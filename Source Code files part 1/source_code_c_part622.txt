
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))


        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

            // We're done -- the status had better not be pending!
            //
            ASSERTEX(!PEND(Status), pTask);

            
            // Clear ourselves as the secondary task in the adapter object.
            //
            {
                ULONG InitState;
                LOCKOBJ(pAdapter, pSR);
                InitState = FAIL(Status)
                             ? ARPAD_AS_FAILEDACTIVATE
                             : ARPAD_AS_ACTIVATED;
                arpClearSecondaryAdapterTask(pAdapter, pTask, InitState, pSR);
                UNLOCKOBJ(pAdapter, pSR);
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskDeactivateAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for shutting down an IP interface.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/

{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pTask);
    BOOLEAN             fContinueShutdown = FALSE;
    enum
    {
        PEND_ShutdownIF,
        PEND_CloseAdapter
    };
    ENTER("arpTaskDeactivateAdapter", 0xe262e828)


    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pAdapter, pSR);
            arpSetSecondaryAdapterTask(pAdapter, pTask, ARPAD_AS_DEACTIVATING, pSR);
            UNLOCKOBJ(pAdapter, pSR);
            fContinueShutdown = TRUE;

        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case PEND_CloseAdapter:
                {

                    //
                    // The close adapter operation is complete. Free the the
                    // adapter and if there is an unbind context, notify NDIS
                    // of unbind completion.
                    //
                    ASSERTEX(pAdapter->bind.AdapterHandle == NULL, pAdapter);
        
                    Status = (NDIS_STATUS) UserParam;

                    //
                    // free the back up tasks allocated in Task Activate Adapter
                    //
                    
                    arpRemoveBackupTasks (&ArpGlobals,ARP1394_BACKUP_TASKS);

                    // Status of the completed operation can't itself be pending!
                    //
                    
                    ASSERT(Status != NDIS_STATUS_PENDING);
                }
                break;

                case PEND_ShutdownIF:
                {
                    //
                    // Closing the IF is complete, continue with the rest
                    // of the shutdown procedure..
                    //
                    ASSERTEX(pAdapter->pIF == NULL, pAdapter);
                    fContinueShutdown = TRUE;
                }
                break;
            }
        }
        break;


        case  RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

            // Clear the secondary task in the adapter object.
            //
            LOCKOBJ(pAdapter, pSR);
            arpClearSecondaryAdapterTask(pAdapter, pTask, ARPAD_AS_DEACTIVATED, pSR);
            UNLOCKOBJ(pAdapter, pSR);
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)


    if (fContinueShutdown)
    {
        do {
            NDIS_HANDLE NdisAdapterHandle;
    
            LOCKOBJ(pAdapter, pSR);
    
            // If required, shutdown interface...
            //
            if (pAdapter->pIF)
            {
                PARP1394_INTERFACE pIF =  pAdapter->pIF;
                RmTmpReferenceObject(&pIF->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                arpDeinitIf(
                    pIF,
                    pTask,
                    PEND_ShutdownIF,
                    pSR
                    );
                RmTmpDereferenceObject(&pIF->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
    
            ASSERT(pAdapter->pIF == NULL);
    
            NdisAdapterHandle = pAdapter->bind.AdapterHandle;
            pAdapter->bind.AdapterHandle = NULL;
            UNLOCKOBJ(pAdapter, pSR);

            if (NdisAdapterHandle != NULL)
            {
                //
                // Suspend task and call NdisCloseAdapter...
                //
            
                RmSuspendTask(pTask, PEND_CloseAdapter, pSR);
                RM_ASSERT_NOLOCKS(pSR);
                NdisCloseAdapter(
                    &Status,
                    NdisAdapterHandle
                    );
            
                if (Status != NDIS_STATUS_PENDING)
                {
                    ArpNdCloseAdapterComplete(
                            (NDIS_HANDLE)pAdapter,
                            Status
                            );
                }
                Status = NDIS_STATUS_PENDING;
            }
    
        } while (FALSE);
    }

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpPnPReconfigHandler(
    IN PARP1394_ADAPTER             pAdapter,
    IN PNET_PNP_EVENT               pNetPnPEvent
    )
/*++

Routine Description:

    Handle a reconfig message on the specified adapter. If no adapter
    is specified, it is a global parameter that has changed.

Arguments:

    pAdapter        -  Pointer to our adapter structure
    pNetPnPEvent    -  Pointer to reconfig event

Return Value:

    NDIS_STATUS_SUCCESS always, for now.

--*/
{
    ENTER("PnPReconfig", 0x39bae883)
    NDIS_STATUS                             Status;
    RM_DECLARE_STACK_RECORD(sr)

    Status = NDIS_STATUS_FAILURE;
    
    do
    {
        PIP_PNP_RECONFIG_REQUEST        pIpReconfigReq;
        PARP1394_INTERFACE              pIF;
        pIpReconfigReq = (PIP_PNP_RECONFIG_REQUEST)pNetPnPEvent->Buffer;

        OBJLOG2(
            pAdapter,
            "AtmArpPnPReconfig: pIpReconfig 0x%x, arpConfigOffset 0x%x\n",
            pIpReconfigReq,
            pIpReconfigReq->arpConfigOffset
            );

        if(pIpReconfigReq->arpConfigOffset == 0)
        {
            // Invalid structure.
            //
            ASSERT(!"Invalid pIpReconfigReq");
            break;
        }

        //
        // Since we support only one IF per adapter, and it's extra work
        // to verify the string, we completely ignore the contents
        // of the pnp event, and instead just start reconfiguration on the 
        // SINGLE IF associated with pAdapter.
        //
        LOCKOBJ(pAdapter, &sr);
        pIF = pAdapter->pIF;
        if (pIF != NULL)
        {
            RmTmpReferenceObject(&pIF->Hdr, &sr);
        }
        UNLOCKOBJ(pAdapter, &sr);

        if (pIF == NULL) break;

        //
        // We've found the IF this reconfig request applies to. Let's
        // start reconfiguration on this IF...
        //

        Status = arpTryReconfigureIf(pIF, pNetPnPEvent, &sr);

        RmTmpDereferenceObject(&pIF->Hdr, &sr);

    } while (FALSE);


    return Status;
}


PRM_OBJECT_HEADER
arpAdapterCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARP1394_ADAPTER.

Arguments:

    pParentObject   - Object that is to be the parent of the adapter.
    pCreateParams   - Actually a pointer to a ARP1394_BIND_PARAMS structure,
                      which contains information required to create the adapter.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ARP1394_ADAPTER * pA;
    ARP1394_BIND_PARAMS *pBindParams = (ARP1394_BIND_PARAMS*) pCreateParams;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    ENTER("arpAdapterCreate", 0xaa25c606)

    ARP_ALLOCSTRUCT(pA, MTAG_ADAPTER);

    do
    {


        if (pA == NULL)
        {
            break;
        }

        ARP_ZEROSTRUCT(pA);

        // Create up-cased version of the DeviceName and save it.
        //
        // WARNING: On MILLEN, this is actually an ANSI string. However,
        // arpCopyUnicodeString works fine even if it's an ANSI string.
        //
        Status = arpCopyUnicodeString(
                            &(pA->bind.DeviceName),
                            pBindParams->pDeviceName,
                            TRUE                        // Upcase
                            );

        if (FAIL(Status))
        {
            pA->bind.DeviceName.Buffer=NULL; // so we don't try to free it later
            break;
        }

        //
        // Determine if we're being created in Ethernet Emulation ("Bridge") mode
        //  We're created in bridge mode if the BindContext is NULL.
        //
        if (pBindParams->BindContext != NULL)
        {
            //
            // NOTE: We ONLY  read configuration if we're operation in
            // normal (Not BRIDGE) mode.
            //

            Status = arpCopyUnicodeString(
                                &(pA->bind.ConfigName),
                                pBindParams->pArpConfigName,
                                FALSE                       // Don't upcase
                                );
    
            if (FAIL(Status))
            {
                pA->bind.ConfigName.Buffer=NULL; // so we don't try to free it later
                break;
            }
        }

        pA->bind.BindContext = pBindParams->BindContext;
        pA->bind.IpConfigHandle = pBindParams->IpConfigHandle;

        RmInitializeLock(
            &pA->Lock,
            LOCKLEVEL_ADAPTER
            );

        RmInitializeHeader(
            pParentObject,
            &pA->Hdr,
            MTAG_ADAPTER,
            &pA->Lock,
            &ArpGlobals_AdapterStaticInfo,
            NULL,
            psr
            );

        if (pBindParams->BindContext == NULL)
        {
            TR_WARN(("pAdapter 0x%p created in BRIDGE mode!\n", pA));
            ARP_ENABLE_BRIDGE(pA);
        }

    }
    while(FALSE);

    if (FAIL(Status))
    {
        if (pA != NULL)
        {
            arpAdapterDelete ((PRM_OBJECT_HEADER) pA, psr);
            pA = NULL;
        }
    }

    EXIT()
    return (PRM_OBJECT_HEADER) pA;
}


NDIS_STATUS
arpTryReconfigureIf(
    PARP1394_INTERFACE pIF,             // NOLOCKIN NOLOCKOUT
    PNET_PNP_EVENT pNetPnPEvent,        // OPTIONAL
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Try to start reconfiguration of the specified IF.

    Some special cases:
    - If the IF is currently being shutdown, we will synchronously succeed. Why?
      Because we don't need to do anything more and it's not an error condition.
    - If the IF is currently being started, we (asychronously) wait until
      the starting is complete, then shut it down and restart it.
    - If the IF is currently UP, we shut it down and restart it.

Arguments:

    pIF             - The interface to be shutdown/restarted. 
    pNetPnPEvent    - OPTIONAL Ndis pnp event to be completed when the
                      reconfiguration operation is over. This is optional because
                      this function can also be called from elsewhere, in particular,
                      from the ioctl admin utility.

Return Value:

    NDIS_STATUS_SUCCESS -- on synchronous success.
    NDIS_STATUS_FAILURE -- on synchronous failure.
    NDIS_STATUS_PENDING -- if completion is going to happen asynchronously.

--*/
{
    NDIS_STATUS Status;
    PRM_TASK    pTask;
    ENTER("arpTryReconfigureIf", 0x65a0bb61)
    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        if (CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_DEINITING)
            || CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_DEINITED))
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        LOCKOBJ(pIF, pSR);
    
        UNLOCKOBJ(pIF, pSR);
    
        Status = arpAllocateTask(
                    &pIF->Hdr,                  // pParentObject,
                    arpTaskReinitInterface, // pfnHandler,
                    0,                          // Timeout,
                    "Task: DeactivateInterface(reconfig)",// szDescription
                    &pTask,
                    pSR
                    );
    
        if (FAIL(Status))
        {
            OBJLOG0(pIF, ("Couldn't alloc reinit IF task!\n"));
        }
        else
        {
            // Save away pNetPnPEvent in the task structure and start the task.
            //
            PTASK_REINIT_IF pReinitTask =  (PTASK_REINIT_IF) pTask;
            ASSERT(sizeof(*pReinitTask)<=sizeof(ARP1394_TASK));
            pReinitTask->pNetPnPEvent = pNetPnPEvent;

            (void)RmStartTask(pTask, 0, pSR);
            Status = NDIS_STATUS_PENDING;
        }

    } while (FALSE);

    EXIT()
    return Status;
}


NDIS_STATUS
arpPrepareAndSendNdisRequest(
    IN  PARP1394_ADAPTER            pAdapter,
    IN  PARP_NDIS_REQUEST           pArpNdisRequest,
    IN  PRM_TASK                    pTask,              // OPTIONAL
    IN  UINT                        PendCode,
    IN  NDIS_OID                    Oid,
    IN  PVOID                       pBuffer,
    IN  ULONG                       BufferLength,
    IN  NDIS_REQUEST_TYPE           RequestType,
    IN  PRM_STACK_RECORD            pSR
)
/*++

Routine Description:

    Send an NDIS Request to query an adapter for information.
    If the request pends, block on the ATMARP Adapter structure
    till it completes.

Arguments:

    pAdapter                - Points to ATMARP Adapter structure
    pNdisRequest            - Pointer to UNITIALIZED NDIS request structure
    pTask                   - OPTIONAL Task. If NULL, we block until the operation
                              completes.
    PendCode                - PendCode to suspend pTask
    Oid                     - OID to be passed in the request
    pBuffer                 - place for value(s)
    BufferLength            - length of above

Return Value:

    The NDIS status of the request.

--*/
{
    NDIS_STATUS         Status;
    PNDIS_REQUEST       pNdisRequest = &pArpNdisRequest->Request;

    ARP_ZEROSTRUCT(pArpNdisRequest);

    //
    //  Fill in the NDIS Request structure
    //
    if (RequestType == NdisRequestQueryInformation)
    {
        pNdisRequest->RequestType = NdisRequestQueryInformation;
        pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
        pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
        pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
        pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
        pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
    }
    else
    {
        ASSERT(RequestType == NdisRequestSetInformation);
        pNdisRequest->RequestType = NdisRequestSetInformation;
        pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
        pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
        pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
        pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
        pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = BufferLength;
    }

    if (pTask == NULL)
    {
        // We might potentially wait.
        //
        ASSERT_PASSIVE();

        NdisInitializeEvent(&pArpNdisRequest->Event);
        NdisRequest(
            &Status,
            pAdapter->bind.AdapterHandle,
            pNdisRequest
            );
        if (PEND(Status))
        {
            NdisWaitEvent(&pArpNdisRequest->Event, 0);
            Status = pArpNdisRequest->Status;
        }

    }
    else
    {
        pArpNdisRequest->pTask = pTask;
        RmSuspendTask(pTask, PendCode, pSR);
        NdisRequest(
            &Status,
            pAdapter->bind.AdapterHandle,
            pNdisRequest
            );
        if (!PEND(Status))
        {
            RmUnsuspendTask(pTask, pSR);
        }
    }

    return Status;
}


ENetAddr 
arpGetSecondaryMacAddress (
    IN ENetAddr  EthernetMacAddress
    )
/*++

    When we are in the bridge mode, we pretend that there is 
    only one other Ethernet Card out there on the net. Therefore
    only one Ethernet Address needs to be generated.

    For now we simply add one to the Local Adapter's Ethernet 
    address and generate it
 
--*/
{
    ENetAddr NewAddress = EthernetMacAddress; // copy

    //
    // randomize the returned Mac Address
    // by xor ing the address with a random 
    // 0x0d3070b17715 (a random number)
    //
    NewAddress.addr[0] ^= 0x00;
    NewAddress.addr[1] ^= 0x2f;
    NewAddress.addr[2] ^= 0x61;
    NewAddress.addr[3] ^= 0x7c;
    NewAddress.addr[4] ^= 0x91;
    NewAddress.addr[5] ^= 0x30;
    

    // Set the locally administered bit 
    // and clear the multicast bit.
    NewAddress.addr[0] &= 0x20;

    
    return NewAddress;

}


NDIS_STATUS
arpGetEuidTopology (
    IN PARP1394_ADAPTER pAdapter,
    IN PRM_STACK_RECORD pSR
    )
/*++

	Queues A workitem to get the EuidTopology
 
--*/
{
    ENTER ("arpGetEuidTopology ",0x97a0abcb)
    PARP1394_WORK_ITEM pWorkItem = NULL;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fQueueWorkItem = FALSE;


    do
    {
        if (pAdapter->fQueryAddress == TRUE)
        {
            break;
        }


        LOCKOBJ (pAdapter, pSR);
        
        if (pAdapter->fQueryAddress == FALSE)
        {
            pAdapter->fQueryAddress = TRUE; 
            fQueueWorkItem  = TRUE;
        }
        else
        {
            fQueueWorkItem  = FALSE;
        }
        
        UNLOCKOBJ(pAdapter, pSR);

        if (fQueueWorkItem == FALSE)
        {
            break;
        }
        
        Status   = ARP_ALLOCSTRUCT(pWorkItem, MTAG_ARP_GENERIC); 

        if (Status != NDIS_STATUS_SUCCESS || pWorkItem == NULL)
        {
            pWorkItem = NULL;
            break;
        }

        arpQueueWorkItem (pWorkItem,
                            arpGetEuidTopologyWorkItem,
                            &pAdapter->Hdr,
                            pSR);

    } while (FALSE); 


    EXIT()
    return Status;

}


VOID
arpQueueWorkItem (
    PARP1394_WORK_ITEM pWorkItem,
    ARP_WORK_ITEM_PROC pFunc,
    PRM_OBJECT_HEADER pHdr,
    PRM_STACK_RECORD pSR
    )
/*++

    Sends a request to get the bus topology . Only used in bridge mode
    For now only Adapter's are passed in as pHdr

--*/
{
    ENTER("arpQueueWorkItem",0xa1de6752)
    PNDIS_WORK_ITEM         pNdisWorkItem = &pWorkItem->u.NdisWorkItem;
    PARP1394_ADAPTER        pAdapter = (PARP1394_ADAPTER)pHdr;
    BOOLEAN                 fStartWorkItem = FALSE;

    LOCKOBJ(pAdapter, pSR);
    
    if (CHECK_AD_PRIMARY_STATE(pAdapter, ARPAD_PS_INITED ) == TRUE)
    {

        
        #if RM_EXTRA_CHECKING

            RM_DECLARE_STACK_RECORD(sr)

            RmLinkToExternalEx(
                pHdr,                            // pHdr
                0x5a2fd7ca,                             // LUID
                (UINT_PTR)pWorkItem,                    // External entity
                ARPASSOC_WORK_ITEM,           // AssocID
                "		Outstanding WorkItem",
                &sr
                );

        #else   // !RM_EXTRA_CHECKING

            RmLinkToExternalFast(pHdr);

        #endif // !RM_EXTRA_CHECKING

        fStartWorkItem  = TRUE;
        
    }

    UNLOCKOBJ(pAdapter, pSR);

    if (fStartWorkItem == TRUE)
    {
        NdisInitializeWorkItem ( pNdisWorkItem ,arpGenericWorkItem, pHdr);

        pWorkItem->pFunc = pFunc;

        NdisScheduleWorkItem(pNdisWorkItem );
    }

    EXIT()
}

VOID    
arpGenericWorkItem(
    struct _NDIS_WORK_ITEM * pWorkItem, 
    PVOID pContext
    )
/*++

    Generic workitem finction. Takes care of the reference on the pObj
     
--*/
{
    PARP1394_WORK_ITEM pArpWorkItem = (ARP1394_WORK_ITEM*)pWorkItem;
    PRM_OBJECT_HEADER pObj = (PRM_OBJECT_HEADER)pContext;
    RM_DECLARE_STACK_RECORD(sr)

    pArpWorkItem->pFunc (pArpWorkItem, pObj, &sr);

#if RM_EXTRA_CHECKING
    {

        RmUnlinkFromExternalEx(pObj,
                                0x548c9d54,
                                (UINT_PTR)pWorkItem,
                                ARPASSOC_WORK_ITEM,
                                &sr
                                );
    }
#else

    RmUnlinkFromExternalFast(pObj);

#endif

}


NDIS_STATUS
arpGetEuidTopologyWorkItem(
    struct _ARP1394_WORK_ITEM* pWorkItem, 
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD pSR
    )
    
/*++

    workitem to get the topology of the bus .. The WorkItem structure can be null;

--*/
{
    PARP1394_ADAPTER    pAdapter = (PARP1394_ADAPTER)pObj;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    ARP_NDIS_REQUEST    ArpRequest;
    EUID_TOPOLOGY       EuidTopology;
    

    //
    // Return if the adapter is not active
    //
    if (CHECK_AD_PRIMARY_STATE(pAdapter, ARPAD_PS_DEINITING ) ==TRUE)
    {
        ASSERT (CHECK_AD_PRIMARY_STATE(pAdapter, ARPAD_PS_DEINITING ) ==FALSE);
        return NDIS_STATUS_FAILURE; // early return
    }

    //
    // Initialize the structures
    // 
    ARP_ZEROSTRUCT(&ArpRequest);
    ARP_ZEROSTRUCT(&EuidTopology);

    
    //Send the request down
    //
    Status  = \
        arpPrepareAndSendNdisRequest(pAdapter, 
                                    &ArpRequest,  
                                    NULL, //IN PRM_TASK pTask, 
                                    0,   //IN UINT PendCode, 
                                    OID_1394_QUERY_EUID_NODE_MAP,
                                    &EuidTopology,
                                    sizeof (EuidTopology),
                                    NdisRequestQueryInformation ,
                                    pSR
                                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        NdisMoveMemory (&pAdapter->EuidMap, &EuidTopology, sizeof (pAdapter->EuidMap));
    }

    pAdapter->fQueryAddress = FALSE; 

    return Status;
}


VOID
arpNdProcessBusReset(
    IN   PARP1394_ADAPTER pAdapter
    )
/*++

    If the adapter is in the Bridge mode, it will query the 
    adapter for the bus topology	 

--*/
{
    ENTER("arpNdProcessBusReset ",0x48e7659a)
    BOOLEAN BridgeEnabled = ARP_BRIDGE_ENABLED(pAdapter);
    RM_DECLARE_STACK_RECORD(SR)

    if (BridgeEnabled == TRUE)
    {
        arpGetEuidTopology (pAdapter, &SR);
    }


    EXIT()
}


VOID
arpRemoveBackupTasks (
    IN ARP1394_GLOBALS* pGlobals,
    UINT Num
     )
/*++

Removes Num tasks to be used as a backup. However, the number is only a 
approximate value as the back up tasks could be in use

--*/
{
    PSLIST_HEADER pListHead = &pGlobals->BackupTasks;
    PNDIS_SPIN_LOCK  pLock = &pGlobals->BackupTaskLock; 

    UINT i=0;

    for (i = 0;i <Num;i++)
    {
        PSLIST_ENTRY pEntry;
        pEntry = NdisInterlockedPopEntrySList(pListHead, pLock );
        
        if (pEntry != NULL)
        {
            TASK_BACKUP* pTask;
            ARP1394_TASK *pATask;

            pTask = CONTAINING_RECORD (pEntry, TASK_BACKUP,  List);

            pATask = (ARP1394_TASK*)pTask;

            ARP_FREE (pATask);
            
            pGlobals->NumTasks --;
        }

        
    }  
    
}


VOID
arpAddBackupTasks (
    IN ARP1394_GLOBALS* pGlobals,
    UINT Num
    )
/*++

Adds Num tasks to be used as a backup.
We are modifying pGlobals without holding the lock

--*/
{
    PSLIST_HEADER pListHead = &pGlobals->BackupTasks;
    PNDIS_SPIN_LOCK  pLock = &pGlobals->BackupTaskLock; 

    UINT i=0;
    
    for (i = 0;i <Num;i++)
    {
        ARP1394_TASK *pATask=NULL;
        
        ARP_ALLOCSTRUCT(pATask, MTAG_TASK); // TODO use lookaside lists.


        if (pATask != NULL)
        {
            NdisInterlockedPushEntrySList(pListHead,&pATask->Backup.List, pLock);
            pGlobals->NumTasks ++;
        }
    }



}


VOID
arpAllocateBackupTasks (
    ARP1394_GLOBALS*                pGlobals 
    )
/*++

    Allocates 4 Tasks to be used as a backup in lowmem conditions

--*/

{
    PSLIST_HEADER pListHead = &pGlobals->BackupTasks;
    PNDIS_SPIN_LOCK  pLock = &pGlobals->BackupTaskLock; 
    
    NdisInitializeSListHead (pListHead);
    NdisAllocateSpinLock(pLock);

    arpAddBackupTasks (pGlobals, 4);

}    


VOID
arpFreeBackupTasks (
    ARP1394_GLOBALS*                pGlobals 
    )

/*++

    Free all the backup tasks hanging off the adapter object

    Since this is only called from the Unload handler, the code 
    presumes that all tasks are complete

    We are modifying pGlobals without holding a lock

--*/

{
    PSLIST_HEADER pListHead = &pGlobals->BackupTasks;
    PNDIS_SPIN_LOCK pLock = &pGlobals->BackupTaskLock; 

    PSLIST_ENTRY pEntry = NULL; 

    
    do 
    {
       
        pEntry = NdisInterlockedPopEntrySList(pListHead, pLock );
        
        if (pEntry != NULL)
        {
            TASK_BACKUP* pTask;
            ARP1394_TASK *pATask;

            pTask = CONTAINING_RECORD (pEntry, TASK_BACKUP,  List);

            pATask = (ARP1394_TASK*)pTask;

            ARP_FREE (pATask);
            
            pGlobals->NumTasks --;
        }

    }  while (pEntry != NULL);

    
    ASSERT (pGlobals->NumTasks == 0);
        
}


ARP1394_TASK *
arpGetBackupTask (
    ARP1394_GLOBALS*                pGlobals 
    )
/*++

    Removes a task from the Back up task list and returns it
    
--*/
    
{
    PSLIST_HEADER pListHead = &pGlobals->BackupTasks;
    PNDIS_SPIN_LOCK pLock = &pGlobals->BackupTaskLock; 
    PSLIST_ENTRY pEntry = NULL; 
    TASK_BACKUP* pTask = NULL;

    pEntry = NdisInterlockedPopEntrySList(pListHead, pLock);

    if (pEntry != NULL)
    {
        pTask = CONTAINING_RECORD (pEntry, TASK_BACKUP,  List);

        NdisZeroMemory ( pTask, sizeof (ARP1394_TASK));
        
        MARK_TASK_AS_BACKUP(&pTask->Hdr);
    }

    return  (ARP1394_TASK*)pTask;       


}




VOID
arpReturnBackupTask (
    IN ARP1394_TASK* pTask
    )
//
// We can always return the task to the Slist because we are gauranteed that it 
// will be present until all the interfaces are unloaded.
//
{

    // re-insert the task
    PSLIST_HEADER pListHead = &ArpGlobals.BackupTasks;
    PNDIS_SPIN_LOCK pLock = &ArpGlobals.BackupTaskLock; 
    PTASK_BACKUP pBkTask = (PTASK_BACKUP ) pTask;

    NdisInterlockedPushEntrySList(pListHead, &pBkTask->List, pLock);
    

}



NDIS_STATUS
arpTaskCloseCallLowPower(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    This function will close all the open VCs. 
    This will allow the 1394 miniport to power down without any problem

    It will also have to close the Address Families. 

    This function will also have to return synchronously. 

--*/
{
    ENTER("arpTaskLowPower", 0x922f875b)

    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    PARPCB_DEST         pDest = (ARPCB_DEST*)RM_PARENT_OBJECT(pTask);
    TASK_SET_POWER_CALL *pCloseCallTask =  (TASK_SET_POWER_CALL *) pTask;

    enum
    {
        PEND_CleanupVcComplete,
    };
    switch(Code)
    {
        case RM_TASKOP_START:
        {
            
            LOCKOBJ(pDest,pSR);
            if (arpNeedToCleanupDestVc(pDest))
            {
                PRM_TASK pCleanupCallTask = pDest->VcHdr.pCleanupCallTask;

                // If there is already an official cleanup-vc task, we pend on it.
                // Other wise we allocate our own, pend on it, and start it.
                //
                if (pCleanupCallTask != NULL)
                {
                    TR_WARN((
                        "Cleanup-vc task %p exists; pending on it.\n",
                         pCleanupCallTask));
                    RmTmpReferenceObject(&pCleanupCallTask->Hdr, pSR);
    
                    UNLOCKOBJ(pDest, pSR);
                    RmPendTaskOnOtherTask(
                        pTask,
                        PEND_CleanupVcComplete,
                        pCleanupCallTask,
                        pSR
                        );

                    RmTmpDereferenceObject(&pCleanupCallTask->Hdr, pSR);
                    Status = NDIS_STATUS_PENDING;
                    break;
                }
                else
                {
                    //
                    // Start the call cleanup task and pend on int.
                    //

                    UNLOCKOBJ(pDest, pSR);
                    RM_ASSERT_NOLOCKS(pSR);

                    Status = arpAllocateTask(
                                &pDest->Hdr,                // pParentObject,
                                arpTaskCleanupCallToDest,   // pfnHandler,
                                0,                          // Timeout,
                                "Task: CleanupCall on UnloadDest",  // szDescription
                                &pCleanupCallTask,
                                pSR
                                );
                
                    if (FAIL(Status))
                    {
                        TR_WARN(("FATAL: couldn't alloc cleanup call task!\n"));
                    }
                    else
                    {
                        RmPendTaskOnOtherTask(
                            pTask,
                            PEND_CleanupVcComplete,
                            pCleanupCallTask,               // task to pend on
                            pSR
                            );
                
                        // RmStartTask uses up the tmpref on the task
                        // which was added by arpAllocateTask.
                        //
                        Status = RmStartTask(
                                    pCleanupCallTask,
                                    0, // UserParam (unused)
                                    pSR
                                    );
                    }
                    break;
                }
            }

            //
            // We're here because there is no async unload work to be done.
            // We simply return and finish synchronous cleanup in the END
            // handler for this task.
            //
            Status = NDIS_STATUS_SUCCESS;
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case PEND_CleanupVcComplete:
                {
                    //
                    // There was vc-cleanup to be done, but how it's
                    // complete. We should be able to synchronously clean up
                    // this task now
                    //

                #if DBG
                    LOCKOBJ(pDest, pSR);

                    ASSERTEX(!arpNeedToCleanupDestVc(pDest), pDest);

                    UNLOCKOBJ(pDest, pSR);
                #endif DBG

                    Status      = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;


            }
        }
        break;

        case RM_TASKOP_END:
        {
            ULONG DestRemaining;
            PCALL_COUNT  pCount = pCloseCallTask->pCount;

            ASSERT (pCount != NULL);
            
            if (SetLowPower == pCloseCallTask->Cause )
            {
                DestRemaining = NdisInterlockedDecrement (&pCount->DestCount);
            
                if ( 0 == DestRemaining )
                {
                    NdisSetEvent (&pCount ->VcEvent);    
                }
            }            
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()


    return Status;

}



INT
arpCloseAllVcOnDest(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
/*++


--*/
{
    ENTER ("arpCloseAllVcOnDest", 0xf19a83d5)

    PARPCB_DEST             pDest = (PARPCB_DEST) pHdr;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    PTASK_SET_POWER_CALL    pTask = NULL;
    PCALL_COUNT             pCloseCall = (PCALL_COUNT) pvContext;

    
    do
    {
        NdisInterlockedIncrement(&pCloseCall->DestCount);
        
        Status = arpAllocateTask(
                    &pDest->Hdr,                  // pParentObject,
                    arpTaskCloseCallLowPower, // pfnHandler,
                    0,                          // Timeout,
                    "Task: Set Power Cleanup VC", // szDescrip.
                    &(PRM_TASK)pTask,
                    pSR
                    );

        if (Status != NDIS_STATUS_SUCCESS || pTask == NULL)
        {
            pTask = NULL;              
            break;
        }

        pTask->Cause = SetLowPower;

        pTask->pCount = pCloseCall;

        
        RmStartTask((PRM_TASK)pTask, 0,pSR);
                    
    
    } while (FALSE);    

    if (Status != NDIS_STATUS_SUCCESS)
    {
        ULONG DestRemaining;

        DestRemaining = NdisInterlockedDecrement (&pCloseCall->DestCount);
        
        if ( 0 == DestRemaining )
        {
            NdisSetEvent (&pCloseCall->VcEvent);    
        }
            
    }

    return TRUE; // continue to enumerate
}


VOID
arpLowPowerCloseAllCalls (
    ARP1394_INTERFACE *pIF,
    PRM_STACK_RECORD pSR
    )
{

    CALL_COUNT CloseCallCount;

    //
    // The Dest Count will be used to make sure that this thread waits for 
    // all the Close Calls to complete.
    //
    NdisInitializeEvent (&CloseCallCount.VcEvent);
    CloseCallCount.DestCount= 0;

    //
    // First we go through all the Dests and close calls on them
    //
    RmWeakEnumerateObjectsInGroup(&pIF->DestinationGroup,
                                  arpCloseAllVcOnDest,
                                  &CloseCallCount,
                                  pSR);

    if (CloseCallCount.DestCount != 0)
    {
        NdisWaitEvent (&CloseCallCount.VcEvent, 0);
    }
    return;

}



NDIS_STATUS
arpTaskCloseVcAndAF (
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    This task does the work that is common between SetLowPower and and 
    the Resume failure case

    As its name suggests, it simply closes all the VCs and Af.

    Its parent task is either a shutdown task or a Set Power task. 
    As the 2 parents of this task are serialized w.r.t each other, 
    there is no need for any serialization within this task.


Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused
--*/
{

    ENTER("arpTaskCloseVcAndAF ", 0xc7c9ad6b)

    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER*    pAdapter = (ARP1394_ADAPTER*)RM_PARENT_OBJECT(pTask);
    TASK_POWER        * pTaskPower =  (TASK_POWER*) pTask;
    ARP1394_INTERFACE * pIF = pAdapter->pIF;
    ULONG               Stage;

    enum
    {
        STAGE_Start,            
        STAGE_StopMaintenanceTask,
        STAGE_CleanupVcComplete,
        STAGE_CloseDestinationGroup,
        STAGE_SwitchedToPassive,
        STAGE_CloseAF,
        STAGE_End
    };
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_Start;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    switch(Stage)
    {
        case STAGE_Start:
        {

            //
            // Stop the IF maintenance task if it's running.
            //
            Status =  arpTryStopIfMaintenanceTask(
                            pIF,
                            pTask,
                            STAGE_StopMaintenanceTask,
                            pSR
                            );

            if (PEND(Status)) break;

        }
        // FALL THROUGH 
        
        case STAGE_StopMaintenanceTask:
        {
            LOCKOBJ(pIF, pSR);

            TIMESTAMP("===CloseVC and AF:MaintenanceTask stopped");
            // Unlink the explicit reference of the broadcast channel destination
            // from the interface.
            //
            if (pIF->pBroadcastDest != NULL)
            {
                PARPCB_DEST pBroadcastDest = pIF->pBroadcastDest;
                pIF->pBroadcastDest = NULL;
    
                // NOTE: We're unlinking the two with the IF lock (which is
                // is the same as the pBroadcastDest's lock) held.
                // This is OK to do.
                //
    
            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pIF->Hdr,
                    &pBroadcastDest->Hdr,
                    0x66bda49b,
                    ARPASSOC_LINK_IF_OF_BCDEST,
                    ARPASSOC_LINK_BCDEST_OF_IF,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pIF->Hdr, &pBroadcastDest->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING
    
            }

            //
            // If the VC state needs cleaning up, we need to get a task
            // going to clean it up. Other wise we fake the completion of this
            // stage so that we move on to the next...
            //
            if (pIF->recvinfo.VcHdr.NdisVcHandle == NULL)
            {
                UNLOCKOBJ(pIF, pSR);
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                PRM_TASK pCleanupCallTask = pIF->recvinfo.VcHdr.pCleanupCallTask;


                // If there is already an official cleanup-vc task, we pend on it.
                // Other wise we allocate our own, pend on it, and start it.
                //
                if (pCleanupCallTask != NULL)
                {
                    TR_WARN((
                        "IF %p Cleanup-vc task %p exists; pending on it.\n",
                         pIF,
                         pCleanupCallTask));
                    RmTmpReferenceObject(&pCleanupCallTask->Hdr, pSR);
    
                    UNLOCKOBJ(pIF, pSR);
                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_CleanupVcComplete,
                        pCleanupCallTask,
                        pSR
                        );

                    RmTmpDereferenceObject(&pCleanupCallTask->Hdr, pSR);
                    Status = NDIS_STATUS_PENDING;
                }
                else
                {
                    //
                    // Start the call cleanup task and pend on int.
                    //
                    UNLOCKOBJ(pIF, pSR);

                    Status = arpAllocateTask(
                                &pIF->Hdr,                  // pParentObject,
                                arpTaskCleanupRecvFifoCall, // pfnHandler,
                                0,                          // Timeout,
                                "Task: CleanupRecvFifo on Set LowPower ", // szDescrip.
                                &pCleanupCallTask,
                                pSR
                                );
                

                    if (FAIL(Status))
                    {
                        // Couldn't allocate task.
                        //
                        TR_WARN(("FATAL: couldn't alloc cleanup call task!\n"));
                    }
                    else
                    {
                        Status = RmPendTaskOnOtherTask(
                                    pTask,
                                    STAGE_CleanupVcComplete,
                                    pCleanupCallTask,
                                    pSR
                                    );
                        ASSERT(!FAIL(Status));
                
                        // RmStartTask uses up the tmpref on the task
                        // which was added by arpAllocateTask.
                        //
                        Status = RmStartTask(
                                    pCleanupCallTask,
                                    0, // UserParam (unused)
                                    pSR
                                    );
                        // We rely on pending status to decide whether
                        // or not to fall through to the next stage.
                        //
                        Status = NDIS_STATUS_PENDING;
                    }
                }
            }
        }

        if (PEND(Status)) break;

        // FALL THROUGH 

        case STAGE_CleanupVcComplete:
        {
            TIMESTAMP("===Set LowPower:RecvFifo cleanup complete");
            // Initiate unload of all the items in the DestinationGroup.
            //
            // If we are going to low power state, then close all the VC's 
            // on these Destinations
            //
            
            arpLowPowerCloseAllCalls (pIF, pSR);

            //
            // Unlink the special "destination VCs". This is executed on both 
            // Low power and unbind.
            //
            LOCKOBJ(pIF, pSR);

            TIMESTAMP("===Set LowPower:Destination objects cleaned up.");
            if (pIF->pMultiChannelDest != NULL)
            {
                PARPCB_DEST pMultiChannelDest = pIF->pMultiChannelDest;
                pIF->pMultiChannelDest = NULL;
    
                // NOTE: We're unlinking the two with the IF lock (which is
                // is the same as the pBroadcastDest's lock) held.
                // This is OK to do.
                //
    
            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pIF->Hdr,
                    &pMultiChannelDest->Hdr,
                    0xf28090bd,
                    ARPASSOC_LINK_IF_OF_MCDEST,
                    ARPASSOC_LINK_MCDEST_OF_IF,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pIF->Hdr, &pMultiChannelDest->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING
    
            }

            if (pIF->pEthernetDest != NULL)
            {
                PARPCB_DEST pEthernetDest = pIF->pEthernetDest;
                pIF->pEthernetDest = NULL;
    
                // NOTE: We're unlinking the two with the IF lock (which is
                // is the same as the pBroadcastDest's lock) held.
                // This is OK to do.
                //
    
            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pIF->Hdr,
                    &pEthernetDest->Hdr,
                    0xf8eedcd1,
                    ARPASSOC_LINK_IF_OF_ETHDEST,
                    ARPASSOC_LINK_ETHDEST_OF_IF,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pIF->Hdr, &pEthernetDest->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING
    
            }

            UNLOCKOBJ(pIF, pSR);

            // If required, switch to passive. This check should obviously be done
            // without any locks held!
            if (!ARP_ATPASSIVE())
            {
                // We're not at passive level, but we need to be.. 
                // . So we switch to passive...
                //
                RmSuspendTask(pTask, STAGE_SwitchedToPassive, pSR);
                RmResumeTaskAsync(pTask, 0, &pTaskPower->WorkItem, pSR);
                Status = NDIS_STATUS_PENDING;
            }
            else
            {
                Status = NDIS_STATUS_SUCCESS;
            }
        }

        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_SwitchedToPassive:
        {
            NDIS_HANDLE NdisAfHandle;

            // We're now switched to passive
            //
            ASSERT(ARP_ATPASSIVE());

            //
            // We're done with all VCs, etc. Time to close the AF, if it's open.
            //

            LOCKOBJ(pTask, pSR);
            NdisAfHandle = pIF->ndis.AfHandle;
            pIF->ndis.AfHandle = NULL;
            pAdapter->PoMgmt.bReceivedAf = FALSE;
            UNLOCKOBJ(pTask, pSR);
    
            if (NdisAfHandle == NULL)
            {
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                //
                // (Debug) Delete the association we added when the
                // address family was opened.
                //
                DBG_DELASSOC(
                    &pIF->Hdr,                  // pObject
                    NdisAfHandle,               // Instance1
                    NULL,                       // Instance2
                    ARPASSOC_IF_OPENAF,         // AssociationID
                    pSR
                    );

                //
                // Suspend task and call NdisCloseAdapter...
                //
                pIF->PoMgmt.pAfPendingTask = pTask;
                RmSuspendTask(pTask, STAGE_CloseAF, pSR);
                RM_ASSERT_NOLOCKS(pSR);
                TIMESTAMP("===DeinitIF: Calling NdisClCloseAddressFamily");
                Status = NdisClCloseAddressFamily(
                            NdisAfHandle
                            );
        
                if (Status != NDIS_STATUS_PENDING)
                {
                    ArpCoCloseAfComplete(
                            Status,
                            (NDIS_HANDLE)pIF
                            );
                    Status = NDIS_STATUS_PENDING;
                }
            }
        }
        
        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_CloseAF:
        {

            //
            // The close AF operation is complete.
            // We've not got anything else to do.
            //
            TIMESTAMP("===Set Low Power: Done with CloseAF");

            // Recover the last status ...
            //
            pIF->PoMgmt.pAfPendingTask =NULL;
            
            Status = (NDIS_STATUS) UserParam;

            // Status of the completed operation can't itself be pending!
            //
            ASSERT(Status != NDIS_STATUS_PENDING);

            //
            // By returning Status != pending, we implicitly complete
            // this task.
            //
        }
        break;

        case STAGE_End:
        {
  
            TIMESTAMP("===Set Low Power done: All done!");

            // Force status to be success as a transition to LowPower
            // cannot fail
            //
            Status = NDIS_STATUS_SUCCESS;
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Stage)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()


    return Status;


}

NDIS_STATUS
arpTaskLowPower(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    Task handler responsible for setting an adapter to low power state 
    (but leaving it allocated and linked to the adapter).

    This task will close all the VCs, AF. However it will leave the Interface 
    registered with IP and will not delete either the RemoteIP or DEST structures.

    This task is a primary Interface task. This task is serialized with the Bind
    , Unbind tasks
    
Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused
--*/
{
    NDIS_STATUS         Status;
    PARP1394_INTERFACE  pIF;
    PTASK_POWER         pTaskPower;
    UINT                Stage;
    PARP1394_ADAPTER    pAdapter;
    enum
    {
        STAGE_Start,
        STAGE_BecomePrimaryTask,
        STAGE_ExistingPrimaryTaskComplete,
        STAGE_CleanupVcAfComplete,
        STAGE_End
    };
    ENTER("arpTaskLowPower", 0x1a34699e)

    Status              = NDIS_STATUS_FAILURE;
    pAdapter            = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pTask);
    pIF                 = pAdapter->pIF;
    pTaskPower          = (PTASK_POWER) pTask;


    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_Start;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    switch(Stage)
    {
        case STAGE_Start:
        {

            // There should NOT be another activate/deactivate task running
            // on this interface. We fail the SetPower if we receive it in 
            // while we are activating or deactivating the task
            //
            TIMESTAMP("===Set Power Low Starting");

            if (pIF->pActDeactTask != NULL || 
                (CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_INITED) != TRUE))
            {
                UNLOCKOBJ(pIF, pSR);
                *pTaskPower->pStatus = NDIS_STATUS_NOT_SUPPORTED;
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            
            // FALL THROUGH            
        }
        
        case STAGE_BecomePrimaryTask:
        {
            //
            // Next, we try and set ourselves as the primary Adapter Task.
            // This ensures that bind,unbind, and Set Power Tasks are all serialized.
            //
            LOCKOBJ(pAdapter, pSR);

            if (pAdapter->bind.pPrimaryTask == NULL)
            {   
                ULONG CurrentInitState = GET_AD_PRIMARY_STATE(pAdapter);

                // Do not change the Init state of the Adapter. However, 
                // mark the adapter as transitioning to a low power state
                //
                pTaskPower->PrevState = CurrentInitState;

                arpSetPrimaryAdapterTask(pAdapter, pTask, CurrentInitState, pSR);

                //
                // Set the Power State to Low Power. This will block all 
                // outstanding sends
                //
                SET_POWER_STATE (pAdapter, ARPAD_POWER_LOW_POWER);
        
                UNLOCKOBJ(pAdapter, pSR);
            }
            else
            {
                PRM_TASK pOtherTask =  pAdapter->bind.pPrimaryTask;
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    STAGE_BecomePrimaryTask, // we'll try again...
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

        }        
        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_ExistingPrimaryTaskComplete:
        {
            PRM_TASK pCloseVCAndAfTask = NULL;
            //
            // Stop the IF maintenance task if it's running.
            //

            Status = arpAllocateTask(
                        &pAdapter->Hdr,                  // pParentObject,
                        arpTaskCloseVcAndAF , // pfnHandler,
                        0,                          // Timeout,
                        "Task: Close VC and AF on SetPower", // szDescrip.
                        &pCloseVCAndAfTask ,
                        pSR
                        );
        

            if (FAIL(Status))
            {
                // Couldn't allocate task.
                //
                TR_WARN(("FATAL: couldn't alloc cleanup call task!\n"));
                break;
            }
            else
            {
                Status = RmPendTaskOnOtherTask(
                            pTask,
                            STAGE_CleanupVcAfComplete,
                            pCloseVCAndAfTask,
                            pSR
                            );
                
                ASSERT(!FAIL(Status));
        
                // RmStartTask uses up the tmpref on the task
                // which was added by arpAllocateTask.
                //
                Status = RmStartTask(
                            pCloseVCAndAfTask,
                            0, // UserParam (unused)
                            pSR
                            );

            }
            if (PEND(Status)) break;

        }
        break;
        
        case STAGE_CleanupVcAfComplete:
        {
        
            //
            // The close AF operation is complete.
            // We've not got anything else to do.
            //
            TIMESTAMP("===Set LowPower: Done with CloseAF");

            // Recover the last status ...
            //
            Status = (NDIS_STATUS) UserParam;

            //
            // Status of the completed operation can't itself be pending!
            //
            ASSERT(Status == NDIS_STATUS_SUCCESS);

            //
            // By returning Status != pending, we implicitly complete
            // this task.
            //
        }
        break;

        case STAGE_End:
        {
            //
            // We are done with all async aspects of setting the Low Power state
            // Set the event so that the original Low Power thread can return.
            //
  
            TIMESTAMP("===Set Low Power done: All done!");

            // Recover the last status ...
            //
            Status = (NDIS_STATUS) UserParam;

            *pTaskPower->pStatus  = Status;


            LOCKOBJ (pAdapter, pSR);
            arpClearPrimaryAdapterTask(pAdapter, pTask, pTaskPower->PrevState ,pSR);
            UNLOCKOBJ (pAdapter, pSR);


            NdisSetEvent (&pAdapter->PoMgmt.Complete);
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Stage)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}





NDIS_STATUS
arpMakeCallOnDest(
    IN  PARPCB_REMOTE_IP            pRemoteIp,
    IN  PARPCB_DEST                 pDest,
    IN  PRM_TASK                    pTaskToPend,
    IN  ULONG                       PEND_StageMakeCallComplete,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    This function will do a make call on a particular task.
    It will also pend pTaskToPend on that make call

--*/
{
    ENTER("arpTaskLowPower", 0x922f875b)

    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;


    do
    {
        if (pRemoteIp->pDest != pDest)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        
            
        if (pDest->VcHdr.pMakeCallTask != NULL )
        {
            //
            // There is an existing task. Pend on it.
            //
            PRM_TASK pOtherTask = pDest->VcHdr.pMakeCallTask;

            RM_DBG_ASSERT_LOCKED(&pRemoteIp->Hdr, pSR);
        
            TR_WARN(("MakeCall task %p exists; pending on it.\n", pOtherTask));
            RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
            DBGMARK(0x0c387a9f);
            UNLOCKOBJ(pRemoteIp, pSR);
            RmPendTaskOnOtherTask(
                pTaskToPend,
                PEND_StageMakeCallComplete,
                pOtherTask,
                pSR
                );
            RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
            Status = NDIS_STATUS_PENDING;
        }
        else
        {
            DBGMARK(0xe9f37ba9);

            //
            // There is no pMakeCallTask. If it makes sense to start one, we do...
            // Note that checking ARP_CAN_SEND_ON_DEST strictly-speaking requires
            // at-least a read-lock on the IF send lock. However, we don't need
            // precision here -- as long as we don't miss making a call when we
            // should (which we won't) we are ok.
            //
            if (!ARP_CAN_SEND_ON_DEST(pDest) && pDest->VcHdr.pCleanupCallTask==NULL)
            {
                PRM_TASK pMakeCallTask;

                //
                // Let's start a MakeCall task and pend on it.
                //
                Status = arpAllocateTask(
                            &pDest->Hdr,                    // pParentObject
                            arpTaskMakeCallToDest,      // pfnHandler
                            0,                              // Timeout
                            "Task: SendFifoMakeCall",       // szDescription
                            &pMakeCallTask,
                            pSR
                            );
                if (FAIL(Status))
                {
                    // Couldn't allocate task. We fail with STATUS_RESOURCES
                    //
                    Status = NDIS_STATUS_RESOURCES;
                }
                else
                {
                    UNLOCKOBJ(pRemoteIp, pSR);

                    RmPendTaskOnOtherTask(
                        pTaskToPend,
                        PEND_StageMakeCallComplete,
                        pMakeCallTask,
                        pSR
                        );
                    
                    (VOID)RmStartTask(
                            pMakeCallTask,
                            0, // UserParam (unused)
                            pSR
                            );
                
                    Status = NDIS_STATUS_PENDING;
                }
            }
            else
            {
                // Calls is ready to do. We finish sending off the packets in
                // the END handler.
                //
                Status = NDIS_STATUS_SUCCESS;
            }
        }
        
    } while (FALSE);
    RmUnlockAll(pSR);


    EXIT()
    return Status;

}






NDIS_STATUS
arpTaskStartGenericVCs (
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    This function will close all the open VCs. 
    This will allow the 1394 miniport to power down without any problem

    It will also have to close the Address Families. 

    This function will also have to return synchronously. 

--*/
{
    ENTER("arpTaskStartGenericVCs", 0x75780ca6)

    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER*    pAdapter = (ARP1394_ADAPTER*)RM_PARENT_OBJECT(pTask);
    TASK_POWER        * pTaskPower =  (TASK_POWER*) pTask;
    ARP1394_INTERFACE * pIF = pAdapter->pIF;

    enum
    {
        PEND_OpenAF,
        PEND_SetupBroadcastChannel,
        PEND_SetupReceiveVc,
        PEND_SetupMultiChannel,
        PEND_SetupEthernetVc,
        PEND_StartedVC            
    };

    
    switch(Code)
    {
        case RM_TASKOP_START:
        {
            CO_ADDRESS_FAMILY AddressFamily;
            //
            // This task is inherently serialized as its parent task is serialized.
            //
            LOCKOBJ (pIF, pSR);

            if (pIF->pActDeactTask != NULL)
            {
                // This should never happen, because the Activate task is
                // always started by an active primary task, and at most one primary
                // task is active at any point of time.
                //
                ASSERTEX(!"start: activate/deactivate task exists!", pIF);
                Status = NDIS_STATUS_FAILURE;
                UNLOCKOBJ(pIF, pSR);
                break;
            }

            UNLOCKOBJ (pIF,pSR);

            //
            // Now Open the Address Family.
            //
            
            NdisZeroMemory(&AddressFamily, sizeof(AddressFamily));
    
            AddressFamily.AddressFamily = CO_ADDRESS_FAMILY_1394;
            AddressFamily.MajorVersion = NIC1394_AF_CURRENT_MAJOR_VERSION;
            AddressFamily.MinorVersion = NIC1394_AF_CURRENT_MINOR_VERSION;

            pIF->PoMgmt.pAfPendingTask = pTask;
            RmSuspendTask(pTask, PEND_OpenAF, pSR);
            RM_ASSERT_NOLOCKS(pSR);
    
            TIMESTAMP("===ActivateIF: Calling NdisClOpenAddressFamily");
            Status = NdisClOpenAddressFamily(
                            pIF->ndis.AdapterHandle,
                            &AddressFamily,
                            (NDIS_HANDLE)pIF,
                            &ArpGlobals.ndis.CC,
                            sizeof(ArpGlobals.ndis.CC),
                            &(pIF->ndis.AfHandle)
                            );
            if (Status != NDIS_STATUS_PENDING)
            {
                ArpCoOpenAfComplete(
                        Status,
                        (NDIS_HANDLE)pIF,
                        pIF->ndis.AfHandle
                        );
            }
            Status = NDIS_STATUS_PENDING;
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            
            pTaskPower->LastStage = (RM_PEND_CODE(pTask));
            Status = (NDIS_STATUS) UserParam;

            switch(RM_PEND_CODE(pTask))
            {
                case PEND_OpenAF:
                {
                    PARPCB_DEST pBroadcastDest;

                    pIF->PoMgmt.pAfPendingTask = NULL;

                    if (FAIL(Status))
                    {
                        // 
                        // OpenAF failed...
                        //
                        break;
                    }

                    //
                    // Successfully opened the address family and waited for
                    // connect status.
                    // Now setup the broadcast channel VC.
                    // 
                    //

                    TR_INFO(("Interface: 0x%p, Got NdisAfHandle: 0x%p\n",
                                    pIF, pIF->ndis.AfHandle));
                    //
                    // Let's create a destination object representing the
                    // broadcast channel, and make a call to it.
                    //
                    Status =  arpSetupSpecialDest(
                                pIF,
                                NIC1394AddressType_Channel, // This means bcast channel.
                                pTask,                      // pParentTask
                                PEND_SetupBroadcastChannel, //  PendCode
                                &pBroadcastDest,
                                pSR
                                );
                    // Should either fail or pend -- never return success.
                    //
                    ASSERT(Status != NDIS_STATUS_SUCCESS);

                    if (!PEND(Status))
                    {
                        OBJLOG0( pIF, "FATAL: Couldn't create BC dest entry.\n");
                    }
                }
                break;

                case PEND_SetupBroadcastChannel:
                {
                    PRM_TASK pMakeCallTask;

                    if (FAIL(Status))
                    {
                        // 
                        // Couldn't setup the broadcast channel...
                        //
                        break;
                    }

                    //
                    // Successfully opened the address family.
                    // Now setup the receive FIFO VC.
                    // 
                    //

                    // TR_INFO(("Interface: 0x%p, Got NdisAfHandle: 0x%p\n",
                    //              pIF, pIF->ndis.AfHandle));
    
                    //
                    // Let's start a MakeCall task and pend on it.
                    //
                    Status = arpAllocateTask(
                                &pIF->Hdr,                  // pParentObject
                                arpTaskMakeRecvFifoCall,        // pfnHandler
                                0,                              // Timeout
                                "Task: MakeRecvFifoCall",       // szDescription
                                &pMakeCallTask,
                                pSR
                                );
                    if (FAIL(Status))
                    {
                        // Couldn't allocate task. Let's do a fake completion of
                        // this stage...
                        //
                        RmSuspendTask(pTask, PEND_SetupReceiveVc, pSR);
                        RmResumeTask(pTask, (UINT_PTR) Status, pSR);
                        Status = NDIS_STATUS_PENDING;
                        break;
                    }
                    else
                    {
                        RmPendTaskOnOtherTask(
                            pTask,
                            PEND_SetupReceiveVc,
                            pMakeCallTask,
                            pSR
                            );
        
                        (VOID)RmStartTask(
                                pMakeCallTask,
                                0, // UserParam (unused)
                                pSR
                                );
                    
                        Status = NDIS_STATUS_PENDING;
                    }
                }
                break;

                case PEND_SetupReceiveVc:
                {
                    PARPCB_DEST pMultiChannelDest;

                    if (FAIL(Status))
                    {
                        TR_WARN(("FATAL: COULDN'T SETUP RECEIVE FIFO VC!\n"));
                        break;
                    }
    
                    //
                    // Let's create a destination object representing the
                    // multichannel vc, and make a call to it.
                    //

                    Status =  arpSetupSpecialDest(
                                pIF,
                                NIC1394AddressType_MultiChannel,
                                pTask,                      // pParentTask
                                PEND_SetupMultiChannel, //  PendCode
                                &pMultiChannelDest,
                                pSR
                                );
                    // Should either fail or pend -- never return success.
                    //
                    ASSERT(Status != NDIS_STATUS_SUCCESS);

                    if (!PEND(Status))
                    {
                        OBJLOG0( pIF, "FATAL: Couldn't create BC dest entry.\n");
                    }
                    else
                    {
                        //
                        // On pending, pMultiChannelDest contains a valid
                        // pDest which has been tmpref'd. 
                        // Keep a pointer to the broadcast dest in the IF.
                        // and  link the broadcast dest to the IF.
                        //
                        {
                        #if RM_EXTRA_CHECKING
                            RmLinkObjectsEx(
                                &pIF->Hdr,
                                &pMultiChannelDest->Hdr,
                                0x34639a4c,
                                ARPASSOC_LINK_IF_OF_MCDEST,
                                "    IF of MultiChannel Dest 0x%p (%s)\n",
                                ARPASSOC_LINK_MCDEST_OF_IF,
                                "    MultiChannel Dest of IF 0x%p (%s)\n",
                                pSR
                                );
                        #else // !RM_EXTRA_CHECKING
                            RmLinkObjects(&pIF->Hdr, &pMultiChannelDest->Hdr,pSR);
                        #endif // !RM_EXTRA_CHECKING

                            LOCKOBJ(pIF, pSR);
                            ASSERT(pIF->pMultiChannelDest == NULL);
                            pIF->pMultiChannelDest = pMultiChannelDest;
                            UNLOCKOBJ(pIF, pSR);

                            // arpSetupSpecialDest ref'd pBroadcastDest.
                            //
                            RmTmpDereferenceObject(&pMultiChannelDest->Hdr, pSR);
                        }
                    }
                }
                break;

                case PEND_SetupMultiChannel:
                {
                    PARPCB_DEST pEthernetDest;

                    if (FAIL(Status))
                    {
                        TR_WARN(("COULDN'T SETUP MULTI-CHANNEL VC (IGNORING FAILURE)!\n"));
                        break;
                    }
    
                    //
                    // Let's create a destination object representing the
                    // ethernet, and make a call to it.
                    //
                    Status =  arpSetupSpecialDest(
                                pIF,
                                NIC1394AddressType_Ethernet,
                                pTask,                      // pParentTask
                                PEND_SetupEthernetVc, //  PendCode
                                &pEthernetDest,
                                pSR
                                );

                    // Should either fail or pend -- never return success.
                    //
                    ASSERT(Status != NDIS_STATUS_SUCCESS);

                    if (!PEND(Status))
                    {
                        OBJLOG0( pIF, "FATAL: Couldn't create BC dest entry.\n");
                    }
                    else
                    {
                        //
                        // On pending, pEthernetDest contains a valid
                        // pDest which has been tmpref'd. 
                        // Keep a pointer to the broadcast dest in the IF.
                        // and  link the broadcast dest to the IF.
                        //
                        {
                        #if RM_EXTRA_CHECKING
                            RmLinkObjectsEx(
                                &pIF->Hdr,
                                &pEthernetDest->Hdr,
                                0xcea46d67,
                                ARPASSOC_LINK_IF_OF_ETHDEST,
                                "    IF of Ethernet Dest 0x%p (%s)\n",
                                ARPASSOC_LINK_ETHDEST_OF_IF,
                                "    Ethernet Dest of IF 0x%p (%s)\n",
                                pSR
                                );
                        #else // !RM_EXTRA_CHECKING
                            RmLinkObjects(&pIF->Hdr, &pEthernetDest->Hdr,pSR);
                        #endif // !RM_EXTRA_CHECKING

                            LOCKOBJ(pIF, pSR);
                            ASSERT(pIF->pEthernetDest == NULL);
                            pIF->pEthernetDest = pEthernetDest;
                            UNLOCKOBJ(pIF, pSR);

                            // arpSetupSpecialDest ref'd pBroadcastDest.
                            //
                            RmTmpDereferenceObject(&pEthernetDest->Hdr, pSR);
                        }
                    }
                }
                break;

                case PEND_SetupEthernetVc:
                {

                    if (FAIL(Status))
                    {
                        TR_WARN(("COULDN'T SETUP ETHERNET VC (IGNORING FAILURE)!\n"));
                        break;
                    }
        
                    if (!ARP_ATPASSIVE())
                    {
                        ASSERT(sizeof(TASK_ACTIVATE_IF)<=sizeof(ARP1394_TASK));

                        // We're not at passive level, but we need to be when we
                        // call IP's add interface. So we switch to passive...
                        // NOTE: we specify completion code PEND_SetupReceiveVc
                        //       because we want to get back here (except
                        //       we'll be at passive).
                        //
                        RmSuspendTask(pTask, PEND_SetupEthernetVc, pSR);
                        RmResumeTaskAsync(
                            pTask,
                            Status,
                            &((TASK_ACTIVATE_IF*)pTask)->WorkItem,
                            pSR
                            );
                        Status = NDIS_STATUS_PENDING;
                        break;
                    }
                        
                    ASSERT(Status == NDIS_STATUS_SUCCESS);

                    //
                    // Successfully opened the address family and setup
                    // the recv VC.

                    if (!FAIL(Status))
                    {
                        //
                        // Start the maintenance task on this IF.
                        //
                        arpStartIfMaintenanceTask(pIF, pSR);
                    }
    
                } // end  case PEND_SetupEthernetVc
                break;

    
                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))
        }
        break;

        case RM_TASKOP_END:
        {
            //
            // Recover the last status ...
            //
            Status = (NDIS_STATUS) UserParam;

            //
            // Status of the completed operation can't itself be pending!
            //
            ASSERT(Status != NDIS_STATUS_PENDING);

        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;
    }

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()


    return Status;

}




NDIS_STATUS
arpTaskOnPower (
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    Validates the event and passes it off to the correct function.

    This presumes that the LowPowerTask has already run

    It then waits for that function to finish its work.
    

--*/
{
    ENTER("arpTaskOnPower", 0xccaf09cd)

    NDIS_STATUS         Status  = NDIS_STATUS_SUCCESS;
    ARP1394_ADAPTER*    pAdapter = (ARP1394_ADAPTER*)RM_PARENT_OBJECT(pTask);
    TASK_POWER        * pTaskPower =  (TASK_POWER*) pTask;
    ARP1394_INTERFACE * pIF = pAdapter->pIF;
    ULONG               Stage = 0;

    enum
    {
        STAGE_Start,
        STAGE_BecomePrimaryTask,
        STAGE_ExistingPrimaryTaskComplete,
        STAGE_StartGenericVCs,
        PEND_DeinitIF,
        STAGE_End
    };

    
    pTaskPower          = (PTASK_POWER) pTask;

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_Start;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    switch(Stage)
    {
        case STAGE_Start:
        {

            // There should NOT be another activate/deactivate task running
            // on this interface. We fail the SetPower if we receive it in 
            // while we are activating or deactivating the task
            //
            TIMESTAMP("===Set Power ON Starting");

            LOCKOBJ(pAdapter, pSR);

            if (CHECK_AD_PRIMARY_STATE(pAdapter,ARPAD_PS_INITED) == FALSE)
            {
                break;
            }
            //
            // Now, make this task the primary task on the adapter
            //
            if (pAdapter->bind.pPrimaryTask == NULL)
            {
                // Don't change the Init State of this adapter
                // 
                ULONG CurrentInitState = GET_AD_PRIMARY_STATE(pAdapter);
                arpSetPrimaryAdapterTask(pAdapter, pTask, CurrentInitState , pSR);
                pAdapter->PoMgmt.bResuming = TRUE;
                UNLOCKOBJ(pAdapter, pSR);
            }
            else
            {
                PRM_TASK pOtherTask =  pAdapter->bind.pPrimaryTask;
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    STAGE_BecomePrimaryTask, // we'll try again...
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }



        }        
        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_ExistingPrimaryTaskComplete:
        {
            PRM_TASK pStartGenericVCs = NULL;

            if (pIF->pActDeactTask != NULL)
            {
                // This should never happen, because the Activate task is
                // always started by an active primary task, and at most one primary
                // task is active at any point of time.
                //
                ASSERTEX(!"start: activate/deactivate task exists!", pIF);
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            //
            // Stop the IF maintenance task if it's running.
            //

            Status = arpAllocateTask(
                        &pAdapter->Hdr,                  // pParentObject,
                        arpTaskStartGenericVCs , // pfnHandler,
                        0,                          // Timeout,
                        "Task: arpTaskStartGenericVCs", // szDescrip.
                        &pStartGenericVCs,
                        pSR
                        );
        

            if (FAIL(Status))
            {
                // Couldn't allocate task.
                //
                TR_WARN(("FATAL: couldn't alloc start call task!\n"));
                break;
            }
            else
            {
                Status = RmPendTaskOnOtherTask(
                            pTask,
                            STAGE_StartGenericVCs,
                            pStartGenericVCs,
                            pSR
                            );
                
                ASSERT(!FAIL(Status));
        
                // RmStartTask uses up the tmpref on the task
                // which was added by arpAllocateTask.
                //
                Status = RmStartTask(
                            pStartGenericVCs,
                            0, // UserParam (unused)
                            pSR
                            );

            }
            if (PEND(Status)) break;

        }
        break;
        
        case STAGE_StartGenericVCs:
        {
        
            //
            // The close AF operation is complete.
            // We've not got anything else to do.
            //
            TIMESTAMP("===Set PowerOn: Created VCs");

            // Recover the last status ...
            //
            Status = (NDIS_STATUS) UserParam;

            if (Status != NDIS_STATUS_SUCCESS)
            {
                //
                // Undo all the VCs, AFs and Task that 
                //have been created in arpTaskStartGenericVCs 
                //
                pAdapter->PoMgmt.bFailedResume = TRUE;
                arpDeinitIf(pIF, pTask,PEND_DeinitIF, pSR);
                Status = NDIS_STATUS_PENDING;                
            }
        }
        break;

        case PEND_DeinitIF:
        {
            //
            // Set the Failure state on the adapter object here
            //

            //
            // return Failure, so we can inform NDIS of the failure
            //
            Status = NDIS_STATUS_SUCCESS;
        }
        break;
        case STAGE_End:
        {
            //
            // We are done with all async aspects of setting the Low Power state
            // Set the event so that the original Low Power thread can return.
            //
  
            TIMESTAMP("===Set Power On done: All done!");

            LOCKOBJ (pAdapter, pSR);
            if (Status== NDIS_STATUS_SUCCESS)
            {
                arpClearPrimaryAdapterTask (pAdapter, pTask, ARPAD_PS_INITED,pSR);
            }
            else
            {
                arpClearPrimaryAdapterTask (pAdapter, pTask, ARPAD_PS_FAILEDINIT,pSR);
            }

            SET_POWER_STATE(pAdapter, ARPAD_POWER_NORMAL);;

            UNLOCKOBJ (pAdapter, pSR);

            *pTaskPower->pStatus = Status;

            NdisSetEvent (&pAdapter->PoMgmt.Complete);
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Stage)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}






NDIS_STATUS
arpStandby (
    IN ARP1394_ADAPTER *pAdapter,
    IN NET_DEVICE_POWER_STATE DeviceState,
    IN PRM_STACK_RECORD pSR
    )
/*++

    arpStandby does the work for putting the adapter into standby.

    It synchronously return Success, Failure or Not Supported.

    If the Adapter structure has not inited, then this function returns
    Not supported

--*/
{
    PARP1394_INTERFACE pIF  = pAdapter->pIF;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    PTASK_POWER pSetPowerTask = NULL;
    NDIS_STATUS TaskStatus = NDIS_STATUS_FAILURE;
    
    ENTER ("arpStandby  ", 0x2087f71a)

    do
    {
        //
        // If we have been asked to standby before the Interface has initialized
        // then we return NOT_SUPPORTED. This will cause NDIS to unbind the the ARP 
        // from the miniport . 
        //
        if (pIF == NULL) 
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
        
        if(!CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_INITED)) 
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        
        Status = arpAllocateTask(
                &pAdapter->Hdr,                  // pParentObject
                arpTaskLowPower,        // pfnHandler
                0,                              // Timeout
                "Task: Set Power Low",       // szDescription
                &(PRM_TASK)pSetPowerTask,
                pSR
                );

        if (NDIS_STATUS_SUCCESS != Status || NULL == pSetPowerTask)
        {
            pSetPowerTask = NULL;
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        pSetPowerTask->pStatus = &TaskStatus;
        pSetPowerTask ->PowerState = DeviceState;

        NdisInitializeEvent(&pAdapter->PoMgmt.Complete);

        RmStartTask((PRM_TASK)pSetPowerTask,0,pSR);

        NdisWaitEvent (&pAdapter->PoMgmt.Complete, 0);

        //
        // Set the variable for the wakeup
        //
        pAdapter->PoMgmt.bReceivedSetPowerD0= FALSE;



        Status = NDIS_STATUS_SUCCESS;                
        break;

    } while (FALSE);




    EXIT();
    return Status;        
}




NDIS_STATUS
arpResume (
    IN ARP1394_ADAPTER* pAdapter,
    IN ARP_RESUME_CAUSE Cause,
    IN PRM_STACK_RECORD pSR
)
/*++

    This function manages the starting of the Resume Task. 

    The resume task can only be started once after receiving an AfNotify 
    and a Set Power. 

    However, an Unbind can come in and unbind the adapter in the middle of this.
    
    This function does not start the resume if the adapter is already unbinding    

--*/
{
    BOOLEAN bSetPowerOnTask = FALSE;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PTASK_POWER pSetPowerTask = NULL;
    NDIS_STATUS TaskStatus;
    
    ENTER ("arpResume", 0x3dddc538)
        

    do
    {
        if (CHECK_POWER_STATE(pAdapter, ARPAD_POWER_NORMAL)== TRUE)
        {
            break;
        }

        LOCKOBJ (pAdapter, pSR);

        if (Cause == Cause_SetPowerD0)
        {
            pAdapter->PoMgmt.bReceivedSetPowerD0 = TRUE;
        }
        //
        // If we have already received an Unbind, then don't do anything.
        //
        if ( pAdapter->PoMgmt.bReceivedUnbind == FALSE)
        {
            //
            // If we have not received an unbind,
            // then this thread needs to all the work to 
            // reactivate the arp module.
            //
            bSetPowerOnTask = TRUE;

        }

        UNLOCKOBJ(pAdapter,pSR);

        if (bSetPowerOnTask  == FALSE)
        {
            break;
        }

        //
        // Start the Set Power Task
        //

        Status = arpAllocateTask(
            &pAdapter->Hdr,                  // pParentObject
            arpTaskOnPower,        // pfnHandler
            0,                              // Timeout
            "Task: SetPower On",       // szDescription
            &(PRM_TASK)pSetPowerTask,
            pSR
            );

        if (Status != NDIS_STATUS_SUCCESS || NULL == pSetPowerTask)
        {
            break;
        }

        pSetPowerTask->pStatus = &TaskStatus;

        NdisResetEvent (&pAdapter->PoMgmt.Complete);

        RmStartTask ((PRM_TASK)pSetPowerTask,0,pSR);

        NdisWaitEvent (&pAdapter->PoMgmt.Complete, 0);

        Status = TaskStatus;


    } while (FALSE);



    EXIT()

    return Status;
}



NDIS_STATUS
arpNdSetPower (
    ARP1394_ADAPTER *pAdapter,
    PNET_DEVICE_POWER_STATE   pPowerState,
    PRM_STACK_RECORD pSR
    )
/*++

    Validates the event and passes it off to the correct function

--*/
{
    ENTER("arpNdSetPower ", 0x21c4013a)
    TASK_POWER          *pSetPowerTask = NULL;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    NDIS_STATUS         TaskStatus = NDIS_STATUS_NOT_SUPPORTED;
    
    
    //
    // The bridge is present.Close all the VCs if we are going to
    // a low power or re-create all the VC if we are going to D0
    //
    if (NetDeviceStateD0 == (*pPowerState))
    {
        Status = arpResume(pAdapter, Cause_SetPowerD0, pSR);
    }
    else
    {
        Status = arpStandby(pAdapter, *pPowerState, pSR);
    }
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\componentdef\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\rm.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    rm.c

Abstract:

    Implementation of the "Resource Manager" APIs.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     11-18-98    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_RM

//=========================================================================
//                  U T I L I T Y     M A C R O S
//=========================================================================

#define RM_ALLOC(_pp, _size, _tag) \
                NdisAllocateMemoryWithTag((_pp), (_size), (_tag))

#define RM_ALLOCSTRUCT(_p, _tag) \
                NdisAllocateMemoryWithTag(&(_p), sizeof(*(_p)), (_tag))

#define RM_FREE(_p)         NdisFreeMemory((_p), 0, 0)

#define RM_ZEROSTRUCT(_p) \
                NdisZeroMemory((_p), sizeof(*(_p)))

#define RM_PRIVATE_UNLINK_NEXT_HASH(_pHashTable, _ppLink) \
            ((*(_ppLink) = (*(_ppLink))->pNext), ((_pHashTable)->NumItems--))

#define SET_RM_STATE(_pHdr, _Mask, _Val)    \
            (((_pHdr)->RmState) = (((_pHdr)->RmState) & ~(_Mask)) | (_Val))

#define CHECK_RM_STATE(_pHdr, _Mask, _Val)  \
            ((((_pHdr)->RmState) & (_Mask)) == (_Val))

#define RMISALLOCATED(_pHdr) \
                CHECK_RM_STATE((_pHdr), RMOBJSTATE_ALLOCMASK, RMOBJSTATE_ALLOCATED)

#define SET_RM_TASK_STATE(_pTask, _pState) \
    SET_RM_STATE(&(_pTask)->Hdr, RMTSKSTATE_MASK, (_pState))

#define CHECK_RM_TASK_STATE(_pTask, _pState) \
    CHECK_RM_STATE(&(_pTask)->Hdr, RMTSKSTATE_MASK, (_pState))

#define GET_RM_TASK_STATE(_pTask) \
        ((_pTask)->Hdr.RmState &  RMTSKSTATE_MASK)

#if RM_EXTRA_CHECKING
    #define RMPRIVATELOCK(_pobj, _psr) \
         rmLock(&(_pobj)->RmPrivateLock, 0, rmPrivateLockVerifier, (_pobj), (_psr))
#else // !RM_EXTRA_CHECKING
    #define RMPRIVATELOCK(_pobj, _psr) \
        rmLock(&(_pobj)->RmPrivateLock, (_psr))
#endif // !RM_EXTRA_CHECKING

#define RMPRIVATEUNLOCK(_pobj, _psr) \
        rmUnlock(&(_pobj)->RmPrivateLock, (_psr))
        

#if 0
    #define RM_TEST_SIG          0x59dcfd36
    #define RM_TEST_DEALLOC_SIG  0x21392147
    #define RM_OBJECT_IS_ALLOCATED(_pobj) \
                    ((_pobj)->Sig == RM_TEST_SIG)
    #define RM_MARK_OBJECT_AS_DEALLOCATED(_pobj) \
                    ((_pobj)->Sig = RM_TEST_DEALLOC_SIG)
#else
    #define RM_OBJECT_IS_ALLOCATED(_pobj)  0x1
    #define RM_MARK_OBJECT_AS_DEALLOCATED(_pobj)  (0)
#endif

//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

#if RM_EXTRA_CHECKING

// The lowest AssociationID used internal to the RM API implementation.
//
#define RM_PRIVATE_ASSOC_BASE (0x1<<31)

// Association types internal to RM API impmenentation.
//
enum
{
    RM_PRIVATE_ASSOC_LINK =  RM_PRIVATE_ASSOC_BASE,
    RM_PRIVATE_ASSOC_LINK_CHILDOF,
    RM_PRIVATE_ASSOC_LINK_PARENTOF,
    RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
    RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
    RM_PRIVATE_ASSOC_INITGROUP,
    RM_PRIVATE_ASSOC_RESUME_TASK_ASYNC,
    RM_PRIVATE_ASSOC_RESUME_TASK_DELAYED
};


const char *szASSOCFORMAT_LINK                  = "    Linked  to 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_CHILDOF          = "    Child   of 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_PARENTOF         = "    Parent  of 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_TASKPENDINGON    = "    Pending on 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_TASKBLOCKS       = "    Blocks     0x%p (%s)\n";
const char *szASSOCFORMAT_INITGROUP             = "    Owns group 0x%p (%s)\n";
const char *szASSOCFORMAT_RESUME_TASK_ASYNC     = "    Resume async (param=0x%p)\n";
const char *szASSOCFORMAT_RESUME_TASK_DELAYED   = "    Resume delayed (param=0x%p)\n";

//  Linked to 0x098889(LocalIP)
//  Parent of 0x098889(InitIPTask)
//  Child  of 0x098889(Interface)

#endif // RM_EXTRA_CHECKING

// Private RM task to unload all objects in a group.
//
typedef struct
{
    RM_TASK             TskHdr;             // Common task header
    PRM_GROUP           pGroup;         // Group being unloaded
    UINT                uIndex;             // Index of hash-table currently being
                                            // unloaded.
    NDIS_EVENT          BlockEvent;         // Event to optionally signal when done.
    BOOLEAN             fUseEvent;          // TRUE IFF event is to be signaled.
    PFN_RM_TASK_HANDLER             pfnTaskUnloadObjectHandler; // ...
                                             // Object's unload task.
    PFN_RM_TASK_ALLOCATOR   pfnUnloadTaskAllocator;

} TASK_UNLOADGROUP;


//
// RM_PRIVATE_TASK is the union of all tasks structures used intenally in rm.c.
// rmAllocateTask allocates memory of sizeof(RM_PRIVATE_TASK), which is guaranteed
// to be large enough to hold any task internal to rm.c
// 
typedef union
{
    RM_TASK                 TskHdr;
    TASK_UNLOADGROUP        UnloadGroup;

}  RM_PRIVATE_TASK;


#if RM_EXTRA_CHECKING

VOID
rmDbgInitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    );

VOID
rmDbgDeinitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    );

VOID
rmDbgPrintOneAssociation (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    );

VOID
_cdecl
rmDefaultDumpEntry (
    char *szFormatString,
    UINT_PTR Param1,
    UINT_PTR Param2,
    UINT_PTR Param3,
    UINT_PTR Param4
);

UINT
rmSafeAppend(
    char *szBuf,
    const char *szAppend,
    UINT cbBuf
);

#endif // RM_EXTRA_CHECKING


NDIS_STATUS
rmTaskUnloadGroup(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );


NDIS_STATUS
rmAllocatePrivateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,      OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
rmWorkItemHandler_ResumeTaskAsync(
    IN  PNDIS_WORK_ITEM             pWorkItem,
    IN  PVOID                       pTaskToResume
    );


VOID
rmTimerHandler_ResumeTaskDelayed(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );

VOID
rmPrivateTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

VOID
rmDerefObject(
    PRM_OBJECT_HEADER       pObject,
    PRM_STACK_RECORD        pSR
    );

VOID
rmLock(
    PRM_LOCK                pLock,
#if RM_EXTRA_CHECKING
    UINT                    uLocID,
    PFNLOCKVERIFIER         pfnVerifier,
    PVOID                   pVerifierContext,
#endif //RM_EXTRA_CHECKING
    PRM_STACK_RECORD        pSR
    );

VOID
rmUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    );

#if RM_EXTRA_CHECKING
ULONG
rmPrivateLockVerifier(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        );

ULONG
rmVerifyObjectState(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        );

RM_DBG_LOG_ENTRY *
rmDbgAllocateLogEntry(VOID);

VOID
rmDbgDeallocateLogEntry(
        RM_DBG_LOG_ENTRY *pLogEntry
        );

#endif // RM_EXTRA_CHECKING

VOID
rmEndTask(
    PRM_TASK            pTask,
    NDIS_STATUS         Status,
    PRM_STACK_RECORD    pSR
    );


VOID
rmUpdateHashTableStats(
    PULONG pStats,
    ULONG   LinksTraversed
    );

typedef struct
{
    PFN_RM_GROUP_ENUMERATOR pfnObjEnumerator;
    PVOID pvCallerContext;
    INT   fContinue;

} RM_STRONG_ENUMERATION_CONTEXT, *PRM_STRONG_ENUMERATION_CONTEXT;


typedef struct
{
    PRM_OBJECT_HEADER *ppCurrent;
    PRM_OBJECT_HEADER *ppEnd;

} RM_WEAK_ENUMERATION_CONTEXT, *PRM_WEAK_ENUMERATION_CONTEXT;


VOID
rmEnumObjectInGroupHashTable (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    );

VOID
rmConstructGroupSnapshot (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    );

//=========================================================================
//                  L O C A L       D A T A
//=========================================================================

// Global struture for the RM apis.
//
struct
{
    // Accessed via interlocked operation.
    //
    ULONG           Initialized;

    RM_OS_LOCK          GlobalOsLock;
    LIST_ENTRY      listGlobalLog;
    UINT            NumGlobalLogEntries;

}   RmGlobals;


RM_STATIC_OBJECT_INFO
RmPrivateTasks_StaticInfo = 
{
    0, // TypeUID
    0, // TypeFlags
    "RM Private Task",  // TypeName
    0, // Timeout

    NULL, // pfnCreate
    rmPrivateTaskDelete, // pfnDelete
    NULL,   // LockVerifier

    0,   // length of resource table
    NULL // Resource Table
};


// TODO: make constant
static
RM_STATIC_OBJECT_INFO
RmTask_StaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "Task", // TypeName
    0, // Timeout

    NULL, // Create
    NULL, // Delete
    NULL, // LockVerifier

    0,   // ResourceTable size
    NULL // ResourceTable
};


//=========================================================================
//                  R M         A P I S
//=========================================================================


#define RM_INITIALIZATION_STARTING 1
#define RM_INITIALIZATION_COMPLETE 2

VOID
RmInitializeRm(VOID)
/*++
    Must be called before any RM APIs are called.
    TODO: replace by registration mechanism.
          See notes.txt  03/07/1999  entry "Registering root objects with RM".
--*/
{
    ENTER("RmInitializeRm", 0x29f5d167)

    if (InterlockedCompareExchange(
            &RmGlobals.Initialized, RM_INITIALIZATION_STARTING, 0)==0)
    {
        TR_INFO(("Initializing RM APIs Global Info\n"));
        NdisAllocateSpinLock(&RmGlobals.GlobalOsLock);
        InitializeListHead(&RmGlobals.listGlobalLog);

        InterlockedExchange(&RmGlobals.Initialized, RM_INITIALIZATION_COMPLETE);
    }
    else
    {
        // Spin waiting for it to get to RM_INITIALIZATION_COMPLETE (allocated).
        TR_INFO(("Spinning, waiting for initialization to complete.\n"));
        while (RmGlobals.Initialized != RM_INITIALIZATION_COMPLETE)
        {
            // spin
        }
    }

    EXIT()
}


VOID
RmDeinitializeRm(VOID)
/*++
    Must be called to deinitialze, after last RM api is called and all async
    activity is over.
    TODO: replace by deregistration mechanism.
          See notes.txt  03/07/1999  entry "Registering root objects with RM".
--*/
{
    ENTER("RmDeinitializeRm", 0x9a8407e9)

    ASSERT(RmGlobals.Initialized == RM_INITIALIZATION_COMPLETE);
    TR_INFO(("Deinitializing RM APIs Global Info\n"));

    // Make sure global log list is empty. Acquiring the GLobalOsLock is
    // not necessary here because all activity has stopped by now.
    //
    ASSERT(IsListEmpty(&RmGlobals.listGlobalLog));

    EXIT()
}


VOID
RmInitializeHeader(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  UINT                        Sig,
    IN  PRM_LOCK                    pLock,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  const char *                szDescription,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize the RM_OBJECT_HEADER portion of an object.

Arguments:

    pParentObject       - NULL for a root object.
    pObject             - Object to be initialized.
    Sig                 - Signature of the object.
    pLock               - Lock used to serialize access to the object.
    pStaticInfo         - Static informatation about the object.
    szDescription       - A discriptive string (for debugging only) to be associated
                          with this object.
--*/
{
    ENTER("RmInitializeHeader", 0x47dea382)

    NdisZeroMemory(pObject, sizeof(*pObject));

    if (szDescription == NULL)
    {
        szDescription = pStaticInfo->szTypeName;
    }

    TR_VERB(("Initializing header 0x%p (%s)\n", pObject, szDescription));

    pObject->Sig = Sig;
    pObject->pLock = pLock;
    pObject->pStaticInfo = pStaticInfo;
    pObject->szDescription = szDescription;
    SET_RM_STATE(pObject, RMOBJSTATE_ALLOCMASK, RMOBJSTATE_ALLOCATED);

    // The private lock is set to level (UINT)-1, which is the highest
    // possible level.
    //
    RmInitializeLock(&pObject->RmPrivateLock, (UINT)-1);

#if RM_EXTRA_CHECKING
    rmDbgInitializeDiagnosticInfo(pObject, pSR);
#endif //RM_EXTRA_CHECKING

    // Link to parent if non NULL.
    //

    if (pParentObject != NULL)
    {
        pObject->pParentObject = pParentObject;
        pObject->pRootObject =  pParentObject->pRootObject;

    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            pObject,
            pParentObject,
            0x11f25620,
            RM_PRIVATE_ASSOC_LINK_CHILDOF,
            szASSOCFORMAT_LINK_CHILDOF,
            RM_PRIVATE_ASSOC_LINK_PARENTOF,
            szASSOCFORMAT_LINK_PARENTOF,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(pObject, pParentObject, pSR);
    #endif // !RM_EXTRA_CHECKING


    }
    else
    {
        pObject->pRootObject = pObject;
    }


    // We increment the total-ref count once for the allocation. This
    // reference is removed in the call to RmDeallocateObject.
    // Note that this reference is in addition to the reference implicitly
    // added by the call to RmLinkObjects above.
    //
    NdisInterlockedIncrement(&pObject->TotRefs);

#if RM_TRACK_OBJECT_TREE

    // Initialize our list of children.
    //
    InitializeListHead(&pObject->listChildren);

    if (pParentObject != NULL)
    {
        // Insert ourselves into our parent's list of children.
        //
        RMPRIVATELOCK(pParentObject, pSR);
        InsertHeadList(&pParentObject->listChildren, &pObject->linkSiblings);
        RMPRIVATEUNLOCK(pParentObject, pSR);
    }
#endif //  RM_TRACK_OBJECT_TREE

    EXIT()
    return;
}


VOID
RmDeallocateObject(
    IN  PRM_OBJECT_HEADER           pObject,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Logically deallocate the object pObject. We don't actually unlink it from
    its parent or deallocate if there are non zero references to it.

--*/
{
    UINT Refs;
    ENTER("RmDeallocateObject", 0xa87fdf4a)
    TR_INFO(("0x%p (%s)\n", pObject, pObject->szDescription));

    RMPRIVATELOCK(pObject, pSR);

    RETAILASSERTEX(RMISALLOCATED(pObject), pObject);


    // Set state to deallocated.
    //
    SET_RM_STATE(pObject, RMOBJSTATE_ALLOCMASK, RMOBJSTATE_DEALLOCATED);

    RMPRIVATEUNLOCK(pObject, pSR);

    // Remove the ref explicitly added in RmInitializeAllocateObject.
    // rmDerefObject will remove the link to the parent, if any, if the
    // ref count drop to 1.
    //
    rmDerefObject(pObject, pSR);

    EXIT()
}


VOID
RmInitializeLock(
    IN PRM_LOCK pLock,
    IN UINT     Level
    )
/*++

Routine Description:

    Initialize a lock.

Arguments:

    pLock       - Unitialized memory to hold a struct of type RM_LOCK.
    Level       - Level to be associated with this lock. Locks must be acquired
                  in strictly increasing order of the locks' "Level" values.
--*/
{
    ASSERT(Level > 0);
    NdisAllocateSpinLock(&pLock->OsLock);
    pLock->Level = Level;
    
#if RM_EXTRA_CHECKING
    pLock->pDbgInfo = &pLock->DbgInfo;
    NdisZeroMemory(&pLock->DbgInfo, sizeof(pLock->DbgInfo));
#endif //  RM_EXTRA_CHECKING
}


VOID
RmDoWriteLock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Acquire (write lock) lock pLock.

--*/
{
    rmLock(
        pLock,
    #if RM_EXTRA_CHECKING
        0x16323980, // uLocID,
        NULL,
        NULL,
    #endif //RM_EXTRA_CHECKING
        pSR
        );
}


VOID
RmDoUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Unlock lock pLock.

--*/
{
    rmUnlock(
        pLock,
        pSR
        );
}

#if TODO // Currently RmReadLockObject is a macro defined to be RmWriteLockObject.
         // TODO: Verifier need to to also make sure that object hasn't changed state
         //       *while* the object has been read-locked.
VOID
RmReadLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Acquire (read lock)  lock pLock.

--*/
{
    ASSERT(!"Unimplemented");
}
#endif //TODO


VOID
RmWriteLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Acquire (write lock) the lock associated with object pObj.

Arguments:

    pObj        --      Object whose lock to acquire.
    uLocID      --      Arbitrary UINT identifying static location from which this
                        call is made.

--*/
{
    ENTER("RmWriteLockObject", 0x590ed543)
    TR_VERB(("Locking 0x%p (%s)\n", pObj, pObj->szDescription));

    rmLock(
        pObj->pLock,
    #if RM_EXTRA_CHECKING
        uLocID,
        // pObj->pStaticInfo->pfnLockVerifier,
        rmVerifyObjectState,
        pObj,
    #endif //RM_EXTRA_CHECKING
        pSR
        );
    EXIT()
}


VOID
RmUnlockObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Release the lock associated with object pObj.

--*/
{
    ENTER("RmUnLockObject", 0x0307dd84)
    TR_VERB(("Unlocking 0x%p (%s)\n", pObj, pObj->szDescription));

#if RM_EXTRA_CHECKING
    //
    // Make sure that pObject is the object that is *supposed* to be freed.
    //
    ASSERT(pSR->LockInfo.pNextFree[-1].pVerifierContext  == (PVOID) pObj);
#endif // RM_EXTRA_CHECKING

    rmUnlock(
        pObj->pLock,
        pSR
        );

    EXIT()
}


VOID
RmUnlockAll(
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Unlocks all currently held locks as recorded in pSR.
    If the locks are associated with objects, RmUnlockObject is called for
    each of the held locks. Otherwise the raw unlock is performed.

--*/
{
    ENTER("RmUnLockObject", 0x9878be96)
    TR_VERB(("Unlocking all\n"));

    while (pSR->LockInfo.CurrentLevel != 0)
    {
        rmUnlock(
            pSR->LockInfo.pNextFree[-1].pLock,
            pSR
            );
    }

    EXIT()
}


VOID
RmDbgChangeLockScope(
    IN  PRM_OBJECT_HEADER           pPreviouslyLockedObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG                       LocID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    (Debug only)

    Munge things so that the following sequence works:
    Rm[Read|Write]LockObject(pPreviouslyLockedObject, pSR);
    RmChangeLockScope(pPreviouslyLockedObject, pSR);
    RmUnlockObject(pObject, pSR);

    Of course, we require that the two objects have the same lock!

    NOTE: We only support changing scope of the MOST RECENTLY 
    acquired lock.


Arguments:

    pPreviouslyLockedObject     - Currently locked object.
    pObject                     - Object to transfer lock scope to.
    LocID                       - Arbitrary UINT identifying static location from
                                  which this call is made.
--*/
{
    //
    // This is a NOOP unless extra-checking is enabled.
    // TODO: make this inline in the fre build.
    //
#if RM_EXTRA_CHECKING
    RM_LOCKING_INFO * pLI = pSR->LockInfo.pNextFree-1;
    PRM_LOCK        pLock =  pPreviouslyLockedObject->pLock;
    ASSERT(
            pLock->Level == pSR->LockInfo.CurrentLevel
        &&  pLock == pObject->pLock
        &&  pLock == pLI->pLock
        &&  pLI->pVerifierContext == (PVOID) pPreviouslyLockedObject);

    ASSERT(pLI->pfnVerifier == rmVerifyObjectState);

    rmVerifyObjectState(pLock, FALSE, pLI->pVerifierContext, pSR);
    pLI->pVerifierContext   =  pObject;
    pLock->DbgInfo.uLocID   =  LocID;
    rmVerifyObjectState(pLock, TRUE, pLI->pVerifierContext, pSR);
    
#endif // RM_EXTRA_CHECING

}


VOID
RmLinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSr
    )
/*++

Routine Description:

        Link object pObj1 to object pObj2. Basically, this function refs both
        objects.

        OK to call with some locks held, including RmPrivateLock.
        TODO: remove arp pSr above -- we don't need it.
--*/
{
    ENTER("RmLinkObjects", 0xfe2832dd)

    // Maybe we're being too harsh here -- if required, remove this...
    // This could happen where a task is linked at the point where the object
    // is being deallocated, so I'm changing the following  to debug asserts
    // (used to be retail asserts).
    //
    ASSERT(RMISALLOCATED(pObj1));
    ASSERT(RMISALLOCATED(pObj2));

    TR_INFO(("0x%p (%s) linked to 0x%p (%s)\n",
                 pObj1,
                 pObj1->szDescription,
                 pObj2,
                 pObj2->szDescription
                ));

    NdisInterlockedIncrement(&pObj1->TotRefs);
    NdisInterlockedIncrement(&pObj2->TotRefs);

}


VOID
RmLinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  ULONG                       InvAssocID,
    IN  const char *                szInvAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        Same as RmLinkObjects, execpt that (debug only) it also sets up  association
          (pObj2, pObj2->szDescription, AssocID)
        on pObj1, and association
            (pObj1, pObj1->szDescription, InvAssocID)
        on object pObj2

Arguments:

    pObj1                   - Object whose lock to acquire.
    pObj2                   - Object whose lock to acquire.
    LocID                   - Arbitrary UINT identifying static location from which
                              this call is made.
    AssocID                 - ID of the association (see RmDbgAddAssociation) that
                              represents the link from pObj1 to pObj2.
    szAssociationFormat     - Format of the association (see RmDbgAddAssociation)
    InvAssocId              - ID of the inverse association (i.e., represents
                              link from pObj2 to pObj1).
    szInvAssociationFormat  - Format of the inverse association.

--*/
{
    ENTER("RmLinkObjectsEx", 0xef50263b)

#if RM_EXTRA_CHECKING

    RmDbgAddAssociation(
        LocID,                              // Location ID
        pObj1,                              // pObject
        (UINT_PTR) pObj2,                   // Instance1
        (UINT_PTR) (pObj2->szDescription),  // Instance2
        AssocID,                            // AssociationID
        szAssociationFormat,
        pSR
        );

    RmDbgAddAssociation(
        LocID,                              // Location ID
        pObj2,                              // pObject
        (UINT_PTR) pObj1,                   // Instance1
        (UINT_PTR) (pObj1->szDescription),  // Instance2
        InvAssocID,                         // AssociationID
        szInvAssociationFormat,
        pSR
        );
    
#endif // RM_EXTRA_CHECKING

    RmLinkObjects(
        pObj1,
        pObj2,
        pSR
        );
}


VOID
RmUnlinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:
    
    Unlink objects pObj1 and pObj2 (i.e., undo the effect of
    RmLinkObjects(pObj1, pObj2, pSR)).

--*/
{
    ENTER("RmUnlinkObjects", 0x7c64356a)
    TR_INFO(("0x%p (%s) unlinked from 0x%p (%s)\n",
                 pObj1,
                 pObj1->szDescription,
                 pObj2,
                 pObj2->szDescription
                ));
#if RM_EXTRA_CHECKING
    //
    // TODO: remove explict link
    //
#endif // RM_EXTRA_CHECKING

    // Remove link refs.
    //
    rmDerefObject(pObj1, pSR);
    rmDerefObject(pObj2, pSR);
}


VOID
RmUnlinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  ULONG                       InvAssocID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        Same as RmUnlinkObjects, execpt that it also removes the  association
          (pObj2, pObj2->szDescription, AssocID)
        on pObj1, and association
            (pObj1, pObj1->szDescription, InvAssocID)
        object pObj2

Arguments:

        See RmLinkObjectsEx.

--*/
{
    ENTER("RmUnlinkObjectsEx", 0x65d3536c)

#if RM_EXTRA_CHECKING

    RmDbgDeleteAssociation(
        LocID,                              // Location ID
        pObj1,                              // pObject
        (UINT_PTR) pObj2,                   // Instance1
        (UINT_PTR) (pObj2->szDescription),  // Instance2
        AssocID,                            // AssociationID
        pSR
        );

    RmDbgDeleteAssociation(
        LocID,                              // Location ID
        pObj2,                              // pObject
        (UINT_PTR) pObj1,                   // Instance1
        (UINT_PTR) (pObj1->szDescription),  // Instance2
        InvAssocID,                         // AssociationID
        pSR
        );
    
#endif // RM_EXTRA_CHECKING

    RmUnlinkObjects(
        pObj1,
        pObj2,
        pSR
        );
}


VOID
RmLinkToExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Links object pObj to external entity ExternalEntity. Basically, this function
    adds a reference to pObj. In addition (debug only) this function sets up
    an association on pObj that links the external entity to pObj. pObj can be
    linked to ExternalEntity with the specified association ID AssocID only ONCE
    at any particular point of time.

    Once this link is setup, an attempt to deallocate pObj without removing the
    link results in an assertion failure.

    RmUnlinkFromExternalEx is the inverse function.

Arguments:

    pObj                        - Object to be linked to an external entity.

    (following are for debug only...)

    LocID                       - Arbitrary UINT identifying static location from
                                  which this call is made.
    ExternalEntity              - Opaque value representing the external entity.
    AssocID                     - Association ID representing the linkage.
    szAssociationFormat         - Association format for the linkage.

--*/
{
    ENTER("RmLinkToExternalEx", 0x9aeaca74)

#if RM_EXTRA_CHECKING

    RmDbgAddAssociation(
        LocID,                              // Location ID
        pObj,                               // pObject
        (UINT_PTR) ExternalEntity,          // Instance1
        (UINT_PTR) 0,                       // Instance2 (unused)
        AssocID,                            // AssociationID
        szAssociationFormat,
        pSR
        );

#endif // RM_EXTRA_CHECKING

    RmLinkToExternalFast(pObj);

    EXIT()
}


VOID
RmUnlinkFromExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Inverse of RmUnlinkFromExternalEx -- removes the link set up between
    pObj and ExternalEntity.

Arguments:

    See RmLinkToExternalEx.

--*/
{
    ENTER("RmUnlinkFromExternalEx", 0x9fb084c3)

#if RM_EXTRA_CHECKING

    RmDbgDeleteAssociation(
        LocID,                              // Location ID
        pObj,                               // pObject
        (UINT_PTR) ExternalEntity,          // Instance1
        (UINT_PTR) 0,                       // Instance2 (unused)
        AssocID,                            // AssociationID
        pSR
        );

#endif // RM_EXTRA_CHECKING

    RmUnlinkFromExternalFast(pObj);

    EXIT()
}


VOID
RmLinkToExternalFast( // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    )
/*++

Routine Description:

    Fast version of RmLinkToExternalEx -- same behavior in retail. No associations
    are setup.

Arguments:

    See RmLinkToExternalEx.

--*/
{
    NdisInterlockedIncrement(&pObj->TotRefs);
}


VOID
RmUnlinkFromExternalFast(   // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    )
/*++
Routine Description:

    Inverse of RmUnlinkFromExternalFast -- removes the link set up between
    pObj and ExternalEntity.

    TODO -- we need a fast implementation for the case that the object is
    not going to go away. For now we actually declare a stack record here each
    time, becaues rmDerefObject wants one! Bad bad.

Arguments:

    See RmLinkToExternalFast.

--*/
{
    RM_DECLARE_STACK_RECORD(sr)
    rmDerefObject(pObj, &sr);
}


VOID
RmTmpReferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Add a temporary reference to object pObj.
    (Debug only) Increments the count of tmprefs maintained in pSR.

--*/
{
    ENTER("RmTmpReferenceObject", 0xdd981024)
    TR_VERB(("0x%p (%s)\n", pObj, pObj->szDescription));

    ASSERT(RM_OBJECT_IS_ALLOCATED(pObj));

    pSR->TmpRefs++;

    NdisInterlockedIncrement(&pObj->TotRefs);
}


VOID
RmTmpDereferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Remove a temporary reference to object pObj.
    (Debug only) Decrements the count of tmprefs maintained in pSR.

--*/
{
    ENTER("RmTmpDereferenceObject", 0xd1630c11)
    TR_VERB(("0x%p (%s)\n", pObj, pObj->szDescription));

    RETAILASSERTEX(pSR->TmpRefs>0, pSR);
    pSR->TmpRefs--;

    rmDerefObject(pObj, pSR);
}


VOID
RmDbgAddAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Entity1,
    IN  ULONG_PTR                   Entity2,
    IN  ULONG                       AssociationID,
    IN  const char *                szFormatString, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    )
/*++


Routine Description:

        Add an arbitrary association, for debugging purposes, under
        object pObject. The association is defined by the triple
        (Entity1, Entity2, AssociationID) -- only ONE such tuple may
        be registered at any time with object pParentObject.
        Note: It is valid for both of the following to be registered at the same
        time: (a, b, 1) and (a, b, 2)

        No association should exist at the point the object is deleted.

Arguments:

        LocID           -   Arbitrary ID, typically representing the source location
                        -   from which this function is called.
        pObject         -   Object to add the association.
        Entity1         -   The 1st entity making up the association. May be NULL.
        Entity2         -   The 2nd entity making up the association. May be NULL.
        AssociationID   -   ID defining the association. 
                            NOTE: AssociationID must not have the high-bit set.
                            Associations with the high bit set are reserved for
                            internal use of the Rm API implementation.

--*/
{
#if RM_EXTRA_CHECKING
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;
    ENTER("RmDbgAddAssociation", 0x512192eb)

    if (pDiagInfo)
    {

        //
        // Allocate an association and  enter it into the hash table.
        // Assert if it already exists.
        //

        RM_PRIVATE_DBG_ASSOCIATION *pA;
        RM_ALLOCSTRUCT(pA, MTAG_DBGINFO); // TODO use lookaside lists.
    
        if (pA == NULL)
        {
            //
            // Allocation failed. Record this fact, so that
            // RmDbgDeleteAssociation doesn't assert
            // if an attempt is made to remove an assertion which doesn't exist.
            //
            NdisAcquireSpinLock(&pDiagInfo->OsLock);
            pDiagInfo->AssociationTableAllocationFailure = TRUE;
            NdisReleaseSpinLock(&pDiagInfo->OsLock);
        }
        else
        {
            BOOLEAN fFound;
            PRM_HASH_LINK *ppLink;
            RM_ZEROSTRUCT(pA);

            pA->Entity1 = Entity1;
            pA->Entity2 = Entity2;
            pA->AssociationID = AssociationID;

            if (szFormatString == NULL)
            {
                // Put in the default description format string.
                //
                szFormatString = "    Association (E1=0x%x, E2=0x%x, T=0x%x)\n";
            }

            TR_VERB((" Obj:0x%p (%s)...\n", pObject, pObject->szDescription));
            TRACE0(TL_INFO,((char*)szFormatString, Entity1, Entity2, AssociationID));

            pA->szFormatString = szFormatString;

            NdisAcquireSpinLock(&pDiagInfo->OsLock);
    
            fFound = RmLookupHashTable(
                            &pDiagInfo->AssociationTable,
                            &ppLink,
                            pA      // We use pA as the key.
                            );
    
            if (fFound)
            {
                ASSERTEX(
                    !"Association already exists:",
                    CONTAINING_RECORD(*ppLink, RM_PRIVATE_DBG_ASSOCIATION, HashLink)
                    );
                RM_FREE(pA);
                pA = NULL;
            }
            else
            {
                //
                // Enter the association into the hash table.
                //
    
                RmAddHashItem(
                    &pDiagInfo->AssociationTable,
                    ppLink,
                    &pA->HashLink,
                    pA      // We use pA as the key
                    );
            }
            NdisReleaseSpinLock(&pDiagInfo->OsLock);

            // Now, just for grins, make a note of this in the object's log.
            // WARNING: Although pEntity1/2 may contain pointers, 
            // we expect the the format string is such that if there are any
            // references to regular or unicode strings, those strings will
            // be valid for the life of the object (typically these strings
            // are statically-allocated strings).
            //
            // We  COULD use the more conservative format string to display the
            // log entry, but it's useful to have the information displayed
            // properly.
            //
            // Note-- we could also do different things depending on the type
            // of association.
            //
            #if 0 // conservative format
            RmDbgLogToObject(
                    pObject,
            "    Add association (E1=0x%x, E2=0x%x, T=0x%x)\n",
                    Entity1,
                    Entity2,
                    AssociationID,
                    0, // Param4  // (UINT_PTR) szFormatString,
                    NULL,
                    NULL
                    );
            #else // aggresive format
            {
                #define szADDASSOC "    Add assoc:"

#if OBSOLETE        //  This doesn't work because rgMungedFormat is on the stack!
                char rgMungedFormat[128];
                UINT uLength;
                rgMungedFormat[0]=0;
                rmSafeAppend(rgMungedFormat, szADDASSOC, sizeof(rgMungedFormat));
                uLength = rmSafeAppend(
                            rgMungedFormat,
                            szFormatString,
                            sizeof(rgMungedFormat)
                            );
                if (uLength && rgMungedFormat[uLength-1] != '\n')
                {
                    rgMungedFormat[uLength-1] = '\n';
                }
                RmDbgLogToObject(
                        pObject,
                        rgMungedFormat,
                        Entity1,
                        Entity2,
                        AssociationID,
                        0,
                        NULL,
                        NULL
                        );
#endif // OBSOLETE

                RmDbgLogToObject(
                        pObject,
                        szADDASSOC,
                        (char*)szFormatString,
                        Entity1,
                        Entity2,
                        AssociationID,
                        0,
                        NULL,
                        NULL
                        );
            }
            #endif // aggressive format
        }
    }

    EXIT()
#endif // RM_EXTRA_CHECKING
}


VOID
RmDbgDeleteAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Entity1,
    IN  ULONG_PTR                   Entity2,
    IN  ULONG                       AssociationID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        Removes the previously-added association (Entity1, Entity2, Association)
        from object pObject. See the description of RmDbgAddAssociation for
        details.

Arguments:

        See RmDbgAddAssociation.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmDbgDelAssociation", 0x8354559f)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    if (pDiagInfo)
    {
        BOOLEAN fFound;
        PRM_HASH_LINK *ppLink;
        RM_PRIVATE_DBG_ASSOCIATION TrueKey;

        // Only the following 3 fields of TrueKey make up the key
        //
        TrueKey.Entity1 = Entity1;
        TrueKey.Entity2 = Entity2;
        TrueKey.AssociationID = AssociationID;

        NdisAcquireSpinLock(&pDiagInfo->OsLock);

        fFound = RmLookupHashTable(
                        &pDiagInfo->AssociationTable,
                        &ppLink,
                        &TrueKey
                        );

        if (fFound)
        {
            RM_PRIVATE_DBG_ASSOCIATION *pA =
                    CONTAINING_RECORD(*ppLink, RM_PRIVATE_DBG_ASSOCIATION, HashLink);

            TR_VERB((" Obj:0x%p (%s)...\n", pObject, pObject->szDescription));
            TRACE0(TL_INFO,
                ((char*)pA->szFormatString,
                 pA->Entity1,
                 pA->Entity2,
                 pA->AssociationID));

            //
            // Now, just for grins, make a note of this in the oject's log.
            // Note that of pEntity1/2 contain pointers, we can't expect them
            // to be valid for as long as the object is alive, so we use
            // the more conservative format string to display the log entry.
            //
            //  TODO/BUGUG -- see comments under RmDbgAddAssociation
            //                  about the risk of directly passing szFormat
            //
            
        #if 0 // conservative
                RmDbgLogToObject(
                        pObject,
                        NULL,
                "    Deleted Association (E1=0x%x, E2=0x%x, T=0x%x)\n",
                        pA->Entity1,
                        pA->Entity2,
                        pA->AssociationID,
                        0,
                        NULL,
                        NULL
                        );
        #else // aggressive
                #define szDELASSOC "    Del assoc:"
                RmDbgLogToObject(
                        pObject,
                        szDELASSOC,
                        (char*) pA->szFormatString,
                        pA->Entity1,
                        pA->Entity2,
                        pA->AssociationID,
                        0, // Param4  // (UINT_PTR) szFormatString,
                        NULL,
                        NULL
                        );
        #endif // aggressive

            //
            // Remove the association and free it.
            //

            RM_PRIVATE_UNLINK_NEXT_HASH( &pDiagInfo->AssociationTable, ppLink );

            RM_FREE(pA);
        }
        else
        {
            if  (!pDiagInfo->AssociationTableAllocationFailure)
            {
                ASSERT(!"Association doesn't exist");
            }
        }
        NdisReleaseSpinLock(&pDiagInfo->OsLock);


    }
    EXIT()
#endif // RM_EXTRA_CHECKING
}


VOID
RmDbgPrintAssociations(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    (Debug only) Dumps the associations on object pObject.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmPrintAssociations", 0x8354559f)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    if (pDiagInfo)
    {
        TR_INFO((
            "Obj 0x%p (%s):\n",
            pObject,
            pObject->szDescription
            ));

        NdisAcquireSpinLock(&pDiagInfo->OsLock);

        RmEnumHashTable(
                    &pDiagInfo->AssociationTable,
                    rmDbgPrintOneAssociation,   // pfnEnumerator
                    pObject,        // context
                    pSR
                    );

        NdisReleaseSpinLock(&pDiagInfo->OsLock);
    }
    EXIT()
#endif // RM_EXTRA_CHECKING
}


//
// Diagnostic per-object logging.
//

VOID
RmDbgLogToObject(
    IN  PRM_OBJECT_HEADER       pObject,
    IN  char *                  szPrefix,       OPTIONAL
    IN  char *                  szFormatString,
    IN  UINT_PTR                Param1,
    IN  UINT_PTR                Param2,
    IN  UINT_PTR                Param3,
    IN  UINT_PTR                Param4,
    IN  PFN_DBG_DUMP_LOG_ENTRY  pfnDumpEntry,   OPTIONAL
    IN  PVOID                   pvBuf           OPTIONAL
    )
/*++

Routine Description:

    Make one log entry in pObject's log.

    TODO: See notes.txt  entry "03/07/1999 ... Registering root objects with RM"
    on how we will find the deallocator function fo pvBuf. For now we simply
    use NdisFreeMemory.

    TODO: need to implement trimming of log when we reach a maximum. Currently we
    just stop logging. 

Arguments:
        pfnDumpEntry    - Function to be used for dumping the log.
                          If NULL, a default function is used, which interprets
                          szFormatString as the standard printf format string.

        szFormatString  - Format string for log display -- 1st arg to pfnDumpEntry

        Param1-4        - Remaining args to pfnDumpEntry;

        pvBuf           - If non-NULL, piece of memory to be freed when the log entry
                          is freed.

        NOTE:   If Param1-4 contain pointers, the memory they refer to is assumed
        to be valid for as long as the object is alive. If the entities being logged
        may go away before the object is deallocated, the caller should
        allocate a buffer to hold a copy of the entities, and pass the pointer to
        that buffer as pvBuf.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmDbgLogToObject", 0x2b2015b5)

    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    if (pDiagInfo && RmGlobals.NumGlobalLogEntries < 4000)
    {
        RM_DBG_LOG_ENTRY *pLogEntry;

        NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);

        pLogEntry = rmDbgAllocateLogEntry();

        if (pLogEntry != NULL)
        {
            if (pfnDumpEntry == NULL)
            {
                pfnDumpEntry = rmDefaultDumpEntry;
            }

            pLogEntry->pObject      = pObject;
            pLogEntry->pfnDumpEntry = pfnDumpEntry;
            pLogEntry->szPrefix = szPrefix;
            pLogEntry->szFormatString = szFormatString;
            pLogEntry->Param1 = Param1;
            pLogEntry->Param2 = Param2;
            pLogEntry->Param3 = Param3;
            pLogEntry->Param4 = Param4;
            pLogEntry->pvBuf  = pvBuf;

            // Insert item at head of object log.
            //
            InsertHeadList(&pDiagInfo->listObjectLog, &pLogEntry->linkObjectLog);

            // Insert item at head of global log.
            //
            InsertHeadList(&RmGlobals.listGlobalLog, &pLogEntry->linkGlobalLog);


            pDiagInfo->NumObjectLogEntries++;
            RmGlobals.NumGlobalLogEntries++;
        }

        NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);

    #if 0
        pfnDumpEntry(
                szFormatString,
                Param1,
                Param2,
                Param3,
                Param4
                );
    #endif // 0
    }
    else
    {
        // TODO -- free pvBuf if NON NULL.
    }
    EXIT()
#endif // RM_EXTRA_CHECKING

}


VOID
RmDbgPrintObjectLog(
    IN PRM_OBJECT_HEADER pObject
    )
/*++

Routine Description:

    (Debug only) Dumps object pObject's log.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmPrintObjectLog", 0xe06507e5)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    TR_INFO((" pObj=0x%p (%s)\n", pObject, pObject->szDescription));


    if (pDiagInfo != NULL)
    {
        LIST_ENTRY          *pLink=NULL;
        LIST_ENTRY *        pObjectLog =  &pDiagInfo->listObjectLog;
        
        NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);
    
        for(
            pLink =  pObjectLog->Flink;
            pLink != pObjectLog;
            pLink = pLink->Flink)
        {
            RM_DBG_LOG_ENTRY    *pLE;
    
            pLE = CONTAINING_RECORD(pLink,  RM_DBG_LOG_ENTRY,  linkObjectLog);

            if (pLE->szPrefix != NULL)
            {
                // Print the prefix.
                DbgPrint(pLE->szPrefix);
            }
    
            // Call the dump function for this entry.
            //
            // 
            pLE->pfnDumpEntry(
                            pLE->szFormatString,
                            pLE->Param1,
                            pLE->Param2,
                            pLE->Param3,
                            pLE->Param4
                            );
    
        }
        NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);
    }
    EXIT()

#endif // RM_EXTRA_CHECKING
}


VOID
RmDbgPrintGlobalLog(VOID)
/*++

Routine Description:

    (Debug only) Dumps the global log (which contains entries from all object's
    logs.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmPrintGlobalLog", 0xe9915066)
    LIST_ENTRY          *pLink=NULL;
    LIST_ENTRY          *pGlobalLog =  &RmGlobals.listGlobalLog;

    TR_INFO(("Enter\n"));

    NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);

    for(
        pLink =  pGlobalLog->Flink;
        pLink != pGlobalLog;
        pLink = pLink->Flink)
    {
        RM_DBG_LOG_ENTRY    *pLE;

        pLE = CONTAINING_RECORD(pLink,  RM_DBG_LOG_ENTRY,  linkGlobalLog);

        // Print the ptr and name of the object whose entry this is...
        //
        DbgPrint(
            "Entry for 0x%p (%s):\n",
            pLE->pObject,
            pLE->pObject->szDescription
            );

        if (pLE->szPrefix != NULL)
        {
            // Print the prefix.
            DbgPrint(pLE->szPrefix);
        }

        // Call the dump function for this entry.
        //
        // 
        pLE->pfnDumpEntry(
                        pLE->szFormatString,
                        pLE->Param1,
                        pLE->Param2,
                        pLE->Param3,
                        pLE->Param4
                        );

    }
    NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);

    EXIT()

#endif // RM_EXTRA_CHECKING
}


RM_STATUS
RmLoadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    TODO This function is going away...

--*/
{
    PRM_STATIC_OBJECT_INFO pSI = pObj->pStaticInfo;
    RM_STATUS              Status;

    // The resource ID should be less than number of bits in the ResourceMap
    //
    ASSERT(GenericResourceID < 8*sizeof(pObj->ResourceMap));


    RMPRIVATELOCK(pObj, pSR);

    do
    {
        UINT ResFlag = 1<<GenericResourceID;

        if (!RMISALLOCATED(pObj))
        {
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        if (pSI->NumResourceTableEntries <= GenericResourceID)
        {
            ASSERTEX(!"Invalid GenericResourceID", pObj);
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        // The resource entry indexed must have its ID == GenericResourceID
        //
        //
        if (pSI->pResourceTable[GenericResourceID].ID != GenericResourceID)
        {
            ASSERTEX(!"Resource ID doesn't match table entry", pObj);
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        if ( ResFlag & pObj->ResourceMap)
        {
            ASSERTEX(!"Resource already allocated", pObj);
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        pObj->ResourceMap |= ResFlag;

        RMPRIVATEUNLOCK(pObj, pSR);

        Status = pSI->pResourceTable[GenericResourceID].pfnHandler(
                            pObj,
                            RM_RESOURCE_OP_LOAD,
                            NULL, // pvUserParams (unused)
                            pSR
                            );

        if (FAIL(Status))
        {
            // Clear the resource map bit on failure.
            //
            RMPRIVATELOCK(pObj, pSR);
            ASSERTEX(ResFlag & pObj->ResourceMap, pObj);
            pObj->ResourceMap &= ~ResFlag;
            RMPRIVATEUNLOCK(pObj, pSR);
        }

    } while (FALSE);

    return Status;
}


VOID
RmUnloadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    TODO This function is going away...

--*/
{
    PRM_STATIC_OBJECT_INFO pSI = pObj->pStaticInfo;
    RM_STATUS              Status;

    // The resource ID should be less than number of bits in the ResourceMap
    //
    ASSERT(GenericResourceID < 8*sizeof(pObj->ResourceMap));

    RMPRIVATELOCK(pObj, pSR);

    do
    {
        UINT ResFlag = 1<<GenericResourceID;

        if (pSI->NumResourceTableEntries <= GenericResourceID)
        {
            ASSERTEX(!"Invalid GenericResourceID", pObj);
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        if ( !(ResFlag & pObj->ResourceMap))
        {
            ASSERTEX(!"Resource not allocated", pObj);
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        // Clear the resource flag.
        //
        pObj->ResourceMap &= ~ResFlag;

        RMPRIVATEUNLOCK(pObj, pSR);

        pSI->pResourceTable[GenericResourceID].pfnHandler(
                            pObj,
                            RM_RESOURCE_OP_UNLOAD,
                            NULL, // pvUserParams (unused)
                            pSR
                            );

    } while (FALSE);

}


VOID
RmUnloadAllGenericResources(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
    Synchronously unload all previously loaded resources for this object,
    in reverse order to which they were loaded.

    TODO this function is going away...
--*/
{
    PRM_STATIC_OBJECT_INFO pSI = pObj->pStaticInfo;
    RM_STATUS              Status;
    UINT                   u;

    RMPRIVATELOCK(pObj, pSR);

    for(u = pSI->NumResourceTableEntries;
        u && pObj->ResourceMap;
        u--)
    {
        UINT  ResID = u-1;
        UINT ResFlag = 1<<ResID;
        if ( !(ResFlag & pObj->ResourceMap))
        {
            continue;
        }

        if (pSI->NumResourceTableEntries <= ResID)
        {
            ASSERTEX(!"Corrupt ResourceMap", pObj);
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }


        // Clear the resource flag.
        //
        pObj->ResourceMap &= ~ResFlag;

        RMPRIVATEUNLOCK(pObj, pSR);

        pSI->pResourceTable[ResID].pfnHandler(
                            pObj,
                            RM_RESOURCE_OP_UNLOAD,
                            NULL, // pvUserParams (unused)
                            pSR
                            );

        RMPRIVATELOCK(pObj, pSR);

    }

    ASSERTEX(!pObj->ResourceMap, pObj);

    RMPRIVATEUNLOCK(pObj, pSR);

}


VOID
RmInitializeGroup(
    IN  PRM_OBJECT_HEADER           pOwningObject,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  PRM_GROUP                   pGroup,
    IN  const char*                 szDescription,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize a group structure.

Arguments:

    pOwningObject   - Object that will own the group.
    pStaticInfo     - Static information about objects IN the group.
    pGroup          - Uninitialized memory that is to hold the group structure. It
                      will be initialized on return from this function.
    szDescription   - (Debug only) descriptive name for this group.

    TODO: make pStaticInfo const.

--*/
{
    NdisZeroMemory(pGroup, sizeof(*pGroup));

    RMPRIVATELOCK(pOwningObject, pSR);

    do
    {
        if (!RMISALLOCATED(pOwningObject))
        {
            ASSERT(!"pObject not allocated");
            break;
        }

        if (pStaticInfo->pHashInfo == NULL)
        {
            ASSERT(!"NULL pHashInfo");
            // Static info MUST have non-NULL pHashInfo in order
            // for it to be used for groups.
            //
            break;
        }

    
        RmInitializeHashTable(
            pStaticInfo->pHashInfo,
            pOwningObject,  // pAllocationContext
            &pGroup->HashTable
            );


        pGroup->pOwningObject = pOwningObject;
        pGroup->pStaticInfo = pStaticInfo;
        pGroup->szDescription = szDescription;

        NdisAllocateSpinLock(&pGroup->OsLock);
        pGroup->fEnabled = TRUE;

    #if RM_EXTRA_CHECKING
        RmDbgAddAssociation(
            0xc0e5362f,                         // Location ID
            pOwningObject,                      // pObject
            (UINT_PTR) pGroup,                  // Instance1
            (UINT_PTR) (pGroup->szDescription), // Instance2
            RM_PRIVATE_ASSOC_INITGROUP,         // AssociationID
            szASSOCFORMAT_INITGROUP,            // szAssociationFormat
            pSR
            );
    #endif // RM_EXTRA_CHECKING

    } while (FALSE);

    RMPRIVATEUNLOCK(pOwningObject, pSR);

}


VOID
RmDeinitializeGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Deinitialize group structure pGroup. Must only be called when there are no
    members in the group.

--*/
{

#if RM_EXTRA_CHECKING
    RmDbgDeleteAssociation(
        0x1486def9,                         // Location ID
        pGroup->pOwningObject,              // pObject
        (UINT_PTR) pGroup,                  // Instance1
        (UINT_PTR) (pGroup->szDescription), // Instance2
        RM_PRIVATE_ASSOC_INITGROUP,         // AssociationID
        pSR
        );
#endif // RM_EXTRA_CHECKING

    NdisAcquireSpinLock(&pGroup->OsLock);

    RmDeinitializeHashTable(&pGroup->HashTable);

    NdisReleaseSpinLock(&pGroup->OsLock);
    NdisFreeSpinLock(&pGroup->OsLock);
    NdisZeroMemory(pGroup, sizeof(*pGroup));

}


RM_STATUS
RmLookupObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  ULONG                       Flags, // create, remove, lock
    IN  PVOID                       pvKey,
    IN  PVOID                       pvCreateParams,
    OUT PRM_OBJECT_HEADER *         ppObject,
    OUT INT *                       pfCreated, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    TODO: split this into a pure lookup and a lookupand/orcreate function..

    Lookup and/or create an object in the specified group.


#if OBSOLETE // Must allow fCreate w/o locking -- see notes.txt  entry:
               //   03/04/1999   JosephJ  Problems with deadlock when using Groups.
        MUST ONLY be NON-NULL if the fLOCKED flag is specified.
        Why? Because if the lock is not held on exit, it would be possible
        for someone else to pick up the object in the freshly-created state.
        We want to discourage that situation.
#endif // OBSOLETE

         Typically the caller specifes the
        fRM_LOCKED|fRM_CREATE flags as well as non-null pfCreated. On return, if
        *pfCreated is TRUE, the caller then would go on to do some more
        initialization before releasing the lock.

        A new important point is that if the user requests that the object be 
        created and locked, then the RM no longer guranteees that the create and 
        lock will happen in the context of holding the GroupLock
        

        FUNDAMENTAL ASSUMPTION: The key of an object doesn't change once
        it's in the group. Based on this assumption, we don't try to claim
        the object's lock when looking for the object with a matching key.

Arguments:

    pGroup          - Group in which to lookup/create object.
    Flags           - One or more of fRM_LOCKED, fRM_CREATE, fRM_NEW
    pvKey           - Key used to lookup object.
    pvCreateParams  - If object is to be created, parameters to be passed to the
                      object's creation function.
    ppObject        - Place to store pointer to the found/created object.
    pfCreated       - If non-NULL, *pfCreated is set to TRUE IFF the object was
                      created.

Return Value:

    NDIS_STATUS_SUCCESS     If the operation succeeded.
    NDIS_STATUS_RESOURCES   If a new object could not be created.
    NDIS_STATUS_RFAILURE    If the object was not found.

--*/
{
    RM_STATUS           Status          = NDIS_STATUS_FAILURE;
    BOOLEAN             fUnlockOutOfOrder = FALSE;
    PRM_OBJECT_HEADER   pOwningObject   = pGroup->pOwningObject;
    PRM_OBJECT_HEADER   pObject;

#if DBG
    KIRQL EntryIrql =  KeGetCurrentIrql();
#endif // DBG
    ENTER("RmLookupObjectInGroup",  0xd2cd6379)

    ASSERT(pOwningObject!=NULL);
    // OBSOLETE -- see comments above: ASSERT(pfCreated==NULL || (Flags&RM_LOCKED));

    if (pfCreated != NULL) *pfCreated = FALSE;

    NdisAcquireSpinLock(&pGroup->OsLock); 
    
    do
    {
        BOOLEAN fFound;
        PRM_HASH_LINK *ppLink = NULL;

        if (!RMISALLOCATED(pGroup->pOwningObject)) break;

        if (pGroup->fEnabled != TRUE)   break;

        fFound = RmLookupHashTable(
                        &pGroup->HashTable,
                        &ppLink,
                        pvKey
                        );

        if (fFound)
        {
            if (Flags & RM_NEW)
            {
                // Caller wanted us to created a new object, but the object already
                // exists, so we fail...
                //
                // TODO: return appropriate error code.
                //
                break;
            }

            // Go from hash-link to object.
            //  TODO: once HashLink goes away, need some other way to get
            //       to the object.
            //
            pObject = CONTAINING_RECORD(*ppLink, RM_OBJECT_HEADER, HashLink);
            ASSERT(pObject->pStaticInfo == pGroup->pStaticInfo);

        }
        else
        {
            if (!(Flags & RM_CREATE))
            {
                // Couldn't find it, and caller doesn't want us to create one, so
                // we fail...
                break;
            }
            
            // Create object...
            //
            ASSERTEX(pGroup->pStaticInfo->pfnCreate!=NULL, pGroup);
            pObject = pGroup->pStaticInfo->pfnCreate(
                                                pOwningObject,
                                                pvCreateParams,
                                                pSR
                                                );
            
            if (pObject == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            TR_INFO((
                "Created 0x%p (%s) in Group 0x%p (%s)\n",
                pObject,
                pObject->szDescription,
                pGroup,
                pGroup->szDescription
                ));

            ASSERTEX(RMISALLOCATED(pObject), pObject);

            // Now enter it into the hash table.
            //
            RmAddHashItem(
                &pGroup->HashTable,
                ppLink,
                &pObject->HashLink,
                pvKey
                );
            if (pfCreated != NULL)
            {
                *pfCreated = TRUE;
            }

        }

        RmTmpReferenceObject(pObject, pSR);

        Status = NDIS_STATUS_SUCCESS;

    } while(FALSE);

    NdisReleaseSpinLock(&pGroup->OsLock);

    // Do we need to look the object before returning it
    // to the user
    if ((!FAIL(Status)) && (Flags & RM_LOCKED))
    {
        RmWriteLockObject(
                pObject,   
            #if RM_EXTRA_CHECKING
                0x6197fdda,
            #endif //RM_EXTRA_CHECKING
                pSR
                );

        if  (!RMISALLOCATED(pObject))
        {
            // We don't allow this...
            RmUnlockObject(
                pObject,
                pSR
                );
        }
    }
    
    if (FAIL(Status))
    {
        *ppObject = NULL;
    }
    else
    {
        *ppObject = pObject;
    }

#if DBG
    {
        KIRQL ExitIrql =  KeGetCurrentIrql();
        TR_VERB(("Exiting. EntryIrql=%lu, ExitIrql = %lu\n", EntryIrql, ExitIrql));
    }
#endif //DBG

    return Status;
}


RM_STATUS
RmGetNextObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pCurrentObject, // OPTIONAL
    OUT PRM_OBJECT_HEADER *         ppNextObject,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Get the 1st object in group (if pCurrentObject == NULL), or the object
    "after" pCurrentObject (if pCurrentObject != NULL).
    
    The definition of "after" is hidden -- the only guarantee is if this
    function is 1st called with NULL pCurrentObject and subsequently with
    pCurrentObject set to the value previously returned in ppNextObject, until
    the function returns NDIS_STATUS_FAILURE, all objects in the group will
    be returned once and only once. This guarantee is only valid if no objects
    are added or removed during the enumeration process.

    On success, the "next" object is tmpref'd a pointer to it is saved in
    *ppNextObject.

Arguments:

    pGroup          - The group
    pCurrentObject  - (OPTIONAL) An object in the group.
    ppNextObject    - Place to return the the object  "after" pCurrentObject
                      (see RoutineDescription for details.)
                     

Return Value:

    NDIS_STATUS_SUCCESS if we could find a "next" object.
    NDIS_STATUS_FAILURE otherwise

--*/
{
    RM_STATUS           Status          = NDIS_STATUS_FAILURE;
    PRM_OBJECT_HEADER   pOwningObject   = pGroup->pOwningObject;
    PRM_OBJECT_HEADER   pObject;

    ENTER("RmGetNextObjectInGroup",  0x11523db7)

    ASSERT(pOwningObject!=NULL);

    NdisAcquireSpinLock(&pGroup->OsLock);

    do
    {
        BOOLEAN fFound;
        PRM_HASH_LINK pLink = NULL;
        PRM_HASH_LINK pCurrentLink = NULL;

        if (!RMISALLOCATED(pGroup->pOwningObject)) break;

        if (pGroup->fEnabled != TRUE)   break;

        if (pCurrentObject != NULL)
        {
            pCurrentLink = &pCurrentObject->HashLink;
        }

        fFound =  RmNextHashTableItem(
                        &pGroup->HashTable,
                        pCurrentLink,   // pCurrentLink
                        &pLink  // pNextLink
                        );

        if (fFound)
        {

            // Go from hash-link to object.
            //  TODO: once HashLink goes away, need some other way to get
            //       to the object.
            //
            pObject = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
            ASSERT(pObject->pStaticInfo == pGroup->pStaticInfo);

        }
        else
        {
            // Couldn't find one.
            // we fail...
            break;
        }

        RmTmpReferenceObject(pObject, pSR);

        Status = NDIS_STATUS_SUCCESS;

    } while(FALSE);

    NdisReleaseSpinLock(&pGroup->OsLock);

    if (FAIL(Status))
    {
        *ppNextObject = NULL;
    }
    else
    {
        *ppNextObject = pObject;
    }

    return Status;
}


VOID
RmFreeObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  struct _RM_TASK             *pTask, OPTIONAL  // Unused. TODO: remove this.
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Remove object pObject from group pGroup and deallocate pObject.

--*/
{
    ENTER("RmFreeObjectInGroup",  0xd2cd6379)
    PRM_OBJECT_HEADER pOwningObject = pGroup->pOwningObject;

    ASSERTEX(pOwningObject!=NULL, pGroup);
    ASSERTEX(pTask==NULL, pGroup);

    NdisAcquireSpinLock(&pGroup->OsLock);

    // TODO: what if at this time, someone else is doing FreeAllObjects in Group?
    //
    TR_INFO((
        "Freeing 0x%p (%s) in Group 0x%p (%s)\n",
        pObject,
        pObject->szDescription,
        pGroup,
        pGroup->szDescription
        ));

    ASSERTEX(RMISALLOCATED(pObject), pObject);

    RmRemoveHashItem(
            &pGroup->HashTable,
            &pObject->HashLink
            );

    NdisReleaseSpinLock(&pGroup->OsLock);

    // Deallocate the object.
    //
    RmDeallocateObject(
                pObject,
                pSR
                );

    EXIT()
}


VOID
RmFreeAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  struct _RM_TASK             *pTask, OPTIONAL // Unused. TODO: remove this.
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Remove and deallocate all object in pGroup.

--*/
{
    PRM_HASH_LINK *ppLink, *ppLinkEnd;
    NdisAcquireSpinLock(&pGroup->OsLock);
    if (pGroup->fEnabled)
    {
        pGroup->fEnabled = FALSE;
    }
    else
    {
        NdisReleaseSpinLock(&pGroup->OsLock);
        return;                                 // EARLY RETURN
    }

    //
    // With fEnabled set to FALSE by us, we expect the following:
    // (a) pHashTable->pTable is going to stay the same size.
    // (b) No items are going to be added or removed by anyone else.
    //

    ppLink      = pGroup->HashTable.pTable;
    ppLinkEnd   = ppLink + pGroup->HashTable.TableLength;

    for ( ; ppLink < ppLinkEnd; ppLink++)
    {
        while (*ppLink != NULL)
        {
            PRM_HASH_LINK pLink =  *ppLink;
            PRM_OBJECT_HEADER pObj;
    
            // Remove it from the bucket list.
            //
            *ppLink = pLink->pNext;
            pLink->pNext = NULL;
            pGroup->HashTable.NumItems--;
    
            NdisReleaseSpinLock(&pGroup->OsLock);
    
            pObj = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
            ASSERT(pObj->pStaticInfo == pGroup->pStaticInfo);
    
            // Deallocate the object.
            //
            RmDeallocateObject(
                        pObj,
                        pSR
                        );
        
            NdisAcquireSpinLock(&pGroup->OsLock);
        }
    }

    NdisReleaseSpinLock(&pGroup->OsLock);
}


VOID
RmUnloadAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    PFN_RM_TASK_ALLOCATOR           pfnUnloadTaskAllocator,
    PFN_RM_TASK_HANDLER             pfnUnloadTaskHandler,
    PVOID                           pvUserParam,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  UINT                        uTaskPendCode,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Stops new objects from being added and unloads(see below) all objects
    currently in the group.

    "Unload" consists of allocating and starting a pfnUnloadTaskHask task
    on each object. The unload task is responsible for
    removing and deallocating the object from the group.

    If pTask if non-NULL, it will be resumed on completion of the unload.
    Otherwise, this function will BLOCK until the unload is complete.

Arguments:

    pGroup                  - Group to unload.
    pfnUnloadTaskAllocator  - Use to allocate the object-unload tasks.
    pfnTaskAllocator        - Function used to allocate the unload task.
    pfnUnloadTaskHandler    - The handler of the unload task
    pvUserParam             - Task creation user-param. 
                            WARNING: this param must be valid for the duration
                            of the unload process, not just until this
                            function returns. Of course, if pTask is NULL,
                            the two cases are equivalent.
    pTask                   - (OPTIONAL) Task to resume when unload is complete.
                            If NULL, this function will block until the
                            unload is complete.
    uTaskPendCode           - (OPTIONAL) PendCode to use when resuming pTask.
        
--*/
{
    PRM_TASK    pUnloadTask;
    NDIS_STATUS Status;

    NdisAcquireSpinLock(&pGroup->OsLock);

    //
    // We don't check if there is already an unload task active for this group.
    // Instead we go ahead and allocate and start an unload task. This latter
    // task will pend on the already running unload task if there is on.
    //

    // Allocate a private task to coordinate the unloading of all the objects.
    //
    Status =    rmAllocatePrivateTask(
                            pGroup->pOwningObject,
                            rmTaskUnloadGroup,
                            0,
                            "Task:UnloadAllObjectsInGroup",
                            &pUnloadTask,
                            pSR
                            );

    if (FAIL(Status))
    {
        //
        // Ouch -- ugly failure...
        //
        ASSERT(FALSE);

        NdisReleaseSpinLock(&pGroup->OsLock);

    }
    else
    {
        TASK_UNLOADGROUP *pUGTask =  (TASK_UNLOADGROUP *) pUnloadTask;

        pUGTask->pGroup                     = pGroup;
        pUGTask->pfnTaskUnloadObjectHandler =    pfnUnloadTaskHandler;
        pUGTask->pfnUnloadTaskAllocator     =   pfnUnloadTaskAllocator;

        if (pTask == NULL)
        {

            // Set up an event which we'll wait on. The event will be signaled
            // by pUnloadTask when it completes.
            //
            NdisInitializeEvent(&pUGTask->BlockEvent);
            pUGTask->fUseEvent = TRUE;

            // Tmpref it so pUnloadTask will stay around even afer it's
            // completed -- because we wait on the event that's actually
            // located in the task memory.
            //
            RmTmpReferenceObject(&pUnloadTask->Hdr, pSR);
        }

        NdisReleaseSpinLock(&pGroup->OsLock);

        if (pTask != NULL)
        {
            RmPendTaskOnOtherTask(
                    pTask,
                    uTaskPendCode,
                    pUnloadTask,
                    pSR
                    );
        }

        Status = RmStartTask(pUnloadTask, 0, pSR);

        if (pTask == NULL)
        {
            NdisWaitEvent(&pUGTask->BlockEvent, 0);
            RmTmpDereferenceObject(&pUnloadTask->Hdr, pSR);
        }
    }
}

VOID
RmEnableGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    TODO: need better name for this.

Routine Description:

    Enables items to be added to a group.
    This function is typically called with a group which has completed
    RmUnloadAllObjectsFromGroup or RmFreeAllObjectsInGroup.
    On return from this call items may once more be added to this group.

    This call must only be called after UnloadAllObjectsInGroup or
    RmFreeAllObjectsInGroup have completed (synchronously or asynchronously).

    If there are items in in group or there is an unload
    task associated with the group at the time this function is called,
    the group is NOT reinited and the DBG version will assert.

    This function and may be called with an already enabled group, provided
    the condition above is met (no items in group, no unload task).

--*/
{
    NdisAcquireSpinLock(&pGroup->OsLock);
    if (    pGroup->pUnloadTask == NULL 
        &&  pGroup->HashTable.NumItems == 0)
    {
        pGroup->fEnabled = TRUE;
    }
    else
    {
        ASSERT("invalid state.");
    }
    NdisReleaseSpinLock(&pGroup->OsLock);
}


VOID
RmInitializeTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,    OPTIONAL
    IN  const char *                szDescription,  OPTIONAL
    IN  UINT                        Timeout,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize the specified task.

    The task is tempref'd. It is the responsibility of the caller to
    de-ref it when done. Typically this is implicitly done by calling
    RmStartTask.

Arguments:

    pTask           -   points to unitialized memory to hold the task.
    pParentObject   -   will be the parent of the task.
    pfnHandler      -   task's handler function.
    pStaticInfo     -   (OPTIONAL) Static information about the task.
    szDescription   -   (debug only, OPTIONAL) description of the task
    Timeout         -   unused
        
--*/
{
    ASSERT(!Timeout); // TODO: Timeouts unimplemented.

    NdisZeroMemory(pTask, sizeof(*pTask));

    RmInitializeHeader(
            pParentObject,
            &pTask->Hdr,
            MTAG_TASK,
            pParentObject->pLock,
            (pStaticInfo) ? pStaticInfo : &RmTask_StaticInfo,
            szDescription,
            pSR
            );
    pTask->pfnHandler = pfnHandler;
    SET_RM_TASK_STATE(pTask, RMTSKSTATE_IDLE);
    InitializeListHead(&pTask->listTasksPendingOnMe);

    RmTmpReferenceObject(&pTask->Hdr, pSR);

}


VOID
RmAbortTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
    )
{
    ASSERT(!"Unimplemented");
}



RM_STATUS
RmStartTask(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Start the specified task.

    NO locks should be held on entry and none are held on exit.
    pTask is expected to have a tmp-ref which is deref'd here.
    The task is automatically deallocated on completion (either  synchronous
    or asynchronous completion, either successful or failed completion).
    Unless the caller is explicitly added a reference to pTask before calling
    this function, the caller should not assume that pTask is still valid
    on return from this function.

Arguments:

    pTask           -   points to the task to be started.
    UserParam       -   opaque value passed to the task handler with the
                        RM_TASKOP_START message.
        
--*/
{
    ENTER("RmStartTask", 0xf80502d5)
    NDIS_STATUS Status;
    RM_ASSERT_NOLOCKS(pSR);

    RMPRIVATELOCK(&pTask->Hdr, pSR);
    if (!CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_IDLE))
    {
        ASSERTEX(!"Invalid state", pTask);
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        if (!RMISALLOCATED(pTask->Hdr.pParentObject))
        {
            //
            // TODO: consider not calling the handler if the parent object is
            // deallocated, but that may be confusing.
            // Consider not allowing children to be linked to an object
            // (RmInitializeHeader returns failure) if the parent object is
            // deallocated.
            //
            TR_WARN((
                "Starting task 0x%p (%s) with DEALLOCATED parent 0x%p (%s).\n",
                pTask,
                pTask->Hdr.szDescription,
                pTask->Hdr.pParentObject,
                pTask->Hdr.pParentObject->szDescription
                ));
        }

        SET_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING);
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

        TR_INFO((
            "STARTING Task 0x%p (%s); UserParam = 0x%lx\n",
            pTask,
            pTask->Hdr.szDescription,
            UserParam
            ));

        Status = pTask->pfnHandler(
                            pTask,
                            RM_TASKOP_START,
                            UserParam,
                            pSR
                            );

        RM_ASSERT_NOLOCKS(pSR);

        RMPRIVATELOCK(&pTask->Hdr, pSR);
        switch(GET_RM_TASK_STATE(pTask))
        {
        case RMTSKSTATE_STARTING:

            // This task is completing synchronously.
            //
            ASSERT(Status != NDIS_STATUS_PENDING);
            SET_RM_TASK_STATE(pTask, RMTSKSTATE_ENDING);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            rmEndTask(pTask, Status, pSR);
            RmDeallocateObject(&pTask->Hdr, pSR);
            break;

        case RMTSKSTATE_PENDING:
            ASSERTEX(Status == NDIS_STATUS_PENDING, pTask);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;

        case RMTSKSTATE_ENDING:
            // This task is completing synchronously and the RM_TASKOP_END
            // notification has already been sent.
            //
            // ??? ASSERT(Status != NDIS_STATUS_PENDING);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            // ??? RmDeallocateObject(&pTask->Hdr, pSR);
            break;

        default:
            ASSERTEX(FALSE, pTask);
            // Fall through ...

        case RMTSKSTATE_ACTIVE:
            // This can happen if the task is in the process of being resumed
            // in the context of some other thread. Nothing to do here...
            // (This actually happens sometimes on a MP machine).
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;
        }
        
    }

    // Remove the tmp ref added when the task was allocated.
    //
    RmTmpDereferenceObject(
                &pTask->Hdr,
                pSR
                );

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()

    return Status;
}


VOID
RmDbgDumpTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
)
{
}


RM_STATUS
RmSuspendTask(
    IN  PRM_TASK                    pTask,
    IN  UINT                        SuspendContext,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Suspends the specified task.

    RmSuspendTask is always called in the context of a task handler.
    pTask is may be locked on entry -- we don't care.

Arguments:

    pTask           -   task to be suspended.
    SuspendContext  -   context to be presented to the task's handler when
                        the task is subsequently resumed. Specifically, this 
                        context may be accessed using the RM_PEND_CODE macro,
                        when the task's handler is called with code
                        RM_TASKOP_PENDCOMPLETE.
        
--*/
{
    ENTER("RmSuspendTask", 0xd80fdc00)
    NDIS_STATUS Status;
    // RM_ASSERT_NOLOCKS(pSR);

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    TR_INFO((
        "SUSPENDING Task 0x%p (%s); SuspendContext = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        SuspendContext
        ));

    if (    !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING)
        &&  !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE))
    {
        ASSERTEX(!"Invalid state", pTask);
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        SET_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING);
        pTask->SuspendContext = SuspendContext;
        Status = NDIS_STATUS_SUCCESS;
    }

    RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

    // RM_ASSERT_NOLOCKS(pSR);

    EXIT()

    return Status;
}


VOID
RmUnsuspendTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Undoes the effect of a previous call to RmSuspendTask.

    Task MUST be in the pending state and MUST NOT be pending on another task.
    Debug version will ASSERT if above conditions are not met.

    RmUnsuspendTask is always called in the context of a task handler.
    pTask is may be locked on entry -- we don't care.

Arguments:

    pTask           -   task to be suspended.
        
--*/
{
    ENTER("RmUnsuspendTask", 0xcf713639)

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    TR_INFO((
        "UN-SUSPENDING Task 0x%p (%s). SuspendContext = 0x%x\n",
        pTask,
        pTask->Hdr.szDescription,
        pTask->SuspendContext
        ));

    ASSERT(CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING));
    ASSERT(pTask->pTaskIAmPendingOn == NULL);
    SET_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE);
    pTask->SuspendContext = 0;

    RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

    EXIT()
}


VOID
RmResumeTask(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    SuspendCompletionParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Resume a previously-suspended task.

    No locks held on entry or exit.
    
    SuspendCompletionParam is user-defined, and must be agreed upon between
    the caller of RmUnpendTask and the task that's being unpended.
    The Task's handler is ALWAYS called in the context of the caller of RmUnpendTask.
    So it is ok for the caller to declare a structure on the stack and pass
    a pointer to it as SuspendCompletionParam.

    WARNING: pTask could well be invalid (deallocate) by the time we return
    from this function. The caller is responsible for tmprefing pTask if it needs
    to access after return from this function.

Arguments:

    pTask                   -   task to be resumed.
    SuspendCompletionParam  -   arbitrary value that is passed on to the task's
                                handler as "UserParan" when the handler is called
                                with code RM_TASKOP_PENDCOMPLETE.
--*/
{
    ENTER("RmResumeTask", 0xd261f3c6)
    NDIS_STATUS Status;
    RM_ASSERT_NOLOCKS(pSR);

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    TR_INFO((
        "RESUMING Task 0x%p (%s); SuspendCompletionParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        SuspendCompletionParam
        ));

    if (!CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING))
    {
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        ASSERTEX(!"Invalid state", pTask);
    }
    else
    {
        // Add tmp ref, because we need to look at pTask after the return
        // from calling pfnHandler.
        //
        RmTmpReferenceObject(&pTask->Hdr, pSR);

        SET_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE);
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        Status = pTask->pfnHandler(
                            pTask,
                            RM_TASKOP_PENDCOMPLETE,
                            SuspendCompletionParam,
                            pSR
                            );

        RM_ASSERT_NOLOCKS(pSR);

        RMPRIVATELOCK(&pTask->Hdr, pSR);
        switch(GET_RM_TASK_STATE(pTask))
        {
        case RMTSKSTATE_ACTIVE:

            // This task is completing here (maybe)
            //
            if (Status != NDIS_STATUS_PENDING)
            {
                SET_RM_TASK_STATE(pTask, RMTSKSTATE_ENDING);
                RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
                rmEndTask(pTask, Status, pSR);
                RmDeallocateObject(&pTask->Hdr, pSR);
            }
            else
            {
                // It could be returning pending, but the state could
                // by now be active because it was completed elsewhere.
                // ASSERT(Status != NDIS_STATUS_PENDING);
                RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            }
            break;

        case RMTSKSTATE_PENDING:
            ASSERTEX(Status == NDIS_STATUS_PENDING, pTask);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;

        case RMTSKSTATE_ENDING:
            // This task is completing synchronously and the RM_TASKOP_END
            // notification has already been sent.
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;

        default:
            ASSERTEX(FALSE, pTask);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        }
        
        // Remove tmpref added above. pTask may well go away now...
        //
        RmTmpDereferenceObject(&pTask->Hdr, pSR);
    }

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
}


VOID
RmResumeTaskAsync(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    SuspendCompletionParam,
    IN  OS_WORK_ITEM            *   pOsWorkItem,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Similar to RmResumeTask, except that the task is resumed in the context
    of a work-item thread.

Arguments:
    pTask                   - see RmResumeTask
    SuspendCompletionParam  - see RmResumeTask
    pOsWorkItem             - caller supplied UNitialized work item (must stay
                              around until the task is resumed). Typically this
                              will be located within the user-specific portion
                              of pTask
--*/
{
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if RM_EXTRA_CHECKING
    //  This may seem paranoid, but is such a powerful check that it's worth it.
    //
    RmDbgAddAssociation(
        0x33d63ece,                         // Location ID
        &pTask->Hdr,                        // pObject
        (UINT_PTR) SuspendCompletionParam,  // Instance1
        (UINT_PTR) pOsWorkItem,             // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_ASYNC, // AssociationID
        szASSOCFORMAT_RESUME_TASK_ASYNC,    // szAssociationFormat
        pSR
        );
#endif // RM_EXTRA_CHECKING

    // We don't need to grab the private lock to set this, because only one
    // entity can call RmResumeTaskAsync. Note that we also ensure things are clean
    // (in the debug case) by the association added above.
    //
    pTask->AsyncCompletionParam = SuspendCompletionParam;

    NdisInitializeWorkItem(
        pOsWorkItem,
        rmWorkItemHandler_ResumeTaskAsync,
        pTask
        );

    Status = NdisScheduleWorkItem(pOsWorkItem);
    if (FAIL(Status))
    {
        ASSERT(!"NdisStatusWorkItem failed.");

        // It so happens that NdisScheudleWorkItem (current implementation
        // doesn't fail. Nevertheless, we do the best we can and actually
        // resume the task. If the caller was at dpc level and was expecting
        // the task to resume at passive, they're out of luck.
        //
        RmResumeTask(pTask, SuspendCompletionParam, pSR);
    }
}


VOID
RmResumeTaskDelayed(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    SuspendCompletionParam,
    IN  ULONG                       MsDelay,
    IN  OS_TIMER                *   pOsTimer,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Similar to RmResumeTask, except that the task is resumed in the context
    of a os timer handler which is set to fire after MsDelay milliseconds
    from the time RmResumeTaskDelayed is called.

    EXCEPTION: if someone has previously called RmResumeDelayedTaskNow, this
    task could be resumed in the context of this function call itself.

    Abort implementation notes: see notes.txt  07/14/1999 entry.

Arguments:

    pTask                   - see RmResumeTask
    SuspendCompletionParam  - see RmResumeTask
    pOsTimer                - caller supplied UNitialized timer
                              (must stay around until the task is resumed).
                              Typically this will be located within the
                              user-specific portion of pTask.
--*/
{
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if RM_EXTRA_CHECKING
    //  This may seem paranoid, but is such a powerful check that it's worth it.
    //
    RmDbgAddAssociation(
        0x33d63ece,                             // Location ID
        &pTask->Hdr,                            // pObject
        (UINT_PTR) SuspendCompletionParam,      // Instance1
        (UINT_PTR) NULL,                        // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_DELAYED,   // AssociationID
        szASSOCFORMAT_RESUME_TASK_DELAYED,      // szAssociationFormat
        pSR
        );
#endif // RM_EXTRA_CHECKING

    // Ddk states that it's best to call this function at passive level.
    //
    NdisInitializeTimer(
        pOsTimer,
        rmTimerHandler_ResumeTaskDelayed,
        pTask
        );

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    // The task-del state should NOT be "delayed"
    //
    ASSERT(RM_CHECK_STATE(pTask, RMTSKDELSTATE_MASK, 0));
    pTask->AsyncCompletionParam = SuspendCompletionParam;
    RM_SET_STATE(pTask, RMTSKDELSTATE_MASK, RMTSKDELSTATE_DELAYED);

    if (RM_CHECK_STATE(pTask, RMTSKABORTSTATE_MASK, RMTSKABORTSTATE_ABORT_DELAY))
    {
        // Oops, the delay has been aborted -- we call the tick handler now!
        //
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

        rmTimerHandler_ResumeTaskDelayed(
                NULL, // SystemSpecific1,
                pTask, // FunctionContext,
                NULL,  // SystemSpecific2,
                NULL   // SystemSpecific3
                );

    }
    else
    {
        //
        // Not currently aborting, let's set the timer.
        //
        NdisSetTimer(pOsTimer, MsDelay);

        // Very important to unlock the private lock AFTER calling set timer,
        // other wise someone could call RmResumeDelayedTaskNow BEFORE we call
        // NdisSetTimer, in which we would not end up aborting the delayed task.
        //
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
    }

}


VOID
RmResumeDelayedTaskNow(
    IN  PRM_TASK                    pTask,
    IN  OS_TIMER                *   pOsTimer,
    OUT PUINT                       pTaskResumed,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Cut's short the delay and resumes the task immediately.

    Implementation notes:  see notes.txt  07/14/1999 entry.

Arguments:

    pTask                   - see RmResumeTask
    pOsTimer                - caller supplied initialized timer
                              (must stay around until the task is resumed).
                              Typically this will be located within the
                              user-specific portion of pTask.
    pTaskResumed            - Points to a caller-supplied variable.
                              RmResumeDelayedTask sets this variable to TRUE if the
                              task was resumed as a consequence of this call, or to
                              FALSE if the task was resumed due to some other reason.
--*/
{
    UINT_PTR    CompletionParam = pTask->AsyncCompletionParam;

    *pTaskResumed = FALSE;
    ASSERTEX(RMISALLOCATED(&pTask->Hdr), pTask);

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    RM_SET_STATE(pTask, RMTSKABORTSTATE_MASK, RMTSKABORTSTATE_ABORT_DELAY);

    if (RM_CHECK_STATE(pTask, RMTSKDELSTATE_MASK, RMTSKDELSTATE_DELAYED))
    {
        BOOLEAN     TimerCanceled = FALSE;

        //
        // The task is actually delayed. Let's go ahead and cancel the timer
        // and resume the task now (which we do indirectly by calling
        // the timer handler ourselves).
        //
        NdisCancelTimer(pOsTimer, &TimerCanceled);
        if (TimerCanceled)
        {
            //
            // The timer was actually canceled -- so we call the timer handler
            // ourselves.
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
    
            rmTimerHandler_ResumeTaskDelayed(
                    NULL, // SystemSpecific1,
                    pTask, // FunctionContext,
                    NULL,  // SystemSpecific2,
                    NULL   // SystemSpecific3
                    );
            *pTaskResumed = TRUE;
        }
        else
        {
            //
            // Hmm -- the timer is not enabled. This is either because
            // the timer handler has just been called (and not yet cleared
            // the "DELAY" state) OR someone has previously called
            // RmResumeDelayedTaskNow.
            //
            //
            // Nothing to do.
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        }
    }
    else
    {
        //
        // The task state is not delayed -- so we just set the abort state
        // and go away.
        //
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
    }
}


RM_STATUS
RmPendTaskOnOtherTask(
    IN  PRM_TASK                    pTask,
    IN  UINT                        SuspendContext,
    IN  PRM_TASK                    pOtherTask,
    IN  PRM_STACK_RECORD            pSR
    )

/*++

Routine Description:

    Pend task pTask on task pOtherTask.

    Note: RmPendTaskOnOtherTask will cause pTask's pend operation to be
    completed in the context of this call itself, if pOtherTask is already
    in the completed state.
    03/26/1999 -- see RmPendTaskOnOtherTaskV2, and also
    03/26/1999 notes.txt entry "Some proposed ..."

Arguments:

    pTask           -   task to be suspended.
    SuspendContext  -   Context associated with the suspend (see
                        RmSuspendTask for details).
    pOtherTask      -   task that pTask is to pend on.

Return Value:

    NDIS_STATUS_SUCCESS on success.
    NDIS_STATUS_FAILURE on failure (typically because pTask is not in as
                        position to be suspended.)
--*/
{
    ENTER("RmPendTaskOnOtherTask", 0x0416873e)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fResumeTask = FALSE;
    RM_ASSERT_NOLOCKS(pSR);

    TR_INFO((
        "PENDING Task 0x%p (%s) on Task 0x%p (%s). SuspendCompletionParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        pOtherTask,
        pOtherTask->Hdr.szDescription,
        SuspendContext
        ));
    //
    // WARNING: we break the locking rules here  by getting the lock on
    // both pTask and pOtherTask.
    // TODO: consider acquiring them in order of increasing numerical value.
    //
    ASSERT(pTask != pOtherTask);
    NdisAcquireSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));

    do
    {
        // Break if we can't pend pTask on pOtherTask.
        //
        {
            if (    !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING)
                &&  !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE))
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }

            // Non-NULL pTaskIAmPendingOn implies that pTask is already pending on
            // some other task!
            //
            if (pTask->pTaskIAmPendingOn != NULL)
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }
        }

        Status = NDIS_STATUS_SUCCESS;

        SET_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING);
        pTask->SuspendContext = SuspendContext;

        if (CHECK_RM_TASK_STATE(pOtherTask, RMTSKSTATE_ENDING))
        {
            //
            // Other task is done -- so we resume pTask before returning...
            //
            fResumeTask = TRUE;
            break;
        }

        //
        // pOtherTask is not ended -- add pTask to the list of tasks pending
        // on pOtherTask.
        //
        pTask->pTaskIAmPendingOn  = pOtherTask;

    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            &pTask->Hdr,
            &pOtherTask->Hdr,
            0x77c488ca,
            RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
            szASSOCFORMAT_LINK_TASKPENDINGON,
            RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
            szASSOCFORMAT_LINK_TASKBLOCKS,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(&pTask->Hdr, &pOtherTask->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        ASSERTEX(pTask->linkFellowPendingTasks.Blink == NULL, pTask);
        ASSERTEX(pTask->linkFellowPendingTasks.Flink == NULL, pTask);
        InsertHeadList(
                &pOtherTask->listTasksPendingOnMe,
                &pTask->linkFellowPendingTasks
                );

    } while(FALSE);

    NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    NdisReleaseSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    
    if (fResumeTask)
    {
            RmResumeTask(
                pTask,
                NDIS_STATUS_SUCCESS, // SuspendCompletionParam. TODO: put real code.
                pSR
                );
    }

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
    return Status;
}


RM_STATUS
RmPendOnOtherTaskV2(
    IN  PRM_TASK                    pTask,
    IN  UINT                        SuspendContext,
    IN  PRM_TASK                    pOtherTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    if pOtherTask is not complete, Pend task pTask on task pOtherTask and return
    NDIS_STATUS_PENDING. However, if pOtherTask is already complete,
    then don't pend and instead return NDIS_STATUS_SUCCESS.

    See  03/26/1999 notes.txt entry "Some proposed ...". This function
    is currently used only by rmTaskUnloadGroup, to avoid the problem describted
    in the above-referenced notes.txt entry.

    TODO: Eventually get rid of RmPendTaskOnOtherTask.

Arguments:

    See RmPendTaskOnOtherTask
    
Return Value:

    NDIS_STATUS_PENDING if pTask is pending on pOtherTask
    NDIS_STATUS_SUCCESS if pOtherTask is complete.
    NDIS_STATUS_FAILURE if there was some failure (typically pTask is not
                        in a position to be pended.)
--*/
{
    ENTER("RmPendTaskOnOtherTaskV2", 0x0e7d1b89)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    RM_ASSERT_NOLOCKS(pSR);

    TR_INFO((
        "PENDING(V2) Task 0x%p (%s) on Task 0x%p (%s). SuspendCompletionParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        pOtherTask,
        pOtherTask->Hdr.szDescription,
        SuspendContext
        ));

    // This is not a useless assert -- I'e had a bug elsewhere which caused this
    // assert to get hit.
    //
    ASSERT(pTask != pOtherTask);
    //
    // WARNING: we break the locking rules here  by getting the lock on
    // both pTask and pOtherTask.
    // TODO: consider acquiring them in order of increasing numerical value.
    //
    NdisAcquireSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));

    do
    {
        // Break if we can't pend pTask on pOtherTask.
        //
        {
            if (    !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING)
                &&  !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE))
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }

            // Non-NULL pTaskIAmPendingOn implies that pTask is already pending on
            // some other task!
            //
            if (pTask->pTaskIAmPendingOn != NULL)
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }
        }


        if (CHECK_RM_TASK_STATE(pOtherTask, RMTSKSTATE_ENDING))
        {
            //
            // Other task is done -- so we simply return success...
            //
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // pOtherTask is not ended -- set pTask state to pending, and
        // add it to the list of tasks pending on pOtherTask.
        //
        SET_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING);
        pTask->SuspendContext       = SuspendContext;
        pTask->pTaskIAmPendingOn    = pOtherTask;

    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            &pTask->Hdr,
            &pOtherTask->Hdr,
            0x77c488ca,
            RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
            szASSOCFORMAT_LINK_TASKPENDINGON,
            RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
            szASSOCFORMAT_LINK_TASKBLOCKS,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(&pTask->Hdr, &pOtherTask->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        ASSERTEX(pTask->linkFellowPendingTasks.Blink == NULL, pTask);
        ASSERTEX(pTask->linkFellowPendingTasks.Flink == NULL, pTask);
        InsertHeadList(
                &pOtherTask->listTasksPendingOnMe,
                &pTask->linkFellowPendingTasks
                );
        Status = NDIS_STATUS_PENDING;

    } while(FALSE);

    NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    NdisReleaseSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    
    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
    return Status;
}


VOID
RmCancelPendOnOtherTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_TASK                    pOtherTask,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Resume task pTask which is currently pending on pOtherTask.

    Since no locks are held, pOtherTask needs to be specified, to make sure
    that pTask is indeed pending on pOtherTask before canceling the pend.

    If pTask is indeed pending on pOtherTask, this function will cause the
    completion of the pend status with the specified user param.

    Has no effect if the task is not pending.

Arguments:

    pTask       - Task to be "unpended"
    pOtherTask  - Task pTask is currently pending on.
    UserParam   - Passed to pTask's handler if and when pTask is resumed.

--*/
{
    ENTER("RmCancelPendOnOtherTask", 0x6e113266)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fResumeTask = FALSE;
    RM_ASSERT_NOLOCKS(pSR);

    //
    // WARNING: we break the locking rules here  by getting the lock on
    // both pTask and pOtherTask.
    // TODO: consider acquiring them in order of increasing numerical value.
    //

    TR_INFO((
        "CANCEL PEND of Task 0x%p (%s) on other Task 0x%p (%s); UserParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        pOtherTask,
        pOtherTask->Hdr.szDescription,
        UserParam
        ));

    // With pTask locked, tmp ref the task it is pending on, if any...
    //
    {
        NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
        if (pOtherTask == pTask->pTaskIAmPendingOn)
        {
            RmTmpReferenceObject(&(pOtherTask->Hdr), pSR);
        }
        else
        {
            // Oops -- pTask is not pending on pOtherTask ...
            //
            pOtherTask = NULL;
        }
        NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    }

    if (pOtherTask == NULL) return;                 // EARLY RETURN


    NdisAcquireSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));

    do
    {
        // Now that we have both task's locks, check again if pTask is pending
        // on pOtherTask
        //
        if (pTask->pTaskIAmPendingOn != pOtherTask)
        {
            // Oops -- the situation is different than when we started -- quietly
            // get out of here...
            //
            break;
        }

        pTask->pTaskIAmPendingOn = NULL;

    #if RM_EXTRA_CHECKING
        RmUnlinkObjectsEx(
            &pTask->Hdr,
            &pOtherTask->Hdr,
            0x6992b7a1,
            RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
            RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmUnlinkObjects(&pTask->Hdr, &pOtherTask->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        RemoveEntryList(&pTask->linkFellowPendingTasks);
        pTask->linkFellowPendingTasks.Flink = NULL;
        pTask->linkFellowPendingTasks.Blink = NULL;

        if (CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING))
        {
            fResumeTask = TRUE;
        }
        else
        {
            //
            // We shouldn't get here -- after we are pending on another task...
            //
            ASSERTEX(!"Invalid state", pTask);
            break;
        }

    } while (FALSE);

    NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    NdisReleaseSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    RmTmpDereferenceObject(&(pOtherTask->Hdr), pSR);
    
    if (fResumeTask)
    {
            RmResumeTask(
                pTask,
                UserParam, // SuspendCompletionParam
                pSR
                );
    }

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
}



VOID
RmInitializeHashTable(
    PRM_HASH_INFO pHashInfo,
    PVOID         pAllocationContext,
    PRM_HASH_TABLE pHashTable
    )
/*++

Routine Description:

    Initialize a hash table data structure.
    Caller is responsible for serializing access to the hash table structure.

Arguments:

    pHashInfo           - Points to static information about the hash table
    pAllocationContext  - Passed to the allocation and deallocation functions
                          (pHashInfo->pfnTableAllocator and
                          pHashInfo0->pfnTableDeallocator) which are used to
                          dynamically grow /shrink the hash table.
    pHashTable          - Points to uninitialized memory that is to contain the
                          hash table.
--*/
{

    NdisZeroMemory(pHashTable, sizeof(*pHashTable));

    pHashTable->pHashInfo = pHashInfo;
    pHashTable->pAllocationContext = pAllocationContext;
    pHashTable->pTable =  pHashTable->InitialTable;
    pHashTable->TableLength = sizeof(pHashTable->InitialTable)
                                /sizeof(pHashTable->InitialTable[0]);
}

VOID
RmDeinitializeHashTable(
    PRM_HASH_TABLE pHashTable
    )
/*++

Routine Description:

    Deinitialize a previously-initialized a hash table data structure.
    There must be no items in the hash table when this function is called.

    Caller is responsible for serializing access to the hash table structure.

Arguments:

    pHashTable          - Hash table to be deinitialized.

--*/
{
    PRM_HASH_LINK *pTable = pHashTable->pTable;
    
    ASSERTEX(pHashTable->NumItems == 0, pHashTable);

    if (pTable != pHashTable->InitialTable)
    {
        NdisZeroMemory(pTable, pHashTable->TableLength*sizeof(*pTable));

        pHashTable->pHashInfo->pfnTableDeallocator(
                                    pTable,
                                    pHashTable->pAllocationContext
                                    );
    }

    NdisZeroMemory(pHashTable, sizeof(*pHashTable));

}


BOOLEAN
RmLookupHashTable(
    PRM_HASH_TABLE      pHashTable,
    PRM_HASH_LINK **    pppLink,
    PVOID               pvRealKey
    )
/*++

Routine Description:

    Lookup an item in the hash table and/or find the place where the item
    is to be inserted.

    Caller is expected to serialize access to the hash table.
    OK to use read-locks to serialize access.

    Return value: TRUE if item found; false otherwise.
    On return, *pppLink is set to a the location containing a pointer to
    a RM_HASH_LINK. If the return value is TRUE, the latter pointer points
    to the found RM_HASH_LINK. If the return value is FALSE, the location
    is where the item is to be inserted, if required.

Arguments:

    pHashTable          - Hash table to look up
    pppLink             - place to store a pointer to a link which points
                          to an item (see above for details).
    pvRealKey           - Key used to lookup item.

Return Value:
    
    TRUE    if item is found
    FALSE   otherwise.

--*/
{
    PRM_HASH_LINK *ppLink, pLink;
    UINT LinksTraversed = 0;
    UINT TableLength = pHashTable->TableLength;
    PFN_RM_COMPARISON_FUNCTION pfnCompare =  pHashTable->pHashInfo->pfnCompare;
    BOOLEAN fRet = FALSE;
    ULONG               uHash = pHashTable->pHashInfo->pfnHash(pvRealKey);

    for (
        ppLink = pHashTable->pTable + (uHash%TableLength);
        (pLink = *ppLink) != NULL;
        ppLink = &(pLink->pNext), LinksTraversed++)
    {
        if (pLink->uHash == uHash
            && pfnCompare(pvRealKey, pLink))
        {
            // found it
            //
            fRet = TRUE;
            break;
        }
    }

    // Update stats
    //
    rmUpdateHashTableStats(&pHashTable->Stats, LinksTraversed);
    
    *pppLink = ppLink;

    return fRet;
}


BOOLEAN
RmNextHashTableItem(
    PRM_HASH_TABLE      pHashTable,
    PRM_HASH_LINK       pCurrentLink,   // OPTIONAL
    PRM_HASH_LINK *    ppNextLink
    )
/*++

Routine Description:

    Find the first (if pCurrentLink is NULL) or "next" (if pCurrentLink is not NULL)
    item in the hash table.

    Caller is expected to serialize access to the hash table.
    OK to use read-locks to serialize access.

    NOTE: The "next" item returned is in no particular order.

Arguments:

    pHashTable          - Hash table to look up
    pCurrentLink        - if non-NULL, points to an existing hash link in the
                          hash table.
    ppLinkLink          - place to store a pointer to the link "after"
                          pCurrentLink, or the first link (if pCurrentLink is NULL).

Return Value:
    
    TRUE    if there is a "next" item.
    FALSE   otherwise.

--*/
{
    PRM_HASH_LINK pLink, *ppLink, *ppLinkEnd;
    UINT TableLength;

    ppLink      = pHashTable->pTable;
    TableLength = pHashTable->TableLength;
    ppLinkEnd   = ppLink + TableLength;

    if (pCurrentLink != NULL)
    {

    #if DBG
        {
            // Make sure this link is valid!
            pLink =  *(ppLink + (pCurrentLink->uHash % TableLength));
            while (pLink != NULL && pLink != pCurrentLink)
            {
                pLink = pLink->pNext;
            }
            if (pLink != pCurrentLink)
            {
                ASSERTEX(!"Invalid pCurrentLink", pCurrentLink);
                *ppNextLink = NULL;
                return FALSE;                           // EARLY RETURN
            }
        }
    #endif // DBG

        if (pCurrentLink->pNext != NULL)
        {
            // Found a next link.
            //
            *ppNextLink = pCurrentLink->pNext;
            return TRUE;                            // EARLY RETURN
        }
        else
        {
            // End of current bucket, move to next one.
            // We check later if we've gone past the end of the table.
            //
            ppLink +=  (pCurrentLink->uHash % TableLength) + 1;
        }
    }


    // Look for next non-null item.
    //
    for ( ; ppLink < ppLinkEnd; ppLink++)
    {
        pLink =  *ppLink;
        if (pLink != NULL)
        {
            *ppNextLink = pLink;
            return TRUE;                        // EARLY RETURN
        }
    }

    *ppNextLink = NULL;
    return FALSE;
}


VOID
RmAddHashItem(
    PRM_HASH_TABLE  pHashTable,
    PRM_HASH_LINK * ppLink,
    PRM_HASH_LINK   pLink,
    PVOID           pvKey
    )
/*++

Routine Description:

    Add an item to the hash table at the specified location.
    Caller is expected to serialize access to the hash table.

Arguments:

    pHashTable      - Hash table in which to add item.
    ppLink          - Points to place within table to add new item.
    pLink           - New item to add.
    pvKey           - key associated with the item.

    TODO: pvKey is only used to compute uHash -- consider passing in uHash directly.

--*/
{
    pLink->uHash = pHashTable->pHashInfo->pfnHash(pvKey);
    pLink->pNext = *ppLink;
    *ppLink = pLink;

    pHashTable->NumItems++;

    // TODO: if required, resize
}

VOID
RmRemoveHashItem(
    PRM_HASH_TABLE  pHashTable,
    PRM_HASH_LINK   pLinkToRemove
    )
/*++

Routine Description:

    Remove an item from the hash table.
    Caller is expected to serialize access to the hash table.

    (debug only): Asserts if pLinkToRemove is no in the hash table.

Arguments:

    pHashTable      - Hash table in which to add item.
    pLinkToRemove   - Link to remove.

--*/
{
    PRM_HASH_LINK *ppLink, pLink;
    UINT TableLength = pHashTable->TableLength;
    ULONG uHash = pLinkToRemove->uHash;
    BOOLEAN     fFound = FALSE;

    for (
        ppLink = pHashTable->pTable + (uHash%TableLength);
        (pLink = *ppLink) != NULL;
        ppLink = &(pLink->pNext))
    {
        if (pLink == pLinkToRemove)
        {
            // found it -- remove it and get out.
            //
            RM_PRIVATE_UNLINK_NEXT_HASH(pHashTable, ppLink);
            pLink->pNext = NULL; // Important, so that enumeration works.
            fFound=TRUE;
            break;
        }
    }

    // TODO: if required, resize

    ASSERT(fFound);
}


VOID
RmEnumHashTable(
    PRM_HASH_TABLE          pHashTable,
    PFN_ENUM_HASH_TABLE     pfnEnumerator,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Calls function pfnEnumerator for each item in the hash table.
    Caller is expected to serialize access to the hash table.

Arguments:

    pHashTable      - Hash table to enumerate.
    pfnEnumerator   - Enumerator function.
    pvContext       - Opaque context passed to enumerator function.

--*/
{
    PRM_HASH_LINK *ppLink, *ppLinkEnd;

    ppLink      = pHashTable->pTable;
    ppLinkEnd   = ppLink + pHashTable->TableLength;

    for ( ; ppLink < ppLinkEnd; ppLink++)
    {
        PRM_HASH_LINK pLink =  *ppLink;
        while (pLink != NULL)
        {

            pfnEnumerator(
                pLink,
                pvContext,
                pSR 
                );
    
            pLink = pLink->pNext;
        }
    }
}


VOID
RmEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnEnumerator,
    PVOID                   pvContext,
    INT                     fStrong,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Calls function pfnEnumerator for each item in the group, until
    the funcition return FALSE.

    WARNING: Enumeration is "STRONG" -- the group lock
    is held during the whole enumeration process. The
    enumerator function is therefore called at DPR level, and more importantly,
    the enumerator function avoid locking anything to avoid risk of deadlock.
    Specifically, the enumerator function MUST NOT lock the object -- if any other
    thread has called a group-related RM function with the object's lock held,
    we WILL deadlock.

    This function should only be used to access parts of the object that do
    not need to be protected by the objects lock.

    If locking needs to be performed, use RmWeakEnumerateObjectsInGroup.

Arguments:

    pGroup          - Hash table to enumerate.
    pfnEnumerator   - Enumerator function.
    pvContext       - Opaque context passed to enumerator function.
    fStrong         - MUST be TRUE.
--*/
{

    if (fStrong)
    {
        RM_STRONG_ENUMERATION_CONTEXT Ctxt;
        Ctxt.pfnObjEnumerator = pfnEnumerator;
        Ctxt.pvCallerContext = pvContext;
        Ctxt.fContinue           = TRUE;

        NdisAcquireSpinLock(&pGroup->OsLock);

        RmEnumHashTable(
                    &pGroup->HashTable,
                    rmEnumObjectInGroupHashTable,   // pfnEnumerator
                    &Ctxt,                          // context
                    pSR
                    );

        NdisReleaseSpinLock(&pGroup->OsLock);
    }
    else
    {
        ASSERT(!"Unimplemented");
    }

}


VOID
RmWeakEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnEnumerator,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Calls function pfnEnumerator for each item in the group, until
    the funcition return FALSE.

    Enumeration is "WEAK" -- the group lock is
    NOT held the whole time, and is not held when the enumerator
    function is called.

    A snapshot of the entire group is first taken with the group lock held,
    and each object is tempref'd. The group lock is then released and the
    enumerator function is called for each object in the snapshot. 
    The objects are then derefd.

    NOTE: It is possible that when the enumeration function is called for an
    object, the object is no longer in the group. The enumeration function can
    lock the object and check its internal state to determine if it is still
    relevant to process the object.

Arguments:

    pGroup          - Hash table to enumerate.
    pfnEnumerator   - Enumerator function.
    pvContext       - Opaque context passed to enumerator function.


--*/
{
    #define RM_SMALL_GROUP_SIZE         10
    #define RM_MAX_ENUM_GROUP_SIZE      100000
    PRM_OBJECT_HEADER *ppSnapshot;
    PRM_OBJECT_HEADER SmallSnapshot[RM_SMALL_GROUP_SIZE];
    UINT NumItems = pGroup->HashTable.NumItems;

    do
    {
        RM_WEAK_ENUMERATION_CONTEXT Ctxt;

        if (NumItems <= RM_SMALL_GROUP_SIZE)
        {
            if (NumItems == 0) break;
            ppSnapshot = SmallSnapshot;
        }
        else if (NumItems > RM_MAX_ENUM_GROUP_SIZE)
        {
            // TODO: LOG_RETAIL_ERROR
            ASSERT(FALSE);
            break;
        }
        else
        {
            RM_ALLOC(
                    &(void* )ppSnapshot,
                    NumItems*sizeof(PRM_OBJECT_HEADER),
                    MTAG_RMINTERNAL
                    );

            if (ppSnapshot == NULL)
            {
                ASSERT(FALSE);
                break;
            }
        }

        Ctxt.ppCurrent = ppSnapshot;
        Ctxt.ppEnd     = ppSnapshot+NumItems;

        NdisAcquireSpinLock(&pGroup->OsLock);
    
        RmEnumHashTable(
                    &pGroup->HashTable,
                    rmConstructGroupSnapshot,   // pfnEnumerator
                    &Ctxt,                      // context
                    pSR
                    );
    
        NdisReleaseSpinLock(&pGroup->OsLock);

        ASSERT(Ctxt.ppCurrent >= ppSnapshot);
        ASSERT(Ctxt.ppCurrent <= Ctxt.ppEnd);

        // Fix up ppEnd to point to the last actually-filled pointer.
        //
        Ctxt.ppEnd = Ctxt.ppCurrent;
        Ctxt.ppCurrent = ppSnapshot;

        for  (;Ctxt.ppCurrent < Ctxt.ppEnd; Ctxt.ppCurrent++)
        {
            pfnEnumerator(
                    *Ctxt.ppCurrent,
                    pvContext,
                    pSR
                    );
            RmTmpDereferenceObject(*Ctxt.ppCurrent, pSR);
        }

        if (ppSnapshot != SmallSnapshot)
        {
            RM_FREE(ppSnapshot);
            ppSnapshot = NULL;
        }

    } while (FALSE);
}


//=========================================================================
//                  L O C A L   F U N C T I O N S
//=========================================================================


VOID
rmDerefObject(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Dereference object pObject. Deallocate it if the reference count goes to zero.

--*/
{
    ULONG Refs;
    ENTER("rmDerefObject", 0x5f9d81dd)

    ASSERT(RM_OBJECT_IS_ALLOCATED(pObject));

    //
    // On entry, the ref count should be at-least 2 -- one the
    // explicit ref added in RmAllocateObject, and the 2nd the ref due to
    // the link to the parent.
    //
    // Exception to the above: if the object has no parent, the refcount should be
    // at-least 1.
    //

    // Deref the ref added in RmAllocateObject, and if the ref count is now <=1, 
    // we actually unlink and free the object.
    //
    Refs = NdisInterlockedDecrement(&pObject->TotRefs);

    if (Refs <= 1)
    {
        PRM_OBJECT_HEADER pParentObject;
        RMPRIVATELOCK(pObject, pSR);

        //
        // Unlink from parent, if there is one...
        //
    
        pParentObject =  pObject->pParentObject;
        pObject->pParentObject = NULL;

    #if RM_TRACK_OBJECT_TREE
        // Verify that there are no siblings...
        //
        RETAILASSERTEX(IsListEmpty(&pObject->listChildren), pObject);
    #endif // RM_TRACK_OBJECT_TREE

        RMPRIVATEUNLOCK(pObject, pSR);

        if (pParentObject != NULL)
        {
            ASSERTEX(!RMISALLOCATED(pObject), pObject);

            ASSERTEX(Refs == 1, pObject);

        #if RM_TRACK_OBJECT_TREE
            RMPRIVATELOCK(pParentObject, pSR);

            // Remove object from parent's list of children.
            //
            RETAILASSERTEX(
                !IsListEmpty(&pParentObject->listChildren),
                pObject);
            RemoveEntryList(&pObject->linkSiblings);

            RMPRIVATEUNLOCK(pParentObject, pSR);
        #endif // RM_TRACK_OBJECT_TREE

    #if RM_EXTRA_CHECKING
        RmUnlinkObjectsEx(
            pObject,
            pParentObject,
            0xac73e169,
            RM_PRIVATE_ASSOC_LINK_CHILDOF,
            RM_PRIVATE_ASSOC_LINK_PARENTOF,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
            RmUnlinkObjects(pObject, pParentObject, pSR);
    #endif // !RM_EXTRA_CHECKING

        }
        else if (Refs == 0)
        {
            //
            // Free to deallocate this thing...
            //

            ASSERTEX(!RMISALLOCATED(pObject), pObject);

            #if RM_EXTRA_CHECKING
            rmDbgDeinitializeDiagnosticInfo(pObject, pSR);
            #endif // RM_EXTRA_CHECKING

            RM_MARK_OBJECT_AS_DEALLOCATED(pObject);

            if (pObject->pStaticInfo->pfnDelete!= NULL)
            {

                TR_INFO((
                    "Actually freeing 0x%p (%s)\n",
                    pObject,
                    pObject->szDescription
                    ));

                pObject->pStaticInfo->pfnDelete(pObject, pSR);
            }
        }
    }

    EXIT()
}

VOID
rmLock(
    PRM_LOCK                pLock,
#if RM_EXTRA_CHECKING
    UINT                    uLocID,
    PFNLOCKVERIFIER         pfnVerifier,
    PVOID                   pVerifierContext,
#endif //RM_EXTRA_CHECKING
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Lock pLock.

Arguments:

    pLock               - Lock to lock.
    LocID               - Arbitrary ID, typically representing the source location
                          from which this function is called.
    
    Following are for debug only:

    pfnVerifier         - Optional function that is called just after locking
    pfnVerifierContext  - Passed in call to pfnVerifier

--*/
{
    //UINT Level  = pSR->LockInfo.CurrentLevel;
    RM_LOCKING_INFO li;

    RETAILASSERTEX(pLock->Level > pSR->LockInfo.CurrentLevel, pLock);
    RETAILASSERTEX(pSR->LockInfo.pNextFree < pSR->LockInfo.pLast, pLock);

    pSR->LockInfo.CurrentLevel = pLock->Level;

    // Save information about this lock in the stack record.
    //
    li.pLock = pLock;
#if RM_EXTRA_CHECKING
    li.pfnVerifier = pfnVerifier;
    li.pVerifierContext = pVerifierContext;
#endif //RM_EXTRA_CHECKING
    *(pSR->LockInfo.pNextFree++) = li; // struct copy.

    // Get the lock.
    // TODO: uncomment the following optimization...
    //if (Level)
    //{
    //  NdisDprAcquireSpinLock(&pLock->OsLock);
    //}
    //else
    //{
    NdisAcquireSpinLock(&pLock->OsLock);
    //}

#if RM_EXTRA_CHECKING

    ASSERTEX(pLock->DbgInfo.uLocID == 0, pLock);
    ASSERTEX(pLock->DbgInfo.pSR == NULL, pLock);
    pLock->DbgInfo.uLocID = uLocID;
    pLock->DbgInfo.pSR = pSR;
    // Call the verifier routine if there is one.
    //
    if (pfnVerifier)
    {
        pfnVerifier(pLock, TRUE, pVerifierContext, pSR);
    }
#endif //RM_EXTRA_CHECKING

}


VOID
rmUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Unlock pLock.

    Debug only: if there is a verifier function associated with this lock
    we call it just before unlocking pLock.

Arguments:

    pLock               - Lock to unlock.

--*/
{
    RM_LOCKING_INFO * pLI;
    pSR->LockInfo.pNextFree--;
    pLI = pSR->LockInfo.pNextFree;
    RETAILASSERTEX(pLI->pLock == pLock, pLock);

    ASSERTEX(pLock->DbgInfo.pSR == pSR, pLock);
    ASSERTEX(pLock->Level == pSR->LockInfo.CurrentLevel, pLock);

    pLI->pLock = NULL;

    if (pLI > pSR->LockInfo.pFirst)
    {
        PRM_LOCK pPrevLock =  (pLI-1)->pLock;
        pSR->LockInfo.CurrentLevel = pPrevLock->Level;
        ASSERTEX(pPrevLock->DbgInfo.pSR == pSR, pPrevLock);
    }
    else
    {
        pSR->LockInfo.CurrentLevel = 0;
    }


#if RM_EXTRA_CHECKING

    // Call the verifier routine if there is one.
    //
    if (pLI->pfnVerifier)
    {
        pLI->pfnVerifier(pLock, FALSE, pLI->pVerifierContext, pSR);
        pLI->pfnVerifier = NULL;
        pLI->pVerifierContext = NULL;
    }
    pLock->DbgInfo.uLocID = 0;
    pLock->DbgInfo.pSR = NULL;

#endif //RM_EXTRA_CHECKING


    // Release the lock.
    //
    NdisReleaseSpinLock(&pLock->OsLock);
}


#if RM_EXTRA_CHECKING
ULONG
rmPrivateLockVerifier(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    (Debug only)

    The Verifier function for an object's RmPrivateLock.

Arguments:

    pLock               - Lock being locked/unlocked
    fLock               - TRUE if lock has just been locked.
                          FALSE if lock is about to be unlocked.
Return Value:

    Unused: TODO make return value VOID.

--*/
{
    ENTER("rmPrivateLockVerifier", 0xc3b63ac5)
    TR_VERB(("Called with pLock=0x%p, fLock=%lu, pContext=%p\n",
                pLock, fLock, pContext, pSR));
    EXIT()

    return 0;
}

ULONG
rmVerifyObjectState(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    (Debug only)

    Uses the object's verification function (if there is one) to
    compute a signature that is checked each time the object is locked,
    and is updated each time the object is unlocked. Assert if this signature
    has changed while the object was supposedly unlocked.

    Also: Update RM_OBJECT_HEADER.pDiagInfo->PrevState if there is been a
    change of state while the object was locked.

Arguments:

    pLock               - Lock being locked/unlocked
    fLock               - TRUE if lock has just been locked.
                          FALSE if lock is about to be unlocked.
    pContext            - Actually pointer to object being locked.

Return Value:

    Unused: TODO make return value VOID.

--*/
{
    PRM_OBJECT_HEADER pObj = (PRM_OBJECT_HEADER) pContext;
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObj->pDiagInfo;
    ULONG NewChecksum;
    ENTER("rmVerifyObjectState", 0xb8ff7a67)
    TR_VERB(("Called with pLock=0x%p, fLock=%lu, pObj=%p\n",
                pLock, fLock, pObj, pSR));

    if (pDiagInfo != NULL
        && !(pDiagInfo->DiagState & fRM_PRIVATE_DISABLE_LOCK_CHECKING))

    {
        
        // Compute the new checksum and as part of that call the
        // object-specific verifier if there is one....
        //
        {
            PFNLOCKVERIFIER         pfnVerifier;

            // We verify that the objset-specific state was not modified
            // without the lock held. This is done by including the object-specific
            // state in the checksum computation.
            //
            NewChecksum = pObj->State;
    
            // Then, if the object has a verifier function, we call it, and 
            // fold in the return value into the checkum.
            //
            pfnVerifier = pObj->pStaticInfo->pfnLockVerifier;
            if (pfnVerifier != NULL)
            {
                NewChecksum ^= pfnVerifier(pLock, fLock, pObj, pSR);
    
            }
        }

        if (fLock)  // We've just locked the object.
        {

            // First thing we do is to save the current value of pObj->State in
            // the TmpState location -- we'll look at it again on unlocking.
            //
            pDiagInfo->TmpState = pObj->State;


            // Now we compare the new checksum value with the value that wase
            // saved the last time this object was locked...
            // Special case: old Checksum was 0 -- as it is on initialization.
            //
            if (NewChecksum != pDiagInfo->Checksum && pDiagInfo->Checksum)
            {
                TR_WARN((
                    "Object 0x%p (%s) possibly modified without lock held!\n",
                    pObj,
                    pObj->szDescription
                    ));

            // Unfortunately we hit this assert because there are places where
            // the same lock is shared by many objects and 
            #if 0
                // Give users the option to ignore further validation on this 
                // object.
                //
                TR_FATAL((
                    "To skip this assert, type \"ed 0x%p %lx; g\"\n",
                    &pDiagInfo->DiagState,
                    pDiagInfo->DiagState | fRM_PRIVATE_DISABLE_LOCK_CHECKING
                    ));
                ASSERTEX(!"Object was modified without lock held!", pObj);
            #endif // 0
            }
        }
        else    // We're just about to unlock the object....
        {
            // Update the signature...
            //
            pDiagInfo->Checksum = NewChecksum;

            // If there has been a change in state between locking and unlockng
            // this object, save the previous state.
            //
            if (pDiagInfo->TmpState != pObj->State)
            {
                pDiagInfo->PrevState = pDiagInfo->TmpState;
            }
        }
    }


    EXIT()

    return 0;
}
#endif // RM_EXTRA_CHECKING

VOID
rmEndTask(
    PRM_TASK            pTask,
    NDIS_STATUS         Status,
    PRM_STACK_RECORD    pSR
)
/*++

Routine Description:

    Send the RM_TASKOP_END to the task handler, and resume any tasks pending on
    pTask.

Arguments:

    pTask       - Task to end.
    Status      - Completion status -- passed on to the task handler.

--*/
{
    ENTER("rmEndtask", 0x5060d952)
    PRM_TASK pPendingTask;
    RM_ASSERT_NOLOCKS(pSR);

    TR_INFO((
        "ENDING Task 0x%p (%s); Status = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        Status
        ));

    // TODO: could change behavior so that we use the return value, but
    // currently we ignore it...
    //
    pTask->pfnHandler(
                pTask,
                RM_TASKOP_END,
                Status, // UserParam is overloaded here.
                pSR
                );

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        pPendingTask = NULL;
    
        RMPRIVATELOCK(&pTask->Hdr, pSR);
        if (!IsListEmpty(&pTask->listTasksPendingOnMe))
        {
            pPendingTask = CONTAINING_RECORD(
                                (pTask->listTasksPendingOnMe.Flink),
                                RM_TASK,
                                linkFellowPendingTasks
                                );
            RmTmpReferenceObject(&pPendingTask->Hdr, pSR);
        }
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

        if (pPendingTask != NULL)
        {

            RmCancelPendOnOtherTask(
                pPendingTask,
                pTask,
                Status,
                pSR
                );
            RmTmpDereferenceObject(&pPendingTask->Hdr, pSR);
        }
    
    }
    while(pPendingTask != NULL);

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
}


NDIS_STATUS
rmAllocatePrivateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,      OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Allocate and initialize a task of subtype RM_PRIVATE_TASK.

Arguments:

    pParentObject       - Object that is to be the parent of the allocated task.
    pfnHandler          - The task handler for the task.
    Timeout             - Unused.
    szDescription       - Text describing this task.
    ppTask              - Place to store pointer to the new task.

Return Value:

    NDIS_STATUS_SUCCESS if we could allocate and initialize the task.
    NDIS_STATUS_RESOURCES otherwise

--*/
{
    RM_PRIVATE_TASK *pRmTask;
    NDIS_STATUS Status;
    BOOLEAN fBackupTask = FALSE;

    RM_ALLOCSTRUCT(pRmTask, MTAG_TASK); // TODO use lookaside lists.
        
    *ppTask = NULL;

    
    if (pRmTask == NULL)
    {   
        pRmTask = (RM_PRIVATE_TASK*) arpGetBackupTask(&ArpGlobals);
        fBackupTask = TRUE;
    }
        

    if (pRmTask != NULL)
    {
        RM_ZEROSTRUCT(pRmTask);

        RmInitializeTask(
                &(pRmTask->TskHdr),
                pParentObject,
                pfnHandler,
                &RmPrivateTasks_StaticInfo,
                szDescription,
                Timeout,
                pSR
                );
        *ppTask = &(pRmTask->TskHdr);

        if (fBackupTask  == TRUE)
        {
            MARK_TASK_AS_BACKUP(&pRmTask->TskHdr);
        }

        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    return Status;
}


NDIS_STATUS
rmTaskUnloadGroup(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    This task is responsible for unloading all the objects in the group.

    pTask is a pointer to TASK_UNLOADGROUP, and that structure is expected
    to be initialized, including containing the  pGroup to unload.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    TASK_UNLOADGROUP    *pMyTask = (TASK_UNLOADGROUP*) pTask;
    PRM_GROUP           pGroup = pMyTask->pGroup;
    BOOLEAN             fContinueUnload = FALSE;
    ENTER("TaskUnloadGroup", 0x964ee422)


    enum
    {
        PEND_WaitOnOtherTask,
        PEND_UnloadObject
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            // If there is already an unload task bound to pGroup, we
            // pend on it.
            //
            NdisAcquireSpinLock(&pGroup->OsLock);
            if (pGroup->pUnloadTask != NULL)
            {
                PRM_TASK pOtherTask = pGroup->pUnloadTask;
                TR_WARN(("unload task 0x%p already bound to pGroup 0x%p; pending on it.\n",
                pOtherTask, pGroup));

                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                NdisReleaseSpinLock(&pGroup->OsLock);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_WaitOnOtherTask,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
            else if (!pGroup->fEnabled)
            {
                //
                // Presumably this group has already been unloaded of all objects
                // and is simply sitting around. We complete right away.
                //
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                //
                // We're the 1st ones here -- continue on to unloading objects, if
                // any...
                //
                pGroup->pUnloadTask = pTask;
                pGroup->fEnabled = FALSE; // This will prevent new objects from
                                        // being added and from the hash table
                                        // itself from changing size.
                pMyTask->uIndex = 0;    // This keeps track of where we are in the
                                    // hash table.
                                            
                fContinueUnload = TRUE;
            }
            NdisReleaseSpinLock(&pGroup->OsLock);
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_WaitOnOtherTask:
                {
                    //
                    // Nothing to do -- finish task.
                    //
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

                case  PEND_UnloadObject:
                {
                    //
                    // Just done unloading an object; unload another if required.
                    //
                    fContinueUnload = TRUE;
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                ASSERTEX(!"Unknown pend code!", pTask);
                break;
            }

        }
        break;


        case  RM_TASKOP_END:
        {
            BOOLEAN fSignal;
            NdisAcquireSpinLock(&pGroup->OsLock);

            // Clear ourselves from pGroup, if we're there.
            //
            if (pGroup->pUnloadTask == pTask)
            {
                pGroup->pUnloadTask = NULL;
            }
            fSignal = pMyTask->fUseEvent;
            pMyTask->fUseEvent = FALSE;
            NdisReleaseSpinLock(&pGroup->OsLock);

            if (fSignal)
            {
                NdisSetEvent(&pMyTask->BlockEvent);
            }
            Status = NDIS_STATUS_SUCCESS;
        }
        break;

        default:
        ASSERTEX(!"Unknown task op", pTask);
        break;

    } // switch (Code)


    if (fContinueUnload)
    {
        do {
            PRM_HASH_LINK *ppLink, *ppLinkEnd;
            UINT uIndex;
            PRM_HASH_LINK pLink;
            PRM_OBJECT_HEADER pObj;
            PRM_TASK pUnloadObjectTask;

            NdisAcquireSpinLock(&pGroup->OsLock);
    
            uIndex = pMyTask->uIndex;

            //
            // With fEnabled set to FALSE by us, we expect the following:
            // (a) pHashTable->pTable is going to stay the same size.
            // (b) No items are going to be added or removed by anyone else.
            //

            // Find the next non-empty hash table entry, starting at
            // offset pMyTask->uIndex.
            //
            ASSERTEX(!pGroup->fEnabled, pGroup);
            ASSERTEX(uIndex <= pGroup->HashTable.TableLength, pGroup);
            ppLinkEnd = ppLink      = pGroup->HashTable.pTable;
            ppLink      += uIndex;
            ppLinkEnd   += pGroup->HashTable.TableLength;
            while (ppLink < ppLinkEnd && *ppLink == NULL)
            {
                ppLink++;
            }

            // Update index to our current position in the hash table.
            //
            pMyTask->uIndex =  (UINT)(ppLink - pGroup->HashTable.pTable);

            if (ppLink >= ppLinkEnd)
            {
                //
                // We're done...
                //
                NdisReleaseSpinLock(&pGroup->OsLock);
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // Found another object to unload...
            // We'll allocate a task (pUnloadObjectTask) to unload that object,
            // pend ourselves on it, and then start it.
            //
            //

            pLink =  *ppLink;
            pObj = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);

            if (RMISALLOCATED(pTask->Hdr.pParentObject)== FALSE)
            {
                //
                // This object is already de-allocated. Continue past this one.
                // 
                NdisReleaseSpinLock (&pGroup->OsLock);
                continue;
            }
            
            RmTmpReferenceObject(pObj, pSR);
            ASSERT(pObj->pStaticInfo == pGroup->pStaticInfo);
            NdisReleaseSpinLock(&pGroup->OsLock);

            Status = pMyTask->pfnUnloadTaskAllocator(
                        pObj,                                   // pParentObject,
                        pMyTask->pfnTaskUnloadObjectHandler,    // pfnHandler,
                        0,                                      // Timeout,
                        "Task:Unload Object",
                        &pUnloadObjectTask,
                        pSR
                        );
            if (FAIL(Status))
            {
                // Aargh... we couldn't allocate a task to unload this object.
                // We'll return quietly, leaving the other objects intact...
                //
                ASSERTEX(!"Couldn't allocat unload task for object.", pObj);
                RmTmpDereferenceObject(pObj, pSR);
                break;
            }

            RmTmpDereferenceObject(pObj, pSR);
    
    #if OBSOLETE // See  03/26/1999 notes.txt entry "Some proposed ..."

            RmPendTaskOnOtherTask(
                pTask,
                PEND_UnloadObject,
                pUnloadObjectTask,              // task to pend on
                pSR
                );
    
            (void)RmStartTask(
                        pUnloadObjectTask,
                        0, // UserParam (unused)
                        pSR
                        );

            Status = NDIS_STATUS_PENDING;

    #else   // !OBSOLETE
            RmTmpReferenceObject(&pUnloadObjectTask->Hdr, pSR);
            RmStartTask(
                pUnloadObjectTask,
                0, // UserParam (unused)
                pSR
                );
            Status = RmPendOnOtherTaskV2(
                        pTask,
                        PEND_UnloadObject,
                        pUnloadObjectTask,
                        pSR
                        );
            RmTmpDereferenceObject(&pUnloadObjectTask->Hdr, pSR);
            if (PEND(Status))
            {
                break;
            }
    #endif  // !OBSOLETE
    
        }
    #if OBSOLETE // See  03/26/1999 notes.txt entry "Some proposed ..."
        while (FALSE);
    #else   // !OBSOLETE
        while (TRUE);
    #endif  // !OBSOLETE

    }   // if(fContinueUnload)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}

#if RM_EXTRA_CHECKING

BOOLEAN
rmDbgAssociationCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Comparison function used to test for exact equality of items
    in the debug association table.

Arguments:

    pKey        - Actually  a pointer to an RM_PRIVATE_DBG_ASSOCIATION structure.
    pItem       - Points to RM_PRIVATE_DBG_ASSOCIATION.HashLink.

Return Value:

    TRUE IFF the (Entity1, Entity2 and AssociationID) fields of the key
    exactly match the corresponding fields of 
    CONTAINING_RECORD(pItem, RM_PRIVATE_DBG_ASSOCIATION, HashLink);

--*/
{
    RM_PRIVATE_DBG_ASSOCIATION *pA =
             CONTAINING_RECORD(pItem, RM_PRIVATE_DBG_ASSOCIATION, HashLink);

    // pKey is actually a RM_PRIVATE_DBG_ASSOCIATION structure.
    //
    RM_PRIVATE_DBG_ASSOCIATION *pTrueKey = (RM_PRIVATE_DBG_ASSOCIATION *) pKey;


    if (    pA->Entity1 == pTrueKey->Entity1
        &&  pA->Entity2 == pTrueKey->Entity2
        &&  pA->AssociationID == pTrueKey->AssociationID)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}


ULONG
rmDbgAssociationHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash generating function used to compute a ULONG-sized hash from
    key, which is actually  a pointer to an RM_PRIVATE_DBG_ASSOCIATION structure.

Arguments:

    pKey        - Actually  a pointer to an RM_PRIVATE_DBG_ASSOCIATION structure.

Return Value:

    ULONG-sized hash generated from the (Entity1, Entity2 and AssociationID)
    fields of the key.

--*/
{
    // pKey is actually a RM_PRIVATE_DBG_ASSOCIATION structure.
    //
    RM_PRIVATE_DBG_ASSOCIATION *pTrueKey = (RM_PRIVATE_DBG_ASSOCIATION *) pKey;
    ULONG_PTR big_hash;

    big_hash =   pTrueKey->Entity1;
    big_hash ^=  pTrueKey->Entity2;
    big_hash ^=  pTrueKey->AssociationID;

    // Warning: Below, the return value would be truncated in 64-bit.
    // That tolerable because after all this is just a hash.
    // TODO: for 64-bit, consider  xoring hi- and lo- DWORD instead of truncationg.
    //

    return (ULONG) big_hash;
}


// Static hash information use for the hash table (in the diagnostic information
// of each object) that keeps track of associations.
//
RM_HASH_INFO
rmDbgAssociation_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    rmDbgAssociationCompareKey, // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    rmDbgAssociationHash        // pfnHash

};


VOID
rmDbgInitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Allocate and initialize the diagnostic information associated with
    object pObject. This includes initializing the hash table used to keep
    track of arbitrary associations.

--*/
{
    ENTER("InitializeDiagnosticInfo",  0x55db57a2)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo;

    TR_VERB(("   pObj=0x%p\n", pObject));
    // TODO: use lookaside lists for the allocation of these objects.
    //
    RM_ALLOCSTRUCT(pDiagInfo,   MTAG_DBGINFO);
    if (pDiagInfo != NULL)
    {
        RM_ZEROSTRUCT(pDiagInfo);

        NdisAllocateSpinLock(&pDiagInfo->OsLock);
        RmInitializeHashTable(
            &rmDbgAssociation_HashInfo,
            NULL,   // pAllocationContext
            &pDiagInfo->AssociationTable
            );
        pObject->pDiagInfo  = pDiagInfo;
        pDiagInfo->pOwningObject = pObject;

        // Initialize the per-object log list.
        //
        InitializeListHead(&pDiagInfo->listObjectLog);
    }
}


VOID
rmDbgFreeObjectLogEntries(
        LIST_ENTRY *pObjectLog
)
/*++

Routine Description:

    Remove and free all items from the object log pObjectLog.
    It is assumed that no one is trying  to add items to this log at this time.

--*/
{
    LIST_ENTRY          *pLink=NULL, *pNextLink=NULL;
    
    if (IsListEmpty(pObjectLog))    return;             // EARLY RETURN 

    NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);

    for(
        pLink = pObjectLog->Flink;
        pLink != pObjectLog;
        pLink = pNextLink)
    {
        RM_DBG_LOG_ENTRY    *pLogEntry;
        LIST_ENTRY          *pLinkGlobalLog;

        pLogEntry = CONTAINING_RECORD(pLink,  RM_DBG_LOG_ENTRY,  linkObjectLog);
        pLinkGlobalLog =  &pLogEntry->linkGlobalLog;

        // Remove entry from global log.
        // We don't bother removing the entry from the local log list, because
        //  it's going away anyway.
        //
        RemoveEntryList(pLinkGlobalLog);

        // Move to next entry in object's log (which may not be the next entry
        // in the global log).
        //
        pNextLink = pLink->Flink;

        // Free the buffer in the log entry, if any.
        // TODO: need to use log buffer deallocation function --
        //      See notes.txt  03/07/1999  entry "Registering root objects with RM".
        // For now we assume the this memory was allocated using
        // NdisAllocateMemory[WithTag].
        //
        if (pLogEntry->pvBuf != NULL)
        {
            NdisFreeMemory(pLogEntry->pvBuf, 0, 0);
        }

        // Free the log entry itself.
        //
        rmDbgDeallocateLogEntry(pLogEntry);
        
    }
    NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);
}


VOID
rmDbgDeinitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

        (Debug only)

        Deinitialize and free  the diagnostic information associated with
        object pObject. This includes verifying that there are no remaining
        associations and links.
--*/
{
    ENTER("DeinitializeDiagnosticInfo", 0xa969291f)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    TR_VERB((" pObj=0x%p\n", pObject));
    if (pDiagInfo != NULL)
    {

        // Free all the per-object log entries.
        // Note: no one should be trying to add items to this log at this time
        // because we're aboute to deallocate this object.
        //
        {
            rmDbgFreeObjectLogEntries(&pDiagInfo->listObjectLog);
            RM_ZEROSTRUCT(&pDiagInfo->listObjectLog);
        }


        if (pDiagInfo->AssociationTable.NumItems != 0)
        {
            //
            // Ouch! Associations still left. We print out the associations and then
            // DebugBreak.
            //

            TR_FATAL((
                "FATAL: Object 0x%p still has some associations left!\n",
                pObject
                ));
            RmDbgPrintAssociations(pObject, pSR);
            ASSERT(!"Object has associations left at deallocation time.");
        }

        pObject->pDiagInfo = NULL;

        RmDeinitializeHashTable(
            &pDiagInfo->AssociationTable
            );

        //
        // Add any other checks here...
        //

        NdisFreeSpinLock(&pDiagInfo->OsLock);
        RM_FREE(pDiagInfo);
    }
}


VOID
rmDbgPrintOneAssociation (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Dump a single association.

Arguments:

    pLink       -  Points to RM_PRIVATE_DBG_ASSOCIATION.HashLink.
    pvContext   -  Unused

--*/
{
    RM_PRIVATE_DBG_ASSOCIATION *pA =
                    CONTAINING_RECORD(pLink, RM_PRIVATE_DBG_ASSOCIATION, HashLink);
    DbgPrint(
        (char*) (pA->szFormatString),
        pA->Entity1,
        pA->Entity2,
        pA->AssociationID
        );
}


VOID
_cdecl
rmDefaultDumpEntry (
    char *szFormatString,
    UINT_PTR Param1,
    UINT_PTR Param2,
    UINT_PTR Param3,
    UINT_PTR Param4
)
/*++

Routine Description:

    Default function to dump the contents of an association.

--*/
{
    DbgPrint(
        szFormatString,
        Param1,
        Param2,
        Param3,
        Param4
        );
}

UINT
rmSafeAppend(
    char *szBuf,
    const char *szAppend,
    UINT cbBuf
)
/*++

Routine Description:

    Append szAppend to szBuf, but don't exceed cbBuf, and make sure the 
    resulting string is null-terminated.

Return Value:

    Total length of string (excluding null termination) after append.

--*/
{
    UINT uRet;
    char *pc = szBuf;
    char *pcEnd = szBuf+cbBuf-1;    // possible overflow, but we check below.
    const char *pcFrom = szAppend;

    if (cbBuf==0) return 0;             // EARLY RETURN;

    // Skip to end of szBuf
    //
    while (pc < pcEnd && *pc!=0)
    {
        pc++;
    }

    // Append szAppend
    while (pc < pcEnd && *pcFrom!=0)
    {
        *pc++ = *pcFrom++;  
    }

    // Append final zero 
    //
    *pc=0;

    return (UINT) (UINT_PTR) (pc-szBuf);
}

#endif //RM_EXTRA_CHECKING

VOID
rmWorkItemHandler_ResumeTaskAsync(
    IN  PNDIS_WORK_ITEM             pWorkItem,
    IN  PVOID                       pTaskToResume
    )
/*++

Routine Description:

    NDIS work item handler which resumes the give task.

Arguments:

    pWorkItem           - Work item associated with the handler.
    pTaskToResume       - Actually a pointer to the task to resume.

--*/
{
    PRM_TASK pTask  = pTaskToResume;
    UINT_PTR CompletionParam = pTask->AsyncCompletionParam;
    RM_DECLARE_STACK_RECORD(sr)

    ASSERTEX(RMISALLOCATED(&pTask->Hdr), pTask);

#if RM_EXTRA_CHECKING
    //  Undo the association added in RmResumeTasyAsync...
    //
    RmDbgDeleteAssociation(
        0xfc39a878,                             // Location ID
        &pTask->Hdr,                            // pObject
        CompletionParam,                        // Instance1
        (UINT_PTR) pWorkItem,                   // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_ASYNC,     // AssociationID
        &sr
        );
#endif // RM_EXTRA_CHECKING

    // Actually resume the task.
    //
    RmResumeTask(pTask, CompletionParam, &sr);

    RM_ASSERT_CLEAR(&sr)
}


VOID
rmTimerHandler_ResumeTaskDelayed(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )
/*++

Routine Description:

    NDIS timer handler which resumes the give task.

    WARNING: This handler is also called internally by the RM APIs.
    Implementation notes: -- see notes.txt  07/14/1999 entry.

Arguments:

    SystemSpecific1     - Unused
    FunctionContext     - Actually a pointer to the task to be resumed.
    SystemSpecific2     - Unused
    SystemSpecific3     - Unused

--*/
{
    PRM_TASK pTask  = FunctionContext;
    UINT_PTR CompletionParam = pTask->AsyncCompletionParam;
    RM_DECLARE_STACK_RECORD(sr)

    ASSERTEX(RMISALLOCATED(&pTask->Hdr), pTask);

#if RM_EXTRA_CHECKING
    //  Undo the association added in RmResumeTasyDelayed...
    //
    RmDbgDeleteAssociation(
        0xfc39a878,                             // Location ID
        &pTask->Hdr,                            // pObject
        CompletionParam,                        // Instance1
        (UINT_PTR) NULL,                        // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_DELAYED,   // AssociationID
        &sr
        );
#endif // RM_EXTRA_CHECKING

    RMPRIVATELOCK(&pTask->Hdr, &sr);
    ASSERT(RM_CHECK_STATE(pTask, RMTSKDELSTATE_MASK, RMTSKDELSTATE_DELAYED));
    RM_SET_STATE(pTask, RMTSKDELSTATE_MASK, 0);
    RM_SET_STATE(pTask, RMTSKABORTSTATE_MASK, 0);
    RMPRIVATEUNLOCK(&pTask->Hdr, &sr);

    // Actually resume the task.
    //
    RmResumeTask(pTask, CompletionParam, &sr);

    RM_ASSERT_CLEAR(&sr)
}


VOID
rmPrivateTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free a private task (which was allocated using  rmAllocatePrivateTask.

Arguments:

    pObj    - Actually a pointer to a task of subtype RM_PRIVATE_TASK.

--*/
{
    PRM_TASK pTask = (PRM_TASK) pObj;
    if (CHECK_TASK_IS_BACKUP(pTask) == TRUE)
    {
        arpReturnBackupTask((ARP1394_TASK*)pTask);
    }
    else
    {
        RM_FREE(pObj);
    }

}


#if RM_EXTRA_CHECKING


RM_DBG_LOG_ENTRY *
rmDbgAllocateLogEntry(VOID)
/*++

Routine Description:

    Allocate an object log entry.

    TODO use lookaside lists, and implement per-component global logs.
    See notes.txt  03/07/1999  entry "Registering root objects with RM".

--*/
{
    RM_DBG_LOG_ENTRY *pLE;
    RM_ALLOCSTRUCT(pLE, MTAG_DBGINFO);
    return  pLE;
}

VOID
rmDbgDeallocateLogEntry(
        RM_DBG_LOG_ENTRY *pLogEntry
        )
/*++

Routine Description:

    Free an object log entry.

    TODO use lookaside lists, and implement per-component global logs.
    See notes.txt  03/07/1999  entry "Registering root objects with RM".

--*/
{
    RM_FREE(pLogEntry);
}
#endif // RM_EXTRA_CHECKING


VOID
rmUpdateHashTableStats(
    PULONG pStats,
    ULONG   LinksTraversed
    )
/*++

Routine Description:

    Update the stats (loword == links traversed, hiword == num accesses)

--*/
{
    ULONG OldStats;
    ULONG Stats;
    
    // Clip LinksTraversed to 2^13, or 8192 
    //
    if (LinksTraversed > (1<<13))
    {
        LinksTraversed = 1<<13;
    }
    
    Stats = OldStats = *pStats;
    
    // If either the loword or hiword of Stats is greater-than 2^13, we
    // intiger-devide both by 2. We're really only interested in the ratio
    // of the two, which is preserved by the division.
    //
    #define rmSTATS_MASK (0x11<<30|0x11<<14)
    if (OldStats & rmSTATS_MASK)
    {
        Stats >>= 1;
        Stats &= ~rmSTATS_MASK;
    }

    // Compute the updated value of stats..
    //  "1<<16" below means "one access"
    //
    Stats += LinksTraversed | (1<<16);

    // Update the stats, but only if they haven't already been updated by
    // someone else. Note that if they HAVE been updated, we will lose this
    // update. Not a big deal as we are not looking for 100% exact statistics here.
    //
    InterlockedCompareExchange(pStats, Stats, OldStats);
}


VOID
rmEnumObjectInGroupHashTable (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    )
/*++
    Hash table enumerator to implement "STRONG" enumeration -- see
    RmEnumerateObjectsInGroup.
--*/
{
    PRM_STRONG_ENUMERATION_CONTEXT pCtxt = (PRM_STRONG_ENUMERATION_CONTEXT)pvContext;

    if (pCtxt->fContinue)
    {
        PRM_OBJECT_HEADER pHdr;
        pHdr = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
        pCtxt->fContinue = pCtxt->pfnObjEnumerator(
                                    pHdr,
                                    pCtxt->pvCallerContext,
                                    pSR
                                    );
    }
}


VOID
rmConstructGroupSnapshot (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    )
/*++
    Hash table enumerator to construct a snapshot of a group for weak enumeration.
    See RmWeakEnumerateObjectsInGroup.
--*/
{
    PRM_WEAK_ENUMERATION_CONTEXT pCtxt = (PRM_WEAK_ENUMERATION_CONTEXT)pvContext;

    if (pCtxt->ppCurrent < pCtxt->ppEnd)
    {
        PRM_OBJECT_HEADER pHdr;
        pHdr = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
        RmTmpReferenceObject(pHdr, pSR);
        *pCtxt->ppCurrent = pHdr;
        pCtxt->ppCurrent++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\rm.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    rm.h

Abstract:

    "Resource Manager" structures and APIs

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     11-10-98    created

--*/

//=================================================================================
//                  O S - S P E C I F I C   T Y P E S
//=================================================================================

#define RM_OS_LOCK                          NDIS_SPIN_LOCK
#define OS_WORK_ITEM                        NDIS_WORK_ITEM
#define OS_TIMER                            NDIS_TIMER

#define RM_STATUS                            NDIS_STATUS

#define RM_OS_FILL_MEMORY(_dest, _len, _fill) NdisFillMemory(_dest, _len, _fill)
#define RM_OS_ZERO_MEMORY(_dest, _len)        NdisZeroMemory(_dest, _len)
#define RM_OS_GET_CURRENT_THREAD_HANDLE()     NULL

// If set, the object tree is explicitly maintained.
//
#define RM_TRACK_OBJECT_TREE 1

//=================================================================================
//                  F O R W A R D       R E F E R E N C E S
//=================================================================================

typedef struct _RM_STACK_RECORD     RM_STACK_RECORD,        *PRM_STACK_RECORD;
typedef struct _RM_OBJECT_HEADER    RM_OBJECT_HEADER,       *PRM_OBJECT_HEADER;
typedef struct _RM_TASK             RM_TASK,                *PRM_TASK;
typedef struct _RM_RESOURCE_TABLE_ENTRY
                                RM_RESOURCE_TABLE_ENTRY, *PRM_RESOURCE_TABLE_ENTRY;


//=================================================================================
//                  T Y P E D E F S
//=================================================================================

//
// RM_DBG_LOCK_INFO Keeps debugging information specific to an instance of a RM_LOCK.
//
typedef struct _RM_DBG_LOCK_INFO
{
    //
    // If nonzero, LocID is a magic number which uniquely identifies the source
    // location where the lock was aquired.
    //
    ULONG uLocID;

    //
    // pSR points to the stack record of the currently owning thread, if there
    // is one. If a function F expects an object pObj to be locked on entry,
    // it can  ASSERT(pObj->pLock->pDbgInfo->pSR == pSR);
    //
    struct _RM_STACK_RECORD *pSR;


} RM_DBG_LOCK_INFO, *PRM_DBG_LOCK_INFO;

//
// RM_LOCK keeps information about a lock.
//
typedef struct _RM_LOCK
{
    //
    // Native, os-provided lock structure.
    //
    RM_OS_LOCK OsLock;

    //
    // Level of this lock. Multiple locks can only be acquired in increasing order
    // of this value.
    //
    ULONG Level;

    //
    // Pointer to debugging info for this lock. Could be NULL.
    //
    PRM_DBG_LOCK_INFO pDbgInfo;

#if RM_EXTRA_CHECKING
    RM_DBG_LOCK_INFO DbgInfo;
#endif // RM_EXTRA_CHECKING

} RM_LOCK, *PRM_LOCK;


typedef
ULONG
(*PFNLOCKVERIFIER) (
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
    );

// RM_LOCKING_INFO keeps information about a particular lock being held.
// In non-checking mode, this is just the pointer to the lock.
// In checking mode, this additionally contains information that can be used
// to verify that the entity being protected by the lock is not changed when
// the lock is not being held.
//
typedef struct
{
    PRM_LOCK pLock;

#if RM_EXTRA_CHECKING
    PFNLOCKVERIFIER pfnVerifier;
    PVOID           pVerifierContext;
#endif // RM_EXTRA_CHECKING

}  RM_LOCKING_INFO, PRM_LOCKING_INFO;

//
// RM_STACK_RECORD keeps information relevant to the current call tree.
//
typedef struct _RM_STACK_RECORD
{
    //
    // LockInfo contains information about currently-held locks.
    //
    struct
    {
        //
        // Level of the currently held lock. Locks must be claimed in
        // order of increasing Level values. The lowest level value is 1. Level
        // 0 indicates no locks held.
        //
        UINT    CurrentLevel;

        //
        // Pointer to the first location to store a pointers to a locks.
        //
        PRM_LOCKING_INFO *pFirst;

        //
        // Pointer to the next free location to store a pointer to a lock
        // that has been claimed in this call tree.
        //
        PRM_LOCKING_INFO *pNextFree;

        //
        // Pointer to the last valid location to store a lock pointer.
        //
        PRM_LOCKING_INFO *pLast;

    } LockInfo;


    //
    // Count of tmp refs taken with this stack record.
    //
    ULONG TmpRefs;

#if DBG

    //
    // DbgInfo contains diagnostic information relevant to this call tree.
    //
    struct
    {
        //
        // Verbosity level
        //
        ULONG Level;

        //
        //  Points to the os-provided thread handle of the current thread.
        //  if there is one.
        //
        PVOID pvThread;


    } DbgInfo;

#endif // DBG

} RM_STACK_RECORD, *PRM_STACK_RECORD;

#if DBG
    #define RM_INIT_DBG_STACK_RECORD(_sr, _dbglevel)                \
        _sr.DbgInfo.Level           = _dbglevel;                    \
        _sr.DbgInfo.pvThread        = RM_OS_GET_CURRENT_THREAD_HANDLE();
#else
    #define RM_INIT_DBG_STACK_RECORD(_sr, _dbglevel)
#endif 

//
// RM_DECLARE_STACK_RECORD_EX is a macro to reserve some stack space for
// a stack record.
//
#define RM_DECLARE_STACK_RECORD_EX(_sr, _max_locks, _dbglevel)      \
    RM_LOCKING_INFO rm_lock_array[_max_locks];                      \
    RM_STACK_RECORD _sr;                                            \
    RM_OS_ZERO_MEMORY(rm_lock_array, sizeof(rm_lock_array));        \
    _sr.TmpRefs                 = 0;                                \
    _sr.LockInfo.CurrentLevel   = 0;                                \
    _sr.LockInfo.pFirst     = rm_lock_array;                    \
    _sr.LockInfo.pNextFree  = rm_lock_array;                    \
    _sr.LockInfo.pLast      = rm_lock_array+(_max_locks)-1;     \
    RM_INIT_DBG_STACK_RECORD(_sr, _dbglevel);


//
// RM_DECLARE_STACK_RECORD is a macro to reserve default stack space for
// a stack record.
//
#define RM_DECLARE_STACK_RECORD(_sr)                                \
    RM_DECLARE_STACK_RECORD_EX(_sr, 4, 0)



//
// Generic memory allocator prototype
//
typedef
PVOID
(*PFN_RM_MEMORY_ALLOCATOR)(
    PVOID pAllocationContext,
    UINT  Size                  // in bytes
    );

//
// Generic memory deallocator prototype
//
typedef
PVOID
(*PFN_RM_MEMORY_DEALLOCATOR)(
    PVOID pMem,
    PVOID pAllocationContext
    );


//  RM_HASH_LINK is the field in the structures being hashed that is
//  used to link all items in the same bucket. It also contains the
//  "HashKey", which is a potentially-nonunique UINT-sized hash of the
//  real key.
//
typedef struct _RM_HASH_LINK
{
    struct _RM_HASH_LINK *pNext;
    UINT                  uHash;
} RM_HASH_LINK, *PRM_HASH_LINK;


//
// Hash table comparison function.
//
typedef
BOOLEAN
(*PFN_RM_COMPARISON_FUNCTION)(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    );


//
// Hash computation function.
//
typedef
ULONG
(*PFN_RM_HASH_FUNCTION)(
    PVOID           pKey
    );


//
// RM_HASH_INFO specifies customizing information about a hash table.
//
typedef struct
{
    // Allocator used to allocate the hash table if it needs to grow.
    //
    PFN_RM_MEMORY_ALLOCATOR pfnTableAllocator;

    // Free function for the above allocator.
    PFN_RM_MEMORY_DEALLOCATOR pfnTableDeallocator;

    // Comparison function for strict equality.
    //
    PFN_RM_COMPARISON_FUNCTION pfnCompare;

    // Function to generate a ULONG-sized hash.
    //
    PFN_RM_HASH_FUNCTION pfnHash;

#if OBSOLETE
    // Offset in sizeof(UINT) to location of the place to keep
    // the next pointer for the bucket list.
    //
    UINT    OffsetNext;

    // Offset in sizeof(UINT) to location of UINT-sized Temp ref
    //
    UINT    OffsetTmpRef;

    // Offset in sizeof(UINT) to location of UINT-sized Tot ref
    //
    UINT    OffsetTotRef;

    // Offset in sizeof(UINT) to location of ULONG-sized hash key.
    //
    UINT    OffsetHashKey;
#endif // OBSOLETE

} RM_HASH_INFO, *PRM_HASH_INFO;

#define RM_MIN_HASH_TABLE_SIZE 4

//
// RM_HASH_TABLE is a hash table.
//
typedef struct
{
    //  Number of items currently in hash table.
    //
    UINT NumItems;

    //  Stats is a 32-bit quantity keeps a running total of number of accesses
    //  (add+search+remove) in the HIWORD and the total number of list nodes
    //  traversed in the LOWORD. This field gets updated even on searches, but
    //  it is not protected by the hash table lock -- instead it is
    //  updated using  an interlocked operation. This allows us to use
    //  a read lock for searches while still updating this statistic value.
    //  The Stats field is re-scaled when the counts get too high, to avoid
    //  overflow and also to favor more recent stats in preference to older
    //  stats.
    //
    //  NumItems, Stats and TableLength are used to decide whether to
    //  dynamically resize the hash table.
    //
    ULONG Stats;

    //  Length of hash table in units of PVOID
    //
    ULONG TableLength;

    // Pointer to TableLength-sized array of PVOIDs -- this is the actual hash table
    //
    PRM_HASH_LINK *pTable;


    // The hash table
    //
    PRM_HASH_LINK InitialTable[RM_MIN_HASH_TABLE_SIZE];

    // Static information about this hash table.
    //
    PRM_HASH_INFO pHashInfo;

    // Passed into the allocate/deallocate functions.
    //
    PVOID pAllocationContext;

} RM_HASH_TABLE, *PRM_HASH_TABLE;

// Returns approximate value of (num-nodes-traversed)/(num-accesses)
//
#define RM_HASH_TABLE_TRAVERSE_RATIO(_pHash_Table) \
            (((_pHash_Table)->Stats & 0xffff) / (1+((_pHash_Table)->Stats >> 16)))
            //
            // NOTE: the "1+" above is simply to guard against devide-by-zero.


//
// RM_OBJECT_DIAGNOSTIC_INFO keeps diagnostic info specific to an instance of
// an object.
//
// This structure is for private use of the RM APIs.
// The only field of general interest is PrevState.
//
typedef struct
{
    // Back pointer to owning object.
    //
    RM_OBJECT_HEADER *pOwningObject;

    // Each time the object-specific State field is updated, it's previous
    // value is saved here.
    //
    ULONG               PrevState;

    // Used for correctly updating PrevState.
    //
    ULONG               TmpState;

    // Diagnostic-related state.
    //
    ULONG               DiagState;
    #define fRM_PRIVATE_DISABLE_LOCK_CHECKING (0x1<<0)

    // This is an object-specific checksum that is computed and 
    // saved just before the object is unlocked. It is  checked
    // just after the object is locked.
    //
    ULONG               Checksum;

    // Native OS lock to be *only* to serialize access to the information
    // in this structure.
    //
    RM_OS_LOCK          OsLock;

    // Keeps an associative list of all entities which have been registered
    // (using RmDbgAddAssociation) with this object. Ths includes objects which
    // have been linked to this object using the RmLinkObjects call, as well
    // as childen and parents of this object.
    //
    RM_HASH_TABLE       AssociationTable;

    // Following is set to TRUE IFF  there was an allocation failure when trying to
    // add an association. If there'e been an allocation failure, we don't complain
    // (i.e. ASSERT) if an attempt is made to remove an assertion that doesn't
    // exist. In this way we gracefully deal with allocation failures of the
    // association table entries.
    //
    INT                 AssociationTableAllocationFailure;

    // The per-object list of log entries.
    // This is serialized by the global rm lock, not the local rm-private lock!
    //
    LIST_ENTRY          listObjectLog;

    // Count of entries in this object's log.
    // This is serialized by the global rm lock, not the local rm-private lock!
    //
    UINT                NumObjectLogEntries;

#if TODO    // We haven't implemented the following yet...

    // Future:
    // RM_STATE_HISTORY -- generalization of PrevState.

#endif //  TODO


} RM_OBJECT_DIAGNOSTIC_INFO, *PRM_OBJECT_DIAGNOSTIC_INFO;

typedef
PRM_OBJECT_HEADER
(*PFN_CREATE_OBJECT)(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        );

typedef
VOID
(*PFN_DELETE_OBJECT)(PRM_OBJECT_HEADER, PRM_STACK_RECORD psr);


//
// RM_STATIC_OBJECT_INFO keeps information that is common to all instances of
// a particular type of object.
//
typedef struct
{
    ULONG   TypeUID;
    ULONG   TypeFlags;
    char*   szTypeName;
    UINT    Timeout;

    //
    // Various Handlers
    //
    PFN_CREATE_OBJECT           pfnCreate;
    PFN_DELETE_OBJECT           pfnDelete;
    PFNLOCKVERIFIER             pfnLockVerifier;

    //
    // Resource Information
    //
    UINT    NumResourceTableEntries;
    struct  _RM_RESOURCE_TABLE_ENTRY *  pResourceTable;

    //
    // Hash-table info, if this object is part of a group.
    //
    PRM_HASH_INFO pHashInfo;

} RM_STATIC_OBJECT_INFO, *PRM_STATIC_OBJECT_INFO;

//
// RM_OBJECT_HEADER is the common header for all objects.
//
typedef struct _RM_OBJECT_HEADER
{
    //
    // Object-type-specific signature.
    //
    ULONG Sig;

    //
    // Description of this object (could be the same as pStaticInfo->szTypeName,
    // but may be something more specific).
    // Used only for debugging purposes.
    // TODO: consider moving this into the pDiagInfo struct. For now, leave it
    // here because it's useful when debugging.
    //
    const char *szDescription;

    //
    // Object-specific state.
    //
    ULONG State;

    ULONG RmState; // One or more RMOBJSTATE_* or RMTSKSTATE_* flags below...

    //
    // RM state flags....
    //
    
    // Object allocation state...
    //
    #define RMOBJSTATE_ALLOCMASK        0x00f
    #define RMOBJSTATE_ALLOCATED        0x001
    #define RMOBJSTATE_DEALLOCATED      0x000

    // Task state ...
    //
    #define RMTSKSTATE_MASK             0x0f0
    #define RMTSKSTATE_IDLE             0x000
    #define RMTSKSTATE_STARTING         0x010
    #define RMTSKSTATE_ACTIVE           0x020
    #define RMTSKSTATE_PENDING          0x030
    #define RMTSKSTATE_ENDING           0x040

    //  Task delay state
    //
    #define RMTSKDELSTATE_MASK          0x100
    #define RMTSKDELSTATE_DELAYED       0x100

    //  Task abort state
    //
    #define RMTSKABORTSTATE_MASK        0x200
    #define RMTSKABORTSTATE_ABORT_DELAY 0x200

    //
    // Bitmap identifying resources used by this object.
    //
    ULONG ResourceMap;

    // Total reference count.
    //
    //
    ULONG TotRefs;

    //

    // Pointer to a RM_LOCK object used to serialize access to this object.
    //
    PRM_LOCK pLock;

    //
    // Pointer to information common to all instances of this object type.
    //
    PRM_STATIC_OBJECT_INFO    pStaticInfo;

    //
    // Points to diagnostic information about this object.  Could be NULL.
    //
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo;


    //
    //  Points to the parent object.
    //
    struct _RM_OBJECT_HEADER *pParentObject;

    //
    //  Points to the root (ancestor of all object) -- could be the same
    //  as pParentObject;
    //
    struct _RM_OBJECT_HEADER *pRootObject;

    //
    // This is a private lock used exclusively by the RM apis. It is
    // never left unlocked by the RM apis.
    // TODO: maybe make this a native-os lock.
    //
    RM_LOCK RmPrivateLock;

    // Used to create groups of objects.
    // TODO: make this a private field, present only if the object is
    // meant to be in a group.
    //
    RM_HASH_LINK HashLink;

#if RM_TRACK_OBJECT_TREE
    LIST_ENTRY          listChildren; // Protected by this object's RmPrivateLock.
    LIST_ENTRY          linkSiblings; // Protected by parent object's RmPrivateLock.
    
#endif // RM_TRACK_OBJECT_TREE

} RM_OBJECT_HEADER, *PRM_OBJECT_HEADER;


//
// Diagnostic resource tracking.
//
typedef struct
{
    ULONG_PTR               Instance;
    ULONG                   TypeUID;
    PRM_OBJECT_HEADER       pParentObject;
    ULONG                   CallersUID;
    ULONG                   CallersSrUID;

} RM_DBG_RESOURCE_ENTRY;


typedef enum
{
    RM_RESOURCE_OP_LOAD,
    RM_RESOURCE_OP_UNLOAD

} RM_RESOURCE_OPERATION;

typedef
RM_STATUS
(*PFN_RM_RESOURCE_HANDLER)(
    PRM_OBJECT_HEADER       pObj,
    RM_RESOURCE_OPERATION   Op,
    PVOID                   pvUserParams,
    PRM_STACK_RECORD        psr
);

typedef struct _RM_RESOURCE_TABLE_ENTRY
{
    UINT                    ID;
    PFN_RM_RESOURCE_HANDLER pfnHandler;
    
} RM_RESOURCE_TABLE_ENTRY, *PRM_RESOURCE_TABLE_ENTRY;


typedef struct
{
    UINT u;

} RM_OBJECT_INDEX,  *PRM_OBJECT_INDEX;


typedef struct
{
    PRM_OBJECT_HEADER           pOwningObject;
    const char *                szDescription;
    PRM_STATIC_OBJECT_INFO      pStaticInfo;
    RM_HASH_TABLE               HashTable;


    // Private lock used ONLY by group access functions.
    //
    RM_OS_LOCK                      OsLock;

    // When non-NULL, points to the task responsible for unloading all objects
    // in this group.
    //
    PRM_TASK                    pUnloadTask;

    BOOLEAN fEnabled;

} RM_GROUP,  *PRM_GROUP;


typedef enum
{
    RM_TASKOP_START,
    RM_TASKOP_PENDCOMPLETE,
    RM_TASKOP_END,
    RM_TASKOP_PRIVATE,
    RM_TASKOP_ABORT,
    RM_TASKOP_TIMEOUT

} RM_TASK_OPERATION;


typedef
RM_STATUS
(*PFN_RM_TASK_HANDLER)(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Op,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );
//
// For START and PENDCOMPLETE, a return value other than PENDING causes
// the task to end. Of course, it is illegal to return non-pending when
// the task is in a pending state.
//


// Task allocator prototype
//
typedef
RM_STATUS
(*PFN_RM_TASK_ALLOCATOR)(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );

typedef struct _RM_TASK
{
    RM_OBJECT_HEADER                Hdr;

    PFN_RM_TASK_HANDLER             pfnHandler;
    LIST_ENTRY                      linkFellowPendingTasks;
    LIST_ENTRY                      listTasksPendingOnMe;
    struct _RM_TASK *               pTaskIAmPendingOn;


    // In the case that we need to asynchronously notify the completion of a
    // pending operation, we can save the completion param here.
    //
    UINT_PTR                        AsyncCompletionParam;

    UINT                            SuspendContext;

} RM_TASK, *PRM_TASK;

typedef
VOID
(_cdecl *PFN_DBG_DUMP_LOG_ENTRY) (
    char *szFormatString,
    UINT_PTR Param1,
    UINT_PTR Param2,
    UINT_PTR Param3,
    UINT_PTR Param4
);


#if RM_EXTRA_CHECKING

// (For debugging only)
// Keeps track of a single association (See RmDbgAddAssociation)
// This is a PRIVATE data structure, and is only here because
// the kd extension refers to it.
//
typedef struct
{
    ULONG           LocID;
    ULONG_PTR       Entity1;
    ULONG_PTR       Entity2;
    ULONG           AssociationID;
    const char *    szFormatString;
    RM_HASH_LINK    HashLink;

} RM_PRIVATE_DBG_ASSOCIATION;

// (For debugging only)
// Keeps track of a single per-object log entry.
// This is a PRIVATE data structure, and is only here because
// the kd extension refers to it.
//
typedef struct
{
    // Link to other entries for this object
    //
    LIST_ENTRY linkObjectLog;

    // Link to other entries in the global list.
    //
    LIST_ENTRY linkGlobalLog;

    // Object this entry belongs to
    //
    PRM_OBJECT_HEADER   pObject;

    // Function to be used for dumping the log.
    //
    PFN_DBG_DUMP_LOG_ENTRY pfnDumpEntry;

    // Prefix string to be dumped *before* the log display.
    // This was added so we could log associations properly, otherwise it's
    // extra baggage. Can be null.
    //
    char *szPrefix;

    // Format string for log display -- 1st arg to pfnDumpEntry
    //
    char *szFormatString;

    // Remaining args to pfnDumpEntry;
    //
    //
    UINT_PTR Param1;
    UINT_PTR Param2;
    UINT_PTR Param3;
    UINT_PTR Param4;

    // If non-NULL, piece of memory to be freed when the log entry is freed.
    // TODO: See notes.txt  entry "03/07/1999 ... Registering root objects with RM"
    // on how we will find the deallocator function. For now we simply
    // use NdisFreeMemory.
    //
    PVOID pvBuf;

} RM_DBG_LOG_ENTRY;

#endif RM_EXTRA_CHECKING

//=================================================================================
//                      U T I L I T Y       M A C R O S
//=================================================================================

#define RM_PARENT_OBJECT(_pObj)             \
            ((_pObj)->Hdr.pParentObject)

#define RM_PEND_CODE(_pTask)                \
            ((_pTask)->SuspendContext)

#define RM_ASSERT_SAME_LOCK_AS_PARENT(_pObj)                                        \
                ASSERTEX(                                                       \
                    ((_pObj)->Hdr.pLock == (_pObj)->Hdr.pParentObject->pLock),  \
                    (_pObj))

#define RM_SET_STATE(_pObj, _Mask, _Val)    \
            (((_pObj)->Hdr.State) = (((_pObj)->Hdr.State) & ~(_Mask)) | (_Val))

#define RM_CHECK_STATE(_pObj, _Mask, _Val)  \
            ((((_pObj)->Hdr.State) & (_Mask)) == (_Val))

#define RM_GET_STATE(_pObj, _Mask)  \
            (((_pObj)->Hdr.State) & (_Mask))

// Asserts that the object is in the "zombie" state, i.e., it
// lives on just because of references.
// WARNING: It is upto the caller to synchronize access to this -- for example
// if they're going to do thing's like if (!RM_IS_ZOMBIE(pObj)) {do-stuff}, they
// had better make sure that only one of them goes on to "does-stuff".
//
#define RM_IS_ZOMBIE(_pobj) \
            (((_pobj)->Hdr.RmState&RMOBJSTATE_ALLOCMASK)==RMOBJSTATE_DEALLOCATED)

// Asserts that no locks are held.
//
#define RM_ASSERT_NOLOCKS(_psr) \
        ASSERTEX((_psr)->LockInfo.CurrentLevel == 0, (_psr))

// Assert that no locks or tmprefs are held.
//
#define RM_ASSERT_CLEAR(_psr) \
        ASSERTEX(((_psr)->LockInfo.CurrentLevel==0) && (_psr)->TmpRefs==0, (_psr))
        

#if RM_EXTRA_CHECKING

//
// TODO: rename the following to something better...
//

#define RM_DBG_ASSERT_LOCKED0(_pLk, _pSR)   \
    ASSERTEX((_pLk)->DbgInfo.pSR == (_pSR), (_pHdr))

// TODO -- replace calls to this by calls to RM_ASSERT_OBJLOCKED
#define RM_DBG_ASSERT_LOCKED(_pHdr, _pSR)   \
    ASSERTEX((_pHdr)->pLock->DbgInfo.pSR == (_pSR), (_pHdr))

#define RM_ASSERT_OBJLOCKED(_pHdr, _pSR)    \
    ASSERTEX((_pHdr)->pLock->DbgInfo.pSR == (_pSR), (_pHdr))

// Note that we can't assume DbgInfo.pSR is NULL below (it could be locked
// by some other thread), but we CAN assert that DbgInfo.pSR is not equal to the
// current pSR!
//
#define RM_ASSERT_OBJUNLOCKED(_pHdr, _pSR)  \
    ASSERTEX((_pHdr)->pLock->DbgInfo.pSR != (_pSR), (_pHdr))

#else // !RM_EXTRA_CHECKING

#define RM_DBG_ASSERT_LOCKED0(_pLk, _pSR)   (0)
#define RM_DBG_ASSERT_LOCKED(_pHdr, _pSR)   (0)
#define RM_ASSERT_OBJLOCKED(_pHdr, _pSR)    (0)
#define RM_ASSERT_OBJUNLOCKED(_pHdr, _pSR)  (0)


#endif // !RM_EXTRA_CHECKING

#define RM_NUM_ITEMS_IN_GROUP(_pGroup) \
            ((_pGroup)->HashTable.NumItems)

//=================================================================================
//                  F U N C T I O N     P R O T O T Y P E S
//=================================================================================

VOID
RmInitializeRm(VOID);

VOID
RmDeinitializeRm(VOID);

VOID
RmInitializeHeader(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  UINT                        Sig,
    IN  PRM_LOCK                    pLock,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  const char *                szDescription,
    IN  PRM_STACK_RECORD            pSR
    );
//
// Object allocation and deallocation APIs
//

VOID
RmDeallocateObject(
    IN  PRM_OBJECT_HEADER           pObject,
    IN  PRM_STACK_RECORD            pSR
    );


//
// locking
//

VOID
RmInitializeLock(
    IN PRM_LOCK pLock,
    IN UINT     Level
    );

VOID
RmDoWriteLock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    );

#if TODO
VOID
RmDoReadLock(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );
#else //!TODO
#define RmDoReadLock    RmDoWriteLock
#endif //!TODO

VOID
RmDoUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    );


#if TODO
VOID
RmReadLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    );
#else //!TODO
#define RmReadLockObject RmWriteLockObject
#endif //!TODO

VOID
RmWriteLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlockObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlockAll(
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDbgChangeLockScope(
    IN  PRM_OBJECT_HEADER           pPreviouslyLockedObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG                       LocID,
    IN  PRM_STACK_RECORD            
    );

//
// reference counting
//

VOID
RmLinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSr
    );

VOID
RmUnlinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSr
    );

VOID
RmLinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  ULONG                       InvAssocID,
    IN  const char *                szInvAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  ULONG                       InvAssocID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmLinkToExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlinkFromExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmLinkToExternalFast( // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    );

VOID
RmUnlinkFromExternalFast(   // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    );

VOID
RmTmpReferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmTmpDereferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

//
// Generic resource management
//

RM_STATUS
RmLoadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnloadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnloadAllGenericResources(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

//
// Diagnostic per-object tracking of arbitrary "associations"
//

//
// NOTE: AssociationID must not have the high-bit set. Associations with the
// high bit set are reserved for internal use of the Rm API implementation.
//

VOID
RmDbgAddAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Instance1,
    IN  ULONG_PTR                   Instance2,
    IN  ULONG                       AssociationID,
    IN  const char *                szFormatString, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDbgDeleteAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Entity1,
    IN  ULONG_PTR                   Entity2,
    IN  ULONG                       AssociationID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDbgPrintAssociations(
    IN  PRM_OBJECT_HEADER pObject,
    IN  PRM_STACK_RECORD pSR
    );

//
// Diagnostic per-object logging.
//

VOID
RmDbgLogToObject(
    IN  PRM_OBJECT_HEADER       pObject,
    IN  char *                  szPrefix,       OPTIONAL
    IN  char *                  szFormatString,
    IN  UINT_PTR                Param1,
    IN  UINT_PTR                Param2,
    IN  UINT_PTR                Param3,
    IN  UINT_PTR                Param4,
    IN  PFN_DBG_DUMP_LOG_ENTRY  pfnDumpEntry,   OPTIONAL
    IN  PVOID                   pvBuf           OPTIONAL
    );


VOID
RmDbgPrintObjectLog(
    IN PRM_OBJECT_HEADER pObject
    );

VOID
RmDbgPrintGlobalLog(VOID);

//
// Groups of Objects
//


VOID
RmInitializeGroup(
    IN  PRM_OBJECT_HEADER           pOwningObject,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  PRM_GROUP                   pGroup,
    IN  const char*                 szDescription,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDeinitializeGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    );

RM_STATUS
RmLookupObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  ULONG                       Flags, // Lookup flags defined below
    IN  PVOID                       pvKey,
    IN  PVOID                       pvCreateParams,
    OUT PRM_OBJECT_HEADER *         ppObject,
    OUT INT *                       pfCreated,
    IN  PRM_STACK_RECORD            pSR
    );

//
//  Lookup flags
//
#define RM_CREATE       0x1
#define RM_NEW          (0x1<<1)
#define RM_LOCKED       (0x1<<2)


#define RM_CREATE_AND_LOCK_OBJECT_IN_GROUP(_pGrp, _pKey, _pParams, _ppHdr, _fC,_psr)\
        RmLookupObjectInGroup(                                                      \
                            (_pGrp),                                                \
                            RM_CREATE|RM_NEW|RM_LOCKED,                             \
                            (_pKey),                                                \
                            (_pParams),                                             \
                            (_ppHdr),                                               \
                            (_fC),                                                  \
                            (_psr)                                                  \
                            );

// RM_STATUS
// RM_LOOKUP_AND_LOCK_OBJECT_IN_GROUP(
//                  PRM_GROUP           _pGrp,
//                  PVOID               _pKey,
//                  PRM_OBJECT_HEADER * _ppHdr,
//                  PRM_STACK_RECORD    _psr
//                  )
// Lookup (don't create) and lock an object in the specified group.
//
#define RM_LOOKUP_AND_LOCK_OBJECT_IN_GROUP(_pGrp, _pKey, _ppHdr, _psr)              \
        RmLookupObjectInGroup(                                                      \
                            (_pGrp),                                                \
                            RM_LOCKED,                                              \
                            (_pKey),                                                \
                            NULL,                                                   \
                            (_ppHdr),                                               \
                            NULL,                                                   \
                            (_psr)                                                  \
                            );

RM_STATUS
RmGetNextObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pCurrentObject,     OPTIONAL
    OUT PRM_OBJECT_HEADER *         ppNextObject,
    IN  PRM_STACK_RECORD            pSR
    );


VOID
RmFreeObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmFreeAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnloadAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    PFN_RM_TASK_ALLOCATOR           pfnUnloadTaskAllocator,
    PFN_RM_TASK_HANDLER             pfnUnloadTaskHandler,
    PVOID                           pvUserParam,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  UINT                        uTaskPendCode, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmEnableGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    );



// Enumeration function prototype. This function is passed into
// RmEnumerateObjectsInGroup and gets called for each object in the group
// until the function returns FALSE.
//
typedef
INT
(*PFN_RM_GROUP_ENUMERATOR) (
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );

VOID
RmEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnFunction,
    PVOID                   pvContext,
    INT                     fStrong,
    PRM_STACK_RECORD        pSR
    );

VOID
RmWeakEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnFunction,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    );

//
// Task APIs
//

VOID
RmInitializeTask(
IN  PRM_TASK                    pTask,
IN  PRM_OBJECT_HEADER           pParentObject,
IN  PFN_RM_TASK_HANDLER         pfnHandler,
IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,    OPTIONAL
IN  const char *                szDescription,  OPTIONAL
IN  UINT                        Timeout,
IN  PRM_STACK_RECORD            pSR
);


RM_STATUS
RmStartTask(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    UserParam,
IN  PRM_STACK_RECORD            pSR
);


VOID
RmAbortTask(
IN  PRM_TASK                    pTask,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmDbgDumpTask(
IN  PRM_TASK                    pTask,
IN  PRM_STACK_RECORD            pSR
);

RM_STATUS
RmSuspendTask(
IN  PRM_TASK                    pTask,
IN  UINT                        SuspendContext,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmUnsuspendTask(
IN  PRM_TASK                    pTask,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmResumeTask(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    SuspendCompletionParam,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmResumeTaskAsync(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    SuspendCompletionParam,
IN  OS_WORK_ITEM            *   pOsWorkItem,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmResumeTaskDelayed(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    SuspendCompletionParam,
IN  ULONG                       MsDelay,
IN  OS_TIMER                *   pOsTimerObject,
IN  PRM_STACK_RECORD            pSR
);


VOID
RmResumeDelayedTaskNow(
IN  PRM_TASK                    pTask,
IN  OS_TIMER                *   pOsTimer,
OUT PUINT                       pTaskResumed,
IN  PRM_STACK_RECORD            pSR
);

RM_STATUS
RmPendTaskOnOtherTask(
IN  PRM_TASK                    pTask,
IN  UINT                        SuspendContext,
IN  PRM_TASK                    pOtherTask,
IN  PRM_STACK_RECORD            pSR
);

// See  03/26/1999 notes.txt entry "Some proposed ..."
//
RM_STATUS
RmPendOnOtherTaskV2(
IN  PRM_TASK                    pTask,
IN  UINT                        SuspendContext,
IN  PRM_TASK                    pOtherTask,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmCancelPendOnOtherTask(
IN  PRM_TASK                    pTask,
IN  PRM_TASK                    pOtherTask,
IN  UINT_PTR                    UserParam,
IN  PRM_STACK_RECORD            pSR
);

//
// Timer management
//
VOID
RmResetAgeingTimer(
IN  PRM_OBJECT_HEADER           pObj,
IN  UINT                        Timeout,
IN  PRM_STACK_RECORD            pSR
);

//
// Hash table manipulation.
//

VOID
RmInitializeHashTable(
PRM_HASH_INFO pHashInfo,
PVOID         pAllocationContext,
PRM_HASH_TABLE pHashTable
);

VOID
RmDeinitializeHashTable(
PRM_HASH_TABLE pHashTable
);

BOOLEAN
RmLookupHashTable(
PRM_HASH_TABLE      pHashTable,
PRM_HASH_LINK **    pppLink,
PVOID               pvRealKey
);

BOOLEAN
RmNextHashTableItem(
PRM_HASH_TABLE      pHashTable,
PRM_HASH_LINK       pCurrentLink,   // OPTIONAL
PRM_HASH_LINK *    ppNextLink
);

VOID
RmAddHashItem(
PRM_HASH_TABLE  pHashTable,
PRM_HASH_LINK * ppLink,
PRM_HASH_LINK   pLink,
PVOID           pvKey
);

VOID
RmRemoveHashItem(
PRM_HASH_TABLE  pHashTable,
PRM_HASH_LINK   pLinkToRemove
);

typedef
VOID
(*PFN_ENUM_HASH_TABLE)
(
PRM_HASH_LINK pLink,
PVOID pvContext,
PRM_STACK_RECORD pSR
);

VOID
RmEnumHashTable(
PRM_HASH_TABLE          pHashTable,
PFN_ENUM_HASH_TABLE     pfnEnumerator,
PVOID                   pvContext,
PRM_STACK_RECORD        pSR
);

#if OBSOLETE
//
// Indexes of objects.
//

RM_STATUS
RmAllocateObjectIndex(
IN  PRM_OBJECT_HEADER           pParentObject,
// OBSOLETE IN  PRM_OBJECT_ALLOCATOR        pObjectAllocator,
IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
IN  PULONG                      Flags,
OUT PRM_OBJECT_INDEX *          ppObjectIndex,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmFreeObjectIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PRM_STACK_RECORD            pSR
);

RM_STATUS
RmLookupObjectInIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PULONG                      Flags, // create, remove, lock
IN  PVOID                       pvKey,
OUT PRM_OBJECT_HEADER *         ppObject,
IN  PRM_STACK_RECORD            pSR
);


RM_STATUS
RmRemoveObjectFromIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PRM_OBJECT_HEADER           pObject,
IN  PRM_STACK_RECORD            pSR
);

typedef
RM_STATUS
(*PFN_RM_OBJECT_INDEX_ENUMERATOR)(
IN  PRM_OBJECT_HEADER           pObject,
IN  PVOID                       pvContext,
IN  PRM_STACK_RECORD            pSR
);

RmEnumerateObjectsInIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PFN_RM_OBJECT_INDEX_ENUMERATOR
                                pfnEnumerator,
IN  PRM_STACK_RECORD            pSR
);

#endif // OBSOLETE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\enum\sys\enum1394.h ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    1394enum.h

Abstract:

    Definitions for 1394 Ndis enumerator

Author:

    Alireza Dabagh (alid) Nov 98

Environment:

    Kernel mode only

Revision History:


--*/


#ifndef _NDISENUM1394_
#define _NDISENUM1394_

typedef struct _NDISENUM1394_LOCAL_HOST     NDISENUM1394_LOCAL_HOST,*PNDISENUM1394_LOCAL_HOST;
typedef struct _NDISENUM1394_REMOTE_NODE    NDISENUM1394_REMOTE_NODE,*PNDISENUM1394_REMOTE_NODE;

//
// flags for LocalHost->Flags
//
#define     NDISENUM1394_LOCALHOST_REGISTERED       0x00000001

//
// flags for RemoteNode->Flags
//
#define     NDISENUM1394_NODE_INDICATED             0x00000001
#define     NDISENUM1394_NODE_ADDED                 0x00000002
#define     NDISENUM1394_NODE_PNP_STARTED           0x00000004
#define     NDISENUM1394_NODE_PNP_REMOVED           0x00000008


#define     NDISENUM1394_TAG_LOCAL_HOST     'hl4N'
#define     NDISENUM1394_TAG_WORK_ITEM      'iw4N'
#define     NDISENUM1394_TAG_IRB            'br4N'
#define     NDISENUM1394_TAG_DEVICE_NAME    'nd4N'
#define     NDISENUM1394_TAG_1394API_REQ    'qr4N'
#define     NDISENUM1394_TAG_DEFAULT        '  4N'

#define ENUM_SET_FLAG(_M, _F)           ((_M)->Flags |= (_F))
#define ENUM_CLEAR_FLAG(_M, _F)         ((_M)->Flags &= ~(_F))
#define ENUM_TEST_FLAG(_M, _F)          (((_M)->Flags & (_F)) != 0)
#define ENUM_TEST_FLAGS(_M, _F)         (((_M)->Flags & (_F)) == (_F))


typedef enum _NDIS_PNP_DEVICE_STATE
{
    PnPDeviceAdded,
    PnPDeviceStarted,
    PnPDeviceQueryStopped,
    PnPDeviceStopped,
    PnPDeviceQueryRemoved,
    PnPDeviceRemoved,
    PnPDeviceSurpriseRemoved
} NDIS_PNP_DEVICE_STATE;

typedef enum _NDISENUM1394_PNP_OP
{
    NdisEnum1394_StopDevice,
    NdisEnum1394_RemoveDevice,
    NdisEnum1394_SurpriseRemoveDevice,
    
    
} NDISENUM1394_PNP_OP, *PNDISENUM1394_PNP_OP;


//
// block used for references...
//
typedef struct _REFERENCE
{
    KSPIN_LOCK                  SpinLock;
    USHORT                      ReferenceCount;
    BOOLEAN                     Closing;
} REFERENCE, * PREFERENCE;

//
// one per 1394 local host. all remote 1394 controllers connected to a local host
// will be queued on this structure
//
struct _NDISENUM1394_LOCAL_HOST
{
    PNDISENUM1394_LOCAL_HOST        Next;                   // next local host node
    PVOID                           Nic1394AdapterContext;  // Nic1394 context for the local host
    LARGE_INTEGER                   UniqueId;               // unique ID for local host
    PDEVICE_OBJECT                  PhysicalDeviceObject;   // PDO created by 1394 bus
    PNDISENUM1394_REMOTE_NODE       RemoteNodeList;         // remote Nodes on local host
    KSPIN_LOCK                      Lock;
    ULONG                           Flags;
    REFERENCE                       Reference;
};


//
// one per remote node
//
struct _NDISENUM1394_REMOTE_NODE
{
    PNDISENUM1394_REMOTE_NODE       Next;
    PVOID                           Nic1394NodeContext;     // Nic1394 context for the remote node
    PDEVICE_OBJECT                  DeviceObject;
    PDEVICE_OBJECT                  NextDeviceObject;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    KSPIN_LOCK                      Lock;
    PNDISENUM1394_LOCAL_HOST        LocalHost;
    ULONG                           Flags;
    ULONG                           UniqueId[2];
    NDIS_PNP_DEVICE_STATE           PnPDeviceState;
    REFERENCE                       Reference;
};


#define INITIALIZE_EVENT(_pEvent_)          KeInitializeEvent(_pEvent_, NotificationEvent, FALSE)
#define SET_EVENT(_pEvent_)                 KeSetEvent(_pEvent_, 0, FALSE)
#define RESET_EVENT(_pEvent_)               KeResetEvent(_pEvent_)

#define WAIT_FOR_OBJECT(_O_, _TO_)          KeWaitForSingleObject(_O_,          \
                                                                  Executive,    \
                                                                  KernelMode,   \
                                                                  FALSE,        \
                                                                  _TO_)         \

#define ALLOC_FROM_POOL(_Size_, _Tag_)      ExAllocatePoolWithTag(NonPagedPool,     \
                                                                  _Size_,           \
                                                                  _Tag_)
                                                                  
#define FREE_POOL(_P_)                      ExFreePool(_P_)


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PUNICODE_STRING         RegistryPath
    );

VOID
ndisEnum1394InitializeRef(
    IN  PREFERENCE              RefP
    );
    
BOOLEAN
ndisEnum1394ReferenceRef(
    IN  PREFERENCE              RefP
    );

BOOLEAN
ndisEnum1394DereferenceRef(
    IN  PREFERENCE              RefP
    );
    
BOOLEAN
ndisEnum1394CloseRef(
    IN  PREFERENCE              RefP
    );

BOOLEAN
ndisEnum1394ReferenceLocalHost(
        IN PNDISENUM1394_LOCAL_HOST LocalHost
        );

BOOLEAN
ndisEnum1394DereferenceLocalHost(
    IN  PNDISENUM1394_LOCAL_HOST    LocalHost
    );

NTSTATUS
ndisEnum1394AddDevice(
    PDRIVER_OBJECT              DriverObject,
    PDEVICE_OBJECT              PhysicalDeviceObject
    );

NTSTATUS
ndisEnum1394PnpDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );
    
NTSTATUS
ndisEnum1394PowerDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );
    
NTSTATUS
ndisEnum1394WMIDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );

NTSTATUS
ndisEnum1394StartDevice(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );  

NTSTATUS
ndisEnum1394RemoveDevice(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                Irp,
    NDISENUM1394_PNP_OP PnpOp
    );

NTSTATUS
ndisEnum1394CreateIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );

NTSTATUS
ndisEnum1394CloseIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );
    
NTSTATUS
ndisEnum1394DeviceIoControl(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );

VOID
ndisEnum1394Unload(
    IN  PDRIVER_OBJECT          DriverObject
    );

NTSTATUS
ndisEnum1394GetLocalHostForRemoteNode(
    IN  PNDISENUM1394_REMOTE_NODE       RemoteNode,
    OUT PNDISENUM1394_LOCAL_HOST *      pLocalHost
    );
    
VOID
ndisEnum1394GetLocalHostForUniqueId(
    LARGE_INTEGER                   UniqueId,
    OUT PNDISENUM1394_LOCAL_HOST *  pLocalHost
    );
    
NTSTATUS
ndisEnum1394BusRequest(
    PDEVICE_OBJECT              DeviceObject,
    PIRB                        Irb
    );

NTSTATUS
ndisEnum1394IrpCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    );
    
NTSTATUS
ndisEnum1394PassIrpDownTheStack(
    IN  PIRP            pIrp,
    IN  PDEVICE_OBJECT  pNextDeviceObject
    );

VOID
ndisEnum1394FreeLocalHost(
    IN PNDISENUM1394_LOCAL_HOST LocalHost
    );

VOID
ndisEnum1394IndicateNodes(
    PNDISENUM1394_LOCAL_HOST    LocalHost
    );

NTSTATUS
ndisEnum1394DummyIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    );

NTSTATUS
NdisEnum1394RegisterDriver(
    IN  PNIC1394_CHARACTERISTICS    Characteristics
    );

VOID
NdisEnum1394DeregisterDriver(
    VOID
    );

NTSTATUS
NdisEnum1394RegisterAdapter(
    IN  PVOID                   Nic1394AdapterContext,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject,
    OUT PVOID*                  pEnum1394AdapterHandle,
    OUT PLARGE_INTEGER          pLocalHostUniqueId
    );

VOID
NdisEnum1394DeregisterAdapter(
    IN  PVOID                   Enum1394AdapterHandle
    );

VOID
Enum1394Callback(
    PVOID   CallBackContext,
    PVOID   Source,
    PVOID   Characteristics
    );

//
// different debug level defines
//

#define ENUM1394_DBGLEVEL_NONE          0
#define ENUM1394_DBGLEVEL_ERROR         1
#define ENUM1394_DBGLEVEL_WARN          2
#define ENUM1394_DBGLEVEL_INFO          3

#if DBG
#define DBGBREAK        DbgBreakPoint
#define DbgIsNull(_Ptr)  ( ((PVOID)(_Ptr)) == NULL )

#define DBGPRINT(Level, Fmt)                                                \
    {                                                                       \
        if (Enum1394DebugLevel >= Level)                                    \
        {                                                                   \
            DbgPrint Fmt;                                                   \
        }                                                                   \
    }
    
#else
#define DBGPRINT 
#define DBGBREAK()
#define DbgIsNull(_Ptr)         FALSE
#endif


#endif      //_NDIS_1394_ENUM_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\wmi.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    WMI entry points for ARP1394.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     11-23-98    Created

Notes:

--*/
#include <precomp.h>


//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_WMI


NTSTATUS
ArpWmiDispatch(
    IN  PDEVICE_OBJECT              pDeviceObject,
    IN  PIRP                        pIrp
)
/*++

Routine Description:

    System dispatch function for handling IRP_MJ_SYSTEM_CONTROL IRPs from WMI.

Arguments:

    pDeviceObject   - Pointer to device object. The device extension field
                      contains a pointer to the Interface 

    pIrp            - Pointer to IRP.

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION      pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    PVOID                   DataPath = pIrpSp->Parameters.WMI.DataPath;
    ULONG                   BufferSize = pIrpSp->Parameters.WMI.BufferSize;
    PVOID                   pBuffer = pIrpSp->Parameters.WMI.Buffer;
    NTSTATUS                Status =  STATUS_UNSUCCESSFUL;
    ULONG                   ReturnSize;
    ENTER("WmiDispatch", 0x9141e00e)

#if 0
    PATMARP_INTERFACE       pInterface;

    pInterface = AA_PDO_TO_INTERFACE(pDeviceObject);

    AA_STRUCT_ASSERT(pInterface, aai);

    ReturnSize = 0;

    switch (pIrpSp->MinorFunction)
    {
        case IRP_MN_REGINFO:

            Status = AtmArpWmiRegister(
                        pInterface,
                        PtrToUlong(DataPath),
                        pBuffer,
                        BufferSize,
                        &ReturnSize
                        );
            break;
        
        case IRP_MN_QUERY_ALL_DATA:

            Status = AtmArpWmiQueryAllData(
                        pInterface,
                        (LPGUID)DataPath,
                        (PWNODE_ALL_DATA)pBuffer,
                        BufferSize,
                        &ReturnSize
                        );
            break;
        
        case IRP_MN_QUERY_SINGLE_INSTANCE:

            Status = AtmArpWmiQuerySingleInstance(
                        pInterface,
                        pBuffer,
                        BufferSize,
                        &ReturnSize
                        );
            
            break;

        case IRP_MN_CHANGE_SINGLE_INSTANCE:

            Status = AtmArpWmiChangeSingleInstance(
                        pInterface,
                        pBuffer,
                        BufferSize,
                        &ReturnSize
                        );
            break;

        case IRP_MN_CHANGE_SINGLE_ITEM:

            Status = AtmArpWmiChangeSingleItem(
                        pInterface,
                        pBuffer,
                        BufferSize,
                        &ReturnSize
                        );
            break;

        case IRP_MN_ENABLE_EVENTS:

            Status = AtmArpWmiSetEventStatus(
                        pInterface,
                        (LPGUID)DataPath,
                        TRUE                // Enable
                        );
            break;

        case IRP_MN_DISABLE_EVENTS:

            Status = AtmArpWmiSetEventStatus(
                        pInterface,
                        (LPGUID)DataPath,
                        FALSE               // Disable
                        );
            break;

        case IRP_MN_ENABLE_COLLECTION:
        case IRP_MN_DISABLE_COLLECTION:
        default:
        
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = (NT_SUCCESS(Status) ? ReturnSize: 0);

    AADEBUGP(AAD_INFO,
        ("WmiDispatch done: IF x%p, MinorFn %d, Status x%p, ReturnInfo %d\n",
                pInterface, pIrpSp->MinorFunction, Status, pIrp->IoStatus.Information));

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

#endif // 0

    EXIT()
    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\util.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Utility functions for ARP1394.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     01-05-99    Created

Notes:

--*/
#include <precomp.h>




//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_UT


//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

VOID
arpTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );



//
// TODO: make these globals constant data.
//


// ArpTasks_StaticInfo contains static information about
// objects of type  ARP1394_TASK;
//
RM_STATIC_OBJECT_INFO
ArpTasks_StaticInfo = 
{
    0, // TypeUID
    0, // TypeFlags
    "ARP1394 Task", // TypeName
    0, // Timeout

    NULL, // pfnCreate
    arpTaskDelete, // pfnDelete
    NULL,   // LockVerifier

    0,   // length of resource table
    NULL // Resource Table
};



VOID
arpTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free an object of type ARP1394_TASK.

Arguments:

    pHdr    - Actually a pointer to the ARP1394_TASK to be deleted.

--*/
{
    TASK_BACKUP* pTask= (TASK_BACKUP*)pObj;

    if (CHECK_TASK_IS_BACKUP(&pTask->Hdr) == TRUE)
    {
        arpReturnBackupTask((ARP1394_TASK*)pTask);
    }
    else
    {
        ARP_FREE(pObj);
    }
}


VOID
arpObjectDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free an unspecified object owned by the ARP module.

Arguments:

    pHdr    - Object to be freed.

--*/
{
    ARP_FREE(pObj);
}


VOID
arpAdapterDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free an object of type ARP1394_ADAPTER.

Arguments:

    pHdr    - Actually a pointer to the ARP1394_ADAPTER to be deleted.

--*/
{
    ARP1394_ADAPTER * pA = (ARP1394_ADAPTER *) pObj;

    if (pA->bind.DeviceName.Buffer != NULL)
    {
        ARP_FREE(pA->bind.DeviceName.Buffer);
    }

    if (pA->bind.ConfigName.Buffer != NULL)
    {
        ARP_FREE(pA->bind.ConfigName.Buffer);
    }

    if (pA->bind.IpConfigString.Buffer != NULL)
    {
        ARP_FREE(pA->bind.IpConfigString.Buffer);
    }

    ARP_FREE(pA);
}

NDIS_STATUS
arpAllocateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription, OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Allocates and initializes a task of subtype ARP1394_TASK.

Arguments:

    pParentObject       - Object that is to be the parent of the allocated task.
    pfnHandler          - The task handler for the task.
    Timeout             - Unused.
    szDescription       - Text describing this task.
    ppTask              - Place to store pointer to the new task.

Return Value:

    NDIS_STATUS_SUCCESS if we could allocate and initialize the task.
    NDIS_STATUS_RESOURCES otherwise
--*/
{
    ARP1394_TASK *pATask;
    NDIS_STATUS Status;
    BOOLEAN fBackupTask = FALSE;

    ARP_ALLOCSTRUCT(pATask, MTAG_TASK); // TODO use lookaside lists.

    if (pATask == NULL)
    {   
        pATask = arpGetBackupTask(&ArpGlobals);
        fBackupTask = TRUE;
    }
        
    *ppTask = NULL;

    if (pATask != NULL)
    {
        ARP_ZEROSTRUCT(pATask);

        RmInitializeTask(
                &(pATask->TskHdr),
                pParentObject,
                pfnHandler,
                &ArpTasks_StaticInfo,
                szDescription,
                Timeout,
                pSR
                );
        *ppTask = &(pATask->TskHdr);
        Status = NDIS_STATUS_SUCCESS;

        if (fBackupTask  == TRUE)
        {
            MARK_TASK_AS_BACKUP(&pATask->TskHdr);
        }
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }


    return Status;
}


NDIS_STATUS
arpCopyUnicodeString(
        OUT         PNDIS_STRING pDest,
        IN          PNDIS_STRING pSrc,
        BOOLEAN     fUpCase
        )
/*++

Routine Description:

    Copy the contents of unicode string pSrc into pDest.
    pDest->Buffer is allocated using NdisAllocateMemoryWithTag; Caller is
    responsible for freeing it.

    EXTRA EXTRA EXTRA:
        This make sure the destination is NULL terminated.
        IPAddInterface expects the Unicode string passed in to be
        NULL terminated.

    NOTE: fUpCase is ignored.

Return Value:

    NDIS_STATUS_SUCCESS on success;
    NDIS failure status on failure.
--*/
{
    USHORT Length = pSrc->Length;
    PWCHAR pwStr;
    NdisAllocateMemoryWithTag(&pwStr, Length+sizeof(WCHAR), MTAG_STRING);
    ARP_ZEROSTRUCT(pDest);

    if  (pwStr == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }
    else
    {
        pDest->Length = Length;
        pDest->MaximumLength = Length+sizeof(WCHAR);

        pDest->Buffer = pwStr;

        // We-- ignore the copy flag.
        // For some reason, we're not in passive, and moreover 
        // NdisUpcaseUnicode doesn't work.
        //
        if (0 && fUpCase)
        {
        #if !MILLEN

            ASSERT_PASSIVE();
            NdisUpcaseUnicodeString(pDest, pSrc);
        #endif // !MILLEN
        }
        else
        {
            NdisMoveMemory(pwStr, pSrc->Buffer, Length);
            if (Length & 0x1)
            {
                ((PUCHAR)pwStr)[Length] = 0;
            }
            else
            {
                pwStr[Length/sizeof(*pwStr)] = 0;
            }
        }

        return NDIS_STATUS_SUCCESS;
    }
}

VOID
arpSetPrimaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpSetPrimaryIfTask", 0x535f8cd4)
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    ASSERT(pIF->pPrimaryTask==NULL);

#if DBG
    // Veriy that this is a valid primary task. Also verify that PrimaryState
    // is a valid primary state.
    //
    {
        PFN_RM_TASK_HANDLER pfn = pTask->pfnHandler;
        ASSERT(
            ((pfn == arpTaskInitInterface) && (PrimaryState == ARPIF_PS_INITING))
        || ((pfn == arpTaskDeinitInterface) && (PrimaryState == ARPIF_PS_DEINITING))
        || ((pfn == arpTaskReinitInterface) && (PrimaryState == ARPIF_PS_REINITING))
        || ((pfn == arpTaskLowPower) && (PrimaryState == ARPIF_PS_LOW_POWER))
            );
    }
#endif // DBG

    //
    // Although it's tempting to put pTask as entity1 and pRask->Hdr.szDescption as
    // entity2 below, we specify NULL for both so that we can be sure that ONLY one
    // primary task can be active at any one time.
    //
    DBG_ADDASSOC(
        &pIF->Hdr,
        NULL,                           // Entity1
        NULL,                           // Entity2
        ARPASSOC_PRIMARY_IF_TASK,
        "   Primary task\n",
        pSR
        );

    pIF->pPrimaryTask = pTask;
    SET_IF_PRIMARY_STATE(pIF, PrimaryState);

    EXIT()
}


VOID
arpClearPrimaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpClearPrimaryIfTask", 0x10ebb0c3)

    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);
    ASSERT(pIF->pPrimaryTask==pTask);

    // Veriy that PrimaryState is a valid primary state.
    //
    ASSERT(
            (PrimaryState == ARPIF_PS_INITED)
        ||  (PrimaryState == ARPIF_PS_FAILEDINIT)
        ||  (PrimaryState == ARPIF_PS_DEINITED)
        );

    // Delete the association added when setting the primary IF task
    //
    DBG_DELASSOC(
        &pIF->Hdr,
        NULL,
        NULL,
        ARPASSOC_PRIMARY_IF_TASK,
        pSR
        );

    pIF->pPrimaryTask = NULL;
    SET_IF_PRIMARY_STATE(pIF, PrimaryState);

    EXIT()
}


VOID
arpSetSecondaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpSetSecondaryIfTask", 0xf7e925d1)
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    if (pIF->pActDeactTask != NULL)
    {
        ASSERT(FALSE);
        return;                                     // EARLY RETURN
    }

#if DBG
    // Veriy that this is a valid act/deact task. Also verify that SecondaryState
    // is a valid state.
    //
    {
        PFN_RM_TASK_HANDLER pfn = pTask->pfnHandler;
        ASSERT(
   ((pfn == arpTaskActivateInterface) && (SecondaryState == ARPIF_AS_ACTIVATING))
|| ((pfn == arpTaskDeactivateInterface) && (SecondaryState == ARPIF_AS_DEACTIVATING))
            );
    }
#endif // DBG

    //
    // Although it's tempting to put pTask as entity1 and pRask->Hdr.szDescption as
    // entity2 below, we specify NULL for both so that we can be sure that ONLY one
    // primary task can be active at any one time.
    //
    DBG_ADDASSOC(
        &pIF->Hdr,
        NULL,                           // Entity1
        NULL,                           // Entity2
        ARPASSOC_ACTDEACT_IF_TASK,
        "   ActDeact task\n",
        pSR
        );

    pIF->pActDeactTask = pTask;
    SET_IF_ACTIVE_STATE(pIF, SecondaryState);

    EXIT()
}


VOID
arpClearSecondaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpClearSecondaryIfTask", 0x2068f420)
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    if (pIF->pActDeactTask != pTask)
    {
        ASSERT(FALSE);
        return;                                     // EARLY RETURN
    }

    // Veriy that SecondaryState is a valid primary state.
    //
    ASSERT(
            (SecondaryState == ARPIF_AS_ACTIVATED)
        ||  (SecondaryState == ARPIF_AS_FAILEDACTIVATE)
        ||  (SecondaryState == ARPIF_AS_DEACTIVATED)
        );

    // Delete the association added when setting the primary IF task
    //
    DBG_DELASSOC(
        &pIF->Hdr,
        NULL,
        NULL,
        ARPASSOC_ACTDEACT_IF_TASK,
        pSR
        );

    pIF->pActDeactTask = NULL;
    SET_IF_ACTIVE_STATE(pIF, SecondaryState);

    EXIT()
}


VOID
arpSetPrimaryAdapterTask(
    PARP1394_ADAPTER pAdapter,          // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpSetPrimaryAdapterTask", 0x535f8cd4)
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    ASSERT(pAdapter->bind.pPrimaryTask==NULL);

#if DBG
    // Veriy that this is a valid primary task. Also verify that PrimaryState
    // is a valid primary state.
    //
    {
        PFN_RM_TASK_HANDLER pfn = pTask->pfnHandler;
        ASSERT(
            ((pfn == arpTaskInitializeAdapter) && (PrimaryState == ARPAD_PS_INITING))
        || ((pfn == arpTaskShutdownAdapter) && (PrimaryState == ARPAD_PS_DEINITING))
        || (pfn == arpTaskLowPower) || ( pfn == arpTaskOnPower) 
            );
    }
#endif // DBG

    //
    // Although it's tempting to put pTask as entity1 and pRask->Hdr.szDescption as
    // entity2 below, we specify NULL for both so that we can be sure that ONLY one
    // primary task can be active at any one time.
    //
    DBG_ADDASSOC(
        &pAdapter->Hdr,
        NULL,                           // Entity1
        NULL,                           // Entity2
        ARPASSOC_PRIMARY_AD_TASK,
        "   Primary task\n",
        pSR
        );

    pAdapter->bind.pPrimaryTask = pTask;
    SET_AD_PRIMARY_STATE(pAdapter, PrimaryState);

    EXIT()
}


VOID
arpClearPrimaryAdapterTask(
    PARP1394_ADAPTER pAdapter,          // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpClearPrimaryAdapterTask", 0x9062b2ab)

    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);
    ASSERT(pAdapter->bind.pPrimaryTask==pTask);

    // Veriy that PrimaryState is a valid primary state.
    //
    ASSERT(
            (PrimaryState == ARPAD_PS_INITED)
        ||  (PrimaryState == ARPAD_PS_FAILEDINIT)
        ||  (PrimaryState == ARPAD_PS_DEINITED)
        );

    // Delete the association added when setting the primary IF task
    //
    DBG_DELASSOC(
        &pAdapter->Hdr,
        NULL,
        NULL,
        ARPASSOC_PRIMARY_AD_TASK,
        pSR
        );

    pAdapter->bind.pPrimaryTask = NULL;
    SET_AD_PRIMARY_STATE(pAdapter, PrimaryState);

    EXIT()
}


VOID
arpSetSecondaryAdapterTask(
    PARP1394_ADAPTER pAdapter,          // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpSetSecondaryAdapterTask", 0x95dae9ac)
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    if (pAdapter->bind.pSecondaryTask != NULL)
    {
        ASSERT(FALSE);
        return;                                     // EARLY RETURN
    }

#if DBG
    // Veriy that this is a valid act/deact task. Also verify that SecondaryState
    // is a valid state.
    //
    {
        PFN_RM_TASK_HANDLER pfn = pTask->pfnHandler;
        ASSERT(
   ((pfn == arpTaskActivateAdapter) && (SecondaryState == ARPAD_AS_ACTIVATING))
|| ((pfn == arpTaskDeactivateAdapter) && (SecondaryState == ARPAD_AS_DEACTIVATING))
            );
    }
#endif // DBG

    //
    // Although it's tempting to put pTask as entity1 and pRask->Hdr.szDescption as
    // entity2 below, we specify NULL for both so that we can be sure that ONLY one
    // primary task can be active at any one time.
    //
    DBG_ADDASSOC(
        &pAdapter->Hdr,
        NULL,                           // Entity1
        NULL,                           // Entity2
        ARPASSOC_ACTDEACT_AD_TASK,
        "   Secondary task\n",
        pSR
        );

    pAdapter->bind.pSecondaryTask = pTask;
    SET_AD_ACTIVE_STATE(pAdapter, SecondaryState);

    EXIT()
}


VOID
arpClearSecondaryAdapterTask(
    PARP1394_ADAPTER pAdapter,          // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("arpClearSecondaryAdapterTask", 0xc876742b)
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    if (pAdapter->bind.pSecondaryTask != pTask)
    {
        ASSERT(FALSE);
        return;                                     // EARLY RETURN
    }

    // Veriy that SecondaryState is a valid primary state.
    //
    ASSERT(
            (SecondaryState == ARPAD_AS_ACTIVATED)
        ||  (SecondaryState == ARPAD_AS_FAILEDACTIVATE)
        ||  (SecondaryState == ARPAD_AS_DEACTIVATED)
        );

    // Delete the association added when setting the primary IF task
    //
    DBG_DELASSOC(
        &pAdapter->Hdr,
        NULL,
        NULL,
        ARPASSOC_ACTDEACT_AD_TASK,
        pSR
        );

    pAdapter->bind.pSecondaryTask = NULL;
    SET_AD_ACTIVE_STATE(pAdapter, SecondaryState);

    EXIT()
}

#if 0
NDIS_STATUS
arpCopyAnsiStringToUnicodeString(
        OUT         PNDIS_STRING pDest,
        IN          PANSI_STRING pSrc
        )
/*++

Routine Description:

    Converts pSrc into unicode and sets up pDest with the it.
    pDest->Buffer is allocated using NdisAllocateMemoryWithTag; Caller is
    responsible for freeing it.

Return Value:

    NDIS_STATUS_SUCCESS on success;
    NDIS_STATUS_RESOURCES on failure.
--*/
{

    UINT Size;
    PWCHAR pwStr;
    Size = sizeof(WCHAR) * pSrc->MaximumLength;
    NdisAllocateMemoryWithTag(&pwStr, Size, MTAG_STRING);

    ARP_ZEROSTRUCT(pDest);

    if  (pwStr == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }
    else
    {
        pDest->MaximumLength = Size;
        pDest->Buffer = pwStr;
        NdisAnsiStringToUnicodeString(pDest, pSrc);
        return NDIS_STATUS_SUCCESS;
    }
}


NDIS_STATUS
arpCopyUnicodeStringToAnsiString(
        OUT         PANSI_STRING pDest,
        IN          PNDIS_STRING pSrc
        )
/*++

Routine Description:

    Converts pSrc into ansi and sets up pDest with the it.
    pDest->Buffer is allocated using NdisAllocateMemoryWithTag; Caller is
    responsible for freeing it.

Return Value:

    NDIS_STATUS_SUCCESS on success;
    NDIS_STATUS_RESOURCES on failure.
--*/
{

    UINT Size;
    PCHAR pStr;
    Size = pSrc->MaximumLength/sizeof(WCHAR) + sizeof(WCHAR);
    NdisAllocateMemoryWithTag(&pStr, Size, MTAG_STRING);

    ARP_ZEROSTRUCT(pDest);

    if  (pStr == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }
    else
    {
        pDest->Buffer = pStr;
        NdisUnicodeStringToAnsiString(pDest, pSrc);
        pStr[pDest->Length] = 0;
        pDest->MaximumLength = Size; // Must be done AFTER call to
                                     // NdisUnicodeStringToAnsiString, which
                                     // sets MaximumLength to Length;
        return NDIS_STATUS_SUCCESS;
    }
}
#endif // 0


UINT
arpGetSystemTime(VOID)
/*++
    Returns system time in seconds.

    Since it's in seconds, we won't overflow unless the system has been up for over
    a  100 years :-)
--*/
{
    LARGE_INTEGER Time;
    NdisGetCurrentSystemTime(&Time);
    Time.QuadPart /= 10000000;          //10-nanoseconds to seconds.

    return Time.LowPart;
}

#if ARP_DO_TIMESTAMPS

void
arpTimeStamp(
    char *szFormatString,
    UINT Val
    )
{
    UINT Minutes;
    UINT Seconds;
    UINT Milliseconds;
    LARGE_INTEGER Time;
    NdisGetCurrentSystemTime(&Time);
    Time.QuadPart /= 10000;         //10-nanoseconds to milliseconds.
    Milliseconds = Time.LowPart; // don't care about highpart.
    Seconds = Milliseconds/1000;
    Milliseconds %= 1000;
    Minutes = Seconds/60;
    Seconds %= 60;


    DbgPrint( szFormatString, Minutes, Seconds, Milliseconds, Val);
}


#endif // ARP_DO_TIMESTAMPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\enum\sys\enum1394.c ===
/*++


Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    enum1394.c
    
Abstract:

    1394 ndis enumerator
    
    Author: Alireza Dabagh (alid)


Environment:

    Kernel mode

Revision History :

--*/

#include <wdm.h>
//
// extra stuff to keep ks.h happy
//
#ifndef CDECL
#define CDECL
#endif
#ifndef BOOL
#define BOOL    int
#endif

#define ENUM1394_NT 1

#include "1394.h"
#include "ndis1394.h"
#include "enum1394.h"
#include "ntdd1394.h"

#define NDISENUM1394_DEVICE_NAME    L"\\Device\\NdisEnum1394"
#define NDISENUM1394_SYMBOLIC_NAME  L"\\DosDevices\\NDISENUM1394"


NDISENUM1394_CHARACTERISTICS NdisEnum1394Characteristics =
{
    1,
    0,
    0,
    NdisEnum1394RegisterDriver,
    NdisEnum1394DeregisterDriver,
    NdisEnum1394RegisterAdapter,
    NdisEnum1394DeregisterAdapter
};



KSPIN_LOCK                      ndisEnum1394GlobalLock;
ULONG                           Enum1394DebugLevel = ENUM1394_DBGLEVEL_ERROR   ;
PNDISENUM1394_LOCAL_HOST        LocalHostList = (PNDISENUM1394_LOCAL_HOST)NULL;

NIC1394_ADD_NODE_HANLDER            AddNodeHandler = NULL;
NIC1394_REMOVE_NODE_HANLDER         RemoveNodeHandler = NULL;
NIC1394_REGISTER_DRIVER_HANDLER     RegisterDriverHandler = NULL;
NIC1394_DEREGISTER_DRIVER_HANDLER   DeRegisterDriverHandler = NULL;


PDEVICE_OBJECT                  ndisEnum1394DeviceObject = NULL;
PDRIVER_OBJECT                  ndisEnum1394DriverObject = NULL;
PCALLBACK_OBJECT                ndisEnum1394CallbackObject = NULL;
PVOID                           ndisEnum1394CallbackRegisterationHandle = NULL;

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called at system initialization time so we can fill in the basic dispatch points

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS

--*/

{
    OBJECT_ATTRIBUTES   ObjectAttr;
    UNICODE_STRING      CallBackObjectName;
    NTSTATUS            Status;
    UNICODE_STRING      DeviceName;
    BOOLEAN             fDerefCallbackObject = FALSE;
    BOOLEAN             fDeregisterCallback = FALSE;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO,("Enum1394 DriverEntry.\n"));
    
    do
    {
        KeInitializeSpinLock(&ndisEnum1394GlobalLock);

        RtlInitUnicodeString(&DeviceName, NDISENUM1394_DEVICE_NAME);


        ndisEnum1394DriverObject = DriverObject;

        RtlInitUnicodeString(&CallBackObjectName, NDIS1394_CALLBACK_NAME);

        InitializeObjectAttributes(&ObjectAttr,
                                   &CallBackObjectName,
                                   OBJ_CASE_INSENSITIVE | OBJ_PERMANENT | OBJ_KERNEL_HANDLE,
                                   NULL,
                                   NULL);
                                   
        Status = ExCreateCallback(&ndisEnum1394CallbackObject,
                                  &ObjectAttr,
                                  TRUE,
                                  TRUE);

        
        if (!NT_SUCCESS(Status))
        {

            DBGPRINT(ENUM1394_DBGLEVEL_ERROR,("Enum1394 DriverEntry: failed to create a Callback object. Status %lx\n", Status));
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        fDerefCallbackObject = TRUE;
        
        ndisEnum1394CallbackRegisterationHandle = ExRegisterCallback(ndisEnum1394CallbackObject,
                                                                 Enum1394Callback,
                                                                 (PVOID)NULL);
        if (ndisEnum1394CallbackRegisterationHandle == NULL)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR,("Enum1394 DriverEntry: failed to register a Callback routine%lx\n"));
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        fDeregisterCallback = TRUE;

        ExNotifyCallback(ndisEnum1394CallbackObject,
                        (PVOID)NDIS1394_CALLBACK_SOURCE_ENUM1394,
                        (PVOID)&NdisEnum1394Characteristics);
        
        

        //
        // Initialize the Driver Object with driver's entry points
        //
        DriverObject->DriverExtension->AddDevice = ndisEnum1394AddDevice;
        
        //
        // Fill in the Mandatory handlers 
        //
        DriverObject->DriverUnload = ndisEnum1394Unload;

        DriverObject->MajorFunction[IRP_MJ_CREATE] = ndisEnum1394CreateIrpHandler;
        DriverObject->MajorFunction[IRP_MJ_CLOSE] = ndisEnum1394CloseIrpHandler;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ndisEnum1394DeviceIoControl;
        DriverObject->MajorFunction[IRP_MJ_PNP] = ndisEnum1394PnpDispatch;
        DriverObject->MajorFunction[IRP_MJ_POWER] = ndisEnum1394PowerDispatch;
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = ndisEnum1394WMIDispatch;
        
        fDerefCallbackObject =  fDeregisterCallback = FALSE;

        Status = STATUS_SUCCESS;
        
    } while(FALSE);

    if (fDeregisterCallback)
    {
        ExUnregisterCallback(ndisEnum1394CallbackRegisterationHandle);
    }

    if (fDerefCallbackObject)
    {
        ObDereferenceObject(ndisEnum1394CallbackObject);
    }


    if (Status != STATUS_SUCCESS)
    {
        if (DeRegisterDriverHandler != NULL)
            DeRegisterDriverHandler();
    }
    
    return Status;

}


NTSTATUS
ndisEnum1394AddDevice(
    PDRIVER_OBJECT  DriverObject,
    PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    This is our PNP AddDevice called with the PDO ejected from the bus driver

Arguments:


Return Value:

    

--*/

{
    NTSTATUS                    Status;
    PNDISENUM1394_REMOTE_NODE   RemoteNode;
    PDEVICE_OBJECT              DeviceObject, NextDeviceObject;
    KIRQL                       OldIrql;
    PNDISENUM1394_LOCAL_HOST    LocalHost;
    BOOLEAN                     FreeDevice = FALSE;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394AddDevice: PDO %lx\n", PhysicalDeviceObject));
    

    do
    {
    
        //
        // first create a FDO
        //

        Status = IoCreateDevice(
                        DriverObject,
                        sizeof (NDISENUM1394_REMOTE_NODE),  // extension size
                        NULL,                               // name (null for now)
                        FILE_DEVICE_NETWORK,                // device type
                        0,                                  // characteristics
                        FALSE,
                        &DeviceObject);


        if (!NT_SUCCESS(Status))
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394AddDevice: failed to create FDO. Status %lx, PDO %lx\n", Status, PhysicalDeviceObject));
            break;
        }

        FreeDevice = TRUE;

        DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        PhysicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        //
        //  Mark the device as being pageable.
        //
        DeviceObject->Flags |= DO_POWER_PAGABLE;

        //
        //  Attach our FDO to the PDO. This routine will return the top most
        //  device that is attached to the PDO or the PDO itself if no other
        //  device objects have attached to it.
        //
        NextDeviceObject = IoAttachDeviceToDeviceStack(DeviceObject, PhysicalDeviceObject);
        RtlZeroMemory(DeviceObject->DeviceExtension, sizeof (NDISENUM1394_REMOTE_NODE));

        RemoteNode = (PNDISENUM1394_REMOTE_NODE)DeviceObject->DeviceExtension;
        RemoteNode->DeviceObject = DeviceObject;
        RemoteNode->PhysicalDeviceObject = PhysicalDeviceObject;
        RemoteNode->NextDeviceObject = NextDeviceObject;
        RemoteNode->PnPDeviceState = PnPDeviceAdded;
        KeInitializeSpinLock(&RemoteNode->Lock);
        ndisEnum1394InitializeRef(&RemoteNode->Reference);

        Status = ndisEnum1394GetLocalHostForRemoteNode(RemoteNode, &LocalHost);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394AddDevice: ndisEnum1394GetLocalHostForRemoteNode failed. Status %lx\n", Status));
            break;
        }
        
        RemoteNode->LocalHost = LocalHost;

        ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);
        RemoteNode->Next = LocalHost->RemoteNodeList;
        LocalHost->RemoteNodeList = RemoteNode;
        ExReleaseSpinLock(&LocalHost->Lock, OldIrql);
    
        FreeDevice = FALSE;
        
    } while(FALSE);

    if (FreeDevice)
    {
        IoDeleteDevice(DeviceObject);
    }
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394AddDevice: Status %lx, PDO %lx, FDO %lx\n", Status, PhysicalDeviceObject, DeviceObject));
    
    return (Status);

}

NTSTATUS
ndisEnum1394PowerDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )
{
    PIO_STACK_LOCATION          IrpSp;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PDEVICE_OBJECT              NextDeviceObject;
    PNDISENUM1394_REMOTE_NODE   RemoteNode;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394PowerDispatch: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    if (IRP_MN_SET_POWER == IrpSp->MinorFunction ||
       IRP_MN_QUERY_POWER == IrpSp->MinorFunction )
    {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    PoStartNextPowerIrp(Irp);
   
    //
    // Set up the Irp for passing it down, no completion routine is needed
    //
    IoSkipCurrentIrpStackLocation(Irp);
    
    RemoteNode = (PNDISENUM1394_REMOTE_NODE)DeviceObject->DeviceExtension;
    
    //
    //  Get a pointer to the next miniport.
    //
    NextDeviceObject = RemoteNode->NextDeviceObject;
    
    //
    // Call the lower device
    //
    Status = PoCallDriver (NextDeviceObject, Irp);   

    ASSERT (Status != STATUS_PENDING);
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394PowerDispatch: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));
    
    return Status;
}


NTSTATUS
ndisEnum1394WMIDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PNDISENUM1394_REMOTE_NODE RemoteNode = NULL;
    PDEVICE_OBJECT      NextDeviceObject = NULL;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394WMIDispatch: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));
    
    
    //
    //  Get a pointer to the adapter block and miniport block then determine
    //  which one we should use.
    //
    RemoteNode = (PNDISENUM1394_REMOTE_NODE)DeviceObject->DeviceExtension;
    
    //
    //  Get a pointer to the next miniport.
    //
    NextDeviceObject = RemoteNode->NextDeviceObject;

    //
    // Pass the Irp Down
    //
    //
    // Set up the Irp for passing it down, no completion routine is needed
    //
    IoSkipCurrentIrpStackLocation(Irp);
       
    ntStatus = IoCallDriver (NextDeviceObject, Irp);

    return ntStatus;

}


NTSTATUS
ndisEnum1394StartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )   
{
    PNDISENUM1394_REMOTE_NODE   RemoteNode, TmpRemoteNode;
    PNDISENUM1394_LOCAL_HOST    LocalHost;
    NTSTATUS                    Status = STATUS_SUCCESS;
    KIRQL                       OldIrql;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394StartDevice: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    
    RemoteNode = (PNDISENUM1394_REMOTE_NODE)DeviceObject->DeviceExtension;
    LocalHost = RemoteNode->LocalHost;
    ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);
    
    do
    {

        //
        // if this is a duplicate node, leave it in the queue. but don't tag it as
        // being started so we don't end up indicating it
        //
        for (TmpRemoteNode = LocalHost->RemoteNodeList;
                        TmpRemoteNode != NULL;
                        TmpRemoteNode = TmpRemoteNode->Next)
        {
            if ((TmpRemoteNode->UniqueId[0] == RemoteNode->UniqueId[0]) &&
                (TmpRemoteNode->UniqueId[1] == RemoteNode->UniqueId[1]) &&
                ENUM_TEST_FLAG(TmpRemoteNode, NDISENUM1394_NODE_PNP_STARTED))
                
                break;              
        }

        if (TmpRemoteNode != NULL)
        {
            //
            // duplicate node
            //
            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394StartDevice: duplicate node. new node %lx, original Node %lx\n",
                                    TmpRemoteNode, RemoteNode));

            ENUM_CLEAR_FLAG(RemoteNode, NDISENUM1394_NODE_PNP_STARTED);
            break;
        }
        
        ENUM_SET_FLAG(RemoteNode, NDISENUM1394_NODE_PNP_STARTED);
        
        if((AddNodeHandler != NULL) && (LocalHost->Nic1394AdapterContext != NULL))
        {
            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394StartDevice: Notifying Nic1394 of device arrival, Miniport PDO %lx, Node PDO %lx\n", LocalHost->PhysicalDeviceObject, RemoteNode->PhysicalDeviceObject));
            if (!ENUM_TEST_FLAG(RemoteNode, NDISENUM1394_NODE_INDICATED))
            {
                ENUM_SET_FLAG(RemoteNode, NDISENUM1394_NODE_INDICATED);
                
                ExReleaseSpinLock(&LocalHost->Lock, OldIrql);
                Status = AddNodeHandler(LocalHost->Nic1394AdapterContext,
                                        (PVOID)RemoteNode,
                                        RemoteNode->PhysicalDeviceObject,
                                        RemoteNode->UniqueId[0],
                                        RemoteNode->UniqueId[1],
                                        &RemoteNode->Nic1394NodeContext);
                                        
                ASSERT(Status == STATUS_SUCCESS);
                
                ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);

                if (Status == STATUS_SUCCESS)
                {
                    ENUM_SET_FLAG(RemoteNode, NDISENUM1394_NODE_ADDED);
                }
                else
                {
                    DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394StartDevice: AddAdapter failed %lx\n", Status));
                }
            }
            
        }
        
    } while (FALSE);
    
    ExReleaseSpinLock(&LocalHost->Lock, OldIrql);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394StartDevice: Status %lx, DeviceObject %lx, Irp %lx\n", Status, DeviceObject, Irp));

    return Status;
}


VOID
ndisEnum1394IndicateNodes(
    PNDISENUM1394_LOCAL_HOST    LocalHost
    )
{

    PNDISENUM1394_REMOTE_NODE   RemoteNode;
    NTSTATUS                    Status = STATUS_UNSUCCESSFUL;
    KIRQL                       OldIrql;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394IndicateNodes: LocalHost %lx\n", LocalHost));

    
    //
    // notify 1394 NIC driver
    //
    if (AddNodeHandler == NULL)
    {
        DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394IndicateNodes: LocalHost %lx\n", LocalHost));
        return;
    }
    
    ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);

    if (ENUM_TEST_FLAG(LocalHost, NDISENUM1394_LOCALHOST_REGISTERED))
    {
    
      next:
        for (RemoteNode = LocalHost->RemoteNodeList;
                        RemoteNode != NULL;
                        RemoteNode = RemoteNode->Next)
        {
            if ((!ENUM_TEST_FLAG(RemoteNode, NDISENUM1394_NODE_INDICATED)) &&
                ENUM_TEST_FLAG(RemoteNode, NDISENUM1394_NODE_PNP_STARTED))

            {
                ENUM_SET_FLAG(RemoteNode, NDISENUM1394_NODE_INDICATED);
                break;
            }
        }

        if (RemoteNode != NULL)
        {
            
            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394IndicateNodes: Notifying Nic1394 of device arrival, Miniport PDO %lx, Node PDO %lx\n", LocalHost->PhysicalDeviceObject, RemoteNode->PhysicalDeviceObject));

            ExReleaseSpinLock(&LocalHost->Lock, OldIrql);
                
            Status = AddNodeHandler(LocalHost->Nic1394AdapterContext,
                                    (PVOID)RemoteNode,
                                    RemoteNode->PhysicalDeviceObject,
                                    RemoteNode->UniqueId[0],
                                    RemoteNode->UniqueId[1],
                                    &RemoteNode->Nic1394NodeContext);

            ASSERT(Status == STATUS_SUCCESS);

            if (Status == STATUS_SUCCESS)
            {
                ENUM_SET_FLAG(RemoteNode, NDISENUM1394_NODE_ADDED);
            }
            else
            {
                DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394IndicateNodes: AddAdapter failed %lx\n", Status));
            }
            
            ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);
            goto next;
        }
    }
    else
    {
        DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394IndicateNodes: LocalHost is not registered %lx\n", Status));
    }
    
    ExReleaseSpinLock(&LocalHost->Lock, OldIrql);
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394IndicateNodes: LocalHost %lx\n", LocalHost));

}
    

NTSTATUS
ndisEnum1394CreateIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;        
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394CreateIrpHandler: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394CreateIrpHandler: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    return status;
}




NTSTATUS
ndisEnum1394CloseIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;        
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394CloseIrpHandler: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;

    IoCompleteRequest (Irp, IO_NO_INCREMENT );


    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394CloseIrpHandler: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));
    
    return status;
}

NTSTATUS
ndisEnum1394DeviceIoControl(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;        
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394DeviceIoControl: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;

    IoCompleteRequest (Irp, IO_NO_INCREMENT );


    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394DeviceIoControl: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    return status;
;
}

VOID
ndisEnum1394Unload(
    IN  PDRIVER_OBJECT          DriverObject
    )
{
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394Unload: DriverObject %lx\n", DriverObject));
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394Unload: DriverObject %lx\n", DriverObject));

    // 
    // Tell nic1394 that we are going away
    //
    if (DeRegisterDriverHandler != NULL ) 
    {
        DeRegisterDriverHandler()  ;
    }

    //
    // Deregister our callback structure
    // 
    ExUnregisterCallback(ndisEnum1394CallbackRegisterationHandle);

    //
    // Dereference our callback structure
    //
    ObDereferenceObject(ndisEnum1394CallbackObject);

    return;
}



/*
EXPORT
NTSTATUS
NdisEnum1394RegisterAdapter(
    IN  PVOID                   Nic1394AdapterContext,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject,
    OUT PVOID*                  pEnum1394AdapterHandle,
    OUT PLARGE_INTEGER          pLocalHostUniqueId
    );



    This routine is called at system initialization time so we can fill in the basic dispatch points

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS

Routine Description:

    This function is called by Nic1394 during its Ndis IntializeHandler to register a new
    Adapter. each registered adapter corresponds to a local host controller.
    in response Enum1394 finds the local host and for each remote node on the local host
    that have not been indicated yet calls the Nic1394 AddNodes handler.

Arguments:
    Nic1394AdapterContext   Nic1394 context for the local host
    PhysicalDeviceObject    PDO created by 1394 Bus driver for the local host
    pEnum1394AdapterHandle  a pointer a pointer to be initialized to Enum1394 LocalHost context
    pLocalHostUniqueId      a pointer to a LARGE_INTEGER to be initialized to local host unique ID
*/
NTSTATUS
NdisEnum1394RegisterAdapter(
    IN  PVOID                   Nic1394AdapterContext,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject,
    OUT PVOID*                  pEnum1394AdapterHandle,
    OUT PLARGE_INTEGER          pLocalHostUniqueId
    )
{
    PNDISENUM1394_LOCAL_HOST    LocalHost;
    NTSTATUS                    Status;
    IRB                         Irb;
    GET_LOCAL_HOST_INFO1        uId;


    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>NdisEnum1394RegisterAdapter, PhysicalDeviceObject %lx\n", PhysicalDeviceObject));

    do
    {

        //
        // get the unique ID for the local host for this adapter
        //
        
        RtlZeroMemory(&Irb, sizeof(IRB));
        
        Irb.FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
        Irb.u.GetLocalHostInformation.nLevel = GET_HOST_UNIQUE_ID;
        Irb.u.GetLocalHostInformation.Information = (PVOID)&uId;

        Status = ndisEnum1394BusRequest(PhysicalDeviceObject, &Irb);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("NdisEnum1394RegisterAdapter: ndisEnum1394BusRequest for REQUEST_GET_LOCAL_HOST_INFO failed. Status %lx\n", Status));
            break;
        }

        //
        // GetLocal Host Refs the LocalHost - Derefed in DeRegisterAdapter            
        //
        ndisEnum1394GetLocalHostForUniqueId(uId.UniqueId, &LocalHost);


#if 0
        ExAcquireSpinLock(&ndisEnum1394GlobalLock, &OldIrql);
        
        for (LocalHost = LocalHostList; LocalHost != NULL; LocalHost = LocalHost->Next)
        {
            if ((LocalHost->UniqueId.LowPart == uId.UniqueId.LowPart) && 
                (LocalHost->UniqueId.HighPart == uId.UniqueId.HighPart))
            {
                break;
            }
        }
        
        ExReleaseSpinLock(&ndisEnum1394GlobalLock, OldIrql);
#endif

        ASSERT(LocalHost != NULL);

        if (LocalHost == NULL)
        {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }
        
        *pEnum1394AdapterHandle = (PVOID)LocalHost;
        LocalHost->Nic1394AdapterContext = Nic1394AdapterContext;
        LocalHost->PhysicalDeviceObject = PhysicalDeviceObject;
                
        *pLocalHostUniqueId = LocalHost->UniqueId;

        ENUM_SET_FLAG(LocalHost, NDISENUM1394_LOCALHOST_REGISTERED);

        ndisEnum1394IndicateNodes(LocalHost);
        
        Status = STATUS_SUCCESS;
        
    } while (FALSE);
    

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==NdisEnum1394RegisterAdapter: Status %lx\n", Status));
    
    return Status;
}


VOID
NdisEnum1394DeregisterAdapter(
    IN  PVOID                   Enum1394AdapterHandle
    )
{
    PNDISENUM1394_LOCAL_HOST LocalHost = (PNDISENUM1394_LOCAL_HOST)Enum1394AdapterHandle;
    KIRQL   OldIrql;
    PNDISENUM1394_REMOTE_NODE RemoteNode;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>NdisEnum1394DeregisterAdapter: LocalHost %lx\n", Enum1394AdapterHandle));

    //
    // go through all the nodes and remove them
    //
    ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);

    //
    // make sure we will not try to indicate any new dev node on this
    //
    ENUM_CLEAR_FLAG(LocalHost, NDISENUM1394_LOCALHOST_REGISTERED);

    
  next:
    for (RemoteNode = LocalHost->RemoteNodeList;
                    RemoteNode != NULL;
                    RemoteNode = RemoteNode->Next)
    {
        ENUM_CLEAR_FLAG(RemoteNode, NDISENUM1394_NODE_INDICATED);
        if (ENUM_TEST_FLAG(RemoteNode, NDISENUM1394_NODE_ADDED))
        {
            break;
        }
    }

    if (RemoteNode != NULL)
    {       
        DBGPRINT(ENUM1394_DBGLEVEL_INFO, 
            ("NdisEnum1394DeregisterAdapter: Notifying Nic1394 of device removal, Miniport PDO %lx, Node PDO %lx\n", LocalHost->PhysicalDeviceObject, RemoteNode->PhysicalDeviceObject));

        ExReleaseSpinLock(&LocalHost->Lock, OldIrql);
        RemoveNodeHandler(RemoteNode->Nic1394NodeContext);          
        ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);
        ENUM_CLEAR_FLAG(RemoteNode, NDISENUM1394_NODE_ADDED);
        
        goto next;
    }
    
    LocalHost->Nic1394AdapterContext = NULL;
    LocalHost->PhysicalDeviceObject = NULL;

    ExReleaseSpinLock(&LocalHost->Lock, OldIrql);

    //
    // Dereference the Ref made in RegisterAdapter by calling GetLocalHost for Unique ID
    //
    {   
        BOOLEAN bIsRefZero;

        bIsRefZero = ndisEnum1394DereferenceLocalHost(LocalHost);

        if (bIsRefZero == TRUE)
        {
            ndisEnum1394FreeLocalHost(LocalHost);
        }
    }
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==NdisEnum1394DeregisterAdapter: LocalHost %lx\n", Enum1394AdapterHandle));
    
}

NTSTATUS
ndisEnum1394GetLocalHostForRemoteNode(
    IN  PNDISENUM1394_REMOTE_NODE       RemoteNode,
    OUT PNDISENUM1394_LOCAL_HOST *      pLocalHost
    )
{
    NTSTATUS                    Status;
    PNDISENUM1394_LOCAL_HOST    LocalHost;
    IRB                         Irb;
    GET_LOCAL_HOST_INFO1        uId;
    ULONG                       SizeNeeded;
    PVOID                       ConfigInfoBuffer = NULL;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394GetLocalHostForRemoteNode: RemoteNode %lx\n", RemoteNode));

    do
    {
        //
        // get the unique ID for the local host which this device
        // is connected on. then walk through all the existing local
        // hosts and see if this a new local host or not.
        //
        
        RtlZeroMemory(&Irb, sizeof(IRB));
        
        Irb.FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
        Irb.u.GetLocalHostInformation.nLevel = GET_HOST_UNIQUE_ID;
        Irb.u.GetLocalHostInformation.Information = (PVOID)&uId;

        Status = ndisEnum1394BusRequest(RemoteNode->NextDeviceObject, &Irb);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394GetLocalHostForRemoteNode: ndisEnum1394BusRequest for REQUEST_GET_LOCAL_HOST_INFO failed. Status %lx\n", Status));
            break;
        }
        
        //
        // now get the unique ID for the remote node
        //
        // we have to make this call twice. first to get the size, then the actual data
        //

        RtlZeroMemory(&Irb, sizeof(IRB));
        
        Irb.FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;

        Status = ndisEnum1394BusRequest(RemoteNode->NextDeviceObject, &Irb);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394GetLocalHostForRemoteNode: ndisEnum1394BusRequest for REQUEST_GET_CONFIGURATION_INFO (size) failed. Status %lx\n", Status));
            break;
        }

        SizeNeeded = sizeof(CONFIG_ROM) +
                     Irb.u.GetConfigurationInformation.UnitDirectoryBufferSize +
                     Irb.u.GetConfigurationInformation.UnitDependentDirectoryBufferSize +
                     Irb.u.GetConfigurationInformation.VendorLeafBufferSize +
                     Irb.u.GetConfigurationInformation.ModelLeafBufferSize;

        ConfigInfoBuffer = (PVOID)ALLOC_FROM_POOL(SizeNeeded, '  4N');
        
        if (ConfigInfoBuffer == NULL)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394GetLocalHostForRemoteNode: Failed to allocate memory for config info.\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Irb.u.GetConfigurationInformation.ConfigRom = (PCONFIG_ROM)ConfigInfoBuffer;
        Irb.u.GetConfigurationInformation.UnitDirectory = (PVOID)((PUCHAR)ConfigInfoBuffer + sizeof(CONFIG_ROM));
        Irb.u.GetConfigurationInformation.UnitDependentDirectory = (PVOID)((PUCHAR)Irb.u.GetConfigurationInformation.UnitDirectory + 
                                                                            Irb.u.GetConfigurationInformation.UnitDirectoryBufferSize);
        Irb.u.GetConfigurationInformation.VendorLeaf = (PVOID)((PUCHAR)Irb.u.GetConfigurationInformation.UnitDependentDirectory + 
                                                                                  Irb.u.GetConfigurationInformation.UnitDependentDirectoryBufferSize);
        Irb.u.GetConfigurationInformation.ModelLeaf = (PVOID)((PUCHAR)Irb.u.GetConfigurationInformation.VendorLeaf + 
                                                                                  Irb.u.GetConfigurationInformation.VendorLeafBufferSize);      
        Irb.FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;

        Status = ndisEnum1394BusRequest(RemoteNode->NextDeviceObject, &Irb);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394GetLocalHostForRemoteNode: ndisEnum1394BusRequest for REQUEST_GET_CONFIGURATION_INFO failed. Status %lx\n", Status));
            break;
        }

        ASSERT(Irb.u.GetConfigurationInformation.ConfigRom != NULL);
        
        RemoteNode->UniqueId[0] = Irb.u.GetConfigurationInformation.ConfigRom->CR_Node_UniqueID[0];
        RemoteNode->UniqueId[1] = Irb.u.GetConfigurationInformation.ConfigRom->CR_Node_UniqueID[1];

#if DBG
        
        DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("Unique ID for Node %lx: %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x\n",
                        RemoteNode->PhysicalDeviceObject,
                        *((PUCHAR)&RemoteNode->UniqueId[0]),
                        *(((PUCHAR)&RemoteNode->UniqueId[0])+1),
                        *(((PUCHAR)&RemoteNode->UniqueId[0])+2),
                        *(((PUCHAR)&RemoteNode->UniqueId[0])+3),
                        *((PUCHAR)&RemoteNode->UniqueId[1]),
                        *(((PUCHAR)&RemoteNode->UniqueId[1])+1),
                        *(((PUCHAR)&RemoteNode->UniqueId[1])+2),
                        *(((PUCHAR)&RemoteNode->UniqueId[1])+3)));
        

#endif

        ndisEnum1394GetLocalHostForUniqueId(uId.UniqueId, &LocalHost);

        if (LocalHost == NULL)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394GetLocalHostForUniqueId: Failed to get the local host.\n"));
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        *pLocalHost = LocalHost;

        
        Status = STATUS_SUCCESS;

    } while (FALSE);


    if (ConfigInfoBuffer != NULL)
    {
        FREE_POOL(ConfigInfoBuffer);
    }
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394GetLocalHostForRemoteNode: Status %lx, RemoteNode %lx, LocalHostList %lx\n", Status, RemoteNode, LocalHostList));

    return Status;
}

NTSTATUS
ndisEnum1394IrpCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This routine will get called after the next device object in the stack
    processes the IRP_MN_QUERY_CAPABILITIES IRP this needs to be merged with
    the miniport's capabilites and completed.

Arguments:

    DeviceObject
    Irp
    Context

Return Value:

--*/
{
    SET_EVENT(Context);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
ndisEnum1394PassIrpDownTheStack(
    IN  PIRP            pIrp,
    IN  PDEVICE_OBJECT  pNextDeviceObject
    )
/*++

Routine Description:

    This routine will simply pass the IRP down to the next device object to
    process.

Arguments:
    pIrp                -   Pointer to the IRP to process.
    pNextDeviceObject   -   Pointer to the next device object that wants
                            the IRP.

Return Value:

--*/
{
    KEVENT              Event;
    NTSTATUS            Status = STATUS_SUCCESS;

    //
    //  Initialize the event structure.
    //
    INITIALIZE_EVENT(&Event);

    //
    //  Set the completion routine so that we can process the IRP when
    //  our PDO is done.
    //
    IoSetCompletionRoutine(pIrp,
                           (PIO_COMPLETION_ROUTINE)ndisEnum1394IrpCompletion,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    //  Pass the IRP down to the PDO.
    //
    Status = IoCallDriver(pNextDeviceObject, pIrp);
    if (Status == STATUS_PENDING)
    {
        //
        //  Wait for completion.
        //
        WAIT_FOR_OBJECT(&Event, NULL);

        Status = pIrp->IoStatus.Status;
    }

    return(Status);
}

NTSTATUS
ndisEnum1394PnpDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )

/*++

Routine Description:

    The handler for IRP_MJ_PNP_POWER.

Arguments:

    DeviceObject - The adapter's functional device object.
    Irp - The IRP.

Return Value:

--*/
{
    PIO_STACK_LOCATION          IrpSp;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PDEVICE_OBJECT              NextDeviceObject;
    PNDISENUM1394_REMOTE_NODE   RemoteNode;
    ULONG                       PnPDeviceState;
    BOOLEAN                     fSendIrpDown = TRUE;
    BOOLEAN                     fCompleteIrp = TRUE;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394PnpDispatch: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));
    
    if (DbgIsNull(Irp))
    {
        DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394PnpDispatch: Null Irp\n"));
        DBGBREAK();
    }

    //
    //  Get a pointer to the adapter block and miniport block then determine
    //  which one we should use.
    //
    RemoteNode = (PNDISENUM1394_REMOTE_NODE)DeviceObject->DeviceExtension;
    
    //
    //  Get a pointer to the next miniport.
    //
    NextDeviceObject = RemoteNode->NextDeviceObject;
    
    IrpSp = IoGetCurrentIrpStackLocation (Irp);


    switch(IrpSp->MinorFunction)
    {
        case IRP_MN_START_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_START_DEVICE\n", RemoteNode));
            
            IoCopyCurrentIrpStackLocationToNext(Irp);
            Status = ndisEnum1394PassIrpDownTheStack(Irp, NextDeviceObject);

            //
            //  If the bus driver succeeded the start irp then proceed.
            //
            if (NT_SUCCESS(Status))
            {
                Status = ndisEnum1394StartDevice(DeviceObject, Irp);
            }
            else
            {
                DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394PnpDispatch: bus driver failed START IRP RemoteNode %lx\n", RemoteNode));
            }

            RemoteNode->PnPDeviceState = PnPDeviceStarted;

            Irp->IoStatus.Status = Status;
            fSendIrpDown = FALSE;   // we already did send the IRP down
            break;
        
        case IRP_MN_QUERY_REMOVE_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_QUERY_REMOVE_DEVICE\n", RemoteNode));
            
            RemoteNode->PnPDeviceState = PnPDeviceQueryRemoved;

            Irp->IoStatus.Status = STATUS_SUCCESS;
            //
            // if we failed query_remove, no point sending this irp down
            //
            fSendIrpDown = TRUE;
            break;
        
        case IRP_MN_CANCEL_REMOVE_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_CANCEL_REMOVE_DEVICE\n", RemoteNode));

            RemoteNode->PnPDeviceState = PnPDeviceStarted;

            Irp->IoStatus.Status = STATUS_SUCCESS;
            fSendIrpDown = TRUE;
            break;
            
        case IRP_MN_REMOVE_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_REMOVE_DEVICE\n", RemoteNode));
            ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

            //
            // call notify handler
            //

            PnPDeviceState = RemoteNode->PnPDeviceState;
            
            if (PnPDeviceState != PnPDeviceSurpriseRemoved)
            {
                RemoteNode->PnPDeviceState = PnPDeviceRemoved;
                
                Status = ndisEnum1394RemoveDevice(DeviceObject, 
                                                Irp, 
                                                NdisEnum1394_RemoveDevice);

                Irp->IoStatus.Status = Status;
            }
            else
            {
                Irp->IoStatus.Status = STATUS_SUCCESS;
            }
            
            //
            // when we are done, send the Irp down here
            // we have some post-processing to do
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(NextDeviceObject, Irp);

            IoDetachDevice(NextDeviceObject);
            IoDeleteDevice(DeviceObject);
            
            fSendIrpDown = FALSE;
            fCompleteIrp = FALSE;
            break;
            
        case IRP_MN_SURPRISE_REMOVAL:
            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_SURPRISE_REMOVAL\n", RemoteNode));
                
            ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

            RemoteNode->PnPDeviceState = PnPDeviceSurpriseRemoved;
            Status = ndisEnum1394RemoveDevice(DeviceObject, 
                                            Irp, 
                                            NdisEnum1394_SurpriseRemoveDevice);

            Irp->IoStatus.Status = Status;

            //
            // when we are done, send the Irp down here
            // we have some post-processing to do
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(NextDeviceObject, Irp);
                        
            fSendIrpDown = FALSE;
            fCompleteIrp = FALSE;
                
            break;
        
        case IRP_MN_QUERY_STOP_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_QUERY_STOP_DEVICE\n", RemoteNode));

            RemoteNode->PnPDeviceState = PnPDeviceQueryStopped;
            Irp->IoStatus.Status = STATUS_SUCCESS;
            fSendIrpDown = TRUE;
            break;
            
        case IRP_MN_CANCEL_STOP_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_CANCEL_STOP_DEVICE\n", RemoteNode));
            
            RemoteNode->PnPDeviceState = PnPDeviceStarted;
            Irp->IoStatus.Status = STATUS_SUCCESS;
            fSendIrpDown = TRUE;
            break;
            
        case IRP_MN_STOP_DEVICE:

            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, IRP_MN_STOP_DEVICE\n", RemoteNode));

            RemoteNode->PnPDeviceState = PnPDeviceStopped;          
            Status = ndisEnum1394RemoveDevice(DeviceObject, Irp,NdisEnum1394_StopDevice);
            Irp->IoStatus.Status = Status;
            fSendIrpDown = TRUE;
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode, IRP_MN_QUERY_CAPABILITIES\n", RemoteNode));

            IoCopyCurrentIrpStackLocationToNext(Irp);
            Status = ndisEnum1394PassIrpDownTheStack(Irp, NextDeviceObject);
#ifdef  ENUM1394_NT
            //
            // Memphis does not support SurpriseRemovalOK bit
            //
            //  If the bus driver succeeded the start irp then proceed.
            //
            if (NT_SUCCESS(Status))
            {
                //
                //  Modify the capabilities so that the device is not suprise removable.
                //                                                
                IrpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = 1;
            }
#endif // NDIS_NT

            
            fSendIrpDown = FALSE;
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            Irp->IoStatus.Status = Status;
            fSendIrpDown = TRUE ;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
        case IRP_MN_QUERY_INTERFACE:
        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:
        case IRP_MN_EJECT:
        case IRP_MN_SET_LOCK:
        case IRP_MN_QUERY_ID:
        default:
            DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394PnpDispatch: RemoteNode %lx, MinorFunction 0x%x\n", RemoteNode, IrpSp->MinorFunction));

            //
            //  We don't handle the irp so pass it down.
            //
            fSendIrpDown = TRUE;
            break;          
    }

    //
    //  First check to see if we need to send the irp down.
    //  If we don't pass the irp on then check to see if we need to complete it.
    //
    if (fSendIrpDown)
    {
        IoSkipCurrentIrpStackLocation(Irp);
        Status = IoCallDriver(NextDeviceObject, Irp);
    }
    else if (fCompleteIrp)
    {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394PnpDispatch: Status %lx, RemoteNode %lx\n", Status, RemoteNode));

    return(Status);
}


NTSTATUS
ndisEnum1394RemoveDevice(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                Irp,
    NDISENUM1394_PNP_OP PnpOp
    )
/*++

Routine Description:

    This function is called in the RemoveDevice and Stop Device code path.
    In the case of a Stop the function should undo whatever it received in the Start
    and it the case of a Remove it Should do undo the work done in AddDevice

Arguments:

    DeviceObject - The adapter's functional device object.
    Irp - The IRP.

Return Value:

--*/
{
    PNDISENUM1394_REMOTE_NODE   RemoteNode, *ppDB;
    PNDISENUM1394_LOCAL_HOST    LocalHost;
    KIRQL                       OldIrql;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394RemoveDevice: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));
    ASSERT(KeGetCurrentIrql()==PASSIVE_LEVEL );
    //
    // call 1394Nic about this device getting removed
    // if this is the last PDO on local host, get rid of
    // the PDO created for the local host
    //

    RemoteNode = (PNDISENUM1394_REMOTE_NODE)DeviceObject->DeviceExtension;
    LocalHost = RemoteNode->LocalHost;

    //
    // if the node has been indicated, let the nic1394 know
    // it is going away
    //
    if ((RemoveNodeHandler != NULL) && (ENUM_TEST_FLAGS(RemoteNode, NDISENUM1394_NODE_ADDED)))
    {
        RemoveNodeHandler(RemoteNode->Nic1394NodeContext);
        ENUM_CLEAR_FLAG(RemoteNode, NDISENUM1394_NODE_ADDED);
    }

    //
    // If this is a stop device then do NOT do any software specific cleanup work ..
    // leave it for the RemoveDevice
    //
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394RemoveDevice: - pRemoteNode %p LocalHost %p Op %x\n", 
                                        RemoteNode, 
                                        LocalHost,
                                        PnpOp));
    
    if (PnpOp != NdisEnum1394_StopDevice && LocalHost != NULL)
    {
        //
        // find the device block and remove it from local host
        //
        ExAcquireSpinLock(&LocalHost->Lock, &OldIrql);

        for (ppDB = &LocalHost->RemoteNodeList; *ppDB != NULL; ppDB = &(*ppDB)->Next)
        {
            if (*ppDB == RemoteNode)
            {
                *ppDB = RemoteNode->Next;
                break;
            }
        }

        ExReleaseSpinLock(&LocalHost->Lock, OldIrql);

        ASSERT(*ppDB == RemoteNode->Next);

        //
        // Remove the Ref made in the Add Devive when calling GetLocalHost for Unique ID
        //
        {   
            BOOLEAN bIsRefZero;

            RemoteNode->LocalHost = NULL;

            bIsRefZero = ndisEnum1394DereferenceLocalHost(LocalHost);

            
            if (bIsRefZero == TRUE)
            {
                ndisEnum1394FreeLocalHost(LocalHost);
            }
        }
    }
    
    ENUM_CLEAR_FLAG(RemoteNode, NDISENUM1394_NODE_PNP_STARTED);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394RemoveDevice: DeviceObject %lx, Irp %lx\n", DeviceObject, Irp));

    return STATUS_SUCCESS;
}

/*+++
NTSTATUS
ndisEnum1394BusRequest(
    PDEVICE_OBJECT              DeviceObject,
    PIRB                        Irb
    );

Routine Description:
    this function issues a 1394 bus request to the device object. the device
    object could be the NextDeviceObject of the remote PDO or the virtual PDO
    1394 bus ejected (net PDO)

Arguments:
    DeviceObject: the target device object to send the request to
    Irb: the request block

Return Value:
    as appropriate
    
---*/

NTSTATUS
ndisEnum1394BusRequest(
    PDEVICE_OBJECT              DeviceObject,
    PIRB                        Irb
    )
{
    NTSTATUS                Status;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394BusRequest: DeviceObject %lx, Irb %lx\n", DeviceObject, Irb));
    
    do
    {
        Irp = IoAllocateIrp((CCHAR)(DeviceObject->StackSize + 1),
                                 FALSE);
        if (Irp == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394BusRequest: IoAllocateIrp failed. Status %lx\n", Status));
            break;
        }
        
        IrpSp = IoGetNextIrpStackLocation(Irp);
        ASSERT(IrpSp != NULL);
        RtlZeroMemory(IrpSp, sizeof(IO_STACK_LOCATION ));
        
        IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        IrpSp->DeviceObject = DeviceObject;
        IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
        IrpSp->Parameters.Others.Argument1 = Irb;
        Irp->IoStatus.Status  = STATUS_NOT_SUPPORTED;

        Status = ndisEnum1394PassIrpDownTheStack(Irp, DeviceObject);

        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394BusRequest: 1394 Bus driver failed the IRB. Status %lx\n", Status));
        }
        
    }while (FALSE);
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394BusRequest: DeviceObject %lx, Irb %lx\n", DeviceObject, Irb));

    return Status;
}

BOOLEAN
ndisEnum1394ReferenceLocalHost(
        IN PNDISENUM1394_LOCAL_HOST LocalHost
        )
{   
    BOOLEAN                     rc;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394ReferenceLocalHost : LocalHost %p\n", LocalHost));

    rc = ndisEnum1394ReferenceRef(&LocalHost->Reference);

    return rc;
}

BOOLEAN
ndisEnum1394DereferenceLocalHost(
        IN PNDISENUM1394_LOCAL_HOST LocalHost
        )
{   
    BOOLEAN                     rc;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("ndisEnum1394DereferenceLocalHost : LocalHost %p\n", LocalHost));

    rc = ndisEnum1394DereferenceRef(&LocalHost->Reference);

    return rc;
}

VOID
ndisEnum1394FreeLocalHost(
        IN PNDISENUM1394_LOCAL_HOST LocalHost
        )
{
    KIRQL                       OldIrql;
    PNDISENUM1394_LOCAL_HOST *  ppLH;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394FreeLocalHost: LocalHost %p\n", LocalHost));
    
    ASSERT(LocalHost->RemoteNodeList == NULL);
    ASSERT(LocalHost->Reference.ReferenceCount == 0);
    
    //
    // make sure we have not created a PDO for this local host
    //
    ASSERT(LocalHost->PhysicalDeviceObject == NULL);

    ExAcquireSpinLock(&ndisEnum1394GlobalLock, &OldIrql);

    for (ppLH = &LocalHostList; *ppLH != NULL; ppLH = &(*ppLH)->Next)
    {
        if (*ppLH == LocalHost)
        {
            *ppLH = LocalHost->Next;
            break;
        }
    }

    ExReleaseSpinLock(&ndisEnum1394GlobalLock, OldIrql);

    ASSERT(*ppLH == LocalHost->Next);
            
    FREE_POOL(LocalHost);
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394FreeLocalHost: LocalHost %p\n", LocalHost));
}

VOID
ndisEnum1394InitializeRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Initialize a reference count structure.

Arguments:

    RefP - The structure to be initialized.

Return Value:

    None.

--*/

{
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394InitializeRef\n"));

    RefP->Closing = FALSE;
    RefP->ReferenceCount = 1;
    KeInitializeSpinLock(&RefP->SpinLock);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394InitializeRef\n"));
}

BOOLEAN
ndisEnum1394ReferenceRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Adds a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference was added.
    FALSE if the object was closing.

--*/

{
    BOOLEAN rc = TRUE;
    KIRQL   OldIrql;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394ReferenceRef\n"));

    ExAcquireSpinLock(&RefP->SpinLock, &OldIrql);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else
    {
        ++(RefP->ReferenceCount);
    }

    ExReleaseSpinLock(&RefP->SpinLock, OldIrql);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394ReferenceRef: RefCount %lx\n", RefP->ReferenceCount));

    return(rc);
}


BOOLEAN
ndisEnum1394DereferenceRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Removes a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference count is now 0.
    FALSE otherwise.

--*/

{
    BOOLEAN rc = FALSE;
    KIRQL   OldIrql;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394DereferenceRef\n"));


    ExAcquireSpinLock(&RefP->SpinLock, &OldIrql);

    --(RefP->ReferenceCount);

    if (RefP->ReferenceCount == 0)
    {
        rc = TRUE;
    }

    ExReleaseSpinLock(&RefP->SpinLock, OldIrql);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394DereferenceRef: RefCount %lx\n", RefP->ReferenceCount));
            
    return(rc);
}

BOOLEAN
ndisEnum1394CloseRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Closes a reference count structure.

Arguments:

    RefP - The structure to be closed.

Return Value:

    FALSE if it was already closing.
    TRUE otherwise.

--*/

{
    KIRQL   OldIrql;
    BOOLEAN rc = TRUE;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394CloseRef\n"));

    ExAcquireSpinLock(&RefP->SpinLock, &OldIrql);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else RefP->Closing = TRUE;

    ExReleaseSpinLock(&RefP->SpinLock, OldIrql);

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394CloseRef\n"));
            
    return(rc);
}


NTSTATUS
NdisEnum1394RegisterDriver(
    IN  PNIC1394_CHARACTERISTICS    Characteristics
    )
{
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>NdisEnum1394RegisterDriver\n"));

    //
    // Todo: do some check for the version, etc. and make sure the handlers are
    // not null and this is not a dup registeration
    //

    AddNodeHandler = Characteristics->AddNodeHandler;
    RemoveNodeHandler = Characteristics->RemoveNodeHandler;
    RegisterDriverHandler = Characteristics->RegisterDriverHandler;
    DeRegisterDriverHandler = Characteristics->DeRegisterDriverHandler;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==NdisEnum1394RegisterDriver\n"));

    return STATUS_SUCCESS;
}

VOID
NdisEnum1394DeregisterDriver(
    )
{
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>NdisEnum1394DeregisterDriver\n"));

    AddNodeHandler = NULL;
    RemoveNodeHandler = NULL;
    RegisterDriverHandler = NULL;
    DeRegisterDriverHandler = NULL;

    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==NdisEnum1394DeregisterDriver\n"));
}



//
// this functions searchs through the list of local hosts trying to find one
// with matching unique ID. if it does not, it will allocate a new one
//
VOID
ndisEnum1394GetLocalHostForUniqueId(
    LARGE_INTEGER                   UniqueId,
    OUT PNDISENUM1394_LOCAL_HOST *  pLocalHost
    )
{

    PNDISENUM1394_LOCAL_HOST    TempLocalHost;
    PNDISENUM1394_LOCAL_HOST    LocalHost;
    KIRQL                       OldIrql;
    BOOLEAN                     bFreeTempLocalHost = FALSE;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>ndisEnum1394GetLocalHostForUniqueId\n"));
    
    do
    {
        ExAcquireSpinLock(&ndisEnum1394GlobalLock, &OldIrql);

        for (LocalHost = LocalHostList; LocalHost != NULL; LocalHost = LocalHost->Next)
        {
            if (LocalHost->UniqueId.QuadPart == UniqueId.QuadPart)
                break;
        }
        
        ExReleaseSpinLock(&ndisEnum1394GlobalLock, OldIrql);
        
        if (LocalHost == NULL)
        {

            TempLocalHost = (PNDISENUM1394_LOCAL_HOST)ALLOC_FROM_POOL(sizeof(NDISENUM1394_LOCAL_HOST), NDISENUM1394_TAG_LOCAL_HOST);
            if (TempLocalHost == NULL)
            {
                DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("ndisEnum1394GetLocalHostForUniqueId: Failed to allocate memory LocalHost.\n"));
                break;
            }
            
            RtlZeroMemory(TempLocalHost, sizeof (NDISENUM1394_LOCAL_HOST));
            
            ExAcquireSpinLock(&ndisEnum1394GlobalLock, &OldIrql);

            //
            // need to do the search again just in case between the time we release the
            // spinlock and now, we have added the local host
            //
            for (LocalHost = LocalHostList; LocalHost != NULL; LocalHost = LocalHost->Next)
            {
                if (LocalHost->UniqueId.QuadPart == UniqueId.QuadPart)
                {

                    break;
                }
            }
        
            if (LocalHost == NULL)
            {
                LocalHost = TempLocalHost;
                LocalHost->Next = LocalHostList;
                LocalHostList = LocalHost;
                LocalHost->RemoteNodeList = NULL;
                LocalHost->UniqueId.QuadPart = UniqueId.QuadPart;
                KeInitializeSpinLock(&LocalHost->Lock);
                ndisEnum1394InitializeRef(&LocalHost->Reference);

            }
            else
            {
                //
                // We have found the local host on the linked list. 
                // ref the host, free the TempLocalHost and return
                //
                ndisEnum1394ReferenceLocalHost(LocalHost);

                bFreeTempLocalHost = TRUE;
            }
            
            ExReleaseSpinLock(&ndisEnum1394GlobalLock, OldIrql);
            
            if (bFreeTempLocalHost)
                FREE_POOL(TempLocalHost);

        }
        else
        {
            //
            // Give the caller a reference to our struct
            //
            ndisEnum1394ReferenceLocalHost(LocalHost);
        }
        
    } while (FALSE);

    *pLocalHost = LocalHost;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==ndisEnum1394GetLocalHostForUniqueId: LocalHost %lx\n", LocalHost));

    return;
}


VOID
Enum1394Callback(
    PVOID   CallBackContext,
    PVOID   Source,
    PVOID   Characteristics
    )
{
    NTSTATUS    Status;
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("==>Enum1394Callback: Source %lx, Characteristics %lx\n", Source, Characteristics));
    
    //
    // if we are the one issuing this notification, just return
    //
    if (Source == NDIS1394_CALLBACK_SOURCE_ENUM1394)
        return;

    //
    // notification is coming from Nic1394. grab the entry points. call it and
    // let it know that you are here
    //
    ASSERT(Source == (PVOID)NDIS1394_CALLBACK_SOURCE_NIC1394);

    RegisterDriverHandler = ((PNIC1394_CHARACTERISTICS)Characteristics)->RegisterDriverHandler;

    ASSERT(RegisterDriverHandler != NULL);

    if (RegisterDriverHandler == NULL)
    {
        DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("Enum1394Callback: Callback called with invalid Characteristics. Characteristics %lx\n", Characteristics));
        return;     
    }
    
    Status = RegisterDriverHandler(&NdisEnum1394Characteristics);
    
    if (Status == STATUS_SUCCESS)
    {
        AddNodeHandler = ((PNIC1394_CHARACTERISTICS)Characteristics)->AddNodeHandler;
        RemoveNodeHandler = ((PNIC1394_CHARACTERISTICS)Characteristics)->RemoveNodeHandler;
        DeRegisterDriverHandler = ((PNIC1394_CHARACTERISTICS)Characteristics)->DeRegisterDriverHandler;
    }
    else
    {
        DBGPRINT(ENUM1394_DBGLEVEL_ERROR, ("Enum1394Callback: RegisterDriverHandler failed: Status %lx\n", Status));
        RegisterDriverHandler = NULL;
    }
    
    DBGPRINT(ENUM1394_DBGLEVEL_INFO, ("<==Enum1394Callback: Source,  %lx\n", Source));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\inc\ndis1394.h ===
/*++

Copyright (c) 1998-2002  Microsoft Corporation

Module Name:

    ndis1394.h

Abstract:

    This file contains the declarations common to nic1394 and enum1394.

Environment:

    Kernel mode

Revision History:

    AliD created.
    
--*/

#ifndef _NDIS1394_
#define _NDIS1394_


#ifndef EXPORT
#ifdef _NDIS1394ENUM_
#define EXPORT
#else
#define EXPORT DECLSPEC_IMPORT
#endif
#endif


#define NDIS1394_CALLBACK_NAME		L"\\Callback\\Ndis1394CallbackObject"


#define NDIS1394_CALLBACK_SOURCE_ENUM1394		0
#define NDIS1394_CALLBACK_SOURCE_NIC1394		1

typedef struct _NIC1394_CHARACTERISTICS *PNIC1394_CHARACTERISTICS;
typedef struct _NDISENUM1394_CHARACTERISTICS *PNDISENUM1394_CHARACTERISTICS;

typedef
NTSTATUS
(*ENUM1394_REGISTER_DRIVER_HANDLER)(
	IN	PNIC1394_CHARACTERISTICS	Characteristics
	);

typedef
VOID
(*ENUM1394_DEREGISTER_DRIVER_HANDLER)(
	VOID
	);

typedef
NTSTATUS
(*ENUM1394_REGISTER_ADAPTER_HANDLER)(
	IN	PVOID					Nic1394AdapterContext,
	IN	PDEVICE_OBJECT			PhysicalDeviceObject,
	OUT	PVOID*					pEnum1394AdapterHandle,
	OUT	PLARGE_INTEGER			pLocalHostUniqueId
	);


typedef
VOID
(*ENUM1394_DEREGISTER_ADAPTER_HANDLER)(
	IN	PVOID					Enum1394AdapterHandle
	);

typedef struct _NDISENUM1394_CHARACTERISTICS
{
	UCHAR								MajorVersion;
	UCHAR								MinorVersion;
	USHORT								Filler;
	ENUM1394_REGISTER_DRIVER_HANDLER	RegisterDriverHandler;
	ENUM1394_DEREGISTER_DRIVER_HANDLER	DeregisterDriverHandler;
	ENUM1394_REGISTER_ADAPTER_HANDLER	RegisterAdapterHandler;
	ENUM1394_DEREGISTER_ADAPTER_HANDLER	DeregisterAdapterHandler;
} NDISENUM1394_CHARACTERISTICS, *PNDISENUM1394_CHARACTERISTICS;

typedef
NTSTATUS
(*NIC1394_REGISTER_DRIVER_HANDLER)(
	IN	PNDISENUM1394_CHARACTERISTICS	Characteristics
	);

typedef
VOID
(*NIC1394_DEREGISTER_DRIVER_HANDLER)(
	VOID
	);

typedef
NTSTATUS
(*NIC1394_ADD_NODE_HANLDER)(
	IN	PVOID					Nic1394AdapterContext,	// Nic1394 handle for the local host adapter
	IN	PVOID					Enum1394NodeHandle,		// Enum1394 handle for the remote node		
	IN	PDEVICE_OBJECT			PhysicalDeviceObject,	// physical device object for the remote node
	IN	ULONG					UniqueId0,				// unique ID Low for the remote node
	IN	ULONG					UniqueId1,				// unique ID High for the remote node
	OUT	PVOID *					pNic1394NodeContext		// Nic1394 context for the remote node
	);

typedef
NTSTATUS
(*NIC1394_REMOVE_NODE_HANLDER)(
	IN	PVOID					Nic1394NodeContext		// Nic1394 context for the remote node
	);

typedef struct _NIC1394_CHARACTERISTICS
{
	UCHAR								MajorVersion;
	UCHAR								MinorVersion;
	USHORT								Filler;
	NIC1394_REGISTER_DRIVER_HANDLER		RegisterDriverHandler;
	NIC1394_DEREGISTER_DRIVER_HANDLER	DeRegisterDriverHandler;
	NIC1394_ADD_NODE_HANLDER			AddNodeHandler;
	NIC1394_REMOVE_NODE_HANLDER			RemoveNodeHandler;
} NIC1394_CHARACTERISTICS, *PNIC1394_CHARACTERISTICS;

#endif // _NDIS1394_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\inc\a13ioctl.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

    This file contains the ioctl declarations for ARP1394, the IEEE1394 ARP module.

Environment:

    Kernel mode

Revision History:

    11/20/1998 JosephJ Created
    04/10/1999 JosephJ Defined structures to get/set info.

--*/

#ifndef _ARP1394_IOCTL_
#define _ARP1394_IOCTL_

#define ARP_CLIENT_DOS_DEVICE_NAME      L"\\\\.\\ARP1394"

#define ARP_IOCTL_CLIENT_OPERATION      CTL_CODE(FILE_DEVICE_NETWORK, 100, METHOD_BUFFERED, FILE_READ_ACCESS|FILE_WRITE_ACCESS)

// Current version. To rev the version, increment the 2nd number in the
// expression. The 1st number is a random 32-bit number.
//
#define ARP1394_IOCTL_VERSION (0x1ac86e68+3)


// Common header.
//
typedef struct
{
    // Set version to ARP1394_IOCTL_VERSION
    //
    ULONG Version;

    // IP address (in network byte order) of interface this request applies to.
    // (All-zeros == use default).
    //
    ULONG               IfIpAddress;

    // Operation code. Each operation code is associated with
    // a structure relevant to the operation.
    //
    enum
    {
        // Display all ARP entries
        // Associated struct: ARP1394_IOCTL_GET_ARPCACHE
        //
        ARP1394_IOCTL_OP_GET_ARPCACHE,

        // Add a static arp entry.
        // Associated struct: ARP1394_IOCTL_ADD_ARP_ENTRY
        //
        ARP1394_IOCTL_OP_ADD_STATIC_ENTRY,

        // Delete a static arp entry.
        // Associated struct: ARP1394_IOCTL_DEL_ARP_ENTRY
        //
        ARP1394_IOCTL_OP_DEL_STATIC_ENTRY,

        // Get packet statistics.
        // Associated struct: ARP1394_IOCTL_GET_PACKET_STATS
        //
        ARP1394_IOCTL_OP_GET_PACKET_STATS,

        // Get task statistics.
        // Associated struct: ARP1394_IOCTL_GET_TASK_STATS
        //
        ARP1394_IOCTL_OP_GET_TASK_STATS,

        // Get arp table statistics.
        // Associated struct: ARP1394_IOCTL_GET_ARPCACHE_STATS
        //
        ARP1394_IOCTL_OP_GET_ARPCACHE_STATS,

        // Get call statistics.
        // Associated struct: ARP1394_IOCTL_GET_CALL_STATS
        //
        ARP1394_IOCTL_OP_GET_CALL_STATS,

        // Reset statistics collection.
        //
        ARP1394_IOCTL_OP_RESET_STATS,

        // Reinit the interface (deactivate and then activate it).
        //
        ARP1394_IOCTL_OP_REINIT_INTERFACE,

        // Receive a packet
        //
        ARP1394_IOCTL_OP_RECV_PACKET,

        // Get bus information
        //
        ARP1394_IOCTL_OP_GET_NICINFO,

        // Get MCAP-related information
        //
        ARP1394_IOCTL_OP_GET_MCAPINFO,


        
        //
        // FOLLOWING ARE FOR ETHERNET EMULATION. THESE SHOULD NOT BE
        // SUPPORTED FROM USER MODE. HOWEVER FOR TESTING PURPOSES THEY ARE
        // CURRENTLY SUPPORED FROM USER MODE
        //

        // This is a dummy op identifying the beginning of the ethernet-related
        // Ops.
        //
        ARP1394_IOCTL_OP_ETHERNET_FIRST = 0x100,

        // Start ethernet emulation on the specified adapter. We must not
        // currently be bound to this adapter.
        //
        ARP1394_IOCTL_OP_ETHERNET_START_EMULATION =
                                   ARP1394_IOCTL_OP_ETHERNET_FIRST,

        // Stop ethernet emulation on the specified adapter. We must be
        // currently using this adapter in ethernet mode.
        //
        ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION,

        // Start listening on this ethernet multicast address.
        //
        ARP1394_IOCTL_OP_ETHERNET_ADD_MULTICAST_ADDRESS,

        // Stop listening on this ethernet multicast address.
        //
        ARP1394_IOCTL_OP_ETHERNET_DEL_MULTICAST_ADDRESS,

        // Start listening on this ethernet multicast address.
        //
        ARP1394_IOCTL_OP_ETHERNET_ENABLE_PROMISCUOUS_MODE,

        // Stop listening on this ethernet multicast address.
        //
        ARP1394_IOCTL_OP_ETHERNET_DISABLE_PROMISCUOUS_MODE,

        // This is a dummy op identifying the beginning of the ethernet-related
        // Ops.
        //
        ARP1394_IOCTL_OP_ETHERNET_LAST = 
                    ARP1394_IOCTL_OP_ETHERNET_DISABLE_PROMISCUOUS_MODE,

        // This is an ioctl that returns, the Node, Euid, and Dummy Mac address
        // for the Bus
		ARP1394_IOCTL_OP_GET_EUID_NODE_MAC_TABLE
		
    } Op;

} ARP1394_IOCTL_HEADER, *PARP1394_IOCTL_HEADER;


typedef struct
{
        UINT64              UniqueID;
        ULONG               Off_Low;
        USHORT              Off_High;
    
}   ARP1394_IOCTL_HW_ADDRESS, *PARP1394_IOCTL_HW_ADDRESS;

typedef struct
{
    ARP1394_IOCTL_HW_ADDRESS    HwAddress;
    ULONG                       IpAddress;
}
ARP1394_ARP_ENTRY, *PARP1394_ARP_ENTRY;


// Structure used to get items from the arp table.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_ARPCACHE
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Local HW Address (64-bit UniqueID and FIFO offset, if any).
    //
    ARP1394_IOCTL_HW_ADDRESS    LocalHwAddress;

    // Total entries currently in the arp table.
    //
    UINT                 NumEntriesInArpCache;

    // Total number of entries avilable in THIS structure.
    //
    UINT                 NumEntriesAvailable;

    // Number of entries filled out in this structure.
    //
    UINT                 NumEntriesUsed;

    // Zero-based index of the first entry in the structure in the
    // arp table.
    //
    UINT                 Index;

    // Space for NumEntriesAvailable arp table entries.
    //
    ARP1394_ARP_ENTRY    Entries[1];
    
} ARP1394_IOCTL_GET_ARPCACHE, *PARP1394_IOCTL_GET_ARPCACHE;


// Structure used to add a single static arp entry.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_ADD_STATIC_ENTRY
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Destination HW Address.
    //
    ARP1394_IOCTL_HW_ADDRESS HwAddress;

    // Destination IP Address in network byte order
    //
    ULONG               IpAddress;

} ARP1394_IOCTL_ADD_ARP_ENTRY, *PARP1394_IOCTL_ADD_ARP_ENTRY;


// Structure used to delete a single static arp entry.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_ADD_STATIC_ENTRY
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Destination IP Address in network byte order.
    //
    ULONG                IpAddress;

} ARP1394_IOCTL_DEL_ARP_ENTRY, *PARP1394_IOCTL_DEL_ARP_ENTRY;


// Enumeration of packet size slots
//
enum
{
    ARP1394_PKTSIZE_128,    // <= 128       bytes
    ARP1394_PKTSIZE_256,    // 129 ... 256  bytes
    ARP1394_PKTSIZE_1K,     // 257 ... 1K   bytes
    ARP1394_PKTSIZE_2K,     // 1K+1 .. .2K  bytes
    ARP1394_PKTSIZE_G2K,    // > 2K         bytes

    ARP1394_NUM_PKTSIZE_SLOTS
};

// Enumeration of packet send/recv time slots
//
enum
{
    // ARP1394_PKTTIME_1US, // <= 1 microsecond
    // ARP1394_PKTTIME_100US,   // 1+ ... 100   microsecond
    ARP1394_PKTTIME_100US,  // <= 100   microsecond
    ARP1394_PKTTIME_1MS,    // 0.1+ ... 1   millisecond
    ARP1394_PKTTIME_10MS,   // 1+ ... 10    milliseconds
    ARP1394_PKTTIME_100MS,  // 10+ ...100   milliseconds
    ARP1394_PKTTIME_G100MS, // > 100        milliseconds
    // ARP1394_PKTTIME_G10MS,   // > 10         milliseconds

    ARP1394_NUM_PKTTIME_SLOTS       
};


// Enumeration of task time slots
//
enum
{
    ARP1394_TASKTIME_1MS,   // <= 1         millisecond
    ARP1394_TASKTIME_100MS, // 1+ ... 100   milliseconds
    ARP1394_TASKTIME_1S,    // 0.1+ ... 1   second
    ARP1394_TASKTIME_10S,   // 1+ ... 10    seconds
    ARP1394_TASKTIME_G10S,  // > 10         seconds

    ARP1394_NUM_TASKTIME_SLOTS      
};


// Keeps track of the packet counts for each  combination of packet-size-slot
// and packet-time-slot.
//
typedef struct
{
    // Count of successful packets
    //
    UINT GoodCounts[ARP1394_NUM_PKTSIZE_SLOTS][ARP1394_NUM_PKTTIME_SLOTS];

    // Count of unsuccessful packets
    //
    UINT BadCounts [ARP1394_NUM_PKTSIZE_SLOTS][ARP1394_NUM_PKTTIME_SLOTS];

} ARP1394_PACKET_COUNTS, *PARP1394_PACKET_COUNTS;


// Structure used to get packet stats.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_PACKET_STATS
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Duration of stats collection, in seconds.
    //
    UINT                    StatsDuration;

    //
    // Some send stats
    //
    UINT                    TotSends;
    UINT                    FastSends;
    UINT                    MediumSends;
    UINT                    SlowSends;
    UINT                    BackFills;
    UINT                    HeaderBufUses;
    UINT                    HeaderBufCacheHits;

    //
    // Some recv stats
    //
    UINT                    TotRecvs;
    UINT                    NoCopyRecvs;
    UINT                    CopyRecvs;
    UINT                    ResourceRecvs;

    //
    // Packet counts
    //
    ARP1394_PACKET_COUNTS   SendFifoCounts;
    ARP1394_PACKET_COUNTS   RecvFifoCounts;
    ARP1394_PACKET_COUNTS   SendChannelCounts;
    ARP1394_PACKET_COUNTS   RecvChannelCounts;

} ARP1394_IOCTL_GET_PACKET_STATS, *PARP1394_IOCTL_GET_PACKET_STATS;


// Structure used to get task stats.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_TASK_STATS
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Duration of stats collection, in seconds.
    //
    UINT    StatsDuration;

    UINT    TotalTasks;
    UINT    CurrentTasks;
    UINT    TimeCounts[ARP1394_NUM_TASKTIME_SLOTS];

} ARP1394_IOCTL_GET_TASK_STATS, *PARP1394_IOCTL_GET_TASK_STATS;


// Structure used to get arp table stats.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_ARPCACHE_STATS
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Duration of stats collection, in seconds.
    //
    UINT    StatsDuration;

    UINT    TotalQueries;
    UINT    SuccessfulQueries;
    UINT    FailedQueries;
    UINT    TotalResponses;
    UINT    TotalLookups;
    UINT    TraverseRatio;

} ARP1394_IOCTL_GET_ARPCACHE_STATS, *PARP1394_IOCTL_GET_ARPCACHE_STATS;


// Structure used to get call stats.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_CALL_STATS
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Duration of stats collection, in seconds.
    //
    UINT    StatsDuration;

    //
    // FIFO-related call stats.
    //
    UINT    TotalSendFifoMakeCalls;
    UINT    SuccessfulSendFifoMakeCalls;
    UINT    FailedSendFifoMakeCalls;
    UINT    IncomingClosesOnSendFifos;

    //
    // Channel-related call stats.
    //
    UINT    TotalChannelMakeCalls;
    UINT    SuccessfulChannelMakeCalls;
    UINT    FailedChannelMakeCalls;
    UINT    IncomingClosesOnChannels;

} ARP1394_IOCTL_GET_CALL_STATS, *PARP1394_IOCTL_GET_CALL_STATS;


// Structure used to reset statistics.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_RESET_STATS
    //
    ARP1394_IOCTL_HEADER Hdr;

}  ARP1394_IOCTL_RESET_STATS, *PARP1394_IOCTL_RESET_STATS;


// Structure used to re-init the interface.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_REINIT_INTERFACE
    //
    ARP1394_IOCTL_HEADER Hdr;

}  ARP1394_IOCTL_REINIT_INTERFACE, *PARP1394_IOCTL_REINIT_INTERFACE;


#if 0
//
// the structure for returning basic information about the miniport.
//
typedef struct
{
    UINT64                  UniqueID;           // This node's 64-bit Unique ID.
    ULONG                   BusGeneration;      // 1394 Bus generation ID.
    USHORT                  NodeAddress;        // Local nodeID for the current bus
                                                // generation.
    USHORT                  Reserved;           // Padding.
    UINT                    MaxRecvBlockSize;   // Maximum size, in bytes, of blocks
                                                // that can be read.
    UINT                    MaxRecvSpeed;       // Max speed which can be accepted
                                                // -- minimum
                                                // of the max local link speed and
                                                // the max local PHY speed.

} ARP1394_IOCTL_LOCAL_NODE_INFO, *PARP1394_IOCTL_LOCAL_NODE_INFO;


//
// the structure for returning basic information about a remote node.
//
typedef struct
{
    UINT64                  UniqueID;           // This node's 64-bit Unique ID.
    USHORT                  NodeAddress;        // Local nodeID for the current bus
                                                // generation.
    USHORT                  Reserved;           // Padding.
    UINT                    MaxRecvBlockSize;   // Maximum size, in bytes, of blocks
                                                // that can be read.
    UINT                    MaxRecvSpeed;       // Max speed which can be accepted
                                                // -- minimum
                                                // of the max local link speed and
                                                // the max local PHY speed.
    UINT                    MaxSpeedBetweenNodes;// Max speed which can be accepted
    UINT                    Flags;  // One or more  ARP1394_IOCTL_REMOTEFLAGS_* consts

        #define ARP1394_IOCTL_REMOTEFLAGS_ACTIVE        (0x1<<0)
        #define ARP1394_IOCTL_REMOTEFLAGS_LOADING       (0x1<<1)
        #define ARP1394_IOCTL_REMOTEFLAGS_UNLOADING     (0x1<<2)


#if 0   // later
    //
    // Following numbers are since the last bus reset.
    //
    UINT                    NumFifoPktsSent;
    UINT                    NumFifoPktsReceived;
    UINT                    NumChannelPktsReceived;
    UINT                    NumFifoSendFailures;
    UINT                    NumFifoReceiveDiscards;
    UINT                    NumChannelPktsReceived;
    UINT64                  NumFifoBytesSent;
    UINT64                  NumChannelBytesSent;
    UINT64                  NumFifoBytesReceived;
    UINT64                  NumChannelBytesReceived;
#endif // 0

} ARP1394_IOCTL_REMOTE_NODE_INFO, *PARP1394_IOCTL_REMOTE_NODE_INFO;

typedef struct
{
    UINT    NumPacketsSent;
    UINT    NumPacketsReceived;
#if 0   // later
    UINT    NumSendFailures;
    UINT    NumReceiveDiscards;
    UINT64  NumBytesSent;
    UINT64  NumBytesReceived;
#endif // 0

} ARP1394_IOCTL_CHANNEL_INFO, *PARP1394_IOCTL_CHANNEL_INFO;
#endif // 0

#define ARP1394_IOCTL_MAX_BUSINFO_NODES     64
#define ARP1394_IOCTL_MAX_BUSINFO_CHANNELS  64
#define ARP1394_IOCTL_MAX_PACKET_SIZE       1000

typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_NICINFO
    //
    ARP1394_IOCTL_HEADER Hdr;

    // NIC information (defined in nic1394.h)
    //
    NIC1394_NICINFO      Info;

#if 0
    UINT    Version;
    UINT    ChannelMapLow;      // LSB bit == channel 0
    UINT    ChannelMapHigh;     // MSB bit == channel 63
    UINT    NumBusResets;
    UINT    SecondsSinceLastBusReset;
    UINT    NumRemoteNodes;
    ARP1394_IOCTL_LOCAL_NODE_INFO   LocalNodeInfo;
    ARP1394_IOCTL_REMOTE_NODE_INFO  RemoteNodeInfo[ARP1394_IOCTL_MAX_BUSINFO_NODES];
    ARP1394_IOCTL_CHANNEL_INFO      ChannelInfo[ARP1394_IOCTL_MAX_BUSINFO_CHANNELS];
#endif
    
    
} ARP1394_IOCTL_NICINFO, *PARP1394_IOCTL_NICINFO;


typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_SEND_PACKET
    //
    ARP1394_IOCTL_HEADER Hdr;

    UINT  PacketSize;
    UCHAR Data[ARP1394_IOCTL_MAX_PACKET_SIZE];
    
} ARP1394_IOCTL_SEND_PACKET, *PARP1394_IOCTL_SEND_PACKET;

typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_RECV_PACKET
    //
    ARP1394_IOCTL_HEADER Hdr;

    UINT  PacketSize;
    UCHAR Data[ARP1394_IOCTL_MAX_PACKET_SIZE];
    
} ARP1394_IOCTL_RECV_PACKET, *PARP1394_IOCTL_RECV_PACKET;

typedef struct
{
    // Channel number.
    //
    UINT            Channel;

    // IP multicast group address bound to this channel.
    //
    ULONG           GroupAddress;

    // Absolute time at which this information was updated,
    // in seconds.
    //
    UINT            UpdateTime;

    // Absolute time at which this mapping will expire.
    // In seconds.
    //
    UINT            ExpieryTime;

    UINT            SpeedCode;

    // Status
    //
    UINT            Flags;  // One of the ARP1394_IOCTL_MCIFLAGS_*
    #define ARP1394_IOCTL_MCIFLAGS_ALLOCATED 0x1

    // NodeID of owner of this channel.
    //
    UINT            NodeId;

} ARP1394_IOCTL_MCAP_CHANNEL_INFO;

// Structure used to get MCAP-related info.
//
typedef struct
{
    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_MCAPINFO
    //
    ARP1394_IOCTL_HEADER Hdr;

    


    // Number of entries filled out in this structure.
    //
    UINT                 NumEntries;

    // Space for NumEntriesAvailable arp table entries.
    //
    ARP1394_IOCTL_MCAP_CHANNEL_INFO
                Entries[ARP1394_IOCTL_MAX_BUSINFO_CHANNELS];
                        
    
} ARP1394_IOCTL_GET_MCAPINFO, *PARP1394_IOCTL_GET_MCAPINFO;


typedef struct
{
    // Hdr.Op must be set to  one of
    //  ARP1394_IOCTL_OP_ETHERNET_START_EMULATION
    //  ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION
    //  ARP1394_IOCTL_OP_ETHERNET_ADD_MULTICAST_ADDRESS
    //  ARP1394_IOCTL_OP_ETHERNET_DEL_MULTICAST_ADDRESS
    //  ARP1394_IOCTL_OP_ETHERNET_ENABLE_PROMISCUOUS_MODE
    //  ARP1394_IOCTL_OP_ETHERNET_DISABLE_PROMISCUOUS_MODE
    //
    ARP1394_IOCTL_HEADER Hdr;

    // Null-terminated NDIS Adapter name
    //
    #define ARP1394_MAX_ADAPTER_NAME_LENGTH 128
    WCHAR AdapterName[ARP1394_MAX_ADAPTER_NAME_LENGTH+1];


    // Flags. Reserved for future use.
    //
    UINT        Flags;

    // Ethernet MAC address. Usage as follows:
    //
    //  ARP1394_IOCTL_OP_ETHERNET_ADD_MULTICAST_ADDRESS: Multicast address
    //  ARP1394_IOCTL_OP_ETHERNET_DEL_MULTICAST_ADDRESS: Multicast address
    //
    // Unused for other operations.
    //
    UCHAR       MacAddress[6];

} ARP1394_IOCTL_ETHERNET_NOTIFICATION, *PARP1394_IOCTL_ETHERNET_NOTIFICATION;


typedef struct
{

    // Hdr.Op must be set to  ARP1394_IOCTL_OP_GET_EUID_NODE_MAC_TABLE
    //
    ARP1394_IOCTL_HEADER Hdr;

	//
	//This contains the Topology

	EUID_TOPOLOGY Map;


} ARP1394_IOCTL_EUID_NODE_MAC_INFO, *PARP1394_IOCTL_EUID_NODE_MAC_INFO;

typedef union
{
    ARP1394_IOCTL_HEADER                Hdr;
    ARP1394_IOCTL_GET_ARPCACHE          GetArpCache;
    ARP1394_IOCTL_ADD_ARP_ENTRY         AddArpEntry;
    ARP1394_IOCTL_DEL_ARP_ENTRY         DelArpEntry;
    ARP1394_IOCTL_GET_PACKET_STATS      GetPktStats;
    ARP1394_IOCTL_GET_TASK_STATS        GetTaskStats;
    ARP1394_IOCTL_GET_ARPCACHE_STATS    GetArpStats;
    ARP1394_IOCTL_GET_CALL_STATS        GetCallStats;
    ARP1394_IOCTL_RESET_STATS           ResetStats;
    ARP1394_IOCTL_REINIT_INTERFACE      ReinitInterface;
    ARP1394_IOCTL_NICINFO               IoctlNicInfo;
    ARP1394_IOCTL_SEND_PACKET           SendPacket;
    ARP1394_IOCTL_RECV_PACKET           RecvPacket;
    ARP1394_IOCTL_ETHERNET_NOTIFICATION EthernetNotification;
    ARP1394_IOCTL_EUID_NODE_MAC_INFO   EuidNodeMacInfo;				

} ARP1394_IOCTL_COMMAND, *PARP1394_IOCTL_COMMAND;


#endif  // _ARP1394_IOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\inc\nicarp.h ===
//
// Copyright (c) 2000-2001, Microsoft Corporation, all rights reserved
//
// nicarp.h
//
// IEEE1394 mini-port/call-manager driver
//
// Decl file for structures that are common to nic1394 and arp1394
// but are private to these two modules
//
// 12/28/1998 ADube Created. 

//
// Loopback Information - Indicates to the arp module
// that a packet is a loopback packet 
//

#ifndef __NICARP_H
#define __NICARP_H

#define NIC_LOOPBACK_TAG 0x0bad0bad


typedef struct _LOOPBACK_RSVD
{
    UCHAR Mandatory[PROTOCOL_RESERVED_SIZE_IN_PACKET];

    ULONG LoopbackTag;

} LOOPBACK_RSVD, *PLOOPBACK_RSVD;



// Status Indicated by nic1394 to tell arp1394 that the bus has been reset
#define NIC1394_STATUS_BUS_RESET                     ((NDIS_STATUS)0x13940001)

// Ethernet MAC address
//
#define ARP_802_ADDR_LENGTH 6               // Length of an 802 address.
typedef  struct
{
    UCHAR  addr[ARP_802_ADDR_LENGTH];
} ENetAddr;


//
// Structure used to define the topology of the bus. 
// This is used only in the case where the bridge is present.
//


typedef struct _EUID_TUPLE
{
    // The 64 buit Unique Id of the 1394 card
    UINT64   Euid;

    // The Ethernet Mac Address associated with this 1394 card
    ENetAddr		ENetAddress;


}EUID_TUPLE, *PEUID_TUPLE;


typedef struct _EUID_TOPOLOGY
{
    //Number of remote nodes
    UINT    NumberOfRemoteNodes;

    // Have one record for each of the 64 nodes
    EUID_TUPLE Node[NIC1394_MAX_NICINFO_NODES];


}EUID_TOPOLOGY, *PEUID_TOPOLOGY;


//
// Structure used in parsing the Encapsulation Header
// of an IP/1394 packet
//
typedef enum _NDIS1394_FRAGMENT_LF
{
    lf_Unfragmented,
    lf_FirstFragment,
    lf_LastFragment,
    lf_InteriorFragment


} NDIS1394_FRAGMENT_LF, *PNDIS1394_FRAGMENT_LF;


typedef union _NDIS1394_UNFRAGMENTED_HEADER
{
//  NIC1394_UNFRAGMENTED_HEADER Header;

    ULONG   HeaderUlong;

    struct 
    {
            ULONG   FH_EtherType:16;
            ULONG   FH_rsv:14;
            ULONG   FH_lf:2;
    } u;

    struct 
    {
            UCHAR   fHeaderHasSourceAddress;
            UCHAR   SourceAddress;
            USHORT  EtherType;
    } u1;



} NDIS1394_UNFRAGMENTED_HEADER, *PNDIS1394_UNFRAGMENTED_HEADER;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\inf\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v 

$(O)\enum1394.inf: $(_INX)\enum1394.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)


$(O)\net1394.inf: $(_INX)\net1394.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\inc\rfc2734.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    rfc2734.h

Abstract:

    Structures and constants from the IP/1394 RFC 2734, which can be found at:
            http://www.ietf.org/rfc/rfc2734.txt 

Revision History:

    Who         When        What
    --------    --------    ----
    josephj     03-28-99    created, based on draft version 14.

--*/

#pragma pack (push, 1)

// ARP request/response pkt, including the unfragmented encapsulation header.
//
typedef struct _IP1394_ARP_PKT
{
    NIC1394_UNFRAGMENTED_HEADER header;
     
    // hardware_type is a constant that identifies IEEE1394. This field must be set
    // to IP1394_HARDWARE_TYPE, defined below. This field must be byte-swapped
    // before the packet is sent out over the wire.
    //
    USHORT                      hardware_type;

    #define IP1394_HARDWARE_TYPE    0x0018

    // protocol_type is a constant that identifies this ARP packet as being an
    // IPV4 ARP packet. This field must be set to IP1394_PROTOCOL_TYPE, defined
    // below. This field must be byte-swapped before the packet is sent out over the
    // wire.
    //
    USHORT                      protocol_type;

    #define IP1394_PROTOCOL_TYPE    0x0800

    // hw_addr_len is the size (in octets) of the senders hw address, which 
    // consists of the following:
    //      sender_unique_ID            (8 bytes)
    //      sender_maxrec               (1 byte)
    //      sspd                        (1 byte)
    //      sender_unicast_FIFO_hi      (2 bytes)
    //      sender_unicast_FIFO_lo      (4 bytes)
    // This field must be set to IP1394_HW_ADDR_LEN, defined below.
    //
    UCHAR                       hw_addr_len;

    #define IP1394_HW_ADDR_LEN  16

    // IP_addr_len is the size of the IP address field. It must be set to
    // sizeof (ULONG).
    //
    UCHAR                       IP_addr_len;


    // opcode should be set to either IP1394_ARP_REQUEST (for ARP request packets)
    // or to IP1394_ARP_RESPONSE (for ARP response packets). Both constants are
    // defined below. This field must be byte-swapped before the packet is sent out
    // over the wire.
    //
    USHORT                      opcode;

    #define IP1394_ARP_REQUEST      1
    #define IP1394_ARP_RESPONSE     2

    //
    // The following 5 fields constitute the sender's hardware address.
    //

    // sender_unique_ID is the sender's unique ID, in network byte order.
    //
    UINT64                      sender_unique_ID;

    // sender_maxrec is the value of max_rec in the sender's configuration ROM
    // bus information block. The following formula converts from max_rec to
    // size in bytes (from "FireWire System Architecture", 1st ed, pp 225 (or look
    // for max_rec in the index)):
    //          size = 2^(max_rec+1)
    // The minimum value of max_rec is 0x1.
    // The maximun value of max_rec is 0xD.
    //          
    // The macros immediately below may be used to convert from max_rec to
    // bytes, and to verify that max_rec is within the valid range.
    //
    UCHAR                       sender_maxrec;

    #define IP1394_MAXREC_TO_SIZE(_max_rec)  (2 << ((_max_rec)+1))
    #define IP1394_IS_VALID_MAXREC(_max_rec) ((_max_rec)>0 && (_max_rec)<0xE)


    // sspd encodes "sender speed", which is the lesser of the sender's link speed
    // and the PHY speed. ssped must be set to one of the IP1394_SSPD_* constants,
    // defined below.
    //
    UCHAR                       sspd;

    #define IP1394_SSPD_S100    0
    #define IP1394_SSPD_S200    1
    #define IP1394_SSPD_S400    2
    #define IP1394_SSPD_S800    3
    #define IP1394_SSPD_S1600   4
    #define IP1394_SSPD_S3200   5
    #define IP1394_IS_VALID_SSPD(_sspd) ((_sspd)<=5)

    //  sender_unicast_FIFO_hi is the high 16-bits of the sender's 48-bit FIFO
    //  address offset, in network byte order.
    //
    USHORT                      sender_unicast_FIFO_hi;

    //  sender_unicast_FIFO_lo is the low 32-bits of the sender's 48-bit FIFO
    //  address offset, in network byte order.
    //
    ULONG                       sender_unicast_FIFO_lo;

    //  sender_IP_address is the sender's IP address, in network byte order.
    //
    ULONG                       sender_IP_address;

    //  target_IP_address is the target's IP address, in network byte order.
    //  This field is ignored if opcode is set to IP1394_ARP_RESPONSE
    //
    ULONG                       target_IP_address;
    
} IP1394_ARP_PKT, *PIP1394_ARP_PKT;



// MCAP group descriptor format (one or more per MCAP packet)
//
typedef struct _IP1394_MCAP_GD
{
    // size, in octets, of this descriptor.
    //
    UCHAR                       length;

    // Type of descriptor. One of the IP1394_MCAP_GD_TYPE_* values below
    //
    UCHAR                       type;

    #define IP1394_MCAP_GD_TYPE_V1 1 // IP multicast MCAP Ver 1.

    // Reserved
    //
    USHORT                      reserved;

    // Expiration (TTL) in seconds
    //
    UCHAR                       expiration;

    // Channel number
    //
    UCHAR                       channel;

    // Speed code.
    //
    UCHAR                       speed;

    // Reserved
    //
    UCHAR                       reserved2;

    // Bandwidth (unused)
    //
    ULONG                       bandwidth;

    //  IP multicast group  address
    // (In theory it could be of arbitrary length, computed by
    //  looking at the "length" field above. However for our purposes
    //  (type==1) we expect the group_address size to be 4.
    //
    ULONG                       group_address;
    
} IP1394_MCAP_GD, *PIP1394_MCAP_GD;


// MCAP message format, including the unfragmented encapsulation header.
//
typedef struct _IP1394_MCAP_PKT
{
    NIC1394_UNFRAGMENTED_HEADER header;
     
    // size, in octets, of the entire MCAP message (NOT including the 
    // encapsulation header).
    //
    USHORT                      length;

    // Reserved
    //
    UCHAR                       reserved;

    // Opcode -- one of the IP1394_MCAP_OP* values below.
    //
    UCHAR                       opcode;

    #define IP1394_MCAP_OP_ADVERTISE    0
    #define IP1394_MCAP_OP_SOLICIT      1

    // zero or more group address descriptors
    //  
    IP1394_MCAP_GD              group_descriptors[1];
    
} IP1394_MCAP_PKT, *PIP1394_MCAP_PKT;


/*

RFC NOTES and COMMENTS

    1. No max channel expiery. Min expiery is 60sec

Extracts from the RFC re MCAP:

    speed: This field is valid only for advertise messages, in which
    case it SHALL specify the speed at which stream packets for the
    indicated channel are transmitted. Table 2 specifies the encoding
    used for speed.

    A recipient of an MCAP
    message SHALL examine the most significant ten bits of source_ID from
    the GASP header; if they are not equal to either 0x3FF or the most
    significant ten bits of the recipient's NODE_IDS register, the
    recipient SHALL IGNORE the message.

    Subsequent to sending a solicitation request, the
    originator SHALL NOT send another MCAP solicitation request until ten
    seconds have elapsed.

    If no MCAP advertise message is received for a particular group
    address within ten seconds, no multicast source(s) are active for
    channel(s) other than the default. Either there is there is no
    multicast data or it is being transmitted on the default channel.

    Once 100 ms elapses subsequent to the initial
    advertisement of a newly allocated channel number , the multicast
    source may transmit IP datagrams using the channel number advertised.

    Except when a channel owner intends to relinquish ownership (as
    described in 9.7 below), the expiration time SHALL be at least 60
    seconds in the future measured from the time the advertisement is
    transmitted.

    No more than ten seconds SHALL elapse from the transmission of its
    most recent advertisement before the owner of a channel mapping
    initiates transmission of the subsequent advertisement. The owner of
    a channel mapping SHOULD transmit an MCAP advertisement in response
    to a solicitation as soon as possible after the receipt of the
    request.

    MCAP advertisements whose
    expiration field has a value less than 60 SHALL be ignored for the
    purpose of overlapped channel detection. 

    The channel numbers
    advertised by owners with smaller physical IDs are invalid; their
    owners SHALL cease transmission of both IP datagrams and MCAP
    advertisements that use the invalid channel numbers. As soon as these
    channel mappings expire , their owners SHALL deallocate any unused
    channel numbers as described in 9.8 below.

    If the original owner
    observes an MCAP advertisement for the channel to be relinquished
    before its own timer has expired, it SHALL NOT deallocate the channel
    number.

    If the
    intended owner of the channel mapping observes an MCAP advertisement
    whose expiration field is zero, orderly transfer of the channel(s)
    from the former owner has failed. 

    A channel mapping expires when expiration seconds have elapsed since
    the most recent MCAP advertisement. At this time, multicast
    recipients SHALL stop reception on the expired channel number(s).
    Also at this time, the owner of the channel mapping(s) SHALL transmit
    an MCAP advertisement with expiration cleared to zero and SHALL
    continue to transmit such advertisements until 30 seconds have
    elapsed since the expiration of the channel mapping.


    If an IP-capable device observes an MCAP advertisement whose
    expiration field is zero, it SHALL NOT attempt to allocate any of the
    channel number(s) specified until 30 seconds have elapsed since the
    most recent such advertisement.

9.10 Bus reset

    A bus reset SHALL invalidate all multicast channel mappings and SHALL
    cause all multicast recipients and senders to zero all MCAP
    advertisement interval timers.

    Intended or prior recipients or transmitters of multicast on other
    than the default channel SHALL NOT transmit MCAP solicitation
    requests until at least ten seconds have elapsed since the completion
    of the bus reset.  Multicast data on other than the default channel
    SHALL NOT be received or transmitted until an MCAP advertisement is
    observed or transmitted for the IP multicast group address.
    Intended or prior transmitters of multicast on other than the default
    channel that did not own a channel mapping for the IP multicast group
    address prior to the bus reset SHALL NOT attempt to allocate a
    channel number from the isochronous resource manager's
    CHANNELS_AVAILABLE register until at least ten seconds have elapsed
    since the completion of the bus reset.


*/
#pragma pack (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\bcm.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// mp.h
//
// IEEE1394 mini-port/call-manager driver
//
// Broadcast Channel Manager - header file
//
// 07/05/99 ADube - Created - Declaration for miniport routines
//


//
// Various timeout used throught the BCM algorithm
//
#define ONE_SEC 1000000
#define ONE_MINUTE 60000 
#define FIFTY_MILLISECONDS 50000

#define BCM_NUM_RETRY 5


//
// BCR Register flags in the BigEndian and little Endian format
//
#define BCR_IMPLEMENTED_BIG_ENDIAN              0x00000080
#define BCR_IMPLEMENTED_LITTLE_ENDIAN           0x80000000

#define BCR_VALID_BIG_ENDIAN                    0x000000C0
#define BCR_VALID_LITTLE_ENDIAN                 0xC0000000 


typedef struct _BCM_CONTEXT 
{
    ULONG Generation;
    PADAPTERCB pAdapter;

}BCM_CONTEXT, *PBCM_CONTEXT;



//
//  Broadcast Channel Manager functions begin here
//


VOID
nicBCRAccessedCallback (
    IN PNOTIFICATION_INFO pNotificationInfo
    );


VOID
nicBCMAbort (
    IN PADAPTERCB pAdapter,
    IN PREMOTE_NODE pRemoteNode
    );

    

VOID
nicBCMAddRemoteNode (
    IN PADAPTERCB pAdapter, 
    IN BOOLEAN fIsOnlyRemoteNode 
    );



VOID
nicBCMAlgorithm(
    PADAPTERCB pAdapter,
    ULONG BcmGeneration
    );


VOID
nicBCMAlgorithmWorkItem(
    PNDIS_WORK_ITEM pWorkItem,
    PVOID   Context
    );

VOID
nicBCMCheckLastNodeRemoved(
    IN PADAPTERCB pAdapter
    );


NDIS_STATUS
nicFindIrmAmongRemoteNodes (
    IN PADAPTERCB pAdapter,
    IN ULONG BCMGeneration, 
    OUT PPREMOTE_NODE ppIrmRemoteNode
    );
    

VOID
nicFreeBroadcastChannelRegister(
    IN PADAPTERCB pAdapter
    );
    

NDIS_STATUS
nicInformAllRemoteNodesOfBCM (
    IN PADAPTERCB pAdapter
    );

NDIS_STATUS
nicInitializeBroadcastChannelRegister (
    PADAPTERCB pAdapter
    );


NDIS_STATUS
nicIsLocalHostTheIrm(
    IN PADAPTERCB pAdapter, 
    OUT PBOOLEAN pfIsLocalHostIrm,
    OUT PPTOPOLOGY_MAP  ppTopologyMap,
    OUT PNODE_ADDRESS pLocalHostAddress
    );


NDIS_STATUS
nicLocalHostIsIrm(
    IN PADAPTERCB pAdapter
    );



NDIS_STATUS
nicLocalHostIsNotIrm (
    IN PADAPTERCB pAdapter,
    IN ULONG CurrentGeneration
    );


NDIS_STATUS
nicLocalNotIrmMandatoryWait (
    IN PADAPTERCB pAdapter,
    IN ULONG BCMGeneration,
    OUT NETWORK_CHANNELSR* pBCR
    );



NDIS_STATUS
nicReadIrmBcr (
    PREMOTE_NODE pIrmRemoteNode,
    IN PMDL pBCRMdl,
    IN ULONG GivenGeneration,
    OUT PBOOLEAN fDidTheBusReset
    );


NDIS_STATUS
nicRetryToReadIrmBcr( 
    PREMOTE_NODE pIrmRemoteNode, 
    PMDL pRemoteBCRMdl,                                           
    ULONG Generation,
    PBOOLEAN pfDidTheBusReset
    ); 


NDIS_STATUS
nicScheduleBCMWorkItem(
    PADAPTERCB pAdapter
    );  


VOID
nicSetEventMakeCall (
    IN PADAPTERCB pAdapter
    );


VOID
nicLocalHostIsNotIrmPost (
    PADAPTERCB pAdapter,
    PREMOTE_NODE pIrmRemoteNode,
    BOOLEAN fNeedToReset, 
    BOOLEAN fRemoteNodeBCRIsValid , 
    BOOLEAN fLocalHostBCRIsValid ,
    BOOLEAN fDidTheBusReset, 
    NETWORK_CHANNELSR*      pBCR
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\bcm.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// bcm.c
//
// IEEE1394 mini-port/call-manager driver
//
// Bradcast Channel Manager
//
// 07/05/99 ADube - Created - Declaration for miniport routines
//


#include <precomp.h>
#pragma hdrstop

//
// Local Prototypes
//

VOID
nicUpdateLocalHostNodeAddress (
    IN PADAPTERCB 
    );




//
// Local functions
//
VOID
nicBCMReset (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:
 Resets the Bus with the force root flag.
 Only if there are remote nodes present on the bus

Arguments:
  pAdapter

Return Value:


--*/
{
    BOOLEAN NoRemoteNodes = FALSE;

    
    TRACE( TL_T, TM_Bcm, ( "==> nicBCMReset  " ) );

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    NoRemoteNodes = IsListEmpty (&pAdapter->PDOList);
    
    ADAPTER_RELEASE_LOCK (pAdapter);


    //
    // Do not reset the bus if there are no remote nodes present
    //
    if (NoRemoteNodes == TRUE)  
    {
        return;
    }

    //
    //Reset the bus
    //
    TRACE( TL_I, TM_Bcm, ( "   RESETTING WITH FORCE ROOT") );

    nicBusReset( pAdapter , BUS_RESET_FLAGS_FORCE_ROOT);


    TRACE( TL_T, TM_Bcm, ( "<== nicBCMReset  " ) );

}


VOID
nicBCRAccessedCallback (
    IN PNOTIFICATION_INFO pNotificationInfo
    )
    // Function Description:
    //   This is the callback function invoked whenever another node
    //   tries to access the local host's BCR
    //   The value of the BCR is set elsewhere. So this function simply returns
    //
    // Arguments
    // Adapter - this is passed to the workitem
    //
    //
    // Return Value:
    //  Failure if allocation of workitem failed
    //
    
{
    UNALIGNED NETWORK_CHANNELSR*    pBCR = NULL;
    PADAPTERCB                      pAdapter = (PADAPTERCB) pNotificationInfo->Context;
    PBROADCAST_CHANNEL_DATA         pBCRData  = &pAdapter->BCRData;
    
    TRACE( TL_T, TM_Bcm, ( "==> nicBCRAccessedCallback  NotificationInfo %x", pNotificationInfo) );
    TRACE( TL_V, TM_Bcm, ( " pMdl %x", pNotificationInfo->Mdl) );
    TRACE( TL_V, TM_Bcm, ( " SourceID  %x", ((PASYNC_PACKET)pNotificationInfo->RequestPacket)->AP_Source_ID) );

    
    pBCR = (NETWORK_CHANNELSR*) NIC_GET_SYSTEM_ADDRESS_FOR_MDL(pNotificationInfo->Mdl);
    

    ASSERT (pNotificationInfo->Mdl == pAdapter->BCRData.AddressRangeContext.pMdl);

    switch (pNotificationInfo->fulNotificationOptions)
    {

        case NOTIFY_FLAGS_AFTER_READ:
        {
            TRACE( TL_V, TM_Bcm, ( " LocalHost's BCR is READ") );
                
            if ( pBCRData->Flags & BCR_ChannelAllocated)
            {
                TRACE( TL_V, TM_Bcm, ( " BCR_ChannelAllocated Flag Set ") );
            }
            else
            {
                TRACE( TL_V, TM_Bcm, ( " BCR_ChannelAllocated Flag Not Set ") );
            }
            ASSERT ( pAdapter->BCRData.LocalHostBCRBigEndian & BCR_IMPLEMENTED_BIG_ENDIAN);
            
            TRACE( TL_V, TM_Bcm, ( " pBCR %x", pBCR) );
            TRACE( TL_I, TM_Bcm, ( " BCR Accessed %x", *pBCR) );
            break;
        }

        case NOTIFY_FLAGS_AFTER_LOCK:
        {
            TRACE( TL_V, TM_Bcm, ( " LocalHost's BCR is being Locked to") );
            //
            // knowingly fall into AsyncWrite
            //
        }
        
        case NOTIFY_FLAGS_AFTER_WRITE:
        {
            ULONG LocalHostBCRLittleEndian;
            TRACE( TL_V, TM_Bcm, ( " LocalHost's BCR is being Written to") );
            
            //
            // Update local data structures.
            //
            
            LocalHostBCRLittleEndian = SWAPBYTES_ULONG (pAdapter->BCRData.LocalHostBCRBigEndian);

            pBCR = (NETWORK_CHANNELSR*)(&LocalHostBCRLittleEndian);
            TRACE( TL_V, TM_Bcm, ( " pBCR %x", pBCR) );
            TRACE( TL_V, TM_Bcm, ( " BCR %x", *pBCR) );
            
            if ( BCR_IS_VALID (pBCR) == TRUE)
            {
                ADAPTER_ACQUIRE_LOCK(pAdapter);

                pAdapter->BCRData.IRM_BCR.NC_One =1;
                pAdapter->BCRData.IRM_BCR.NC_Valid =1;
                pAdapter->BCRData.IRM_BCR.NC_Channel = pBCR->NC_Channel;
                
                BCR_SET_FLAG (pAdapter,BCR_LocalHostBCRUpdated);
                

                ADAPTER_RELEASE_LOCK(pAdapter);

                nicSetEventMakeCall(pAdapter);

                TRACE( TL_I, TM_Bcm, ( " IRM_BCR Accessed %x", pAdapter->BCRData.IRM_BCR) );

            }
            break;

        }

        default :
        {
            ASSERT (0);
            break;
        }

    }

        
    TRACE( TL_T, TM_Bcm, ( "<== nicBCRAccessedCallback NotificationInfo %x", pNotificationInfo) );
    
}




VOID
nicBCMAddRemoteNode (
    IN PADAPTERCB pAdapter,
    IN BOOLEAN fIsOnlyRemoteNode
    )
    
/*++


Routine Description:
  This is the BCM algorithm - It finds out if the local host is the IRM and goes into the appropriate code path.
  Due to network conditions, this can quietly fail if all other remedies fail

Arguments:
 pAdapter - Adapter
 Generation - Generation associated with this iteration of the algorithm

Return Value:
 None -



--*/



{
    BOOLEAN fDoBcm = FALSE;
    ULONG Generation = 0;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    TRACE( TL_T, TM_Bcm, ( "==>nicBCMAddRemoteNode pAdapter %x, fIsOnlyRemoteNode %x ", pAdapter, fIsOnlyRemoteNode  ) );


    NdisStatus = nicGetGenerationCount (pAdapter, &Generation);


    //
    // Do not schedule the BCM, if the have a valid BCR for the current generation
    //
    if (NdisStatus == NDIS_STATUS_SUCCESS &&
      (BCR_IS_VALID (&pAdapter->BCRData.IRM_BCR) == TRUE) &&
      Generation == pAdapter->Generation )
    {
        fDoBcm = FALSE;
    }
    else
    {
        fDoBcm  = TRUE;
    }

    TRACE( TL_T, TM_Bcm, ( "  nicBCMAddRemoteNode fDoBCM%x ", fDoBcm) );

    
    //
    // Set An Event so a waiting BCM thread (in FindIrmAmongRemoteNodes) can
    // be schduled to run
    //
    ADAPTER_ACQUIRE_LOCK (pAdapter);


    BCR_CLEAR_FLAG (pAdapter, BCR_LastNodeRemoved);


    if (fDoBcm == TRUE)
    {
        //
        // if the BCM is already in progress, mark it as dirty
        //
        BCR_SET_FLAG (pAdapter, BCR_NewNodeArrived);    

        pAdapter->BCRData.BCRWaitForNewRemoteNode.EventCode = Nic1394EventCode_NewNodeArrived;
        
        NdisSetEvent( &pAdapter->BCRData.BCRWaitForNewRemoteNode.NdisEvent);

        
    }

    ADAPTER_RELEASE_LOCK (pAdapter);

    if (fDoBcm  == TRUE)
    {
        TRACE( TL_A, TM_Bcm , ("Add RemoteNode- scheduling the BCM" ) );

        nicScheduleBCMWorkItem(pAdapter);
    }

    //
    // now do the media connectivity stuff
    //
    
    if (fIsOnlyRemoteNode == TRUE)
    {
        //
        // WE have media connectivity 
        //
        pAdapter->MediaConnectStatus = NdisMediaStateConnected;
        
        nicMIndicateStatus( pAdapter, NDIS_STATUS_MEDIA_CONNECT, NULL, 0);  
    }
    


    TRACE( TL_T, TM_Bcm, ( "<== nicBCMAddRemoteNode ") );

}















VOID
nicBCMAlgorithm(
    PADAPTERCB pAdapter,
    ULONG BcmGeneration
    )



/*++

Routine Description:

  Execute the BCM algorithm.
  Finds out if the current host Is IRM
  If YES then inform remote nodes and exit
  if NO then find the remote node and read its BCR.

  Reasons for abort - New Node Arrival or Invalid Generation caused by a BusReset

  If no remote nodes are present and this node is the IRM it will allocate the b channel and exit

Arguments:

    pAdapter - paDapter
    BCMGeneration - Generation at which the BCM was started

Return Value:


--*/
{

    NDIS_STATUS         NdisStatus  = NDIS_STATUS_FAILURE;
    PREMOTE_NODE        pRemoteNode= NULL;  
    PREMOTE_NODE        pIRMRemoteNode = NULL;
    PTOPOLOGY_MAP       pTopologyMap = NULL;
    ULONG               Length = DEFAULT_TOPOLOGY_MAP_LENGTH;
    PVOID               pTopologyBuffer = NULL;
    NODE_ADDRESS        LocalNodeAddress;
    BOOLEAN             fIsLocalHostIrm = FALSE;
    ULONG               TopologyGeneration = 0;
    PVOID               pOldTopologyMap = NULL;
    STORE_CURRENT_IRQL;
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
    
    TRACE( TL_T, TM_Bcm, ( "==>nicBCMAlgorithm pAdapter %x, BcmGen %x", pAdapter, BcmGeneration ) );


    do
    {   
        
        ASSERT (BCR_TEST_FLAG (pAdapter, BCR_BCMInProgress) == TRUE);
        //
        // find out if the local host is the IRM and update the generation count as well
        //
        NdisStatus = nicIsLocalHostTheIrm ( pAdapter,
                                           &fIsLocalHostIrm,
                                           &pTopologyMap,
                                           &LocalNodeAddress);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            
            TRACE( TL_A, TM_Bcm, ( "    nicBCMAlgorithm:  nicIsLocalHostTheIrm FAILED ") );
            break;
        }   

        //
        // Update the adapter structure
        //
        TopologyGeneration = pTopologyMap->TOP_Generation;

        
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        if (TopologyGeneration != BcmGeneration)
        {
            ADAPTER_SET_FLAG(pAdapter, fADAPTER_InvalidGenerationCount);
            ADAPTER_RELEASE_LOCK(pAdapter);
            FREE_NONPAGED (pTopologyMap);
            pTopologyMap = NULL;
            TRACE( TL_A, TM_Bcm, ( "  TopologyGeneration %x, BcmGeneration %x", TopologyGeneration, BcmGeneration) );
            break;

        }

        //
        // extract information from the topology map and store it in the adapter structure
        //
        ASSERT (pAdapter->Generation == pTopologyMap->TOP_Generation);
        pAdapter->BCRData.LocalNodeAddress = LocalNodeAddress;
        pOldTopologyMap = pAdapter->BCRData.pTopologyMap;
        pAdapter->BCRData.pTopologyMap = pTopologyMap;
        pAdapter->BCRData.LocalNodeNumber = LocalNodeAddress.NA_Node_Number;
        pAdapter->NodeAddress = LocalNodeAddress;
        pAdapter->Generation =  pTopologyMap->TOP_Generation;
        BcmGeneration = pTopologyMap->TOP_Generation;
        
        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Free the Old Topology Map
        //
        if (pOldTopologyMap != NULL)
        {
            FREE_NONPAGED(pOldTopologyMap);
        }

        //
        // Now Start the BCM algorithm
        //
        if (fIsLocalHostIrm == TRUE)
        {
            pAdapter->BCRData.Flags |= BCR_LocalHostIsIRM;
            
            ASSERT (pTopologyMap->TOP_Node_Count-1 ==  LocalNodeAddress.NA_Node_Number);

            TRACE( TL_V, TM_Bcm, ( "    LOCAL HOST IS IRM ") );

            NdisStatus = nicLocalHostIsIrm (pAdapter);
        }
        else
        {
            TRACE( TL_V, TM_Bcm, ( "    LOCAL HOST IS NOT IRM ") );

            NdisStatus = nicLocalHostIsNotIrm( pAdapter,
                                               BcmGeneration  );

        }

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_V, TM_Bcm, ( "    nicBCMAlogrithm: nicLocalHostIsNotIrm or nicLocalHostIsIrm FAILED") );
            break;
        }

        //
        // Marks the end of the BCM algorithm . Do the clean up work.
        // Check for the last node going away. , Release any pending make calls
        // and set up the Gasp Header
        //

        nicMakeGaspHeader (pAdapter, &pAdapter->GaspHeader);
        
        nicSetEventMakeCall (pAdapter);

        
    } while (FALSE);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        NIC1394_LOG_PKT(pAdapter,
                            NIC1394_LOGFLAGS_BCM_FAILED,
                            pAdapter->Generation,
                            fIsLocalHostIrm ,
                            &NdisStatus,
                            sizeof (NDIS_STATUS));

        BCR_SET_FLAG (pAdapter, BCR_BCMFailed);
    }
    
    TRACE( TL_T, TM_Bcm, ( "<==nicBCMAlgorithm %x  ", NdisStatus ) );
    MATCH_IRQL;
    
}



VOID
nicBCMAlgorithmWorkItem(
    PNDIS_WORK_ITEM pWorkItem,
    PVOID   pContext
    )

/*++

Routine Description:
  The function kicks of the BCM algorithm.
  Restarts the BCM if a reset occurred during the BCM algorithm.

Arguments:
  Adapter - localhost

Return Value:


--*/


{
    PADAPTERCB          pAdapter    = (PADAPTERCB)pContext;
    ULONG               BcmGeneration = pAdapter->Generation;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    ULONG               Generation;
    BOOLEAN             fRestartBCM = FALSE;
    BOOLEAN             fFreeBCR = FALSE;
    BOOLEAN             fFlagSetByThisThread = FALSE;
    STORE_CURRENT_IRQL;

    TRACE( TL_T, TM_Bcm, ( "==>nicBCMAlgorithmWorkItem pAdapter %x, Generation  %x", pAdapter, BcmGeneration  ) );



    //
    // Ensure that only one thread gets into the BCM algorithm and
    // all other threads are returned immediately
    //
    
    ADAPTER_ACQUIRE_LOCK (pAdapter);

    //
    // If the BCR is being freed, then don't touch it
    //
    
    if (BCR_TEST_FLAGS (pAdapter, (BCR_Freed |BCR_BCRNeedsToBeFreed ) )== TRUE)
    {
        // Do Nothing, this thread will simply exit
        //

    }
    else
    {
        //
        // The BCR is active, 
        // If there is no other thread running the BCM algorithm, then this thread should set 
        // the BCMInProgress flag
        //
        if (BCR_TEST_FLAG (pAdapter, BCR_BCMInProgress ) == FALSE )
        {
            BCR_SET_FLAG (pAdapter, BCR_BCMInProgress );
            fFlagSetByThisThread = TRUE;
        }

    }  

    ADAPTER_RELEASE_LOCK (pAdapter);

    
    do
    {

        //
        // First check to see if we have a valid reason to stop
        //
        if (fFlagSetByThisThread == FALSE)
        {
            break;
        }

        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // If there are no remote nodes then mark the BCR as so
        //
        if (IsListEmpty (&pAdapter->PDOList) == TRUE )
        {
            TRACE (TL_V, TM_Bcm, ("No Nodes present" )  );
            BCR_SET_FLAG (pAdapter, BCR_NoNodesPresent);
            
        }
        else
        {

            BCR_CLEAR_FLAG (pAdapter, BCR_NoNodesPresent);
        }   
        
        
        //
        // Clear the two flags which cause us to restart the BCM
        //
        ADAPTER_CLEAR_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) ;
        BCR_CLEAR_FLAG (pAdapter, BCR_NewNodeArrived );


        ADAPTER_RELEASE_LOCK (pAdapter);
        

        do
        {
            NdisStatus = nicGetGenerationCount (pAdapter, &Generation) ;

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_T, TM_Bcm, ( "  nicGetGenerationCount , Generation  %x", pAdapter, BcmGeneration  ) );

                break;
            }

            //
            //  If the BCM is freed then exit
            //
            if ((BCR_TEST_FLAGS (pAdapter, BCR_Freed | BCR_BCRNeedsToBeFreed )== TRUE) )
            {
                break;
            }


            //
            // Update the generation count
            //
            BcmGeneration = Generation;
            pAdapter->Generation = Generation;
            //
            // Update the remote nodes table
            //
            nicUpdateRemoteNodeTable (pAdapter);

            nicUpdateLocalHostNodeAddress (pAdapter);
        
            if ( ADAPTER_TEST_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) == TRUE)
            {
                //
                // The local host has been reset since the start of the loop. Break
                // out and restart
                //
                break;
        
            }

            //
            // Now start the BCM
            //
            

            if (BCR_TEST_FLAG (pAdapter, BCR_LocalHostBCRUpdated ) == FALSE)
            {

                //
                // We need to go and do the BCM because our registers have not been updated
                //
                nicBCMAlgorithm(pAdapter, BcmGeneration);
            }
            else
            {
                
                //
                // Our BCR was written to
                //
                ULONG                           LocalHostBCRLittleEndian ;
                NETWORK_CHANNELSR*              pBCR;

                ASSERT (BCR_TEST_FLAG (pAdapter, BCR_LocalHostBCRUpdated ) == TRUE);
                

                //
                // Update the IRM_BCR so we have a record of the new BCM
                //
                ADAPTER_ACQUIRE_LOCK (pAdapter);

                NdisZeroMemory (&pAdapter->BCRData.IRM_BCR, sizeof (NETWORK_CHANNELSR) );
                
                LocalHostBCRLittleEndian = SWAPBYTES_ULONG (pAdapter->BCRData.LocalHostBCRBigEndian);
                
                ASSERT ((LocalHostBCRLittleEndian & BCR_VALID_LITTLE_ENDIAN) == BCR_VALID_LITTLE_ENDIAN);

                pBCR = (NETWORK_CHANNELSR*)(&LocalHostBCRLittleEndian);
                
                pAdapter->BCRData.IRM_BCR.NC_Channel = pBCR->NC_Channel ;           // bits 0-5
                pAdapter->BCRData.IRM_BCR.NC_Valid = pBCR->NC_Valid ;             // bit  30
                pAdapter->BCRData.IRM_BCR.NC_One  = pBCR->NC_One ;
                
                ADAPTER_RELEASE_LOCK (pAdapter);

            }

            
        } while (FALSE);

        //
        // Check to see if another Bus Reset has come in.
        // if so we need to restart the BCM
        //

        ADAPTER_ACQUIRE_LOCK (pAdapter);

        BCR_CLEAR_FLAG (pAdapter, BCR_BCMInProgress);


        //
        // if the generation is bad the BCR is not being freed initialzed then restart the BCM
        //

        
        TRACE( TL_V, TM_Bcm, ( "pAdapter Flags %x, BCM flags %x, BCM %x", pAdapter->ulFlags, pAdapter->BCRData.Flags, pAdapter->BCRData.IRM_BCR) );

        //
        // If the BCR is getting freed , set the flag and break, then we cannot loop back, we must exit
        //
        if (BCR_TEST_FLAGS (pAdapter, (BCR_Freed |BCR_BCRNeedsToBeFreed ) )== TRUE)
        {

            //
            // As the BCM is about to be freed, this run of the BCM should terminate 
            // and free the BCR
            //
            fRestartBCM = FALSE;    
            fFreeBCR = TRUE;
            ADAPTER_RELEASE_LOCK (pAdapter);
            break;

        }

        //
        // We need to do the bcm again, if a reset has occurred or a new node has arrived
        //
        if ((ADAPTER_TEST_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) == TRUE) ||
             (BCR_TEST_FLAG (pAdapter, BCR_NewNodeArrived)== TRUE)  )
        {
        
            //
            // Invalidate the BCR and restart
            //
            pAdapter->BCRData.IRM_BCR.NC_Valid  = 0;

            //
            // We are going to try again. Update the flags
            //
            BCR_CLEAR_FLAG (pAdapter, BCR_BCMFailed | BCR_LocalHostBCRUpdated |  BCR_LocalHostIsIRM | BCR_NewNodeArrived );

            //
            // As this thread is going ot retry thr BCM, it must block all new entrants again
            //
            BCR_SET_FLAG (pAdapter, BCR_BCMInProgress);


            fRestartBCM = TRUE; 


            TRACE( TL_V, TM_Bcm, ( "Restart BCM TRUE ") );

                
        }   
        else
        {
            //
            // We do not retart the BCM has completed
            //
            TRACE( TL_V, TM_Bcm, ( "Restart BCM FALSE") );

            fRestartBCM = FALSE;    
        }
        
        ADAPTER_RELEASE_LOCK (pAdapter);

        if ((fRestartBCM == TRUE) &&
            (BCR_TEST_FLAGS (pAdapter, BCR_ChannelAllocated) == TRUE))
        {
            TRACE (TL_V, TM_Bcm, ("Free Channel %x", pAdapter->BCRData.LocallyAllocatedChannel ));
            nicFreeChannel (pAdapter, pAdapter->BCRData.LocallyAllocatedChannel );
        }

        //
        //  fSimply Exit is also false, and will allow this thread to execute again
        //
    }while (fRestartBCM == TRUE) ;


    if (fFlagSetByThisThread == TRUE)
    {
        if ( BCR_TEST_FLAG (pAdapter, BCR_BCRNeedsToBeFreed) == FALSE)
        {
            //
            // If we are not freeing the BCR, then the adapter is still valid.
            // Update the local Host Node Address, so that we have the latest information 
            // from the bus. 
            //
            nicUpdateLocalHostNodeAddress (pAdapter);
            nicUpdateRemoteNodeTable (pAdapter);

        }

    
    }

    //
    // Does the BCR need to be freed by this thread. Only threads that have been
    // given a chance to execute the bcm, should be able to free the BCR
    //
    if (fFreeBCR == TRUE)
    {
        nicFreeBroadcastChannelRegister (pAdapter);
    }

    //
    // Dereference the adapter . reference was added for the work item
    //
    nicDereferenceAdapter (pAdapter, "nicBCMAlgorithmWorkItem ");
    
        
    FREE_NONPAGED (pWorkItem);

    TRACE( TL_T, TM_Bcm, ( "<==nicBCMAlgorithmWorkItem fRestartBCM %x", fRestartBCM) );
    MATCH_IRQL; 
}





VOID
nicBCMAbort (
    IN PADAPTERCB pAdapter,
    IN PREMOTE_NODE pRemoteNode
    )

    // Function Description:
    //    This function is called when the BCM aborts. It should release the allocated channel
    //
    // Arguments
    //  pAdapter - Current local Host
    //
    // Return Value:
    //
{
    BOOLEAN fNeedToFreeChannel = FALSE;
    PBROADCAST_CHANNEL_DATA pBCRData = &pAdapter->BCRData;

    TRACE( TL_T, TM_Bcm, ( "==>nicBCMAbort  pAdapter %x", pAdapter) );

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    if ( BCR_TEST_FLAG (pAdapter, BCR_InformingRemoteNodes) == TRUE)
    {
        fNeedToFreeChannel = TRUE;
        BCR_CLEAR_FLAG (pAdapter, BCR_ChannelAllocated);
        BCR_CLEAR_FLAG (pAdapter, BCR_InformingRemoteNodes);
    }
    else
    {
        fNeedToFreeChannel = FALSE;
    }

    ADAPTER_RELEASE_LOCK (pAdapter);

    if (fNeedToFreeChannel == TRUE)
    {
        nicFreeChannel ( pAdapter,
                        pBCRData->LocallyAllocatedChannel);
                
    }
        
    pBCRData->LocallyAllocatedChannel = INVALID_CHANNEL;


    TRACE( TL_T, TM_Bcm, ( "<==nicBCMAbort  " ) );

}



NDIS_STATUS
nicFindIrmAmongRemoteNodes (
    IN PADAPTERCB pAdapter,
    IN ULONG BCMGeneration,
    OUT PPREMOTE_NODE ppIrmRemoteNode
    )
    // Function Description:
    //   This function goes through all the remote nodes
    //   and attempts to get their address to verify which one is
    //   the IRM
    //
    //
    // Arguments
    //   pADpater - Local host
    //   BCMGeneration - the Gerneration at which the BCMStarted
    //   ppIrmRemoteNode - output value - IRM
    //
    // Return Value:
    //  Success - if an IRM is found
    //
{
    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    PLIST_ENTRY             pPdoListEntry = NULL;
    PREMOTE_NODE            pRemoteNode = NULL;
    PREMOTE_NODE            pIrmRemoteNode = NULL;
    NODE_ADDRESS            RemoteNodeAddress;
    ULONG                   HighestNode;
    ULONG                   Generation;
    ULONG                   NumRetry =0;
    PNIC1394_EVENT          pBCRWaitForNewRemoteNode = &pAdapter->BCRData.BCRWaitForNewRemoteNode;
    ULONG                   BackOffWait = ONE_MINUTE>>4;


    TRACE( TL_T, TM_Bcm, ( "==>nicFindIrmAmongRemoteNodes pAdapter %x, ppIrmRemoteNode %x",
                            pAdapter, ppIrmRemoteNode) );

    ASSERT (pAdapter->BCRData.pTopologyMap != NULL);

    HighestNode =   pAdapter->BCRData.pTopologyMap->TOP_Node_Count-1;

    //
    // Set up a loop, so that we continue until we succeed, timeout, or have a good reason to break
    // One of two things will cause the break:
    //  1. the bus has been reset - break out
    //  2. Irm has been found
    //

    do
    {
        //
        // Reset the event here - This is so that when the newly arrived node is not the IRM 
        // and we will need to wait another time 
        //
        
        pBCRWaitForNewRemoteNode->EventCode  = Nic1394EventCode_InvalidEventCode;

        NdisResetEvent (&pBCRWaitForNewRemoteNode->NdisEvent);

        
        //
        // First see if we already have this remote node in our table
        //
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        if (pAdapter->NodeTable.RemoteNode[HighestNode] != NULL)
        {
            //
            // we found the IRM. Lets break out.
            //
                    
            *ppIrmRemoteNode = pAdapter->NodeTable.RemoteNode[HighestNode] ;

            //
            // Reference the IRM. This will be dereferenced after the BCM is finished. (ie) at the end of nicLocalHostisNotIrm
            //
            nicReferenceRemoteNode (*ppIrmRemoteNode, FindIrmAmongRemoteNodes);

            
            ADAPTER_RELEASE_LOCK (pAdapter);

            NdisStatus = NDIS_STATUS_SUCCESS;

            //
            // Break out if the IRM is found
            //
            break;

        }
        else
        {
            
            //
            // If the IRM is not in adapter's data structures, the thread needs to wait for it to arrive
            //
            BOOLEAN bWaitSuccessful;

            ADAPTER_RELEASE_LOCK (pAdapter);

            //
            // Sleep and try again
            //
            TRACE (TL_V, TM_Bcm, ( " About to Wait 15 sec. for Remote Node") );
    
            bWaitSuccessful = NdisWaitEvent (&pBCRWaitForNewRemoteNode->NdisEvent, BackOffWait );

            TRACE (TL_V, TM_Bcm, ( "  pBCRWaitForNewRemoteNode signalled Event Code = %x, bWaitSuccessful %x",
                                     pBCRWaitForNewRemoteNode->EventCode, bWaitSuccessful) );

            BackOffWait = BackOffWait << 1;         

            //
            // It has been seen that the Remote Node's address might get updated 
            // after a small delay. Refresh our NodeTable here
            //
            nicUpdateRemoteNodeTable(pAdapter);

            if (bWaitSuccessful == TRUE)
            {
                //
                // Check for invalid  conditions
                //

                if (pBCRWaitForNewRemoteNode->EventCode == nic1394EventCode_BusReset  ||
                  pBCRWaitForNewRemoteNode->EventCode == nic1394EventCode_FreedAddressRange) 
                {
                    TRACE( TL_V, TM_Bcm, ( " Bus Has been reset,or addresss range freed aborting BCM") );

                    //
                    // Break out if the Bus Has been reset
                    //
                    break;
                }

                TRACE( TL_V, TM_Bcm, ( "   New Node has arrived check its node address") );
                
                
                ASSERT (pBCRWaitForNewRemoteNode->EventCode  == Nic1394EventCode_NewNodeArrived);

                //
                // Hit the while (TRUE) condition loop back  and verify if the new node is the IRM
                //

            }
            else
            {
                //
                //  Wait has timed out
                //
                if (ADAPTER_TEST_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) == TRUE)
                {
                    //
                    // If the generation is invalid then break out and abort the BCM
                    //
                    NdisStatus = NIC1394_STATUS_INVALID_GENERATION;
                    break;

                }

                NumRetry ++;


                if (NumRetry == 5 )// arbtrary constant
                {
                    break;
                
                }
            }
        }   


            
    } while (TRUE);     

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        //
        // Log this failuire
        //
        NIC1394_LOG_PKT(pAdapter,
                        NIC1394_LOGFLAGS_BCM_IRM_NOT_FOUND,
                        pAdapter->Generation,
                        HighestNode,
                        &pAdapter->NodeTable,
                        5 * sizeof (PVOID));   // arbitrarily number - copies 5 entries

    


    }
    
    TRACE( TL_T, TM_Bcm, ( "<==nicFindIrmAmongRemoteNodes Status %x pIrm %x", NdisStatus, *ppIrmRemoteNode ) );

    return NdisStatus;
}


VOID
nicFreeBroadcastChannelRegister(
    IN PADAPTERCB pAdapter
    )

    // Function Description:
    //   Free the boradcast channed reigster. Only called
    //   from the Init failure or halt code path
    //
    // Arguments
    //   pAdapter
    //
    // Return Value:
    //
    //  None
    //

{
    ADDRESS_RANGE_CONTEXT BCRAddressRange;
    TIMESTAMP_ENTRY ("==>Free BCR");
    TRACE( TL_T, TM_Bcm, ( "==> nicFreeBroadcastChannelRegister pAdapter %x", pAdapter ) );

    
    do
    {
       
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // Mark the BCR so that so the adapter knows that the BCR is about to be freed
        //

        BCR_SET_FLAG (pAdapter, BCR_BCRNeedsToBeFreed);

        //
        // If a Make Call is pending, then set the Event so that the make call can complete.
        //
        if (BCR_TEST_FLAG (pAdapter,BCR_MakeCallPending)== TRUE)
        {

            pAdapter->BCRData.MakeCallWaitEvent.EventCode = nic1394EventCode_FreedAddressRange;   
            NdisSetEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent);
        }
        
        //
        //  If the BCM is in progress, let the BCM thread free the BCR instead
        //
        if (BCR_TEST_FLAG (pAdapter, BCR_BCMInProgress) == TRUE)
        {
            
            ADAPTER_RELEASE_LOCK (pAdapter);

            //
            // Wake up any pending threads - This wakes up an existing BCM thread that could 
            // be waiting for a new remote node
            //
            pAdapter->BCRData.BCRWaitForNewRemoteNode.EventCode = nic1394EventCode_FreedAddressRange;   
            NdisSetEvent (&pAdapter->BCRData.BCRWaitForNewRemoteNode.NdisEvent);


    
            TRACE( TL_N, TM_Bcm, ( "  nicFreeBroadcastChannelRegister BCM in progress or already freed, breaking out", pAdapter ) );
            break;

        }

        //
        // if the BCR is already freed, then simply exit. The event that the caller will wait
        // on BCRData.BCRFreeAddressRange.NdisEvent has already been set
        //
        if (BCR_TEST_FLAG (pAdapter, BCR_Freed) == TRUE)
        {
            ADAPTER_RELEASE_LOCK (pAdapter);
            break;
    
        }
        //
        // sanity check
        //
        ASSERT (BCR_TEST_FLAG (pAdapter,  BCR_BCRNeedsToBeFreed) == TRUE);
        //
        // Now update the flags
        //
        BCR_CLEAR_FLAG (pAdapter, BCR_Initialized | BCR_ChannelAllocated | BCR_BCRNeedsToBeFreed);

        //
        // clear all the BCR Valid bits
        //
        
        pAdapter->BCRData.IRM_BCR.NC_Valid = 0;
        pAdapter->BCRData.LocalHostBCRBigEndian  = BCR_IMPLEMENTED_LITTLE_ENDIAN;  //0x80000000

        if (pAdapter->BCRData.pAsyncWriteBCRMdl != NULL)
        {
            nicFreeMdl (pAdapter->BCRData.pAsyncWriteBCRMdl );
            pAdapter->BCRData.pAsyncWriteBCRMdl = NULL;
        }

        if (pAdapter->BCRData.pRemoteBCRMdl != NULL)
        {

            nicFreeMdl (pAdapter->BCRData.pRemoteBCRMdl);
            pAdapter->BCRData.pRemoteBCRMdl = NULL;
        }


        //
        // Temporary copy of the Address Range Context
        //
        BCRAddressRange = pAdapter->BCRData.AddressRangeContext;

        //
        // Zero out the Address Range Structure. This zeroes out AddressRangeContext.Mdl as well.
        // This is ok as BCRData.pLocalBCRMdl will be freed below and they both 
        // point to the same mdl.
        //
        NdisZeroMemory (
            &pAdapter->BCRData.AddressRangeContext, 
            sizeof (pAdapter->BCRData.AddressRangeContext));

        //
        // Clear out the VC. if any
        //
        if (pAdapter->BCRData.pBroadcastChanneVc != NULL)
        {
              nicDereferenceCall ((PVCCB) pAdapter->BCRData.pBroadcastChanneVc, "nicFreeBroadcastChannelRegister ");
              pAdapter->BCRData.pBroadcastChanneVc = NULL;
        }

        ADAPTER_RELEASE_LOCK (pAdapter);


        //
        // Free Address Range
        //
        if (BCRAddressRange.hAddressRange  != NULL)
        {
            nicFreeAddressRange (pAdapter,
                                 BCRAddressRange.AddressesReturned,
                                 &BCRAddressRange.AddressRange,
                                 &BCRAddressRange.hAddressRange      );
        }


        ADAPTER_ACQUIRE_LOCK (pAdapter);
        
        if (pAdapter->BCRData.pLocalBCRMdl != NULL)
        {
            nicFreeMdl (pAdapter->BCRData.pLocalBCRMdl);
            pAdapter->BCRData.pLocalBCRMdl = NULL;
        }

        
        //
        // Free the Adapter's BCRData. TopologyMap as that is locally allocated
        //
        if (pAdapter->BCRData.pTopologyMap)
        {
            FREE_NONPAGED (pAdapter->BCRData.pTopologyMap);
            pAdapter->BCRData.pTopologyMap = NULL;
        }

        // 
        // Clear the flags to force the BCR to be reintitalized
        //
        BCR_CLEAR_ALL_FLAGS(pAdapter);
        
        BCR_SET_FLAG (pAdapter, BCR_Freed);

        
        ADAPTER_RELEASE_LOCK (pAdapter);
        //
        // Set the Event and let the halt go through
        //
        
        pAdapter->BCRData.BCRFreeAddressRange.EventCode = nic1394EventCode_FreedAddressRange;
        NdisSetEvent (&pAdapter->BCRData.BCRFreeAddressRange.NdisEvent);

        

        TRACE( TL_N, TM_Bcm, ( "  nicFreeBroadcastChannelRegister BCM freed", pAdapter ) );

        
    } while (FALSE);

    TRACE( TL_T, TM_Bcm, ( "<== nicFreeBroadcastChannelRegister pAdapter %x", pAdapter ) );

    TIMESTAMP_EXIT ("<==Free BCR");

}




NDIS_STATUS
nicInformAllRemoteNodesOfBCM (
    IN PADAPTERCB pAdapter
    )


    // Function Description:
    //  This function will simply walk through the remote node list and write
    //  to the BCR of all the remote nodes
    //
    // Arguments
    //  pAdapter - Current local Host
    //  Channel - Channel used for broadcast
    //
    // Return Value:
    //
    //

{

    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PREMOTE_NODE        pRemoteNode = NULL;
    PLIST_ENTRY         pPdoListEntry = NULL;
    IO_ADDRESS          Destination;
    ULONG               IrmGeneration ;
    BOOLEAN             fLockAcquired = FALSE;
    NTSTATUS            NtStatus = STATUS_UNSUCCESSFUL;
    BOOLEAN             fReferencedCurrentRemoteNode = FALSE;
    PMDL                pAsyncWriteBCRMdl = NULL;
    
    TRACE( TL_T, TM_Bcm, ( "==> nicInformAllRemoteNodesOfBCM  pAdapter %x, Channel %x OldGeneration %x",
                             pAdapter, pAdapter->BCRData.LocalHostBCRBigEndian, pAdapter->BCRData.IrmGeneration ) );

    //
    // Set up the constants that will be used
    //
    Destination.IA_Destination_Offset.Off_Low = INITIAL_REGISTER_SPACE_LO | NETWORK_CHANNELS_LOCATION;
    Destination.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;

    
    //
    // Acquire the lock and walk the list of remote nodes
    //
    
    ADAPTER_ACQUIRE_LOCK (pAdapter);

    //
    // Do one last check on LocalHostBCRBigEndian  to ensure that no reset has cleared the bus
    //

    if ( (pAdapter->BCRData.LocalHostBCRBigEndian & BCR_VALID_BIG_ENDIAN) != BCR_VALID_BIG_ENDIAN)
    {
        //
        // Do not write an invalid bcr to remote nodes
        //
        ASSERT ((ADAPTER_TEST_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) == TRUE)  ||
                 (BCR_TEST_FLAGS (pAdapter, BCR_Freed | BCR_BCRNeedsToBeFreed )== TRUE) );

        ADAPTER_RELEASE_LOCK (pAdapter);

        return NIC1394_STATUS_INVALID_GENERATION;
    }

    pAsyncWriteBCRMdl = pAdapter->BCRData.pAsyncWriteBCRMdl;

    fLockAcquired = TRUE;

    IrmGeneration = pAdapter->BCRData.IrmGeneration;
    
    pPdoListEntry = pAdapter->PDOList.Flink ;

    //
    // Now start the actual informing the remote nodes- asyncwrite algorithm
    //

    //
    // Since the loop can be broken in the middle of the while loop. the code
    // keeps track of lock acquire/release state
    //
    
    while (pPdoListEntry != &pAdapter->PDOList )
    {
        
        pRemoteNode = CONTAINING_RECORD (pPdoListEntry,
                                            REMOTE_NODE,
                                            linkPdo);

        //
        //Ref the remote node for the Asnyc Operation. 
        // In case of failure, Dereference happens at the end of the function
        //
        nicReferenceRemoteNode (pRemoteNode, InformAllRemoteNodesOfBCM);

        fReferencedCurrentRemoteNode = TRUE;

        ADAPTER_RELEASE_LOCK (pAdapter);

        fLockAcquired = FALSE;

        
        //
        // First check if we are still in the same generation. 
        //
        if (pAdapter->Generation != IrmGeneration)
        {
            NdisStatus = NIC1394_STATUS_INVALID_GENERATION;
            TRACE( TL_T, TM_Bcm, ( "  nicInformAllRemoteNodesOfBCM  Generation Incorrect New Gen %x, Old Gen  ",
                                      pAdapter->Generation , IrmGeneration));
            break;

        }

        if (ADAPTER_TEST_FLAG(pAdapter, fADAPTER_LowPowerState) == TRUE)
        {
            //
            // As all BCMalgorithms are serialized and as Set Low Power State waits for BCM_InProgress
            // to be cleared, we should not hit this assert.
            //
            ASSERT (ADAPTER_TEST_FLAG(pAdapter, fADAPTER_LowPowerState) == FALSE);
            break;
        }

        
        TRACE( TL_V, TM_Bcm, ( "   BCR %x, Mdl  %x, IrmGeneration %x" ,
                                pAdapter->BCRData.LocalHostBCRBigEndian, 
                                pAsyncWriteBCRMdl, 
                                IrmGeneration ) );
        

        NdisStatus = nicAsyncWrite_Synch( pRemoteNode,
                                          Destination,     // Address to write to
                                          sizeof(NETWORK_CHANNELSR),  // Bytes to write
                                          sizeof(NETWORK_CHANNELSR),             // Block size of write
                                          0 , //fulFlags,               // Flags pertinent to write
                                          pAsyncWriteBCRMdl ,                    // Destination buffer
                                          IrmGeneration ,           // Generation as known by driver
                                          &NtStatus);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // Break out if the generation has changed or there are no more nodes left
            //
            if (NtStatus == STATUS_INVALID_GENERATION ||
               BCR_TEST_FLAG (pAdapter, BCR_LastNodeRemoved) )
            {
                TRACE( TL_V, TM_Bcm, ( "  nicAsyncWrite_Synch FAILED Status %x. Aborting ", NtStatus) );

                nicBCMAbort (pAdapter, pRemoteNode);
                
                break;
            }

        }
        

        ADAPTER_ACQUIRE_LOCK (pAdapter);


        fLockAcquired = TRUE;
        //
        // If the irps succeed and then the deref happens , else it happens below
        //
        pPdoListEntry = ListNext (pPdoListEntry);
        nicDereferenceRemoteNode (pRemoteNode , InformAllRemoteNodesOfBCM );
        fReferencedCurrentRemoteNode  = FALSE;
        
    
    }   // end of while loop while (pPdoListEntry != &pAdapter->PDOList )

    //
    // Clear the Informing remote nodes flag and release the lock
    //
    if (fLockAcquired == FALSE)
    {   
        ADAPTER_ACQUIRE_LOCK (pAdapter);
    }

    BCR_CLEAR_FLAG (pAdapter, BCR_InformingRemoteNodes);

    ADAPTER_RELEASE_LOCK (pAdapter);
    
    //
    // Dereference the ref made in the beginning of the function
    //
    if (fReferencedCurrentRemoteNode == TRUE)
    {
        nicDereferenceRemoteNode (pRemoteNode , InformAllRemoteNodesOfBCM );
    }


    TRACE( TL_T, TM_Bcm, ( "<== nicInformAllRemoteNodesOfBCM  (always returns success) Status %x", NdisStatus ) );

    NdisStatus = NDIS_STATUS_SUCCESS; // No failure
    return NdisStatus;
}





NDIS_STATUS
nicInitializeBroadcastChannelRegister (
    PADAPTERCB pAdapter
    )
    
    // Function Description:
    //   This function allocates address range for the BCR with its own MDL and data.
    //   Allocates an MDL for the time when we try to read other node's  BCR
    //   Initializes the IRM_BCR
    //
    //  The Caller is expected to free the BCR in case this function fails.
    //
    // Return Value:
    //   Succss - if the IRP succeeds
    //
    //
    //

{

    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PULONG              pBCRBuffer = NULL;
    PMDL                pBCRMdl = NULL;
    ADDRESS_OFFSET      Required1394Offset;
    ULONG               AddressesReturned;
    ADDRESS_RANGE       BCRAddressRange;
    HANDLE              hAddressRange;
    ULONG               LocalNodeNumber;
    PMDL                pRemoteBCRMdl = NULL;
    PMDL                pAsyncWriteBCRMdl = NULL;


    TRACE( TL_T, TM_Bcm, ( "==>nicInitializeBroadcastChannelRegister Adapter %x" , pAdapter ) );
    do
    {  
    
        BCR_CLEAR_ALL_FLAGS (pAdapter);
    
        //
        //Initialize the Local Host's BCR
        //
        pAdapter->BCRData.LocalHostBCRBigEndian = BCR_IMPLEMENTED_BIG_ENDIAN;

        //
        // Get an MDL that describes this buffer
        //
        if (pAdapter->BCRData.pLocalBCRMdl == NULL)
        {
            NdisStatus = nicGetMdl (sizeof(NETWORK_CHANNELSR),
                                   &pAdapter->BCRData.LocalHostBCRBigEndian,
                                   &pBCRMdl )   ;   
            
            
            if (pBCRMdl == NULL)
            {
                TRACE( TL_A, TM_Bcm, ( "   nicInitializeBroadcastChannelRegister IoAllocateMdl  FAILED" ) );

                NdisStatus = NDIS_STATUS_RESOURCES;

                break;
            }
        }
        else
        {
            //
            // We already have an MDL
            //
             pBCRMdl    = pAdapter->BCRData.pLocalBCRMdl;   
         }

        
        //
        // Allocate an Address Range at the BCR offset and use the MDL as its descriptor
        //
        TRACE( TL_V, TM_Bcm, ( "   LocalHostBCR Mdl %x", pBCRMdl ) );

        Required1394Offset.Off_Low = INITIAL_REGISTER_SPACE_LO | NETWORK_CHANNELS_LOCATION;
        Required1394Offset.Off_High = INITIAL_REGISTER_SPACE_HI ;


        pAdapter->BCRData.AddressRangeContext.pMdl = pBCRMdl ;
        
        //
        // There is no reference for this address range. The last outgoing Remote Node will simply Free it.
        //
        NdisStatus = nicAllocateAddressRange_Synch ( pAdapter,
                                                     pBCRMdl,
                                                     0, // Little Endian
                                                     sizeof (ULONG), // length
                                                     0, // maxsegmentsize
                                                     ACCESS_FLAGS_TYPE_READ | ACCESS_FLAGS_TYPE_WRITE | ACCESS_FLAGS_TYPE_LOCK | ACCESS_FLAGS_TYPE_BROADCAST,
                                                     NOTIFY_FLAGS_AFTER_READ | NOTIFY_FLAGS_AFTER_WRITE | NOTIFY_FLAGS_AFTER_LOCK ,
                                                     nicBCRAccessedCallback,
                                                     (PVOID)pAdapter,
                                                     Required1394Offset,
                                                     NULL,
                                                     NULL,
                                                     &AddressesReturned,
                                                     &BCRAddressRange,
                                                     &hAddressRange
                                                     );
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Bcm, ( "   nicInitializeBroadcastChannelRegister  nicAllocateAddressRange_Synch  FAILED" ) );
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
            break;
            
        }

        
        TRACE( TL_V, TM_Bcm, ( "   nicInitializeBroadcastChannelRegister  nicAllocateAddressRange_Synch  Succeeded" ) );
        TRACE( TL_V, TM_Bcm, ( "   &BCR Address Range  %x, AddressesReturned %x, hAddressRange %x",
                                   &BCRAddressRange, AddressesReturned, hAddressRange) );

        
        NdisStatus = nicGetMdl (sizeof(NETWORK_CHANNELSR),
                              &pAdapter->BCRData.RemoteBCRMdlData,
                              &pRemoteBCRMdl);

        if (NdisStatus != NDIS_STATUS_SUCCESS || pRemoteBCRMdl == NULL)
        {
            TRACE( TL_V, TM_Bcm, ( "   nicInitializeBroadcastChannelRegister :  nicGetMdl FAILED " ) );
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
            break;
        }

        NdisStatus = nicGetMdl ( sizeof (pAdapter->BCRData.AsyncWriteBCRBigEndian),
                                  &pAdapter->BCRData.AsyncWriteBCRBigEndian,
                                  &pAsyncWriteBCRMdl );

        if (NdisStatus != NDIS_STATUS_SUCCESS || pAsyncWriteBCRMdl == NULL)
        {
            TRACE( TL_V, TM_Bcm, ( "   nicInitializeBroadcastChannelRegister :  nicGetMdl FAILED " ) );
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
            break;
        }

        ADAPTER_ACQUIRE_LOCK (pAdapter);
        pAdapter->BCRData.AddressRangeContext.AddressRange = BCRAddressRange;
        pAdapter->BCRData.AddressRangeContext.AddressesReturned = AddressesReturned;
        pAdapter->BCRData.AddressRangeContext.hAddressRange = hAddressRange;
        pAdapter->BCRData.pLocalBCRMdl = pBCRMdl;  // points to the same MDL as pAdapter->BCRData.AddressRangeContext.pMdl
        pAdapter->BCRData.pRemoteBCRMdl = pRemoteBCRMdl;
        pAdapter->BCRData.pAsyncWriteBCRMdl = pAsyncWriteBCRMdl ;                 
        pAdapter->BCRData.IRM_BCR.NC_One = 1;
        pAdapter->BCRData.MakeCallWaitEvent.EventCode = Nic1394EventCode_InvalidEventCode;
        NdisResetEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent);

        BCR_SET_FLAG (pAdapter, BCR_Initialized);

        ADAPTER_RELEASE_LOCK (pAdapter);
        
    } while (FALSE);
    
    TRACE( TL_T, TM_Bcm, ( "<==nicInitializeBroadcastChannelRegister %x", NdisStatus ) );

    return NdisStatus;
}



NDIS_STATUS
nicIsLocalHostTheIrm(
    IN PADAPTERCB pAdapter,
    OUT PBOOLEAN pfIsLocalHostIrm,
    OUT PPTOPOLOGY_MAP  ppTopologyMap,
    OUT PNODE_ADDRESS pLocalHostAddress
    )
    // Function Description:
    //   This function figures out if the Local Host is the IRM.
    //   If a remote node is specified, it will use that Node, otherwise
    //   it will pick one from the adapter
    //   It gets the 1394 address, and the topologyMap. It then figures out
    //   if the local host's node address makes it the IRM
    //
    // Arguments
    //
    //  pAdapter   - Local Host,
    //  pfIsLocalHostIrm, - TRUE if Local Host Is IRM, False - otherwise
    //  ppTopologyMap, - TopologyMap used to determine if this is the IRM
    //  pLocalHostAddress  - LocalHost Address discovered by querying the local host
    //
    //
    // Return Value:
    //
    //
    //
    //
{
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PVOID               pTopologyBuffer = NULL; 
    PREMOTE_NODE        pRemoteNode = NULL;
    NODE_ADDRESS        LocalNodeAddress;
    PTOPOLOGY_MAP       pTopologyMap = NULL;
    PTOPOLOGY_MAP       pOldTopologyMap = NULL;
    ULONG               Length = DEFAULT_TOPOLOGY_MAP_LENGTH;

    
    TRACE( TL_T, TM_Bcm, ( "==>nicIsLocalHostTheIrm  ") );

    ASSERT (pfIsLocalHostIrm != NULL);

    ASSERT (ppTopologyMap!=NULL);

    ASSERT (pLocalHostAddress != NULL);

    do
    {



        //
        // get the address of the local node/
        //
        NdisStatus = nicGet1394AddressFromDeviceObject( pAdapter->pNextDeviceObject,
                                                        &LocalNodeAddress,
                                                        USE_LOCAL_NODE );
        if (NDIS_STATUS_SUCCESS != NdisStatus)
        {
            BREAK( TM_Bcm, ( "GetAddrFrom DevObj (Local) FAILED" ) );
        }

        TRACE ( TL_I, TM_Bcm, (  "   NODE_ADDRESS  Node Address %x, Number %x",LocalNodeAddress, LocalNodeAddress.NA_Node_Number ) );

        ASSERT (LocalNodeAddress.NA_Bus_Number == 0x3ff);
        //
        // Now we get the TopologyMap to find out if LocalHostIsIrm. We could fail the 1st Irp because our buffer is not
        // big enough, hence the do .. while loop
        //
        do
        {
    
            pTopologyBuffer = ALLOC_NONPAGED (Length , MTAG_DEFAULT);

            if (pTopologyBuffer ==NULL)
            {
                NdisStatus = NDIS_STATUS_RESOURCES; 
                break;
            }


            NdisStatus = nicGetLocalHostCSRTopologyMap (pAdapter,
                                                       &Length,
                                                       pTopologyBuffer );                       

            if (NdisStatus == NDIS_STATUS_INVALID_LENGTH)
            {
                FREE_NONPAGED(pTopologyBuffer);
            }

        } while (NdisStatus == NDIS_STATUS_INVALID_LENGTH);

        TRACE ( TL_V, TM_Bcm, ( "  TopologyBuffer %x",pTopologyBuffer) );

        pTopologyMap = (PTOPOLOGY_MAP)pTopologyBuffer;

        TRACE( TL_I, TM_Bcm, ( "    Top node count = %x ", pTopologyMap->TOP_Node_Count) );

    } while (FALSE);
    

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        //
        // Now update all the output parameters. The Top_Node_count can be zero.
        //
        if ( LocalNodeAddress.NA_Node_Number == (pTopologyMap->TOP_Node_Count -1 ) ||
            pTopologyMap->TOP_Node_Count == 0)
        {
            *pfIsLocalHostIrm = TRUE;
            BCR_SET_FLAG (pAdapter, BCR_LocalHostIsIRM);
        }
        else
        {
            *pfIsLocalHostIrm = FALSE;
        }

        //
        // If there is a topology map in the pointer, then it means that the topology map from
        // the previous query. Free it first.
        //
        if ( *ppTopologyMap != NULL)
        {
            FREE_NONPAGED(*ppTopologyMap);
        }

        *ppTopologyMap = pTopologyMap;

        *pLocalHostAddress = LocalNodeAddress;
    }
    
    TRACE( TL_T, TM_Bcm, ( "<==nicIsLocalHostTheIrm  %x   NdisStatus %x",*pfIsLocalHostIrm , NdisStatus ) );

    return NdisStatus;
}



NDIS_STATUS
nicLocalHostIsIrm(
    IN PADAPTERCB pAdapter
    )
    // Function Description:
    //
    //
    //
    //
    // Arguments
    //  pAdapter - Local adapter object
    //  pRemoteNode - Node to be used for submitting IRPs to the Busdriver
    //
    //
    // Return Value:
    //
    //
    //
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    ULONG       Channel = BROADCAST_CHANNEL;
    ULONG       TimeOut = 5;
    ULONG       LocalHostBCRLittleEndian;
    ULONG       WaitBackOff = ONE_SEC;
    

    TRACE( TL_T, TM_Bcm, ( "==>nicLocalHostIsIrm Adapter %x ", pAdapter) );


    //
    // Allocate BCM channel = 31
    //
    Channel = BROADCAST_CHANNEL;    

    do
    {
        //
        // If the channel is already allocated. Do not try and reallocate it.
        //

        if (BCR_TEST_FLAG(pAdapter,BCR_ChannelAllocated) == TRUE)
        {
            ASSERT (pAdapter->BCRData.IRM_BCR.NC_Channel == Channel);
            NdisStatus = NDIS_STATUS_SUCCESS;
            break;
        }
        

        //
        // Retry a 5 times to allocate the channel
        //
        while (NdisStatus != NDIS_STATUS_SUCCESS && TimeOut-- != 0 )
        {
            NdisStatus = nicAllocateChannel (pAdapter,
                                             Channel,
                                             NULL);

            if (NdisStatus != NDIS_STATUS_SUCCESS )
            {
                TRACE( TL_V, TM_Bcm, ( "  nicNodeIsIRMAlgorithm: nicallocateChannel Failed. Sleep and try again") );


                if (BCR_TEST_FLAG (pAdapter, BCR_BCRNeedsToBeFreed |BCR_NewNodeArrived) == TRUE ||
                  ADAPTER_TEST_FLAG (pAdapter,fADAPTER_InvalidGenerationCount) == TRUE)
                {
                    break;
                }
                //
                // Sleep for 1 Sec and try again.
                //
                NdisMSleep (WaitBackOff);
                WaitBackOff  = WaitBackOff << 1;
                //
                // Someother node has alredy asked for the BroadcastChannel .Force it out.
                // Eventually will need to allocate a new channel.
                //
                
            }
        }       

    } while (FALSE);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {

        //
        // Update our BCR and inform all the remote Nodes
        //
        TRACE( TL_V, TM_Bcm, ( "  nicLocalHostIsIrm: nicallocateChannel succeeded  %x", Channel) );
        ASSERT (Channel == BROADCAST_CHANNEL);

        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // Update State - if no reset has occurred
        //
        if (ADAPTER_TEST_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) == FALSE)
        {
            BCR_SET_FLAG (pAdapter, BCR_ChannelAllocated);
            BCR_SET_FLAG (pAdapter, BCR_InformingRemoteNodes);

            pAdapter->BCRData.IrmGeneration = pAdapter->Generation;


            pAdapter->BCRData.LocalHostBCRBigEndian = 0;
            NdisZeroMemory (&pAdapter->BCRData.IRM_BCR, sizeof (NETWORK_CHANNELSR) );

            //
            // Update the BCR
            //
                        
            pAdapter->BCRData.IRM_BCR.NC_Channel = Channel;           // bits 0-5
            pAdapter->BCRData.IRM_BCR.NC_Valid = 1;             // bit  30
            pAdapter->BCRData.IRM_BCR.NC_One = 1;               // bit  31

            pAdapter->BCRData.LocallyAllocatedChannel = Channel;
        }
        else
        {
            TRACE( TL_V, TM_Bcm, ( "  nicLocalHostIsIrm: Reset after nicallocateChannel succeeded  %x", Channel) );
            
            pAdapter->BCRData.IRM_BCR.NC_Valid = 0;             // bit  30

        }
        
        TRACE( TL_V, TM_Bcm, ( "  nicLocalHostIsIrm: IRM_BCR Updated to %x ",pAdapter->BCRData.IRM_BCR) );

        //
        // Now convert LocalHost BCR so it can be read over the network
        //

        pAdapter->BCRData.LocalHostBCRBigEndian = SWAPBYTES_ULONG (*(PULONG)(&pAdapter->BCRData.IRM_BCR));

        TRACE( TL_V, TM_Bcm, ( "  nicLocalHostIsIrm: LocalHost BCR Updated to %x ",pAdapter->BCRData.LocalHostBCRBigEndian ) );

        //
        // Capture the value so that we can async write it to other nodes in the network.
        // this will protect us from a Reset that can clear LocalHostBCRBigEndian
        //
        pAdapter->BCRData.AsyncWriteBCRBigEndian = pAdapter->BCRData.LocalHostBCRBigEndian; 

        ADAPTER_RELEASE_LOCK (pAdapter);

        if ((pAdapter->BCRData.LocalHostBCRBigEndian & BCR_VALID_BIG_ENDIAN) == (BCR_VALID_BIG_ENDIAN))             
        {
            //
            // Tell all the other nodes about the BCM and the channel.
            // This will abort the process if a reset happenned just prior
            //  to the channel allocation.
            //
            
            nicInformAllRemoteNodesOfBCM (pAdapter);
        }
    
    }
    else
    {
        TRACE( TL_A, TM_Bcm, ( "  nicLocalHostIsIrm - Failed RESET THE BUS") );

        NIC1394_LOG_PKT(pAdapter,
                        NIC1394_LOGFLAGS_BCM_IS_IRM_TIMEOUT,
                        pAdapter->Generation,
                        0,
                        &NdisStatus,
                        sizeof (NDIS_STATUS));

        //
        // If the generation is invalid or we need to bail out of the BCM for some reason,
        // then simply exit. Otherwise reset the bus
        //
        if (! (BCR_TEST_FLAG (pAdapter, BCR_BCRNeedsToBeFreed |BCR_NewNodeArrived) == TRUE ||
                  ADAPTER_TEST_FLAG (pAdapter,fADAPTER_InvalidGenerationCount) == TRUE) )
        {
            nicBCMReset(pAdapter);
        }

    }
    
    TRACE( TL_T, TM_Bcm, ( "<==nicLocalHostIsIrm%x  ",NdisStatus ) );
    
    return NdisStatus;
}



NDIS_STATUS
nicLocalHostIsNotIrm (
    IN PADAPTERCB pAdapter,
    IN ULONG BCMGeneration
    )
    // Function Description:
    //   This function goes through all the remote nodes
    //   and attempts to read their broadcast channels register
    //   If the Read itself fails - means the IRM does not implement the BCR - we issue a  reset
    //   If the generation is wrong - means the bus has been reset and we need to abort
    //   If the read succeeds, but BCR's MSB is not set - we issue a reset
    //
    //   If the read succeeds and valid bit is not set, we retry for 5 min. waiting for the Valid bit
    //      This involves i) attempt to read the (IRM) remote Node's BCR
    //                    If Read does not find a BCR,
    //                      Sleep
    //                      Check to see if RemoteNode Has written to Our BCR
    //                      If RemoteNode has NOT written to our BCR, then go back to i)
    //                  
    //
    //   This function can be optimized into a do while loop. However for
    //   the sake of simplicity and blindly following the BCM algorithm, it is
    //   spread out.
    //
    // Arguments
    //
    //
    //
    // Return Value:
    //
    //
    //
    //
{
    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    PLIST_ENTRY             pPdoListEntry = NULL;
    PREMOTE_NODE            pIrmRemoteNode = NULL;
    PMDL                    pRemoteBCRMdl = NULL;
    ULONG                   Generation;
    BOOLEAN                 fRemoteNodeBCRIsValid  = FALSE;
    BOOLEAN                 fNeedToReset = FALSE;
    BOOLEAN                 fDidTheBusReset = FALSE;
    BOOLEAN                 fExit = FALSE;
    ULONG                   TimeOut;
    ULONG                   LocalHostBCRLittleEndian , RemoteNodeBCRLittleEndian;
    NETWORK_CHANNELSR*      pBCR = NULL;
    BOOLEAN                 fLocalHostBCRIsValid  = FALSE;
    ULONG                   BackOffWait = ONE_SEC;

    TRACE( TL_T, TM_Bcm, ( "==>nicLocalHostIsNotIrm " ) );

    ASSERT (pAdapter->BCRData.pTopologyMap != NULL);

    do
    {
        //
        // First do the wait - BCM algorithm requires this
        //
        pBCR = (NETWORK_CHANNELSR*)(&LocalHostBCRLittleEndian) ;

        NdisStatus = nicLocalNotIrmMandatoryWait (pAdapter,
                                             BCMGeneration,
                                             pBCR);

        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            fLocalHostBCRIsValid = TRUE;

            TRACE( TL_V, TM_Bcm, ( "   BCR written to during Mandatory Wait ") );

            break;
        }
        else
        {
            fLocalHostBCRIsValid = FALSE;
        }

        //
        // Initialize variables again and move on
        //
        pBCR = NULL;
        LocalHostBCRLittleEndian  = 0;
        
        //
        // Our BCR has not been updated. Lets go and find the IRM's BCR. we will loop until we
        // i)either find the IRM,  ii)timeout and then reset, or iii)find a new generation and abort
        //
        //
        NdisStatus = nicFindIrmAmongRemoteNodes (pAdapter, BCMGeneration, &pIrmRemoteNode);

        if (NdisStatus != NDIS_STATUS_SUCCESS  )
        {
                //
                // If there is NO IRM , it means we have not been notified of its addition.
                //
                TRACE( TL_V, TM_Bcm, ( "   nicLocalHostIsNotIrm :  nicFindIrmAmongRemoteNodes FAILED " ) );
                //
                // One of two things can have caused this:
                //  1. the bus has been reset - break out
                //  2. we have not been notified of a new node - exit
                //
                if (NdisStatus == NIC1394_STATUS_INVALID_GENERATION)
                {
                    TRACE( TL_V, TM_Bcm, ( "   Invalid Generation, the bus has been reset ") );

                    NdisStatus = NtStatusToNdisStatus(NIC1394_STATUS_INVALID_GENERATION);
                    break;
                }

                //
                // We have not been able to find the IRM and have timed out.  
                // If the BCR is not freed, then abort and Reset
                //
                if (BCR_TEST_FLAGS (pAdapter, (BCR_Freed | BCR_BCRNeedsToBeFreed) == FALSE))
                {
                    TRACE( TL_I, TM_Bcm, ( "   nicLocalHostIsNotIrm -  Could Not Find IRM RESETTING ") );
                    fNeedToReset = TRUE;
                }
                break;
        }

        ASSERT (pIrmRemoteNode != NULL)

        //
        // We will now wait for the BCM to come up and initialize its BCR.
        // We will attempt to read it 5 times
        //
        pRemoteBCRMdl = pAdapter->BCRData.pRemoteBCRMdl;

        pAdapter->BCRData.RemoteBCRMdlData = 0;

        TimeOut = 5;  // arbitrary


        while (TimeOut-- != 0 )
        {       
            NdisStatus = nicReadIrmBcr ( pIrmRemoteNode,
                                         pRemoteBCRMdl,
                                         BCMGeneration,
                                         &fDidTheBusReset);

            //
            // First check to see if no reset has happenned while we were reading the BCR
            //

            if ( fDidTheBusReset == TRUE ||
                 (ADAPTER_TEST_FLAG (pAdapter, fADAPTER_InvalidGenerationCount) == TRUE))
            {
                //
                // A reset has gone through under us or the IRM has gone.
                // We need to abort this round of the BCM process
                //
                TRACE( TL_V, TM_Bcm, ( "  nicLocalHostIsNotIrm : nicReadIrmBcr FAILED Invalid generation ") );

                NdisStatus = NDIS_STATUS_FAILURE;
                break;
            }
            
           
            //
            // Now check for Success and see if the BCR is implemented by the IRM
            //

            if (NdisStatus == NDIS_STATUS_SUCCESS )
            {

                TRACE( TL_V, TM_Bcm, ( "  BCR is %x ", pAdapter->BCRData.RemoteBCRMdlData ) );

                //
                // At this point we have a guarantee that nicReadIrmBcr succeeded. If the IRM does not implement the BCR
                // at all, there is no point in retrying, reset the bus and become the IRM
                //

                RemoteNodeBCRLittleEndian  = SWAPBYTES_ULONG (pAdapter->BCRData.RemoteBCRMdlData);

                pBCR  = (NETWORK_CHANNELSR*)(&RemoteNodeBCRLittleEndian );
                
                if ( IS_A_BCR (pBCR) == FALSE && NdisStatus == NDIS_STATUS_SUCCESS)
                {
                    fNeedToReset = TRUE;
                    TRACE( TL_I, TM_Bcm, ( "  nicLocalHostIsNotIrm : IRM does not implement the BCR %x RESETTING",RemoteNodeBCRLittleEndian ) );
                    break;

                }

                //
                // The remote node implements the BCR, so now lets see if it has set up the broadcast channel by looking
                //  at the valid bit.
                //
                if (BCR_IS_VALID (pBCR) ==TRUE)
                {
                    //
                    // We've succeeded and have received a Broadcast Channel. Update data structures and exit.
                    //
                    ULONG BCMCh;
                    
                    fRemoteNodeBCRIsValid = TRUE;

                    BCMCh = pBCR->NC_Channel;

                    TRACE( TL_V, TM_Bcm, ( "   BCM Channel  %x ", BCMCh  ) );

                    break;

                }
                //
                // At this point we know that the IRM implements the BCR but has not set its valid bit yet.
                // Lets sleep and give it som more time
                //
                pBCR = NULL;
                RemoteNodeBCRLittleEndian  = 0;
            }


            //
            // Check to see if the Remote Node PDO is valid 
            //
            if (REMOTE_NODE_TEST_FLAG(pIrmRemoteNode, PDO_Removed) )
            {
                fNeedToReset = TRUE;
                fExit = TRUE;
            }
            //
            // Remote Node's BCR  is not up yet
            // We need to sleep and retry to read the IRM's BCR in the 
            // hope that it will have allocated the
            // broadcast channel by the time we read the register again.
            //
            NdisMSleep (BackOffWait);           
            BackOffWait = BackOffWait << 1;

            
            ADAPTER_ACQUIRE_LOCK (pAdapter);

            if (BCR_TEST_FLAG (pAdapter, BCR_BCRNeedsToBeFreed) == FALSE )
            {
                LocalHostBCRLittleEndian  = SWAPBYTES_ULONG (pAdapter->BCRData.LocalHostBCRBigEndian);
            }
            else
            {
                fExit = TRUE;
            }
            ADAPTER_RELEASE_LOCK (pAdapter);

            

            //
            // As Address range has been freed or the Remote Node is going away
            // quietly exit the BCM algorithm
            //
            if (fExit== TRUE)
            {
                break;
            }

            //
            // Let's read our own BCR and see if someone has written a valid BCR to it.
            // Another thread will write to the LocalHost BCR
            //

            pBCR = (NETWORK_CHANNELSR*)(&LocalHostBCRLittleEndian);

            //
            // Check if the BCR is valid and that no reset has come through the in the Interim.
            // The reset would have cleared the BCR_localHostBCRUpdated field
            //
            if ( BCR_IS_VALID (pBCR) == TRUE && 
                ( BCR_TEST_FLAGS (pAdapter, BCR_LocalHostBCRUpdated  ) == TRUE))
            {
                //
                // We've succeeded. Update data structures and exit.
                // The actual IRM BCR will have been updated in the BCRAccessed thread
                // so we simply exit
                //
                ULONG BCMCh = pBCR->NC_Channel;

                TRACE( TL_V, TM_Bcm, ( "   BCM Channel  After Backoff Wait%x ", BCMCh  ) );

                NdisStatus  = NDIS_STATUS_SUCCESS;

                fLocalHostBCRIsValid = TRUE;
                fRemoteNodeBCRIsValid = FALSE;

                break;
            }

            if (TimeOut == 0)
            {
                //
                // We've waited, retried 5 times. The IRM has not implemented the BCM
                // We need to wrest control by resetting the bus
                //
                // This happens when the remote node is still booting up.
                //
                TRACE( TL_I, TM_Bcm, ( "   nicLocalHostIsNotIrm - TIMEOUT  RESETTING") );

                fNeedToReset = TRUE;
                
            }
            
            LocalHostBCRLittleEndian   = 0;
            pBCR = NULL;


        } //while (Timeout-- != 0 )
        
    } while (FALSE);

    //
    // Now do the clean up work and updating of data structures that needs to be done at the end of the BCM
    // algorithm
    //
    nicLocalHostIsNotIrmPost (pAdapter,
                          pIrmRemoteNode,
                          fNeedToReset,
                          fRemoteNodeBCRIsValid ,
                          fLocalHostBCRIsValid ,
                          fDidTheBusReset,
                          pBCR  );

    //
    // If the IRM was successfuly found, then it was referenced as well.  We dereference it now
    // Ref was made in FindIRmAmongstRemoteNode
    //
    if (pIrmRemoteNode != NULL)
    {
        nicDereferenceRemoteNode (pIrmRemoteNode, FindIrmAmongRemoteNodes);
    }

    TRACE( TL_T, TM_Bcm, ( "<==nicLocalHostIsNotIrm Status %x", NdisStatus ) );

    return NdisStatus;
 }




VOID
nicLocalHostIsNotIrmPost (
    PADAPTERCB pAdapter,
    PREMOTE_NODE pIrmRemoteNode,
    BOOLEAN fNeedToReset,
    BOOLEAN fRemoteNodeBCRIsValid ,
    BOOLEAN fLocalHostBCRIsValid ,
    BOOLEAN fDidTheBusReset,
    NETWORK_CHANNELSR*      pBCR
    )

/*++

Routine Description:
   This routine does the post processing after the Local Host Is Not Irm has completed.
   It i)resets the bus if necessary,  ii) Updates the BCR if pBCR has a valid Value
   The Boolean Variables passed in indicate the state of the BCM algorithm

Arguments:

    pAdapter - pAdapter in question,
    pIrmRemoteNode - RemoteNode that is the IRM,
    fNeedToReset - Does the bus need to be reset,
    fRemoteNodeBCRIsValid - Is the RemoteNodeBCR Valid ,
    fLocalHostBCRIsValid  - LocalHost BCR Valid,
    fDidTheBusReset - Did the bus reset during this iteration of the BCM algorithm,
    pBCR - the BCR that was passed in


Return Value:


--*/


{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
        
    TRACE( TL_T, TM_Bcm, ( "==> nicLocalHostIsNotIrmPost  pAdapter %x, pIrm %x, fNeedToReset%x, fRemoteNodeBCRIsValid %x, fLocalHostBCRIsValid %x, fDidTheBusReset,%x, pBCR %x",
                                pAdapter, pIrmRemoteNode, fNeedToReset, fRemoteNodeBCRIsValid , fLocalHostBCRIsValid, fDidTheBusReset, pBCR) );

    do
    {
        
        
        if (fRemoteNodeBCRIsValid == TRUE || fLocalHostBCRIsValid == TRUE)
        {
        
            //
            // The BCM algorithm has succeeded. We need to update our internal record of
            // the IRM's BCR. In both ocde (local and Remote) the pBCR points to the BCR in little
            // endian
            //
            ASSERT (fNeedToReset == FALSE);
            //
            // One final check
            //
            ASSERT (pBCR!= NULL);
            ASSERT (pBCR->NC_Valid  == 1);

            ADAPTER_ACQUIRE_LOCK (pAdapter);


            pAdapter->BCRData.IRM_BCR.NC_One = 1;
            pAdapter->BCRData.IRM_BCR.NC_Valid = 1;
            pAdapter->BCRData.IRM_BCR.NC_Channel =  pBCR->NC_Channel;


            ASSERT ( BCR_IS_VALID (&pAdapter->BCRData.IRM_BCR) == TRUE);

            TRACE( TL_V, TM_Bcm, ( "   Updated IRM_BCM with %x ",pAdapter->BCRData.IRM_BCR ) );

            ADAPTER_RELEASE_LOCK (pAdapter);

            ASSERT (fDidTheBusReset == FALSE);
            ASSERT (fNeedToReset == FALSE);
            break;
        }

        
        if ( fNeedToReset )
        {
            //
            // If our BCR's are invalid and the IRM has gone away
            // OR if there has been a timeout, we should reset the 
            // bus to force a new BCM 
            //
            BOOLEAN NoRemoteNodes = IsListEmpty(&pAdapter->PDOList) ;

            //
            // Reset only if there are remote nodes present
            //
            if (NoRemoteNodes == FALSE)
            {
                TRACE( TL_V, TM_Bcm, ("fNeedToReset %x, RemoteNode %p\n",fNeedToReset,pIrmRemoteNode));                    
                
                nicBCMReset( pAdapter);
            }

            

            ASSERT (fRemoteNodeBCRIsValid == FALSE);
            ASSERT (fDidTheBusReset == FALSE);
            break;
        }
        
    } while (FALSE);    



    TRACE( TL_T, TM_Bcm, ( "<== nicLocalHostIsNotIrmPost  ") );


}





NDIS_STATUS
nicLocalNotIrmMandatoryWait (
    IN PADAPTERCB pAdapter,
    IN ULONG BCMGeneration,
    OUT NETWORK_CHANNELSR* pBCR
    )
    // Function Description:
    //  This function implements the mandatory portion
    //  of the local host is not Irm protion of the BCM algorithm
    //
    //   Sleeps and expects that a IRM will have written to its BCR
    //   by the time it wakes up
    //
    // Arguments
    //   pAdapter
    //
    //
    // Return Value:
    //
    //
{
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    ULONG               HighestNode = pAdapter->BCRData.pTopologyMap->TOP_Node_Count-1;
    ULONG               LocalNodeNumber = pAdapter->BCRData.LocalNodeNumber;    
    ULONG               TimeOut = 0;
    ULONG               Generation;
    ULONG               LocalHostBCRLittleEndian  = 0;
    
    ASSERT (pBCR != NULL);
    
    TRACE( TL_T, TM_Bcm, ( "==> nicLocalNotIrmMandatoryWait pAdapter %x, HighNode %x, LocalNode %x, BCMGeneration %x",
                                pAdapter, HighestNode, LocalNodeNumber, BCMGeneration) );

    
    //
    // BCM algorithm states that node must wait 15ms * IRM_ID - candidate_ID
    //

    TimeOut = HighestNode - LocalNodeNumber;

    do
    {
        if (TimeOut > 64)
        {

            ASSERT (TimeOut <= 64);
            
            NdisStatus = NDIS_STATUS_FAILURE;

            break;
        }
        
        //
        // Store the generation as a reference point. The moment the bus is reset, the gen count
        // will increment and we will need to bail out of this round of the BCM process
        //
        
        
        if (BCMGeneration != pAdapter->Generation)
        {
            
            TRACE( TL_V, TM_Bcm, ( " nicLocalHostIsNotIrm : Generations do not match " ) );

            NdisStatus = NIC1394_STATUS_INVALID_GENERATION;
            
            break;
        }

        //
        // Sleep for 15ms * IRM_ID - CandidateNodeID
        //
        NdisMSleep (TimeOut * 15000);

        //
        // First let's read our own BCR and see if someone has written a valid BCR to it.
        //
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        LocalHostBCRLittleEndian = pAdapter->BCRData.LocalHostBCRBigEndian;

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Copy it over to what pBCR points to
        //
        LocalHostBCRLittleEndian = SWAPBYTES_ULONG (LocalHostBCRLittleEndian );

        *pBCR = (*(NETWORK_CHANNELSR*)&LocalHostBCRLittleEndian );

        if ( BCR_IS_VALID(pBCR)==TRUE)
        {
            //
            // We've succeeded. Update data structures and exit. Nothing for us
            // to do as the other thread updates everything
            //
            ULONG BCMChannel  = -1;
            NdisStatus = NDIS_STATUS_SUCCESS;
            
            BCMChannel = pBCR->NC_Channel;

            TRACE( TL_V, TM_Bcm, ( "   BCM Channel  %x ", BCMChannel  ) );
            TRACE( TL_V, TM_Bcm, ( "   BCR Is valid on LocalHost BCR", pAdapter->BCRData.LocalHostBCRBigEndian) );

            NdisStatus = NDIS_STATUS_SUCCESS;
            ASSERT (BCMChannel == 31);          
            break;
        }
        else
        {
            NdisStatus = NDIS_STATUS_FAILURE;
        }


    } while (FALSE);        



    TRACE( TL_T, TM_Bcm, ( "<== nicLocalNotIrmMandatoryWait Status %x , pBCR %x", NdisStatus, pBCR) );

    return NdisStatus;
}
    







NDIS_STATUS
nicReadIrmBcr (
    PREMOTE_NODE pIrmRemoteNode,
    IN PMDL pBCRMdl,
    IN ULONG GivenGeneration,
    OUT PBOOLEAN pfDidTheBusReset
    )
    // Function Description:
    //   Purpose is to do an async read on the IRM's BCR and see if it is set.
    // Arguments
    //   pIrmRemoteNode  - The remote node (IRM)
    //   pBCRMdl The MDL that will contain the remote node's BCR. Needs to preinitialized
    // Return Value:
    //  Success - If Irp succeeded. Appropriate Error code otherwise
    //   If the Generation is incorrect. the call will be failed
    //
    //


{
    NDIS_STATUS                         NdisStatus = NDIS_STATUS_FAILURE;
    IO_ADDRESS                          Destination;
    PNETWORK_CHANNELS                   pBCR = NULL;
    NTSTATUS                            NtStatus = STATUS_UNSUCCESSFUL;
    

    TRACE( TL_T, TM_Bcm, ( "==>nicReadIrmBcr  pIrm %x, pMdl %x, GivenGeneration %x",
                             pIrmRemoteNode, pBCRMdl, GivenGeneration) );

    ASSERT (pBCRMdl != NULL);
    ASSERT (pIrmRemoteNode != NULL);

    pBCR = NIC_GET_SYSTEM_ADDRESS_FOR_MDL(pBCRMdl);


    Destination.IA_Destination_Offset.Off_Low = INITIAL_REGISTER_SPACE_LO | NETWORK_CHANNELS_LOCATION;
    Destination.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;

    
    do 
    {
        if (pBCR == NULL)
        {
            break;
        }

        pBCR->NC_Valid = 0;


        if (pIrmRemoteNode->pAdapter->Generation != GivenGeneration)
        {
            
            TRACE( TL_A, TM_Bcm, ( "nicReadIrmBcr : Generation Mismatch orig %x, curr %x", GivenGeneration , pIrmRemoteNode->pAdapter->Generation) );
            
            NdisStatus = NDIS_STATUS_DEST_OUT_OF_ORDER;

            *pfDidTheBusReset = TRUE;

            break;
        }

        if (REMOTE_NODE_TEST_FLAG (pIrmRemoteNode, PDO_Removed))
        {
           NdisStatus = NDIS_STATUS_DEST_OUT_OF_ORDER;
           break;
        }
            

        //
        // We have a correct generation count
        //
        *pfDidTheBusReset = FALSE;  

        NdisStatus = nicAsyncRead_Synch(  pIrmRemoteNode,
                                          Destination,
                                          sizeof(NETWORK_CHANNELSR),  // Number of bytes to Read
                                          sizeof (NETWORK_CHANNELSR),  // Block Size
                                          0, // fulFlags,
                                          pBCRMdl ,
                                          GivenGeneration,
                                          &NtStatus);
                        

    } while (FALSE);

    if (NtStatus == STATUS_INVALID_GENERATION )
    {
        *pfDidTheBusReset = TRUE;
    }
    
    TRACE( TL_I, TM_Bcm, ( "   nicReadIrmBcr pBCRMdl %x, BCR %x ", pBCRMdl, *pBCR ) );

    TRACE( TL_T, TM_Bcm, ( "<==nicReadIrmBcr  Status %x, fDidTheBusReset %x", NdisStatus ,*pfDidTheBusReset ) );

    return NdisStatus;

}











NDIS_STATUS
nicScheduleBCMWorkItem(
    PADAPTERCB pAdapter
    )

/*++

Routine Description:
 This function queues a workitem to kick of the BCM algorithm.

 If there is already a BCM in progress, (look at BCM_WorkItem flag)
 it simply returns.

 It is the responsiblity of the caller to mark the invocation of BCMAlgorithm as
 dirty, thereby forcing it to restart the BCM (by setting the InvalidGeneration of the
 new Node Arrived Flags)

Arguments:
 pAdapter -     Adapter

Return Value:


--*/
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS_WORK_ITEM pBCMWorkItem;
    BOOLEAN fBCMWorkItemInProgress = FALSE;
    
    TRACE( TL_T, TM_Bcm, ( "==>nicScheduleBCMWorkItem pAdapter %x", pAdapter ) );

    do
    {
        if (BCR_TEST_FLAG(pAdapter, BCR_Initialized)== FALSE)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        pBCMWorkItem = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM);
                    
        if (pBCMWorkItem == NULL )
        {
            TRACE( TL_A, TM_Cm, ( "Local Alloc failed for WorkItem" ) );
    
            NdisStatus = NDIS_STATUS_RESOURCES;
    
            break;
        }
        else
        {   
            //
            // From here on, this function cannot fail.
            //
            NdisStatus = NDIS_STATUS_SUCCESS;
        }

        //
        // reference the adapter as it is going to passed to a workiter.
        // decremented in the workitem
        //
        nicReferenceAdapter(pAdapter, "nicScheduleBCMWorkItem ");


            
        NdisInitializeWorkItem ( pBCMWorkItem,
                                (NDIS_PROC) nicBCMAlgorithmWorkItem,
                                (PVOID) pAdapter);

        TRACE( TL_V, TM_Cm, ( "Scheduling BCM WorkItem" ) );

            
        NdisScheduleWorkItem (pBCMWorkItem);

            
    } while (FALSE);


    TRACE( TL_T, TM_Bcm, ( "<==nicScheduleBCMWorkItem %x  ", NdisStatus ) );

    return NdisStatus;
}


VOID
nicSetEventMakeCall (
    IN PADAPTERCB pAdapter
    )

    // Function Description:
    //  The Sets the event that a Broadcast channel Make Call might be waiting for
    //
    // Arguments
    // Adapter - this is passed to the workitem
    //
    //
    // Return Value:
    //  Failure if allocation of workitem failed
    //
{
    TRACE( TL_T, TM_Bcm, ( "==> nicSetEventMakeCall  pAdapter %x", pAdapter) );


    //
    // now inform a waiting channel Vc to move on. If the BCR is not active.
    // it will continue waiting till the next round
    //
    if (BCR_IS_VALID(&(pAdapter->BCRData.IRM_BCR))==TRUE)
    {
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        if (BCR_TEST_FLAG (pAdapter, BCR_MakeCallPending) == TRUE)
        {
            TRACE( TL_V, TM_Bcm, ( "    We found a waiting call ") );
            NdisSetEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent);            

        }
        else
        {
            TRACE( TL_V, TM_Bcm, ( "    No Call Waiting") );

        }

        ADAPTER_RELEASE_LOCK (pAdapter);


    }


    TRACE( TL_T, TM_Bcm, ( "<==nicSetEventMakeCall ") );


}



VOID
nicUpdateLocalHostNodeAddress (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:

    This function queries the Bus driver for the Local Node Address of 
    the Adapter 

    If the Node Address has changed, it updates the GaspHeader 
    

Arguments:

 pAdapter -     Adapter

Return Value:


--*/
{
    NODE_ADDRESS LocalNodeAddress, OldNodeAddress;
    NDIS_STATUS NdisStatus;

    OldNodeAddress = pAdapter->NodeAddress;

    NdisStatus = nicGet1394AddressFromDeviceObject( pAdapter->pNextDeviceObject,
                                                &LocalNodeAddress,
                                                USE_LOCAL_NODE );

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        pAdapter->NodeAddress = LocalNodeAddress;

        // If the Node Address has changed , then update the GaspHeader
        //
        if (FALSE == NdisEqualMemory (&LocalNodeAddress,&OldNodeAddress, sizeof(NODE_ADDRESS) ) )
        {
            nicMakeGaspHeader (pAdapter, &pAdapter->GaspHeader);
        }

    }

    


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\ccdefs.h ===
//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// The NDIS version we report when registering mini-port and address family.
//
#define NDIS_MajorVersion 5
#define NDIS_MinorVersion 0
#define NIC1394_MajorVersion 5
#define NIC1394_MinorVersion 1

#define MAX_PACKET_POOL_SIZE 0xFFFF
#define MIN_PACKET_POOL_SIZE 0x100

#define NOT !
#define IS ==
#define AND &&
#define OR ||
#define NOT_EQUAL !=

#define Nic1394_MaxFrameSize    2048
#define WAIT_INFINITE 0
#define MAX_CHANNEL_NUMBER 63 
#define BROADCAST_CHANNEL 31
#define GASP_SPECIFIER_ID_HI 0
#define GASP_SPECIFIER_ID_LO 0x5E
#define INVALID_CHANNEL 0xff
#define HEADER_FRAGMENTED_MASK 0xC0000000
#define MAX_ALLOWED_FRAGMENTS 4
#define MCAST_LIST_SIZE                 32
#define ISOCH_TAG 3 // Set to 3 in accordance with 1394a spec. Clause 8.2 - Gasp Header
#define QUEUE_REASSEMBLY_TIMER_ALWAYS 0
#define IP1394_RFC_FRAME_SIZE 1514
#define NIC1394_MAX_NUMBER_CHANNELS 64
#define NIC1394_MAX_NUMBER_NODES 64
#define NIC1394_MAX_REASSEMBLY_THRESHOLD 5000
//
// Compile options
//
#define FALL_THROUGH
#define INTERCEPT_MAKE_CALL 0
#define TRACK_FAILURE 1
#define NUM_RECV_FIFO_FIRST_PHASE 20
#define NUM_RECV_FIFO_BUFFERS   256

#define TRACK_LOCKS 0


#define DO_TIMESTAMPS 0

#if DO_TIMESTAMPS 
    #define ENTRY_EXIT_TIME 0
    #define INIT_HALT_TIME 1
#else
    #define ENTRY_EXIT_TIME 0
    #define INIT_HALT_TIME 0
#endif


#define TESTMODE 0


//
// Constants used to tag data structures like NdisPackets and IsochDescriptors
// For informational purposes only
//
#define NIC1394_TAG_INDICATED       'idnI'
#define NIC1394_TAG_QUEUED          'ueuQ'
#define NIC1394_TAG_RETURNED        'uteR'
#define NIC1394_TAG_ALLOCATED       'ollA'
#define NIC1394_TAG_FREED           'eerF'
#define NIC1394_TAG_REASSEMBLY      'sseR'
#define NIC1394_TAG_COMPLETED       'pmoC'
#define NIC1394_TAG_IN_SEND         'dneS'
#define NIC1394_TAG_IN_CALLBACK     'llaC'



#define ADAPTER_NAME_SIZE 128

#define ANSI_ARP_CLIENT_DOS_DEVICE_NAME "\\\\.\\ARP1394"

#define NOT_TESTED_YET 0

//
// The 1394 constants for 800 and above are not defined in
// 1394.h Make temporary local definitions.
//
#define ASYNC_PAYLOAD_800_RATE_LOCAL      4096
#define ASYNC_PAYLOAD_1600_RATE_LOCAL      (4096*2)
#define ASYNC_PAYLOAD_3200_RATE_LOCAL      (4096*4)

#define MAX_REC_800_RATE_LOCAL  (MAX_REC_400_RATE+1)
#define MAX_REC_1600_RATE_LOCAL  (MAX_REC_800_RATE_LOCAL + 1)
#define MAX_REC_3200_RATE_LOCAL  (MAX_REC_1600_RATE_LOCAL + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\debug.c ===
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// debug.c
// IEEE1394 mini-port/call-manager driver
// Debug utilities and globals
//
// 12/28/1998 JosephJ.
//


#include "precomp.h"


//-----------------------------------------------------------------------------
// Global data definitions
//-----------------------------------------------------------------------------

//
// Temporary definition for testing purposes
//


#if TESTMODE
#define DEFAULTTRACELEVEL TL_V  
#define DEFAULTTRACEMASK TM_RemRef
#else
#define DEFAULTTRACELEVEL TL_None
#define DEFAULTTRACEMASK TM_Base
#endif

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' are
// displayed.  All messages from any (TM_*) set(s) present in 'g_ulTraceMask'
// are displayed.
//
ULONG g_ulTraceLevel = DEFAULTTRACELEVEL;
ULONG g_ulTraceMask = DEFAULTTRACEMASK;


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------


#if DBG
VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks )

    // Tries to detect corruption in list 'pList', printing verbose linkage
    // output if 'fShowLinks' is set.
    //
{
    LIST_ENTRY* pLink;
    ULONG ul;

    ul = 0;
    for (pLink = pList->Flink;
         pLink != pList;
         pLink = pLink->Flink)
    {
        if (fShowLinks)
        {
            DbgPrint( "N13: CheckList($%p) Flink(%d)=$%p\n",
                pList, ul, pLink );
        }
        ++ul;
    }

    for (pLink = pList->Blink;
         pLink != pList;
         pLink = pLink->Blink)
    {
        if (fShowLinks)
        {
            DbgPrint( "N13: CheckList($%p) Blink(%d)=$%p\n",
                pList, ul, pLink );
        }
        --ul;
    }

    if (ul)
    {
        DbgBreakPoint();
    }
}
#endif


#if DBG
VOID
Dump(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )

    // Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
    // For example, with 'ulGroup' of 1, 2, and 4:
    //
    // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    // 0000 0000 0000 0000 0000 0000 0000 0000 |................|
    // 00000000 00000000 00000000 00000000 |................|
    //
    // If 'fAddress' is true, the memory address dumped is prepended to each
    // line.
    //
{
    while (cb)
    {
        INT cbLine;

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
    }
}
#endif


#if DBG
VOID
DumpLine(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress)
        DbgPrint( "N13: %p: ", p );
    else
        DbgPrint( "N13: " );

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\cm.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// cm.c
//
// IEEE1394 mini-port/call-manager driver
//
// Call Manager routines
//
// 06/20/1999 ADube Created - Declarations for call-manager routines 
//



// Debug counts of client oddities that should not be happening.
//
extern ULONG g_ulUnexpectedInCallCompletes;
extern ULONG g_ulCallsNotClosable;

//#define MaxNumSlistEntry 0x100
#define MAX_NUM_ISOCH_DESCRIPTOR 0x20
#define MAX_CHANNEL_BUFFER_SIZE 0x300
#define MAX_CHANNEL_BYTES_PER_FRAME 0x280



//-----------------------------------------------------------------------------
//          L O C A L   T Y P E S    F O R     cm.c
//-----------------------------------------------------------------------------

typedef enum _VC_SEND_RECEIVE
{
    TransmitVc = 0,
    ReceiveVc,
    TransmitAndReceiveVc,
    InvalidType
    

} VC_SEND_RECEIVE  ;



//-----------------------------------------------------------------------------
//          N D I S     C A L L - M A N A G E R     H A N D L E R S 
//-----------------------------------------------------------------------------


NDIS_STATUS
NicCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext
    );

NDIS_STATUS
NicCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext
    );


NDIS_STATUS
NicCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext
    );

NDIS_STATUS
NicCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext
    );


NDIS_STATUS
NicCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext
    );



NDIS_STATUS
NicCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size
    );


NDIS_STATUS
NicCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

NDIS_STATUS
NicCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST NdisRequest
    );

NDIS_STATUS
nicRegisterSapHandler(
    IN  NDIS_HANDLE             CallMgrAfContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    );

NDIS_STATUS
nicDeregisterSapHandler(
    IN  NDIS_HANDLE             CallMgrSapContext
    );

NDIS_STATUS
nicCmAddPartyHandler(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle,
    OUT PNDIS_HANDLE            CallMgrPartyContext
    );
    
NDIS_STATUS
nicCmDropPartyHandler(
    IN  NDIS_HANDLE             CallMgrPartyContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    );


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------





VOID
InterceptMakeCallParameters(
    PCO_MEDIA_PARAMETERS pMediaParams,
    PNIC1394_MEDIA_PARAMETERS pN1394Params
    );

NDIS_STATUS
nicAllocateAddressRangeOnActiveRemoteNodes (
    IN PADAPTERCB pAdapter
    );

VOID
nicCallSetupComplete(
    IN VCCB* pVc
    );

VOID
nicChannelCallFreeResources ( 
    IN PCHANNEL_VCCB            pChannelVc,
    IN PADAPTERCB               pAdapter,
    IN HANDLE                   hResource,
    IN ULONG                    NumDescriptors,
    IN PISOCH_DESCRIPTOR        pIsochDesciptor,
    IN BOOLEAN                  fChannelAllocated,
    IN ULONG                    Channel,
    IN PNIC_PACKET_POOL         pPool
    );


VOID
nicChannelCallCleanDataStructure ( 
    IN PCHANNEL_VCCB            pChannelVc,
    IN HANDLE                   hResource,
    IN ULONG                    NumDescriptors,
    IN PISOCH_DESCRIPTOR        pIsochDesciptor,
    IN BOOLEAN                  fChannelAllocated,
    IN ULONG                    Channel,
    IN NDIS_HANDLE              hPacketPoolHandle,
    OUT PULONG                  pNumRefsDecremented 
    );

NDIS_STATUS
nicAllocateChannelResourcesAndListen (
    IN PADAPTERCB pAdapter,
    IN PCHANNEL_VCCB pChannelVc
    );

NDIS_STATUS
nicCmGenericMakeCallInit (
    IN PVCCB pVc
    );

VOID
nicCmGenrericMakeCallFailure (
    IN PVCCB pVc
    );

VOID
nicCmCloseCallComplete(
    NDIS_WORK_ITEM* pCloseCallCompleteWorkItem,     
    IN PVOID Context 
    );


NDIS_STATUS
nicCmCloseCallEthernet (
    IN PVCCB pVc
    );
    
NDIS_STATUS
nicCmCloseCallMultiChannel (
    IN PVCCB pVc
    );

NDIS_STATUS
nicCmCloseCallRecvFIFO (
    IN PVCCB pVc
    );


NDIS_STATUS
nicCmCloseCallSendFIFO (
    IN PVCCB pVc
    );
    

NDIS_STATUS
nicCmCloseCallSendRecvChannel (
    IN PVCCB pVc 
    );

NDIS_STATUS
nicCmCloseCallSendChannel(
    IN PVCCB pVc 
    );

VOID
nicCmMakeCallComplete (
    NDIS_WORK_ITEM* pMakeCallCompleteWorkItem,
    IN PVOID Context
    );

VOID
nicCmMakeCallCompleteFailureCleanUp(
    IN OUT PVCCB pVc 
    );

NDIS_STATUS
nicCmMakeCallInitRecvChannelVc(
    IN OUT PVCCB pVc 
    );

    
NDIS_STATUS
nicCmMakeCallInitSendChannelVc(
    IN OUT PVCCB pVc 
    );

    
NDIS_STATUS
nicCmMakeCallInitSendRecvChannelVc(
    IN OUT PVCCB pVc 
    );


NDIS_STATUS
nicCmMakeCallInitEthernet(
    IN PVCCB pVc
    );

NDIS_STATUS
nicCmMakeCallSendChannel (
    IN PVCCB pVc
    );

NDIS_STATUS
nicCmMakeCallMultiChannel (
    IN PVCCB pVc
    );


NDIS_STATUS
nicAllocateRequestedChannelMakeCallComplete (
    IN PADAPTERCB pAdapter,
    IN PCHANNEL_VCCB pChannelVc,
    IN OUT PULONG pChannel
    );


NDIS_STATUS
nicCmMakeCallInitRecvFIFOVc(
    IN OUT PVCCB pVc
    );


NDIS_STATUS
nicCmMakeCallInitSendFIFOVc(
    IN OUT PVCCB pVc
    );

VOID
nicDereferenceAF(
    IN AFCB* pAF
    );

ULONG
nicGetMaxPayLoadForSpeed(
    IN ULONG Speed,
    IN ULONG mtu
    );
    

VOID
nicInactiveCallCleanUp(
    IN VCCB* pVc
    );


NDIS_STATUS
nicInitRecvFifoDataStructures (
    IN PRECVFIFO_VCCB pRecvFIFOVc
    );

VOID
nicUnInitRecvFifoDataStructures (
    IN PRECVFIFO_VCCB pRecvFIFOVc
    );

VOID
nicFreeAF(
    IN AFCB* pAF
    );


VOID
nicReferenceAF(
    IN AFCB* pAF
    );


NDIS_STATUS
nicCmQueryInformation(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    );


NDIS_STATUS
nicCmSetInformation(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    );


NDIS_STATUS
nicGetActiveRemoteNode (
    PADAPTERCB pAdpater,
    PREMOTE_NODE*      ppRemoteNodePdoCb
    );


NDIS_STATUS
nicChangeChannelChar (
    PVCCB pVc, 
    PNIC1394_CHANNEL_CHARACTERISTICS pMcChar
    );



NDIS_STATUS
nicCmGenericMakeCallInitChannels (
    IN PCHANNEL_VCCB pChannelVc,
    VC_SEND_RECEIVE  VcType 
    );


NDIS_STATUS
nicCmGenericMakeCallInitFifo (
    IN PVCCB pVc,
    VC_SEND_RECEIVE  VcType 
    );



NDIS_STATUS
nicCmGenericMakeCallMutilChannel (
    IN PVCCB pVc,
    VC_SEND_RECEIVE  VcType 
    );
    


NDIS_STATUS
nicCmGenericMakeCallEthernet(
    IN PVCCB pVc,
    IN VC_SEND_RECEIVE VcType
    );

VOID 
nicInterceptMakeCallParameters (
    PCO_MEDIA_PARAMETERS pMedia     
    );

NDIS_STATUS
nicQueryRemoteNodeCaps (
    IN PADAPTERCB pAdapter,
    IN PREMOTE_NODE pRemoteNode,
    OUT PULONG pSpeed,
    OUT PULONG pMaxBufferSize,
    OUT PULONG pMaxRec
    );

UINT
nicSpeedFlagsToSCode(
    IN UINT SpeedFlags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\driver.c ===
// Copyright (c) 2000-2002, Microsoft Corporation, all rights reserved
//
// driver.c
//
// IEEE1394 mini-port/call-manager driver
//
//
// Loads and unload the ARP module when the 
// bridge is activated
//
// Created by Adube
//


//--------------------------------------------------------//
//                                                        // 
//                                                        //   
//   ZwLoadDriver is locally declared because if I try    //
//   and include ZwApi.h there are conflicts with         //
//   structures defined in wdm.h                          //
//                                                        //
//                                                        //
//--------------------------------------------------------//


#include "precomp.h"


NDIS_STRING ArpName  = NDIS_STRING_CONST("\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ARP1394");

//----------------------------------------------------------//
//      Local Prototypes                                    //
//----------------------------------------------------------//

NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadDriver(
    IN PUNICODE_STRING DriverServiceName
    );

VOID
nicEthStartArpWorkItem (
    PNDIS_WORK_ITEM pWorkItem, 
    IN PVOID Context
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

VOID
nicSetupIoctlToLoadArp (
    IN PADAPTERCB pAdapter,
    IN PARP_INFO pArpInfo
    );

VOID
nicSetupAndSendIoctlToArp (
    IN PADAPTERCB pAdapter,
    IN PARP_INFO pArpInfo
    );
    
//----------------------------------------------------------//
//      Functions                                           //
//----------------------------------------------------------//



VOID
nicSendIoctlToArp(
    PARP1394_IOCTL_COMMAND pCmd
)
/*++

Routine Description:

Send the start Ioctl to the ARp module

Arguments:


Return Value:


--*/

{
    BOOLEAN                 fRet = FALSE;
    PUCHAR                  pc;
    HANDLE                  DeviceHandle;
    ULONG                   BytesReturned;
    OBJECT_ATTRIBUTES       Atts;
    NDIS_STRING             strArp1394 = NDIS_STRING_CONST ("\\Device\\Arp1394");
    HANDLE                  Handle;
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    IO_STATUS_BLOCK         ioStatusBlock;

    do
    {   
    
        InitializeObjectAttributes(&Atts,
                                   &strArp1394,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

                 
       status = ZwCreateFile(&Handle,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &Atts,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN_IF,
                             0,
                             NULL,
                             0);

        if (!NT_SUCCESS(status))
        {
            Handle = NULL;
            break;
        }

        //
        // Submit the request to the forwarder
        //

            
        status = ZwDeviceIoControlFile(
                          Handle,
                          NULL,
                          NULL,
                          NULL,
                          &ioStatusBlock,
                          ARP_IOCTL_CLIENT_OPERATION,
                          pCmd,
                          sizeof(*pCmd),
                          pCmd,
                          sizeof(*pCmd));


                              
        //
        // Close the device.
        //
        
        ZwClose(Handle);

        if (!NT_SUCCESS(status))
        {
            ASSERT (status == STATUS_SUCCESS);
            break;
        }

    } while (FALSE);



}


VOID
nicLoadArpDriver ()
/*++

Routine Description:

Load the arp module

Arguments:


Return Value:


--*/
{
    ZwLoadDriver(&ArpName);

    TRACE (TL_T, TM_Mp,("Loaded the Arp Module %p\n", &ArpName));

}





VOID
nicGetAdapterName (
    IN PADAPTERCB pAdapter,
    IN WCHAR* pAdapterName, 
    IN ULONG  BufferSize,
    IN PULONG  pSizeReturned 
    )
/*++

Routine Description:

Get the Adapter Name From NDIS. All sizes are in bytes

Arguments:


Return Value:


--*/

{

    //
    // The BufferSize always has to be greater than SizeReturned
    //

    if (BufferSize > pAdapter->AdapterNameSize)
    {

        NdisMoveMemory (pAdapterName, 
                       &pAdapter->AdapterName[0],
                       pAdapter->AdapterNameSize);


        if (pSizeReturned  != NULL)
        {

            *pSizeReturned = pAdapter->AdapterNameSize ;
        }

    }
    else
    {

        //
        // The else case cannot be hit because the size of the AdapterName buffer 
        // is 1 less than the sizeof pEthCmd->AdapterName[]. if this is ever changed,
        // the Assert will be hit.
        //
        
        ASSERT (BufferSize > pAdapter->AdapterNameSize);
        *pSizeReturned = 0;

    }
}



VOID
nicSetupIoctlToArp (
    IN PADAPTERCB pAdapter,
    IN PARP_INFO pArpInfo
    )
    /*++

Routine Description:

    Sets up the Ioctl to be sent to the Arp module

Arguments:


Return Value:


--*/

{

    PARP1394_IOCTL_ETHERNET_NOTIFICATION pEthCmd = &pAdapter->ArpIoctl.EthernetNotification;


    ADAPTER_ACQUIRE_LOCK(pAdapter);

    if (BindArp == pArpInfo->Action || LoadArp == pArpInfo->Action)
    {
        pEthCmd->Hdr.Op     =  ARP1394_IOCTL_OP_ETHERNET_START_EMULATION;
        pAdapter->fIsArpStarted  = TRUE;
        ADAPTER_SET_FLAG(pAdapter,fADAPTER_BridgeMode);
    }


    if (UnloadArp == pArpInfo->Action || UnloadArpNoRequest== pArpInfo->Action)
    {
        pEthCmd->Hdr.Op     = ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION;
        pAdapter->fIsArpStarted  = FALSE;
        ADAPTER_CLEAR_FLAG(pAdapter,fADAPTER_BridgeMode);

    }


    ADAPTER_RELEASE_LOCK(pAdapter);



}   



VOID
nicSetupAndSendIoctlToArp (
    IN PADAPTERCB pAdapter,
    PARP_INFO pArpInfo    )
/*++

Routine Description:

    Sets up an Ioctl and Sends it to the Arp module

Arguments:


Return Value:


--*/
{   

    
    nicSetupIoctlToArp (pAdapter, pArpInfo);


    nicSendIoctlToArp(&pAdapter->ArpIoctl);

}








VOID
nicSendNotificationToArp(
    IN PADAPTERCB pAdapter,
    IN PARP_INFO  pArpInfo 
    )
/*++

Routine Description:

    Send the notification to the arp module

Arguments:


Return Value:


--*/

{
    PNDIS_REQUEST   pRequest = NULL;
    ULONG           Start = FALSE;
    NDIS_STATUS     NdisStatus = NDIS_STATUS_SUCCESS;
  
    ARP1394_IOCTL_COMMAND ArpIoctl;

    //
    // Extract our variables from the workitem
    //
  
    TRACE (TL_T, TM_Mp, ("==>nicEthStartArpWorkItem Start  %x", Start ));

    

    do
    {
        //
        // First complete the request, so that protocols can start sending new 
        // requests . Notes  11/30/00
        // 
        if (pArpInfo->Action == LoadArp || pArpInfo->Action == UnloadArp)
        {
            //
            // in either of these cases, it is a request that has initiated the action.
            // 
            // 
            if (pRequest == NULL)
            {
                //
                // This came in through our CL SetInformation Handler
                //
                NdisMSetInformationComplete (pAdapter->MiniportAdapterHandle, NdisStatus );
            }
            else
            {
                NdisMCoRequestComplete ( NdisStatus ,
                                         pAdapter->MiniportAdapterHandle,
                                         pRequest);
                                         
            }


        }

        

        //
        // "arp13 -bstart adapter"
        // If we are asked to Load Arp, we verify that the arp hasn't 
        // already been started
        //

        if (pArpInfo->Action == LoadArp &&  pAdapter->fIsArpStarted == FALSE)// we are turning ON
        {
            //
            // Load the driver
            //
            nicLoadArpDriver ();
            //
            // Send it an IOCTL to open the nic1394 adapter
            //

        }
        
        
        if (pArpInfo->Action == BindArp && pAdapter->fIsArpStarted  == FALSE)
        {
            //
            // if the arp module has not been started and we are asking to bind,
            // then it means that an unload was ahead of us in the queue and
            // unbound nic1394 from arp1394. This thread can exit.
            //
            break;

        }


        //
        // Send the Ioctl to the Arp module
        //
        
        nicSetupAndSendIoctlToArp (pAdapter, pArpInfo);
        
    
        
    } while (FALSE);
    
    //
    // end of function
    //
    FREE_NONPAGED (pArpInfo);

    TRACE (TL_T, TM_Mp, ("<==nicEthStartArpWorkItem fLoadArp %x", pArpInfo->Action));

    return;


}



VOID
nicProcessNotificationForArp(
    IN PNDIS_WORK_ITEM pWorkItem,   
    IN PVOID Context 
    )
/*++

Routine Description:

    This function extracts the notification from the workitem and 
    sends the Load/Unload/ BInd notfication to ARp 1394
    
Arguments:


Return Value:


--*/
{

    PADAPTERCB      pAdapter = (PADAPTERCB) Context;

    ADAPTER_ACQUIRE_LOCK (pAdapter);
    

    //
    // Empty the Queue indicating as many packets as possible
    //
    while (IsListEmpty(&pAdapter->LoadArp.Queue)==FALSE)
    {
        PARP_INFO               pArpInfo;
        PLIST_ENTRY             pLink;
        NDIS_STATUS             NdisStatus;

        pAdapter->LoadArp.PktsInQueue--;

        pLink = RemoveHeadList(&pAdapter->LoadArp.Queue);

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Extract the send context
        //
        if (pLink != NULL)
        {
            pArpInfo = CONTAINING_RECORD(
                                               pLink,
                                               ARP_INFO,
                                               Link);

            nicSendNotificationToArp(pAdapter, pArpInfo);
        }        
        ADAPTER_ACQUIRE_LOCK (pAdapter);

    }
    
    //
    // clear the flag
    //

    ASSERT (pAdapter->LoadArp.PktsInQueue==0);
    ASSERT (IsListEmpty(&pAdapter->LoadArp.Queue));

    pAdapter->LoadArp.bTimerAlreadySet = FALSE;


    ADAPTER_RELEASE_LOCK (pAdapter);

    NdisInterlockedDecrement (&pAdapter->OutstandingWorkItems);
    

}


VOID
nicInitializeLoadArpStruct(
    PADAPTERCB pAdapter
    )
/*++

Routine Description:

    This function initializes the LoadArp struct in _ADAPTERCB
    
Arguments:


Return Value:


--*/

{

    if (pAdapter->LoadArp.bInitialized == FALSE)
    {
        
        PARP1394_IOCTL_ETHERNET_NOTIFICATION pEthCmd = &pAdapter->ArpIoctl.EthernetNotification;
        ULONG Size;

        //
        // Initialize the Load Arp struct
        //

        NdisZeroMemory (&pAdapter->LoadArp, sizeof(pAdapter->LoadArp));
        InitializeListHead(&pAdapter->LoadArp.Queue); 
        pAdapter->LoadArp.bInitialized  = TRUE;
       
        NdisInitializeWorkItem (&pAdapter->LoadArp.WorkItem,
                                nicProcessNotificationForArp,
                                pAdapter);

        //
        // Initialize the AdapterName, this will ensure that the string is 
        // NULL terminated
        //

        NdisZeroMemory( pEthCmd->AdapterName, sizeof(pEthCmd->AdapterName));

        nicGetAdapterName (pAdapter,
                           pEthCmd->AdapterName, 
                           sizeof(pEthCmd->AdapterName)-sizeof(WCHAR),
                           &Size );


        pEthCmd->Hdr.Version    = ARP1394_IOCTL_VERSION;


    }
}
    


NDIS_STATUS
nicQueueRequestToArp(
    PADAPTERCB pAdapter, 
    ARP_ACTION Action,
    PNDIS_REQUEST pRequest
    )
/*++

Routine Description:

    This function inserts a request to load/unload or bind the Arp module
    If there is no timer servicing the queue
    then it queues a timer to dequeue the packet in Global Event's context


Arguments:

    Self explanatory 
    
Return Value:
    Success - if inserted into the the queue

--*/
    
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fSetWorkItem = FALSE;
    PARP_INFO pArpInfo;

    do
    {

        pArpInfo = ALLOC_NONPAGED(sizeof (ARP_INFO), MTAG_DEFAULT); 

        if (pArpInfo == NULL)
        {
            break;
        }
        
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // Find out if this thread needs to fire the timer
        //

        pArpInfo->Action = Action;
        pArpInfo->pRequest = pRequest;

        if (pAdapter->LoadArp.bTimerAlreadySet == FALSE)
        {
            fSetWorkItem = TRUE;
            pAdapter->LoadArp.bTimerAlreadySet = TRUE;

        }
                
        InsertTailList(
                &pAdapter->LoadArp.Queue,
                &pArpInfo->Link
                );
        pAdapter->LoadArp.PktsInQueue++;

        
        ADAPTER_RELEASE_LOCK (pAdapter);
        //
        // Now queue the workitem
        //
        if (fSetWorkItem== TRUE)
        {
            PNDIS_WORK_ITEM pWorkItem;
            //
            //  Initialize the timer
            //
            pWorkItem = &pAdapter->LoadArp.WorkItem;      

            
            TRACE( TL_V, TM_Recv, ( "   Set Timer "));
            
                                  
            NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

            NdisScheduleWorkItem (pWorkItem);

        }

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    ASSERT (Status == NDIS_STATUS_SUCCESS);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\cm.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// cm.c
//
// IEEE1394 mini-port/call-manager driver
//
// Call Manager routines
//
// 12/28/1998 JosephJ Created
// 01/01/1999 ADube modified - Added Remote Node Capability 
//

#include "precomp.h"

    
//-----------------------------------------------------------------------------
// Call-manager handlers and completers
//-----------------------------------------------------------------------------

NDIS_STATUS
NicCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext )

    // Standard 'CmCmOpenAfHandler' routine called by NDIS when a client
    // requests to open an address family.  See DDK doc.
    //
{
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hExistingAf;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    TIMESTAMP_ENTRY ("==>Open Af");


    TRACE( TL_T, TM_Cm, ( "==>NicCmOpenAf" ) );

    pAdapter = (ADAPTERCB* )CallMgrBindingContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    if (AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_1394
        || AddressFamily->MajorVersion != NDIS_MajorVersion
        || AddressFamily->MinorVersion != NDIS_MinorVersion)
    {
        return NDIS_STATUS_BAD_VERSION;
    }


    do
    {
        AFCB *pAF  = NULL;

        // Allocate and initialize the adress family structure.
        //
        pAF = ALLOC_NONPAGED( sizeof(*pAF), MTAG_AFCB );
        if (!pAF)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        NdisZeroMemory( pAF, sizeof(*pAF) );


        // Set a marker for easier memory dump browsing and future assertions.
        //
        pAF->ulTag = MTAG_AFCB;
    
        // Save the NDIS handle associated with this AF for use in future
        // NdisXxx calls.
        //

        ADAPTER_ACQUIRE_LOCK( pAdapter );

        pAF->NdisAfHandle = NdisAfHandle;
    
    
        // Initialize the VC list for this AF.
        //
        InitializeListHead( &pAF->AFVCList );
    
    
        // Set up linkages and references.
        //
        pAF->pAdapter = pAdapter;
        nicReferenceAF( pAF );           // OpenAF
        nicReferenceAdapter( pAdapter ,"NicCmOpenAf "); // OpenAF

        InsertHeadList(&pAdapter->AFList, &pAF->linkAFCB);

   
        // Return pAF as the address family context.
        //
        
        *CallMgrAfContext = (PNDIS_HANDLE )pAF;

        

        ADAPTER_RELEASE_LOCK (pAdapter);

    } while (FALSE);


    TRACE( TL_T, TM_Cm, ( "NicCmOpenAf Status %x", Status ) );

    TIMESTAMP_EXIT("<==Open Af ");

    return Status;
}


NDIS_STATUS
NicCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext )

    // Standard 'CmCloseAfHandler' routine called by NDIS when a client
    // requests to close an address family.  See DDK doc.
    //
{
    AFCB* pAF;
    TIMESTAMP_ENTRY ("==>CloseAf");
    
    TRACE( TL_T, TM_Cm, ( "NicCmCloseAf" ) );

    pAF = (AFCB* )CallMgrAfContext;
    
    if (pAF->ulTag != MTAG_AFCB)
    {
        ASSERT( !"AFCB?" );
        return NDIS_STATUS_INVALID_DATA;
    }
    
    
    nicSetFlags (&pAF->ulFlags, ACBF_ClosePending);



    // This dereference will eventually lead to us calling
    // NdisMCmCloseAfComplete.
    //

    //
    // The references that were made in OpenAf
    //
    nicDereferenceAF( pAF ); 



    TRACE( TL_T, TM_Cm, ( "NicCmCloseAf pending" ) );
    
    TIMESTAMP_EXIT ("<==Close Af");

    return NDIS_STATUS_PENDING;
}



NDIS_STATUS
NicCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext )

    // Standard 'CmCreateVc' routine called by NDIS in response to a
    // client's request to create a virtual circuit.  This
    // call must return synchronously.
    //
{
    NDIS_STATUS status;
    AFCB* pAF;
    VCCB* pVc;

   
    TRACE( TL_T, TM_Cm, ( "==>NicCmCreateVc, Af %x",ProtocolAfContext) );
    
    pAF = (AFCB* )ProtocolAfContext;
    if (pAF->ulTag != MTAG_AFCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // Allocate and zero a VC control block, then make any non-zero
    // initializations.
    //
    pVc = ALLOC_VCCB( pAdapter );
    if (!pVc)
    {
        ASSERT( !"Alloc VC?" );
        return NDIS_STATUS_RESOURCES;
    }

    NdisZeroMemory( pVc, sizeof(*pVc) );

    TRACE( TL_I, TM_Cm, ( "NicCmCreateVc $%p", pVc ) );

    // Set a marker for easier memory dump browsing.
    //
    pVc->Hdr.ulTag = MTAG_VCCB;


    // Save the NDIS handle of this VC for use in indications to NDIS later.
    //
    pVc->Hdr.NdisVcHandle = NdisVcHandle;

    // The VC control block's address is the VC context we return to NDIS.
    //
    *ProtocolVcContext = (NDIS_HANDLE )pVc;

    // Add a reference to the control block and the associated address family
    // that is removed by LmpCoDeleteVc. Add the linkages.
    //
    pVc->Hdr.pAF = pAF;
    // Initialize the VC's copy of the spinlock to point to the Adapter's spinlock.
    //
    pVc->Hdr.plock =  &pAF->pAdapter->lock;

    nicReferenceVc( pVc );  // Create VC
    nicReferenceAF( pAF );  // Create VC
    

    VC_SET_FLAG (pVc, VCBF_VcCreated);
    
    // Add to list of VC's associated with this AF
    //
    AF_ACQUIRE_LOCK (pAF);
    
    InsertHeadList(&pAF->AFVCList, &pVc->Hdr.linkAFVcs);

    AF_RELEASE_LOCK (pAF);

    TRACE( TL_T, TM_Cm, ( "<==NicCmCreateVc=0" ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
NicCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext )

    // Standard 'CmDeleteVc' routine called by NDIS in response to a
    // client's request to delete a virtual circuit.  This
    // call must return synchronously.
    //
{
    VCCB* pVc = NULL;
    AFCB *pAF = NULL;
    PADAPTERCB pAdapter = NULL;

    TRACE( TL_T, TM_Cm, ( "==>NicCmDelVc($%p)", ProtocolVcContext ) );

    pVc = (VCCB* )ProtocolVcContext;
    if (pVc->Hdr.ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

        
    VC_ACQUIRE_LOCK (pVc);
    
    // Set vc flag to deleted, and remove back pointer to AF
    //
    {


        // This flag catches attempts by the client to delete the VC twice.
        //
        if (nicReadFlags( &pVc->Hdr.ulFlags ) & VCBF_VcDeleted)
        {
            TRACE( TL_A, TM_Cm, ( "VC $%p re-deleted?", pVc ) );

            VC_RELEASE_LOCK ( pVc );

            ASSERT (0);
            return NDIS_STATUS_FAILURE;
        }
        nicSetFlags( &pVc->Hdr.ulFlags, VCBF_VcDeleted );

        pAF = pVc->Hdr.pAF;
        
        
    }
    


    // Unlink from the AF vc list.
    //
    {

        nicRemoveEntryList (&pVc->Hdr.linkAFVcs);
        InitializeListHead (&pVc->Hdr.linkAFVcs);

        pVc->Hdr.pAF = NULL;

    }

    
    // Remove the references added by NicCmCreateVc.
    //
    VC_RELEASE_LOCK (pVc);

    nicDereferenceAF( pAF );

    //
    // This deref could cause the Vc to be deleted. Don't touch the Vc after that
    //
    nicDereferenceVc( pVc );



    TRACE( TL_T, TM_Cm, ( "<==NicCmDelVc 0"  ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
NicCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS pCallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext )

    // Function Description:
    //
    // Standard 'CmMakeCallHandler' routine called by NDIS when the a client
    // has requested to connect to a remote end-point.  See DDK doc.
    //
    // Arguments
    // Call Mge context: 
    // Call Parameters 
    // Optiuonal NdisPartyHandle
    // Return Value:
    //
    //

{

    PVCCB pVc                                   = (VCCB* )CallMgrVcContext;
    NDIS_STATUS NdisStatus                      = NDIS_STATUS_FAILURE;
    PADAPTERCB pAdapter                         = NULL;
    NDIS_WORK_ITEM* pMakeCallCompleteWorkItem   = NULL; 

    
    PCO_MEDIA_PARAMETERS pMediaParams = pCallParameters->MediaParameters;   
    
    PNIC1394_MEDIA_PARAMETERS pN1394Params = (PNIC1394_MEDIA_PARAMETERS) pMediaParams->MediaSpecific.Parameters;

    TRACE( TL_T, TM_Cm, ( "==>NicCmMakeCall" ) );

    nicInterceptMakeCallParameters(pMediaParams); 


    do 
    {

    
        if (NdisPartyHandle != NULL || 
            pVc == NULL  ||
            pCallParameters == NULL ||
            pCallParameters->MediaParameters == NULL ||
            pCallParameters->MediaParameters->MediaSpecific.ParamType != NIC1394_MEDIA_SPECIFIC ||
            pN1394Params->MTU == 0)
        {
            //
            // We do not support these parameters
            //
            return NDIS_STATUS_FAILURE;
        }

        
        pAdapter = pVc->Hdr.pAF->pAdapter;
        ASSERT (pAdapter != NULL);


        //
        // Reference the Vc so it does not go during this makeCall
        // This is decremented in the failure code path or the workitem or 
        // when the call is closed 

        VC_ACQUIRE_LOCK (pVc);
            
        nicReferenceVc (pVc);

        //
        // Erase all references to past calls
        //
        VC_CLEAR_FLAGS (pVc, VCBM_NoActiveCall);
        
        VC_SET_FLAG (pVc, VCBF_MakeCallPending);
        //
        // Initialize the Call's refcount to 1 beacuse we are about to begin to allocate resources to the MakeCall
        // This will be decremented in the closecall handler. Or in the failure code path
        //
        nicInitializeCallRef (pVc);

        VC_RELEASE_LOCK (pVc);


        pVc->Hdr.pCallParameters = pCallParameters;
        
        NdisStatus = nicCmGenericMakeCallInit (pVc);
    

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "nicCmGenericMakeCallInit did not succeed- Make Call FAILED($%p)", CallMgrVcContext ) );      
            break;
        }
        //
        // If status is pending it means that we want to make this an asynchronous call
        // The completing th

        pMakeCallCompleteWorkItem = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM); 

        if (pMakeCallCompleteWorkItem == NULL)
        {
            TRACE( TL_A, TM_Cm, ( "Local Alloc failed for WorkItem - Make Call FAILED($%p)", CallMgrVcContext ) );
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
            
        }

        //
        // Now schedule the work item so it runs at passive level and pass the Vc as
        // an argument
        //

        NdisInitializeWorkItem ( pMakeCallCompleteWorkItem, 
                             (NDIS_PROC)nicCmMakeCallComplete,
                             (PVOID)pVc );

        NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

        NdisScheduleWorkItem (pMakeCallCompleteWorkItem);

        NdisStatus = NDIS_STATUS_PENDING;

    } while (FALSE);
    
    

    if (!NT_SUCCESS (NdisStatus))
    {

        //
        // Clean up, close the ref on the Calls, Deref the Call. And Update the Vc  
        // to show that we have failed the make call 
        //

        nicCmGenrericMakeCallFailure (pVc);

    }

    TRACE( TL_T, TM_Cm, ( "<==NicCmMakeCall, Vc %x, Status%x", pVc, NdisStatus ) );
    return NdisStatus;
}



NDIS_STATUS
nicCmGenericMakeCallInitChannels (
    IN PCHANNEL_VCCB pChannelVc,
    VC_SEND_RECEIVE  VcType 
    )
/*++

Routine Description:
    Initialze handlers for Send / Recv Channels

Arguments:


Return Value:


--*/
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS; // As there are no allocations
    PCO_MEDIA_PARAMETERS pMediaParams = pChannelVc->Hdr.pCallParameters->MediaParameters;   
    PNIC1394_MEDIA_PARAMETERS pN1394Params = (PNIC1394_MEDIA_PARAMETERS) pMediaParams->MediaSpecific.Parameters;


    if ((pN1394Params->Flags & NIC1394_VCFLAG_ALLOCATE) == NIC1394_VCFLAG_ALLOCATE)
    {
        TRACE( TL_V, TM_Cm, ( "   MakeCall- Channel Vc %x nneds to allocate channel %x", 
                            pChannelVc,
                            pN1394Params->Destination.Channel) );


        VC_SET_FLAG (pChannelVc, VCBF_NeedsToAllocateChannel);
    }
    
    switch (VcType)
    {
        case TransmitAndReceiveVc:
        {
            //
            // Channels will be defaulted to have Send And Receive Capabilities
            //
            TRACE( TL_V, TM_Cm, ( "   MakeCall- Channel Transmit and Receive Vc Vc %x", pChannelVc ) );

            pChannelVc->Hdr.VcType = NIC1394_SendRecvChannel;
                
            pChannelVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitSendRecvChannelVc;
            pChannelVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallSendRecvChannel;
            pChannelVc->Hdr.VcHandlers.SendPackets = AsyncStreamSendPacketsHandler; 
            break;
        }
    
        case ReceiveVc:
        {
            TRACE( TL_V, TM_Cm, ( "   MakeCall- Channel Receive Vc %x", pChannelVc ) );
            pChannelVc->Hdr.VcType = NIC1394_RecvChannel;
                
            pChannelVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitSendRecvChannelVc;
            pChannelVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallSendRecvChannel;
            pChannelVc->Hdr.VcHandlers.SendPackets = DummySendPacketsHandler; 

            break;
        }
        
        case TransmitVc:
        {
            TRACE( TL_V, TM_Cm, ( "   MakeCall- Channel Transmit  Vc Vc %x", pChannelVc ) );
            pChannelVc->Hdr.VcType = NIC1394_SendChannel;
                
            pChannelVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallSendChannel ;
            pChannelVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallSendChannel;
            pChannelVc->Hdr.VcHandlers.SendPackets = AsyncStreamSendPacketsHandler; 
            break;

        }

        default:
        {

            NdisStatus = NDIS_STATUS_FAILURE;
        }

    }


    return NdisStatus;

}




NDIS_STATUS
nicCmGenericMakeCallInitFifo (
    IN PVCCB pVc,
    VC_SEND_RECEIVE  VcType 

    )
/*++

Routine Description:
    Initializes Fifo Vcs'. This only fails a recv fifo is asked for and the
    adapter already has one.
    
Arguments:
    pVc

Return Value:


--*/
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS; //As there are no allocations
    PCO_MEDIA_PARAMETERS pMediaParams = pVc->Hdr.pCallParameters->MediaParameters;  
    PNIC1394_MEDIA_PARAMETERS pN1394Params = (PNIC1394_MEDIA_PARAMETERS) pMediaParams->MediaSpecific.Parameters;

    switch (VcType)
    {
    
        case ReceiveVc:
        {
            //
            // Recv FifoVcs
            //
            PADAPTERCB      pAdapter        = pVc->Hdr.pAF->pAdapter;
            PRECVFIFO_VCCB  pRecvFIFOVc     = (PRECVFIFO_VCCB) pVc; 

            ASSERT(pMediaParams->Flags & RECEIVE_VC);
            
            TRACE( TL_V, TM_Cm, ( "   MakeCall - AsyncReceiveVc Vc %x", pVc ) );
            
            pVc->Hdr.VcType = NIC1394_RecvFIFO;

            pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitRecvFIFOVc;
            pVc->Hdr.VcHandlers.SendPackets  = DummySendPacketsHandler;
            pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallRecvFIFO;


            //
            // There are two reasons to fail a RecvFIFO Make call. 
            // One, a REcvFIFO already exists and second UniqueId != 0
            //
            
            if (pAdapter->pRecvFIFOVc == NULL && pN1394Params->Destination.FifoAddress.UniqueID == 0 )
            {
                ADAPTER_ACQUIRE_LOCK (pAdapter);
            
                pAdapter->pRecvFIFOVc = (PRECVFIFO_VCCB)pVc;
                //
                // Since the adapter now has a pointer to the Vc, increment the Refcount.
                // This will be decremented in the CloseCall
                //
                nicReferenceVc (pVc);

                ADAPTER_RELEASE_LOCK (pAdapter);
            } 
            else
            {
                TRACE( TL_A, TM_Cm, ( "Adapter at %x, already has a recvFIFO. Field is at %x", pAdapter, &pAdapter->pRecvFIFOVc  ) );
                ASSERT (pAdapter->pRecvFIFOVc == NULL);

                NdisStatus = NDIS_STATUS_FAILURE;

                pVc->Hdr.VcHandlers.MakeCallHandler = NULL;
                pVc->Hdr.VcHandlers.CloseCallHandler = NULL;
            }


            break;
        }
        
        case TransmitVc:
        {
            //
            // Send Fifo Vcs
            //
            
            TRACE( TL_V, TM_Cm, ( "    MakeCall - AsyncTransmitVc Vc %x", pVc ) );

            pVc->Hdr.VcType = NIC1394_SendFIFO;

            pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitSendFIFOVc;  
            pVc->Hdr.VcHandlers.SendPackets = AsyncWriteSendPacketsHandler; 
            pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallSendFIFO;

            break;

        }

        case TransmitAndReceiveVc:
        default:
        {

            NdisStatus = NDIS_STATUS_FAILURE;
        }

    }

    return NdisStatus;



}





NDIS_STATUS
nicCmGenericMakeCallMutilChannel (
    IN PVCCB pVc,
    VC_SEND_RECEIVE  VcType 
    )
/*++

Routine Description:
  Init the handlers

Arguments:


Return Value:


--*/
{

    TRACE( TL_A, TM_Cm, ( "Make Call Recvd for MultiChannel %x ", pVc) );
    
    pVc->Hdr.VcType = NIC1394_MultiChannel;
        
    pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallMultiChannel ;
    pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallMultiChannel ;
    pVc->Hdr.VcHandlers.SendPackets = AsyncStreamSendPacketsHandler; 

    return NDIS_STATUS_SUCCESS;


}

NDIS_STATUS
nicCmGenericMakeCallEthernet(
    IN PVCCB pVc,
    IN VC_SEND_RECEIVE VcType
    )
/*++

Routine Description:

  Init the handlers
  
Arguments:


Return Value:


--*/

{

    TRACE( TL_A, TM_Cm, ( "Make Call Recvd for Ethernet %x ", pVc) );

    pVc->Hdr.VcType = NIC1394_Ethernet;

    pVc->Hdr.VcHandlers.MakeCallHandler = nicCmMakeCallInitEthernet;
    pVc->Hdr.VcHandlers.SendPackets  = nicEthernetVcSend;
    pVc->Hdr.VcHandlers.CloseCallHandler = nicCmCloseCallEthernet ;

    return NDIS_STATUS_SUCCESS;


}



NDIS_STATUS
nicCmGenericMakeCallInit (
    IN PVCCB pVc
    )
    
    // Function Description:
    //
    // This initializes the VcType and Copied the Media Parameters over
    // Initialized VCType to SendChannel, RecvChannel, SendAndRecvChanne,
    // SendFifo,
    //
    // Arguments
    // Vc - Vc that needs to be initalized
    //
    // Return Value:
    // Success - as no memory allocation takes place


    // This function should not do anything that can fail.

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    VC_SEND_RECEIVE VcType = InvalidType;
    
    PCO_MEDIA_PARAMETERS pMediaParams = pVc->Hdr.pCallParameters->MediaParameters;  
    
    PNIC1394_MEDIA_PARAMETERS pN1394Params = (PNIC1394_MEDIA_PARAMETERS) pMediaParams->MediaSpecific.Parameters;


    TRACE( TL_T, TM_Cm, ( "==>nicCmGenericMakeCallInit  pVc %x", pVc ) );

    pVc->Hdr.Nic1394MediaParams = *pN1394Params;
    ASSERT(pVc->Hdr.pAF!=NULL);
    pVc->Hdr.pGeneration = &pVc->Hdr.pAF->pAdapter->Generation;

    //
    // Figure out if this is send or receive Vc Or both
    //
    do 
    {
        if ((pMediaParams->Flags & (TRANSMIT_VC |RECEIVE_VC)) == TRANSMIT_VC)
        {
            VcType = TransmitVc;
            break;
        }

        if ((pMediaParams->Flags & (TRANSMIT_VC |RECEIVE_VC)) == RECEIVE_VC)
        {
            VcType = ReceiveVc;
            break;
        }
        if ((pMediaParams->Flags & (TRANSMIT_VC |RECEIVE_VC)) == (TRANSMIT_VC |RECEIVE_VC)  )
        {
            VcType = TransmitAndReceiveVc;
            break;
        }

    } while (FALSE);
    
    ASSERT (VcType <= TransmitAndReceiveVc);


    switch (pN1394Params->Destination.AddressType)
    {
        case NIC1394AddressType_Channel:
        {
            NdisStatus = nicCmGenericMakeCallInitChannels ((PCHANNEL_VCCB)pVc, VcType);

            break;
        }
        case NIC1394AddressType_FIFO:
        {
            //
            // Now we are in FIFO land. 
            //
            
            NdisStatus = nicCmGenericMakeCallInitFifo (pVc,  VcType );
                
            break;
        }

        case NIC1394AddressType_MultiChannel:
        {

            NdisStatus  = nicCmGenericMakeCallMutilChannel (pVc, VcType );
            
            break;
        }

        case NIC1394AddressType_Ethernet:
        {
            NdisStatus = nicCmGenericMakeCallEthernet(pVc,  VcType );
            break;
        }

        default:
        {

            ASSERT (pN1394Params->Destination.AddressType<=NIC1394AddressType_Ethernet);
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

    }


    TRACE( TL_T, TM_Cm, ( "<==nicCmGenericMakeCallInit  pVc %x, Status %x",pVc , NdisStatus) );
    
    return NdisStatus; 
     
}



VOID
nicCmGenrericMakeCallFailure (
    IN PVCCB pVc
    )
    // Function Description:
    // Does the clean up on the VcHDr structure. Will cleanup the Destination, VcType
    // and Vc. Initialize Handler. Special case - Recv VC
    // Arguments
    // PVCCB : Vc on which cleanup need to be done.
    // Return Value:
    // None
{


    TRACE( TL_T, TM_Cm, ( "==>nicGenrericMakeCallFailure   pVc %x, ",pVc ) );



    //
    // First, we need to make sure if adapter's VC is the same as this VC, 
    // otherwise the adapters'recv VC is Valid Vc currently in Use. Do not touch it.
    //

    if (pVc->Hdr.VcType == NIC1394_RecvFIFO && 
        pVc->Hdr.pAF->pAdapter->pRecvFIFOVc == (PRECVFIFO_VCCB)pVc)
    {
        
        //
        // This is the reference that was added GenericInitVc function
        // and only applied to Recv VC's
        //
        nicDereferenceVc (pVc);
    }

    VC_ACQUIRE_LOCK(pVc)

    pVc->Hdr.VcHandlers.MakeCallHandler = NULL;
    pVc->Hdr.VcHandlers.CloseCallHandler = NULL;

    pVc->Hdr.VcType = NIC1394_Invalid_Type;


    NdisZeroMemory (&pVc->Hdr.Nic1394MediaParams , 
                    sizeof (pVc->Hdr.Nic1394MediaParams) );

    nicCloseCallRef (pVc);

    //
    // Mark the Vc Flags, with a MakeCall Failed 
    //
    VC_CLEAR_FLAGS(pVc ,VCBF_MakeCallPending);

    VC_SET_FLAG (pVc, VCBF_MakeCallFailed);

    VC_RELEASE_LOCK (pVc);
            
    
    TRACE( TL_T, TM_Cm, ( "<==nicGenrericMakeCallFailure   pVc %x, ",pVc ) );

}


VOID
nicCmMakeCallComplete (
    NDIS_WORK_ITEM* pMakeCallCompleteWorkItem,
    IN PVOID Context
    )
    // Function:
    // This function is used to complete a Make Call. This can be done synchronously
    // or asynchronous. If a status pending was passed to this function, it will complete using 
    // the asynchronous route
    //
    // If everytrhing succeeds, one Ref to the Vc will be passed through and that will be decremented
    // when the call is closed
    // This function should never return NDIS_STATUS_PENDING. Will be called as a WorkItem
{

    PVCCB pVc               = (PVCCB)Context;
    PADAPTERCB pAdapter     = pVc->Hdr.pAF->pAdapter;
    NDIS_STATUS NdisStatus  = NDIS_STATUS_FAILURE;
    STORE_CURRENT_IRQL;

    TRACE( TL_T, TM_Cm, ( "==>NicCmMakeCallComplete ,pVc %x",pVc  ) );

    //
    // Reference the Vc as we want the Vc structure to stay alive till 
    // the end of the make call complete
    //
    nicReferenceVc (pVc);
    
    
    //
    // Call the Initialize handler for the VC so that it can be initialized
    //

    ASSERT (pVc->Hdr.VcHandlers.MakeCallHandler != NULL);

    NdisStatus = (*pVc->Hdr.VcHandlers.MakeCallHandler) (pVc);
    
    MATCH_IRQL;

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        VC_ACQUIRE_LOCK(pVc);
        //
        //  Now mark the Vc as active
        //
    
    
        VC_SET_FLAG( pVc, VCBF_VcActivated);
            
        VC_CLEAR_FLAGS(pVc ,VCBF_MakeCallPending);

        
        VC_RELEASE_LOCK (pVc);
    }
    else
    {   
    
        //
        // call the clean up routine to bring the Vc back to its old state
        //

        nicCmMakeCallCompleteFailureCleanUp (pVc);

        //
        // Dereference the call that we are about to fail. This reference was made in
        // the beginning of make call routine. when the callref ==0, the Vc will be 
        // dereferenced as well
        //
        VC_ACQUIRE_LOCK (pVc);  

        VC_SET_FLAG (pVc, VCBF_MakeCallFailed);
            
        VC_CLEAR_FLAGS(pVc ,VCBF_MakeCallPending);
    
        nicDereferenceCall (pVc, "nicCmMakeCallComplete");

        VC_RELEASE_LOCK (pVc);
    
    }


    MATCH_IRQL;

    //
    // Complete the call with the correct status
    //
    TRACE( TL_N, TM_Cm, ( "Completing the Make Call , Vc %x, Status %x", pVc, NdisStatus ) );



    
    NdisCmMakeCallComplete(NdisStatus,
                            pVc->Hdr.NdisVcHandle,
                            NULL,
                            NULL,
                            pVc->Hdr.pCallParameters );
                             

    
    TRACE( TL_I, TM_Cm, ( "Called NdisCmMakeCallComplete, Vc %x, Status%x", pVc, NdisStatus ) );

    TRACE( TL_T, TM_Cm, ( "<==NicCmMakeCallComplete, Vc %x, Status%x", pVc,  NdisStatus ) );


    FREE_NONPAGED (pMakeCallCompleteWorkItem); 

    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);
    //
    // This will cause the Vc Refcount to go to zero if the Make Call fails
    //
    nicDereferenceVc (pVc);

    MATCH_IRQL;
}






NDIS_STATUS
nicCmMakeCallInitRecvFIFOVc(
    IN OUT PVCCB pVc
    )
    // Function Description:
    //
    //  This function allocates, packet pool, populates the Slist
    //  allocates the address range and 
    //  inserts the Vc into the Adapter->pRecvFifoVc field
    //  
    //  Will succeed the call, if this process was successful on 1 remote node
    // Arguments
    // PVCCB  : pVc that the call is made on
    //
    //
    // Return Value:
    //  Success: If all allocations succeeded for just 1 remote node
        

{

    PRECVFIFO_VCCB pRecvFIFOVc                      = (PRECVFIFO_VCCB) pVc;
    NDIS_STATUS NdisStatus                          = NDIS_STATUS_SUCCESS;
    REMOTE_NODE *pRemoteNode                                    = NULL;
    PADAPTERCB pAdapter                             = pRecvFIFOVc->Hdr.pAF->pAdapter;

    PNIC1394_MEDIA_PARAMETERS pN1394Params = &pVc->Hdr.Nic1394MediaParams;
    UINT64 UniqueId                                 = pN1394Params->Destination.FifoAddress.UniqueID;       
    PLIST_ENTRY pPdoListEntry                       = NULL;
    BOOLEAN fWaitSuccessful                         = FALSE;
    BOOLEAN fInitRecvFifoDataStructures             = FALSE;
    BOOLEAN fNeedToWait                             = FALSE;
    PNIC1394_FIFO_ADDRESS pFifoAddress              = NULL;

    STORE_CURRENT_IRQL;

    TRACE( TL_T, TM_Cm, ( "==>nicCmMakeCallInitRecvFIFOVc pRecvFIFOVc %x ", pRecvFIFOVc) );

    ASSERT (pAdapter != NULL);
    ASSERT (KeGetCurrentIrql()==PASSIVE_LEVEL);

    pFifoAddress = &pN1394Params->Destination.FifoAddress;

    UniqueId = pFifoAddress->UniqueID;              
    do 
    {

        

        NdisStatus = nicInitRecvFifoDataStructures (pRecvFIFOVc);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( " nicInitRecvFifoDataStructures FAILED pRecvFIFOVc is %x, UniqueId %I64x  ", pRecvFIFOVc) );
            break;
        }

        fInitRecvFifoDataStructures = TRUE; 

        //
        // This field is not used by a RecvFIFO because it has multiple Pdos
        //
        pRecvFIFOVc->Hdr.pRemoteNode = NULL;

        NdisStatus = nicAllocateAddressRange(pAdapter, pRecvFIFOVc);

        if(NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "Unable to get Pdo and allocate addresses,  call FAILED ,pRecvFIFOVc is %x", pRecvFIFOVc) );

            ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);

            break;
        }


    
        ASSERT(pRecvFIFOVc->PacketPool.Handle != NULL);
        ASSERT(pRecvFIFOVc->Hdr.MTU != 0);


    } while (FALSE);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        // 
        // Undo all allocated memory
        //
        TRACE( TL_A, TM_Cm, ( "Failing the Make Call for Vc %x" , pVc) );

        if (fInitRecvFifoDataStructures == TRUE)
        {
            nicUnInitRecvFifoDataStructures (pRecvFIFOVc);
        }
        

    }
    
    TRACE( TL_I, TM_Cm, ( "pVc's Offset High %4x",pVc->Hdr.Nic1394MediaParams.Destination.FifoAddress.Off_High ) );
    TRACE( TL_I, TM_Cm, ( "pVc's Offset Low %x",pVc->Hdr.Nic1394MediaParams.Destination.FifoAddress.Off_Low ) );


    
    TRACE( TL_T, TM_Cm, ( "<==nicCmMakeCallInitRecvFIFOVc %x",NdisStatus ) );

    MATCH_IRQL;

    return NdisStatus;

}




NDIS_STATUS
nicCmMakeCallInitSendFIFOVc(
    IN OUT PVCCB pVc 
    )

/*++

Routine Description:

 This initializes a Send Fifo Make Call. 
 It 
  i) finds the remote node using the make call parameters
  ii) inititalizes strcutures

Arguments:
 pVc - Vc that the make call is done on.

Return Value:


--*/
    //
        

{

    PSENDFIFO_VCCB          pSendFIFOVc = (PSENDFIFO_VCCB) pVc;
    NDIS_STATUS             NdisStatus  = NDIS_STATUS_SUCCESS;
    UINT                    Generation  = 0;
    PREMOTE_NODE            pRemoteNode = NULL;
    PADAPTERCB              pAdapter    = pSendFIFOVc->Hdr.pAF->pAdapter;
    PNIC1394_MEDIA_PARAMETERS pN1394Params = NULL;
    UINT64                  UniqueId    = 0;
    PNIC1394_FIFO_ADDRESS   pFifoAddress    = NULL;
    ULONG                   Speed;
    ULONG                   MaxBufferSize;
    ULONG                   RemoteMaxRec;
    BOOLEAN                 fDeRefRemoteNode = FALSE;

    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Cm, ( "==>NicCmMakeCallInitSendFIFOVc pSendFIFOVc %x", pSendFIFOVc  ) );
        
        
    pN1394Params = (PNIC1394_MEDIA_PARAMETERS)&pVc->Hdr.pCallParameters->MediaParameters->MediaSpecific.Parameters[0];
    
    ASSERT (pN1394Params->Destination.AddressType == NIC1394AddressType_FIFO);


    pFifoAddress = &pN1394Params->Destination.FifoAddress;

    UniqueId = pFifoAddress->UniqueID;              

    
    TRACE( TL_V, TM_Cm, ( "FifoAddress %x, UniqueId %I64x, Hi %.4x, Lo %x", 
                              pFifoAddress, pFifoAddress->UniqueID, 
                              pFifoAddress->Off_High, pFifoAddress->Off_Low ) );

    do 
    {

        //
        // Get the Pdo that corresponds with the UniqueId 
        //
        ASSERT(pSendFIFOVc->Hdr.pAF->pAdapter != NULL);


        
        NdisStatus = nicFindRemoteNodeFromAdapter( pSendFIFOVc->Hdr.pAF->pAdapter,
                                                  NULL,
                                                  UniqueId,
                                                  &pRemoteNode);
        
        if(NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "Unable to Find Pdo, call FAILED ,pSendFIFOVc is %x, UniqueId %I64x  ", pSendFIFOVc, UniqueId ) );

            break;
            
        }
        
        ASSERT (pRemoteNode != NULL);
        
        //
        // nicFindRemoteNodeFromAdapter ref's pRemoteNode on success.
        // We need to deref it if we're not going to be using it.
        // Let's start by assuming we aren't.
        //
        fDeRefRemoteNode = TRUE;

        //
        // Get the Generation Count of the device
        //
        NdisStatus = nicGetGenerationCount ( pRemoteNode->pAdapter, &Generation);

        if(NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "GET GENERATION FAILED ,pSendFIFOVc is %x", pSendFIFOVc ) );

            ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);
            break;
        }


                
        TRACE( TL_V, TM_Cm, ( "Found PdoCb  %x for pSendFIFOVc %x", pRemoteNode,pSendFIFOVc ) );

        //
        //  We check if the remote node's pdo is active. if so, then insert the Vc into the 
        //  PdoCb's list. Now responsibility for any removals has moved to the remove remote node code path
        // 

        //
        // Get the max buffer size that can be transmitted on this link
        //
        NdisStatus  = nicQueryRemoteNodeCaps (pAdapter,
                                              pRemoteNode,
                                              // FALSE,   // FALSE== not from cache.
                                              &Speed,
                                              &MaxBufferSize,
                                              &RemoteMaxRec);
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        ADAPTER_ACQUIRE_LOCK (pAdapter);

        if (REMOTE_NODE_ACTIVE (pRemoteNode) == FALSE)
        {
            NdisStatus = NDIS_STATUS_DEST_OUT_OF_ORDER;

            ADAPTER_RELEASE_LOCK (pAdapter);

            break;
        }


        //
        // Reference the call in the Vc as the RemoteNodePdo is about to have a pointer to it., This is dereferenced
        // in the CloseCallComplete Send Fifo Function. we have the lock
        //
        nicReferenceCall (pVc, "nicCmMakeCallInitSendFIFOVc");

        //
        // We keep the reference to pRemoteNode that was added by FindRemoteNode.
        // Derefed in SendFifoCloseCall when the pointer is nulled
        //
        fDeRefRemoteNode = FALSE;

        //
        // Insert the Vc into the Pdo's List
        //

        InsertTailList (&pRemoteNode->VcList, &pSendFIFOVc->Hdr.SinglePdoVcLink);

        TRACE( TL_V, TM_Cm, ( "Inserted Vc %x into Pdo List %x ", pSendFIFOVc, pRemoteNode) );



        //
        // This is not protected by the lock, but we are gauranteed that the Call will not be closed
        // and the Pdo will not be be removed from the system at this point, So  we can update
        // this field.
        //
        pSendFIFOVc->Hdr.pRemoteNode = pRemoteNode;


        
        ADAPTER_RELEASE_LOCK (pAdapter);

        
        //
        // Acquire the spin lock and initialize the structures
        //
        VC_ACQUIRE_LOCK (pSendFIFOVc);

        pSendFIFOVc->Hdr.MTU = pN1394Params->MTU;
    

        pSendFIFOVc->Hdr.pGeneration = &pAdapter->Generation; 

        pSendFIFOVc->FifoAddress = pN1394Params->Destination.FifoAddress;

        pSendFIFOVc->MaxSendSpeed = pN1394Params->MaxSendSpeed;

        pSendFIFOVc->Hdr.MaxPayload = min (pN1394Params->MTU, (ULONG)pN1394Params->MaxSendBlockSize); 


        VC_RELEASE_LOCK (pSendFIFOVc);



        //
        // Validate the parameters for the Vc
        //
        ASSERT(pSendFIFOVc->Hdr.pRemoteNode != NULL);
        ASSERT(pSendFIFOVc->Hdr.pRemoteNode->pPdo != NULL);
        ASSERT(pSendFIFOVc->Hdr.pGeneration != NULL);
        ASSERT(pSendFIFOVc->MaxSendSpeed != 0);
        ASSERT(pSendFIFOVc->Hdr.MTU != 0);
        

        TRACE( TL_V, TM_Cm, ( "    Generation is %x", *pSendFIFOVc->Hdr.pGeneration ) );
    
        TRACE( TL_N, TM_Cm, ( "    Pdo in the Send VC is %x", pSendFIFOVc->Hdr.pRemoteNode->pPdo) );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        
        pSendFIFOVc->MaxSendSpeed = min(pSendFIFOVc->MaxSendSpeed,Speed); 
        pSendFIFOVc->Hdr.MaxPayload = min (pSendFIFOVc->Hdr.MaxPayload, MaxBufferSize);

#ifdef LOWER_SEND_SPEED

        pSendFIFOVc->MaxSendSpeed = SCODE_200_RATE;//min(pSendFIFOVc->MaxSendSpeed,Speed); 
        
        pSendFIFOVc->Hdr.MaxPayload = ASYNC_PAYLOAD_200_RATE ;//  min(pSendFIFOVc->Hdr.MaxPayload, MaxBufferSize);
#endif

        TRACE( TL_V, TM_Cm, ( "    MaxSendSpeed  is %x", pSendFIFOVc->MaxSendSpeed) );
        TRACE( TL_V, TM_Cm, ( "    MaxPayload is %d", pSendFIFOVc->Hdr.MaxPayload ) );


    } while (FALSE);

    if ( NdisStatus != NDIS_STATUS_SUCCESS)
    {
        //
        // The Make is going to be failed asynchrnously
        // If we allocated in resources, we must free them
        // In this case, there have been no Resources allocated
        //


    }


        
    TRACE( TL_I, TM_Cm, ( "    pVc's Offset High %4x",pVc->Hdr.Nic1394MediaParams.Destination.FifoAddress.Off_High ) );
    TRACE( TL_I, TM_Cm, ( "    pVc's Offset Low %x",pVc->Hdr.Nic1394MediaParams.Destination.FifoAddress.Off_Low ) );


    TRACE( TL_T, TM_Cm, ( "<==NicCmMakeCallInitSendFIFOVc %x",NdisStatus ) );

    if (fDeRefRemoteNode)
    {
        nicDereferenceRemoteNode (pRemoteNode, FindRemoteNodeFromAdapterFail);
    }


    MATCH_IRQL;
    return NdisStatus;

}



NDIS_STATUS
nicCmMakeCallInitSendRecvChannelVc(
    IN OUT PVCCB pVc 
    )
    // Function Description:
    //
    // Arguments
    // pVc, This is the send fifo that needs to be initilaized
    //
    //
    // Return Value:
    //
    // Success if the irps sent to the driver succeed
    //
    //
        

{

    PCHANNEL_VCCB                                   pChannelVc = (PCHANNEL_VCCB)pVc;
    NDIS_STATUS                                     NdisStatus = NDIS_STATUS_FAILURE;
    PNIC1394_MEDIA_PARAMETERS             pN1394Params = NULL;
    PADAPTERCB                                      pAdapter = pVc->Hdr.pAF->pAdapter;
    ULONG                                           Channel = 64;
    HANDLE                                          hResource=NULL;
    ULONG                                           MaxBufferSize = 0; 
    ULONG                                           QuadletsToStrip = 0;
    PISOCH_DESCRIPTOR                               pIsochDescriptor = NULL;
    CYCLE_TIME                                      CycleTime;
    PDEVICE_OBJECT                                  ArrayRemotePDO[64];
    //NDIS_HANDLE                                       hPacketPoolHandle=NULL;
    BOOLEAN                                         fAnyChannel = FALSE;
    NIC_PACKET_POOL                                 PacketPool;
    STORE_CURRENT_IRQL;
   
    
    TRACE( TL_T, TM_Cm, ( "==>NicCmMakeCallInitSendRecvChannelVc pVc %x", pVc ) );
    

    ASSERT (pAdapter != NULL);

    pN1394Params = (PNIC1394_MEDIA_PARAMETERS)&pVc->Hdr.pCallParameters->MediaParameters->MediaSpecific.Parameters[0];

    Channel = pN1394Params->Destination.Channel;

    TRACE( TL_V, TM_Cm, ( "Channel %x", Channel ) );

    do 
    {
        PacketPool.Handle = NULL;
        
        ADAPTER_ACQUIRE_LOCK( pAdapter );


        //
        //  Set up the the VDO, so that all channel operations can use it
        //
        pVc->Hdr.pLocalHostVDO  = pAdapter->pNextDeviceObject;
        

        ADAPTER_RELEASE_LOCK( pAdapter );

        
        NdisAllocatePacketPoolEx ( &NdisStatus,
                                   &PacketPool.Handle,
                                   MIN_PACKET_POOL_SIZE,
                                   MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                   sizeof (RSVD) );
        
        if (PacketPool.Handle == NULL || NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Cm, ( "NdisAllocatePacketPoolEx FAILED" ) );
        }

        //
        // Reference Call for Packet Pool Handle
        //
        nicReferenceCall ((PVCCB)pChannelVc, "nicCmMakeCallInitSendRecvChannelVc - packet pool ");
        

        PacketPool.AllocatedPackets = 0;
        
        pChannelVc->Hdr.MTU = pN1394Params->MTU;
        pChannelVc->PacketPool= PacketPool;
        NdisInitializeEvent(&pChannelVc->LastDescReturned);


        //
        // This function should do its own cleanup
        //
        NdisStatus =  nicAllocateChannelResourcesAndListen (pAdapter,
                                                     pChannelVc );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Cm, ( "nicAllocateChannelResourcesAndListen  FAILED" ) );
        }
        //
        // Return the allocated channel number, if this is an any channel 
        // or broadcast channel call
        //
        if ((pN1394Params->Destination.Channel == NIC1394_ANY_CHANNEL) &&
           (pN1394Params->Destination.AddressType == NIC1394AddressType_Channel))
        {
            pN1394Params->Destination.Channel  = pChannelVc->Channel;   
        }

        //
        // Make the same change for broadcast channels
        //

        if ((pN1394Params->Destination.Channel == NIC1394_BROADCAST_CHANNEL) &&
           (pN1394Params->Destination.AddressType == NIC1394AddressType_Channel))
        {
            pN1394Params->Destination.Channel  = pChannelVc->Channel;   
        }


    }   while (FALSE);
        
    //
    // Time to do clean up based on what resources were allocated
    //
    if (NdisStatus != NDIS_STATUS_SUCCESS )
    {
        //Undo all resources acquired
        if (PacketPool.Handle != NULL)
        {
            //
            //  Free the pool
            //
            nicFreePacketPool(&PacketPool);

            nicDereferenceCall ((PVCCB)pChannelVc, "nicCmMakeCallInitSendRecvChannelVc - packet pool ");

            NdisZeroMemory (&pChannelVc->PacketPool, sizeof (pChannelVc->PacketPool));
        }

        //
        // Do not decrement any ref counts because if Status != success
        // then we have not incremented refcounts.
        //


    }

    TRACE( TL_T, TM_Cm, ( "<==NicCmMakeCallInitSendRecvChannelVc %x", NdisStatus) );

    return NdisStatus;
}







NDIS_STATUS
nicCmMakeCallInitEthernet (
    IN PVCCB pVc
    )
/*++

Routine Description:
  Do nothing for now. Just succeed 

Arguments:


Return Value:


--*/
{

    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PADAPTERCB          pAdapter = pVc->Hdr.pAF->pAdapter;
    PETHERNET_VCCB      pEthernetVc = (PETHERNET_VCCB)pVc;
    NIC_PACKET_POOL     PacketPool;
    
    TRACE( TL_T, TM_Cm, ( "==>nicCmMakeCallInitEthernet %x", pVc) );




    do
    {
        PacketPool.Handle = NULL;
        
        //
        // Initialize the PacketPool
        //

        NdisAllocatePacketPoolEx ( &NdisStatus,
                                   &PacketPool.Handle,
                                   MIN_PACKET_POOL_SIZE,
                                   MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                   sizeof (RSVD) );
        
        if (NdisStatus!= NDIS_STATUS_SUCCESS)
        {
            ASSERT(NdisStatus != NDIS_STATUS_SUCCESS);
            pEthernetVc->PacketPool.Handle = NULL;
            PacketPool.Handle = NULL;
            break;
        }



        
        NdisStatus = NDIS_STATUS_SUCCESS;
        //
        // No more failures
        //

        nicReferenceCall ((PVCCB)pEthernetVc, "Alloc PacketPool - Ethernet VC " ) ;
        
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // Reference the VC as the adapter has a pointer to it
        //
        nicReferenceCall (pVc, "nicCmMakeCallEthernet ");

        pAdapter->pEthernetVc = (PETHERNET_VCCB)pVc;
        

        pEthernetVc->PacketPool= PacketPool;
        pEthernetVc->PacketPool.AllocatedPackets = 0;

        ADAPTER_RELEASE_LOCK (pAdapter);

        

    } while (FALSE);


    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        if (PacketPool.Handle != NULL)
        {
            //
            //  Free the pool
            //
            nicFreePacketPool(&PacketPool);

        }
    }


    
    TRACE( TL_T, TM_Cm, ( "<==nicCmMakeCallEthernet  %x", NdisStatus) );
    return NdisStatus;

}


    
NDIS_STATUS
nicCmMakeCallMultiChannel (
    IN PVCCB pVc
    )
/*++

Routine Description:
    Do whatever the channel Vc does

Arguments:


Return Value:


--*/
{

    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    PADAPTERCB              pAdapter = pVc->Hdr.pAF->pAdapter;
    PCHANNEL_VCCB           pMcVc = (PCHANNEL_VCCB)pVc;
    NIC_PACKET_POOL         PacketPool;
    
    
    TRACE( TL_T, TM_Cm, ( "==>nicCmMakeCallMultiChannel  %x", pVc) );





    do
    {
        PacketPool.Handle = NULL;

        
        //
        // Initialize the PacketPool
        //

        NdisAllocatePacketPoolEx ( &NdisStatus,
                                   &PacketPool.Handle,
                                   MIN_PACKET_POOL_SIZE,
                                   MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                   sizeof (RSVD) );
        
        if (NdisStatus!= NDIS_STATUS_SUCCESS)
        {
            ASSERT(NdisStatus != NDIS_STATUS_SUCCESS);
            pMcVc->PacketPool.Handle = NULL;
            break;
        }



        
        NdisStatus = NDIS_STATUS_SUCCESS;
        //
        // No more failures
        //

        nicReferenceCall ((PVCCB)pMcVc, "Alloc PacketPool - MultiChannel VC " ) ;
        
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        

        pMcVc->PacketPool= PacketPool;
        pMcVc->PacketPool.AllocatedPackets = 0;

        pMcVc->Hdr.MTU =   pMcVc->Hdr.Nic1394MediaParams.MTU;

        ADAPTER_RELEASE_LOCK (pAdapter);


        if (pMcVc->Hdr.Nic1394MediaParams.Destination.ChannnelMap.QuadPart == 0)
        {

            pMcVc->Channel = 0xff;
            NdisStatus = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // This portion Not Implemented yet.  ChannelMap != 0
        // Should use nicAllocateResourcesAndListen after updating the 
        // Nic1394MediaParams to make it look like a regular ChannelMake Call
        //
        NdisStatus =  NDIS_STATUS_FAILURE;
        ASSERT (0);
        
    } while (FALSE);


    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        if (PacketPool.Handle != NULL)
        {
            //
            //  Free the pool
            //
            nicFreePacketPool(&PacketPool);

        }
    }



    TRACE( TL_T, TM_Cm, ( "<==nicCmMakeCallMultiChannel   %x", NdisStatus) );
    return NdisStatus;

}
    

NDIS_STATUS
nicCmMakeCallSendChannel (
    IN PVCCB pVc
    )
/*++

Routine Description:
   This function allocates the channel but does nothing else. 
   It is only used to send data and therefore needs no other data

    It needs to update pChannelVc->Channel; ulSynch; Speed;  
    all of which are needed to do an AsyncStream Irb
    

Arguments:


Return Value:


--*/
{
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PCHANNEL_VCCB       pChannelVc = (PCHANNEL_VCCB)pVc;
    BOOLEAN             fNeedToAllocate = VC_TEST_FLAG (pChannelVc, VCBF_NeedsToAllocateChannel);
    PADAPTERCB          pAdapter = pVc->Hdr.pAF->pAdapter;
    ULONG               Speed = 0;
    UINT                MaxPacketSize = 0;
    PNIC1394_MEDIA_PARAMETERS pN1394Params = (PNIC1394_MEDIA_PARAMETERS)&pChannelVc->Hdr.Nic1394MediaParams;
    ULONG               Channel = pN1394Params->Destination.Channel;
    
    TRACE( TL_T, TM_Cm, ( "==>nicCmMakeCallSendChannel pVc %x", pVc) );

    do 
    {

        //
        // Allocate the channel 
        // 
        if (fNeedToAllocate == TRUE)
        {
    
            NdisStatus = nicAllocateRequestedChannelMakeCallComplete (pAdapter, 
                                                               pChannelVc, 
                                                               &Channel);
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {   
                BREAK (TM_Cm, ("Unable to allocate Channel on Send Only Vc" ) );
            }

        }

        //
        // Find out the Speed. 
        //  
        if (pAdapter->Speed == 0)
        {
            nicUpdateLocalHostSpeed (pAdapter);
        }   


        pChannelVc->Speed = pAdapter->Speed;

        Speed = pAdapter->Speed;
            
        switch (pChannelVc->Speed)
        {
            case SPEED_FLAGS_100  : 
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_100_RATE;
                break;
            }
            case SPEED_FLAGS_200 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_200_RATE ;
                break;
            }
                
            case SPEED_FLAGS_400 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }

            case SPEED_FLAGS_800:                          
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }

            case SPEED_FLAGS_1600:                          
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }

            case SPEED_FLAGS_3200 :                         
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }

            default :
            {
                pChannelVc->Hdr.MaxPayload = ISOCH_PAYLOAD_400_RATE; 
                break;
            }

        }


        pChannelVc->Channel = Channel ;

        MaxPacketSize = min(pN1394Params->MTU + sizeof(GASP_HEADER) , pChannelVc->Hdr.MaxPayload);

        

        
        //
        // If broadcast channel, then decrease the speed setting, and fragment
        //

        
        
        pChannelVc->Channel = Channel;
        pChannelVc->MaxBufferSize = 0;
        pChannelVc->Speed = Speed;

        pChannelVc->Hdr.MaxPayload = MaxPacketSize;
        pChannelVc->Hdr.MTU = pN1394Params->MTU ; 

        pChannelVc->NumDescriptors = 0;
        pChannelVc->pIsochDescriptor = NULL;


        NdisStatus = NDIS_STATUS_SUCCESS;




    } while (FALSE);



    TRACE( TL_T, TM_Cm, ( "<==nicCmMakeCallSendChannel %x", NdisStatus) );

    return NdisStatus;
}










VOID
nicCmMakeCallCompleteFailureCleanUp(
    IN OUT PVCCB pVc 
    )

    // Function Description:
    // This function cleans up, if the makecallcomplete fails for whatever reason.
    // Maybe this should be split up as well
    // In the RecvFIFOVc case: it needs to deallocate the Slist and PacketPool, 
    // Common:
    // Also delete the VcType and nic1394 destination in the Vc Hdr
    // Arguments
    // PVCCB pVc - Vc that needs to be cleaned up
    //
    // Return Value:
    // 
    //  

{

    STORE_CURRENT_IRQL;
        
    TRACE( TL_T, TM_Cm, ( "==>nicCmMakeCallCompleteFailureCleanUp pVc %x", pVc ) );
    
    switch (pVc->Hdr.VcType)
    {

        case NIC1394_RecvFIFO:
        {
            PRECVFIFO_VCCB pRecvFIFOVc = (PRECVFIFO_VCCB )pVc;

            TRACE( TL_V, TM_Cm, ( "Cleaning up a recv FIFo %x", pVc ) );

            if (pRecvFIFOVc->PacketPool.Handle != NULL)
            {
                nicFreePacketPool (&pRecvFIFOVc->PacketPool);
            }
            pRecvFIFOVc->PacketPool.Handle = NULL;

            if (pRecvFIFOVc->FifoSListHead.Alignment != 0)
            {
                nicFreeAllocateAddressRangeSList (pRecvFIFOVc);
            }

            pRecvFIFOVc->FifoSListHead.Alignment = 0;
            
            break;
        }


        case NIC1394_SendFIFO:
        case NIC1394_SendRecvChannel:
        case NIC1394_SendChannel:
        case NIC1394_RecvChannel:

        default:
            break;
    }



    //
    // This call does the generic clean up
    //
    nicCmGenrericMakeCallFailure (pVc);

    
    TRACE( TL_T, TM_Cm, ( "<==nicCmMakeCallCompleteFailureCleanUp ") );

    MATCH_IRQL;
    return ;
}





NDIS_STATUS
NicCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size )

    // Standard 'CmCloseCallHandler' routine called by NDIS when the a client
    // has requested to tear down a call.  See DDK doc.
    //
{
    NDIS_STATUS NdisStatus                      = NDIS_STATUS_FAILURE;
    ADAPTERCB* pAdapter                         = NULL;
    VCCB* pVc                                   = NULL;
    NDIS_WORK_ITEM* pCloseCallCompleteWorkItem  = NULL;
    

    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Cm, ( "==>NicCmCloseCall($%p)", CallMgrVcContext ) );

    pVc = (VCCB* )CallMgrVcContext;

    if (pVc->Hdr.ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    
    do 
    {
        pAdapter = pVc->Hdr.pAF->pAdapter;

        if (pAdapter == NULL)
        {
            TRACE( TL_A, TM_Cm, ( "pAdpater is NULL - Make Call FAILED($%p)", CallMgrVcContext ) );
        
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        VC_ACQUIRE_LOCK (pVc);

        //
        // If the Make Call is Pending, then fail the CloseCall. 
        // Or if there call is already closing then fail this close call
        //

        if ( VC_ACTIVE (pVc) == FALSE )
        {
            TRACE( TL_A, TM_Cm, ( "NicCmCloseCall Invalid flags - Close Call FAILED Vc $%p, flags %x", pVc, pVc->Hdr.ulFlags ) );

            ASSERT ( ! "MakeCallPending or Call already closed?");

            VC_RELEASE_LOCK (pVc);
            break;
        }

        //
        //
        // Reference the Vc so we can gaurantee its presence till the end of the work item
        // to CloseCallComplete. we have the lock
        //
        nicReferenceVc (pVc);

        //
        // Mark the Call as closing, and close the refcount, so no one can increment it
        //
        VC_SET_FLAG ( pVc, VCBF_CloseCallPending); 

        nicCloseCallRef (pVc);

        VC_RELEASE_LOCK (pVc);

        pCloseCallCompleteWorkItem = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM); 

        if (pCloseCallCompleteWorkItem == NULL)
        {
            TRACE( TL_A, TM_Cm, ( "Local Alloc failed for WorkItem - Close Call FAILED($%p)", CallMgrVcContext ) );
            
            NdisStatus = NDIS_STATUS_RESOURCES;

            break;
        }
        
        NdisInitializeWorkItem ( pCloseCallCompleteWorkItem, 
                            (NDIS_PROC)nicCmCloseCallComplete,
                            (PVOID)pVc );

        NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

       
        NdisScheduleWorkItem (pCloseCallCompleteWorkItem);

        NdisStatus = NDIS_STATUS_PENDING;


    } while (FALSE);
    
    MATCH_IRQL;
    
    TRACE( TL_T, TM_Cm, ( "<==NicCmCloseCall pending" ) );


    return NdisStatus;
}


VOID
nicCmCloseCallComplete(
    NDIS_WORK_ITEM* pCloseCallCompleteWorkItem,     
    IN PVOID Context 
    )
    // Function Description:
    // This function completes the close call. The qor Item gaurantees that all work will be
    // done at passive level    
    //
    // Arguments
    // Context : Which is VCCB for  which the close call was requested
    //
    //
    // Return Value:
    // None  
    // However an NdisStatus is passed in the call to Ndis' close call complete  function   
    //
    //

{
    NDIS_STATUS NdisStatus  = NDIS_STATUS_FAILURE;
    PVCCB pVc               = (PVCCB) Context;
    PADAPTERCB pAdapter       = pVc->Hdr.pAF->pAdapter;
    BOOLEAN fCallClosable   = FALSE;
    BOOLEAN fWaitSucceeded = FALSE;

    STORE_CURRENT_IRQL;



    TRACE( TL_T, TM_Cm, ( "==>nicCmCloseCallComplete pVc %x", pVc ) );


    //
    // Invoke the close call handler of the VC
    //
    ASSERT (pVc->Hdr.VcHandlers.CloseCallHandler != NULL);
    
    NdisStatus = (*pVc->Hdr.VcHandlers.CloseCallHandler) (pVc);
     
    //
    // right now, we do not fail a close call because the bus driver failed us.
    //
    NdisStatus = NDIS_STATUS_SUCCESS;
    //
    // Made it so far, we now need to dereference the call. We made the reference in 
    // MakeCall. This will complete the call if it gets down to zero
    // 
    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        //
        // Derefercence the call ref and Vc Refs that were added at the end of 
        // a successful make call
        //
        nicDereferenceCall (pVc, "nicCmCloseCallComplete");

    
    }

    //
    // Important : THIS WAIT is for the REFCOUNT on the CALL , not the VC
    //
    TRACE( TL_N, TM_Cm, ( "About to Wait for CallRefs to go to zero pVc %x ", pVc) );

    fWaitSucceeded = NdisWaitEvent (&pVc->Hdr.CallRef.RefZeroEvent, WAIT_INFINITE );

    if (fWaitSucceeded == FALSE)
    {
        TRACE( TL_A, TM_Cm, ( "Wait Timed Out Call, Vc %x, RefCount %x ", pVc , pVc->Hdr.CallRef.ReferenceCount) );

        ASSERT (fWaitSucceeded == TRUE);
    }


    ASSERT (KeGetCurrentIrql() <= DISPATCH_LEVEL);
    //
    // Succeed the Close call as all references have gone to zero
    // The call has no more outstanding resources
    //

    TRACE( TL_N, TM_Cm, ( "About to Close Call on pVc %x", pVc ) );

    NdisMCmCloseCallComplete( NDIS_STATUS_SUCCESS,
                           pVc->Hdr.NdisVcHandle, NULL );
                           
    

    VC_ACQUIRE_LOCK (pVc);

    VC_CLEAR_FLAGS (pVc, VCBF_CloseCallPending); 
    VC_SET_FLAG (pVc, VCBF_CloseCallCompleted);

    VC_RELEASE_LOCK (pVc);

    FREE_NONPAGED (pCloseCallCompleteWorkItem);
    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);

    //
    // Release the reference made when entering the Close Call function above. so the Vc can disappear if it wants to
    // Remember that delete Vc can already have gone through at this time, and the Vc will be freed after the deref
    //
    nicDereferenceVc (pVc);

    
    TRACE( TL_T, TM_Cm, ( "<==nicCmCloseCallComplete pVc %x, Status %x", pVc, NdisStatus  ) );

    MATCH_IRQL;
    
}


NDIS_STATUS
nicCmCloseCallEthernet (
    IN PVCCB pVc
    )
/*++

Routine Description:
  Do nothing for now. Just succeed 

Arguments:


Return Value:


--*/
{

    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PADAPTERCB          pAdapter = pVc->Hdr.pAF->pAdapter;
    PETHERNET_VCCB      pEthernetVc = (PETHERNET_VCCB)pVc;
    NIC_PACKET_POOL     PacketPool;

    
    TRACE( TL_T, TM_Cm, ( "==>nicCmCloseCallEthernet  %x", pVc) );


    ADAPTER_ACQUIRE_LOCK (pAdapter);
    
    PacketPool = pEthernetVc->PacketPool;

    pEthernetVc->PacketPool.Handle = 0;
    pEthernetVc->PacketPool.AllocatedPackets = 0;
    
    ADAPTER_RELEASE_LOCK (pAdapter);

    if (PacketPool.Handle != NULL)
    {
        nicDereferenceCall ((PVCCB)pEthernetVc, "pEthernetVc - Free PacketPool" );
        nicFreePacketPool (&PacketPool);

    }


    ADAPTER_ACQUIRE_LOCK (pAdapter);

    //
    // Dereference the VC as the adapter's pointer has been cleared 
    //
    nicDereferenceCall (pVc, "nicCmMakeCallEthernet ");

    pAdapter->pEthernetVc = NULL;
    
    ADAPTER_RELEASE_LOCK (pAdapter);





    NdisStatus = NDIS_STATUS_SUCCESS;
    TRACE( TL_T, TM_Cm, ( "<==nicCmCloseCallEthernet  %x", NdisStatus) );
    return NdisStatus;

}


    
NDIS_STATUS
nicCmCloseCallMultiChannel (
    IN PVCCB pVc
    )
/*++

Routine Description:
  Free the packet pool and  Just succeed 

Arguments:


Return Value:


--*/
{

    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    PADAPTERCB              pAdapter = pVc->Hdr.pAF->pAdapter;
    PCHANNEL_VCCB           pMcVc = (PCHANNEL_VCCB)pVc;
    NIC_PACKET_POOL         PacketPool;
    
    TRACE( TL_T, TM_Cm, ( "==>nicCmCloseCallMultiChannel  %x", pVc) );

    ASSERT (VC_TEST_FLAG (pVc, VCBF_BroadcastVc) == FALSE);

    //
    // Mask the fact that this is a multichannel Call
    //
    
    NdisStatus = nicCmCloseCallSendRecvChannel  (pVc);


    //
    // Nothing to fail
    //
    NdisStatus = NDIS_STATUS_SUCCESS;

    TRACE( TL_T, TM_Cm, ( "<==nicCmCloseCallMultiChannel   %x", NdisStatus) );
    return NdisStatus;

}
    


NDIS_STATUS
nicCmCloseCallSendRecvChannel (
    IN PVCCB pVc 
    )
    // Function Description:
    // This function will do clean up for RecvFifos
    // Includes removing the VC pointer from Pdo Adapter structure.
    // And needs to go through all active remote nodes and free the address ranges on them
    // The BCM Vc has the added overhead of having an address range associated with it. 
    //  which we need to free 
    //
    // Arguments
    // PVCCB pVc - The Channel VC that needs to be closed
    //
    // Return Value:
    // Success for now
    //
    // Called with the lock held

{
    PCHANNEL_VCCB       pChannelVc = (PCHANNEL_VCCB ) pVc;
    PCHANNEL_VCCB       pTempVc = NULL;
    BOOLEAN             fIsBroadcastVc =  FALSE;
    PLIST_ENTRY         pVcListEntry = NULL;
    PADAPTERCB          pAdapter = NULL; 
    ULONG               NumDereferenced ;
    HANDLE              hResource ;
    ULONG               NumDescriptors ;
    PISOCH_DESCRIPTOR   pIsochDescriptor;
    BOOLEAN             fAllocatedChannel ;
    ULONG               Channel ;
    NIC_PACKET_POOL     PacketPool;

    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Cm, ( "==> nicCmCloseCallSendRecvChannel pVc %x", pVc) );

    ASSERT (pVc!=NULL);
    pAdapter = pChannelVc->Hdr.pAF->pAdapter;
    ASSERT (pAdapter != NULL);
    do 
    {
        



        VC_ACQUIRE_LOCK (pChannelVc);

        if (VC_TEST_FLAG (pChannelVc, VCBF_BroadcastVc) == TRUE)
        {
            PADDRESS_RANGE_CONTEXT pBCRAddress = &pAdapter->BCRData.AddressRangeContext;
            
            //
            // Free the allocated address renge for the Broadcast Channel Register
            //
            if ( BCR_TEST_FLAG (pAdapter, BCR_Initialized) == TRUE)
            {

                //
                // Clear out the Broadcast VC in the BCRData structure, Derereference the call. and clear the flag
                // The ref was made in the MakeCallAllocateChannel function 
                //
                if (pAdapter->BCRData.pBroadcastChanneVc  != NULL)
                {
                    pAdapter->BCRData.pBroadcastChanneVc = NULL;

                    nicDereferenceCall((PVCCB) pChannelVc, "nicCmCloseCallSendRecvChannel Broadcast VC");       
                }
                VC_CLEAR_FLAGS (pChannelVc, VCBF_BroadcastVc) ;
                        
            }

        }
        
        VC_RELEASE_LOCK (pChannelVc);
        
        nicIsochStop (pAdapter,
                      pChannelVc->hResource);
        

        VC_ACQUIRE_LOCK (pChannelVc);
        
        PacketPool = pChannelVc->PacketPool;

        hResource = pChannelVc->hResource;

        NumDescriptors = pChannelVc->NumDescriptors;

        pIsochDescriptor = pChannelVc->pIsochDescriptor;

        fAllocatedChannel = VC_TEST_FLAGS( pChannelVc, VCBF_AllocatedChannel);

        Channel =   pChannelVc->Channel;

        PacketPool = pChannelVc->PacketPool;

        //
        // Clean out the VC structure and then call NDIS or the bus driver to free all
        // the resources
        //
        nicChannelCallCleanDataStructure  (pChannelVc,
                                           pChannelVc->hResource,
                                           pChannelVc->NumDescriptors,
                                           pChannelVc->pIsochDescriptor,
                                           fAllocatedChannel, 
                                           pChannelVc->Channel,
                                           pChannelVc->PacketPool.Handle,
                                           &NumDereferenced );

        
        VC_RELEASE_LOCK (pChannelVc);

            
        nicChannelCallFreeResources ( pChannelVc,
                                   pAdapter,
                                   hResource,
                                   NumDescriptors,
                                   pIsochDescriptor,
                                   fAllocatedChannel, 
                                   Channel,
                                   &PacketPool);
    
        
        
    } while (FALSE);
    

    TRACE( TL_T, TM_Cm, ( "<== nicCmCloseCallSendRecvChannel Status %x(always success)" ) );
    MATCH_IRQL;
    
    return NDIS_STATUS_SUCCESS;

}



NDIS_STATUS
nicCmCloseCallRecvFIFO (
    IN PVCCB pVc 
    )
    // Function Description:
    // This function will do clean up for RecvFifos
    // Includes removing the VC pointer from Pdo Adapter structure.
    // And needs to go through all active remote nodes and free the address ranges on them
    // 
    // 
    // Arguments
    // PVCCB pVc - The SendFifo that needs to be closed
    //
    // Return Value:
    // Success for now
    //

{
    NDIS_STATUS NdisStatus          = NDIS_STATUS_FAILURE;
    PRECVFIFO_VCCB pRecvFIFOVc      = (PRECVFIFO_VCCB)pVc;
    PADDRESS_FIFO pAddressFifo      = NULL;
    PSINGLE_LIST_ENTRY pAddressFifoEntry = NULL;
    PADAPTERCB pAdapter             = pVc->Hdr.pAF->pAdapter;

        
    TRACE( TL_T, TM_Cm, ( "==> nicCmCloseCallRecvFIFO pVc %x", pVc) );

    NdisStatus = nicFreeAddressRange( pAdapter,
                                     pRecvFIFOVc->AddressesReturned,
                                     &pRecvFIFOVc->VcAddressRange,
                                     &pRecvFIFOVc->hAddressRange    );

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_I, TM_Cm, ( "Call to Free Address Range Failed pVc at %x",pVc ) );

        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

        //
        // Do not Break. Continue
        //
        NdisStatus = NDIS_STATUS_SUCCESS;
        
    }

    pRecvFIFOVc->hAddressRange  = NULL;
    pRecvFIFOVc->AddressesReturned = 0;
    pRecvFIFOVc->VcAddressRange.AR_Off_High = 0;
    pRecvFIFOVc->VcAddressRange.AR_Off_Low = 0;
    
    

    nicDereferenceCall ((PVCCB)pRecvFIFOVc, 
                        "nicCmCloseCallRecvFIFO  - Free address range" );

    nicFreePacketPool (&pRecvFIFOVc->PacketPool);

    //
    // Free the Slist Entries (AddressFifo, Mdl's) and their associated memory 
    // and decrease the refcount for each entry
    //
    
    nicFreeAllocateAddressRangeSList (pRecvFIFOVc);

    //
    // At this point all the resources of the call have been exhuasted and we can del the pointer in the adapter structure
    // 
    VC_ACQUIRE_LOCK (pVc);

    pVc->Hdr.pAF->pAdapter->pRecvFIFOVc = NULL;

    VC_RELEASE_LOCK (pVc);

    //
    // Decrement the Vc Refcount as the adapter no longer has a pointer to it
    //
    nicDereferenceVc (pVc);

    TRACE( TL_T, TM_Cm, ( "<== nicCmCloseCallRecvFIFO Status %x", NdisStatus) );

    return NdisStatus;
}







NDIS_STATUS
nicCmCloseCallSendFIFO (
    IN PVCCB pVc 
    )
    // Function Description:
    // This function will do clean up for Send Fifos
    // Includes removing the pointer to the Vc that is in Pdo Adapter structure.
    // For the Send FIFO, the Pdo block is in the pVc->Hdr.pRemoteNode location, so 
    // this does not try and find the pRemoteNode
    // Arguments
    // PVCCB pVc - The SendFifo that needs to be closed
    //
    // Return Value:
    // Success for now
    //
{
    NDIS_STATUS NdisStatus      = NDIS_STATUS_FAILURE;
    REMOTE_NODE * pRemoteNode               = pVc->Hdr.pRemoteNode;
    PLIST_ENTRY pVcListEntry    = NULL;
    PSENDFIFO_VCCB pTempVc      = NULL;
    BOOLEAN fVcFound            = FALSE;
    
    TRACE( TL_T, TM_Cm, ( "==> nicCmCloseCallSendFIFO pVc %x", pVc) );


    //
    // SendComplete Handler will complete the close call.
    // This thread should not do it
    // Called in nicFreeSendPacketDataStructures
    //

    //
    // Go through the PdoCb structure and remove the VC from it's VC List
    //
    
    ASSERT (pRemoteNode != NULL);

    VC_ACQUIRE_LOCK (pVc);
    
    for (pVcListEntry = pRemoteNode->VcList.Flink;
        pVcListEntry != &pRemoteNode->VcList;
        pVcListEntry = pVcListEntry->Flink)
    {
        pTempVc = (PSENDFIFO_VCCB) CONTAINING_RECORD (pVcListEntry, VCHDR, SinglePdoVcLink);

        //
        // Now remove the Vc from that linked list
        //
        if (pTempVc == (PSENDFIFO_VCCB) pVc )
        {

            nicRemoveEntryList (pVcListEntry);          
            
            TRACE( TL_V, TM_Cm, ( "==> Removed Vc %x From Pdo's Vc List ", pVc) );

            //
            // Remove the reference from the Vc as the Pdo no longer
            // has a pointer to it. This ref was made in MakeCallInitSendFifo
            //
            nicDereferenceCall (pVc, "nicCmCloseCallSendFIFO ");
            
            NdisStatus = NDIS_STATUS_SUCCESS;
            break;
        }


    }
        
    //
    // Decerement the Ref on the Pdo as the Vc no longer has a pointer to it.
    // This Ref was made in MakeCallSendFifo function
    //

    nicDereferenceRemoteNode (pRemoteNode, FindRemoteNodeFromAdapter);
    
    //
    // Null, it so that if we try to access this pointer, we bugcheck 
    //
    pVc->Hdr.pRemoteNode = NULL;

    VC_RELEASE_LOCK (pVc);

    //
    // There is no reason why we should not have found the Vc in the Pdo list
    //
    ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

    TRACE( TL_T, TM_Cm, ( "<== nicCmCloseCallSendFIFO Status %x", NdisStatus) );

    NdisStatus = NDIS_STATUS_SUCCESS;
    
    return NdisStatus;
}




NDIS_STATUS
nicCmCloseCallSendChannel(
    IN PVCCB pVc 
    )
/*++

Routine Description:

  Free the channel, if its been allocated
  
Arguments:


Return Value:


--*/
{
    PADAPTERCB pAdapter = (PADAPTERCB) pVc->Hdr.pAF->pAdapter;
    PCHANNEL_VCCB pChannelVc = (PCHANNEL_VCCB)pVc;

    TRACE( TL_T, TM_Cm, ( "==>nicCmCloseCallSendChannel " ) );

    if (VC_TEST_FLAG (pVc,VCBF_AllocatedChannel) == TRUE)
    {
        nicFreeChannel (pAdapter, pChannelVc->Channel);
        nicDereferenceCall ((PVCCB)pChannelVc, "Close Call - Send Channel - Freeing Channel" );
    }
    
    TRACE( TL_T, TM_Cm, ( "<==nicCmCloseCallSendChannel " ) );
    return NDIS_STATUS_SUCCESS;

}






VOID
nicChannelCallFreeResources ( 
    IN PCHANNEL_VCCB            pChannelVc,
    IN PADAPTERCB               pAdapter,
    IN HANDLE                   hResource,
    IN ULONG                    NumDescriptors,
    IN PISOCH_DESCRIPTOR        pIsochDescriptor,
    IN BOOLEAN                  fChannelAllocated,
    IN ULONG                    Channel,
    IN PNIC_PACKET_POOL         pPacketPool
    
    )
    // Function Description:
    //  This function is called from Close call or MakeCall Failure code path.
    //  It will detach buffers, free resources, free channel and free bandwdith. 
    //  It is the responsibility of the caller to do all the appropriate ref counting
    //
    // Arguments
    //
    // pAdapter             contains the VDO to which all the IRPs were sent
    // hResource            resource handle to be used by the bus driver,
    // NumDescriptors       Number of descriptors attached to the buffer,
    // pIsochDesciptor      Original pointer to the start of the Buffer Descriptor  ,
    // Channel, -           Channel that was allocated
    //
    // Return Value:
    //    Success if all irps completed succeesfully. Wil be ignored by called
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    STORE_CURRENT_IRQL;
    TRACE( TL_T, TM_Cm, ( "==>nicChannelCallFreeResources " ) );
    TRACE( TL_V, TM_Cm,  ( "hResource %x, NumDescriptors %.2x, pIsochDescriptor %x, Channel Allocated %.2x, Channel %x",
                             hResource, NumDescriptors, pIsochDescriptor, fChannelAllocated, Channel ) )

    //
    // Reference the pdo structure so it will be around until the end
    // of this function
    // Reference decremented at the end of this function
    //
    
    ADAPTER_ACQUIRE_LOCK (pAdapter);
    nicReferenceAdapter (pAdapter, "nicChannelCallFreeResources ");
    ADAPTER_RELEASE_LOCK (pAdapter);

    //
    // Do not break out of the loop.   We need to try and free as much as possible
    //

    if (pIsochDescriptor != NULL)
    {   
        // Detach Buffers
        //
        while (pChannelVc->NumIndicatedIsochDesc != 0 )
        {
            //
            // we will wait for ever, checking periodically for all the packets to return
            //
            TRACE( TL_V, TM_Cm, ( "  nicChannelCallFreeResources  - Sleeping to wait for packets to be retuerned " ) );
        
            NdisMSleep ( FIFTY_MILLISECONDS );      

        }

        NdisStatus = nicIsochDetachBuffers( pAdapter,
                                            hResource,
                                            NumDescriptors,
                                            pIsochDescriptor );
                                        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "nicIsochDetachBuffers FAILED " ) );
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);             
        }


        // First Free Isoch Descriptors and their associated MDLs
        //
        nicFreeIsochDescriptors (NumDescriptors, pIsochDescriptor, (PVCCB)pChannelVc);
    }

    if (hResource != NULL)
    {

        // Free resources
        //
        NdisStatus = nicIsochFreeResources( pAdapter,
                                            hResource );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "nicIsochFreeResources   FAILED " ) );
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);             
        }
                             


    }

    if (fChannelAllocated == TRUE)
    {
        PULONGLONG pLocalHostChannels = &pAdapter->ChannelsAllocatedByLocalHost; 
        
        ASSERT (Channel < NIC1394_MAX_NUMBER_CHANNELS);
        
        // Free the Channel
        //

        NdisStatus = nicFreeChannel (pAdapter,
                                     Channel);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "nicIsochFreeChannel   FAILED " ) );
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);             
            
        }

        //
        // Clear the bit in the adapter;s channel bitmap
        //
        VC_ACQUIRE_LOCK (pChannelVc);

        (*pLocalHostChannels)= ((*pLocalHostChannels)  & (~(g_ullOne <<Channel)));


        VC_CLEAR_FLAGS( pChannelVc, VCBF_AllocatedChannel);

        VC_RELEASE_LOCK (pChannelVc);


                      
    }

    if (pPacketPool->Handle != NULL)
    {
        nicFreePacketPool(pPacketPool);
    }   

    //
    // Remove The Ref that was added in the beginning of the function
    //

    nicDereferenceAdapter (pAdapter, "nicChannelCallFreeResources ");


    MATCH_IRQL;

    TRACE( TL_T, TM_Cm, ( "<==nicChannelCallFreeResources " ) );
}




VOID
nicChannelCallCleanDataStructure ( 
    IN PCHANNEL_VCCB            pChannelVc,
    IN HANDLE                   hResource,
    IN ULONG                    NumDescriptors,
    IN PISOCH_DESCRIPTOR        pIsochDescriptor,
    IN BOOLEAN                  fChannelAllocated,
    IN ULONG                    Channel,
    IN NDIS_HANDLE              hPacketPoolHandle,
    OUT PULONG                  pNumRefsDecremented 
    )
    // Function Description:
    //    If any of the data fields in the ChannelVc match the
    //    corresponding argument in this structure it will be 
    //    NULLed out and the call dereferenced
    //
    //   Called with the lock held.
    //
    // Arguments
    // PCHANNEL_VCCB            pChannelVc,  - Channel Vc 
    // HANDLE                   hResource,  - Handle to resource
    // ULONG                    NumDescriptors, - Num descriptors will be set to zero
    // PISOCH_DESCRIPTOR        pIsochDesciptor,  - Pointer to array of isoch descriptors
    // BOOLEAN                  fChannelAllocated, - Was the Channel allocated
    // ULONG                    Channel,  - channel number
    // NDIS_HANDLE              hPacketPoolHandle - Packet pool handle
    //
    //
    //
    // Return Value:
    //
    //
    //
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    ULONG NumRefsDecremented      = 0;
    TRACE( TL_T, TM_Cm, ( "==>nicChannelCallCleanDataStructure " ) );

    TRACE( TL_V, TM_Cm,  ( "hResource %x, NumDescriptors %.2x, pIsochDescriptor %x, Channel Allocated %.2x, Channel %x",
                             hResource, NumDescriptors, pIsochDescriptor, fChannelAllocated, Channel ) )

    if (pChannelVc == NULL)
    {
        return ;
    }

    if ((pChannelVc->NumDescriptors  == NumDescriptors )&&
       (pChannelVc->pIsochDescriptor  == pIsochDescriptor ) &&
       pIsochDescriptor != NULL )
    {
        pChannelVc->NumDescriptors   = 0;   
        pChannelVc->pIsochDescriptor   = NULL;
        nicDereferenceCall ((PVCCB)pChannelVc, "nicChannelCallCleanDataStructure Detach Buffers ");
        NumRefsDecremented    ++;
    }

    if (hResource != NULL && pChannelVc->hResource == hResource)
    {
        pChannelVc->hResource = NULL;
        nicDereferenceCall ((PVCCB)pChannelVc, "nicChannelCallCleanDataStructure Free Resource ");
        NumRefsDecremented    ++;
    }


    if (fChannelAllocated == TRUE)
    {
        ASSERT ( VC_TEST_FLAG (pChannelVc, VCBF_AllocatedChannel) == TRUE);
        VC_CLEAR_FLAGS (pChannelVc, VCBF_AllocatedChannel);

        pChannelVc->Channel = INVALID_CHANNEL; 
        
        nicDereferenceCall ((PVCCB)pChannelVc, "nicChannelCallCleanDataStructure - Free Channel");
        NumRefsDecremented    ++;

    }

    if (hPacketPoolHandle != NULL && pChannelVc->PacketPool.Handle == hPacketPoolHandle)
    {
        pChannelVc->PacketPool.Handle  = NULL;
        nicDereferenceCall ((PVCCB)pChannelVc, "nicChannelCallCleanDataStructure  - Packet Pool");
        NumRefsDecremented    ++;
    }


    
    //REMOTE_NODE_RELEASE_LOCK (pRemoteNodePdoCb);
    
    //
    // Remove The Ref that was added in the beginning of the function
    //

    NdisStatus = NDIS_STATUS_SUCCESS;


    if (pNumRefsDecremented  != NULL)
    {
        *pNumRefsDecremented      = NumRefsDecremented   ;
    }

    TRACE( TL_T, TM_Cm, ( "<==nicChannelCallCleanDataStructure %x", *pNumRefsDecremented     ) );
}




NDIS_STATUS
NicCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmModifyQoSCallHandler' routine called by NDIS when a client
    // requests a modification in the quality of service provided by the
    // virtual circuit.  See DDK doc.
    //
{
    TRACE( TL_T, TM_Cm, ( "NicCmModQoS" ) );

    // There is no useful concept of quality of service for IP media.
    //
    return NDIS_STATUS_NOT_SUPPORTED;
}






NDIS_STATUS
NicCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST pNdisRequest )

    // Standard 'CmRequestHandler' routine called by NDIS in response to a
    // client's request for information from the call manager.
    //
{
    AFCB* pAF;
    VCCB* pVc;
    NDIS_STATUS NdisStatus;

    TRACE( TL_T, TM_Cm, ( "==>NicCmReq" ) );

    pAF = (AFCB*) CallMgrAfContext;

    if (pAF->ulTag != MTAG_AFCB )
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pVc = (VCCB* )CallMgrVcContext;

    if (pVc && pVc->Hdr.ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    #if TODO // Add 1394-specific functionality here.
    #endif
    ASSERT(pNdisRequest != NULL);
    
    switch (pNdisRequest->RequestType)
    {
        case NdisRequestQueryStatistics:
        case NdisRequestQueryInformation:

        {
            NdisStatus = nicCmQueryInformation(
                CallMgrAfContext,
                CallMgrVcContext,
                CallMgrPartyContext,
                pNdisRequest->DATA.QUERY_INFORMATION.Oid,
                pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                &pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                &pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded );
            break;
        }

        case NdisRequestSetInformation:
        {
            
            NdisStatus = nicCmSetInformation(
                CallMgrAfContext,
                CallMgrVcContext,
                CallMgrPartyContext,
                pNdisRequest->DATA.SET_INFORMATION.Oid,
                pNdisRequest->DATA.SET_INFORMATION.InformationBuffer,
                pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength,
                &pNdisRequest->DATA.SET_INFORMATION.BytesRead,
                &pNdisRequest->DATA.SET_INFORMATION.BytesNeeded );
            break;
        }

        
        default:
        {
            NdisStatus = NDIS_STATUS_NOT_SUPPORTED;
            TRACE( TL_A, TM_Mp, ( "type=%d?", pNdisRequest->RequestType ) );
            break;
        }
    }

    TRACE( TL_T, TM_Cm, ( "<==NicCmReq" ) );
    
    return NdisStatus;
}



VOID
nicDereferenceAF(
    IN AFCB* pAF )

    // Removes a reference from the address family of adapter control block
    // 'pAdapter', and when frees the block when the last reference is
    // removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement (&pAF->lRef);

    TRACE( TL_T, TM_Ref, ( "DerefAf to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        ADAPTERCB* pAdapter = pAF->pAdapter;

        // Remove linkages.
        //
        ADAPTER_ACQUIRE_LOCK (pAdapter);
        
        pAF->pAdapter = NULL;

        nicRemoveEntryList (&pAF->linkAFCB);
        
        InitializeListHead (&pAF->linkAFCB);

        
        ADAPTER_RELEASE_LOCK (pAdapter);

        // Tell NDIS it's close is complete.
        //

        ASSERT ( nicReadFlags (&pAF->ulFlags) & ACBF_ClosePending);
        
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseAfComp Af %x",pAF ) );
        
        NdisMCmCloseAddressFamilyComplete( 
                     NDIS_STATUS_SUCCESS, pAF->NdisAfHandle );

        //
        // Update State information to show that we have called CloseComplete
        //
        nicSetFlags ( &pAF->ulFlags, ACBF_CloseComplete);
        nicClearFlags ( &pAF->ulFlags, ACBF_ClosePending);

        nicDereferenceAdapter (pAdapter, "NdisMCmCloseAfComp "); // nicDereferenceFA (CloseAfComp)

        nicFreeAF (pAF);

        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseAfComp done Af %x", pAF ) );

    }
}


BOOLEAN
nicDereferenceCall(
    IN VCCB* pVc,
    IN PCHAR pDebugPrint
    )

    // Removes a reference from the call active on 'pVc', invoking call clean
    // up when the value reaches zero.
    //
    // CAlled with the lock held
{
    BOOLEAN bRefZero = FALSE;
    LONG RefCount;
    //
    // If the Ref goes to zero, derefref return true
    // 
    

    bRefZero = nicDereferenceRef (&pVc->Hdr.CallRef, &RefCount);

    TRACE( TL_V, TM_Ref, ( "***DerefCall %x to %d , %s" , pVc, RefCount, pDebugPrint  ) );

    if ( bRefZero == TRUE)
    {
        //
        // Dereference the Vc as the Call no longer exists. This reference was
        // added in the beginning of the make call
        nicDereferenceVc (pVc);

    }
    
    return bRefZero;
 
}


VOID
nicDereferenceVc(
    IN VCCB* pVc )

    // Removes a reference to the VC control block 'pVc', and when frees the
    // block when the last reference is removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pVc->Hdr.lRef );

    TRACE( TL_V, TM_Ref, ( "DerefVC to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0 )
    {
        // If close call is pending and the refcount has gone to zero, then call 
        // 

        ASSERT( pVc->Hdr.ulTag == MTAG_VCCB );

        pVc->Hdr.ulTag = MTAG_FREED;

        FREE_VCCB( pAdapter, pVc );

        TRACE( TL_I, TM_Mp, ( "VCB freed $%p", pVc ) );
    }
}


VOID
nicFreeAF(
    IN AFCB* pAF )

    // Frees all resources allocated for address family 'pAF', including
    // 'pAF' itself.
    //
{

#if TODO
    Assert that the various lists (such as pAF->AFVCList) and resources are empty.
#endif // TODO

    pAF->ulTag = MTAG_FREED;

    FREE_NONPAGED (pAF);
}



VOID
nicReferenceAF(
    IN AFCB* pAF )

    // Adds areference to the address family of adapter block, 'pAdapter'.
    //
{
    LONG lRef=0;

    lRef = NdisInterlockedIncrement (&pAF->lRef);

    TRACE( TL_V, TM_Ref, ( "RefAf to %d", lRef ) );
}


BOOLEAN
nicReferenceCall(
    IN VCCB* pVc,
    IN PCHAR pDebugPrint
    )

    // Returns true if a reference is added to the active call on VC control
    // block, 'pVc', or false if no reference was added because no call is
    // active.
    //
{
    BOOLEAN fActive;
    LONG RefNumber;

    
    fActive = nicReferenceRef (&pVc->Hdr.CallRef, &RefNumber);
    
    TRACE( TL_V, TM_Ref, ( "***RefCall %x to %d , %s" , pVc, pVc->Hdr.CallRef.ReferenceCount, pDebugPrint  ) );

    if ( fActive==FALSE)
    {
        TRACE( TL_N, TM_Ref, ( "RefC Inactive" ) );
    }

    return fActive;
}


VOID
nicReferenceVc(
    IN VCCB* pVc )

    // Adds a reference to the VC control block 'pVc'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement (&pVc->Hdr.lRef);

    TRACE( TL_I, TM_Ref, ( "RefVc to %d", lRef ) );
}


NDIS_STATUS
nicAllocateRequestedChannelMakeCallComplete (
    IN PADAPTERCB pAdapter,
    IN PCHANNEL_VCCB pChannelVc,
    IN OUT PULONG pChannel
    )
    // Function Description:
    // This function allocates the channel requested in the make
    //  If any channel is requested it will try all 64. 
    //  If the broadcast channel is requested, it will look for 
    //  for the channel allocated by the BCM
    //  Other wise it will simply try and allocate the requested channel
    //
    //  This can be called from the AddFirstRemoteNode code path.
    //
    // Arguments
    //  Channel Vc - The channel Vc in question
    //  Channel - the channel requested
    //
    // Return Value:
    // Success : if allocate channel succeeds
    // pChannel  - contains the allocated channel
    //
 {
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    ULONG Channel = *pChannel;
    BOOLEAN fAnyChannel = FALSE;
    BOOLEAN fFailCall = FALSE;
    
    TRACE( TL_T, TM_Cm, ( " ==>nicAllocateRequestedChannelMakeCallComplete pAdapter, pVc %x, Channel %x ", 
                            pAdapter, pChannelVc, *pChannel ) );

    do
    {

        //
        // First make sure we have a good channel number
        //
        
        if ( (signed long)Channel < (signed long)NIC1394_BROADCAST_CHANNEL   ||
            (signed long)Channel >(signed long)MAX_CHANNEL_NUMBER)
        {
            TRACE( TL_A, TM_Cm, ( "Invalid Channel Number, channel %x", Channel) );

            NdisStatus = NDIS_STATUS_INVALID_DATA;          

            ASSERT (!(signed long)Channel < (signed long)NIC1394_BROADCAST_CHANNEL   ||
                       (signed long)Channel >(signed long)MAX_CHANNEL_NUMBER);
            
            break;
        }

        if ((signed long)Channel == NIC1394_BROADCAST_CHANNEL   )
        {
            NETWORK_CHANNELSR* pBCR;
            ULONG i = 0;
            
            pBCR = &pAdapter->BCRData.IRM_BCR;

            ADAPTER_ACQUIRE_LOCK (pAdapter);

            if (BCR_IS_VALID (pBCR) == FALSE)
            {
                BOOLEAN bWaitSuccessful  = FALSE;
                BOOLEAN fIsTheBCRFree = FALSE;
                //
                // BCM algorithm has not completed yet, we need to wait 
                //
                TRACE( TL_I, TM_Cm, ( " nicAllocateRequestedChannelMakeCallComplete : BCR Has not completed. About to wait BCR %x ", *pBCR ) );


                BCR_SET_FLAG (pAdapter, BCR_MakeCallPending);

                ADAPTER_RELEASE_LOCK (pAdapter);

                //
                // If we don't have a BCR then we should wait until the BCM algorithm completes
                //
                
                //
                // Now wait for the BCM algorithm to complete. First we will wait for 
                // 5 seconds. (5*1)
                // If we still don't see it, we will reset the bus and hope that the new 
                // iteration of BCM will succeed. 
                //


                //
                // There can 2 reasons to stop waiting, the BCR is being freed because of a 
                // standby or BCR is correct. We check both conditions
                //
  
                NdisWaitEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent, (5000));

                //
                // We reset the bus - if the BCR is not getting freed and we 
                // still do not have a valid BCR . and than we wait 
                // for the BCR to complete
                //
                if (BCR_IS_VALID(pBCR) == FALSE &&
                    (BCR_TEST_FLAGS (pAdapter, BCR_BCRNeedsToBeFreed | BCR_Freed)== FALSE))
                {
                    TRACE( TL_I, TM_Cm, ( " nicAllocateRequestedChannelMakeCallComplete WaitCompleted - About to RESET THE BUS" ) );
                    nicIssueBusReset (pAdapter, BUS_RESET_FLAGS_FORCE_ROOT );

                    //
                    // Wait for 5 minutes before failing the Make Call 
                    // (5 minutes is an experimental number)
                    //
                    {
                        BOOLEAN bWait;

                        bWait = NdisWaitEvent (
                                        &pAdapter->BCRData.MakeCallWaitEvent.NdisEvent, 
                                        ONE_MINUTE * 5 );
                        
                    }
                }

                
                ADAPTER_ACQUIRE_LOCK (pAdapter);

                NdisResetEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent);

                pAdapter->BCRData.MakeCallWaitEvent.EventCode = Nic1394EventCode_InvalidEventCode;
                BCR_CLEAR_FLAG (pAdapter, BCR_MakeCallPending);


                //
                // if we have  not got a valid BCR, then fail the call
                //
                if (BCR_IS_VALID(pBCR) == FALSE || 
                    BCR_TEST_FLAGS (pAdapter, BCR_BCRNeedsToBeFreed | BCR_Freed)) 
                {
                    fFailCall = TRUE;
                    ADAPTER_RELEASE_LOCK(pAdapter);
                    NdisStatus = NDIS_STATUS_FAILURE;
                    break;

                }


            }

            
            Channel = pBCR->NC_Channel;

            //
            // Update the VC structure and break .
            // Do not add a reference. Do not set the flag
            //

            pChannelVc->Channel = Channel;

            pChannelVc->Hdr.Nic1394MediaParams.Destination.Channel = Channel;

            //
            // Reference that this Vc now has a pointer in the BCRData. This is dereferneced 
            // in the channel close call complete.
            //
            nicReferenceCall ((PVCCB)pChannelVc, "nicAllocateRequestedChannelMakeCallComplete Broadcast VC");

            pAdapter->BCRData.pBroadcastChanneVc = pChannelVc;

        
            VC_SET_FLAG (pChannelVc, VCBF_BroadcastVc);     

            pAdapter->ChannelsAllocatedByLocalHost  = pAdapter->ChannelsAllocatedByLocalHost | (g_ullOne<<Channel);


            ADAPTER_RELEASE_LOCK (pAdapter);
            
            NdisStatus = NDIS_STATUS_SUCCESS;
            
            break;
        }

        if ((signed long)Channel == NIC1394_ANY_CHANNEL )
        {
            TRACE( TL_V, TM_Cm, ( "Requesting Any Channel %x", Channel) );

            fAnyChannel = TRUE;
            Channel = MAX_CHANNEL_NUMBER;
        }

        //
        // Now begin the request to allocate a channel
        //
        if (fAnyChannel == FALSE)
        {
            TRACE( TL_V, TM_Cm, ( "Requesting Channel %x, on remote node ", Channel ) );

        
            NdisStatus = nicAllocateChannel ( pAdapter,
                                             Channel,
                                             NULL);

        }

        else
        {
        
            //
            // we need to go through all 64 channels. 
            //
            do
            {

                NdisStatus = nicAllocateChannel ( pAdapter,
                                                 Channel,
                                                 NULL);

                if (NdisStatus != NDIS_STATUS_SUCCESS)
                {
                    if (Channel == 0 )
                    {
                        //
                        //  We now need to fail the make call as the user asked for any channel 
                        //  and none are available
                        // 
                    
                        break;
                    }
                    
                    Channel --;

                }
                else
                {
                    //
                    // We succeeded in allocating a channel .. break
                    //
                    break;
                }

            } while (TRUE);

        }

        //
        // Status of Channel allocation. If AnyChannel == TRUE then we need to make sure that 
        // a channel was allocated
        //
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {

            VC_ACQUIRE_LOCK (pChannelVc);

            VC_SET_FLAG( pChannelVc, VCBF_AllocatedChannel); 

            pChannelVc->Channel = Channel;

            pChannelVc->Hdr.Nic1394MediaParams.Destination.Channel = Channel;

            //
            // Record the channel number in the adpater structure
            //
            pAdapter->ChannelsAllocatedByLocalHost  = pAdapter->ChannelsAllocatedByLocalHost | (g_ullOne<<Channel);

            VC_RELEASE_LOCK (pChannelVc);
            
            nicReferenceCall ((PVCCB)pChannelVc, "nicAllocateRequestedChannelMakeCallComplete  -Allocated Channel");

        
        }
        else
        {
            //
            // we failed to allocate any channel and are going to fail
            //
            if (fAnyChannel == TRUE)
            {
                Channel = 0xff;
                NdisStatus = NDIS_STATUS_RESOURCES;
                break;
            }
            else
            {

                //
                // If the Call specifically wants the channel to 
                // be allocated, we return the correct channel allocate
                // status to it,
                //
                // Otherwise we overwrite and presume that another node may
                // already have allocated the channel
                //
                if (VC_TEST_FLAG (pChannelVc,VCBF_NeedsToAllocateChannel) == FALSE)
                {
                    NdisStatus = NDIS_STATUS_SUCCESS;
                    
                }
                else
                {

                    ASSERT (!"Failing make call because channel was allocated, Hit 'g'");
                }
            }

        }


    } while (FALSE);

    
    *pChannel = Channel;

    TRACE( TL_T, TM_Cm, ( "<==nicAllocateRequestedChannelMakeCallComplete Status %x Channel %x", NdisStatus, *pChannel ) );

    return NdisStatus;

}



NDIS_STATUS
nicFindRemoteNodeFromAdapter( 
    IN PADAPTERCB pAdapter, 
    IN PDEVICE_OBJECT pRemotePdo,
    IN UINT64 UniqueId,
    IN OUT REMOTE_NODE ** ppRemoteNode
    )
/*++

Routine Description:

    This routine matches either a Remote Node' pdo OR unique
    Id to the Remote node's on the adapter
    
    It walks the RemoteNode  List in the Adapter Structure 
    and tries to find a match for the Unique Id, 
    or match the remote Pdo from the adapter's PdoList
    

Arguments:
    pAdapter - pAdapter on which to search
    pRemoptePdo - Remote Pdo to find
    UniqueId - Unique Id to find
    ppRemoteNode - Remote Node structure

Return Value:
    Success if the node is found

--*/
{
    NDIS_STATUS     NdisStatus = NDIS_STATUS_FAILURE;
    PLIST_ENTRY     pPdoListEntry = NULL;
    PREMOTE_NODE pRemoteNode = NULL;
    BOOLEAN         fPdoFound = FALSE;
    STORE_CURRENT_IRQL;
        
    TRACE( TL_T, TM_Cm, ( "==>nicFindRemoteNodeFromAdapter pAdapter is %x, ,Pdo %x, UniqueId %I64x  ", pAdapter, pRemotePdo, UniqueId ) );

    //
    // Validate the parameters 
    //
    ASSERT (pAdapter != NULL);
    TRACE( TL_I, TM_Cm, ( "    Request to Match UniqueID %I64x or pRemotePdo %x", UniqueId, pRemotePdo) );


    do 
    {
        (*ppRemoteNode) = NULL;

        ADAPTER_ACQUIRE_LOCK (pAdapter);
        
        //
        // Check for empty list
        //
        if (pAdapter->PDOList.Flink == &pAdapter->PDOList)
        {

            ADAPTER_RELEASE_LOCK (pAdapter);
            MATCH_IRQL;
            NdisStatus = NDIS_STATUS_FAILURE;
            (*ppRemoteNode) = NULL;
            TRACE( TL_A, TM_Cm, ( "    NO REMOTE NODES PRESENT FAILING MAKE CALL ") );
            break;
        }

        //
        // go through all the Pdo's on the adapter
        //
        for (pPdoListEntry = pAdapter->PDOList.Flink;
            pPdoListEntry!= &pAdapter->PDOList;
            pPdoListEntry = pPdoListEntry->Flink)
        {
            pRemoteNode = CONTAINING_RECORD( pPdoListEntry,
                                          REMOTE_NODE,
                                          linkPdo);

            //
            // Check for the two cases, i.e unique Id's match or Pdo's match
            //
            if ( pRemoteNode->UniqueId == UniqueId || pRemoteNode->pPdo == pRemotePdo)
            {
                TRACE( TL_I, TM_Cm, ( "    Matched UniqueID or pRemotePdo for Pdo%x",pRemoteNode->pPdo) );

                *ppRemoteNode = pRemoteNode;
                nicReferenceRemoteNode (pRemoteNode, FindRemoteNodeFromAdapter);
                //
                // We ref pRemoteNode to keep it alive once we release the lock.
                // Caller is responsible for derefing pRemoteNode.
                //

                fPdoFound = TRUE;

                NdisStatus = NDIS_STATUS_SUCCESS;
    
                break;
            }
            else
            {
                TRACE( TL_A, TM_Cm, ( "remote node's Unique ID's %I64x, given UniqueID %I64x ", pRemoteNode->UniqueId, UniqueId ) );
            }
        

        }
        ADAPTER_RELEASE_LOCK (pAdapter);
        MATCH_IRQL;

        TRACE( TL_V, TM_Cm, ( "Is PdoFound %.2x, RemoteNode at %x ", fPdoFound, &fPdoFound )    );

        if (fPdoFound ==FALSE)
        {
            TRACE( TL_A, TM_Cm, ( "Remote Node was NOT Found: Make Call failed  " )     );
            ASSERT ((*ppRemoteNode) == NULL);
        }


    } while (FALSE);    


    TRACE( TL_T, TM_Cm, ( "<==nicFindRemoteNodeFromAdapter pPdoBlock %x",(*ppRemoteNode) ) );

    MATCH_IRQL;
    return NdisStatus;
 }







NDIS_STATUS
nicCmQueryInformation(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    )

    // Handle QueryInformation requests.  Arguments are as for the standard
    // NDIS 'CallMgrQueryInformation' handler except this routine does not
    // count on being serialized with respect to other requests.
    //
{




    NDIS_STATUS NdisStatus;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;
    USHORT usInfo;

    //  The next variables are used to setup the data structures that are 
    //  used to respond to the OIDs they correspond to
    //


    NDIS_CO_LINK_SPEED  CoLinkSpeed;
    NIC1394_LOCAL_NODE_INFO LocalNodeInfo;
    NIC1394_VC_INFO VcInfo;
    PVCCB pVc;

    TRACE( TL_T, TM_Cm, ( "==>nicCmQueryInformation %x, Vc %x", Oid, CallMgrVcContext ) );


    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof (ulInfo);

    NdisStatus = NDIS_STATUS_SUCCESS;

    // Validate the arguments
    //
    pVc = (VCCB* )CallMgrVcContext;

    if (pVc && pVc->Hdr.ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }


    // Perform the request
    //
    switch (Oid)
    {
    
        case OID_1394_VC_INFO:
        {

            // Returns information about the VC that is being queried
            //


            TRACE( TL_N, TM_Mp, ("QInfo(OID_1394_VC_INFO)") );

            VcInfo.Destination = pVc->Hdr.Nic1394MediaParams.Destination;

            pInfo = &VcInfo;

            ulInfoLen = sizeof (VcInfo);

            break;
         }

        case OID_1394_ISSUE_BUS_RESET:
        {
            PADAPTERCB pAdapter = pVc->Hdr.pAF->pAdapter;
            
            TRACE( TL_V, TM_Mp, ( " OID_1394_ISSUE_BUS_RESET" ) );

            if (InformationBufferLength == sizeof(ULONG))
            {
                nicIssueBusReset (pAdapter, (*(PULONG)InformationBuffer));
            }
            else
            {
                nicIssueBusReset (pAdapter, BUS_RESET_FLAGS_FORCE_ROOT );

            }
            break;
        }
        
        default:
        {
            TRACE( TL_A, TM_Cm, ( "Q-OID=$%08x?", Oid ) );
            NdisStatus = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        *BytesWritten  = 0;
        
        NdisStatus = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        // Copy the found result to caller's buffer.
        //
        if (ulInfoLen > 0)
        {
            NdisMoveMemory (InformationBuffer, pInfo, ulInfoLen );

            DUMPDW( TL_N, TM_Mp, pInfo, ulInfoLen );
        }

        *BytesNeeded = *BytesWritten = ulInfoLen;
    }

    TRACE( TL_T, TM_Cm, ( "<==nicCmQueryInformation %x",NdisStatus ) );

    return NdisStatus;

}





NDIS_STATUS
nicCmSetInformation(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    )
    //
    // Not implemented yet. Will be used to set information
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_NOT_SUPPORTED;
    PVCCB pVc;

    TRACE( TL_T, TM_Cm, ( "==>NicCmMakeCallInitVc Oid %x",Oid ) );

    // Validate the arguments
    //
    UNREFERENCED_PARAMETER(CallMgrAfContext);
    UNREFERENCED_PARAMETER(CallMgrVcContext);
    UNREFERENCED_PARAMETER(CallMgrAfContext);
    UNREFERENCED_PARAMETER(CallMgrPartyContext);
    UNREFERENCED_PARAMETER(Oid);
    UNREFERENCED_PARAMETER(InformationBuffer);
    UNREFERENCED_PARAMETER(InformationBufferLength);
    UNREFERENCED_PARAMETER(BytesRead);
    UNREFERENCED_PARAMETER(BytesNeeded);
    TRACE( TL_T, TM_Cm, ( "<==NicCmMakeCallInitVc %x",NdisStatus ) );

    return NDIS_STATUS_FAILURE;
}






NDIS_STATUS
nicInitRecvFifoDataStructures (
    IN PRECVFIFO_VCCB pRecvFIFOVc
    )
    
    // Function Description:
    // This function will initialize the data structures, buffers etc that are needed on 
    // all the allocate address range Irps that will be called because of the RecvFifo Vc
    //
    // Arguments
    //  pRecvFIFOVc - RecvFifo Vc structure
    //
    // Return Value:
    //  SUCCESS: If all the values are initiaized successfully
    //  Appropriate error code otherwise
{
    

    NDIS_STATUS     NdisStatus          = NDIS_STATUS_FAILURE;
    NDIS_HANDLE     PacketPoolHandle    = NULL;
    PSLIST_HEADER   pSlistHead          = NULL;
    extern  UINT    NumRecvFifos ;
    UINT            AllocateNumBuffers  = NumRecvFifos;
    NIC_PACKET_POOL PacketPool;

    TRACE( TL_T, TM_Cm, ( "==> nicInitRecvFifoDataStructures  pVc %x",pRecvFIFOVc ) );

    do
    {
        PacketPool.Handle = NULL;
        
        //
        // Initialize the PacketPool
        //

        NdisAllocatePacketPoolEx ( &NdisStatus,
                                   &PacketPool.Handle,
                                   MIN_PACKET_POOL_SIZE,
                                   MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                   sizeof (RSVD) );
        
        if (NdisStatus!= NDIS_STATUS_SUCCESS)
        {
            ASSERT(NdisStatus != NDIS_STATUS_SUCCESS);
            pRecvFIFOVc->PacketPool.Handle = NULL;
            break;
        }

        //      
        // Do not acquire the lock as we cannot have two make 
        // calls for the same Vc at the same time
        //

        //
        // Create an S-list and intialize its structures
        //

        ExInitializeSListHead (&pRecvFIFOVc->FifoSListHead);

        KeInitializeSpinLock (&pRecvFIFOVc->FifoSListSpinLock);

        pRecvFIFOVc->Hdr.MTU = pRecvFIFOVc->Hdr.Nic1394MediaParams.MTU ;
        
        TRACE( TL_I, TM_Cm, ( " Recv FIFO MTU is %d ", pRecvFIFOVc->Hdr.MTU ) );
        

        ASSERT (pRecvFIFOVc->Hdr.MTU  >= 512);
        


        //
        // Now, fill the Slist with buffers. 
        //
        
        NdisStatus = nicFillAllocateAddressRangeSList (pRecvFIFOVc, &AllocateNumBuffers);
    
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // nicFillAllocateAddressRangeSlist does its own clean up
            // but we should free the Packet Pool Allocated above
            //
            if (PacketPool.Handle != NULL)
            {
                nicFreePacketPool (&PacketPool);
            
            }

            break;
        }

        ASSERT(AllocateNumBuffers == NumRecvFifos );

        pRecvFIFOVc->PacketPool= PacketPool;
        pRecvFIFOVc->PacketPool.AllocatedPackets = 0;
        pRecvFIFOVc->NumAllocatedFifos = AllocateNumBuffers ;


        TRACE( TL_V, TM_Cm, ( "PacketPool allocated at %x", PacketPool.Handle) );

    } while (FALSE);        

    TRACE( TL_T, TM_Cm, ( "<== nicInitRecvFifoDataStructures  Status %x", NdisStatus ) );
    return NdisStatus;
}




VOID
nicUnInitRecvFifoDataStructures (
    IN PRECVFIFO_VCCB pRecvFIFOVc
    )

/*++

Routine Description:
  Frees all the resources that were allocated in nicInitRecvFifoDataStructures 

Arguments:


Return Value:


--*/
{

    if (pRecvFIFOVc->PacketPool.Handle != NULL)
    {
        ASSERT (pRecvFIFOVc->PacketPool.AllocatedPackets == 0);
        nicFreePacketPool (&pRecvFIFOVc->PacketPool);
    }
    
    pRecvFIFOVc->PacketPool.Handle = NULL;
    

    if (pRecvFIFOVc->FifoSListHead.Alignment != 0)
    {   
                        
        nicFreeAllocateAddressRangeSList(pRecvFIFOVc);

        ASSERT (pRecvFIFOVc->FifoSListHead.Alignment == 0)

    }

    pRecvFIFOVc->FifoSListHead.Alignment = 0;




}








ULONG
nicGetMaxPayLoadForSpeed(
    IN ULONG Speed,
    IN ULONG mtu
    )
    // Function Description:
    //  The purpose is to map a speed to the max payload that 
    //  can be delivered at that speed . this is limited by the Bytes PerFrameAvailable
    //
    // Arguments
    //  Speed - the speed supported by the Bus driver or the Max speed between devices
    //  BytesPerFrameAvailable Bytes per frame available on the bus. 
    //
    //
    // Return Value:
    //   Minimin of the Size determined by the payload and the size determined by the 
    //   byte per frame available.
{


    ULONG maxIsochPayload = ISOCH_PAYLOAD_400_RATE;

    TRACE( TL_T, TM_Cm, ( "<==nicGetMaxPayLoadForSpeed %x", Speed ) );

    switch (Speed) 
    {

        case SPEED_FLAGS_100:

            maxIsochPayload = ISOCH_PAYLOAD_100_RATE;
            break;

        case SPEED_FLAGS_200:

            maxIsochPayload = ISOCH_PAYLOAD_200_RATE;
            break;

        case SPEED_FLAGS_400:

            maxIsochPayload = ISOCH_PAYLOAD_400_RATE;
            break;

        case SPEED_FLAGS_800:

            maxIsochPayload = ISOCH_PAYLOAD_800_RATE;
            break;

        case SPEED_FLAGS_1600:

            maxIsochPayload = ISOCH_PAYLOAD_1600_RATE;
            break;

        default :
        
            TRACE( TL_A, TM_Cm, ( "Invalid Speed %x", Speed ) );
            ASSERT (Speed < SPEED_FLAGS_1600);
            maxIsochPayload = ISOCH_PAYLOAD_1600_RATE;
            break;

    }

    if (maxIsochPayload > mtu)
    {
        maxIsochPayload = mtu;
    }

    
    TRACE( TL_T, TM_Cm, ( "<==nicGetMaxPayLoadForSpeed, payload %x", maxIsochPayload  ) );

    return  maxIsochPayload;

}











//---------------------------------------------------------------------------------
//  SAP function - all of them return failure
//-------------------------------------------------------------------------------

NDIS_STATUS
nicRegisterSapHandler(
    IN  NDIS_HANDLE             CallMgrAfContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    )
{

    *CallMgrSapContext = NULL;
    return NDIS_STATUS_FAILURE;
}




NDIS_STATUS
nicDeregisterSapHandler(
    IN  NDIS_HANDLE             CallMgrSapContext
    )
{
    return NDIS_STATUS_FAILURE;
    
}


NDIS_STATUS
nicCmDropPartyHandler(
    IN  NDIS_HANDLE             CallMgrPartyContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    )
{
    return NDIS_STATUS_FAILURE;

}

NDIS_STATUS
nicCmAddPartyHandler(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle,
    OUT PNDIS_HANDLE            CallMgrPartyContext
    )
{
    *CallMgrPartyContext = NULL;    
    return NDIS_STATUS_FAILURE;
}








NDIS_STATUS
nicAllocateChannelResourcesAndListen (
    IN PADAPTERCB pAdapter,
    IN PCHANNEL_VCCB pChannelVc
    )
    // Function Description:
    //   This function isolated the reource and channel allocation portion 
    //  of initializing a MakeCall. This lets us do the same work when the 
    //  AddRemoteNode code path is hit and there is an existing Channel Vc 
    //
    // Arguments
    // pChannelVc, This is the send fifo that needs to be initilaized
    // 
    // Return Value:
    //
    // Success if the irps sent to the driver succeed
    //
    //


{
    NDIS_STATUS                     NdisStatus = NDIS_STATUS_FAILURE;
    PDEVICE_OBJECT                  ArrayRemotePDO[NIC1394_MAX_NUMBER_NODES];
    ULONG                           Channel = INVALID_CHANNEL;
    ULONG                           Speed;
    PNIC1394_MEDIA_PARAMETERS       pN1394Params;
    ULONG                           NumDescriptors = MAX_NUM_ISOCH_DESCRIPTOR;
    PISOCH_DESCRIPTOR               pIsochDescriptor = NULL;
    ULONG                           MaxBufferSize;
    ULONG                           MaxBytesPerFrame;
    HANDLE                          hResource;
    CYCLE_TIME                      CycleTime;
    ULARGE_INTEGER                  uliChannelMap;
    ULONG                           ResourceFlags = 0;
    ULONG                           State = 0;
    BOOLEAN                         fBroadcastVc = FALSE;
    BOOLEAN                         fChannelAllocate = FALSE;
    BOOLEAN                         fIsMultiChannel = FALSE;
    enum 
    {
        StartState,
        AllocatedResources,
        AllocatedBuffers,
        AttachedBuffers,
        IsochListen
    };

    
    STORE_CURRENT_IRQL;

    TRACE( TL_T, TM_Cm, ( "==> nicAllocateChannelResourcesAndListen pAdapter %x, pChannelVc %x ", 
                               pAdapter,pChannelVc ) );


    State = StartState;
    
    pN1394Params = (PNIC1394_MEDIA_PARAMETERS)&pChannelVc->Hdr.Nic1394MediaParams;

    //
    // Use the original request to figure out which channel needs to be allocated
    //
    fIsMultiChannel  = (pN1394Params->Destination.AddressType == NIC1394AddressType_MultiChannel);

    if (fIsMultiChannel  == FALSE)
    {
        Channel = pN1394Params->Destination.Channel;
    }

    do 
    {
        if (pAdapter == NULL)
        {
            BREAK (TM_Cm, ("nicAllocateChannelResourcesAndListen : pAdapter == NULL ")   );
        }

        //
        // Get the max payload that is possible for isoch receives
        //

        if (pAdapter->Speed == 0)
        {
            nicUpdateLocalHostSpeed (pAdapter);
        }   

        Speed = pAdapter->Speed;
            
        switch (Speed)
        {
            case SPEED_FLAGS_100  : 
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_100_RATE;
                break;
            }
            case SPEED_FLAGS_200 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_200_RATE ;
                break;
            }
                
            case SPEED_FLAGS_400 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }

            case SPEED_FLAGS_800 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }

            case SPEED_FLAGS_1600 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }
            
            case SPEED_FLAGS_3200 :
            {
                pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_400_RATE;
                break;
            }
            default :
            {
                ASSERT (Speed <= SPEED_FLAGS_3200 && Speed != 0 );
                pChannelVc->Hdr.MaxPayload   = ISOCH_PAYLOAD_400_RATE; 
                break;
            }

        }

        //
        // If the make call wants the channel to allocate we try and allocate the channel, 
        // In the Multichannel case, we do not allocate the channel (as this is
        // for listening purposes only )
        //

        fBroadcastVc = (Channel == NIC1394_BROADCAST_CHANNEL);
        fChannelAllocate = VC_TEST_FLAG (pChannelVc,VCBF_NeedsToAllocateChannel);
        
        
        if (fChannelAllocate  || fBroadcastVc )
        {
            ASSERT (pChannelVc->Hdr.VcType != NIC1394_MultiChannel);

            NdisStatus =  nicAllocateRequestedChannelMakeCallComplete( pAdapter,
                                                                 pChannelVc,
                                                                 &Channel );


            

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK( TM_Cm, ( " nicAllocateChannelResourcesAndListen : nicAllocateRequestedChannelMakeCallComplete FAILED") );

            }

        
            TRACE( TL_I, TM_Cm, ( "Using Channel %x, on remote node ", Channel ) );

            ASSERT (Channel < NIC1394_MAX_NUMBER_NODES);  

            ResourceFlags = 0;

            uliChannelMap.QuadPart = 0;

        }
        else
        {
            //
            //  Multichannels - no allocation just update the ullChannelMap
            //
            uliChannelMap = pChannelVc->uliChannelMap;

            if (fIsMultiChannel == TRUE)
            {
                ResourceFlags = RESOURCE_USE_MULTICHANNEL; 
            }
            else
            {
                pChannelVc->Channel = Channel ;
            }
        }
        
        MaxBufferSize = min(pN1394Params->MTU + sizeof(GASP_HEADER) , pChannelVc->Hdr.MaxPayload);

        MaxBytesPerFrame =  MaxBufferSize;

        TRACE( TL_V, TM_Cm, ( "   MAxBufferSize %x, MaxBytesPerFrame  %x", MaxBufferSize, MaxBytesPerFrame ) );

        //
        // Add the flags used for resources allocation
        //
        ResourceFlags |= (RESOURCE_USED_IN_LISTENING | RESOURCE_USE_PACKET_BASED  | RESOURCE_BUFFERS_CIRCULAR); 
            
        
        //
        // MaxBufferSize should be an integral mutiple of MaxBytesPerFram
        //
        ASSERT (MaxBufferSize % MaxBytesPerFrame == 0);

        //
        // Noe allocate the resource 
        //
        NdisStatus = nicIsochAllocateResources( pAdapter,
                                             Speed,
                                             ResourceFlags, 
                                             Channel,
                                             MaxBytesPerFrame,
                                             NumDescriptors,
                                             MaxBufferSize,
                                             0, //QuadletsToStrip,
                                             uliChannelMap,
                                             &hResource); 

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            hResource = NULL;
            BREAK(TM_Cm, ( "Allocate Resources Failed. Make Call failed ") );
        }
    
        State = AllocatedResources;
        
        ASSERT (NumDescriptors != 0);       

        ASSERT (pChannelVc->Hdr.MTU  != 0);

        // 
        // Get Isoch Descriptors that will be submitted to the Bus drivers
        // 

        //
        // Add room for the Isoch Header and Isoch prefix
        //
        MaxBufferSize += ISOCH_PREFIX_LENGTH        ;

        NdisStatus = nicAllocateAndInitializeIsochDescriptors (pChannelVc,
                                                          NumDescriptors,
                                                          MaxBufferSize,
                                                          &pIsochDescriptor );
        if(NdisStatus != NDIS_STATUS_SUCCESS)
        {
            
            BREAK (TM_Cm, (" nicAllocateAndInitializeIsochDescriptors  failed, Make Call Failed") );
        }
        
        ASSERT (pIsochDescriptor != NULL);

        State = AllocatedBuffers;

        NdisStatus = nicIsochAttachBuffers( pAdapter, 
                                         hResource,
                                         NumDescriptors,
                                         pIsochDescriptor);
                                        

        if (NdisStatus != NDIS_STATUS_SUCCESS)  
        {
            BREAK (TM_Cm, "nicIsochAttachBuffers FAILED");
        }

        State = AttachedBuffers;

        //
        // Start the Listen
        //
        NdisZeroMemory (&CycleTime, sizeof(CycleTime));
        
        NdisStatus = nicIsochListen (pAdapter,
                                     hResource,
                                     0,
                                     CycleTime ); // Cycle Time is Zero
        //
        // Update the Vc structure, because we have now succeeded
        //
        State = IsochListen;

        VC_ACQUIRE_LOCK (pChannelVc);
                
        //
        // If broadcast channel, then decrease the speed setting, and fragment
        //
        if (Channel == NIC1394_BROADCAST_CHANNEL)
        {
            
            Speed = SPEED_FLAGS_200   ;
            pChannelVc->Hdr.MaxPayload  = ISOCH_PAYLOAD_200_RATE ;
        }

        

        pChannelVc->Channel = Channel;
        pChannelVc->MaxBufferSize = MaxBufferSize - ISOCH_PREFIX_LENGTH;
        pChannelVc->Speed = Speed;
        
        pChannelVc->hResource = hResource;
        //
        // Reference Call for allocated resource handle
        //
        nicReferenceCall ( (PVCCB) pChannelVc, "nicAllocateRequestedChannelMakeCallComplete - allocate resources ");

        pChannelVc->NumDescriptors = NumDescriptors;
        pChannelVc->pIsochDescriptor = pIsochDescriptor;
        //
        // Reference the call because we will now need to detach buffers
        //
        nicReferenceCall ( (PVCCB) pChannelVc, "nicAllocateRequestedChannelMakeCallComplete  - Attach Buffers");


        //
        // We have succeded in allocating all resources. 
        // If the Freed Resources flag is set it needs to be cleared
        //
        VC_CLEAR_FLAGS (pChannelVc, VCBF_FreedResources);           
        VC_RELEASE_LOCK (pChannelVc);

        //
        // No more failures
        //
    } while (FALSE);


    //
    // Time to do clean up based on what resources were allocated.
    //  There are no failures after the point where the refs for
    //  Allocate Resources and Attach Buffers are added, so 
    //  No Derefs in the following code except in ( FreeIsochDesc)
    //
    if (NdisStatus != NDIS_STATUS_SUCCESS )
    {
        BOOLEAN fAllocatedChannel = FALSE;

        switch (State)
        {
            case  IsochListen:
            {
                nicIsochStop(pAdapter, hResource);
                FALL_THROUGH
            }
            case AttachedBuffers:
            {
                nicIsochDetachBuffers( pAdapter,
                                   hResource,
                                   NumDescriptors,
                                   pIsochDescriptor );
                                        

                FALL_THROUGH;
            }
            case  AllocatedBuffers:
            {
                //
                // Free the isoch Buffers and Descriptors that were
                // allocated
                //
                nicFreeIsochDescriptors(NumDescriptors,
                                    pIsochDescriptor, 
                                    (PVCCB) pChannelVc);
                
                FALL_THROUGH
            }

            case  AllocatedResources:
            {
                //
                // Free the Isoch Resources Handle 
                //
                nicIsochFreeResources (pAdapter, hResource);
                FALL_THROUGH
            }

            case  StartState:
            {
                FALL_THROUGH
            }
            default:
            {
            
                break;
            }
        }
        VC_ACQUIRE_LOCK (pChannelVc);

        //
        // Update Flags in the VC structure
        //
        VC_SET_FLAG  (pChannelVc, VCBF_FreedResources);         
        
        fAllocatedChannel = VC_TEST_FLAGS( pChannelVc, VCBF_AllocatedChannel);

        //
        // Do we need to free a channel as well
        //
        if (fAllocatedChannel  == TRUE)
        {
            Channel = pChannelVc->Channel;
            pChannelVc->Channel = INVALID_CHANNEL; 

            nicDereferenceCall ((PVCCB) pChannelVc, "Free Allocated Channel");
        }   
        VC_RELEASE_LOCK (pChannelVc);


        if (fAllocatedChannel)
        {
            nicFreeChannel (pAdapter, pChannelVc->Channel);
        }

        
    }  // end of failure code path

    TRACE( TL_T, TM_Cm, ( "<== nicAllocateChannelResourcesAndListen NdisStatus %x ",NdisStatus) );

    MATCH_IRQL;
    return NdisStatus;
    

}




NDIS_STATUS
nicQueryRemoteNodeCaps (
    IN PADAPTERCB pAdapter,
    IN PREMOTE_NODE pRemoteNode,
    OUT PULONG pSpeedTo,
    OUT PULONG pMaxBufferSize,
    OUT PULONG pMaxRec
    )
/*++

Routine Description:

 Queries the remote Node for speed and max size

Arguments:
    pSpeedTo        -- max speed to the remote node. From nodes config rom.
                          in units of SCODE_XXX_RATE.
    pMaxBufferSize  -- max buffer size to use ( this is the min of local,
                          remote and max allowed by *pSpeedTo).
    pMaxRec         -- maxrec of the remote node -- from the node's config
                         rom.


Return Value:


--*/
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    ULONG Speed = 0;        // Speed in units of SPEED_FLAG_XXX
    ULONG MaxBufferSize;
    PVOID pCRom = NULL;
    PCONFIG_ROM pBusInfo = NULL;
    ULONG SpeedMaxRec = 0;
    ULONG MaxRec= 0;
    ULONG MinMaxRec= 0;

    TRACE( TL_T, TM_Cm, ( "==> nicQueryRemoteNodeCaps pRemoteNode%x ",pRemoteNode) );

    do 
    {
        ASSERT (KeGetCurrentIrql()==PASSIVE_LEVEL);
    
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        if (REMOTE_NODE_ACTIVE (pRemoteNode) == FALSE)
        {
            NdisStatus = NDIS_STATUS_DEST_OUT_OF_ORDER;

            ADAPTER_RELEASE_LOCK (pAdapter);

            break;
        }

        ADAPTER_RELEASE_LOCK (pAdapter);

    
        NdisStatus = nicGetMaxSpeedBetweenDevices (pAdapter,
                                                   1 ,
                                                   &pRemoteNode->pPdo,
                                                   &Speed);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Cm, (" nicQueryRemoteNodeCaps   : nicGetMaxSpeedBetweenDevices FAILED") );
        
        }
        
        TRACE( TL_V, TM_Cm, ( "nicGetMaxSpeedBetweenDevices  Speed %x ",Speed) );

        //
        //  This is the MaxRec from the Actual speed of 
        //  the link.
        //  

        SpeedMaxRec = nicGetMaxRecFromSpeed(Speed);



        //
        // Now get the max rec from the config rom
        //

        NdisStatus = nicGetConfigRom (pRemoteNode->pPdo, &pCRom);


        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Cm, (" nicQueryRemoteNodeCaps   : nicGetMaxSpeedBetweenDevices FAILED") );
        
        }

        //
        // Now extract the bus info, and get the remoteNode's MaxRec
        // The max rec is a 4-bit field at location 0x0000f000.
        // See for example Figure 11-3: Format of the Bus_Info_Block in
        // the Mind Share Inc's FireWire System Architecture book.
        //
        //
        pBusInfo = (PCONFIG_ROM) pCRom;

        MaxRec = SWAPBYTES_ULONG (pBusInfo->CR_BusInfoBlockCaps);

        MaxRec &= 0xf000;

        MaxRec = MaxRec >> 12;


        //
        // Take the minimum of the adapter, the remote node
        // and the link's maxRec
        //
        MinMaxRec = min (MaxRec, pAdapter->MaxRec);
        MinMaxRec = min (MinMaxRec, SpeedMaxRec);

        switch (MinMaxRec)
        {
            case MAX_REC_100_RATE:
            {
                MaxBufferSize = ASYNC_PAYLOAD_100_RATE ;
                break;
            }
            case MAX_REC_200_RATE:
            {
                MaxBufferSize = ASYNC_PAYLOAD_200_RATE;
                break;
            }
            case MAX_REC_400_RATE :
            {
                MaxBufferSize = ASYNC_PAYLOAD_400_RATE;
                break;
            }
            
            default: 
            {
                //                    
                // Use the 400 size for all larger payloads.
                //
                MaxBufferSize = ASYNC_PAYLOAD_400_RATE;
                break;
            }

        }


        TRACE( TL_N, TM_Cm, (" MaxRec %x\n", MaxRec ) );

    } while (FALSE);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        Speed = nicSpeedFlagsToSCode(Speed);
        *pSpeedTo = Speed;
        *pMaxBufferSize = MaxBufferSize;
        *pMaxRec = MaxRec;

        // Update the remote node's cached caps.
        //
        REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);
        pRemoteNode->CachedCaps.SpeedTo = Speed;
        pRemoteNode->CachedCaps.EffectiveMaxBufferSize = MaxBufferSize;
        pRemoteNode->CachedCaps.MaxRec = MaxRec;
                                           
        REMOTE_NODE_RELEASE_LOCK (pRemoteNode);
    }
    
    if (pCRom != NULL)
    {
        FREE_NONPAGED (pCRom);
    }

    TRACE( TL_T, TM_Cm, ( "<== nicQueryRemoteNodeCaps pRemoteNode%x , NdisStatus %x",pRemoteNode, NdisStatus) );
    return NdisStatus;
}













VOID 
nicInterceptMakeCallParameters (
    PCO_MEDIA_PARAMETERS pMedia     
    )
    
{

    PNIC1394_MEDIA_PARAMETERS p1394Params = (PNIC1394_MEDIA_PARAMETERS )(pMedia->MediaSpecific.Parameters);

#if INTERCEPT_MAKE_CALL 


    if (p1394Params->Destination.AddressType == NIC1394AddressType_MultiChannel)
    {
        p1394Params->Destination.AddressType = NIC1394AddressType_Channel;
        p1394Params->Destination.Channel = 0x3a;
        p1394Params->Flags |= NIC1394_VCFLAG_ALLOCATE;
        pMedia->Flags |= TRANSMIT_VC;
        pMedia->Flags &= (~RECEIVE_VC);
        return;
        
    }

    if (p1394Params->Destination.AddressType == NIC1394AddressType_Ethernet)
    {
        p1394Params->Destination.AddressType = NIC1394AddressType_Channel;
        p1394Params->Destination.Channel = 0x3a;
        pMedia->Flags |= RECEIVE_VC;
        pMedia->Flags &= (~TRANSMIT_VC);
        return;

    }


#endif
}


UINT
nicSpeedFlagsToSCode(
    IN UINT SpeedFlags
    )
{
    UINT SCode = SCODE_400_RATE;

    switch (SpeedFlags)
    {
        case SPEED_FLAGS_100  : 
        {
            SCode = SCODE_100_RATE;
            break;
        }
        case SPEED_FLAGS_200 :
        {
            SCode = SCODE_200_RATE;
            break;
        }
            
        case SPEED_FLAGS_400 :
        {
            SCode = SCODE_400_RATE;
            break;
        }

        case SPEED_FLAGS_800 :
        {
            SCode = SCODE_800_RATE;
            break;
        }

        case SPEED_FLAGS_1600 :
        {
            SCode = SCODE_1600_RATE;
            break;
        }

        case SPEED_FLAGS_3200 :
        {
            SCode = SCODE_3200_RATE;
            break;
        }

        default :
        {
            ASSERT (!"SpeedFlags out of range");
            
            break;
        }
    }

    return SCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\channel.c ===
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// send.c
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port Send routines
//
// 05/15/1999 ADube Created, 
//




#include <precomp.h>




//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

extern ULONG           NdisBufferAllocated[NoMoreCodePaths];
extern ULONG           NdisBufferFreed[NoMoreCodePaths];


NDIS_STATUS
nicGetIsochDescriptors(
    IN UINT Num,
    OUT PPISOCH_DESCRIPTOR  ppIsochDescriptor
    );



NDIS_STATUS
nicInitializeIsochDescriptor (
    IN PCHANNEL_VCCB pChannelVc,
    IN PMDL pMdl,
    IN PISOCH_DESCRIPTOR pIsochDesriptor
    );


VOID
nicIsochRxCallback (
    IN PVOID Context1,
    IN PVOID Context2
    );

ULONG           ReassemblyCompleted = 0;

//-----------------------------------------------------------------------------
// prototypes implementations (alphabetically)
//-----------------------------------------------------------------------------





NDIS_STATUS
nicAllocateAndInitializeIsochDescriptors (
    IN PCHANNEL_VCCB pChannelVc,
    IN UINT NumDescriptors,
    IN UINT BufferLength,
    IN OUT PPISOCH_DESCRIPTOR  ppIsochDescriptor
    )

    
    // Function Description:
    //   This function allocate and initializes a 
    //   a numer of isoch descriptors all allocated 
    //   together.
    //   This should allocate isoch desc, 
    //   get local memory, get mdls 
    //   initialize mdl, isoch _desc and then return
    //
    //
    // Arguments
    //  ChannelVc- this contains all the other argumernts, size
    //  num of descriptors,etc
    //  ppIsochDescriptor- will contain the pointer to the allocated 
    //  array of IsochDescriptor
    //
    //
    // Return Value:
    //  Success if all the memory allocations succeeded 
    //
    //
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    UINT Size;
    UINT index =0;
    PMDL pMdl = NULL;
    PVOID pLocalBuffer = NULL;

    TRACE( TL_T, TM_Recv, ( "==>nicAllocateAndInitializeIsochDescriptors Vc %.8x, Num %.8x", 
                                 pChannelVc, NumDescriptors) );
    TRACE( TL_V, TM_Recv, ( "Max BuffferSize %.8x", pChannelVc, BufferLength) );

    do
    {
        
        NdisStatus = nicGetIsochDescriptors (NumDescriptors, ppIsochDescriptor);

    
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK ( TM_Recv, "nicGetIsochDescriptors FAILED" );
        }

        ASSERT (*ppIsochDescriptor != NULL);

        while (index < NumDescriptors)
        {
            //
            // Get a local that point to the isoch descriptor that needs to be initialized
            //
            PISOCH_DESCRIPTOR pIsochDescriptor = NULL;
            pIsochDescriptor = (PISOCH_DESCRIPTOR)((ULONG_PTR)(*ppIsochDescriptor)+ index*sizeof(ISOCH_DESCRIPTOR));
            //
            // Get Locally owned memory for the data
            // 
            NdisStatus = nicGetLocalBuffer (BufferLength, &pLocalBuffer);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK ( TM_Recv, ( "nicGetLocalBuffer FAILED " ) );
            }
            
            //
            // Get an MDL and initialze the MDL with the buffer 
            //
            NdisStatus = nicGetMdl ( BufferLength,
                                    pLocalBuffer,
                                    &pMdl);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                nicFreeLocalBuffer(BufferLength, pLocalBuffer);
                pLocalBuffer = NULL;
                BREAK ( TM_Recv, ( "nicGetMdl FAILED " ) );
            }

            //
            // this reference will be removed when the MDL will be freed 
            // in FreeSingleIsochDescriptor
            //
            nicReferenceCall ((PVCCB)pChannelVc, "nicAllocateAndInitializeIsochDescriptors " );

            NdisStatus = nicInitializeIsochDescriptor (pChannelVc,
                                                  pMdl,
                                                  pIsochDescriptor);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK ( TM_Recv, ( "nicInitializeIsochDescriptor FAILED " ) );
            }
                               
            index++;
        }


    } while (FALSE);

    TRACE( TL_T, TM_Recv, ( "==>nicAllocateAndInitializeIsochDescriptors Status %.8x", NdisStatus) );

    return NdisStatus;

}


NDIS_STATUS
nicFreeIsochDescriptors(
    IN UINT Num,
    IN PISOCH_DESCRIPTOR  pIsochDescriptor,
    IN PVCCB pVc
    )
    // Function Description:
    //   Free Num number of IsochDescriptors
    //
    // Arguments
    //  Num number of descriptors
    //  Start of the allocated memory
    //
    //
    // Return Value:
    //  Success if all the memory allocations succeeded 
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PISOCH_DESCRIPTOR pCurrDesc = pIsochDescriptor;
    UINT i=0;

    
    TRACE( TL_T, TM_Recv, ( "==>nicFreeIsochDescriptors Num %.8x, pIsochDescriptor %x", Num, pIsochDescriptor ) );
    do 
    {
        if (pIsochDescriptor == NULL)
        {
            break;
        }
        
        pCurrDesc = pIsochDescriptor;

        while (i < Num)
        {
            nicFreeSingleIsochDescriptor( pCurrDesc, pVc);

            pCurrDesc  = (PISOCH_DESCRIPTOR)((PUCHAR)pCurrDesc + sizeof(ISOCH_DESCRIPTOR));

            i++;

        }       
        
        FREE_NONPAGED (pIsochDescriptor);   

    } while (FALSE);

    NdisStatus = NDIS_STATUS_SUCCESS;

    TRACE( TL_T, TM_Recv, ( "<==nicGetIsochDescriptors Status %.8x", NdisStatus ) );
    return NdisStatus;
    
}



NDIS_STATUS
nicFreeSingleIsochDescriptor(
    IN PISOCH_DESCRIPTOR  pIsochDescriptor,
    IN PVCCB pVc
    )
    // Function Description:
    //   Free IsochDescriptor and its MDL
    //
    // Arguments
    //  Start of the isochDesc
    //
    //
    // Return Value:
    //  Success if all the memory allocations succeeded 
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PCHANNEL_VCCB pChannelVc = pIsochDescriptor->Context1;

    ASSERT (pVc == (PVCCB)pChannelVc);
    
    TRACE( TL_T, TM_Recv, ( "==>nicFreeSingleIsochDescriptor pIsochDescriptor %x", pIsochDescriptor ) );

    //
    // Lets make sure we have a VC and Channel VC 
    //
    ASSERT (pChannelVc->Hdr.ulTag == MTAG_VCCB );

    //
    // Just to protect ourselves against a bad isoch descriptor
    //
    if (pIsochDescriptor->Mdl != NULL)
    {
        PVOID pVa = MmGetMdlVirtualAddress(pIsochDescriptor->Mdl);
        ULONG Length = MmGetMdlByteCount(pIsochDescriptor->Mdl);
            
        nicDereferenceCall ((PVCCB)pChannelVc, "nicFreeSingleIsochDescriptors ");

        nicFreeMdl (pIsochDescriptor->Mdl);

        nicFreeLocalBuffer(Length, pVa);
    }
    else
    {
        ASSERT (pIsochDescriptor->Mdl != NULL);
    }
    
    
    NdisStatus = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Recv, ( "<==nicFreeSingleIsochDescriptors Status %.8x", NdisStatus ) );
    return NdisStatus;
    
}




NDIS_STATUS
nicGetIsochDescriptors(
    IN UINT Num,
    OUT PPISOCH_DESCRIPTOR  ppIsochDescriptor
    )
    // Function Description:
    //   The function returns a block of contigious memory of size
    //   Num * sizeof (ISOCH_DESCRIPTOR)
    //
    //
    // Arguments
    //  Num number of descriptors
    //  Start of the allocated memory
    //
    //
    // Return Value:
    //  Success if all the memory allocations succeeded 
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PVOID pMemory = NULL; 
    
    TRACE( TL_T, TM_Recv, ( "==>nicGetIsochDescriptors Num %.8x", Num) );

    pMemory = ALLOC_NONPAGED (Num*sizeof(ISOCH_DESCRIPTOR),  MTAG_CBUF  );  

    if (pMemory != NULL)
    {
        NdisStatus = NDIS_STATUS_SUCCESS;
        *ppIsochDescriptor = (PISOCH_DESCRIPTOR)pMemory;
    
    }
    else
    {
        *ppIsochDescriptor  = NULL;
        TRACE( TL_A, TM_Recv, ( "<==nicGetIsochDescriptors About to Fail") );
        ASSERT (*ppIsochDescriptor  != NULL);

        
    }

    TRACE( TL_T, TM_Recv, ( "<==nicGetIsochDescriptors Status %.8x, StartAddress %.8x", NdisStatus , *ppIsochDescriptor) );
    return NdisStatus;
    
}



NDIS_STATUS
nicInitializeIsochDescriptor (
    IN PCHANNEL_VCCB pChannelVc,
    IN PMDL pMdl,
    IN OUT PISOCH_DESCRIPTOR pIsochDescriptor
    )
    // Function Description:
    //   Initializes the Isoch_desciptor using the fields in
    //   the Channel Vc Block and the Mdl
    //
    // Arguments
    //   ChannelVc- Pointer to the Channel Vc which will own 
    //              Descriptor, also contains information
    //   pMdl- The IsochDescriptor will get a pointer to this Mdl
    //   pIsochDescriptor - is the descriptor whose fields will get 
    //                    initialized
    //
    // Return Value:
    //  Success if all the memory allocations succeeded 
    //


{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;

    TRACE( TL_T, TM_Recv, ( "==>nicInitializeIsochDescriptor Vc %.8x, Mdl ", pChannelVc, pMdl) );

    pIsochDescriptor->fulFlags = DESCRIPTOR_SYNCH_ON_TAG;

    //
    // Mdl pointing to buffer
    //
    pIsochDescriptor->Mdl = pMdl;

    //
    // Length of combined buffer(s) as represented by the Mdl
    //
    pIsochDescriptor->ulLength = MmGetMdlByteCount(pMdl);

    //
    // Payload size of each Isoch packet to be used in this descriptor
    //
    pIsochDescriptor->nMaxBytesPerFrame = MmGetMdlByteCount(pMdl);

    //
    // Synchronization field; equivalent to Sy in the Isoch packet
    //
    pIsochDescriptor->ulSynch= 0;

    //
    // Synchronization field; equivalent to Tag in the Isoch packet. 
    //
    pIsochDescriptor->ulTag = g_IsochTag;

    //
    // Cycle time field; returns time to be sent/received or when finished
    //
    //    (ULONG)pIsochDescriptor->CycleTime=0;

    //
    // Callback routine (if any) to be called when this descriptor completes
    //
    pIsochDescriptor->Callback = nicIsochRxCallback;

    //
    // First context (if any) parameter to be passed when doing callbacks
    //
    pIsochDescriptor->Context1 = pChannelVc;

    //
    // Second context (if any) parameter to be passed when doing callbacks
    //
    pIsochDescriptor->Context2 = pIsochDescriptor;

    //
    // Holds the final status of this descriptor. Assign a bogus value
    //
    pIsochDescriptor->status = STATUS_INFO_LENGTH_MISMATCH;

    NdisStatus = NDIS_STATUS_SUCCESS;

    TRACE( TL_T, TM_Recv, ( "<==nicInitializeIsochDescriptors  Status %.8x, IsochDesc %.8x", NdisStatus, pIsochDescriptor) );
    return NdisStatus;
}




VOID
nicIsochRxCallback (
    PVOID Context1,
    PVOID Context2
    )
/*++

Routine Description:
    This is the callback routine passed to bus driver
    This function does some channel specific work and calls the common callback routine

Arguments:
    Context1 - pChannel Vc
    Context2 - pIsochDescriptor2

Return Value:


--*/
    
{
    PISOCH_DESCRIPTOR pIsochDescriptor = (PISOCH_DESCRIPTOR)Context2;
    PVCCB pVc = (PVCCB) Context1;

    MARK_ISOCH_DESCRIPTOR_INDICATED (pIsochDescriptor);
    STORE_CHANNELVC_IN_DESCRIPTOR (pIsochDescriptor, pVc );
    NdisInterlockedIncrement (&((PCHANNEL_VCCB)pVc)->NumIndicatedIsochDesc);
    CLEAR_DESCRIPTOR_NEXT (pIsochDescriptor);
    pIsochDescriptor->Mdl->Next = NULL;
    

    nicReceiveCommonCallback (pIsochDescriptor ,
                            pVc,
                            IsochReceive,
                            pIsochDescriptor->Mdl);
}



VOID
nicReceiveCommonCallback (
    IN PVOID pIndicatedStruct,
    IN PVCCB pVc,
    BUS_OPERATION RecvOp,
    PMDL pMdl
    )
/*++

Routine Description:

    This function is the common receive code for Isoch and Fifo Recv

    It allocate an NdisBuffer that points to the Ip1394 data
    If packet is complete (i.e reassembly is complete) , then it allocates an ndis packet
        and indicates it up to Ndis


Arguments:
    pIndicatedStruct - Isoch Desc. or Address fifo,
    pVc - VC on which data was indicated, 
    RecvOp - Isoch or Fifo,
    pMdl - Mdl associated with the Isoch Desc or Fifo. 
           Passed in seperately for ease of use (debugging)


Return Value:
    None

--*/



{
    NDIS_STATUS                         NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS1394_REASSEMBLY_STRUCTURE      pReassembly = NULL;
    NIC_RECV_DATA_INFO                  RcvInfo;
    ULONG                               DataLength = 0;
    BOOLEAN                             fVcActive = FALSE;
    ULONG                               ulValidDataLength = 0;
    PVOID                               pStartValidData = NULL;
    PNDIS_BUFFER                        pHeadNdisBuffer = NULL;
    PADAPTERCB                          pAdapter = NULL;
    BOOLEAN                             fPacketCompleted  = FALSE;
    PNDIS_PACKET                        pMyPacket = NULL;
    ULONG                               PacketLength = 0;
    PPKT_CONTEXT                        pPktContext = NULL;
    NDIS_STATUS                         IndicatedStatus = NDIS_STATUS_FAILURE;
    PVOID                               pIndicatedChain = NULL;

    
    STORE_CURRENT_IRQL;

    ASSERT (RecvOp == IsochReceive || RecvOp == AddressRange);

    TRACE( TL_T, TM_Recv, ( "==>nicReceiveCommonCallback pVc %x, IndicatedStruc %x, Mdl %x", 
                              pVc, pIndicatedStruct , pMdl ) );



    do 
    {
    

        if (pVc->Hdr.ulTag != MTAG_VCCB)
        {
            ASSERT (pVc->Hdr.ulTag == MTAG_VCCB);
            NdisStatus = NDIS_STATUS_VC_NOT_ACTIVATED;

            break;
        }
        //
        // First, we need to check if we still have an active make call. VC will be present will bus driver
        // has buffers
        //

        fVcActive = VC_ACTIVE (pVc) ;

        if (fVcActive == TRUE)
        {
            pAdapter = pVc->Hdr.pAF->pAdapter;
        }

        
        
        if (fVcActive == FALSE ) 
        {
            TRACE( TL_N, TM_Recv, ( "We do not have a valid VC Block  %x ",pVc) );   

            NdisStatus = NDIS_STATUS_VC_NOT_ACTIVATED;

            break;
        }


        NdisStatus = nicValidateRecvData ( pMdl,
                                      RecvOp,
                                      pIndicatedStruct,
                                      pVc  ,
                                      &RcvInfo);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE (TL_A, TM_Recv, ("Invalid Data Received pMdl %x, RecvOp %x, pVc %x", 
                                    pMdl, RecvOp, pVc) );
            break;
        }

                                        
        nicDumpMdl (pMdl, RcvInfo.Length1394, "Received Mdl\n");


#ifdef PKT_LOG
            
        {
            

            if (RecvOp == IsochReceive)
            {
                PPACKET_FORMAT pPacketFormat = (PPACKET_FORMAT)RcvInfo.p1394Data; 
                GASP_HEADER GaspHeader = pPacketFormat->IsochReceiveNonFragmented.GaspHeader;
                GaspHeader.FirstQuadlet.GaspHeaderHigh = SWAPBYTES_ULONG (GaspHeader.FirstQuadlet.GaspHeaderHigh);


                NIC1394_LOG_PKT(
                    pVc->Hdr.pAF->pAdapter,
                    NIC1394_LOGFLAGS_RECV_CHANNEL,
                    GaspHeader.FirstQuadlet.u.GH_Source_ID, // SourceID
                    ((PCHANNEL_VCCB)pVc)->Channel, // DestID
                    RcvInfo.p1394Data,
                    RcvInfo.DataLength );
            }
            else
            {
                PNOTIFICATION_INFO pNotificationInfo = (PNOTIFICATION_INFO)pIndicatedStruct;
                ULONG NodeNumber =  ((PASYNC_PACKET)pNotificationInfo->RequestPacket)->AP_Source_ID.NA_Node_Number;
                
                    NIC1394_LOG_PKT(
                    pVc->Hdr.pAF->pAdapter,
                    NIC1394_LOGFLAGS_RECV_FIFO  ,
                    NodeNumber , // SourceID
                    pAdapter->BCRData.LocalNodeNumber,
                    RcvInfo.p1394Data,
                    RcvInfo.DataLength );


            }
        }

#endif
        //
        // Sanity check 
        //
        
        if (RcvInfo.fFragmented == FALSE)
        {
            //
            // Pack the mdl into an ndispacket and indicate it to Ndis.
            // SHOULD BE NDIS_BUFFERS
            //

            
            ulValidDataLength = RcvInfo.DataLength;

        
            pStartValidData  = (PVOID)RcvInfo.pEncapHeader;
    
            NdisStatus = nicGetNdisBuffer ( ulValidDataLength,
                                            pStartValidData,
                                            &pHeadNdisBuffer);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                pHeadNdisBuffer = NULL;
                break;
            }

            nicIncRecvBuffer(pVc->Hdr.VcType == NIC1394_RecvFIFO);

            pIndicatedChain = RcvInfo.NdisPktContext.pCommon;


            fPacketCompleted = TRUE;



        }
        else  // Recv Data is fragemented
        {
            PREMOTE_NODE    pRemoteNode= NULL;
            USHORT          SourceNodeAddress = 0xff;

            //
            // First extract all the useful information from the indicated structure, rem node, dgl, first frag, etc
            //
            nicInitRecvDataFragmented (pMdl, RecvOp, pIndicatedStruct, &RcvInfo);

            
            RcvInfo.pRemoteNode = nicGetRemoteNodeFromTable (RcvInfo.SourceID,pAdapter);


            TRACE( TL_T, TM_Recv, ( "     pRemoteNode %x", RcvInfo.pRemoteNode) );
            //
            // If there is no remote node present , break out
            //

            if (RcvInfo.pRemoteNode == NULL)
            {
                NdisStatus = NDIS_STATUS_FAILURE;

                nicRecvNoRemoteNode (pAdapter);
                BREAK (TM_Recv, (" Rx - Did not find a remote Node for reassembly" ) );
            }

            //
            // Try and use the indicated data to reassemble 
            //
            NdisStatus = nicDoReassembly (&RcvInfo, &pReassembly, &fPacketCompleted  );

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                TRACE (TL_N, TM_Recv, ("Generic  RX - Reassembly Failed") );
                break;
            }
            
            ASSERT (pReassembly != NULL);
            
            if (fPacketCompleted  == TRUE && 
              REASSEMBLY_ACTIVE (pReassembly))
            {
                
                TRACE( TL_V, TM_Recv, ( " pReassembly->ReassemblyComplete %x ", pReassembly->fReassemblyComplete )  );

                pHeadNdisBuffer = pReassembly->pHeadNdisBuffer;

                pIndicatedChain = pReassembly->Head.pCommon;

                nicReassemblyCompleted(pAdapter);

            }
            else
            {
                //
                // Do not call the return packet as reassembly is in progress. Dereference the ref made 
                // when the reaassembly was found in nicFindReassembly...
                //
                ASSERT (pHeadNdisBuffer == NULL);

                NdisStatus = NDIS_STATUS_SUCCESS;

            }

            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

                
            //
            // Dereference the ref that was made nicFindReassembly. After this only one thread
            // should have the reassembly struct. And there should be one ref on it.
            //
            nicDereferenceReassembly (pReassembly, "nicIsochRxCallback Reassembly Incomplete");


        }  // Completed the ifFragmented code


        if (RcvInfo.pRemoteNode != NULL)
        {
            //
            // Deref the ref made earlier in the if fragmented code path within this function
            //
            nicDereferenceRemoteNode(RcvInfo.pRemoteNode , GetRemoteNodeFromTable );
            RcvInfo.pRemoteNode = NULL;
        }

        
        if (fPacketCompleted  == FALSE)
        {
            //
            // If  the  packet is not completely reassembled, then there is no 
            // more work to be done
            //
            pReassembly = NULL;

            NdisStatus  = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Now we package the data into an NdisPacket
        //

        nicAllocatePacket (&NdisStatus,
                        &pMyPacket,
                        RcvInfo.pPacketPool);


        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            pMyPacket = NULL;
            ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);
            break;
        }

        
        //
        // Set the NdisBuffer as Head and Tail of the Packet
        //
        NdisChainBufferAtFront (pMyPacket, pHeadNdisBuffer);


        NdisQueryPacket( pMyPacket,
                       NULL,
                       NULL,
                       NULL,
                       &PacketLength);

        TRACE( TL_V, TM_Recv, ( "Packet %x Length %x", pMyPacket, PacketLength )  ); 

    
        NDIS_SET_PACKET_STATUS (pMyPacket, NDIS_STATUS_SUCCESS);

        // Insert the node address if we are in bridge mode
        //
        if (ADAPTER_TEST_FLAG(pAdapter,fADAPTER_BridgeMode)== TRUE)
        {
            nicInsertNodeAddressAtHead (pMyPacket, &RcvInfo);
        }
        //
        // Set up the context in the ndis packet . Contains the Vc, and 
        // the Buffer registered with the bus driver
        //

        pPktContext = (PPKT_CONTEXT)&pMyPacket->MiniportReserved;   
        pPktContext->Receive.pVc = pVc;
        pPktContext->Receive.IndicatedStruct.pCommon = pIndicatedChain ;

        
        //
        // Its time to indicate the packet to NDIS
        //

        IndicatedStatus = NDIS_GET_PACKET_STATUS(pMyPacket);

        nicIndicateNdisPacketToNdis (pMyPacket,
                                     pVc,
                                     pVc->Hdr.pAF->pAdapter);
                                     
        //
        // Dereference the reassembly here . so that pReassembly is valid and it will catch all 
        // failures prior this 
        //

        if (pReassembly != NULL)
        {
            //
            // This should free the reassembly
            //
            nicFreeReassemblyStructure (pReassembly);
            pReassembly = NULL;
        }
        
    } while (FALSE);

    ASSERT (IndicatedStatus != NDIS_STATUS_RESOURCES);

    if (IndicatedStatus == NDIS_STATUS_RESOURCES)
    {

        //
        // The packet was completed with  a status of resources.
        // It is gauranteed to be valid and we need to call the 
        // return packet handler
        //
        nicInternalReturnPacket (pVc, pMyPacket);

    }
    //
    // Failure code path
    //
    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        //
        // if there was a valid reassembly structure and the failure occured after that
        // then we need to abort the reaasembly
        //
        if (pMyPacket)
        {
            
            nicFreePacket (pMyPacket, RcvInfo.pPacketPool);
        }

        //
        // There could still be NdisBuffers that are allocated.
        //
        if (pReassembly != NULL)
        {
            nicDereferenceReassembly (pReassembly, "Indication failure");
            nicAbortReassembly(pReassembly);

        }
        else
        {
            //
            // We need to return this descriptor or fifo back to the bus driver
            //
            
            if (pVc->Hdr.VcType == NIC1394_SendRecvChannel || 
              pVc->Hdr.VcType == NIC1394_RecvChannel )
            {
                nicReturnDescriptorChain ((PISOCH_DESCRIPTOR)pIndicatedStruct,
                                      (PCHANNEL_VCCB) pVc);
            }
            else
            {
                ASSERT (pVc->Hdr.VcType == NIC1394_RecvFIFO);
                ASSERT (((PNOTIFICATION_INFO)pIndicatedStruct)->Fifo != NULL);
                
                nicReturnFifoChain ( ((PNOTIFICATION_INFO)pIndicatedStruct)->Fifo, 
                                   (PRECVFIFO_VCCB) pVc);

            }

            if (pHeadNdisBuffer != NULL)
            {   
                nicReturnNdisBufferChain(pHeadNdisBuffer, pVc);
            }

        }

    }

    
    TRACE( TL_T, TM_Recv, ( "<==nicReceiveCommonCallback  " )  ); 

}






VOID 
nicChannelReturnPacket (
    IN PVCCB pVc,
    IN PNDIS_PACKET pMyPacket
    )

    // Function Description:
    //  Return Packets Handler -
    //   For FIFO's will reinsert the buffer (MDL) into  the Fifo SList
    //   Check for the VC Active  and then return it ot the SList . Free it otherwise
    //
    // Arguments
    //  RecvFIFOVc - Vc of the packet
    //  pPacket = Packet in question
    //
    // Return Value:
    //
    //
    //
    
{
    PCHANNEL_VCCB       pChannelVc = (PCHANNEL_VCCB)pVc;
    PNDIS_BUFFER        pMyNdisBuffer;
    PPKT_CONTEXT        pPktContext  = (PPKT_CONTEXT)&pMyPacket->MiniportReserved; 
    PISOCH_DESCRIPTOR   pIsochDescriptor = NULL;
    
    
    TRACE( TL_T, TM_Recv, ( "==>nicChannelReturnPacket  pVc %x, pPacket %x", 
                             pChannelVc, pMyPacket) );

    ASSERT (pMyPacket != NULL);                          

    NdisUnchainBufferAtFront (pMyPacket,
                              &pMyNdisBuffer);
 
    while (pMyNdisBuffer != NULL)
    {

        NdisFreeBuffer(pMyNdisBuffer);
        nicDecChannelRecvBuffer();
        
        pMyNdisBuffer = NULL;
        
        NdisUnchainBufferAtFront (pMyPacket,
                                 &pMyNdisBuffer);
    
    } 


    //
    // Return the Descriptors to the bus driver
    //
    
    pIsochDescriptor = pPktContext->IsochListen.pIsochDescriptor;
                    

    //
    // temporary sanity check asserts
    //
    ASSERT (pIsochDescriptor != NULL);


    nicReturnDescriptorChain (pIsochDescriptor, pChannelVc);

    //
    // Free The packet 
    //
    nicFreePacket(pMyPacket, &pChannelVc->PacketPool);
    //
    // Update Count
    //
    //NdisInterlockedDecrement (&pChannelVc->OutstandingPackets ) ;

    

    TRACE( TL_T, TM_Recv, ( "<==nicChannelReturnPacket  "  ) );

}



VOID
nicReturnDescriptorChain ( 
    IN PISOCH_DESCRIPTOR pIsochDescriptor,
    IN PCHANNEL_VCCB pChannelVc
    )
{
    //
    // Walk the list of isoch descriptors and mark them as returned
    //

    PISOCH_DESCRIPTOR pCurr = NULL;
    PVOID       pNext = NULL;
    PMDL        pMdl = NULL;
    PVOID       pVa = NULL;
    ULONG       Len = 0;

    TRACE( TL_T, TM_Recv, ( "==> nicReturnDescriptorChain pIsochDescriptor %x",pIsochDescriptor  ) );
    
    pCurr = pIsochDescriptor ;
    


    while (pCurr != NULL)
    {   
        //ASSERT (pChannelVc == (PCHANNEL_VCCB)GET_CHANNELVC_FROM_DESCRIPTOR(pCurr));

        if (pNext != NULL)
        {
            pCurr = CONTAINING_RECORD (pNext, 
                                       ISOCH_DESCRIPTOR,
                                       DeviceReserved[IsochNext] );

            
        }
        
        pNext = (PVOID)NEXT_ISOCH_DESCRIPTOR(pCurr);

        TRACE (TL_V, TM_Recv ,(" Isoch Descriptors Curr %x, next %x" , pCurr, pNext) );
        
        CLEAR_DESCRIPTOR_OF_NDIS_TAG(pCurr);

        CLEAR_DESCRIPTOR_NEXT(pCurr);

        //
        // Zero out the data that is being returned to the bus driver
        //
#if 0       
        pMdl = pCurr->Mdl;
        pVa = NIC_GET_SYSTEM_ADDRESS_FOR_MDL (pMdl);

        if (pVa != NULL)
        {
            Len = NIC_GET_BYTE_COUNT_FOR_MDL(pMdl); 
            NdisZeroMemory(pVa, Len);

        }
#endif      
        pCurr = pNext;

        //
        // Update the count, The close call will wait for this count to go to zero
        //

        NdisInterlockedDecrement (&pChannelVc->NumIndicatedIsochDesc);

        //
        // Clear the Variables
        //
        pMdl = NULL;
        pVa = NULL;
        Len = 0;


    }

    TRACE( TL_T, TM_Recv, ( "<== nicReturnDescriptorChain  pIsochDescriptor %x",pIsochDescriptor  ) );


}










VOID
nicRecvNoRemoteNode(
    PADAPTERCB pAdapter
    )

    

/*++

Routine Description:

 Queues a work item to go and update the node addresses of all the remote node

Arguments:


Return Value:


--*/

{
    NDIS_STATUS NdisStatus  = NDIS_STATUS_FAILURE;
    
    TRACE( TL_T, TM_Send, ( "==>nicRecvNoRemoteNode ") );

    ASSERT (pAdapter != NULL);
    
    do
    {
        PNDIS_WORK_ITEM pUpdateTableWorkItem  = NULL;
        BOOLEAN fWorkItemAlreadyLaunched  = FALSE;

        //
        // We need to update the generation count
        //
        pUpdateTableWorkItem   = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM); 

        if (pUpdateTableWorkItem   == NULL)
        {
            TRACE( TL_A, TM_Cm, ( "Local Alloc failed for WorkItem - GetGeneration FAILED" ) );

            break;
        }

        
        
        ADAPTER_ACQUIRE_LOCK (pAdapter);
        
        if (ADAPTER_TEST_FLAGS (pAdapter, fADAPTER_UpdateNodeTable))
        {
            fWorkItemAlreadyLaunched = TRUE;
        }
        else
        {
            ADAPTER_SET_FLAG (pAdapter, fADAPTER_UpdateNodeTable);
            //
            // Ref the adapter. Deref in workitem
            //
            nicReferenceAdapter (pAdapter, "nicRecvNoRemoteNode" );
            fWorkItemAlreadyLaunched = FALSE;

        }
        
        ADAPTER_RELEASE_LOCK (pAdapter);

        if (fWorkItemAlreadyLaunched == TRUE)
        {
            FREE_NONPAGED(pUpdateTableWorkItem);
            break;
        }


        //
        // Set the Workitem
        //

        NdisInitializeWorkItem ( pUpdateTableWorkItem, 
                              (NDIS_PROC)nicUpdateNodeTable,
                              (PVOID)pAdapter );

        NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);
        
        NdisScheduleWorkItem (pUpdateTableWorkItem);

        NdisStatus = NDIS_STATUS_SUCCESS;
        
    } while (FALSE);




    TRACE( TL_T, TM_Send, ( "<==nicRecvNoRemoteNode %x", NdisStatus) );



}




VOID
nicUpdateNodeTable(
    NDIS_WORK_ITEM* pUpdateTable,
    IN PVOID Context 
    )

/*++

Routine Description:
 
    This is called when the reassembly cannot find 
    a remote node for reassembly

    For simplicity's sake, we go through all 63 entries

    We find a remote node, get its address. now the address' entry
    in the Node Table may already have another node there, so we take that 
    node out put the new remote Node in that location.  Then we go
    and update the node address of that remote node

    This is the WorkItem version of nicUpdateRemoteNodeTable

Arguments:
   pAdapter Local host

Return Value:


--*/
{

    ULONG               i = 0;
    ULONG               NumNodes = 0;
    PREMOTE_NODE        pRemoteNode = NULL;
    NODE_ADDRESS        NodeAddress ;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_SUCCESS;
    PADAPTERCB          pAdapter = (PADAPTERCB)Context;

    NdisZeroMemory (&NodeAddress, sizeof(NODE_ADDRESS));

    do
    {
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // Get a remote node
        //
        pRemoteNode = NULL;
        
        while (i<NIC1394_MAX_NUMBER_NODES)
        {
            pRemoteNode = pAdapter->NodeTable.RemoteNode[i];
            
            if (pRemoteNode != NULL)
            {
                break;
            }
            
            i++;
        }

        if (pRemoteNode != NULL)
        {
            nicReferenceRemoteNode (pRemoteNode, UpdateNodeTable);
        }           

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        //  break out if we are the end of the loop
        //

        if  (i>=NIC1394_MAX_NUMBER_NODES)
        {
            ASSERT (pRemoteNode == NULL)
            break;
        }
        
        if (pRemoteNode == NULL)
        {
            break;
        }

        i++;

    
        //
        // Now update the table. The new location of the Node in the
        // NodeTable may already have a Node, so we we will need to
        // update that remote node's address as well
        // 
        do
        {
            PREMOTE_NODE pRemNodeOld = NULL;


            nicGet1394AddressOfRemoteNode (pRemoteNode,
                                           &NodeAddress,
                                           0);
                                           

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                //
                // Just use the old node address, if it fails
                //
                NodeAddress  = pRemoteNode->RemoteAddress;
            }

            
            ADAPTER_ACQUIRE_LOCK (pAdapter);

            //
            // Extract the occupant of the location
            //
            pRemNodeOld = pAdapter->NodeTable.RemoteNode[NodeAddress.NA_Node_Number];

            //
            // Update RemoteNode Address
            //
        
            pRemoteNode->RemoteAddress = NodeAddress  ;
    
            if (pRemNodeOld == pRemoteNode)
            {
                //
                //  The remote nodes are the same, so we do not
                //  care about the old remote node
                //
                pRemNodeOld = NULL;
            }

            //
            // Only Reference And Update the Old remoteNode'address
            // if it is not our current remote node
            //

            if ( pRemNodeOld != NULL )
            {
                //
                // This location is already occupied. 
                // Take it out, reference it and update its address
                //
                nicReferenceRemoteNode (pRemNodeOld, UpdateNodeTable);
                
                
            }


            //
            //  Update the Master Node Table
            //
            pAdapter->NodeTable.RemoteNode[NodeAddress.NA_Node_Number] = pRemoteNode;

            //
            // This either derefs' the remote node or pRemNodeOld from a previous interation
            //
            nicDereferenceRemoteNode (pRemoteNode, UpdateNodeTable);

            //
            // Update pRemoteNode so that it loops again 
            // and we can update the node addres of this pRemNodeOld
            //  else it will be null and we exit this loop
            // 
            pRemoteNode = pRemNodeOld;
            
            ADAPTER_RELEASE_LOCK (pAdapter);


        } while (pRemoteNode != NULL);

    //
    // If we have not gone through all the nodes . 
    //  get the next remote node
    // 

    }while (i<NIC1394_MAX_NUMBER_NODES);
    

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    ADAPTER_CLEAR_FLAG (pAdapter, fADAPTER_UpdateNodeTable);

    ADAPTER_RELEASE_LOCK (pAdapter);

        
        
    FREE_NONPAGED (pUpdateTable);
    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);

    nicDereferenceAdapter(pAdapter, "nicRecvNoRemoteNode Derefed in  nicUpdateNodeTable" );
    
}


VOID
nicInsertNodeAddressAtHead (
    IN PNDIS_PACKET pPacket, 
    IN PNIC_RECV_DATA_INFO pRcvInfo
    )
/*++

Routine Description:
    Adds the Node Address to the first 16 bits in the packet. 
    It fails quietly if it is not able to do so

Arguments:
    pPacket  pPacket in Question
    pRcvInfo -> With the correct Gasp Header
Return Value:


--*/
{
    PNDIS1394_UNFRAGMENTED_HEADER pHeader = NULL;

    TRACE( TL_T, TM_Recv, ( "nicInsertNodeAddressAtHead , pPacket %x pRecvInfo %x",pPacket, pRcvInfo  ) );

    do
    {
        pHeader = nicNdisBufferVirtualAddress (pPacket->Private.Head);

        if (pHeader == NULL)
        {
            break;
        }

        //
        // Assert for now. Will not work if there are 1394 bridges with bus number != 0;
        //
        ASSERT (pRcvInfo->SourceID < 64);
        pHeader->u1.SourceAddress= (UCHAR)(pRcvInfo->SourceID); 

        pHeader->u1.fHeaderHasSourceAddress = TRUE;
        
    } while (FALSE);

    TRACE( TL_T, TM_Recv, ( "nicInsertNodeAddressAtHead , pHeader %x =  *pHeader %x", pHeader, pHeader->HeaderUlong  ) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\debug.h ===
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// debug.h
// IEEE1394 mini-port/call-manager driver
// Debug helper header
//
// 12/27/1998 JosephJ adapted from the l2tp project.


#ifndef _DEBUG_H_
#define _DEBUG_H_



//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

// Memory tags used with NdisAllocateMemoryWithTag to identify allocations
// made by the 1394 nic driver.  Also, several context blocks define a first field
// of 'ulTag' set to these values for ASSERT sanity checking and eased memory
// dump browsing.  Such tags are set to MTAG_FREED just before NdisFreeMemory
// is called. Form: N13a, N13b, etc.
//
#define MTAG_FREED              'a31N'
#define MTAG_ADAPTERCB          'b31N'
#define MTAG_AFCB               'c31N'
#define MTAG_VCCB               'd31N'
#define MTAG_WORKITEM           'e31N'
#define MTAG_TIMERQ             'f31N'
#define MTAG_TIMERQITEM         'g31N'
#define MTAG_PACKETPOOL         'h31N'
#define MTAG_FBUFPOOL           'i31N'
#define MTAG_HBUFPOOL           'j31N'
#define MTAG_INCALL             'k31N'
#define MTAG_UTIL               'l31N'
#define MTAG_RBUF               'r31N'   // Used in Receive Buffer 
#define MTAG_REMOTE_NODE        'p31N'
#define MTAG_CBUF               'n31N' // Used in send buffer
#define MTAG_DEFAULT            'z31N'
#define MTAG_FRAG               'x31N'
#define MTAG_REASSEMBLY         's31N'
#define MTAG_PKTLOG             'y31N'
#define MTAG_FIFO               'w31N'
// Trace levels.
//
#define TL_None 0    // Trace disabled
#define TL_A    0x10 // Alert
#define TL_I    0x18 // Interface (highest level workable for general use)
#define TL_N    0x20 // Normal
#define TL_T    0x25 // Displays Entry and Exit points of all functions
#define TL_V    0x30 // Verbose
#define TL_D    0x40 // Dump packets

// Trace mask bits.
//
#define TM_Cm       0x00000001 // Call manager general
#define TM_Mp       0x00000002 // Mini-port general
#define TM_Send     0x00000004 // Send path
#define TM_Recv     0x00000008 // Receive path
#define TM_Init     0x00000020 // Initialization
#define TM_Misc     0x00000040 // Miscellaneous
#define TM_Bcm      0x00000080 // BCM Algorithm
#define TM_Pkt      0x00000100 // Dump packets
#define TM_Reas     0x00000200 // Reassembly
#define TM_Irp      0x00000400 // Irp Handling and Bus Interface routines
#define TM_Ref      0x00010000 // References
#define TM_Time     0x00020000 // Timer queue
#define TM_Pool     0x00080000 // Buffer and packet pooling
#define TM_Stat     0x00100000 // Call statistics
#define TM_RemRef   0x00200000 // Remote Node Refs
#define TM_Spec     0x01000000 // Special purpose temporary traces
#define TM_Lock     0x02000000 // Lock Acquure / Release
#define TM_Dbg      0x80000000 // Debug corruption checks

#define TM_Wild 0xFFFFFFFF // Everything
#define TM_All  0x7FFFFFFF // Everything except corruption checks
#define TM_Base 0x000000FF // Base only

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16


//-----------------------------------------------------------------------------
// Debug global declarations (defined in debug.c)
//-----------------------------------------------------------------------------

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' and from
// any (TM_*) set(s) present in 'g_ulTraceMask' are displayed.
//
extern ULONG g_ulTraceLevel;
extern ULONG g_ulTraceMask;


//-----------------------------------------------------------------------------
// Debug macros
//-----------------------------------------------------------------------------

#if DBG

// TRACE sends printf style output to the kernel debugger.  Caller indicates a
// "verbosity" level with the 'ulLevel' argument and associates the trace with
// one or more trace sets with the 'ulMask' bit mask argument.  Notice that
// the variable count printf arguments 'Args' must be parenthesized.  For
// example...
//
// A "leave" routine message:
//     TRACE( TL_N, TM_Init, ( "DriverEntry=$%x", status ) );
// An error condition occurred:
//     TRACE( TL_E, TM_Init, ( "NdisMRegisterMiniport=$%x", status ) );
//
//
#define TRACE(ulLevel,ulMask,Args)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        DbgPrint Args;                                         \
        DbgPrint( "\n" );                                      \
    }                                                          \
}

// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                           \
{                                                           \
    if (!(x))                                               \
    {                                                       \
        DbgPrint( "N13: !ASSERT( %s ) at line %d of %s\n",  \
            #x, __LINE__, __FILE__ );                       \
        DbgBreakPoint();                                    \
    }                                                       \
}

// DUMP prints to the kernel debugger a hex dump of 'cb' bytes starting at 'p'
// in groups of 'ul'.  If 'f' is set the address of each line in shown before
// the dump.  DUMPB, DUMPW, and DUMPDW are BYTE, WORD, and DWORD dumps
// respectively.  Note that the multi-byte dumps do not reflect little-endian
// (Intel) byte order.  The 'ulLevel' and 'ulMask' are described for TRACE.
//
#define DUMP(ulLevel,ulMask,p,cb,f,ul)                         \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, f, ul );                          \
    }                                                          \
}

#define DUMPB(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 1 );                           \
    }                                                          \
}

#define DUMPW(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 2 );                           \
    }                                                          \
}

#define DUMPDW(ulLevel,ulMask,p,cb)                            \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 4 );                           \
    }                                                          \
}


// Double-linked list corruption detector.  Runs the test if 'ulMask' is
// enabled, with TM_Dbg a suggested setting.  Shows verbose output if
// 'ulLevel' is at or above the current trace threshold.
//
#define CHECKLIST(ulMask,p,ulLevel)                            \
{                                                              \
    if (g_ulTraceMask & ulMask)                                \
    {                                                          \
        CheckList( p, (BOOLEAN )(ulLevel <= g_ulTraceLevel) ); \
    }                                                          \
}


// DBG_if can be used to put in TRACE/DUMPs conditional on an expression that
// need not be evaluated in non-DBG builds, e.g the statements below generate
// no code in a non-DBG build, but in DBG builds print the TRACE if x<y and
// asserts otherwise.
//
//     DBG_if (x < y)
//         TRACE( TL_N, TM_Misc, ( "x < y" ) );
//     DBG_else
//         ASSERT( FALSE );
//
//
#define DBG_if(x) if (x)
#define DBG_else  else


#else // !DBG

// Debug macros compile out of non-DBG builds.
//
#define TRACE(ulLevel,ulMask,Args)
#undef ASSERT
#define ASSERT(x)
#define DUMP(ulLevel,ulMask,p,cb,f,dw)
#define DUMPB(ulLevel,ulMask,p,cb)
#define DUMPW(ulLevel,ulMask,p,cb)
#define DUMPDW(ulLevel,ulMask,p,cb)
#define CHECKLIST(ulMask,p,ulLevel)
#define DBG_if(x)
#define DBG_else

#endif


//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

#if DBG

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );
#else
#define Dump(p,cb,fAddress,ulGroup)

#endif


VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\globals.c ===
// Copyright (c) 2000-2002, Microsoft Corporation, all rights reserved
//
// globals.c
//
// IEEE1394 mini-port/call-manager driver
//
//
// Loads and unload the ARP module when the 
// bridge is activated
//
// Created by Adube
//

#include <precomp.h>


NIC1394_CHARACTERISTICS Nic1394Characteristics =
{
    5,
    1,
    0,
    NicRegisterEnum1394,
    NicDeregisterEnum1394,
    nicAddRemoteNode,
    nicRemoveRemoteNode
};

ENUM1394_REGISTER_DRIVER_HANDLER    NdisEnum1394RegisterDriver = NULL;
ENUM1394_DEREGISTER_DRIVER_HANDLER  NdisEnum1394DeregisterDriver = NULL;
ENUM1394_REGISTER_ADAPTER_HANDLER   NdisEnum1394RegisterAdapter = NULL;
ENUM1394_DEREGISTER_ADAPTER_HANDLER NdisEnum1394DeregisterAdapter = NULL;

PCALLBACK_OBJECT                Nic1394CallbackObject = NULL;
PVOID                           Nic1394CallbackRegisterationHandle = NULL;


ULONG g_IsochTag = ISOCH_TAG;
ULONGLONG g_ullOne = 1;


LONG g_ulMedium ;
UINT NumRecvFifos = NUM_RECV_FIFO_FIRST_PHASE ; 
UINT NicSends;
UINT BusSends;
UINT NicSendCompletes;
UINT BusSendCompletes;


const PUCHAR pnic1394DriverDescription = "NET IP/1394 Miniport";
const USHORT nic1394DriverGeneration = 0;

BOOLEAN g_ulNicDumpPacket  = FALSE;
ULONG g_ulDumpEthPacket = 0;


// Debug counts of client oddities that should not be happening.
//
ULONG g_ulUnexpectedInCallCompletes = 0;
ULONG g_ulCallsNotClosable = 0;
BOOLEAN g_AdapterFreed = FALSE;


ULONG AdapterNum = 0;


const unsigned char Net1394ConfigRom[48] = {
    0x00, 0x04, 0xad, 0xeb, 0x12, 0x00, 0x00, 0x5e, 
    0x13, 0x00, 0x00, 0x01, 0x17, 0x7b, 0xb0, 0xcf, 
    0x81, 0x00, 0x00, 0x01, 0x00, 0x06, 0x38, 0x91, 
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x09, 
    0x4e, 0x00, 0x49, 0x00, 0x43, 0x00, 0x31, 0x00, 
    0x33, 0x00, 0x39, 0x00, 0x34, 0x00, 0x00, 0x00
};






//
// Histograms to collect data
//
STAT_BUCKET     SendStats;
STAT_BUCKET     RcvStats;

// Stats
ULONG           nicMaxRcv;
ULONG           nicMaxSend;
ULONG           BusFailure;
ULONG           MallocFailure;
ULONG           IsochOverwrite;
ULONG           RcvTimerCount;      // Number of times timer has fired.
ULONG           SendTimerCount;     // Number of times timer has fired.
ULONG           TotSends;
ULONG           TotRecvs;
ULONG           MaxIndicatedFifos;
ULONG           MdlsAllocated[NoMoreCodePaths];
ULONG           MdlsFreed[NoMoreCodePaths];
ULONG           NdisBufferAllocated[NoMoreCodePaths];
ULONG           NdisBufferFreed[NoMoreCodePaths];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\irp.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// irp.c
//
// IEEE1394 mini-port/call-manager driver
//
// Routines that issue the numerous Irbs to the 1394 Bus driver 
//
// 04/01/1999 ADube Created, 
//

#include "precomp.h"



//
// This file will contain all the functions that issue Irps with the various Irbs to the 
// 1394 bus. All Irbs except the actual send/recv irbs will be implemented here
//

//
// The functions will follow this general algorithm
// nicGetIrb
// nicInitialize....Irb
// nicPrintDebugSpew
// nicGetIrp
// nicSubmit_Irp_Synch
// return Status
//

//-----------------------------------------------------------------------------
// A Simple template that can be used to send Irps syncronously
//-----------------------------------------------------------------------------



/*
Comments Template

/*++

Routine Description:


Arguments:


Return Value:


--*/

/*

    // Function Description:
    //
    //
    //
    //
    //
    // Arguments
    //
    //
    //
    // Return Value:
    //
    //
    //
    //




Function template

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    

    TRACE( TL_T, TM_Irp, ( "==>nicGe....ect, pAdapter %x", pAdapter ) );


    ASSERT (pNodeAddress != NULL);
    do
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressFromDeviceObject, nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        nicInit....Irb (..)
        
        
        NdisStatus = nicGetIrp ( pRemoteNodePdoCb, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressFromDeviceObject, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_Synch ( pAdapter->pLocalHostPdoCb,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressFromDeviceObject, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;


        }
    
        Copy returned data to nic1394's data structures

    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    TRACE( TL_T, TM_Irp, ( "<==nicGet139...,  pAdapter %x", pAdapter ) );


    return NdisStatus;







*/

//-----------------------------------------------------------------------------
// Routines begin here
//-----------------------------------------------------------------------------

NDIS_STATUS
nicAllocateAddressRange_Synch (
    IN PADAPTERCB pAdapter,
    IN PMDL pMdl,
    IN ULONG fulFlags,
    IN ULONG nLength,
    IN ULONG MaxSegmentSize,
    IN ULONG fulAccessType,
    IN ULONG fulNotificationOptions,
    IN PVOID Callback,
    IN PVOID Context,
    IN ADDRESS_OFFSET  Required1394Offset,
    IN PSLIST_HEADER   FifoSListHead,
    IN PKSPIN_LOCK     FifoSpinLock,
    OUT PULONG pAddressesReturned,  
    IN OUT PADDRESS_RANGE  p1394AddressRange,
    OUT PHANDLE phAddressRange
    )
    // Function Description:
    //   Takes the parameter and just passes it down to the bus driver
    // Arguments
    //
    // Return Value:
    //

{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    

    TRACE( TL_T, TM_Irp, ( "==>nicAllocateAddressRange_Synch, pAdapter %x, Offset %x", pAdapter, Required1394Offset ) );

    TRACE (TL_V, TM_Irp, ("    pMdl %x, fulFlags %x, nLength %x, MaxSegmentSize %x, fulAcessType %x", 
                              pMdl, fulFlags, nLength, MaxSegmentSize, fulAccessType ) );

    TRACE (TL_V, TM_Irp, ("    fulNotification %x, Callback %x, Context %x, ReqOffset.High %x, ReqOffset.Low %x" ,
                               fulNotificationOptions, Callback, Context, Required1394Offset.Off_High, Required1394Offset.Off_Low ) );

    TRACE (TL_V, TM_Irp, ("    FifoSListHead %x, FifoSpinLock %x, p1394AddressRange %x" ,FifoSListHead, FifoSpinLock, p1394AddressRange ) )
    do
    {
        
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicAllocateAddressRange_Synch , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

            
        NdisStatus = nicGetIrp (pAdapter->pNextDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicAllocateAddressRange_Synch , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);

        pIrb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;      
        pIrb->Flags = 0;
        pIrb->u.AllocateAddressRange.Mdl = pMdl;                    // Address to map to 1394 space
        pIrb->u.AllocateAddressRange.fulFlags = fulFlags;               // Flags for this operation
        pIrb->u.AllocateAddressRange.nLength = nLength;                // Length of 1394 space desired
        pIrb->u.AllocateAddressRange.MaxSegmentSize = MaxSegmentSize;         // Maximum segment size for a single address element
        pIrb->u.AllocateAddressRange.fulAccessType = fulAccessType;          // Desired access: R, W, L
        pIrb->u.AllocateAddressRange.fulNotificationOptions = fulNotificationOptions; // Notify options on Async access
        pIrb->u.AllocateAddressRange.Callback = Callback;               // Pointer to callback routine
        pIrb->u.AllocateAddressRange.Context = Context;                // Pointer to driver supplied data
        pIrb->u.AllocateAddressRange.Required1394Offset = Required1394Offset;     // Offset that must be returned
        pIrb->u.AllocateAddressRange.FifoSListHead = FifoSListHead;          // Pointer to SList FIFO head
        pIrb->u.AllocateAddressRange.FifoSpinLock = FifoSpinLock;           // Pointer to SList Spin Lock
        pIrb->u.AllocateAddressRange.p1394AddressRange = p1394AddressRange; // Address Range Returned

        ASSERT ( pIrb->u.AllocateAddressRange.p1394AddressRange != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                               pIrp,
                                               pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicAllocateAddressRange_Synch , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;


        }

        //
        // Update the output values
        //
        
        *pAddressesReturned = pIrb->u.AllocateAddressRange.AddressesReturned;      // Number of addresses returned
        p1394AddressRange = pIrb->u.AllocateAddressRange.p1394AddressRange;      // Pointer to returned 1394 Address Ranges
        *phAddressRange = pIrb->u.AllocateAddressRange.hAddressRange;          // Handle to address range
        
        TRACE (TL_V, TM_Irp, ("    *pAddressesReturned  %x, p1394AddressRange %x, phAddressRange %x," ,
                                   *pAddressesReturned, p1394AddressRange, *phAddressRange ) );
    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    TRACE( TL_T, TM_Irp, ( "<==nicAllocateAddressRange_Synch, Status %x", NdisStatus) );

    return NdisStatus;


}








NDIS_STATUS
nicGet1394AddressOfRemoteNode( 
    IN PREMOTE_NODE pRemoteNode,
    IN OUT NODE_ADDRESS *pNodeAddress,
    IN ULONG fulFlags
    )
    // Function Description:
    // This function will get the 1394 Address from the device object. 
    //
    // Arguments
    // PdoCb * Local Host's Pdo Control Block
    // NodeAddress * Node Address structre wher the address will be returned in 
    // fulFlags - Could specify USE_LOCAL_HOST
    //
    // Return Value:
    // Success if the irp succeeeded
    // Failure: if the pdo is not active or the irp failed
    //
    
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    
    TRACE( TL_T, TM_Irp, ( "==>nicGet1394AddressOfRemoteNode, pRemoteNode %x, pNodeAdddress ", pRemoteNode, pNodeAddress) );


    ASSERT (pNodeAddress != NULL);
    do
    {
    
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressOfRemoteNode, nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);
        
        pIrb->FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;     
        pIrb->u.Get1394AddressFromDeviceObject.fulFlags = fulFlags;

        NdisStatus = nicGetIrp (pRemoteNode->pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressOfRemoteNode, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);

        
        NdisStatus = nicSubmitIrp_Synch (pRemoteNode,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressOfRemoteNode, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;


        }
    
        (*pNodeAddress) = pIrb->u.Get1394AddressFromDeviceObject.NodeAddress;

    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //

    nicFreeIrb(pIrb);

    nicFreeIrp(pIrp);

    TRACE( TL_T, TM_Irp, ( "<==nicGet1394AddressOfRemoteNode, Status %x, Address %x", NdisStatus, *pNodeAddress ) );

    return NdisStatus;
}








NDIS_STATUS
nicGet1394AddressFromDeviceObject( 
    IN PDEVICE_OBJECT pPdo,
    IN OUT NODE_ADDRESS *pNodeAddress,
    IN ULONG fulFlags
    )
    // Function Description:
    // This function will get the 1394 Address from the device object. 
    //
    // Arguments
    // PdoCb * Local Host's Pdo Control Block
    // NodeAddress * Node Address structre wher the address will be returned in 
    // fulFlags - Could specify USE_LOCAL_HOST
    //
    // Return Value:
    // Success if the irp succeeeded
    // Failure: if the pdo is not active or the irp failed
    //
    
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    
    TRACE( TL_T, TM_Irp, ( "==>nicGet1394AddressFromDeviceObject, pPdo %x, pNodeAdddress ", 
                            pPdo, pNodeAddress) );


    ASSERT (pNodeAddress != NULL);
    ASSERT (pPdo != NULL);
    do
    {
    
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressFromDeviceObject, nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        pIrb->Flags = 0;
        pIrb->FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;     
        pIrb->u.Get1394AddressFromDeviceObject.fulFlags = fulFlags;

        NdisStatus = nicGetIrp (pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressFromDeviceObject, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);

        
        NdisStatus = nicSubmitIrp_PDOSynch (pPdo,
                                            pIrp,
                                            pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGet1394AddressFromDeviceObject, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;


        }
    
        (*pNodeAddress) = pIrb->u.Get1394AddressFromDeviceObject.NodeAddress;

    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //

    nicFreeIrb(pIrb);

    nicFreeIrp(pIrp);

    TRACE( TL_T, TM_Irp, ( "<==nicGet1394AddressFromDeviceObject, Status %x, Address %x", NdisStatus, *pNodeAddress ) );

    return NdisStatus;
}



NDIS_STATUS
nicGetGenerationCount(
    IN PADAPTERCB       pAdapter,
    IN OUT PULONG    GenerationCount
    )
    // This function returns the generation count of the Device Object that PDO points to.
    //
{
    NDIS_STATUS       NdisStatus = NDIS_STATUS_SUCCESS;
    PIRB               pIrb = NULL;
    PIRP               pIrp = NULL;
    PDEVICE_OBJECT   pDeviceObject = pAdapter->pNextDeviceObject;


    TRACE( TL_T, TM_Irp, ( "==>nicGetGenerationCount, PDO %x, pVc %x", pDeviceObject ) );



    ASSERT( pDeviceObject != NULL);
    


    do
    {

        NdisStatus  = nicGetIrb( &pIrb );
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {

            TRACE( TL_A, TM_Irp, ( "Failed to allocate an Irb in nicGetGenerationCout") );
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisStatus = nicGetIrp (pDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {

            TRACE( TL_A, TM_Irp, ( "Failed to allocate an Irp in nicGetGenerationCout") );
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        

        pIrb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
        pIrb->Flags = 0;

        NdisStatus = nicSubmitIrp_LocalHostSynch( pAdapter, pIrp, pIrb);

        if (NdisStatus == NDIS_STATUS_SUCCESS) 
        {
        
            *GenerationCount = pIrb->u.GetGenerationCount.GenerationCount;

            TRACE( TL_N, TM_Irp,  ("GenerationCount = 0x%x\n", *GenerationCount) );
        }
        else 
        {

            TRACE(TL_A, TM_Irp, ("SubmitIrpSync failed = 0x%x\n", NdisStatus));
            ASSERT (0);
            break;
        }


    } while(FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //

    nicFreeIrb(pIrb);

    nicFreeIrp(pIrp);
    
    TRACE( TL_T, TM_Irp, ( "<==nicGetGenerationCount, PDO %x, Generation %x", pDeviceObject, *GenerationCount) );

    return NdisStatus;
}




NDIS_STATUS
nicFreeAddressRange(
    IN PADAPTERCB pAdapter,
    IN ULONG nAddressesToFree,
    IN PADDRESS_RANGE p1394AddressRange,
    IN PHANDLE phAddressRange
    )
    // Function Description:
    //    This is the generic call to free an address range. It is the callers responsibility to figure out 
    //    the reference counting on the RemoteNode
    //    This is because in the RecvFIFO code path we allocate one address range on each remote node
    //    whereas in the Broadcast channel register, we allocate one addreesss on ONE remote node only
    //
    // Arguments
    //  pRemoteNode, - Remote Node used to submit the IRP
    //  nAddressesToFree, - Number of addreses to free
    //  p1394AddressRange, - pointer to the address range which was allocated
    //  phAddressRange - Handle returned by the bus driver
    //
    // Return Value:
    // Success if the irp succeeeded
    // Failure: if the pdo is not active or the irp failed
    //
    
{
 
    PIRP    pIrp            = NULL;
    PIRB    pIrb            = NULL;
    PDEVICE_OBJECT  pPdo    = pAdapter->pNextDeviceObject;
    NDIS_STATUS NdisStatus  = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Irp, ( "==>nicFreeAddressRange  pAdapter %x", pAdapter ) );
    
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL); 
    
    do
    {

        if (pPdo == NULL)
        {
            TRACE( TL_A, TM_Irp, ( "pPdo is NULL in nicFreeRecvFifoAddressRange" ) );
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }


        NdisStatus = nicGetIrb(&pIrb);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrb failed in nicFreeRecvFifoAddressRange" ) );
            break;
        }

        
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrp failed in nicFreeRecvFifoAddressRange" ) );
            break;
        }

        TRACE (TL_V, TM_Cm, (" NumAddresses %x, hAddressRange %x, Hi %x, Length %x, Lo %x", 
                               nAddressesToFree,
                               phAddressRange,
                               p1394AddressRange->AR_Off_High,
                               p1394AddressRange->AR_Length,
                               p1394AddressRange->AR_Off_Low ) );
        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_FREE_ADDRESS_RANGE;
        pIrb->Flags = 0;
        pIrb->u.FreeAddressRange.nAddressesToFree = nAddressesToFree;
        pIrb->u.FreeAddressRange.p1394AddressRange = p1394AddressRange;
        pIrb->u.FreeAddressRange.pAddressRange = phAddressRange;


        
        NdisStatus = nicSubmitIrp_LocalHostSynch( pAdapter, 
                                                 pIrp,
                                                 pIrb );


        
    } while (FALSE);

    //
    // Free the locally allocated memory
    //
    nicFreeIrb(pIrb);

    nicFreeIrp(pIrp);

            
    //
    // We do not care about the status, because we do not know what to do if it fails.
    // However, spew some debug out.
    //

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_N, TM_Irp, ( "nicFreeAddressRangeFAILED %x", NdisStatus) );
    
        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
    }


    
    TRACE( TL_T, TM_Irp, ( "<==nicFreeAddressRangeStatus %x (always success)", NdisStatus) );

    NdisStatus = NDIS_STATUS_SUCCESS;
    return NdisStatus;
}





VOID
nicFreeAddressRangeDebugSpew(
    IN PIRB pIrb 
    )
    // This functions spews out the parameters in a Free Address Range Irb
    //
    //
{


    TRACE( TL_V, TM_Irp, ( "==>nicFreeAddressRangeDebugSpew, pIrb = %x", pIrb) );
    ASSERT(pIrb != NULL);
    
    TRACE( TL_N, TM_Irp, ( "Num Addresses Returned %x ",pIrb->u.FreeAddressRange.nAddressesToFree ) );
    TRACE( TL_N, TM_Irp, ( "Address High %x", pIrb->u.FreeAddressRange.p1394AddressRange->AR_Off_High ) );
    TRACE( TL_N, TM_Irp, ( "Address Low %x", pIrb->u.FreeAddressRange.p1394AddressRange->AR_Off_Low ) );
    TRACE( TL_N, TM_Irp, ( "Address Length %x", pIrb->u.FreeAddressRange.p1394AddressRange->AR_Length ) );
    TRACE( TL_N, TM_Irp, ( "Handle %x", pIrb->u.FreeAddressRange.pAddressRange ) );
    
    TRACE( TL_V, TM_Irp, ( "<==nicFreeAddressRangeDebugSpew " ) );

}



NDIS_STATUS
nicFreeChannel(
    IN PADAPTERCB pAdapter,
    IN ULONG nChannel
    )
    // Function Description:
    //  This function sends an Irp to the Bus driver to free a channel
    //  Any remote Pdo can be used for the Irp. However for the sake of
    //  bookkeeping use the same Pdo that the channel was allocated on (maybe) 
    // Arguments
    //  PdoCb The Pdo for the remote node to which the Irp is submitted
    //  Channel Pointer The Channel, requested and the  channel returned
    //
    // Return Value:
    // Success if the channel was allocated
    // Failure otherwise
    //
    
{
 
    PIRP    pIrp            = NULL;
    PIRB    pIrb            = NULL;
    PDEVICE_OBJECT pPdo     = pAdapter->pNextDeviceObject;
    NDIS_STATUS NdisStatus  = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Irp, ( "==>nicFreeChannel pAdapter %x, Channel %x", pAdapter, nChannel) );
    
    ASSERT (pAdapter!= NULL);
    ASSERT (pPdo != NULL);
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL); 
    
    do
    {

        if (pPdo == NULL)
        {
            TRACE( TL_A, TM_Irp, ( "pPdo is NULL in nicFreeChannel" ) );
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }


        NdisStatus = nicGetIrb(&pIrb);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrb failed in nicFreeChannel" ) );
            break;
        }

        
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrp failed in nicFreeChannel" ) );
            break;
        }

        
        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_FREE_CHANNEL;
        pIrb->Flags = 0;
        pIrb->u.IsochFreeChannel.nChannel = nChannel;

        
        NdisStatus = nicSubmitIrp_LocalHostSynch( pAdapter, 
                                              pIrp,
                                              pIrb );

        //
        // Regardless update the mask, as the channel could have been freed by a bus reset
        //
        if (nChannel != BROADCAST_CHANNEL)
        {
            ADAPTER_ACQUIRE_LOCK (pAdapter);
            

            //
            // Clear the channel in the mask
            //
            pAdapter->ChannelsAllocatedByLocalHost &= (~( g_ullOne <<nChannel ));

            ADAPTER_RELEASE_LOCK (pAdapter);

        }

    } while (FALSE);

    //
    // Free the locally allocated memory
    //
    nicFreeIrb(pIrb);

    nicFreeIrp(pIrp);

            
    //
    // We do not care about the status, because we do not know what to do if it fails.
    // However, spew some debug out.
    //

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_N, TM_Irp, ( "nicFreeChannel FAILED %x", NdisStatus) );
    }


    
    TRACE( TL_T, TM_Irp, ( "<==nicFreeChannel Status %x ", NdisStatus) );

    return NdisStatus;
}



NDIS_STATUS
nicAllocateChannel (
    IN PADAPTERCB pAdapter,
    IN ULONG Channel,
    OUT PULARGE_INTEGER pChannelsAvailable OPTIONAL
    )
    // Function Description:
    //  This function sends an Irp to the Bus driver to allocate a channel
    //  Any remote Pdo can be used for the Irp
    //  
    // Arguments
    //  PdoCb The Pdo for the remote node to which the Irp is submitted
    //  Channel  -The Channel, requested and the  channel returned
    //
    // Return Value:
    // Success if the channel was allocated
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    PDEVICE_OBJECT pDeviceObject = pAdapter->pNextDeviceObject;
    STORE_CURRENT_IRQL;

    TRACE( TL_T, TM_Irp, ( "==>nicIsochAllocateChannel, PdoCb, %x Channel %d", pAdapter, Channel ) );

    do
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicIsochAllocateChannel , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_CHANNEL;
        pIrb->Flags = 0;
        pIrb->u.IsochAllocateChannel.nRequestedChannel = Channel;

        ASSERT (Channel < 64);
            
        NdisStatus = nicGetIrp ( pDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochAllocateChannel , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                               pIrp,
                                               pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochAllocateChannel , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }
    
        if (pChannelsAvailable  != NULL)
        {
            pChannelsAvailable->QuadPart = pIrb->u.IsochAllocateChannel.ChannelsAvailable.QuadPart; 

        }
        

        TRACE( TL_N, TM_Irp, ( "Channel allocated %d", Channel ) );

        if (Channel != BROADCAST_CHANNEL)
        {
            
            ADAPTER_ACQUIRE_LOCK (pAdapter);
            

            //
            // Set the channel in the mask
            //
            pAdapter->ChannelsAllocatedByLocalHost |= ( g_ullOne <<Channel );

            ADAPTER_RELEASE_LOCK (pAdapter);

        }

    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;

    TRACE( TL_T, TM_Irp, ( "<==nicIsochAllocateChannel, Channel %d, Status %x",  Channel, NdisStatus ) );
        
    return NdisStatus;
}




NDIS_STATUS
nicQueryChannelMap (
    IN PADAPTERCB pAdapter,
    OUT PULARGE_INTEGER pChannelsAvailable 
    )
    // Function Description:
    //  This function sends an Irp to the Bus driver to allocate a channel
    //  Any remote Pdo can be used for the Irp
    //  
    // Arguments
    //  PdoCb The Pdo for the remote node to which the Irp is submitted
    //  Channel  -The Channel, requested and the  channel returned
    //
    // Return Value:
    // Success if the channel was allocated
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    PDEVICE_OBJECT pDeviceObject = pAdapter->pNextDeviceObject;
    STORE_CURRENT_IRQL;

    TRACE( TL_T, TM_Irp, ( "==>nicQueryChannelMap , PdoCb, %x ", pAdapter) );

    do
    {
        if (pChannelsAvailable == NULL)
        {
            ASSERT (pChannelsAvailable != NULL);
            NdisStatus =  NDIS_STATUS_FAILURE;
            break;
        }

        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicQueryChannelMap  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_QUERY_RESOURCES ;
        pIrb->u.IsochQueryResources.fulSpeed = SPEED_FLAGS_100;
        pIrb->Flags = 0;

            
        NdisStatus = nicGetIrp ( pDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicQueryChannelMap  , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                               pIrp,
                                               pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicQueryChannelMap  , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }

        

        //
        // We get the *available* channels, in network-byte order.
        // We have to byte reverse and flip the bits to get 
        // it in the form we want.
        //
        // Looks like we really have to flip the *bits*, not just the bytes.
        //
        {
            LARGE_INTEGER in, out;
            PUCHAR        puc;
            UINT u;
            in = pIrb->u.IsochQueryResources.ChannelsAvailable;
            out.LowPart =  ~SWAPBYTES_ULONG (in.HighPart );
            out.HighPart = ~SWAPBYTES_ULONG (in.LowPart );

            // Now swap the bits in each byte.
            //
            puc = (PUCHAR) &out;
            for (u=sizeof(out); u; u--,puc++)
            {
                UCHAR uc,uc1;
                UINT u1;
                uc= *puc;
                uc1=0;
                for (u1=0;u1<8;u1++)
                {
                    if (uc & (1<<u1))
                    {
                        uc1 |= (1 << (7-u1));
                    }
                }
                *puc = uc1;
            }

            pChannelsAvailable->QuadPart = out.QuadPart;
        }

        
            
    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;

    TRACE( TL_T, TM_Irp, ( "<==nicQueryChannelMap , , Status %x",  NdisStatus ) );
        
    return NdisStatus;
}


NDIS_STATUS
nicIsochAllocateBandwidth(
    IN PREMOTE_NODE pRemoteNodePdoCb,
    IN ULONG MaxBytesPerFrameRequested, 
    IN ULONG SpeedRequested,
    OUT PHANDLE phBandwidth,
    OUT PULONG  pBytesPerFrameAvailable,
    OUT PULONG  pSpeedSelected
    )

    // Function Description:
    //   This function allocates bandwith on the bus
    //   
    // Arguments
    //  PdoCb - Remote Nodes Pdo Block
    //  MaxBytesPerFrame Requested -
    //  SpeedRequested - 
    //  hBandwidth
    //  pSpeedSelected
    //  Bytes Per Frame Available
    //
    //
    // Return Value:
    //  hBandwidth, 
    //  Speed and 
    //  BytesPerFrameAvailable
    //
    //
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    

    TRACE( TL_T, TM_Irp, ( "==>nicIsochAllocateBandwidth, pRemoteNodePdoCb %x", pRemoteNodePdoCb) );


    do
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK( TM_Irp, ( "nicIsochAllocateBandwidth, nicGetIrb FAILED" ) );
        }
        
        ASSERT ( pIrb != NULL);

        pIrb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_BANDWIDTH;
        pIrb->Flags = 0;
        pIrb->u.IsochAllocateBandwidth.nMaxBytesPerFrameRequested = MaxBytesPerFrameRequested;
        pIrb->u.IsochAllocateBandwidth.fulSpeed = SpeedRequested;

        
        ASSERT (pRemoteNodePdoCb->pPdo != NULL);
        
        NdisStatus = nicGetIrp (pRemoteNodePdoCb->pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK( TM_Irp, ( "nicIsochAllocateBandwidth, nicGetIrp FAILED" ) );
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_Synch ( pRemoteNodePdoCb,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE (TL_N, TM_Irp, ( "nicIsochAllocateBandwidth, nicSubmitIrp_Synch FAILED ") );
            break;
        }

        *phBandwidth = pIrb->u.IsochAllocateBandwidth.hBandwidth ;
        *pBytesPerFrameAvailable = pIrb->u.IsochAllocateBandwidth.BytesPerFrameAvailable;
        *pSpeedSelected = pIrb->u.IsochAllocateBandwidth.SpeedSelected;
  
        TRACE( TL_V, TM_Irp, ( "hBandwidth %x", *phBandwidth) );
        TRACE( TL_V, TM_Irp, ( "BytesPerFrameAvailable %x", *pBytesPerFrameAvailable) );
        TRACE( TL_V, TM_Irp, ( "SpeedSelected %x", *pSpeedSelected) );

            

    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    TRACE( TL_T, TM_Irp, ( "<==nicIsochAllocateBandwidth NdisStatus %x", NdisStatus) );

    return NdisStatus;

}



NDIS_STATUS
nicAsyncRead_Synch(
    PREMOTE_NODE    pRemoteNode,
    IO_ADDRESS      DestinationAddress,     
    ULONG           nNumberOfBytesToRead,
    ULONG           nBlockSize,
    ULONG           fulFlags,
    PMDL            Mdl,
    ULONG           ulGeneration,
    OUT NTSTATUS    *pNtStatus
    )

    
    // Function Description:
    //  This is an asyc read operation a remote node;s address space
    //
    //
    //
    //
    // Arguments
    //PREMOTE_NODE  pRemoteNode             // Remote Node which owns the Destination address
    //        IO_ADDRESS      DestinationAddress;     // Address to read from
    //        ULONG           nNumberOfBytesToRead;   // Bytes to read
    //        ULONG           nBlockSize;             // Block size of read
    //        ULONG           fulFlags;               // Flags pertinent to read
    //        PMDL            Mdl;                    // Destination buffer
    //        ULONG           ulGeneration;           // Generation as known by driver
    //
    // Return Value:
    //  Success - if successful
    //  Invalid Generation
    //
    //
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;


    
    TRACE( TL_T, TM_Mp, ( "==>nicAsyncRead, Remote Node, %x ", pRemoteNode ) );



    TRACE( TL_V, TM_Mp, ( "   fulFlags %x, Mdl %x, Generation %x, pNtStatus %x",   
                               fulFlags, Mdl, ulGeneration, pNtStatus ) );

    ASSERT(DestinationAddress.IA_Destination_Offset.Off_High  == INITIAL_REGISTER_SPACE_HI);


    do 
    {
        NdisStatus = nicGetIrp ( pRemoteNode->pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (  TM_Irp, ( "nicAsyncRead, nicGetIrp FAILED" ) );
            break;
        }
        

        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK ( TM_Irp, ( "nicAsyncRead, nicGetIrb FAILED" ) );
        }
        
        ASSERT ( pIrb != NULL);
        ASSERT (pIrp != NULL);



        pIrb->FunctionNumber = REQUEST_ASYNC_READ;
        pIrb->Flags = 0;
        pIrb->u.AsyncRead.DestinationAddress = DestinationAddress; 
        pIrb->u.AsyncRead.nNumberOfBytesToRead  = nNumberOfBytesToRead ; 
        pIrb->u.AsyncRead.nBlockSize = nBlockSize ;  
        pIrb->u.AsyncRead.fulFlags = fulFlags;
        pIrb->u.AsyncRead.Mdl = Mdl;
        pIrb->u.AsyncRead.ulGeneration = ulGeneration; 

        NdisStatus = nicSubmitIrp_Synch ( pRemoteNode,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE ( TL_A, TM_Irp, ( "nicAsyncRead, nicSubmitIrp_Synch FAILED %xm pRemoteNode %x", NdisStatus, pRemoteNode) );
            break;
        }

        if (pNtStatus != NULL)
        {
            *pNtStatus = pIrp->IoStatus.Status;
        }


    } while (FALSE);



    TRACE( TL_T, TM_Mp, ( "<==nicAsyncRead, Status, %x ", NdisStatus) );

    nicFreeIrb(pIrb);

    nicFreeIrp(pIrp);
    
    
    
    return NdisStatus;
}



NDIS_STATUS
nicAsyncWrite_Synch(
    PREMOTE_NODE    pRemoteNode,
    IO_ADDRESS      DestinationAddress,     // Address to write to
    ULONG           nNumberOfBytesToWrite,  // Bytes to write
    ULONG           nBlockSize,             // Block size of write
    ULONG           fulFlags,               // Flags pertinent to write
    PMDL            Mdl,                    // Destination buffer
    ULONG           ulGeneration,           // Generation as known by driver
    OUT NTSTATUS   *pNtStatus               // pointer to NTSTatus returned by the IRP  
    )


    
    // Function Description:
    //  This performs an asynchronous write operation in thje remote node's
    //  address space
    //
    // Arguments
    //PREMOTE_NODE  pRemoteNode             // Remote Node which owns the Destination address
    //IO_ADDRESS      DestinationAddress;     // Address to write to
    //ULONG           nNumberOfBytesToWrite;  // Bytes to write
    //ULONG           nBlockSize;             // Block size of write
    //ULONG           fulFlags;               // Flags pertinent to write
    //PMDL            Mdl;                    // Destination buffer
    //ULONG           ulGeneration;           // Generation as known by driver
    //
    // Return Value:
    //  Success - if successful
    //  Invalid Generation
    //
    //
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    

    
    TRACE( TL_T, TM_Mp, ( "==>nicAsyncWrite_Synch, Remote Node, %x ", pRemoteNode ) );


    TRACE( TL_V, TM_Mp, ( "   Destination %x, nNumberOfBytesToWrite %x, nBlockSize %x",
                               DestinationAddress, nNumberOfBytesToWrite, nBlockSize) );


    TRACE( TL_V, TM_Mp, ( "   fulFlags %x, , Mdl %x, Generation %x, pNtStatus %x",   
                               fulFlags , Mdl, ulGeneration, pNtStatus ) );


    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK ( TM_Irp, ( "nicAsyncWrite_Synch, nicGetIrb FAILED" ) );
        }
        
        ASSERT ( pIrb != NULL);

        pIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
        pIrb->Flags = 0;
        pIrb->u.AsyncWrite.DestinationAddress = DestinationAddress; 
        pIrb->u.AsyncWrite.nNumberOfBytesToWrite = nNumberOfBytesToWrite; 
        pIrb->u.AsyncWrite.nBlockSize = nBlockSize;  
        pIrb->u.AsyncWrite.fulFlags = fulFlags;
        pIrb->u.AsyncWrite.Mdl = Mdl;
        pIrb->u.AsyncWrite.ulGeneration = ulGeneration; 
        
        
        NdisStatus = nicGetIrp ( pRemoteNode->pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (  TM_Irp, ( "nicAsyncWrite_Synch, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_Synch ( pRemoteNode,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE ( TL_A, TM_Irp, ( "nicAsyncWrite_Synch, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }

        if (pNtStatus != NULL)
        {
            *pNtStatus = pIrp->IoStatus.Status;
        }
        
    } while (FALSE);


    TRACE( TL_T, TM_Mp, ( "<==nicAsyncWrite_Synch, Success , %x Nt %x", NdisStatus, pIrp->IoStatus.Status) );

    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);
    
    return NdisStatus;
}



    
NDIS_STATUS
nicIsochAllocateResources (
    IN PADAPTERCB       pAdapter,
    IN ULONG            fulSpeed,               // Speed flags
    IN ULONG            fulFlags,               // Flags
    IN ULONG            nChannel,               // Channel to be used
    IN ULONG            nMaxBytesPerFrame,      // Expected size of Isoch frame
    IN ULONG            nNumberOfBuffers,       // Number of buffer(s) that will be attached
    IN ULONG            nMaxBufferSize,         // Max size of buffer(s)
    IN ULONG            nQuadletsToStrip,       // Number striped from start of every packet
    IN ULARGE_INTEGER   uliChannelMask,     // ChannelMask for Multiple channels
    IN OUT PHANDLE      phResource              // handle to Resource
    )
    // Function Description:
    // This function sends an allocate resources irp to the driver. The miniport must do this before it 
    // attempts any channel operation
    // Arguments
    // Taken from documentation for the IsochAllocateResources  
    // fulSpeed - should be the max speed the tx side is expected to stream
    // The payload size in nMaxBytesPerFram cannot exceed the max payload for
    // for this speed.
    // fulFlags - For receive, wtih the standard header stripped, the field should
    // be = (RESOURCE_USED_IN_LISTEN | RESOURCES_STRIP_ADDITIONAL_QUADLETS)
    // Also nQuadletsToStrip = 1
    // For no stripping set nQuadsTostrip to 0 and dont specify the stripping flag.
    // nMaxBytesPerframe - If not stripping it should include the 8 bytes for header/trailer
    // expected to be recieved for each packet.
    // nNumberOfBuffer - see below
    // nMaxBufferSize - This should be always such mode(nMaxBufferSize,nMaxBytesPerFrame) == 0
    // (integer product of number of bytes per packet).
    // nQuadletsTostrip - If stripping only one quadlet (standrd iso header) this is set to 1
    // if zero, the isoch header will be included AND the trailer. So 8 bytes extra will be recieved
    // hResource - see below

    // Return Value:
    // Success if the channel was allocated
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicIsochAllocateResources ") );
    ASSERT (fulSpeed != 0); // 0 is undefined in ISOCH_SP...
    
    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicIsochAllocateResources  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_RESOURCES;
        pIrb->Flags = 0;
        pIrb->u.IsochAllocateResources.fulSpeed = fulSpeed; 
        pIrb->u.IsochAllocateResources.fulFlags = fulFlags;
        pIrb->u.IsochAllocateResources.nChannel = nChannel;
        pIrb->u.IsochAllocateResources.nMaxBytesPerFrame = nMaxBytesPerFrame;
        pIrb->u.IsochAllocateResources.nNumberOfBuffers = nNumberOfBuffers;  
        pIrb->u.IsochAllocateResources.nMaxBufferSize = nMaxBufferSize; 
        pIrb->u.IsochAllocateResources.nQuadletsToStrip = nQuadletsToStrip;
        pIrb->u.IsochAllocateResources.ChannelMask = uliChannelMask;
        
        nicIsochAllocateResourcesDebugSpew(pIrb);

        
        NdisStatus = nicGetIrp ( pAdapter->pNextDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochAllocateResources  , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                 pIrp,
                                                 pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochAllocateResources , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }

        
        TRACE( TL_N, TM_Irp, ( "nicIsochAllocateResources  Succeeded  hResource %x", pIrb->u.IsochAllocateResources.hResource) );

        *phResource = pIrb->u.IsochAllocateResources.hResource;
                
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    TRACE( TL_T, TM_Irp, ( "<==nicIsochAllocateResources  , Status %x, hResource %x", NdisStatus, *phResource ) );

    MATCH_IRQL;

        
    return NdisStatus;
}


VOID
nicIsochAllocateResourcesDebugSpew(
    IN PIRB pIrb)
{
    


    TRACE( TL_V, TM_Irp, ( " Speed %x", pIrb->u.IsochAllocateResources.fulSpeed ) );
    TRACE( TL_V, TM_Irp, ( " flags %x", pIrb->u.IsochAllocateResources.fulFlags  ) );
    TRACE( TL_V, TM_Irp, ( " Channel %x", pIrb->u.IsochAllocateResources.nChannel  ) );
    TRACE( TL_V, TM_Irp, ( " nMaxBytesPerFrame %x", pIrb->u.IsochAllocateResources.nMaxBytesPerFrame  ) );
    TRACE( TL_V, TM_Irp, ( " nNumberOfBuffers %x", pIrb->u.IsochAllocateResources.nNumberOfBuffers  ) );
    TRACE( TL_V, TM_Irp, ( " nMaxBufferSize  %x", pIrb->u.IsochAllocateResources.nMaxBufferSize  ) );
    TRACE( TL_V, TM_Irp, ( " nQuadletsToStrip %x",  pIrb->u.IsochAllocateResources.nQuadletsToStrip  ) );
    TRACE( TL_V, TM_Irp, ( " pIrb->u.IsochAllocateResources.ChannelMask  %I64x",  pIrb->u.IsochAllocateResources.ChannelMask ) );



}





NDIS_STATUS
nicIsochFreeResources(
    IN PADAPTERCB pAdapter,
    IN HANDLE hResource
    )
    // Function Description:
    // Arguments
    //
    // Return Value:
    //
    
{
 
    PIRP    pIrp            = NULL;
    PIRB    pIrb            = NULL;
    PDEVICE_OBJECT  pPdo    = pAdapter->pNextDeviceObject;
    NDIS_STATUS NdisStatus  = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Irp, ( "==>nicIsochFreeResources pAdapter %x, hResource %8x", pAdapter, hResource) );
    
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL); 
    ASSERT (hResource != NULL);

    do
    {
        NdisStatus = nicGetIrb(&pIrb);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrb failed in nicIsochFreeResources" ) );
            break;
        }

        
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrp failed in nicIsochFreeResources" ) );
            break;
        }

        
        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_FREE_RESOURCES;
        pIrb->Flags = 0;
        pIrb->u.IsochFreeResources.hResource = hResource;

        
        NdisStatus = nicSubmitIrp_LocalHostSynch( pAdapter, 
                                               pIrp,
                                               pIrb );

    } while (FALSE);

    //
    // Free the locally allocated memory
    //
    nicFreeIrb(pIrb);

    nicFreeIrp(pIrp);

            
    //
    // We do not care about the status, because we do not know what to do if it fails.
    // However, spew some debug out.
    //

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_N, TM_Irp, ( "nicIsochFreeResources FAILED %x", NdisStatus) );
    
        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
    }


    
    TRACE( TL_T, TM_Irp, ( "<==nicIsochFreeResources Status %x (always success)", NdisStatus) );

    NdisStatus = NDIS_STATUS_SUCCESS;
    return NdisStatus;
}



NDIS_STATUS
nicIsochModifyStreamProperties (
    PADAPTERCB pAdapter,
    NDIS_HANDLE hResource,
    ULARGE_INTEGER ullChannelMap,
    ULONG ulSpeed)
/*++

Routine Description:
 Sets up the Irp and uses the VDO to do an IoCallDriver
 
Arguments:


Return Value:


--*/
{
    PIRP    pIrp            = NULL;
    PIRB    pIrb            = NULL;
    PDEVICE_OBJECT  pPdo    = pAdapter->pNextDeviceObject;
    NDIS_STATUS NdisStatus  = NDIS_STATUS_SUCCESS;
    
    TRACE( TL_T, TM_Irp, ( "==>nicIsochModifyStreamProperties  pAdapter %x, hResource %x, Speed %x, ChannelMap %I64x", 
                          pAdapter, 
                          hResource,
                          ulSpeed,
                          ullChannelMap) );
    
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL); 
    ASSERT (hResource != NULL);

    do
    {
        NdisStatus = nicGetIrb(&pIrb);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrb failed in nicIsochModifyStreamProperties " ) );
            break;
        }

        
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetIrp failed in nicIsochModifyStreamProperties " ) );
            break;
        }

        
        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_MODIFY_STREAM_PROPERTIES  ;
        pIrb->Flags = 0;
        pIrb->u.IsochModifyStreamProperties.hResource = hResource;
        pIrb->u.IsochModifyStreamProperties.ChannelMask = ullChannelMap;
        pIrb->u.IsochModifyStreamProperties.fulSpeed = ulSpeed;

        
        NdisStatus = nicSubmitIrp_LocalHostSynch( pAdapter, 
                                               pIrp,
                                               pIrb );

    } while (FALSE);

    //
    // Free the locally allocated memory
    //
    nicFreeIrb(pIrb);

    nicFreeIrp(pIrp);

            
    //
    // We do not care about the status, because we do not know what to do if it fails.
    // However, spew some debug out.
    //

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_N, TM_Irp, ( "nicIsochModifyStreamProperties  FAILED %x", NdisStatus) );
    
        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
    }


    
    TRACE( TL_T, TM_Irp, ( "<==nicIsochModifyStreamProperties  Status %x (always success)", NdisStatus) );

    return NdisStatus;








}






NDIS_STATUS
nicBusReset (
    IN PADAPTERCB pAdapter,
    IN OUT ULONG fulFlags
    )
    // Function Description:
    //  This function sends an Irp to the Bus driver to reset the bus
    //  Any remote Pdo can be used for the Irp. 
    //  A flag can be set to force the root to be reset
    // Arguments
    //  PdoCb The Pdo for the remote node to which the Irp is submitted
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    PDEVICE_OBJECT pPdo = pAdapter->pNextDeviceObject;
    STORE_CURRENT_IRQL;

        
    
    TRACE( TL_T, TM_Irp, ( "==>nicBusReset , PdoCb, %x Flags %x", pAdapter, fulFlags ) );
    ASSERT (pPdo != NULL);
    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicBusReset  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_BUS_RESET;
        pIrb->Flags = 0;
        pIrb->u.BusReset.fulFlags = fulFlags;

        
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicBusReset, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);

        TRACE( TL_N, TM_Irp, ( "BUS RESET,  Flags%d on pAdapter %x", fulFlags, pAdapter) );
    

        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicBusReset , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }

        NdisInterlockedIncrement (&pAdapter->AdaptStats.ulNumResetsIssued);     
                
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    TRACE( TL_T, TM_Irp, ( "<==nicBusReset %x",  NdisStatus ) );
    MATCH_IRQL;
    
        
    return NdisStatus;
}


NDIS_STATUS
nicBusResetNotification (
    IN PADAPTERCB pAdapter,
    IN ULONG fulFlags,
    IN PBUS_BUS_RESET_NOTIFICATION pResetRoutine,
    IN PVOID pResetContext
    )
    // Function Description:
    //  This function sends an Irp to the Bus driver to register/deregister 
    //  a notification routine. Any remote Pdo can be used for the Irp. 
    //  
    // Arguments
    //  PdoCb The Pdo for the remote node to which the Irp is submitted
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PDEVICE_OBJECT pPdo  = pAdapter->pNextDeviceObject;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicBusResetNotification, pAdapter %x, Flags %x, Routine %x, Context %x", pAdapter, fulFlags, pResetRoutine, pResetContext  ) );

    ASSERT (KeGetCurrentIrql()==PASSIVE_LEVEL);
    
    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicBusResetNotification  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
        pIrb->Flags = 0;
        pIrb->u.BusResetNotification.fulFlags = fulFlags;
        pIrb->u.BusResetNotification.ResetRoutine = pResetRoutine;
        pIrb->u.BusResetNotification.ResetContext= pResetContext;

        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicBusResetNotification , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicBusResetNotification  , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }
    
        TRACE( TL_N, TM_Irp, ( "    nicBusResetNotification success,  Flags %d on pAdapter %x", fulFlags, pAdapter) );
                
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<==nicBusResetNotification %x",  NdisStatus ) );
        
    return NdisStatus;
}


NDIS_STATUS
nicGetMaxSpeedBetweenDevices (
    PADAPTERCB pAdapter,
    UINT   NumOfRemoteNodes,
    PDEVICE_OBJECT pArrayDestinationPDO[MAX_LOCAL_NODES],
    PULONG  pSpeed
    )
    // Function Description:
    //   This function submits an irp to the bus driver
    //   to get the max speed between 2 nodes
    //   Uses REQUEST_GET_SPEED_BETWEEN_DEVICES  
    //
    //
    // Arguments
    //   Remote Node Start of an array of PDOs for remote nodes
    //   NumOfRemoteNodes The number of remote nodes we are interested in
    //   pArrayDestinationPDO = Array of Destination PDO's
    // Return Value:
    //  Success if irp succeeded
    //  pSpeed will point to the Speed
    //
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    ULONG NumRemote = NumOfRemoteNodes;

    
    TRACE( TL_T, TM_Irp, ( "==>nicGetMaxSpeedBetweenDevices pRemoteNodeArray %x", 
                            pArrayDestinationPDO ) );
    TRACE( TL_T, TM_Irp, ( "==>NumOfRemoteNodes %x, pSpeed %x", 
                            NumOfRemoteNodes, pSpeed ) );

    do 
    {

        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGetMaxSpeedBetweenDevices , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        while (NumRemote != 0)
        {
            pIrb->u.GetMaxSpeedBetweenDevices.hDestinationDeviceObjects[NumRemote-1] = pArrayDestinationPDO[NumRemote-1];   
            NumRemote --;
        }

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_GET_SPEED_BETWEEN_DEVICES;
        pIrb->Flags = 0;
        pIrb->u.GetMaxSpeedBetweenDevices.fulFlags = USE_LOCAL_NODE;
        pIrb->u.GetMaxSpeedBetweenDevices.ulNumberOfDestinations = NumOfRemoteNodes;
        

        
        NdisStatus = nicGetIrp ( pAdapter->pNextDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetMaxSpeedBetweenDevices , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                    pIrp,
                                                    pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetMaxSpeedBetweenDevices , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }

        *pSpeed = pIrb->u.GetMaxSpeedBetweenDevices.fulSpeed ;
    

    } while (FALSE);    
    
    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);

    

    TRACE( TL_T, TM_Irp, ( "<==nicGetMaxSpeedBetweenDevices Status %x, Speed %x",
                             NdisStatus, *pSpeed ) );


    
    return NdisStatus;

    
                             


}
    



NDIS_STATUS
nicIsochAttachBuffers (
    IN PADAPTERCB           pAdapter,
    IN HANDLE              hResource,
    IN ULONG               nNumberOfDescriptors,
    PISOCH_DESCRIPTOR       pIsochDescriptor
    )
    // Function Description:
    //  
    // Arguments
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    ASSERT (pIsochDescriptor!=NULL);
    ASSERT (hResource != NULL);
    ASSERT (nNumberOfDescriptors > 0);

    TRACE( TL_T, TM_Irp, ( "==>nicIsochAttachBuffers, pAdapter, %x ", pAdapter) );
    TRACE( TL_N, TM_Irp, ( "hResource  %x, nNumberOfDescriptors %x, pIsochDescriptor %x, ", hResource, nNumberOfDescriptors, pIsochDescriptor ) );



    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicIsochAttachBuffers, nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_ATTACH_BUFFERS;
        pIrb->Flags = 0;
        pIrb->u.IsochAttachBuffers.hResource = hResource ;
        pIrb->u.IsochAttachBuffers.nNumberOfDescriptors = nNumberOfDescriptors;
        pIrb->u.IsochAttachBuffers.pIsochDescriptor = pIsochDescriptor;
        
        NdisStatus = nicGetIrp ( pAdapter->pNextDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochAttachBuffers , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                 pIrp,
                                                 pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochAttachBuffers  , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }
    
        TRACE( TL_N, TM_Irp, ( "nicIsochAttachBuffers success") );
                
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<==nicIsochAttachBuffers %x",  NdisStatus ) );
        
    return NdisStatus;
}

NDIS_STATUS
nicIsochDetachBuffers (
    IN PADAPTERCB           pAdapter,
    IN HANDLE              hResource,
    IN ULONG               nNumberOfDescriptors,
    PISOCH_DESCRIPTOR     pIsochDescriptor
    )
    // Function Description:
    //  
    // Arguments
    //        HANDLE              hResource;            // Resource handle
    //        ULONG               nNumberOfDescriptors; // Number to detach
    //        PISOCH_DESCRIPTOR   pIsochDescriptor;     // Pointer to Isoch descriptors - same as
    //                                                      pointer used in Attach Buffers
    // Return Status :
    //       Success if the Irp succeeded 
    //


{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    PDEVICE_OBJECT pPdo = pAdapter->pNextDeviceObject;
    STORE_CURRENT_IRQL;

    ASSERT (pIsochDescriptor!=NULL);
    ASSERT (hResource != NULL);
    ASSERT (nNumberOfDescriptors > 0);

    TRACE( TL_T, TM_Irp, ( "==>nicIsochDetachBuffers, ") );
    TRACE( TL_V, TM_Irp, ( "hResource  %x, nNumberOfDescriptors %x, pIsochDescriptor %x, ", hResource, nNumberOfDescriptors, pIsochDescriptor ) );



    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicIsochDetachBuffers, nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_DETACH_BUFFERS;
        pIrb->Flags = 0;
        pIrb->u.IsochDetachBuffers.hResource = hResource ;
        pIrb->u.IsochDetachBuffers.nNumberOfDescriptors = nNumberOfDescriptors;
        pIrb->u.IsochDetachBuffers.pIsochDescriptor = pIsochDescriptor;
        
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochDetachBuffers , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                               pIrp,
                                               pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochDetachBuffers  , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }
    
        TRACE( TL_V, TM_Irp, ( "nicIsochDetachBuffers success,  ") );
                
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<==nicIsochDetachBuffers %x",  NdisStatus ) );
        
    return NdisStatus;
}



NDIS_STATUS
nicIsochListen (
    IN PADAPTERCB pAdapter,
    HANDLE        hResource,
    ULONG         fulFlags,
    CYCLE_TIME    StartTime
    )
    // Function Description:
    //  Activates the bus driver to listen to data on that channel
    // Arguments
    //  RemoteNode - Remote Node
    //  hResource - Handle to resource with ISochDescriptors
    //  Flags - not used yet
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    ASSERT (hResource != NULL);

    TRACE( TL_T, TM_Irp, ( "==>nicIsochListen, pAdapter %x, hResource  %x ", pAdapter,hResource) );

    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicIsochListen, nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_LISTEN;
        pIrb->Flags = 0;
        pIrb->u.IsochListen.hResource = hResource ;
        pIrb->u.IsochListen.fulFlags = fulFlags;
        pIrb->u.IsochListen.StartTime = StartTime;
        
        NdisStatus = nicGetIrp ( pAdapter->pNextDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochListen , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                 pIrp,
                                                 pIrb );
                                                 
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochListen  , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }
    
        TRACE( TL_N, TM_Irp, ( "nicIsochListen success,  pAdapter %x", pAdapter) );
                
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<==nicIsochListen %x",  NdisStatus ) );
        
    return NdisStatus;





}






NDIS_STATUS
nicIsochStop (
    IN PADAPTERCB pAdapter,
    IN HANDLE  hResource
    )
    // Function Description:
    //   Issues an IsochStop Irp to the Device
    //  Should stop Isoch IO on that resource
    // Arguments
    //  PdoCb The Pdo for the remote node to which the Irp is submitted
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    PDEVICE_OBJECT pPdo = pAdapter->pNextDeviceObject;
    STORE_CURRENT_IRQL;


    TRACE( TL_T, TM_Irp, ( "==>nicIsochStop , pPdo, %x hResource %x", pPdo, hResource) );

    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicIsochStop  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        pIrb->FunctionNumber = REQUEST_ISOCH_STOP;
        pIrb->Flags = 0;
        pIrb->u.IsochStop.hResource = hResource;
        pIrb->u.IsochStop.fulFlags = 0;
        
        NdisStatus = nicGetIrp (pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochStop , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                pIrp,
                                                pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicIsochStop , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;
        }

        
            
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<== nicIsochStop , Status ", NdisStatus) );
        
    return NdisStatus;
}




NDIS_STATUS
nicGetLocalHostCSRTopologyMap(
    IN PADAPTERCB pAdapter,
    IN PULONG pLength,
    IN PVOID pBuffer
    )
    // Function Description:
    //  Retrieves the local hosts CSR.  
    // Arguments
    //  pBuffer - LocalHostBuffer
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    GET_LOCAL_HOST_INFO6    LocalHostInfo6;
    STORE_CURRENT_IRQL;

    ASSERT (pLength != NULL);
    ASSERT (pBuffer != NULL);
    
    TRACE( TL_T, TM_Irp, ( "==>nicGetLocalHostCSRTopologyMap , pAdapter %x ,Length %x, Buffer", 
                           pAdapter, *pLength, pBuffer) );

    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostCSRTopologyMap  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        LocalHostInfo6.CsrBaseAddress.Off_High  = INITIAL_REGISTER_SPACE_HI;
        LocalHostInfo6.CsrBaseAddress.Off_Low  = TOPOLOGY_MAP_LOCATION;
        LocalHostInfo6.CsrDataLength = *pLength;
        LocalHostInfo6.CsrDataBuffer = pBuffer;
        
        
        pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
        pIrb->Flags = 0;
        pIrb->u.GetLocalHostInformation.nLevel = GET_HOST_CSR_CONTENTS;
        pIrb->u.GetLocalHostInformation.Information = &LocalHostInfo6;

        
        NdisStatus = nicGetIrp ( pAdapter->pNextDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostCSRTopologyMap , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostCSRTopologyMap , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );

            TRACE( TL_A, TM_Irp, ( "Length Needed %.x", LocalHostInfo6.CsrDataLength) );

            if (pIrp->IoStatus.Status == STATUS_INVALID_BUFFER_SIZE)
            {
                *pLength = LocalHostInfo6.CsrDataLength; 
            }
            break;
        }

            
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<== nicGetLocalHostCSRTopologyMap , Status %x", NdisStatus) );
        
    return NdisStatus;
}






NDIS_STATUS
nicGetLocalHostConfigRom(
    IN PADAPTERCB pAdapter,
    OUT  PVOID *ppCRom
    )
    // Function Description:
    //  Retrieves the local hosts CSR.  
    // Arguments
    //  pBuffer - Locally allocated. Caller has to free
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    GET_LOCAL_HOST_INFO5 Info;
    PVOID pCRom;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicGetLocalHostConfigRom, pAdapter %x ", 
                           pAdapter) );

    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostConfigRom , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        Info.ConfigRom = NULL;
        Info.ConfigRomLength = 0;
        
        pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO ;
        pIrb->Flags = 0;
        pIrb->u.GetLocalHostInformation.nLevel = GET_HOST_CONFIG_ROM;
        pIrb->u.GetLocalHostInformation.Information = &Info;
        
        NdisStatus = nicGetIrp ( pAdapter->pNextDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostConfigRom , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);

        //
        // First find the length
        // 

        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (Info.ConfigRomLength == 0)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
        
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostConfigRom, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;

        }

        nicFreeIrp (pIrp);
        pIrp = NULL;

        pCRom = ALLOC_NONPAGED (Info.ConfigRomLength, 'C31N');

        if (pCRom == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        Info.ConfigRom = pCRom;

        NdisStatus = nicGetIrp ( pAdapter->pNextDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostConfigRom, nicGetIrp FAILED" ) );
            break;
        }
        
        
        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                               pIrp,
                                               pIrb );

        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostConfigRom, nicGetIrp FAILED" ) );
            break;
        }

        *ppCRom = pCRom;

            
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<== nicGetLocalHostCSRTopologyMap , Status %x", NdisStatus) );
        
    return NdisStatus;
}






NDIS_STATUS
nicGetConfigRom(
    IN PDEVICE_OBJECT pPdo,
    OUT PVOID *ppCrom
    )
    // Function Description:
    //  Retrieves the Config Rom from the Device Object.
    // Caller responsibility to free this memory.  
    // Arguments
    //  pBuffer - LocalHostBuffer
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    ULONG SizeNeeded= 0;
    PVOID pConfigInfoBuffer;

    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicGetConfigRom, pPdo %x ",pPdo ) );

    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostCSRTopologyMap  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        
        
        pIrb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
            
        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetConfigRom, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_PDOSynch ( pPdo,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetConfigRom, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );

            break;
        }


        nicFreeIrp (pIrp);

        //
        // Clear the Irp so that it will not be double freed if we fail
        //
        pIrp = NULL;
        
        SizeNeeded = sizeof(CONFIG_ROM) +pIrb->u.GetConfigurationInformation.UnitDirectoryBufferSize +
                                pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize + 
                                pIrb->u.GetConfigurationInformation.VendorLeafBufferSize +
                                pIrb->u.GetConfigurationInformation.ModelLeafBufferSize;

        TRACE( TL_A, TM_Irp, ( "nicGetConfigRom , SixeNeeded %x", SizeNeeded) );

        pConfigInfoBuffer = ALLOC_NONPAGED (SizeNeeded , 'C13N');

        if (pConfigInfoBuffer  == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
    
        }

        pIrb->u.GetConfigurationInformation.ConfigRom = (PCONFIG_ROM)pConfigInfoBuffer;
        pIrb->u.GetConfigurationInformation.UnitDirectory = (PVOID)((PUCHAR)pConfigInfoBuffer + sizeof(CONFIG_ROM));
        pIrb->u.GetConfigurationInformation.UnitDependentDirectory = (PVOID)((PUCHAR)pIrb->u.GetConfigurationInformation.UnitDirectory + 
                                                                            pIrb->u.GetConfigurationInformation.UnitDirectoryBufferSize);
        pIrb->u.GetConfigurationInformation.VendorLeaf = (PVOID)((PUCHAR)pIrb->u.GetConfigurationInformation.UnitDependentDirectory + 
                                                                                  pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize);
        pIrb->u.GetConfigurationInformation.ModelLeaf = (PVOID)((PUCHAR)pIrb->u.GetConfigurationInformation.VendorLeaf + 
                                                                                  pIrb->u.GetConfigurationInformation.VendorLeafBufferSize);        
        pIrb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;

        NdisStatus = nicGetIrp ( pPdo, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetConfigRom, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_PDOSynch ( pPdo,
                                        pIrp,
                                        pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetConfigRom, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );

            break;
        }
        TRACE( TL_A, TM_Irp, ( "nicGetConfigRom, pConfigRom %x, Size %x", pConfigInfoBuffer  , SizeNeeded ) );
        

        *ppCrom = pConfigInfoBuffer;
        
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<== nicGetLocalHostCSRTopologyMap , Status %x", NdisStatus) );
        
    return NdisStatus;
}





NDIS_STATUS
nicGetReadWriteCapLocalHost(
    IN PADAPTERCB pAdapter,
    PGET_LOCAL_HOST_INFO2 pReadWriteCaps
    )
/*++

Routine Description:
  Gets the ReadWrite Capabilities for the local host

Arguments:
    ReadWriteCaps - To be filled up byt the bus driver

Return Value:


--*/

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicGetReadWriteCapLocalHost, pAdapter %x pReadWriteCaps %x", 
                           pAdapter, pReadWriteCaps) );

    do 
    {
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGetReadWriteCapLocalHost , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        NdisZeroMemory (pReadWriteCaps, sizeof(*pReadWriteCaps));
 
        
        pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
        pIrb->Flags = 0;
        pIrb->u.GetLocalHostInformation.nLevel = GET_HOST_CAPABILITIES;
        pIrb->u.GetLocalHostInformation.Information = pReadWriteCaps;

        
        NdisStatus = nicGetIrp ( pAdapter->pNextDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetReadWriteCapLocalHost, nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetReadWriteCapLocalHost, nicSubmitIrp_Synch FAILED %x", NdisStatus ) );

            break;
        }

            
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);

    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<== nicGetReadWriteCapLocalHost, Status %x", NdisStatus) );
        
    return NdisStatus;
}



NDIS_STATUS
nicSetLocalHostPropertiesCRom (
    IN PADAPTERCB pAdapter,
    IN PUCHAR pConfigRom,
    IN ULONG Length,
    IN ULONG Flags,
    IN OUT PHANDLE phCromData,
    IN OUT PMDL *ppConfigRomMdl
    )


    // Function Description:
    //   Allocates an MDL pointing to the Buffer 
    //   and sends it to the bus driver
    //
    // Arguments
    //   pAdapter - Local host
    //   ConfigRom - Buffer to be sent to the bus driver
    //   Length - Length of the Config Rom Buffer
    //   Flags - Add or remove
    //   phConfigRom - if Remove then this is an input parameter
    // Return Value: 
    //   Handle  - Is successful
    //

{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    PMDL pMdl = NULL;
    SET_LOCAL_HOST_PROPS3 SetLocalHost3;

    TRACE( TL_T, TM_Irp, ( "==>nicSetLocalHostPropertiesCRom , pAdapter %x, pConfigRom %x",pAdapter, pConfigRom) );

    if (Flags == SLHP_FLAG_ADD_CROM_DATA)
    {
        TRACE( TL_T, TM_Irp, ( "    ADD") );

    }
    else
    {
        TRACE( TL_T, TM_Irp, ( "    REMOVE Handle %x", *pConfigRom) );
    
    }


    do
    {   
        //
        // Get an mdl describing the config rom
        //

        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicSetLocalHostPropertiesCRom , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);
        
        //
        // Initialize the set local host struct
        //

        if (Flags == SLHP_FLAG_ADD_CROM_DATA)
        {
            NdisStatus = nicGetMdl ( Length, pConfigRom, &pMdl);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Irp, ( "nicSetLocalHostPropertiesCRom , nicGetIrb FAILED" ) );
                break;
            }


            SetLocalHost3.fulFlags = SLHP_FLAG_ADD_CROM_DATA;          
            SetLocalHost3.hCromData = NULL;
            SetLocalHost3.nLength = Length;
            SetLocalHost3.Mdl = pMdl;
        }
        else
        {
            SetLocalHost3.fulFlags = SLHP_FLAG_REMOVE_CROM_DATA  ;
            ASSERT (phCromData != NULL);
            SetLocalHost3.hCromData  = *phCromData;
        }

        pIrb->FunctionNumber = REQUEST_SET_LOCAL_HOST_PROPERTIES;
        pIrb->Flags = 0;
        pIrb->u.GetLocalHostInformation.nLevel = SET_LOCAL_HOST_PROPERTIES_MODIFY_CROM;
        pIrb->u.GetLocalHostInformation.Information = &SetLocalHost3;


        //
        // Get an Irp
        //

        NdisStatus = nicGetIrp ( pAdapter->pNextDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicSetLocalHostPropertiesCRom , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicSetLocalHostPropertiesCRom , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );
            break;


        }

        if (Flags == SLHP_FLAG_ADD_CROM_DATA)
        {
            *phCromData = SetLocalHost3.hCromData;
            *ppConfigRomMdl = pMdl;

        }
        else
        {
            //
            // Free the Mdl that contains the CROM
            //
            ASSERT (*ppConfigRomMdl);
            nicFreeMdl (*ppConfigRomMdl);
        }
    } while (FALSE);


    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    TRACE( TL_T, TM_Irp, ( "<==nicSetLocalHostPropertiesCRom  pAdapter %x", pAdapter ) );


    return NdisStatus;

}


NDIS_STATUS
nicGetLocalHostUniqueId(
    IN PADAPTERCB pAdapter,
    IN OUT PGET_LOCAL_HOST_INFO1 pUid
    )
    // Function Description:
    //  Retrieves the local hosts UniqueId.  
    // Arguments
    //  pBuffer - LocalHostBuffer
    //  
    // Return Value:
    // Success if the Irp Succeeded
    // Failure otherwise
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PIRB pIrb = NULL;
    PIRP pIrp = NULL;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicGetLocalHostUniqueId , pAdapter%x ,pUid", 
                           pAdapter, pUid) );

    do 
    {
        ASSERT (pAdapter->pNextDeviceObject != NULL);
        
        NdisStatus = nicGetIrb (&pIrb);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
    
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostUniqueId  , nicGetIrb FAILED" ) );
            break;
        }
        
        ASSERT ( pIrb != NULL);

        //
        //Initialize the datastructures in the Irb
        //
        
        
        pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
        pIrb->Flags = 0;
        pIrb->u.GetLocalHostInformation.nLevel = GET_HOST_UNIQUE_ID;
        pIrb->u.GetLocalHostInformation.Information = (PVOID) pUid;

        
        NdisStatus = nicGetIrp ( pAdapter->pNextDeviceObject, &pIrp);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostCSRTopologyMap , nicGetIrp FAILED" ) );
            break;
        }
        
        ASSERT (pIrp != NULL);


        NdisStatus = nicSubmitIrp_LocalHostSynch ( pAdapter,
                                                   pIrp,
                                                   pIrb );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Irp, ( "nicGetLocalHostUniqueId , nicSubmitIrp_Synch FAILED %x", NdisStatus ) );

            break;
        }

            
    } while (FALSE);

    //
    // Now free all the locally allocated resources. They can point to NULL, in which case the called 
    // functions return immediately
    //
    nicFreeIrb (pIrb);

    nicFreeIrp (pIrp);


    MATCH_IRQL;
    TRACE( TL_T, TM_Irp, ( "<== nicGetLocalHostUniqueId , Status %x", NdisStatus) );
        
    return NdisStatus;
}



//---------------------------------------------------------
// The routines to submit Irp's to the bus, synchronously or 
// asynchronously begin here 
//---------------------------------------------------------


NTSTATUS 
nicSubmitIrp(
   IN PDEVICE_OBJECT    pPdo,
   IN PIRP              pIrp,
   IN PIRB              pIrb,
   IN PIO_COMPLETION_ROUTINE  pCompletion,
   IN PVOID             pContext
   )
   
    //
    // This is the generic function used by all Irp Send Handlers 
    // to do an IoCallDriver. It sets up the next location in the 
    // stack prior to calling the Irp   
    // Make sure the Irp knows about the Irb by setting it up as an argument
    //
{

    NTSTATUS NtStatus ;
    PIO_STACK_LOCATION  NextIrpStack;
    
    TRACE( TL_T, TM_Irp, ( "==>nicSubmitIrp, pPdo %x, Irp %x, Irb %x, ", 
                            pPdo, pIrp ,pIrb, pCompletion ) );

    TRACE( TL_T, TM_Irp, ( "     pCompletion %x, pContext %x", 
                            pCompletion, pContext ) );


    ASSERT (pPdo != NULL);

    IoSetCompletionRoutine (pIrp,
                            pCompletion,
                            pContext,
                            TRUE,
                            TRUE,
                            TRUE);
    

    //
    //  Insert the Irp as as the argument in the NextStack location for the IRP
    //


    if (pIrb) 
    {
        NextIrpStack = IoGetNextIrpStackLocation (pIrp);
        NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        NextIrpStack->DeviceObject = pPdo;
        NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
        NextIrpStack->Parameters.Others.Argument1 = pIrb;
    }
    else 
    {
        IoCopyCurrentIrpStackLocationToNext(pIrp);
    }


    //
    //  Reference the PDO and Submit the Irp 
    //  If Ref fails, it means the PDO has been deactivated on another thread
    //
    NtStatus = IoCallDriver (pPdo, pIrp);


    
    

    TRACE( TL_T, TM_Irp, ( "<==nicSubmitIrp, PDO %x, NtStatus %x",
                              pPdo, NtStatus ) );
    
    //
    //  Since we did a IoCallDriver, we have a guarantee that the completion
    //  routine will be called.  Exit gracefully
    //
    
    return NtStatus;

}


NDIS_STATUS
nicSubmitIrp_Synch(
    IN REMOTE_NODE      *pRemoteNode,
    IN PIRP           pIrp,
    IN PIRB           pIrb 
    )

    // Callers need to make sure that no context is set for the Irp
    // as it will be a synchronous call for them
    //

    // We refcount the Pdo block so that the pdo block  will not disappear 
    // during the duration of the IoCallDriver
   
{
    NDIS_EVENT  NdisSynchEvent;
    NTSTATUS NtStatus; 
    NDIS_STATUS NdisStatus;
    BOOLEAN bSuccessful = FALSE;
    BOOLEAN bIsPdoValid = FALSE;
    
    TRACE( TL_T, TM_Irp, ( "==>nicSubmitIrp_Synch, PDO %x", pRemoteNode->pPdo ) );


    ASSERT (pRemoteNode != NULL);
    ASSERT (pRemoteNode->pPdo != NULL);
    
    ASSERT (pIrp != NULL);
    ASSERT (pIrb != NULL)


    do
    {
        //
        // Check to see if Pdo is Valid. We do not care here if the Pdo is being 
        // removed because Vcs may want to submit Irps as part of their cleanup
        // process
        //
        REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);

        if (  REMOTE_NODE_TEST_FLAG (pRemoteNode, PDO_Activated ) 
             && (nicReferenceRemoteNode (pRemoteNode, SubmitIrp_Synch) == TRUE) )
        {
            bIsPdoValid = TRUE;
        }

        REMOTE_NODE_RELEASE_LOCK (pRemoteNode);

        if ( bIsPdoValid == FALSE)
        {
            NtStatus = STATUS_NO_SUCH_DEVICE;
        
            TRACE( TL_A, TM_Irp, ( "==>PDO is NOT Valid, nicSubmitIrp_Synch, PdoCb %x, Pdo %x", pRemoteNode, pRemoteNode->pPdo ) );

            break;  
        }


        //
        // Add a reference to the PDO block so it cannot be removed
        // This reference is decremented at the end of this function
        //
        NdisInitializeEvent (&NdisSynchEvent);

            
        NtStatus = nicSubmitIrp (  pRemoteNode->pPdo,
                                  pIrp,
                                  pIrb,
                                  nicSubmitIrp_SynchComplete,
                                  (PVOID)&NdisSynchEvent); 


    

    } while (FALSE);

    if (NT_SUCCESS (NtStatus) ==TRUE)  // Could also pend
    {
        //
        // Now we need to wait for the event  to complete
        // and return a good status if we do not hit the timeout
        //
        ASSERT (KeGetCurrentIrql()==PASSIVE_LEVEL);
        
        bSuccessful = NdisWaitEvent (&NdisSynchEvent,WAIT_INFINITE);

        if (bSuccessful == TRUE)
        {
            //
            // We waited successfully. Now lets see how the Irp fared.
            //
            TRACE( TL_V, TM_Irp, ("    Irp Completed Status %x", pIrp->IoStatus.Status) );
            
            NdisStatus = NtStatusToNdisStatus (pIrp->IoStatus.Status);
        }
        else
        {
            NdisStatus = NDIS_STATUS_FAILURE;
        }

    }
    else
    {   //
        // The call to submit Irp failed synvhronously. Presently, the only cause is an 

        NdisStatus = NtStatusToNdisStatus (NtStatus);       

    }

    if (bIsPdoValid  == TRUE)
    {   
        //
        // If this variable is set, it means we have referenced the PDO 
        //
        nicDereferenceRemoteNode (pRemoteNode, SubmitIrp_Synch);
    }
    
    TRACE( TL_T, TM_Irp, ( "<==nicSubmitIrp_Synch, bSuccessful %.2x, Status %x", bSuccessful, NdisStatus) );

    return NdisStatus;

}


NTSTATUS
nicSubmitIrp_SynchComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID           Context   
    )
    // This is the completion routine for functions nicSubmitIrp_synch.
    // It sets the event (int the context) and exits
    //

{
    PNDIS_EVENT pNdisSynchEvent = (PNDIS_EVENT) Context;
    
    TRACE( TL_T, TM_Irp, ( "==>nicSubmitIrp_SynchComplete, PDO %x, pIrp %x, status %x",DeviceObject,pIrp, pIrp->IoStatus.Status  ) );

    NdisSetEvent (pNdisSynchEvent);

    return (STATUS_MORE_PROCESSING_REQUIRED);

}
    


NDIS_STATUS
nicSubmitIrp_LocalHostSynch(
    IN PADAPTERCB       pAdapter,
    IN PIRP             pIrp,
    IN PIRB             pIrb 
    )

    // Callers need to make sure that no context is set for the Irp
    // as it will be a synchronous call for them
    //
    // No Checking 
    //
   
{
    NDIS_EVENT  NdisSynchEvent;
    NTSTATUS NtStatus; 
    NDIS_STATUS NdisStatus;
    BOOLEAN bSuccessful = FALSE;
    BOOLEAN bIsPdoValid = FALSE;
    
    TRACE( TL_T, TM_Irp, ( "==>nicSubmitIrp_LocalHostSynch, PDO %x", pAdapter->pNextDeviceObject ) );
    TRACE( TL_V, TM_Irp, ( "Current Irql , %.2x", KeGetCurrentIrql()) );


    
    ASSERT (pIrp != NULL);
    ASSERT (pIrb != NULL)

    
    do
    {
        //
        // Check to see if Pdo is Valid. 
        //

        //
        // Add a reference to the PDO block so it cannot be removed
        // This reference is decremented at the end of this function
        //
        // This reference is decrement below

        
        if (ADAPTER_ACTIVE(pAdapter))
        {
            nicReferenceAdapter(pAdapter, "nicSubmitIrp_LocalHostSynch");
            TRACE( TL_V, TM_Irp, ( "Adapter Active pAdapter %x,  ulflags %x", pAdapter , pAdapter->ulFlags) );

            bIsPdoValid = TRUE;
        }
        else
        {
            TRACE( TL_V, TM_Irp, ( "Adapter INActive pAdapter %x,  ulflags %x", pAdapter , pAdapter->ulFlags) );
            bIsPdoValid = FALSE;

        }

        
        if ( bIsPdoValid == FALSE)
        {
            NtStatus = STATUS_NO_SUCH_DEVICE;
        
            TRACE( TL_A, TM_Irp, ( "==>PDO is NOT Valid, nicSubmitIrp_LocalHostSynch, pAdapter %x, Pdo %x", pAdapter , pAdapter->pNextDeviceObject) );

            break;  
        }


        NdisInitializeEvent (&NdisSynchEvent);

            
        NtStatus = nicSubmitIrp ( pAdapter->pNextDeviceObject,
                                  pIrp,
                                  pIrb,
                                  nicSubmitIrp_SynchComplete,
                                  (PVOID)&NdisSynchEvent); 


    

    } while (FALSE);

    if (NT_SUCCESS (NtStatus) ==TRUE)  // Could also pend
    {
        //
        // Now we need to wait for the event  to complete
        // and return a good status if we do not hit the timeout
        //

        bSuccessful = NdisWaitEvent (&NdisSynchEvent,WAIT_INFINITE);

        if (bSuccessful == TRUE)
        {
            //
            // We waited successfully. Now lets see how the Irp fared.
            //
            TRACE( TL_V, TM_Irp, ("    Irp Completed Status %x", pIrp->IoStatus.Status) );
            
            NdisStatus = NtStatusToNdisStatus (pIrp->IoStatus.Status);
        }
        else
        {
            NdisStatus = NDIS_STATUS_FAILURE;
        }

    }
    else
    {
        //
        // IoCallDriver failed synchronously
        //
        NdisStatus = NtStatusToNdisStatus (NtStatus);       
    }

    if (bIsPdoValid  == TRUE)
    {
         nicDereferenceAdapter(pAdapter, "nicSubmitIrp_LocalHostSynch");
    }
    TRACE( TL_T, TM_Irp, ( "<==nicSubmitIrp_LocalHostSynch, bSuccessful %.2x, Status %x", bSuccessful, NdisStatus) );

    return NdisStatus;

}


NDIS_STATUS
nicSubmitIrp_PDOSynch(
    IN PDEVICE_OBJECT pPdo,
    IN PIRP             pIrp,
    IN PIRB             pIrb 
    )

    // Callers need to make sure that no context is set for the Irp
    // as it will be a synchronous call for them
    //
    // No Checking 
    //
   
{
    NDIS_EVENT  NdisSynchEvent;
    NTSTATUS NtStatus; 
    NDIS_STATUS NdisStatus;
    BOOLEAN bSuccessful = FALSE;
    STORE_CURRENT_IRQL;

    
    TRACE( TL_T, TM_Irp, ( "==>nicSubmitIrp_PDOSynch, PDO %x", pPdo) );
    TRACE( TL_V, TM_Irp, ( "Current Irql , %.2x", KeGetCurrentIrql()) );


    
    ASSERT (pIrp != NULL);
    ASSERT (pIrb != NULL)

    //
    // No Checks to see if Pdo is Valid. 
    //


    //
    // Send the Irp to the bus driver
    //
    NdisInitializeEvent (&NdisSynchEvent);

    NtStatus = nicSubmitIrp ( pPdo,
                              pIrp,
                              pIrb,
                              nicSubmitIrp_SynchComplete,
                              (PVOID)&NdisSynchEvent); 





    if (NT_SUCCESS (NtStatus) ==TRUE)  // Could also pend
    {
        //
        // Now we need to wait for the event  to complete
        // and return a good status if we do not hit the timeout
        //
        ASSERT (KeGetCurrentIrql()==PASSIVE_LEVEL);

        bSuccessful = NdisWaitEvent (&NdisSynchEvent,WAIT_INFINITE);

        if (bSuccessful == TRUE)
        {
            //
            // We waited successfully. Now lets see how the Irp fared.
            //
            TRACE( TL_V, TM_Irp, ("    Irp Completed Status %x", pIrp->IoStatus.Status) );
            
            NdisStatus = NtStatusToNdisStatus (pIrp->IoStatus.Status);
        }
        else
        {
            NdisStatus = NDIS_STATUS_FAILURE;
        }

    }
    else
    {
        //
        // IoCallDriver failed synchronously
        //
        NdisStatus = NtStatusToNdisStatus (NtStatus);       
    }

    TRACE( TL_T, TM_Irp, ( "<==nicSubmitIrp_PDOSynch, bSuccessful %.2x, Status %x", bSuccessful, NdisStatus) );
    MATCH_IRQL;
    return NdisStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\md5.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// md5.h
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port routines
//
// 08/08/2000 ADube created.  
// 
// Purpose: Create a unique MAC address from 1394 EUID 
//
// Derived from derived from the RSA Data  Security, 
// Inc. MD5 Message-Digest Algorithm 
//

/*
  been defined with C compiler flags.
 */
#ifndef PROTOTYPES
#define PROTOTYPES 1
#endif

/* POINTER defines a generic pointer type */
typedef unsigned char *POINTER;

/* UINT2 defines a two byte word */
typedef unsigned short int UINT2;

/* UINT4 defines a four byte word */
typedef unsigned long int UINT4;

/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.
If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
  returns an empty list.
 */
#if PROTOTYPES
#define PROTO_LIST(list) list
#else
#define PROTO_LIST(list) ()
#endif


/* MD5 context. */

typedef struct _MD5_CTX{
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
} MD5_CTX, MD_CTX;



void MD5Init PROTO_LIST ((MD5_CTX *));
void MD5Update PROTO_LIST
  ((MD5_CTX *, unsigned char *, unsigned int));
void MD5Final PROTO_LIST ((unsigned char [16], MD5_CTX *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\irp.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// irp.h
//
// IEEE1394 mini-port/call-manager driver
//
// Delaration for Routines that issue the Irps to the 1394 Bus driver 
//
// 06/20/1999 ADube Created
//


//----------------------------------------------------------------------------
//      1 3 9 4 B U S   I N T E R F A C E   F U N C T I O N S
//----------------------------------------------------------------------------



NDIS_STATUS
nicAllocateAddressRange_Synch (
    IN PADAPTERCB pAdapter,
    IN PMDL pMdl,
    IN ULONG fulFlags,
    IN ULONG nLength,
    IN ULONG MaxSegmentSize,
    IN ULONG fulAccessType,
    IN ULONG fulNotificationOptions,
    IN PVOID Callback,
    IN PVOID Context,
    IN ADDRESS_OFFSET  Required1394Offset,
    IN PSLIST_HEADER   FifoSListHead,
    IN PKSPIN_LOCK     FifoSpinLock,
    OUT PULONG pAddressesReturned,  
    OUT PADDRESS_RANGE  p1394AddressRange,
    OUT PHANDLE phAddressRange
    );



NDIS_STATUS
nicAsyncRead_Synch(
    PREMOTE_NODE    pRemoteNode,
    IO_ADDRESS      DestinationAddress,     
    ULONG         nNumberOfBytesToRead,
    ULONG         nBlockSize,
    ULONG         fulFlags,
    PMDL          Mdl,
    ULONG         ulGeneration,
    OUT NTSTATUS *pNtStatus
    );




NDIS_STATUS
nicAsyncWrite_Synch(
    PREMOTE_NODE    pRemoteNode,
    IO_ADDRESS      DestinationAddress,     // Address to write to
    ULONG           nNumberOfBytesToWrite,  // Bytes to write
    ULONG           nBlockSize,             // Block size of write
    ULONG           fulFlags,               // Flags pertinent to write
    PMDL            Mdl,                    // Destination buffer
    ULONG           ulGeneration,           // Generation as known by driver
    OUT NTSTATUS   *pNtStatus               // pointer to NTSTatus returned by the IRP  
    );


NDIS_STATUS
nicFreeAddressRange(
    IN PADAPTERCB pAdapter,
    IN ULONG nAddressesToFree,
    IN PADDRESS_RANGE p1394AddressRange,
    IN PHANDLE phAddressRange
    );

    

NDIS_STATUS
nicBusReset (
    IN PADAPTERCB pAdapter,
    IN OUT ULONG fulFlags
    );


NDIS_STATUS
nicBusResetNotification (
    IN PADAPTERCB pAdapter,
    IN ULONG fulFlags,
    IN PBUS_BUS_RESET_NOTIFICATION pResetRoutine,
    IN PVOID pResetContext
    );



NDIS_STATUS
nicFreeChannel(
    IN PADAPTERCB pAdapter,
    IN ULONG nChannel
    );


NDIS_STATUS
nicGet1394AddressFromDeviceObject( 
    IN PDEVICE_OBJECT pPdo,
    IN OUT NODE_ADDRESS *pNodeAddress,
    IN ULONG fulFlags
    );


NDIS_STATUS
nicGet1394AddressOfRemoteNode( 
    IN PREMOTE_NODE pRemoteNode,
    IN OUT NODE_ADDRESS *pNodeAddress,
    IN ULONG fulFlags
    );


NDIS_STATUS
nicGetGenerationCount(
    IN PADAPTERCB       pAdapter,
    IN OUT PULONG    GenerationCount
    );


NDIS_STATUS
nicIsochAllocateBandwidth(
    IN PREMOTE_NODE pRemoteNodePdoCb,
    IN ULONG MaxBytesPerFrameRequested, 
    IN ULONG SpeedRequested,
    OUT PHANDLE phBandwidth,
    OUT PULONG  pBytesPerFrameAvailable,
    OUT PULONG  pSpeedSelected
    );

    
NDIS_STATUS
nicAllocateChannel (
    IN PADAPTERCB pAdapter,
    IN ULONG pChannel,
    OUT PULARGE_INTEGER pChannelsAvailable OPTIONAL
    );
    

NDIS_STATUS
nicQueryChannelMap (
    IN PADAPTERCB pAdapter,
    OUT PULARGE_INTEGER pChannelsAvailable 
    );


NDIS_STATUS
nicIsochAllocateResources (
    IN PADAPTERCB       pAdapter,
    IN ULONG            fulSpeed,              
    IN ULONG            fulFlags,               
    IN ULONG            nChannel,              
    IN ULONG            nMaxBytesPerFrame,      
    IN ULONG            nNumberOfBuffers,
    IN ULONG            nMaxBufferSize,         
    IN ULONG            nQuadletsToStrip,        
    IN ULARGE_INTEGER   uliChannelMask,     
    IN OUT PHANDLE      hResource              
    );

 
NDIS_STATUS
nicIsochAttachBuffers (
    IN PADAPTERCB           pAdapter,
    HANDLE                  hResource,
    ULONG                   nNumberOfDescriptors,
    PISOCH_DESCRIPTOR       pIsochDescriptor
    );


NDIS_STATUS
nicIsochFreeResources(
    IN PADAPTERCB pAdapter,
    IN HANDLE hResource
    );



NDIS_STATUS
nicIsochFreeBandwidth(
    IN REMOTE_NODE *pRemoteNode,
    IN HANDLE hBandwidth
    );



NDIS_STATUS
nicIsochListen (
    IN PADAPTERCB pAdapter,
    HANDLE        hResource,
    ULONG         fulFlags,
    CYCLE_TIME    StartTime
    );

    

NDIS_STATUS
nicGetMaxSpeedBetweenDevices (
    PADAPTERCB pAdapter,
    UINT   NumOfRemoteNodes,
    PDEVICE_OBJECT pArrayDestinationPDO[64],
    PULONG pSpeed
    );
    

NDIS_STATUS
nicIsochDetachBuffers (
    IN PADAPTERCB           pAdapter,
    IN HANDLE               hResource,
    IN ULONG                nNumberOfDescriptors,
    PISOCH_DESCRIPTOR    pIsochDescriptor
    );




NDIS_STATUS
nicIsochStop (
    IN PADAPTERCB pAdapter,
    IN HANDLE  hResource
    );


NDIS_STATUS
nicIsochModifyStreamProperties (
    PADAPTERCB pAdapter,
    NDIS_HANDLE hResource,
    ULARGE_INTEGER ullChannelMap,
    ULONG ulSpeed);

    
NDIS_STATUS
nicGetLocalHostCSRTopologyMap(
    IN PADAPTERCB pAdapter,
    IN PULONG pLength,
    IN PVOID pBuffer
    );


NDIS_STATUS
nicAsyncLock(
    PREMOTE_NODE    pRemoteNode,
    IO_ADDRESS      DestinationAddress,     // Address to lock to
    ULONG           nNumberOfArgBytes,      // Bytes in Arguments
    ULONG           nNumberOfDataBytes,     // Bytes in DataValues
    ULONG           fulTransactionType,     // Lock transaction type
    ULONG           Arguments[2],           // Arguments used in Lock
    ULONG           DataValues[2],          // Data values
    PVOID           pBuffer,                // Destination buffer (virtual address)
    ULONG           ulGeneration           // Generation as known by driver
    );



NDIS_STATUS
nicSetLocalHostPropertiesCRom (
    IN PADAPTERCB pAdapter,
    IN PUCHAR pConfigRom,
    IN ULONG Length,
    IN ULONG Flags,
    IN OUT PHANDLE phCromData,
    IN OUT PMDL *ppConfigRomMdl
    );

NDIS_STATUS
nicGetLocalHostUniqueId(
    IN PADAPTERCB pAdapter,
    IN OUT PGET_LOCAL_HOST_INFO1 pUid
    );
    

NDIS_STATUS
nicGetConfigRom(
    IN PDEVICE_OBJECT pPdo,
    OUT PVOID *ppCrom
    );



NDIS_STATUS
nicGetLocalHostConfigRom(
    IN PADAPTERCB pAdapter,
    OUT  PVOID *ppCRom
    );


NDIS_STATUS
nicGetReadWriteCapLocalHost(
    IN PADAPTERCB pAdapter,
    PGET_LOCAL_HOST_INFO2 pReadWriteCaps
    );
    
NTSTATUS 
nicSubmitIrp(
   IN PDEVICE_OBJECT    pPDO,
   IN PIRP              pIrp,
   IN PIRB              pIrb,
   IN PIO_COMPLETION_ROUTINE  pCompletion,
   IN PVOID             pContext
   );


NDIS_STATUS
nicSubmitIrp_Synch(
    IN REMOTE_NODE      *pRemoteNode,
    IN PIRP           pIrp,
    IN PIRB           pIrb 
    );

NTSTATUS
nicSubmitIrp_SynchComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID           Context   
    );

    
NDIS_STATUS
nicSubmitIrp_LocalHostSynch(
    IN PADAPTERCB       pAdapter,
    IN PIRP             pIrp,
    IN PIRB             pIrb 
    );
    

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
nicFreeAddressRangeDebugSpew(
    IN PIRB pIrb 
    );

VOID
nicIsochAllocateResourcesDebugSpew(
    IN PIRB pIrb
    );

NTSTATUS
nicSubmitIrp_DummyComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID           Context   
    );



NDIS_STATUS
nicSubmitIrp_PDOSynch(
    IN PDEVICE_OBJECT pPdo,
    IN PIRP             pIrp,
    IN PIRB             pIrb 
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\md5.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// md5.c
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port routines
//
// 08/08/2000 ADube created.  
// 
// Purpose: Create a unique MAC address from 1394 EUID 
//
// Derived from derived from the RSA Data  Security, 
// Inc. MD5 Message-Digest Algorithm 
//

#include <precomp.h>
#pragma hdrstop

#include "md5.h"

// Constants for MD5Transform routine.

#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void MD5Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));
static void Encode PROTO_LIST
  ((unsigned char *, UINT4 *, unsigned int));
static void Decode PROTO_LIST
  ((UINT4 *, unsigned char *, unsigned int));
static void MD5_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));
static void MD5_memset PROTO_LIST ((POINTER, int, unsigned int));

static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// F, G, H and I are basic MD5 functions.
 
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

// ROTATE_LEFT rotates x left n bits.
 
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

// FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
// Rotation is separate from addition to prevent recomputation.
 
#define FF(a, b, c, d, x, s, ac) { \
 (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) { \
 (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) { \
 (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) { \
 (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }

// MD5 initialization. Begins an MD5 operation, writing a new context.
 
void 
MD5Init (
    MD5_CTX *context// context 
    )
{
  context->count[0] = context->count[1] = 0;
  // Load magic initialization constants.

  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}

// MD5 block update operation. Continues an MD5 message-digest
//  operation, processing another message block, and updating the
//  context.
 
void 
MD5Update (
    MD5_CTX *context,   // context 
    unsigned char *input,   // input block 
    unsigned int inputLen   // length of input block 
    )
{
    unsigned int i, index, partLen;

    // Compute number of bytes mod 64 
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);

    // Update number of bits 
    if ((context->count[0] += ((UINT4)inputLen << 3))
        < ((UINT4)inputLen << 3))
    {        
        context->count[1]++;
    }
    
    context->count[1] += ((UINT4)inputLen >> 29);

    partLen = 64 - index;

    // Transform as many times as possible.

    if (inputLen >= partLen) 
    {
        MD5_memcpy   ((POINTER)&context->buffer[index], 
                        (POINTER)input, 
                        partLen);

        MD5Transform (context->state, context->buffer);

        for (i = partLen; i + 63 < inputLen; i += 64)
        {
            MD5Transform (context->state, &input[i]);
        }

        index = 0;
    }
    else
    {
        i = 0;
    }
    // Buffer remaining input 
    MD5_memcpy
    ((POINTER)&context->buffer[index], (POINTER)&input[i],
    inputLen-i);
}

// MD5 finalization. Ends an MD5 message-digest operation, writing the
// the message digest and zeroizing the context.
 
void 
MD5Final (
    unsigned char digest[16],                         // message digest 
    MD5_CTX *context
    )                                       // context 
{
  unsigned char bits[8];
  unsigned int index, padLen;

  // Save number of bits 
  Encode (bits, context->count, 8);

  // Pad out to 56 mod 64.

  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);

  // Append length (before padding) 
  MD5Update (context, bits, 8);

  // Store state in digest 
  Encode (digest, context->state, 6);

  // Zeroize sensitive information.

  MD5_memset ((POINTER)context, 0, sizeof (*context));
}

// MD5 basic transformation. Transforms state based on block.
 
static 
void 
MD5Transform (
    UINT4 state[4],
    unsigned char block[64]
    )
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];

  Decode (x, block, 64);

  // Round 1 
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); // 1 
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); // 2 
  FF (c, d, a, b, x[ 2], S13, 0x242070db); // 3 
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); // 4 
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); // 5 
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); // 6 
  FF (c, d, a, b, x[ 6], S13, 0xa8304613); // 7 
  FF (b, c, d, a, x[ 7], S14, 0xfd469501); // 8 
  FF (a, b, c, d, x[ 8], S11, 0x698098d8); // 9 
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); // 10 
  FF (c, d, a, b, x[10], S13, 0xffff5bb1); // 11 
  FF (b, c, d, a, x[11], S14, 0x895cd7be); // 12 
  FF (a, b, c, d, x[12], S11, 0x6b901122); // 13 
  FF (d, a, b, c, x[13], S12, 0xfd987193); // 14 
  FF (c, d, a, b, x[14], S13, 0xa679438e); // 15 
  FF (b, c, d, a, x[15], S14, 0x49b40821); // 16 

 // Round 2 
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); // 17 
  GG (d, a, b, c, x[ 6], S22, 0xc040b340); // 18 
  GG (c, d, a, b, x[11], S23, 0x265e5a51); // 19 
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); // 20 
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); // 21 
  GG (d, a, b, c, x[10], S22,  0x2441453); // 22 
  GG (c, d, a, b, x[15], S23, 0xd8a1e681); // 23 
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); // 24 
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); // 25 
  GG (d, a, b, c, x[14], S22, 0xc33707d6); // 26 
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); // 27 
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); // 28 
  GG (a, b, c, d, x[13], S21, 0xa9e3e905); // 29 
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); // 30 
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); // 31 
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); // 32 

  // Round 3 
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); // 33 
  HH (d, a, b, c, x[ 8], S32, 0x8771f681); // 34 
  HH (c, d, a, b, x[11], S33, 0x6d9d6122); // 35 
  HH (b, c, d, a, x[14], S34, 0xfde5380c); // 36 
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); // 37 
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); // 38 
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); // 39 
  HH (b, c, d, a, x[10], S34, 0xbebfbc70); // 40 
  HH (a, b, c, d, x[13], S31, 0x289b7ec6); // 41 
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); // 42 
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); // 43 
  HH (b, c, d, a, x[ 6], S34,  0x4881d05); // 44 
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); // 45 
  HH (d, a, b, c, x[12], S32, 0xe6db99e5); // 46 
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); // 47 
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); // 48 

  // Round 4 
  II (a, b, c, d, x[ 0], S41, 0xf4292244); // 49 
  II (d, a, b, c, x[ 7], S42, 0x432aff97); // 50 
  II (c, d, a, b, x[14], S43, 0xab9423a7); // 51 
  II (b, c, d, a, x[ 5], S44, 0xfc93a039); // 52 
  II (a, b, c, d, x[12], S41, 0x655b59c3); // 53 
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); // 54 
  II (c, d, a, b, x[10], S43, 0xffeff47d); // 55 
  II (b, c, d, a, x[ 1], S44, 0x85845dd1); // 56 
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); // 57 
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); // 58 
  II (c, d, a, b, x[ 6], S43, 0xa3014314); // 59 
  II (b, c, d, a, x[13], S44, 0x4e0811a1); // 60 
  II (a, b, c, d, x[ 4], S41, 0xf7537e82); // 61 
  II (d, a, b, c, x[11], S42, 0xbd3af235); // 62 
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); // 63 
  II (b, c, d, a, x[ 9], S44, 0xeb86d391); // 64 

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;

  // Zeroize sensitive information.

  MD5_memset ((POINTER)x, 0, sizeof (x));
}

// Encodes input (UINT4) into output (unsigned char). Assumes len is
// a multiple of 4.
 
static 
void 
Encode (
    unsigned char *output,
    UINT4 *input,
    unsigned int len
    )
{
    unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4) 
    {
        output[j] = (unsigned char)(input[i] & 0xff);
        output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
        output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
        output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
    }
}

// Decodes input (unsigned char) into output (UINT4). Assumes len is
// a multiple of 4.
 
static 
void 
Decode (
    UINT4 *output,
    unsigned char *input,
    unsigned int len
    )
{
  unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4)
    {
    output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
                (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
    }
}

// Note: Replace "for loop" with standard memcpy if possible.
 

static 
void 
MD5_memcpy (
    POINTER output,
    POINTER input,
    unsigned int len
    )
{
    unsigned int i;

    for (i = 0; i < len; i++)
    { 
        output[i] = input[i];
    }
}

// Note: Replace "for loop" with standard memset if possible.
 
static 
void 
MD5_memset (
    POINTER output,
    int value,
    unsigned int len
    )
{
    unsigned int i;

    for (i = 0; i < len; i++)
    {   
        ((char *)output)[i] = (char)value;
    }
}


#define ETH_IS_MULTICAST(Address) \
        (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x01))


VOID
nicGetMacAddressFromEuid (
    UINT64 *pEuid,
    MAC_ADDRESS *pMacAddr
    )
{

   MD_CTX context;
    unsigned char digest[6];
    unsigned int len = 8;

    MD5Init (&context);
    MD5Update (&context, (unsigned char*)pEuid, len);
    MD5Final (digest, &context);

    NdisMoveMemory (pMacAddr, digest, 6);

    // Set the locally administered bit 
    // and clear the multicast bit.

    //
    // randomize the returned Mac Address
    // by xor ing the address with a random 
    // 0xf22f617c91e0 (a random number)
    //
    //pMacAddr->addr[0] ^= 0x00;

    pMacAddr->addr[0] |= 0x2;
    pMacAddr->addr[0] &= 0xf2;
    pMacAddr->addr[1] ^= 0x2f;
    pMacAddr->addr[2] ^= 0x61;
    pMacAddr->addr[3] ^= 0x7c;
    pMacAddr->addr[4] ^= 0x91;
    pMacAddr->addr[5] ^= 0x30;

    
}


        
// Digests a string and prints the result.
 
VOID
nicGetFakeMacAddress(
    UINT64 *pEuid, 
    MAC_ADDRESS *pMacAddr
    )
{

	nicGetMacAddressFromEuid (pEuid, pMacAddr);
    



    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\pktlog.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// pktlog.c
//
// IEEE1394 mini-port/call-manager driver
//
// Packet logging utilities.
//
// 10/12/1999 JosephJ Created
//
    
#include <precomp.h>






VOID
nic1394InitPktLog(
    PNIC1394_PKTLOG pPktLog
    )
/*++

Routine Description:

    Initializes a packet log.

Arguments:

    pPktLog     - Pkt log to to be initialized.

--*/
{
    if (pPktLog == NULL)
        return;
    NdisZeroMemory(pPktLog, sizeof(*pPktLog));
    pPktLog->InitialTimestamp = KeQueryPerformanceCounter(
                                        &pPktLog->PerformanceFrequency);
    pPktLog->EntrySize = sizeof(pPktLog->Entries[0]);
    pPktLog->NumEntries = N1394_NUM_PKTLOG_ENTRIES;

}


VOID
Nic1394LogPkt (
    PNIC1394_PKTLOG pPktLog,
    ULONG           Flags,
    ULONG           SourceID,
    ULONG           DestID,
    PVOID           pvData,
    ULONG           cbData
)
/*++

Routine Description:

    Adds a pkt log entry to the specified circular pkt log.
    The entry gets added at location
     (NdisInterlockedIncrement(&pPktLog->SequenceNo) % N1394_NUM_PKTLOG_ENTRIES)

    May be called at any IRQL. Does not use explicit locking -- relies on
    the serialization produced by NdisInterlockedIncrement.

Arguments:

    pPktLog     - Pkt log to log packet
    Flags       - User-defined flags
    SourceID    - User-defined source ID
    DestID      - User-defined destination ID
    pvData      - Data from packet  // can be null
    cbData      - size of this data (at most N1394_PKTLOG_DATA_SIZE bytes are logged)


--*/
{
    ULONG                       SequenceNo;
    PN1394_PKTLOG_ENTRY         pEntry;

    SequenceNo      = NdisInterlockedIncrement(&pPktLog->SequenceNo);
    pEntry          = &pPktLog->Entries[SequenceNo % N1394_NUM_PKTLOG_ENTRIES];

    pEntry->SequenceNo          = SequenceNo;
    pEntry->Flags               = Flags;
    pEntry->TimeStamp           = KeQueryPerformanceCounter(NULL);
    pEntry->SourceID            = SourceID;
    pEntry->DestID              = DestID;
    pEntry->OriginalDataSize    = cbData;

    if (cbData > sizeof(pEntry->Data))
    {
        cbData = sizeof(pEntry->Data);
    }

    if (pvData != NULL && cbData != 0)
    {
        NdisMoveMemory(pEntry->Data, pvData, cbData);
    }
}



VOID
nic1394AllocPktLog(
    IN ADAPTERCB* pAdapter
    )
/*++

Routine Description:

    Initialize the packet log
    
Arguments:
    
Return Value:

--*/
{
    ASSERT (pAdapter->pPktLog==NULL);
    pAdapter->pPktLog =  ALLOC_NONPAGED(sizeof(*pAdapter->pPktLog), MTAG_PKTLOG);
    if (pAdapter->pPktLog == NULL)
    {
        TRACE( TL_A, TM_Misc, ( "  Could not allocate packet log for Adapter %x",
                    pAdapter ) );
    }
}

VOID
nic1394DeallocPktLog(
    IN ADAPTERCB* pAdapter
    )
/*++

Routine Description:

        Free the packet log
        
Arguments:
    
Return Value:

--*/
{
    
    if (pAdapter->pPktLog != NULL)
    {
        FREE_NONPAGED(pAdapter->pPktLog);
        pAdapter->pPktLog = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\mp.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// mp.h
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port routines - header file
//
// 06/20/99 ADube - Created - Declaration for miniport routines
//

//-------------------------------------------------------------------
//          G L O B A L    D E C L A R A T I O N S
//-------------------------------------------------------------------

#ifdef PSDEBUG

// List of all allocated PAYLOADSENT contexts and the lock that protects the
// list.  (for debug purposes only)
//
NDIS_SPIN_LOCK g_lockDebugPs;
LIST_ENTRY g_listDebugPs;

#endif


#define DEFAULT_TOPOLOGY_MAP_LENGTH 0x400


#define FIVE_SECONDS_IN_MILLSECONDS 2000  /*Incorrect value during debugging */




//
// Used to generate a MAC address amd for informational use
//
extern ULONG AdapterNum ;
extern BOOLEAN g_AdapterFreed;

// Call statistics totals for all calls since loading, calls and the lock
// protecting access to them.  For this global only, the 'ullCallUp' field is
// the number of calls recorded, rather than a time.
//
CALLSTATS g_stats;
NDIS_SPIN_LOCK g_lockStats;



// Global driver list lock
//
NDIS_SPIN_LOCK g_DriverLock;

// Global adapter list, serialized by g_DriverLock;
//
LIST_ENTRY g_AdapterList;


//-----------------------------------------------------------------------------
//          N D I S     M I N I P O R T     H A N D L E R S 
//-----------------------------------------------------------------------------


NDIS_STATUS
NicMpInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext
    );

VOID
NicMpHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
NicMpReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext
    );

VOID
NicMpReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet
    );

NDIS_STATUS
NicMpQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    );

NDIS_STATUS
NicMpSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    );

NDIS_STATUS
NicMpCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    );

NDIS_STATUS
NicMpCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext
    );


VOID
NicMpCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets
    );

NDIS_STATUS
NicMpCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest
    );


BOOLEAN
CheckForHang(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );



//-----------------------------------------------------------------------------
// prototypes for miniport.c (alphabetically)
//-----------------------------------------------------------------------------

NDIS_STATUS
nicAllocateAddressRangeOnNewPdo (
    IN PADAPTERCB pAdapter,
    IN PREMOTE_NODE     pRemoteNode 
    );


VOID
nicResetNotificationCallback (                
    IN PVOID pContext               
    );

VOID
nicBusResetWorkItem(
    NDIS_WORK_ITEM* pResetWorkItem,     
    IN PVOID Context 
    );

VOID
nicFreeAdapter(
    IN ADAPTERCB* pAdapter 
    );


NDIS_STATUS
nicFreeRemoteNode(
    IN REMOTE_NODE *pRemoteNode 
    );


NDIS_STATUS
nicGetRegistrySettings(
    IN NDIS_HANDLE WrapperConfigurationContext,
    IN ADAPTERCB * pAdapter
    );



NDIS_STATUS
nicQueryInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN OUT PNDIS_REQUEST NdisRequest 
    );


NDIS_STATUS
nicSetInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN OUT PNDIS_REQUEST NdisRequest
    );


VOID
nicIssueBusReset (
    PADAPTERCB pAdapter,
    ULONG Flags
    );


VOID 
nicResetReallocateChannels (
    IN PADAPTERCB pAdapter
    );  

VOID
nicResetRestartBCM (
    IN PADAPTERCB pAdapter
    );

VOID
nicReallocateChannels (
    IN PNDIS_WORK_ITEM pWorkItem,   
    IN PVOID Context 
    );



VOID
nicUpdateLocalHostSpeed (
    IN PADAPTERCB pAdapter
    );


VOID 
nicInitializeAllEvents (
    IN PADAPTERCB pAdapter
    );




VOID
nicAddRemoteNodeChannelVc (
    IN PADAPTERCB pAdapter, 
    IN PREMOTE_NODE pRemoteNode
    );


VOID
nicNoRemoteNodesLeft (
    IN PADAPTERCB pAdapter
    );
    
VOID
nicDeleteLookasideList (
    IN OUT PNIC_NPAGED_LOOKASIDE_LIST pLookasideList
    );



VOID
nicInitializeAdapterLookasideLists (
    IN PADAPTERCB pAdapter
    );



VOID
nicInitializeLookasideList(
    IN OUT PNIC_NPAGED_LOOKASIDE_LIST pLookasideList,
    ULONG Size,
    ULONG Tag,
    USHORT Depth
    );

VOID
nicDeleteAdapterLookasideLists (
    IN PADAPTERCB pAdapter
    );


VOID
nicFillRemoteNodeTable (
    IN PADAPTERCB pAdapter
    );  



VOID
ReassemblyTimerFunction (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );



extern const PUCHAR pnic1394DriverDescription;
extern const USHORT nic1394DriverGeneration; 
extern const unsigned char Net1394ConfigRom[48];

NDIS_STATUS 
nicAddIP1394ToConfigRom (
    IN PADAPTERCB pAdapter
    );

VOID
nicUpdateRemoteNodeTable (
    IN PADAPTERCB pAdapter
    );

NTSTATUS
nicUpdateRemoteNodeCompletion (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext 
    );

NDIS_STATUS
nicMCmRegisterAddressFamily (
    IN PADAPTERCB pAdapter
    );

VOID
nicFreeReassembliesOnRemoteNode (
    IN PREMOTE_NODE pRemoteNode, 
    IN PLIST_ENTRY pReassemblyList
    );

VOID
nicFreeReassembliesOnRemoteNode (
    IN PREMOTE_NODE pRemoteNode,
    PLIST_ENTRY pToBeFreedList
    );
    
UCHAR
nicGetMaxRecFromBytes(
    IN ULONG ByteSize
    );

UCHAR
nicGetMaxRecFromSpeed(
    IN ULONG Scode
    );

PREMOTE_NODE
nicGetRemoteNodeFromTable (
    ULONG NodeNumber,
    PADAPTERCB pAdapter
    );




//
//  ConnectionLess Handlers
//
NDIS_STATUS 
NicEthQueryInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
);





NDIS_STATUS
NicEthSetInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    NDIS_OID            Oid,
    PVOID               InformationBuffer,
    ULONG               InformationBufferLength,
    PULONG              BytesRead,
    PULONG              BytesNeeded
    );



VOID
NicMpSendPackets(
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN PPNDIS_PACKET            PacketArray,
    IN UINT                     NumberOfPackets
    );



NDIS_STATUS
nicFillNicInfo (
    IN PADAPTERCB pAdapter, 
    PNIC1394_NICINFO pInNicInfo,
    PNIC1394_NICINFO pOutNicInfo
    );


NDIS_STATUS
nicFillBusInfo(
    IN      PADAPTERCB pAdapter, 
    IN  OUT PNIC1394_BUSINFO pBi
    );


NDIS_STATUS
nicFillChannelInfo(
    IN      PADAPTERCB pAdapter, 
    IN OUT  PNIC1394_CHANNELINFO pCi
    );
    

NDIS_STATUS
nicFillRemoteNodeInfo(
    IN      PADAPTERCB pAdapter, 
    IN OUT  PNIC1394_REMOTENODEINFO pRni
    );



VOID
nicCopyPacketStats (
    NIC1394_PACKET_STATS* pStats,
    UINT    TotNdisPackets,     // Total number of NDIS packets sent/indicated
    UINT    NdisPacketsFailures,// Number of NDIS packets failed/discarded
    UINT    TotBusPackets,      // Total number of BUS-level reads/writes
    UINT    BusPacketFailures   // Number of BUS-level failures(sends)/discards(recv)
    );

VOID
nicAddPacketStats(
    NIC1394_PACKET_STATS* pStats,
    UINT    TotNdisPackets,     // Total number of NDIS packets sent/indicated
    UINT    NdisPacketsFailures,// Number of NDIS packets failed/discarded
    UINT    TotBusPackets,      // Total number of BUS-level reads/writes
    UINT    BusPacketFailures   // Number of BUS-level failures(sends)/discards(recv)
    );


NDIS_STATUS
nicResetStats (
    IN      PADAPTERCB pAdapter, 
    PNIC1394_RESETSTATS     pResetStats 
    );

VOID
nicInformProtocolsOfReset(
    IN PADAPTERCB pAdapter
    );


VOID
nicUpdateSpeedInAllVCs (
    PADAPTERCB pAdapter,
    ULONG Speed
    );

VOID
nicUpdateRemoteNodeCaps(
    PADAPTERCB          pAdapter
);

VOID
nicQueryInformationWorkItem(
    IN PNDIS_WORK_ITEM pWorkItem,   
    IN PVOID Context 
);


VOID
nicIndicateStatusTimer(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );

VOID
nicMIndicateStatus(
    IN  PADAPTERCB              pAdapter ,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );


NDIS_STATUS
nicInitSerializedStatusStruct(
    PADAPTERCB pAdapter
    );


VOID
nicDeInitSerializedStatusStruct(
    PADAPTERCB pAdapter
    );


NDIS_STATUS
nicEthLoadArpModule (
    IN PADAPTERCB pAdapter, 
    IN ULONG StartArp,
    IN PNDIS_REQUEST pRequest
    );

    

VOID
nicGetAdapterName (
    IN PADAPTERCB pAdapter,
    IN WCHAR *pAdapterName, 
    IN ULONG  BufferSize,
    IN PULONG  SizeReturned 
    );


NDIS_STATUS
nicQueueRequestToArp(
    PADAPTERCB pAdapter, 
    ARP_ACTION Action,
    PNDIS_REQUEST pRequest
    );


NTSTATUS 
nicSubmitIrp(
   IN PDEVICE_OBJECT    pPdo,
   IN PIRP              pIrp,
   IN PIRB              pIrb,
   IN PIO_COMPLETION_ROUTINE  pCompletion,
   IN PVOID             pContext
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\pktlog.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// pktlog.c
//
// IEEE1394 mini-port/call-manager driver
//
// Packet logging utilities.
//
// 10/12/1999 JosephJ Created
//
    

#define N1394_PKTLOG_DATA_SIZE 64       // Amount of data logged per packet.

#define N1394_NUM_PKTLOG_ENTRIES 1000   // Size of log (circular buffer)


//----------------------------------------------------------------------
// P A C K E T     L O G G I N G
//----------------------------------------------------------------------

// One (fixed-size)  log entry.
//
typedef struct
{
    ULONG Flags;                            // User-defined flags
    ULONG SequenceNo;                       // Sequence number of this entry

    LARGE_INTEGER TimeStamp;                // Timestamp (KeQueryPerformanceCounter)

    ULONG SourceID;
    ULONG DestID;

    ULONG OriginalDataSize;
    ULONG Reserved;

    UCHAR Data[N1394_PKTLOG_DATA_SIZE];

} N1394_PKTLOG_ENTRY, *PN1394_PKTLOG_ENTRY;

typedef struct
{
    LARGE_INTEGER           InitialTimestamp;       // In 100-nanoseconds.
    LARGE_INTEGER           PerformanceFrequency;   // In Hz.
    ULONG                   SequenceNo;             // Current sequence number
    ULONG                   EntrySize;              // sizeof(N1394_PKTLOG_ENTRY)
    ULONG                   NumEntries;             // N1394_NUM_PKTLOG_ENTRIES
    N1394_PKTLOG_ENTRY      Entries[N1394_NUM_PKTLOG_ENTRIES];
    
} NIC1394_PKTLOG, *PNIC1394_PKTLOG;


    

VOID
nic1394InitPktLog(
    PNIC1394_PKTLOG pPktLog
    );

VOID
Nic1394LogPkt (
    PNIC1394_PKTLOG pPktLog,
    ULONG           Flags,
    ULONG           SourceID,
    ULONG           DestID,
    PVOID           pvData,
    ULONG           cbData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\mp.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// mp.c
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port routines
//
// 12/28/1998 JosephJ Created, 
//

#include <precomp.h>
#include "mp.h"
#pragma hdrstop



//-----------------------------------------------------------------------------
// Data used in processing requests
//-----------------------------------------------------------------------------

NDIS_OID SupportedOids[] = 
{
    OID_GEN_CO_SUPPORTED_LIST,
    OID_GEN_CO_HARDWARE_STATUS,
    OID_GEN_CO_MEDIA_SUPPORTED,
    OID_GEN_CO_MEDIA_IN_USE,
    OID_GEN_CO_LINK_SPEED,
    OID_GEN_CO_VENDOR_ID,
    OID_GEN_CO_VENDOR_DESCRIPTION,
    OID_GEN_CO_DRIVER_VERSION,
    OID_GEN_CO_PROTOCOL_OPTIONS,
    OID_GEN_CO_MEDIA_CONNECT_STATUS,
    OID_GEN_CO_MAC_OPTIONS,
    OID_GEN_CO_VENDOR_DRIVER_VERSION,
    OID_GEN_CO_MINIMUM_LINK_SPEED,
    OID_GEN_CO_XMIT_PDUS_OK, 
    OID_GEN_CO_RCV_PDUS_OK,
    OID_GEN_CO_XMIT_PDUS_ERROR,
    OID_GEN_CO_RCV_PDUS_ERROR,
    OID_GEN_CO_RCV_PDUS_NO_BUFFER,
    OID_1394_LOCAL_NODE_INFO,
    OID_1394_VC_INFO,
    OID_1394_NICINFO,
    OID_1394_IP1394_CONNECT_STATUS,
    OID_1394_ENTER_BRIDGE_MODE,
    OID_1394_EXIT_BRIDGE_MODE,
    OID_1394_ISSUE_BUS_RESET,
    OID_802_3_CURRENT_ADDRESS,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_PHYSICAL_MEDIUM,

    OID_PNP_QUERY_POWER,
    OID_PNP_SET_POWER,
    OID_1394_QUERY_EUID_NODE_MAP
};


//-----------------------------------------------------------------------------
// Locally used function prototypes
//-----------------------------------------------------------------------------
NDIS_STATUS
nicAllocateLoopbackPacketPool (
    IN PADAPTERCB pAdapter
    );

VOID
nicFreeLoopbackPacketPool (
    IN PADAPTERCB pAdapter
    );

VOID
nicLoopbackPacket(
    IN VCCB* pVc,
    IN PNDIS_PACKET pPacket
    );

VOID
nicQueryEuidNodeMacMap (
    IN PADAPTERCB pAdapter,
    IN PNDIS_REQUEST pRequest
    );

VOID
nicRemoveRemoteNodeFromNodeTable(
    IN PNODE_TABLE pNodeTable,
    IN PREMOTE_NODE pRemoteNode
    );

NDIS_STATUS
nicSetPower (
    IN PADAPTERCB pAdapter,
    IN NET_DEVICE_POWER_STATE DeviceState
    );



//-----------------------------------------------------------------------------
// Mini-port handlers
//-----------------------------------------------------------------------------

NDIS_STATUS
NicMpInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext 
    )
/*++

Routine Description:

     Standard 'MiniportInitialize' routine called by NDIS to initialize a
     new adapter.  See DDK doc.  The driver will receive no requests
     until this initialization has completed.
    


Arguments:

    See DDK docs
    
Return Value:
    Appropriate Status

--*/
{
    NDIS_STATUS         NdisStatus;
    NTSTATUS            NtStatus;
    PADAPTERCB          pAdapter= NULL;
    PDEVICE_OBJECT      pNextDeviceObject = NULL;
    LARGE_INTEGER       LocalHostUniqueId;   
    REMOTE_NODE         *p1394RemoteNodePdoCb = NULL;
    UINT64              u64LocalHostUniqueId =0;
    BOOLEAN             FreeAdapter = FALSE;
    BOOLEAN             DequeueAdapter = FALSE;
    ULONG               Generation;
    ULONG               InitStatus;
    //
    // This is the order with which the initialize routine is done. 
    //
    enum    
    {
        NoState,
        AllocatedAdapter,
        AdapterQueued,
        InitializedEvents,
        InitializedBcr,
        RegisteredResetCallback,
        AddedConfigRom,
        RegisteredEnumerator,
        InitializedLookasideList,
        InitializedPktLog,
        InitializedRcvThread,
        InitializedSendThread,
        InitializedReassembly,
        InitializedLoopbackPool

    }; 

    STORE_CURRENT_IRQL

    TIMESTAMP_ENTRY("==>IntializeHandler");
    TIMESTAMP_INITIALIZE();

    TRACE( TL_T, TM_Init, ( "==>NicMpInitialize" ) );

    InitStatus = NoState;
    NdisStatus = *OpenErrorStatus = NDIS_STATUS_SUCCESS;

    // Find the medium index in the array of media, looking for the only one
    // we support, 'NdisMedium1394'.
    //
    {
        UINT i;

        for (i = 0; i < MediumArraySize; ++i)
        {
            if (MediumArray[ i ] == g_ulMedium )
            {
                break;
            }
        }

        if (i >= MediumArraySize)
        {
            TRACE( TL_A, TM_Init, ( "medium?" ) );
            return NDIS_STATUS_FAILURE;
        }

        *SelectedMediumIndex = i;
    }

    // Allocate and zero a control block for the new adapter.
    //
    pAdapter = ALLOC_NONPAGED( sizeof(ADAPTERCB), MTAG_ADAPTERCB );
    TRACE( TL_N, TM_Init, ( "Acb=$%p", pAdapter ) );
    if (!pAdapter)
    {
        return NDIS_STATUS_RESOURCES;
    }

    
    FreeAdapter = TRUE;
    InitStatus = AllocatedAdapter;

    NdisZeroMemory (pAdapter, sizeof(*pAdapter) );

    // Add a reference that will eventually be removed by an NDIS call to
    // the nicFreeAdapter handler.
    //
    nicReferenceAdapter (pAdapter, "MpInitialize" );

    // Set a marker for easier memory dump browsing and future assertions.
    //
    pAdapter->ulTag = MTAG_ADAPTERCB;

    // Save the NDIS handle associated with this adapter for use in future
    // NdisXxx calls.
    //
    pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;

    // Initialize the adapter-wide lock.
    //
    NdisAllocateSpinLock( &pAdapter->lock );

    // Initialize the various lists of top-level resources.
    //
    pAdapter->HardwareStatus = NdisHardwareStatusInitializing;

    //
    // The enumerator and bus1394 have asked us to load, therefore media 
    // should be connected
    //
    pAdapter->MediaConnectStatus = NdisMediaStateDisconnected;
    
    InitializeListHead( &pAdapter->AFList );
    InitializeListHead( &pAdapter->PDOList );


    //
    // Default initialization values
    //
    pAdapter->Speed = SPEED_FLAGS_400;
    pAdapter->SpeedMbps = 4 * 1000000;
    pAdapter->SCode = SCODE_400_RATE;


    do
    {
        // Read this adapter's registry settings.
        //
        NdisStatus = nicGetRegistrySettings(
                        WrapperConfigurationContext,
                        pAdapter
                        );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }


 
        // Inform NDIS of the attributes of our adapter.  Set the
        // 'MiniportAdapterContext' returned to us by NDIS when it calls our
        // handlers to the address of our adapter control block.  Turn off
        // hardware oriented timeouts.
        //
        NdisMSetAttributesEx(
            MiniportAdapterHandle,
            (NDIS_HANDLE)pAdapter,
            (UINT)0,
            NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT | NDIS_ATTRIBUTE_IGNORE_TOKEN_RING_ERRORS |
                NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND | NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT | 
                NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK,
            NdisInterfaceInternal );

        NdisStatus  = nicMCmRegisterAddressFamily (pAdapter);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // If we fail, Let the next entrant try the same thing
            //
            break;
        }
        
        ADAPTER_SET_FLAG (pAdapter,fADAPTER_RegisteredAF); 

        //
        // Insert into global list of adapters. So we will be ready to receive notifications
        // from the enumerator
        //
        NdisAcquireSpinLock ( &g_DriverLock);

        InsertHeadList (&g_AdapterList, &pAdapter->linkAdapter);
        
        DequeueAdapter = TRUE;
        InitStatus = AdapterQueued;

        NdisReleaseSpinLock (&g_DriverLock);

        pAdapter->HardwareStatus = NdisHardwareStatusReady;
        
        //
        // Set up linkages. Get the PDO for the device from Ndis
        //
        NdisMGetDeviceProperty( MiniportAdapterHandle, 
                               NULL,
                               NULL, 
                               &pNextDeviceObject, 
                               NULL,
                               NULL );

        ASSERT (pNextDeviceObject != NULL);

        pAdapter->Generation  = 0;

        //
        // Update data structure with the local hosts VDO
        //

        pAdapter->pNextDeviceObject = pNextDeviceObject;        

        TRACE( TL_I, TM_Mp, ( "  LocalHost VDO %x", pNextDeviceObject) );

        nicInitializeAllEvents (pAdapter);

        InitStatus = InitializedEvents;
        
        //
        //  Initialize the BCM so it is ready to handle Resets
        //
        NdisStatus = nicInitializeBroadcastChannelRegister (pAdapter); 

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK( TM_Init, ( "nicMpInitialize - nicInitializeBroadcastChannelRegister  ") );
        }

        InitStatus = InitializedBcr;

        //
        // Initialize the generation count , reset callback and config rom
        //
        NdisStatus = nicGetGenerationCount (pAdapter, &Generation);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Init, ("Initialize Handler - nicGetGeneration Failed" ) );            
        }
        
        pAdapter->Generation = Generation;
        //
        // request notification of bus resets
        //
        NdisStatus = nicBusResetNotification (pAdapter,
                                              REGISTER_NOTIFICATION_ROUTINE,
                                              nicResetNotificationCallback,
                                              pAdapter);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Init, ("Initialize Handler - nicBusResetNotification  Failed" ) );            
        }

        InitStatus = RegisteredResetCallback;

        //
        // add ip/1394 to the config rom
        //
        NdisStatus = nicAddIP1394ToConfigRom (pAdapter);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Init, ("Initialize Handler - nicAddIP1394ToConfigRom  Failed" ) );            
        }


        InitStatus = AddedConfigRom;

        //
        // Lets find out our MaxRec. 
        //
        NdisStatus = nicGetReadWriteCapLocalHost(pAdapter, &pAdapter->ReadWriteCaps);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }
        

        pAdapter->MaxRec = nicGetMaxRecFromBytes(pAdapter->ReadWriteCaps.MaxAsyncWriteRequest);

        TRACE (TL_V, TM_Mp,  (" MaxRec %x\n", pAdapter->MaxRec ) );

        //
        // Update the Local Speed. If we fail now, we will get it again
        // after a Reset.
        //

        nicUpdateLocalHostSpeed (pAdapter);
        
        TRACE (TL_V, TM_Mp,  (" SCode %x", pAdapter->SCode) );
        
        //
        // Bus Reset - used to kick off the BCM algorithm
        //

        nicIssueBusReset (pAdapter,BUS_RESET_FLAGS_FORCE_ROOT );


        //
        // Register this adapter with the enumerator. 
        //
        if (NdisEnum1394DeregisterAdapter != NULL)
        {
            NtStatus = NdisEnum1394RegisterAdapter((PVOID)pAdapter,
                                                   pNextDeviceObject,
                                                   &pAdapter->EnumAdapterHandle,
                                                   &LocalHostUniqueId);
            if (NtStatus != STATUS_SUCCESS)
            {
                
                ADAPTER_SET_FLAG(pAdapter, fADAPTER_FailedRegisteration);

                //
                // Don;t Bail Out
                //
                
                //NdisStatus = NDIS_STATUS_FAILURE;
                BREAK( TM_Init, ( "nicMpInitialize  -  NdisEnum1394RegisterAdapter FAILED ") );
            
                
            }
            else
            {
                ADAPTER_SET_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator);
                InitStatus = RegisteredEnumerator;

            }


        }
        else
        {
            GET_LOCAL_HOST_INFO1  Uid;
            //
            // Enum is not loaded get the Unique Id
            //
            NdisStatus = nicGetLocalHostUniqueId (pAdapter, 
                                                 &Uid );                            
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK( TM_Init, ( " nicMpInitialize  - nicGetLocalHostUniqueId  FAILED ") );
            }
            else
            {
                LocalHostUniqueId = Uid.UniqueId;
            }
        }
       
        //
        // Validate the Local Adapter's Unique Id
        //
        if (LocalHostUniqueId.QuadPart == (UINT64)(0) )
        {
            nicWriteErrorLog (pAdapter,NDIS_ERROR_CODE_HARDWARE_FAILURE, NIC_ERROR_CODE_INVALID_UNIQUE_ID_0);
            NdisStatus = NDIS_STATUS_FAILURE;
            break;            
        }
        if (LocalHostUniqueId.QuadPart == (UINT64)(-1) )
        {
            nicWriteErrorLog (pAdapter,NDIS_ERROR_CODE_HARDWARE_FAILURE,NIC_ERROR_CODE_INVALID_UNIQUE_ID_FF);
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

#ifdef PKT_LOG

        nic1394AllocPktLog (pAdapter);

        if (pAdapter->pPktLog == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            BREAK (TM_Init, ("nicMpInitialize - Could not allocate packetlog" ) );
        }

        nic1394InitPktLog(pAdapter->pPktLog);

        InitStatus = InitializedPktLog;

#endif


        //
        // Initialize the reassembly timers
        //
        nicInitSerializedReassemblyStruct(pAdapter); // cannot fail

        InitStatus = InitializedReassembly;

        //
        // This swap is done so that the byte reported by the bus driver matches that 
        // which is used in the notification of add nodes, remove nodes and make call
        //
        LocalHostUniqueId.LowPart = SWAPBYTES_ULONG (LocalHostUniqueId.LowPart );
        LocalHostUniqueId.HighPart = SWAPBYTES_ULONG (LocalHostUniqueId.HighPart );
        
        u64LocalHostUniqueId = LocalHostUniqueId.QuadPart;

            
        pAdapter->UniqueId = u64LocalHostUniqueId;
        pAdapter->HardwareStatus = NdisHardwareStatusReady;

        //
        // Get Our local Fake Mac address
        //
        nicGetFakeMacAddress (&u64LocalHostUniqueId, &pAdapter->MacAddressEth);

        
        //
        // Initialize the lookaside lists
        //
        nicInitializeAdapterLookasideLists (pAdapter);
        InitStatus = InitializedLookasideList;
        


        //
        //  Initialize the remote node table 
        //
        
        nicUpdateRemoteNodeTable (pAdapter);

        // 
        // initialize the gasp header
        //
        nicMakeGaspHeader (pAdapter, &pAdapter->GaspHeader);


        //
        // Assign a MAC address to this Adapter
        //

        {
            AdapterNum++;
            //
            //  generate a locally 
            //  administered address by manipulating the first two bytes.
            //

        }


        //
        // Allocate the loopback pools
        //
        NdisStatus= nicAllocateLoopbackPacketPool (pAdapter);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Init, ("nicMpInitialize - nicAllocateLoopbackPacketPool  FAILED" ) );
        }
        InitStatus = InitializedLoopbackPool;

        ADAPTER_SET_FLAG (pAdapter, fADAPTER_DoStatusIndications);

        pAdapter->PowerState = NetDeviceStateD0;



    }  while (FALSE);


    
    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        NDIS_STATUS FailureStatus  = NDIS_STATUS_FAILURE; 
        // Failed, so undo whatever portion succeeded.
        //
        TRACE( TL_I, TM_Init, ( "NicMpInitialize FAILING InitStatus %x", InitStatus) );

        ADAPTER_SET_FLAG (pAdapter, fADAPTER_FailedInit);
        ADAPTER_CLEAR_FLAG (pAdapter, fADAPTER_DoStatusIndications);

        //
        // This is in reverse order of the init and there are no breaks here.
        // The implicit assumption is that if the code failed at a certain point
        // it will have to undo whatever was previously allocated
        //

        switch (InitStatus)
        {
            case InitializedLoopbackPool:
            {
                nicFreeLoopbackPacketPool(pAdapter);
                FALL_THROUGH;
            }
            case InitializedLookasideList:
            {
                nicDeleteAdapterLookasideLists(pAdapter);
                FALL_THROUGH;
            }

            case InitializedReassembly:
            {
                nicDeInitSerializedReassmblyStruct(pAdapter);
                FALL_THROUGH;

            }

            case InitializedSendThread:
            {
                FALL_THROUGH;
            }
            case InitializedRcvThread:
            {

                FALL_THROUGH;
            }
            case InitializedPktLog:
            {

#ifdef PKT_LOG
                nic1394DeallocPktLog(pAdapter);
#endif
                FALL_THROUGH
            }
            
            case RegisteredEnumerator:
            {
                //
                // If we registered with the enumerator , then deregister
                //
                if ((NdisEnum1394DeregisterAdapter != NULL) &&
                    ADAPTER_TEST_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator))
                {       
                    //
                    // deregister this adapter with enumerator
                    //
                    TRACE( TL_V, TM_Init, ( "  Deregistering with the Enum %x", pAdapter->EnumAdapterHandle) );

                    NdisEnum1394DeregisterAdapter(pAdapter->EnumAdapterHandle);
        
                    ADAPTER_CLEAR_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator | fADAPTER_FailedRegisteration);
                }   

                FALL_THROUGH
            }

            case AddedConfigRom:
            {
                TRACE( TL_V, TM_Init, ( "  removing config rom handle %x", pAdapter->hCromData ) );

                
                FailureStatus = nicSetLocalHostPropertiesCRom(pAdapter,
                                                              (PUCHAR)&Net1394ConfigRom,
                                                               sizeof(Net1394ConfigRom),
                                                               SLHP_FLAG_REMOVE_CROM_DATA,
                                                               &pAdapter->hCromData,
                                                               &pAdapter->pConfigRomMdl);
    
    
                FALL_THROUGH

            }

            case RegisteredResetCallback:
            {
                TRACE( TL_V, TM_Init, ( "  Deregistering reset callback ") );

                //
                // Deregeister the reset callback
                //
                FailureStatus = nicBusResetNotification (pAdapter,
                                                         DEREGISTER_NOTIFICATION_ROUTINE,
                                                         nicResetNotificationCallback,
                                                         pAdapter) ;
                                         

                FALL_THROUGH



            }

            case InitializedBcr:
            case InitializedEvents:
            {
                TRACE( TL_V, TM_Init, ( "  Freeing BCR ") );


                nicFreeBroadcastChannelRegister(pAdapter);

                NdisWaitEvent (&pAdapter->BCRData.BCRFreeAddressRange.NdisEvent, WAIT_INFINITE);


                FALL_THROUGH

            }

            case AdapterQueued:
            {
                NdisAcquireSpinLock ( &g_DriverLock);
                nicRemoveEntryList (&pAdapter->linkAdapter);
                NdisReleaseSpinLock (&g_DriverLock);

                FALL_THROUGH
            }

            case AllocatedAdapter:
            {
                nicDereferenceAdapter(pAdapter, "NicMpInitialize");
                
                break;
            }

            default :
            {
                ASSERT (0);
            }
        }
    }


    TRACE( TL_T, TM_Init, ( "<==NicMpInitialize=$%08x", NdisStatus ) );
    MATCH_IRQL;

    TRACE( TL_I, TM_Init, ( "NicMpInitialize Status %x, pAdapter %p", NdisStatus,pAdapter  ) );

    TIMESTAMP_EXIT("<==IntializeHandler");

    return NdisStatus;
}


VOID
NicMpHalt(  
    IN NDIS_HANDLE MiniportAdapterContext 
    )

/*++

Routine Description:

     Standard 'MiniportHalt' routine called by NDIS to deallocate all
     resources attached to the adapter.  NDIS does not make any other calls
     for this mini-port adapter during or after this call.  NDIS will not
     call this routine when packets indicated as received have not been
     returned, or when any VC is created and known to NDIS.  Runs at PASSIVE
     IRQL.
   


Arguments:

    
Return Value:

--*/
{
    PADAPTERCB pAdapter = (PADAPTERCB) MiniportAdapterContext;
    BOOLEAN TimerCancelled = FALSE;
    STORE_CURRENT_IRQL

    TIMESTAMP_ENTRY("==>Haltandler");

    TRACE( TL_T, TM_Mp, ( "==>NicMpHalt" ) );
    

    TRACE( TL_I, TM_Mp, ( "  Adapter %x Halted", pAdapter ) );

    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return;
    }

    ADAPTER_CLEAR_FLAG (pAdapter, fADAPTER_DoStatusIndications);

    //
    // Unload the Arp module if necessary. This is necessary if 
    // the nic is forced to operate in a non-power managed environment
    // by the user.
    //
    if (pAdapter->fIsArpStarted == TRUE)
    {
        nicQueueRequestToArp(pAdapter, UnloadArpNoRequest, NULL);
    }

    ADAPTER_SET_FLAG (pAdapter, fADAPTER_Halting);


    //
    // Stop the reassembly timer
    //
    nicDeInitSerializedReassmblyStruct(pAdapter);

    //
    // Deallocating the packet log
    //
#ifdef PKT_LOG
    nic1394DeallocPktLog(pAdapter);
#endif
    //
    //  remove the config rom
    //
    nicSetLocalHostPropertiesCRom(pAdapter,
                                  (PUCHAR)&Net1394ConfigRom,
                                  sizeof(Net1394ConfigRom),
                                  SLHP_FLAG_REMOVE_CROM_DATA,
                                  &pAdapter->hCromData,
                                  &pAdapter->pConfigRomMdl);

    pAdapter->hCromData = NULL;

    //
    // free the apapter packet pool
    
    nicFreeLoopbackPacketPool(pAdapter);

    //
    // Free the BCR
    //
    nicFreeBroadcastChannelRegister(pAdapter);

    TRACE (TL_V, TM_Mp,  ("About to Wait for Free AddressRange\n" ) );
    NdisWaitEvent (&pAdapter->BCRData.BCRFreeAddressRange.NdisEvent, WAIT_INFINITE);
    TRACE (TL_V, TM_Mp, ("Wait Completed for Free AddressRange\n" ) );

    nicBusResetNotification (pAdapter,
                             DEREGISTER_NOTIFICATION_ROUTINE,
                             nicResetNotificationCallback,
                             pAdapter);

    //
    // deregister this adapter with enumerator
    //
    if ((NdisEnum1394DeregisterAdapter != NULL) &&
        ADAPTER_TEST_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator))
    {       
        //
        // deregister this adapter with enumerator
        //
        NdisEnum1394DeregisterAdapter(pAdapter->EnumAdapterHandle);
        
        ADAPTER_CLEAR_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator | fADAPTER_FailedRegisteration);
    }   

    //
    // No more Irps on this adapter's VDO
    //

    ADAPTER_SET_FLAG (pAdapter, fADAPTER_VDOInactive);

    
    //
    //  Cancel Outstanding Timer
    //

    ADAPTER_SET_FLAG (pAdapter, fADAPTER_FreedTimers);

    //
    //  Cancel Outstanding WorItems
    //
    while (pAdapter->OutstandingWorkItems  != 0) 
    {

        NdisMSleep (10000);                       

    } 

    ADAPTER_SET_FLAG (pAdapter, fADAPTER_DeletedWorkItems);

    // Remove this adapter from the global list of adapters.
    //
    NdisAcquireSpinLock(&g_DriverLock);
    nicRemoveEntryList(&pAdapter->linkAdapter);
    NdisReleaseSpinLock(&g_DriverLock);

    ADAPTER_ACQUIRE_LOCK (pAdapter);
    // do Adapter Specific Work here
    pAdapter->HardwareStatus = NdisHardwareStatusClosing;   

    //
    // Free all lookaside lists
    // 
    nicDeleteAdapterLookasideLists (pAdapter);

    ADAPTER_SET_FLAG (pAdapter, fADAPTER_DeletedLookasideLists);
       
    ADAPTER_RELEASE_LOCK (pAdapter);
        
    NdisFreeSpinLock (&pAdapter->lock);

    while (pAdapter->lRef != 1)
    {
        //
        // sleep for 1 second waiting for outstanding operations to complete
        //
        NdisMSleep (1000); 
    }

    nicDereferenceAdapter( pAdapter, "nicMpHalt" );


    //ASSERT (g_AdapterFreed == TRUE);
    
    TRACE( TL_T, TM_Mp, ( "<==NicMpHalt " ) );

    TIMESTAMP_EXIT("<==Haltandler");
    TIMESTAMP_HALT();

    TRACE( TL_I, TM_Init, ( "Nic1394 Halted %p ", pAdapter ) );


    MATCH_IRQL
}


NDIS_STATUS
NicMpReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext 
    )

/*++

Routine Description:

    Do Nothing

Arguments:

    
Return Value:

--*/
{
    TRACE( TL_T, TM_Mp, ( "NicMpReset" ) );

    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
NicMpCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters 
    )

/*++

Routine Description:

     Do Nothing
     Standard 'MiniportCoActivateVc' routine called by NDIS in response to a
     protocol's request to activate a virtual circuit.
    
     The only "protocol" to call us is our call manager half, which knows
     exactly what it's doing and so we don't have to do anything here.
     It does expect us to return success synchronously.
    


Arguments:

    
Return Value:
    Always Succeed

--*/
{
    return NDIS_STATUS_SUCCESS;
}



NDIS_STATUS
NicMpCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext 
    )

/*++

Routine Description:


     Standard 'MiniportCoDeactivateVc' routine called by NDIS in response to
     a protocol's request to de-activate a virtual circuit.
    
     The only "protocol" to call us is our call manager half, which knows
     exactly what it's doing and so we don't have to do anything here.
     It does expect us to return success synchronously.
    



Arguments:

    
Return Value:

--*/
{
    return NDIS_STATUS_SUCCESS;
}



VOID
NicMpCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets 
    )

/*++

Routine Description:

    Co Send Handler for the Miniport
    Any broadcast packets have to be looped back as 1394 does 
    not loop back packets sent on a channel

Arguments:
    See DDK
    
Return Value:
    None: After the first failure, call NdisMCoSendComplete(..) 
    on all packets

--*/
{
    UINT i;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    NDIS_PACKET** ppPacket;
    VCCB* pVc;
    extern UINT NicSends;

    TRACE( TL_V, TM_Send, ( "==>NicMpCoSendPackets(%d), Vc %.8x", NumberOfPackets, MiniportVcContext ) );

    

    pVc = (VCCB* )MiniportVcContext;
    ASSERT( pVc->Hdr.ulTag == MTAG_VCCB );

    for (i = 0, ppPacket = PacketArray;
         i < NumberOfPackets;
         ++i, ++ppPacket)
    {
        NDIS_PACKET* pPacket = *ppPacket;
        // SendPacket sends the packet and eventually calls
        // NdisMCoSendComplete to notify caller of the result.
        //
        NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_PENDING );
        nicIncrementSends (pVc);

        nicDumpPkt (pPacket , "Sending ");

        //
        // Loopback the packet it is a broadcast packet
        //
        if (pVc->Hdr.VcType == NIC1394_SendRecvChannel ||
            pVc->Hdr.VcType == NIC1394_MultiChannel ||
            pVc->Hdr.VcType == NIC1394_SendChannel)
        {
            nicLoopbackPacket(pVc, pPacket);
        }

        nicUpdatePacketState (pPacket, NIC1394_TAG_IN_SEND);

        NdisStatus = pVc->Hdr.VcHandlers.SendPackets (pVc, pPacket);

        if (NT_SUCCESS (NdisStatus) == FALSE)
        {
              TRACE( TL_N, TM_Send, ( "SendHandler failed Status %.8x", NdisStatus ) );

            break;
        }
    }

    //  If the call to the VC's Send handler was not successful
    //  Indicate failure for that packet and all packets following it
    //

    if (NT_SUCCESS(NdisStatus) == FALSE) // can pend also 
    {   
        //  Start from the packet which caused the break and indicate
        //  Failure (call the completion handler for each packet
        //

        for ( ; i < NumberOfPackets;++i,++ppPacket)
        {
            TRACE( TL_V, TM_Send, ( "Calling NdisCoSendComplete, status %x, VcHandle %x, pPkt %x",
                          NDIS_STATUS_FAILURE , pVc->Hdr.NdisVcHandle, *ppPacket ) );

            nicMpCoSendComplete (NDIS_STATUS_FAILURE, pVc,*ppPacket);
        }
        
    }


    TRACE( TL_T, TM_Send, ( "<==NicMpCoSendPackets " ) );
}


NDIS_STATUS
NicMpCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest 
    )

/*++

Routine Description:

    Standard CoRequest handler. It branches off into a Query function 
    and a Set Function.


Arguments:
    See DDK
    
Return Value:

--*/
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_STATUS status;

    TRACE( TL_T, TM_Mp, ( "NicMpCoReq, Request %.8x", NdisRequest ) );


    pAdapter = (ADAPTERCB* )MiniportAdapterContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pVc = (VCCB* )MiniportVcContext;
    if (pVc && pVc->Hdr.ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    switch (NdisRequest->RequestType)
    {
        case NdisRequestQueryStatistics:
        case NdisRequestQueryInformation:
        {
            status = nicQueryInformation(
                pAdapter,
                pVc,
                NdisRequest
                );
            break;
        }

        case NdisRequestSetInformation:
        {   
            status = nicSetInformation(
                pAdapter,
                pVc,
                NdisRequest
                );
            break;
        }

        
        default:
        {
            status = NDIS_STATUS_NOT_SUPPORTED;
            TRACE( TL_V, TM_Mp, ( "type=%d?", NdisRequest->RequestType ) );
            break;
        }
    }

    TRACE( TL_T, TM_Mp, ( "NicMpCoReq, Status=$%x", status ) );

    return status;
}


//-----------------------------------------------------------------------------
// Mini-port utility routines (alphabetically)
// Some are used externally
//-----------------------------------------------------------------------------

VOID
nicDereferenceAdapter(
    IN PADAPTERCB pAdapter, 
    IN PCHAR pDebugPrint
    )

/*++

Routine Description:

    Dereferences the Adapter, If the Ref is zero, it will free 
    the adapter object. 

    It expects that this will happen in the Halt Handler.

    The Ref Count cannot bounce back up from zero because the last refernce 
    is Dereferenced only after no new operations can be started on the adapter.

Arguments:

    Adapter
    DebugString
    
Return Value:

--*/
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pAdapter->lRef );

    TRACE( TL_V, TM_Ref, ( "**nicDereferenceAdapter  pAdapter %x, to %d, %s ", pAdapter, pAdapter->lRef, pDebugPrint  ) );

    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        nicFreeAdapter( pAdapter );
    }
}


VOID
nicFreeAdapter(
    IN ADAPTERCB* pAdapter
    )

/*++

Routine Description:

    Free the memory for the adapter structure

Arguments:

    
Return Value:

--*/
{


    pAdapter->ulTag = MTAG_FREED;

    ASSERT (pAdapter->lRef == 0);
     
    FREE_NONPAGED( pAdapter );

    g_AdapterFreed  = TRUE;
}


NDIS_STATUS
nicGetRegistrySettings(
    IN NDIS_HANDLE WrapperConfigurationContext,
    IN ADAPTERCB * pAdapter
    )

/*++

Routine Description:

    nic1394 reads 1 registry parameter and that is the name of the 
    NDIS miniport so that it can be used if the miniport is ever
    set into Bridge mode

Arguments:

    
Return Value:

--*/
{
    NDIS_STATUS status;
    NDIS_HANDLE hCfg;
    NDIS_CONFIGURATION_PARAMETER* pncp;
    PNDIS_CONFIGURATION_PARAMETER pNameConfig;
    NDIS_STRING strMiniportName = NDIS_STRING_CONST("MiniportName");
    ULONG AdapterNameSizeInBytes = 0;


    NdisOpenConfiguration( &status, &hCfg, WrapperConfigurationContext );
    if (status != NDIS_STATUS_SUCCESS)
        return status;

    do
    {
        //
        // Read the Miniport Name. First setup the buffer
        //
    
        NdisReadConfiguration(&status,
                              &pNameConfig,
                              hCfg,
                              &strMiniportName,
                              NdisParameterString);

        if (status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        AdapterNameSizeInBytes = pNameConfig->ParameterData.StringData.Length;


        //
        // Only Copy the Adapter name if the size of the string from the registry
        // is smaller than the size we have allocated in the adapter structure.
        // There should also be room for the trailing L'\0' character.
        //

        if ((ADAPTER_NAME_SIZE*sizeof(WCHAR)) > (AdapterNameSizeInBytes+2))
        {
            PUCHAR pAdapterName = (PUCHAR)&pAdapter->AdapterName[0];
            
            pAdapter->AdapterNameSize = AdapterNameSizeInBytes; 

            NdisMoveMemory (pAdapterName,   // Destination
                            pNameConfig->ParameterData.StringData.Buffer, // Source
                             AdapterNameSizeInBytes ); // number of characters
            
            //
            // NULL - terminate the string by adding the L'\0' Unicode character
            //
            pAdapterName[AdapterNameSizeInBytes]= 0;
            pAdapterName[AdapterNameSizeInBytes+1]= 0;
            
        }
        


    }
    while (FALSE);

    NdisCloseConfiguration( hCfg );

    TRACE( TL_N, TM_Init,
        ( "Reg: Name %s", &pAdapter->AdapterName));

    return status;
}


NDIS_STATUS
nicQueryInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN OUT PNDIS_REQUEST NdisRequest
    )

/*++

Routine Description:

    NOTE: this function can be called in at least two contexts:
    1: in the context of an NdisRequest
    2: in the context of our own work item, if the request needs to be completed
       at passive.


Arguments:


Return Value:


--*/

{

    NDIS_STATUS status;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;
    USHORT usInfo;
    NDIS_OID Oid;
    PVOID InformationBuffer;
    ULONG InformationBufferLength;
    PULONG BytesWritten;
    PULONG BytesNeeded;
    NDIS_CO_LINK_SPEED          CoLinkSpeed;
    NIC1394_LOCAL_NODE_INFO     LocalNodeInfo;
    NIC1394_VC_INFO             VcInfo;
    NDIS_PNP_CAPABILITIES       PnpCaps;
    NIC1394_NICINFO             NicInfo;
    
    Oid =            NdisRequest->DATA.QUERY_INFORMATION.Oid;
    InformationBuffer =  NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;
    InformationBufferLength = 
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength;
    BytesWritten =  &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten;
    BytesNeeded = &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded;
    

    //  The next variables are used to setup the data structures that are 
    //  used to respond to the OIDs they correspond to
    //
 
    TRACE( TL_T, TM_Init, ( "==>nicQueryInformation, Adapter %.8x, Vc %.8x, Oid %.8x",pAdapter, pVc, Oid ));


    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof(ulInfo);

    status = NDIS_STATUS_SUCCESS;
    
    switch (Oid)
    {
    
        
        case OID_GEN_CO_SUPPORTED_LIST:
        {
            
            pInfo = &SupportedOids[0];
            ulInfoLen = sizeof(SupportedOids);
            break;
        }

        case OID_GEN_CO_HARDWARE_STATUS:
        {
            
            //
            //  Copy the hardware status into the users buffer.
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_HARDWARE_STATUS)" ) );

            NdisAcquireSpinLock (&pAdapter->lock);

            pInfo = (PUCHAR) &pAdapter->HardwareStatus;

            NdisReleaseSpinLock (&pAdapter->lock);
            
            ulInfoLen = sizeof(pAdapter->HardwareStatus);
            break;
        }


        case OID_GEN_MAXIMUM_LOOKAHEAD:
        {
            
            // Report the maximum number of bytes we can always provide as
            // lookahead data on receive indications.  We always indicate full
            // packets so this is the same as the receive block size.  And
            // since we always allocate enough for a full packet, the receive
            // block size is the same as the frame size.
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_LOOKAHEAD)" ) );
            ulInfo = Nic1394_MaxFrameSize;
            break;
        }

        case OID_GEN_CO_MAC_OPTIONS:
        {
            // Report a bitmask defining optional properties of the driver.
            //
            // NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA promises that our receive
            // buffer is not on a device-specific card.
            //
            // NDIS_MAC_OPTION_TRANSFERS_NOT_PEND promises we won't return
            // NDIS_STATUS_PENDING from our TransferData handler which is true
            // since we don't have one.
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_MAC_OPTIONS)" ) );
            ulInfo = 0;
            break;
        }



        case OID_GEN_CO_MEDIA_SUPPORTED:
        case OID_GEN_CO_MEDIA_IN_USE:
        {
            //
            //  We support 1394.
            //
              
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_MEDIA_SUPPORTED or OID_GEN_CO_MEDIA_IN_USE)" ) );

            ulInfo = g_ulMedium;

            break;
        }


        case OID_GEN_CO_MINIMUM_LINK_SPEED:
        {

            //
            //  Link speed depends upon the type of adapter. We will need to 
            //  add support for different speeds and so forth
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_MINIMUM_LINK_SPEED or OID_GEN_CO_LINK_SPEED)" ) );
            CoLinkSpeed.Inbound = CoLinkSpeed.Outbound = pAdapter->SpeedMbps; //10 Mbps ????
                                    
            pInfo = (PUCHAR)&CoLinkSpeed;
            ulInfoLen = sizeof(CoLinkSpeed);

            TRACE( TL_V, TM_Mp, ( "Link Speed %x" ,CoLinkSpeed.Outbound  ) );


            break;
        }

        case OID_GEN_CO_VENDOR_ID:
        {
            //
            //  We need to add the appropriate vendor id for the nic1394
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_VENDOR_ID)" ) );
                    
            ulInfo = 0xFFFFFFFF;

            break;

        }

        case OID_GEN_CO_VENDOR_DESCRIPTION:
        {

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_VENDOR_DESCRIPTION)" ) );
        
            pInfo = (PUCHAR)pnic1394DriverDescription;
            ulInfoLen = strlen(pnic1394DriverDescription);

            break;
        }
       
        case OID_GEN_VENDOR_DRIVER_VERSION:
        {

            pInfo =(PVOID) &nic1394DriverGeneration;
            ulInfoLen = sizeof(nic1394DriverGeneration);
            break;
        }

        case OID_GEN_CO_DRIVER_VERSION:
        {
            //
            //  Return the version of NDIS that we expect.
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_DRIVER_VERSION)" ) );
                    
            usInfo = ((NDIS_MajorVersion << 8) | NDIS_MinorVersion);
            pInfo = (PUCHAR)&usInfo;
            ulInfoLen = sizeof(USHORT);

            break;
        }
        
        case OID_GEN_CO_PROTOCOL_OPTIONS:
        {
            //
            //  We don't support protocol options.
            //

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_PROTOCOL_OPTIONS)" ) );
                    
            ulInfo = 0;

            break;
        }
        
        case OID_GEN_CO_MEDIA_CONNECT_STATUS:
        {
            //
            //  Return our true state only if we have ever received a 
            // remote node in this boot.
            //
            
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CO_MEDIA_CONNECT_STATUS)" ) );

            if (ADAPTER_TEST_FLAG(pAdapter, fADAPTER_RemoteNodeInThisBoot) == FALSE)
            {
                ulInfo = NdisMediaStateConnected;
            }
            else
            {
                ulInfo = pAdapter->MediaConnectStatus;
            }

            break;
        }

        case OID_1394_IP1394_CONNECT_STATUS:
        {
            //
            //  Return whether or not we have a link. This is used by the Arp
            //  module to set connectivity
            //
            
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_1394_IP1394_CONNECT_STATUS)" ) );
                    
            ulInfo = pAdapter->MediaConnectStatus;

            break;
        } 

        case OID_1394_LOCAL_NODE_INFO:
        {

            //  This Oid return information about the local node 
            //  on the machine
            //  Need to change this with real values that will be present
            //  in the header structures
            //
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_1394_LOCAL_NODE_INFO)" ) );

            ADAPTER_ACQUIRE_LOCK (pAdapter);
 
            LocalNodeInfo.UniqueID = pAdapter->UniqueId;
            LocalNodeInfo.BusGeneration = pAdapter->Generation;
            LocalNodeInfo.NodeAddress = pAdapter->NodeAddress;
            LocalNodeInfo.MaxRecvBlockSize = pAdapter->MaxRec; 
            LocalNodeInfo.MaxRecvSpeed = pAdapter->SCode;

            ADAPTER_RELEASE_LOCK (pAdapter);
            
            pInfo = &LocalNodeInfo;
            ulInfoLen = sizeof(LocalNodeInfo);
            break;
        }

        case OID_1394_VC_INFO:
        {

            // Returns information about the VC that is being queried
            //


            TRACE( TL_V, TM_Mp, ("QInfo(OID_1394_VC_INFO)") );

            if (pVc != NULL)
            {
                VcInfo.Destination = pVc->Hdr.Nic1394MediaParams.Destination;

            
                pInfo = &VcInfo;
                ulInfoLen = sizeof(VcInfo);
            }
            else
            {
                status = NDIS_STATUS_FAILURE;
            }
            
            break;
        }


        case OID_1394_NICINFO:
        {
            if (InformationBufferLength >= sizeof(NicInfo))
            {
                //
                // We need to call nicFillNicInfo at passive, so we switch
                // to a work item context.
                //
                if (KeGetCurrentIrql() > PASSIVE_LEVEL)
                {
                    PNIC_WORK_ITEM pNicWorkItem;
                    pNicWorkItem = ALLOC_NONPAGED (sizeof(NIC_WORK_ITEM), MTAG_WORKITEM); 
                    if (pNicWorkItem != NULL)
                    {
                        NdisZeroMemory(pNicWorkItem, sizeof(*pNicWorkItem));
                        pNicWorkItem->RequestInfo.pNdisRequest = NdisRequest;
                        pNicWorkItem->RequestInfo.pVc = NULL;
                        NdisInitializeWorkItem ( &pNicWorkItem->NdisWorkItem, 
                                             (NDIS_PROC) nicQueryInformationWorkItem,
                                             (PVOID) pAdapter);

                        TRACE( TL_V, TM_Cm, ( "Scheduling QueryInformation WorkItem" ) );
                                            
                        nicReferenceAdapter (pAdapter, "nicFillBusInfo ");

                        NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

                        NdisScheduleWorkItem (&pNicWorkItem->NdisWorkItem);
                        status = NDIS_STATUS_PENDING;

                    }
                    else
                    {
                        status = NDIS_STATUS_RESOURCES;
                    }
                }
                else
                {
                    status =  nicFillNicInfo (
                                pAdapter,
                                (PNIC1394_NICINFO) InformationBuffer,   // Input
                                &NicInfo                                // Output
                                );
                    ASSERT(status != NDIS_STATUS_PENDING);
                }
            }

            pInfo = &NicInfo;
            ulInfoLen = sizeof(NicInfo);
            break;

        }
        case OID_1394_QUERY_EUID_NODE_MAP:
        {
            if (sizeof (EUID_TOPOLOGY) <= InformationBufferLength )
            {
                nicQueryEuidNodeMacMap (pAdapter, NdisRequest);
                status = NDIS_STATUS_PENDING;
            }
            else
            {
                //
                // This will cause NDIS_STATUS_INVALID_LENGTH to be returned
                //
                ulInfoLen = sizeof (EUID_TOPOLOGY);  
            }
            break;
        }        
        case OID_GEN_CO_XMIT_PDUS_OK: 
        {
            ulInfo = pAdapter->AdaptStats.ulXmitOk;
            break;
        }
        case OID_GEN_CO_RCV_PDUS_OK:
        {
            ulInfo = pAdapter->AdaptStats.ulRcvOk;
            break;
        }
        case OID_GEN_CO_XMIT_PDUS_ERROR:
        {
            ulInfo = pAdapter->AdaptStats.ulXmitError;
            break;
        }
        case OID_GEN_CO_RCV_PDUS_ERROR:
        {
            ulInfo = pAdapter->AdaptStats.ulRcvError;
            break;
        }
        case OID_GEN_CO_RCV_PDUS_NO_BUFFER:
        {
            ulInfo = 0;
            break;
        }

        case OID_GEN_PHYSICAL_MEDIUM:
        {
            TRACE( TL_V, TM_Mp, ( " OID_GEN_PHYSICAL_MEDIUM" ) );

            ulInfo = NdisPhysicalMedium1394;
            break;
        }

        case OID_1394_ISSUE_BUS_RESET:
        {
            TRACE( TL_V, TM_Mp, ( " OID_1394_ISSUE_BUS_RESET" ) );

            //
            // The ndistester is currently  the only user of this oid and does not set the flag
            //
            if (InformationBufferLength == sizeof(ULONG))
            {
                nicIssueBusReset (pAdapter, BUS_RESET_FLAGS_FORCE_ROOT );
            }
            
            break;
        }
 
        case OID_PNP_CAPABILITIES:
        {
            TRACE( TL_V, TM_Mp, ("QInfo(OID_PNP_CAPABILITIES)") );
            
            PnpCaps.Flags = 0;
            PnpCaps.WakeUpCapabilities.MinMagicPacketWakeUp = NdisDeviceStateUnspecified;           
            PnpCaps.WakeUpCapabilities.MinPatternWakeUp = NdisDeviceStateUnspecified;
            PnpCaps.WakeUpCapabilities.MinLinkChangeWakeUp = NdisDeviceStateUnspecified;

            pInfo = &PnpCaps;
            ulInfoLen = sizeof (PnpCaps);
            
            break;
        }

        case OID_PNP_QUERY_POWER:
        {
            //
            // The miniport is always ready to go into low power state.
            //
            *BytesWritten = sizeof (NDIS_DEVICE_POWER_STATE );
            *BytesNeeded = sizeof (NDIS_DEVICE_POWER_STATE  );
            status = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Now do the Ethernet OIDS
        //
            
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_MAXIMUM_FRAME_SIZE:
        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
        case OID_GEN_MAXIMUM_SEND_PACKETS:
        case OID_GEN_TRANSMIT_BUFFER_SPACE:
        case OID_GEN_RECEIVE_BUFFER_SPACE:
        case OID_802_3_PERMANENT_ADDRESS:
        case OID_802_3_CURRENT_ADDRESS:
        case OID_802_3_MULTICAST_LIST:
        case OID_802_3_MAXIMUM_LIST_SIZE:
        case OID_802_3_RCV_ERROR_ALIGNMENT:
        case OID_802_3_XMIT_ONE_COLLISION:
        case OID_802_3_XMIT_MORE_COLLISIONS:
        case OID_GEN_LINK_SPEED:
        case OID_GEN_CURRENT_PACKET_FILTER:
        {
            status = NicEthQueryInformation((NDIS_HANDLE)pAdapter, 
                                           Oid,
                                           InformationBuffer,
                                           InformationBufferLength,
                                           BytesWritten,
                                           BytesNeeded
                                           );


            if (status == NDIS_STATUS_SUCCESS)
            {
                pInfo = InformationBuffer;
                ulInfoLen = *BytesWritten;

            }
            else
            {
                if (status == NDIS_STATUS_INVALID_LENGTH)
                {
                   ulInfoLen = *BytesNeeded;            
                }
                else
                {
                    status = NDIS_STATUS_NOT_SUPPORTED;
                    TRACE( TL_V, TM_Mp, ( "Q-OID=$%08x?", Oid ) );
                }
            }
            break;

        }

        default:
        {
            TRACE( TL_V, TM_Mp, ( "Q-OID=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        *BytesWritten  = 0;
        status = NDIS_STATUS_INVALID_LENGTH;
    }
    else 
    {
        //
        // If the request has not been pended then, fill
        // out the retuen values
        //
        if (status == NDIS_STATUS_SUCCESS )
        {
            // Copy the found result to caller's buffer.
            //
            if (ulInfoLen > 0)
            {
                NdisMoveMemory( InformationBuffer, pInfo, ulInfoLen );
                DUMPDW( TL_V, TM_Mp, pInfo, ulInfoLen );
            }

            *BytesNeeded = *BytesWritten = ulInfoLen;
        }
    }


    TRACE( TL_N, TM_Mp, ( " Q-OID=$%08x, Status %x, Bytes Written %x", Oid, status, *BytesWritten ) );

    TRACE( TL_T, TM_Init, ( "<==nicQueryInformation, Status %.8x", status ));

    return status;
}


VOID
nicReferenceAdapter(
    IN ADAPTERCB* pAdapter ,
    IN PCHAR pDebugPrint
    )
/*++

Routine Description:



Arguments:

    
Return Value:

--*/

    // Adds areference to the adapter block, 'pAdapter'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pAdapter->lRef );

    TRACE( TL_V, TM_Ref, ( "**nicReferenceAdapter  pAdapter %x, to %d, %s ", pAdapter, pAdapter->lRef, pDebugPrint  ) );

}


NDIS_STATUS
nicSetInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN OUT PNDIS_REQUEST NdisRequest
    )

/*++

Routine Description:

     Handle SetInformation requests.  Arguments are as for the standard NDIS
     'MiniportQueryInformation' handler except this routine does not count
     on being serialized with respect to other requests.    

Arguments:

    
Return Value:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG ulInfo = 0;
    VOID* pInfo= NULL;
    ULONG ulInfoLen= 0;
    USHORT usInfo = 0;
    NDIS_OID Oid;
    PVOID InformationBuffer;
    ULONG InformationBufferLength;
    PULONG BytesRead;
    PULONG BytesNeeded;

    //
    // Initialize the REquest Variables
    //
    Oid =            NdisRequest->DATA.SET_INFORMATION.Oid;
    InformationBuffer =  NdisRequest->DATA.SET_INFORMATION.InformationBuffer;
    InformationBufferLength = 
                NdisRequest->DATA.SET_INFORMATION.InformationBufferLength;
    BytesRead =  &NdisRequest->DATA.SET_INFORMATION.BytesRead;
    BytesNeeded = &NdisRequest->DATA.SET_INFORMATION.BytesNeeded;
    
    TRACE( TL_T, TM_Init, ( "==>nicSetInformation , Adapter %.8x, Vc %.8x, Oid %.8x",pAdapter, pVc, Oid ));
    


    Status = NDIS_STATUS_SUCCESS;

    switch (Oid)
    {

        case OID_GEN_CURRENT_PACKET_FILTER:
        {
            ULONG Filter;
            
            if (InformationBufferLength < sizeof (ULONG))
            {
                Status = NDIS_STATUS_INVALID_LENGTH;
                break;
            }
            else
            {
                *BytesNeeded  = sizeof (ULONG);
            }

            //
            // Store the new value.
            //
            NdisMoveMemory(&Filter, InformationBuffer, sizeof(ULONG));

            //
            // Don't allow promisc mode, because we can't support that.
            //
            if (Filter & NDIS_PACKET_TYPE_PROMISCUOUS)
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }
            
            pAdapter->CurPacketFilter = Filter;

            Status = NDIS_STATUS_SUCCESS;

            ulInfoLen = sizeof (ULONG);
            break;

        }

        case OID_1394_ENTER_BRIDGE_MODE:
        {
            *BytesNeeded = 0;                           

            nicInitializeLoadArpStruct(pAdapter);
            
            Status = nicQueueRequestToArp (pAdapter, 
                                                   LoadArp, // Load Arp Module
                                                   NdisRequest);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                //
                // we have successfully queued a Workitem
                // so this request needs to be pended
                //
                Status = NDIS_STATUS_PENDING;

            }
            ulInfoLen = sizeof (ULONG);
            break;

        }

        case OID_1394_EXIT_BRIDGE_MODE:
        {

            *BytesNeeded = 0;                           

            if (pAdapter->fIsArpStarted == TRUE)
            {

                
                Status = nicQueueRequestToArp (pAdapter, 
                                              UnloadArp, //Unload Arp Module
                                              NdisRequest);

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    //
                    // we have successfully queued a Workitem
                    // so this request needs to be pended
                    //
                    Status = NDIS_STATUS_PENDING;

                }
                ulInfoLen = sizeof (ULONG);
            }
            else
            {
                Status = NDIS_STATUS_SUCCESS;
                ulInfoLen = sizeof (ULONG);
               
            }

            break;
        }

        
        case OID_802_3_MULTICAST_LIST:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_NETWORK_LAYER_ADDRESSES:
        {
            Status =  NicEthSetInformation(pAdapter,
                                           Oid,
                                          InformationBuffer,
                                          InformationBufferLength,
                                          BytesRead ,
                                          BytesNeeded 
                                          );

            break;
        }

        case OID_1394_ISSUE_BUS_RESET:
        {
            TRACE( TL_V, TM_Mp, ( " OID_1394_ISSUE_BUS_RESET" ) );
            //
            // The ndistester is currently  the only user of this oid and does not set the flag
            //
            if (InformationBufferLength == sizeof(ULONG))
            {
                nicIssueBusReset (pAdapter, BUS_RESET_FLAGS_FORCE_ROOT );
            }
            
            break;
        }

        case OID_PNP_SET_POWER:

            TRACE( TL_V, TM_Mp, ( "QInfo OID_PNP_SET_POWER %x", Oid ) );
        
            *BytesRead = sizeof (NDIS_DEVICE_POWER_STATE );
            *BytesNeeded = sizeof (NDIS_DEVICE_POWER_STATE  );
            if (InformationBufferLength >= sizeof (NDIS_DEVICE_POWER_STATE))
            {
                NDIS_DEVICE_POWER_STATE  PoState;
                NdisMoveMemory (&PoState,InformationBuffer,sizeof (PoState));
                Status = nicSetPower(pAdapter,PoState);
            }
            break;

        default:
        {
            TRACE( TL_A, TM_Mp, ( "S-OID=$%08x?", Oid ) );
            Status = NDIS_STATUS_NOT_SUPPORTED;
            *BytesRead = *BytesNeeded = 0;
            break;
        }
    }

    if (*BytesNeeded  > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesRead  = 0;
        Status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {

        *BytesNeeded = *BytesRead = ulInfoLen;
    }

        
      
    TRACE( TL_A, TM_Mp, ( " S-OID=$%08x, Status %x, Bytes Read %x", Oid, Status, *BytesRead ) );


    TRACE( TL_T, TM_Init, ( "<==nicSetInformation, Status %.8x", Status ));

    return Status;
}



//------------------------------------------------------------------------------
// C O N N E C T I O N    L E S S   F U N T I O N S    S T A R T    H E R E  
//


NDIS_STATUS
NicEthSetInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    NDIS_OID            Oid,
    PVOID               InformationBuffer,
    ULONG               InformationBufferLength,
    PULONG              BytesRead,
    PULONG              BytesNeeded
    )


/*++

Routine Description:

    This is the Set information that will be used by the CL edge

Arguments:


Return Value:


--*/

{
    NDIS_STATUS         NdisStatus = NDIS_STATUS_SUCCESS;
    UINT                BytesLeft       = InformationBufferLength;
    PUCHAR              InfoBuffer      = (PUCHAR)(InformationBuffer);
    UINT                OidLength;
    ULONG               LookAhead;
    ULONG               Filter;
    PADAPTERCB          pAdapter;
    BOOLEAN             IsShuttingDown;
    STORE_CURRENT_IRQL;


    pAdapter = (PADAPTERCB)MiniportAdapterContext;

    TRACE( TL_T, TM_Init, ( "==>nicEthSetInformation , Adapter %.8x, Oid %.8x",pAdapter, Oid ));

    // 
    // IS the adapter shutting down
    //
    ADAPTER_ACQUIRE_LOCK (pAdapter);
    IsShuttingDown = (! ADAPTER_ACTIVE(pAdapter)) ;
    ADAPTER_RELEASE_LOCK (pAdapter);

    if (IsShuttingDown)
    {
        TRACE( TL_T, TM_Init, ( "  nicSetInformation Shutting Down , Adapter %.8x, Oid %.8x",pAdapter, Oid ));
        
        *BytesRead = 0;
        *BytesNeeded = 0;

        NdisStatus = NDIS_STATUS_SUCCESS;
        return (NdisStatus);
    }

    //
    // Get Oid and Length of request
    //
    OidLength = BytesLeft;

    switch (Oid) 
    {

        case OID_802_3_MULTICAST_LIST:

            if (OidLength % sizeof(MAC_ADDRESS))
            {
                NdisStatus = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
                *BytesNeeded = 0;
                break;
            }
            
            if (OidLength > (MCAST_LIST_SIZE * sizeof(MAC_ADDRESS)))
            {

                NdisStatus= NDIS_STATUS_MULTICAST_FULL;
                *BytesRead = 0;
                *BytesNeeded = 0;
                break;
            }
            
            NdisZeroMemory(
                    &pAdapter->McastAddrs[0], 
                    MCAST_LIST_SIZE * sizeof(MAC_ADDRESS)
                    );
            NdisMoveMemory(
                    &pAdapter->McastAddrs[0], 
                    InfoBuffer,
                    OidLength
                    );
            pAdapter->McastAddrCount = OidLength / sizeof(MAC_ADDRESS);


            break;

        case OID_GEN_CURRENT_PACKET_FILTER:
            //
            // Verify length
            //
            if (OidLength != sizeof(ULONG)) 
            {
                NdisStatus = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
                *BytesNeeded = sizeof(ULONG);
                break;
            }

            //
            // Store the new value.
            //
            NdisMoveMemory(&Filter, InfoBuffer, sizeof(ULONG));

            //
            // Don't allow promisc mode, because we can't support that.
            //
            if (Filter & NDIS_PACKET_TYPE_PROMISCUOUS)
            {
                NdisStatus = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }

            ADAPTER_ACQUIRE_LOCK (pAdapter);        

            pAdapter->CurPacketFilter = Filter;

            ADAPTER_RELEASE_LOCK (pAdapter);
            
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:

            //
            // Verify length
            //
            if (OidLength != 4) 
            {
                NdisStatus = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
                *BytesNeeded = 0;
                break;
            }

            //
            // Store the new value.
            //
            NdisMoveMemory(&LookAhead, InfoBuffer, sizeof(LookAhead));
        
            pAdapter->CurLookAhead = LookAhead;

            break;

        case OID_GEN_NETWORK_LAYER_ADDRESSES:

            
            NdisStatus = NDIS_STATUS_SUCCESS;
            *BytesRead = InformationBufferLength;
            *BytesNeeded = InformationBufferLength;
            break;

        case OID_PNP_SET_POWER:

            TRACE( TL_V, TM_Mp, ( "QInfo OID_PNP_SET_POWER %x", Oid ) );


            *BytesRead = sizeof (NDIS_DEVICE_POWER_STATE );
            *BytesNeeded = sizeof (NDIS_DEVICE_POWER_STATE  );

            if (InformationBufferLength >= sizeof (NDIS_DEVICE_POWER_STATE))
            {
                NDIS_DEVICE_POWER_STATE  PoState;
                NdisMoveMemory (&PoState,InformationBuffer,sizeof (PoState));
                NdisStatus = nicSetPower(pAdapter,PoState);
            }


            break;
            
        case OID_1394_ISSUE_BUS_RESET:
        {
            
            TRACE( TL_V, TM_Mp, ( " OID_1394_ISSUE_BUS_RESET" ) );

            if (InformationBufferLength == sizeof(ULONG))
            {
                nicIssueBusReset (pAdapter, (*(PULONG)InformationBuffer));
            }
            else
            {
                nicIssueBusReset (pAdapter, BUS_RESET_FLAGS_FORCE_ROOT );

            }
            break;
        }        
        
        default:

            NdisStatus = NDIS_STATUS_INVALID_OID;

            *BytesRead = 0;
            *BytesNeeded = 0;

            break;

    }

    if (NdisStatus == NDIS_STATUS_SUCCESS) 
    {
        DUMPDW( TL_V, TM_Mp, InformationBuffer, InformationBufferLength );

        *BytesRead = BytesLeft;
        *BytesNeeded = 0;
    }



    TRACE( TL_T, TM_Init, ( "<==NicEthSetInformation , Adapter %.8x, Oid %.8x, NdisStatus %x",pAdapter, Oid, NdisStatus  ));

    MATCH_IRQL;

    return NdisStatus;
}



NDIS_STATUS 
NicEthQueryInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
)

/*++

Routine Description:

    This is the Query information that will be used by the CL edge

Arguments:


Return Value:


--*/
{
    UINT                    BytesLeft       = InformationBufferLength;
    PUCHAR                  InfoBuffer      = (PUCHAR)(InformationBuffer);
    NDIS_STATUS             NdisStatus      = NDIS_STATUS_SUCCESS;
    NDIS_HARDWARE_STATUS    HardwareStatus  = NdisHardwareStatusReady;
    NDIS_MEDIA_STATE        MediaState;
    NDIS_MEDIUM             Medium;
    PADAPTERCB              pAdapter;   
    ULONG                   GenericULong;
    USHORT                  GenericUShort;
    UCHAR                   GenericArray[6];
    UINT                    MoveBytes       = sizeof(GenericULong);
    PVOID                   MoveSource      = (PVOID)(&GenericULong);
    ULONG                   i;
    STORE_CURRENT_IRQL;



    pAdapter = (PADAPTERCB)MiniportAdapterContext;

    TRACE( TL_T, TM_Init, ( "==>NicEthQueryInformation , Adapter %.8x, Oid %.8x",pAdapter, Oid ));

    

    //
    // Switch on request type
    //
    switch (Oid) 
    {
        case OID_GEN_MAC_OPTIONS:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MAC_OPTIONS)" ) );
            
            GenericULong = NDIS_MAC_OPTION_NO_LOOPBACK;


            break;

        case OID_GEN_SUPPORTED_LIST:

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_SUPPORTED_LIST)" ) );
            MoveSource = (PVOID)(SupportedOids);
            MoveBytes = sizeof(SupportedOids);
            break;

        case OID_GEN_HARDWARE_STATUS:

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_HARDWARE_STATUS)" ) );
            HardwareStatus = NdisHardwareStatusReady;
            MoveSource = (PVOID)(&HardwareStatus);
            MoveBytes = sizeof(NDIS_HARDWARE_STATUS);

            break;

        case OID_GEN_MEDIA_CONNECT_STATUS:

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MEDIA_CONNECT_STATUS)" ) );
            if (ADAPTER_TEST_FLAG(pAdapter, fADAPTER_RemoteNodeInThisBoot) == FALSE)
            {
                MediaState = NdisMediaStateConnected;
            }
            else
            {
                MediaState = pAdapter->MediaConnectStatus;
            }
            MoveSource = (PVOID)(&MediaState);
            
            MoveBytes = sizeof(NDIS_MEDIA_STATE);

            break;

        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:

            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MEDIA_SUPPORTED)" ) );

            Medium = g_ulMedium;

            
            MoveSource = (PVOID) (&Medium);
            MoveBytes = sizeof(NDIS_MEDIUM);

            break;

        case OID_GEN_MAXIMUM_LOOKAHEAD:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_LOOKAHEAD)" ) );
                
            GenericULong = pAdapter->MaxRecvBufferSize;
            
            break;
            
        case OID_GEN_CURRENT_LOOKAHEAD:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CURRENT_LOOKAHEAD)" ) );
            
            GenericULong = pAdapter->MaxRecvBufferSize;
        
            break;

        case OID_GEN_MAXIMUM_FRAME_SIZE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_FRAME_SIZE)" ) );
            GenericULong = IP1394_RFC_FRAME_SIZE; //pAdapter->MaxRecvBufferSize;
            
            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_TOTAL_SIZE)" ) );
            
            GenericULong = IP1394_RFC_FRAME_SIZE; //pAdapter->MaxRecvBufferSize;
            
            break;

        case OID_GEN_TRANSMIT_BLOCK_SIZE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_TRANSMIT_BLOCK_SIZE)" ) );
            
            GenericULong = pAdapter->MaxRecvBufferSize - sizeof (NDIS1394_UNFRAGMENTED_HEADER);

            break;
            
        case OID_GEN_RECEIVE_BLOCK_SIZE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_RECEIVE_BLOCK_SIZE)" ) );
            
            GenericULong = pAdapter->MaxRecvBufferSize - sizeof (NDIS1394_UNFRAGMENTED_HEADER);
            
            break;
        
        case OID_GEN_MAXIMUM_SEND_PACKETS:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_SEND_PACKETS)" ) );
            
            GenericULong = 32;      // XXX What is our limit? From adapter?
            
            break;
        
        case OID_GEN_LINK_SPEED:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_LINK_SPEED)" ) );
            
            GenericULong = pAdapter->SpeedMbps;
            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_TRANSMIT_BUFFER_SPACE)" ) );
            
            GenericULong = pAdapter->MaxSendBufferSize;;
            break;

        case OID_GEN_RECEIVE_BUFFER_SPACE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_RECEIVE_BUFFER_SPACE)" ) );
            GenericULong = pAdapter->MaxRecvBufferSize;
            break;

        case OID_GEN_VENDOR_ID:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_VENDOR_ID)" ) );

            GenericULong = 0xFFFFFFFF;
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_VENDOR_DESCRIPTION)" ) );
            MoveSource = pnic1394DriverDescription;
            MoveBytes = strlen(pnic1394DriverDescription);

            break;

        case OID_GEN_DRIVER_VERSION:
        case OID_GEN_VENDOR_DRIVER_VERSION:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_DRIVER_VERSION)" ) );

            GenericULong = 2;

            break;

        case OID_802_3_PERMANENT_ADDRESS:
        case OID_802_3_CURRENT_ADDRESS:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_802_3_CURRENT_ADDRESS)" ) );

            NdisMoveMemory((PCHAR)GenericArray,
                        &pAdapter->MacAddressEth,
                        sizeof(MAC_ADDRESS));
                         
            MoveSource = (PVOID)(GenericArray);
            MoveBytes = sizeof(MAC_ADDRESS);


            break;

 
        case OID_802_3_MULTICAST_LIST:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_802_3_MULTICAST_LIST)" ) );

            MoveSource = (PVOID) &pAdapter->McastAddrs[0];
            MoveBytes = pAdapter->McastAddrCount * sizeof(MAC_ADDRESS);

            break;

        case OID_802_3_MAXIMUM_LIST_SIZE:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_802_3_MAXIMUM_LIST_SIZE)" ) );

            GenericULong = MCAST_LIST_SIZE;

            break;


        case OID_GEN_XMIT_OK:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_XMIT_OK)" ) );

            GenericULong = pAdapter->AdaptStats.ulXmitOk;;

            
            break;

        case OID_GEN_RCV_OK:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_RCV_OK)" ) );

            GenericULong = pAdapter->AdaptStats.ulRcvOk  ;

            
            break;
        case OID_GEN_CURRENT_PACKET_FILTER:
            TRACE( TL_V, TM_Mp, ( "QInfo(OID_GEN_CURRENT_PACKET_FILTER)" ) );

            GenericULong = pAdapter->CurPacketFilter ;
            break;
            
        case OID_GEN_XMIT_ERROR:
        case OID_GEN_RCV_ERROR:
        case OID_GEN_RCV_NO_BUFFER:
        case OID_802_3_RCV_ERROR_ALIGNMENT:
        case OID_802_3_XMIT_ONE_COLLISION:
        case OID_802_3_XMIT_MORE_COLLISIONS:

            GenericULong = 0;
            TRACE( TL_V, TM_Mp, ( "QInfo oid %x", Oid ) );

            
            break;

           
        case OID_PNP_QUERY_POWER:
            TRACE( TL_V, TM_Mp, ( "QInfo OID_PNP_QUERY_POWER %x", Oid ) );

            *BytesWritten = sizeof (NDIS_DEVICE_POWER_STATE );
            *BytesNeeded = sizeof (NDIS_DEVICE_POWER_STATE  );

            NdisStatus = NDIS_STATUS_SUCCESS;
            
            break;


        default:

            NdisStatus = NDIS_STATUS_INVALID_OID;
            break;

    }


    if (NdisStatus == NDIS_STATUS_SUCCESS) 
    {
        if (MoveBytes > BytesLeft) 
        {
            //
            // Not enough room in InformationBuffer. Punt
            //
            *BytesNeeded = MoveBytes;

            NdisStatus = NDIS_STATUS_INVALID_LENGTH;
        }
        else
        {
            //
            // Store result.
            //
            NdisMoveMemory(InfoBuffer, MoveSource, MoveBytes);

            //(*BytesWritten) += MoveBytes;
            *BytesWritten = MoveBytes;
            DUMPDW( TL_V, TM_Mp, InfoBuffer, *BytesWritten);

        }
    }


    TRACE( TL_T, TM_Init, ( "<==NicEthQueryInformation , Adapter %.8x, Oid %.8x, Status %x Bytes Written %x ",pAdapter, Oid, NdisStatus, *BytesWritten ));
    //MATCH_IRQL;
    return NdisStatus;
}




VOID
NicMpSendPackets(
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN PPNDIS_PACKET            PacketArray,
    IN UINT                     NumberOfPackets
    )
/*++

Routine Description:

    The is the SendPacket handler used by the ConnectionLess interface
    The Bridge Protocol will send packets here and this function will
    wrap the data into a new NDIS_PACKET and indicate it up on the
    Ethernet VC to the ARP module

Arguments:


Return Value:


--*/
{
    PADAPTERCB              pAdapter = (PADAPTERCB)MiniportAdapterContext;
    PETHERNET_VCCB          pEthernetVc = NULL;
    BOOLEAN                 fVcActive = FALSE;
    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    NDIS_STATUS             IndicatedStatus = NDIS_STATUS_FAILURE;

    ULONG i;

    TRACE( TL_T, TM_Init, ( "==> NicMpSendPackets , Adapter %.8x, ppPacket %x, Num %x",pAdapter, PacketArray, NumberOfPackets ));

    do
    {
    

        if (pAdapter->pEthernetVc == NULL)
        {
            break;
        }


        ADAPTER_ACQUIRE_LOCK (pAdapter);
        pEthernetVc = pAdapter->pEthernetVc;

        fVcActive = VC_ACTIVE(pEthernetVc);

        if (fVcActive  == TRUE)
        {
            for (i =0 ; i < NumberOfPackets; i++)
            {
                //
                // Reference the Vc for each packet
                //
                nicReferenceCall((PVCCB)pEthernetVc, "NicMpSendPackets");
            }
        }
        
        ADAPTER_RELEASE_LOCK (pAdapter);


        if (fVcActive)
        {
                //
                //Set resource and indicate the packet array up to ndis
                //
                for (i =0 ; i < NumberOfPackets; i++)
                {
                    PNDIS_PACKET pMyPacket = NULL, pPacket = NULL;
                    PPKT_CONTEXT        pPktContext = NULL;

                    pPacket = PacketArray[i];

                    //
                    // Now allocate a new packet
                    // 
                    nicAllocatePacket (&NdisStatus, 
                                   &pMyPacket,
                                   &pEthernetVc->PacketPool);

                    if (NdisStatus != NDIS_STATUS_SUCCESS)
                    {
                        pMyPacket = NULL;
                        break;
                    }

                    //
                    // Set the original packet as the packet context 
                    //
                    pPktContext = (PPKT_CONTEXT)&pMyPacket->MiniportReservedEx; 
                    pPktContext->EthernetSend.pOrigPacket = pPacket;    

                    IndicatedStatus = NDIS_STATUS_RESOURCES;
                    NDIS_SET_PACKET_STATUS (pMyPacket, IndicatedStatus);

                    //
                    // Chain the NdisBuffers 
                    //
                    pMyPacket->Private.Head = pPacket->Private.Head;
                    pMyPacket->Private.Tail = pPacket->Private.Tail;

                    //
                    // Dump the packet
                    //
                    {
                        nicDumpPkt (pMyPacket, "Conn Less Send ");

                        nicCheckForEthArps (pMyPacket);
                    }
                    //
                    // We are in Ndis' context so we do not need a timer
                    //

                    NdisMCoIndicateReceivePacket(pEthernetVc->Hdr.NdisVcHandle, &pMyPacket,NumberOfPackets );


                    if (IndicatedStatus == NDIS_STATUS_RESOURCES)
                    {
                        //
                        //  Return Packets work
                        //

                        
                        pPktContext = (PPKT_CONTEXT)&pMyPacket->MiniportReservedEx; 
                        ASSERT ( pPacket == pPktContext->EthernetSend.pOrigPacket );

                        //
                        // Free the locally allocated packet 
                        //
                        nicFreePacket(pMyPacket, &pEthernetVc->PacketPool);
                    }   
    
                }
                
                                    
                NdisMCoReceiveComplete(pAdapter->MiniportAdapterHandle);

        }   

            

        
    }while (FALSE); 


    //
    // Regardless of success, we need to complete the sends
    //
    
    for ( i = 0 ; i < NumberOfPackets; i++)
    {
        if (fVcActive == TRUE)
        {
            nicDereferenceCall ((PVCCB)pEthernetVc, "NicMpSendPackets" );
        }
        NdisMSendComplete ( pAdapter->MiniportAdapterHandle,
                           PacketArray[i],
                           NDIS_STATUS_SUCCESS);

    }


    TRACE( TL_T, TM_Init, ( "<== NicMpSendPackets "));

}





//----------------------------------------------------------------------------
// R E M O T E    N O D E  F U N C T I O N S       S T A R T      H E R E 
//



NTSTATUS
nicAddRemoteNode(
    IN  PVOID                   Nic1394AdapterContext,          // Nic1394 handle for the local host adapter 
    IN  PVOID                   Enum1394NodeHandle,             // Enum1394 handle for the remote node      
    IN  PDEVICE_OBJECT          RemoteNodePhysicalDeviceObject, // physical device object for the remote node
    IN  ULONG                   UniqueId0,                      // unique ID Low for the remote node
    IN  ULONG                   UniqueId1,                      // unique ID High for the remote node
    OUT PVOID *                 pNic1394NodeContext             // Nic1394 context for the remote node
    )
/*++

Routine Description:

     This function does updates all the required nic1394 data 
     structures to signal the arrival of a new remote node. 
     Inserts itself into the correct list and allocates an address range 
     for itself.
    
     The calls to AddRemoteNode and RemoveRemoteNode are serialized because
     they only happen in the when enum1394 gets a Start and Stop
    
    



Arguments:

    Explained above
    
Return Value:

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    REMOTE_NODE *pRemoteNode = NULL;
    PADAPTERCB  pAdapter = (PADAPTERCB)Nic1394AdapterContext;
    UINT64 RemoteNodeUniqueId;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    BOOLEAN fNeedToRequestResetNotification = FALSE;
    ULONG Generation = 0;
    BOOLEAN fIsOnlyNode  = FALSE;

    STORE_CURRENT_IRQL;
    

    
    RemoteNodeUniqueId = 0;

    RemoteNodeUniqueId = UniqueId0;
    RemoteNodeUniqueId = RemoteNodeUniqueId<<32;    
    RemoteNodeUniqueId = RemoteNodeUniqueId | UniqueId1 ;

    
    TRACE( TL_N, TM_Mp, ( "** nicAddRemoteNode Remote %.8x, UniqueId %I64x", RemoteNodePhysicalDeviceObject, RemoteNodeUniqueId) );

    // Initialize a PdoCb with the 1394 Pdo and insert it into the Pdo list
    //
    do
    {
        NdisStatus = nicInitializeRemoteNode(&pRemoteNode,
                                             RemoteNodePhysicalDeviceObject,
                                             RemoteNodeUniqueId);

        *pNic1394NodeContext = pRemoteNode;

        if (NdisStatus!=NDIS_STATUS_SUCCESS)
        {
            TRACE(  TL_A, TM_Mp, ( "NicMpInitializePdoCb FAILED %.8x", RemoteNodePhysicalDeviceObject) );
            break;
        }
    
        pRemoteNode->pAdapter = pAdapter;
        pRemoteNode->Enum1394NodeHandle = Enum1394NodeHandle;

        pAdapter->MediaConnectStatus = NdisMediaStateConnected;

        //
        // We need to go through the RecvFiFo List and get allocate any address ranges on this pdo as well
        //
        ADAPTER_ACQUIRE_LOCK (pAdapter);
        //
        // Increment the Refcount. This signifies that the pRemoteNode has been created and will
        // be derefed only when the nic gets a notification of removal. 
        //
    
        pRemoteNode->pAdapter = pAdapter;

        //
        // Add a reference to the adapter as the Pdo Block, now has a pointer to it
        // Will be derefed in the RemoveRemoteNode
        //
        nicReferenceAdapter (pAdapter, "nicAddRemoteNode");

        //
        // Figure out if there are no remote node in the Adapter's list. that will make this node the only remote node
        // and we will have to kickstart the BCM algorithm
        //
        fIsOnlyNode  = IsListEmpty (&pAdapter->PDOList);

        TRACE( TL_V, TM_Mp, ( "   nicAddRemoteNode: fIsOnlyNode  %x", fIsOnlyNode ) );

        //
        // Insert the PDO into the adapter's RemoteNode List
        //

        InsertTailList (&pAdapter->PDOList, &pRemoteNode->linkPdo);        

        NdisInterlockedIncrement (&pAdapter->AdaptStats.ulNumRemoteNodes);

        //
        // Increment the ref on the Pdo block as the adapter, now has a pointer to it
        // Will be derefed whereve the remote node is popped of the list 
        //
        nicReferenceRemoteNode (pRemoteNode, AddRemoteNode);

        //
        // Now set the flag that the Pdo Block is activated, and that
        // it is ready to receive Irps
        //
        REMOTE_NODE_SET_FLAG (pRemoteNode, PDO_Activated);

        

        ADAPTER_RELEASE_LOCK (pAdapter);




        {       

            NODE_ADDRESS RemoteNodeAddress;


            NdisStatus = nicGet1394AddressOfRemoteNode( pRemoteNode,
                                                        &RemoteNodeAddress,
                                                              0 );

            if (NdisStatus == NDIS_STATUS_SUCCESS)
            {
                
                TRACE( TL_V, TM_Mp, ( "   RemoteNode %x , NodeAddress %", 
                                          pRemoteNode, RemoteNodeAddress.NA_Node_Number) );
                                          
                ADAPTER_ACQUIRE_LOCK (pAdapter);
                
                pAdapter->NodeTable.RemoteNode[RemoteNodeAddress.NA_Node_Number] = pRemoteNode; 

                pRemoteNode->RemoteAddress = RemoteNodeAddress;

                ADAPTER_RELEASE_LOCK (pAdapter);

            
            }
            else
            {
                ASSERT (!" Unable to get Address from remote node");

                //
                // Do not fail the Add Node
                //

                REMOTE_NODE_SET_FLAG (pRemoteNode, PDO_NotInsertedInTable);

                NdisStatus = NDIS_STATUS_SUCCESS;
            }

        }

        //
        // Update the local host's speed values
        //
        nicUpdateLocalHostSpeed (pAdapter);

        //
        // Update the remote node's cached caps.
        //
        {
            UINT SpeedTo;
            UINT EffectiveMaxBufferSize;
            UINT MaxRec;


            // Specifying FALSE (!from cache) below causes pRemoteNode's cached caps
            // to be refreshed. Ignore return value.
            //
            (VOID) nicQueryRemoteNodeCaps (pAdapter,
                                          pRemoteNode,
                                          &SpeedTo,
                                          &EffectiveMaxBufferSize,
                                          &MaxRec
                                          );
        }

        //
        // We have received a remote node in this boot. 
        // Set the flag. No need to hold the lock
        //
        ADAPTER_SET_FLAG(pAdapter, fADAPTER_RemoteNodeInThisBoot);
    
        //
        // Kick start the BCM algorithm if this is the only node in the Adapter's list.  also need to initialize the BCR
        // if necessary. All done in this BCMAddRemoteNode function
        //
        nicBCMAddRemoteNode (pAdapter, 
                             fIsOnlyNode );

        //
        // Inform the protocols of this new node, so that
        // it can query us for a new Euid Map
        //
        nicInformProtocolsOfReset(pAdapter);

    }while (FALSE);

    
    TRACE( TL_T, TM_Mp, ("<==nicAddRemoteNode Remote %.8x, Status %.8x", RemoteNodePhysicalDeviceObject, Status));

    MATCH_IRQL;
    return NdisStatus;

}


   


        
VOID
nicDeleteLookasideList (
    IN OUT PNIC_NPAGED_LOOKASIDE_LIST pLookasideList
    )
/*++

Routine Description:

    Deletes a nic1394 Lookaside list

Arguments:

    
Return Value:

--*/
{
    TRACE( TL_T, TM_Cm, ( "==> nicDeleteLookasideList  pLookaside List %x", pLookasideList ) );

    if (pLookasideList)
    {
        ASSERT (pLookasideList->OutstandingPackets == 0);
        
        NdisDeleteNPagedLookasideList (&pLookasideList->List);
    }

    TRACE( TL_T, TM_Cm, ( "<== nicDeleteLookasideList pLookaside List %x", pLookasideList) );
    
}







NDIS_STATUS
nicFreeRemoteNode(
    IN REMOTE_NODE *pRemoteNode 
    )

/*++

Routine Description:

    Frees a Remote Node when the refcount goes to zero

Arguments:

    
Return Value:

--*/
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    
    TRACE( TL_T, TM_Mp, ( "==>nicFreeRemoteNodepRemoteNode %.8x", pRemoteNode ) );

    ASSERT (pRemoteNode->Ref.ReferenceCount == 0);

    nicFreeNicSpinLock  (&pRemoteNode->ReassemblyLock);

    pRemoteNode->pPdo = NULL;

    pRemoteNode->ulTag = MTAG_FREED;

    FREE_NONPAGED (pRemoteNode);
    
    TRACE( TL_T, TM_Mp, ( "<==nicFreeRemoteNode" ) );

    return NdisStatus;
}






VOID
nicInitializeLookasideList(
    IN OUT PNIC_NPAGED_LOOKASIDE_LIST pLookasideList,
    ULONG Size,
    ULONG Tag,
    USHORT Depth
    )
/*++

Routine Description:

  Allocates and initializes a nic Lookaside list

Arguments:


Return Value:


--*/
{
    TRACE( TL_T, TM_Cm, ( "==> nicInitializeLookasideList pLookaside List %x, size %x, Tag %x, Depth %x, ", 
                             pLookasideList, Size, Tag, Depth) );
                             
    NdisInitializeNPagedLookasideList( &pLookasideList->List,
                                       NULL,                        //Allocate 
                                       NULL,                            // Free
                                       0,                           // Flags
                                       Size,
                                       MTAG_CBUF,
                                       Depth );                             // Depth

    pLookasideList->Size =  Size;


    TRACE( TL_T, TM_Cm, ( "<== nicInitializeLookasideList " ) );
}   
                                  






NDIS_STATUS
nicInitializeRemoteNode(
    OUT REMOTE_NODE **ppRemoteNode,
    IN   PDEVICE_OBJECT p1394DeviceObject,
    IN   UINT64 UniqueId 
    )

/*++

Routine Description:

    This function allocates and initializes a control block for the Device Object
    that is being passed . Also sets the initalize flag and, intialized the Vc List 
    Copies the unique id,  Initializes the reassembly structures ( lock and list)


Arguments:

    pRemoteNode - Pointer to remote node that was allocated
    pDevice Object for the remote node
    Unique Id - UID of the  remote node
    
Return Value:
    Resources - if the Allocation failed
    Success - otherwise
--*/

{

    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    PREMOTE_NODE pRemoteNode = NULL;

    TRACE( TL_T, TM_Mp, ( "==>NicInitializeRemoteNode PDO %.8x UniqueId %I64x", p1394DeviceObject, UniqueId) );

    do
    {
        pRemoteNode = ALLOC_NONPAGED( sizeof(REMOTE_NODE), MTAG_REMOTE_NODE);
        
        if (pRemoteNode == NULL)
        {

            TRACE( TL_A, TM_Mp, ( "Memory Allocation for Pdo Block FAILED" ) );
            *ppRemoteNode = NULL;
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Zero out the strcuture
        //
        NdisZeroMemory ( pRemoteNode , sizeof(REMOTE_NODE) ); 

        //
        // Set up the tag
        //
        pRemoteNode ->ulTag = MTAG_REMOTE_NODE;

        //
        // Set up the  remote device's PDO
        //
        pRemoteNode ->pPdo = p1394DeviceObject;

        //
        // Set up the Unique ID
        //
        pRemoteNode ->UniqueId = UniqueId;

        //
        // Set up a Fake Mac Address for the Unique ID
        //
        nicGetMacAddressFromEuid(&UniqueId, &pRemoteNode->ENetAddress) ;
        //
        // Initialize the VC that are open on this Remote Node
        //
        InitializeListHead ( &(pRemoteNode->VcList));

        //
        // Initialize the ref count
        //
        nicInitializeRef (&pRemoteNode->Ref);

        //
        // allocate the spin lock to control reassembly
        //
        nicInitializeNicSpinLock (&(pRemoteNode ->ReassemblyLock));
        
        //
        //  list for all reassemblies happenning on the remote node
        //
        InitializeListHead (&pRemoteNode->ReassemblyList);

        *ppRemoteNode = pRemoteNode ;
                                   
    } while (FALSE);
     
    TRACE( TL_T, TM_Mp, ( "<==NicInitializeRemoteNode, Status %.8x, pRemoteNode %.8x", NdisStatus, *ppRemoteNode) );

    return NdisStatus;
}


VOID
nicNoRemoteNodesLeft (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:

    Called from the RemoveRemote Node codepath
    This means that the last node has gone away.

    Indicate a Media Disconnect.


Arguments:

    
Return Value:

--*/
{
    BOOLEAN fBCMInProgress;
    ADDRESS_RANGE_CONTEXT BCRAddressRange;
    
    TRACE( TL_T, TM_Bcm, ( "==>nicNoRemoteNodesLeft  pAdapter %x  ",pAdapter ) );

    
    pAdapter->MediaConnectStatus = NdisMediaStateDisconnected;

    if (ADAPTER_TEST_FLAG( pAdapter, fADAPTER_Halting) == FALSE)
    {
        nicMIndicateStatus ( pAdapter,NDIS_STATUS_MEDIA_DISCONNECT, NULL,0);  
    }




    TRACE( TL_T, TM_Bcm, ( "<==nicNoRemoteNodesLeft  pAdapter %x  ",pAdapter ) );

}






VOID
nicReallocateChannels (
    IN PNDIS_WORK_ITEM pWorkItem,   
    IN PVOID Context 
    )
/*++

Routine Description:

       Walk through all the channel VCs and reallocate all 
       the previously allocated channels except the BCM channel . 
       The BCM will reallocate this 
    
       Tell the protocol that the 1394 bus has been reset. after all the channels have 
       been allocated

Arguments:

    
Return Value:

--*/
{
    ULONGLONG           ChannelsAllocatedByLocalHost = 0;
    ULONG               Channel = 0;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PADAPTERCB          pAdapter = (PADAPTERCB) Context; 
    ULONGLONG           One = 1;


    TRACE( TL_T, TM_Mp, ( "==>nicReallocateChannels pAdpater %x", pAdapter) );


    
    TRACE( TL_V, TM_Mp, ("  nicReallocateChannels ChannelsAllocatedByLocalHost %I64x ", ChannelsAllocatedByLocalHost) );

    Channel =0;

    while (Channel < NIC1394_MAX_NUMBER_CHANNELS )
    {
        //
        // Does the channel 'i' need to be allocated
        //
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        ChannelsAllocatedByLocalHost  = pAdapter->ChannelsAllocatedByLocalHost ;

        ADAPTER_RELEASE_LOCK (pAdapter);
        
        if ( (( g_ullOne<<Channel ) & ChannelsAllocatedByLocalHost) == TRUE) 
        {
            if (Channel == BROADCAST_CHANNEL)
            {
                //
                // The broadcast channel will  be allocated by the BCM. skip it.
                //
                continue;
            }
            NdisStatus = nicAllocateChannel (pAdapter,
                                             Channel,
                                             NULL);

            //
            // If allocation fails ... Have not implemented recovery yet.
            //
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                ASSERT (NdisStatus == NDIS_STATUS_SUCCESS)
            }
        }
    
        Channel ++;
    }


    //
    // Now that the channels are reallocated, inform the protocols of the reset
    //

    nicInformProtocolsOfReset(pAdapter);
    
    
    //
    // Dereference the ref that was added prior to scheduling this workitem
    //
    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);

    nicDereferenceAdapter(pAdapter, "nicResetReallocateChannels ");


    FREE_NONPAGED(pWorkItem);
    
    TRACE( TL_T, TM_Mp, ( "<==nicReallocateChannels "  ) );


}






NDIS_STATUS
nicRemoteNodeRemoveVcCleanUp(
    IN REMOTE_NODE  *pRemoteNode
    )

/*++

Routine Description:

     This function walks through the Pdo's Vc list annd closes 
     the calls on each of them. These are SendFIFO VCs. 
     Channel VC's will not be closed when the remote node is removed.
     This is typically called from a remove remote node function


Arguments:

    PdoCb Pdo Control block that is getting removed

    
Return Value:

--*/
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PVCCB pVc = NULL;
    PLIST_ENTRY pVcList = NULL;
    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Mp, ( "==>nicRemoteNodeRemoveVcCleanUp pRemoteNode %.8x", pRemoteNode ) );

    pVcList = ListNext (&pRemoteNode->VcList);

    while (pVcList != &pRemoteNode->VcList)
    {

        pVc = (VCCB*) CONTAINING_RECORD (pVcList, VCHDR, SinglePdoVcLink);

        //
        // move to the next Vc in the list
        //
        pVcList = ListNext (pVcList);


        TRACE( TL_V, TM_Mp, ( "   nicRemoteNodeRemoveVcCleanUp VcType %x",pVc->Hdr.VcType  ) );

        
        switch(pVc->Hdr.VcType)
        {
            case NIC1394_SendRecvChannel:
            case NIC1394_RecvChannel:
            case NIC1394_SendChannel:
            {
                PCHANNEL_VCCB pChannelVc = (PCHANNEL_VCCB)pVc;
                PREMOTE_NODE pNewChannelNode = NULL;
                //
                // Nothing to do here now
                //
                break;                                      
            }

            case NIC1394_SendFIFO:
            {   
                //
                // We know that it is a Send FIFO and the call needs to be closed
                //
                VC_SET_FLAG (pVc, VCBF_VcDispatchedCloseCall);


                //
                // This is to guarantee that we have the Vc Structure around at the end of the call
                //
                
                nicReferenceVc (pVc);

                REMOTE_NODE_RELEASE_LOCK (pRemoteNode);

                TRACE( TL_V, TM_Mp, ( "Dispatching a close call for Vc%.8x ",pVc ) );

                
                NdisMCmDispatchIncomingCloseCall (NDIS_STATUS_SUCCESS,
                                              pVc->Hdr.NdisVcHandle,
                                              NULL,
                                              0 );
                                               
                REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);

                //
                // Deref the ref made above.
                //
                nicDereferenceVc (pVc);

                break;
            }

            default:
            {   
                //
                // There should be no other VC types here
                //
                
                TRACE( TL_A, TM_Mp, ( "  Invalid VC  %x Type nicRemoteNodeRemoveVcCleanUp ", pVc ) );
                
                ASSERT (0);

            }
                    
        }


    }


    MATCH_IRQL;
    TRACE( TL_T, TM_Mp, ( "<==nicRemoteNodeRemoveVcCleanUp " ) );

    
    return NDIS_STATUS_SUCCESS;

}








NTSTATUS
nicRemoveRemoteNode(
    IN  PVOID                   Nic1394NodeContext      // Nic1394 context for the remote node
    )
/*++

Routine Description:

     This function does all the hard work when the nic gets notification
     of a remote node going away.
     Closes all calls on the Pdo ,
     Removes the Remote Node from the adapter's listPdo
     frees all the reassemblies on this node
     and then waits for the refcount to go to zero
    
     The calls to AddRemoteNode and RemoveRemoteNode are serialized because
     they only happen in the when enum1394 gets a Start and Stop
    


Arguments:

    
Return Value:

--*/    
{
    NDIS_STATUS     NdisStatus = NDIS_STATUS_FAILURE;
    NTSTATUS        Status = STATUS_SUCCESS;
    PREMOTE_NODE    pRemoteNode = (REMOTE_NODE *)Nic1394NodeContext;
    PADAPTERCB      pAdapter = pRemoteNode->pAdapter;
    PLIST_ENTRY     pVcListEntry = NULL;
    PVCCB           pVc = NULL;
    BOOLEAN         FreeAddressRange = TRUE;
    BOOLEAN         fIsPdoListEmpty = FALSE;
    LIST_ENTRY      ReassemblyList;

    STORE_CURRENT_IRQL;


    
    TRACE( TL_T, TM_Mp, ( "  ** nicRemoveRemoteNode Node Context %x , Pdo  %x",Nic1394NodeContext, pRemoteNode->pPdo    ) );

    do 
    {
        pAdapter->pLastRemoteNode = pRemoteNode;

        REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);

        //
        // We should tell everyone that the Pdo is being removed. However keep the node active      
        // because there are Vc's which might need to submit Irps
        //
        REMOTE_NODE_SET_FLAG (pRemoteNode, PDO_Removed);

        //
        // Dispatch Close call requests for active calls on this Pdo. 
        // However, keep the VCs in the pdocb's list
        // The NicCmCloseCall is the only function that removes Pdo's from the list
        // Will need to free the address range for any recv Vcs seperately
        //
        NdisStatus = nicRemoteNodeRemoveVcCleanUp (pRemoteNode);



        //
        // Remove the remote node from the RemoteNode Table
        //
        //
        nicRemoveRemoteNodeFromNodeTable(&pAdapter->NodeTable,pRemoteNode);

        //
        // Free All reassembly operations on this remopte node
        // 
        nicFreeReassembliesOnRemoteNode (pRemoteNode, &ReassemblyList);
        
        //
        // Dereference the ref that was added when the Pdo block was inserted in the Adapter's list
        // The actual removal will take place later. We still have close calls to be completed and they
        // will need the PdoCb. So it remains in the adapter's queue
        //
        nicDereferenceRemoteNode (pRemoteNode, RemoveRemoteNode);
        
        //
        // Need to Deref the Reference made in NicInitializeRemoteNode function
        //
        nicDereferenceRemoteNode (pRemoteNode, RemoveRemoteNode);

        //
        // Dequeue the remote node here
        //

        nicRemoveEntryList (&pRemoteNode->linkPdo);

        NdisInterlockedDecrement (&pAdapter->AdaptStats.ulNumRemoteNodes);

        //
        // If this was the last remote node, then some special cleaning will be done
        //
        fIsPdoListEmpty = IsListEmpty (&pAdapter->PDOList);
    
        TRACE( TL_T, TM_Mp, ( "  nicRemoveRemoteNode fIsOnlyNode %x ",fIsPdoListEmpty ) );

        
        REMOTE_NODE_RELEASE_LOCK (pRemoteNode);
        
        //
        // Now, we wait forever for all the reference to go away
        //
        TRACE( TL_V, TM_Mp, ( "About ot Wait RemoteNode Ref's to go to zero" ) );
        
        
        NdisWaitEvent (&pRemoteNode->Ref.RefZeroEvent, WAIT_INFINITE);

        TRACE( TL_V, TM_Mp, ( "Wait Succeeded Ref == 0, pRemoteNode %.8x, RefCount %.8x ", 
                              pRemoteNode, pRemoteNode->Ref.ReferenceCount) );
            
        //
        // If this was the last node, and the remote node list is empty, we need to clean up the BCR
        //
        if (fIsPdoListEmpty == TRUE)
        {
            nicNoRemoteNodesLeft (pAdapter);
        }

        //
        // Delete the reassemblies that belong to this remote node and free them
        //
        if (IsListEmpty (&ReassemblyList) == FALSE)
        {
            nicAbortReassemblyList (&ReassemblyList);
        }

        nicFreeRemoteNode(pRemoteNode);

        //
        // Now update the speed on the adapter
        //

        nicUpdateLocalHostSpeed(pAdapter);

        //
        // Inform the protocols of the node removal, so that
        // it can query us for a new Euid Map
        //
        nicInformProtocolsOfReset(pAdapter);


        //
        // Careful this could cause the adapter refcounts to go to zero
        //
        nicDereferenceAdapter(pAdapter, "nicRemoveRemoteNode ");


    } while (FALSE);

    
    TRACE( TL_T, TM_Mp, ( "<== nicRemoveRemoteNode Status %.8x ", 
                               NdisStatus ) );

    MATCH_IRQL;
    

    return NDIS_STATUS_SUCCESS;

}



VOID
nicResetNotificationCallback (                
    IN PVOID pContext               
    )
/*++

Routine Description:

      This routine will be called whenever  the bus is reset. 
      It will be called at DISPATCH Level
     
 

Arguments:

     Context : a Remote Node

    
Return Value:

--*/
{
    PADAPTERCB pAdapter = (PADAPTERCB) pContext;
    BOOLEAN fNeedToQueueBCMWorkItem = FALSE; 
    
    TRACE( TL_T, TM_Mp, ( "==>nicResetNotificationCallback Context %.8x ", pContext ) );

    NdisInterlockedIncrement (&pAdapter->AdaptStats.ulNumResetCallbacks);       
    pAdapter->AdaptStats.ulResetTime = nicGetSystemTime();

    
    TRACE( TL_I, TM_Mp, ( "    BUS RESET Callback Context %x, Old Gen %x ", pContext , pAdapter->Generation) );

    //
    // Restart the BCM
    //
            
    nicResetRestartBCM (pAdapter);
    //
    // reallocate all channels that were opened by this node
    //
    nicResetReallocateChannels( pAdapter);      

    
    //
    // Invalidate all pending reassemblies
    //
    nicFreeAllPendingReassemblyStructures(pAdapter);


    TRACE( TL_T, TM_Mp, ( "<==nicResetNotificationCallback " ) );


}



VOID 
nicResetReallocateChannels (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:


   Fires off a workitem to reallocate channels. 
   ONLY To be called from a reset.
   Once all the channels have been re-allocated, 
   it causes an indication to the protocols, 


Arguments:

    
Return Value:

--*/
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS_WORK_ITEM pResetChannelWorkItem;
    
    TRACE( TL_T, TM_Mp, ( "==>nicResetReallocateChannels  " ) );

    //
    // reference the adapter as it is going to passed to a workiter.
    // decremented in the workitem
    //
    nicReferenceAdapter(pAdapter, "nicResetReallocateChannels");

    do
    {
    
        pResetChannelWorkItem = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM); 

                    
        if (pResetChannelWorkItem== NULL)
        {
            TRACE( TL_A, TM_Cm, ( "nicResetReallocateChannels : Local Alloc failed for WorkItem" ) );
    
            NdisStatus = NDIS_STATUS_RESOURCES;
    
            break;
        }
        else
        {   
            //
            // From here on, this function cannot fail.
            //
            NdisStatus = NDIS_STATUS_SUCCESS;
        }

                             
            
        NdisInitializeWorkItem ( pResetChannelWorkItem, 
                                 (NDIS_PROC) nicReallocateChannels ,
                                 (PVOID) pAdapter);

        TRACE( TL_V, TM_Cm, ( "Scheduling Channels WorkItem" ) );
                                
        NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);
            
        NdisScheduleWorkItem (pResetChannelWorkItem);


    } while (FALSE);


    TRACE( TL_T, TM_Mp, ( "<==nicResetReallocateChannels %x  ", NdisStatus ) );

}




VOID
nicResetRestartBCM (
    IN PADAPTERCB pAdapter
    )

/*++

Routine Description:

    Clean up the adapter's data structure and restart the BCM algorithm


Arguments:

    
Return Value:

--*/
{

    TRACE( TL_T, TM_Mp, ( "==>nicResetRestartBCM  pAdpater %x", pAdapter ) );

    //
    // Now set up the data structures so we can restart the BCM for this generation
    //
    ADAPTER_ACQUIRE_LOCK(pAdapter);

    pAdapter->BCRData.LocalHostBCRBigEndian = BCR_IMPLEMENTED_BIG_ENDIAN;

    pAdapter->BCRData.IRM_BCR.NC_One = 1;
    pAdapter->BCRData.IRM_BCR.NC_Valid  = 0;
    pAdapter->BCRData.IRM_BCR.NC_Channel  = 0x3f; 

    //
    // Clear the flags that are only valid through a single run of the BCM algorithm
    //
    BCR_CLEAR_FLAG (pAdapter, BCR_BCMFailed | BCR_LocalHostBCRUpdated | BCR_ChannelAllocated | BCR_LocalHostIsIRM);
    //
    // This will inform any BCM algorithm that a new reset happened
    //
    ADAPTER_SET_FLAG (pAdapter, fADAPTER_InvalidGenerationCount);

    //
    // We might have a thread waiting in FindIrmAmongRemoteNodes. .. Let it go and make it
    // abort the BCM
    //
    
    pAdapter->BCRData.BCRWaitForNewRemoteNode.EventCode = nic1394EventCode_BusReset;

    NdisSetEvent (&pAdapter->BCRData.BCRWaitForNewRemoteNode.NdisEvent);
    
    ADAPTER_RELEASE_LOCK(pAdapter);

    //
    // Now reschedule a work item to do the BCM algorithm
    //
    TRACE( TL_A, TM_Bcm , ("Reset - scheduling the BCM" ) );
    nicScheduleBCMWorkItem(pAdapter);

    TRACE( TL_T, TM_Mp, ( "<==nicResetRestartBCM  " ) );

}







VOID
nicBusResetWorkItem(
    NDIS_WORK_ITEM* pResetWorkItem,     
    IN PVOID Context 
    )
/*++

Routine Description:

    Calls nicBusReset and exits


Arguments:

    
Return Value:

--*/
{


    PADAPTERCB pAdapter= (PADAPTERCB) Context; 

    TRACE( TL_T, TM_Mp, ( "==>nicBusResetWorkItem " ) );
    

    nicBusReset (pAdapter,
                BUS_RESET_FLAGS_FORCE_ROOT );


    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);

    nicDereferenceAdapter(pAdapter, "nicBusResetWorkItem");
    
    TRACE( TL_T, TM_Mp, ( "<==nicBusResetWorkItem" ) );


    FREE_NONPAGED (pResetWorkItem);


}
    




VOID
nicIssueBusReset (
    PADAPTERCB pAdapter,
    ULONG Flags
    )
/*++

Routine Description:

    Picks up a PDO and issues a bus reset on that PDO
    As this can come down through an NdisRequest, it can be at IRQL <=DISPATCH_LEVEL

Arguments:

    
Return Value:

--*/
{
    PREMOTE_NODE pRemoteNode = NULL;

    TRACE( TL_T, TM_Mp, ( "==> nicIssueBusReset %x ",Flags ) );

    if (PASSIVE_LEVEL == KeGetCurrentIrql () )
    {
        nicBusReset (pAdapter, Flags);          

    }
    else
    {
        //
        // Dereferenced in the workitem
        //
        
        nicReferenceAdapter (pAdapter, "nicIssueBusReset ");

        do
        {
            PNDIS_WORK_ITEM pReset;
            NDIS_STATUS NdisStatus;
            pReset = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM); 

        
            if (pReset == NULL)
            {
                TRACE( TL_A, TM_Cm, ( "Local Alloc failed for WorkItem" ) );
        
                break;
            }

                
        
            NdisInitializeWorkItem ( pReset, 
                                     (NDIS_PROC)nicBusResetWorkItem,
                                      (PVOID)pAdapter);

            TRACE( TL_A, TM_Cm, ( "Setting WorkItem" ) );
                                                    
            NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);
            
            NdisScheduleWorkItem (pReset);

        }while (FALSE);


    }

    TRACE( TL_T, TM_Mp, ( "<== nicIssueBusReset " ) );


}







VOID
nicUpdateLocalHostSpeed (
    IN PADAPTERCB pAdapter
    )

/*++

Routine Description:
  Updates the speed for the local host and updates the payload for 
  all ChannelVCs 

  This also updates the SCode that goes to the ARP module..
  The SCode will never be updated unless this function is called
  via the BCM algorithm

  
Arguments:


Return Value:


--*/


{

    NDIS_STATUS                 NdisStatus = NDIS_STATUS_FAILURE;
    PREMOTE_NODE                pRemoteNode = NULL;
    PDEVICE_OBJECT              PdoTable[MAX_LOCAL_NODES];
    ULONG                       Num = 0;
    ULONG                       SpeedMbps = 10000000;
    ULONG                       PrevSpeed = pAdapter->Speed;
    ULONG                       Speed =0;
    ULONG                       MaxRecvBufferSize = 0;
    ULONG                       MaxSendBufferSize = 0;
    ULONG                       SCode = 0;
    
    TRACE( TL_T, TM_Bcm, ( "==> nicUpdateLocalHostSpeed " ) );


    do
    {
        PLIST_ENTRY     pRemoteNodeList;
        NODE_ADDRESS    RemoteNodeAddress;
        NODE_TABLE      RefNodeTable;
        ULONG           NumRemoteNodes = 0;
        
        NdisZeroMemory (&RefNodeTable, sizeof(RefNodeTable));

        NumRemoteNodes = 0;

        
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        pRemoteNodeList = ListNext (&pAdapter->PDOList);

        //
        // Walk through the entire list and make a copy of the current list.
        // Reference each remote node on the list. 
        // The lock will ensure that the list is valid and that no removed remote nodes
        // get into our RefNodeTable list.
        //
        
        while (pRemoteNodeList != &pAdapter->PDOList)
        {
            pRemoteNode = CONTAINING_RECORD (pRemoteNodeList, REMOTE_NODE, linkPdo);

            //
            // Reference the remote node. This guarantees that the remote node will
            // remain valid and in the list until it is dereferenced (deref happens below)
            //
            nicReferenceRemoteNode (pRemoteNode, UpdateLocalHostSpeed);
            RefNodeTable.RemoteNode[NumRemoteNodes] = pRemoteNode;
            ASSERT (REMOTE_NODE_TEST_FLAG (pRemoteNode,PDO_Removed) == FALSE);

            //
            // Increment the Cursors and go to the next RemoteNode
            //
            pRemoteNodeList = ListNext (pRemoteNodeList);
            NumRemoteNodes++;

            //
            // We only do 63 nodes .
            //
            if (NumRemoteNodes > (NIC1394_MAX_NICINFO_NODES - 1))
            {
                break;
            }

        }  //while (pRemoteNodeList != &pAdapter->PDOList)

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Now Create the Array of Remote Node PDOs that will be send down into the 
        // bus driver
        //
        NdisZeroMemory (&PdoTable[0], sizeof (PdoTable) );

        Num = 0;
        while (Num < NumRemoteNodes)
        {

            PdoTable[Num] = RefNodeTable.RemoteNode[Num]->pPdo;

            Num++;

        }

        //
        // Now send the Array down to the Bus Driver and get the speed of 
        // the 1394 network.
        //
        
        NdisStatus = nicGetMaxSpeedBetweenDevices( pAdapter,
                                                    Num,
                                                    PdoTable,
                                                    &Speed);


        //
        // Now Dereference all the Remote Nodes that were referenced above
        //
        ADAPTER_ACQUIRE_LOCK(pAdapter)
        
        //
        // We're done, Now Dereference the Remote Node References Made above
        //
        {
            USHORT RefIndex=0;
            PREMOTE_NODE pCurrRemoteNode;

            //
            // Initialize the structures
            //
            pCurrRemoteNode = RefNodeTable.RemoteNode[0];
            RefIndex =0;
            
            while (pCurrRemoteNode != NULL)
            {
         
                nicDereferenceRemoteNode(pCurrRemoteNode, UpdateRemoteNodeTable);
                RefIndex++;
                pCurrRemoteNode = RefNodeTable.RemoteNode[RefIndex];
            }

        }


        ADAPTER_RELEASE_LOCK (pAdapter);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // By looking at the speed constants 1 -> 100Mbps
        //
        SpeedMbps = Speed*1000000;

        //
        // update the scode -- default 400. 
        // As 400+ hardware is prototype from WinXP, we default to 400 for now
        //
        SCode = SCODE_400_RATE;

        if (Speed > SPEED_FLAGS_400)
        {
            Speed = SPEED_FLAGS_400;
        }
       
        switch (Speed)
        {
            case SPEED_FLAGS_400 :
            {
                SCode = SCODE_400_RATE ;
                MaxRecvBufferSize = ISOCH_PAYLOAD_400_RATE;
                MaxSendBufferSize = ASYNC_PAYLOAD_400_RATE;
                break;
            }
            case SPEED_FLAGS_100 :
            {
                SCode = SCODE_100_RATE;
                MaxRecvBufferSize = ISOCH_PAYLOAD_100_RATE;
                MaxSendBufferSize = ASYNC_PAYLOAD_100_RATE;

                break;
            }
            case SPEED_FLAGS_200 :
            {
                SCode = SCODE_200_RATE;
                MaxRecvBufferSize = ISOCH_PAYLOAD_200_RATE;
                MaxSendBufferSize = ASYNC_PAYLOAD_200_RATE;

                break;
            }
            
            default:
            {
                SCode = SCODE_400_RATE ;
                MaxRecvBufferSize = ISOCH_PAYLOAD_400_RATE;
                MaxSendBufferSize = ASYNC_PAYLOAD_400_RATE;
                break;
            }


        }
        
        ADAPTER_ACQUIRE_LOCK(pAdapter);

        pAdapter->Speed = Speed;
        pAdapter->SpeedMbps = SpeedMbps;
        pAdapter->SCode = SCode;
        pAdapter->MaxRecvBufferSize = MaxRecvBufferSize;
        pAdapter->MaxSendBufferSize = MaxSendBufferSize;

        ADAPTER_RELEASE_LOCK (pAdapter);
        
        TRACE( TL_V, TM_Mp, ( "  nicUpdateLocalHostSpeed Speed returned %d",SpeedMbps  ) );


        //
        // Now update the speed value in all the channel VC's as they are dependent on this parameter
        // 
        
        if (Speed == PrevSpeed || 
            Speed > SPEED_FLAGS_1600 )

        {
            //
            // either the speed has not changed or it has invalid value, break out
            //
            TRACE (TL_V, TM_Init, ("Will not update - Speed %x, Prev Speed %x", Speed, PrevSpeed) );
            break;
        }

        //
        // The speed  and the payload have changed. Update all the channel Vc's
        // and Recv FIFOVc's payload
        //


        nicUpdateSpeedInAllVCs (pAdapter,
                             Speed
                             );


        
    } while (FALSE);



    TRACE( TL_T, TM_Mp, ( "<== nicUpdateLocalHostSpeed SpeedCode %x, Num %x" , pAdapter->Speed, Num) );


}

VOID
nicUpdateSpeedInAllVCs (
    PADAPTERCB pAdapter,
    ULONG Speed
    )
/*++

Routine Description:

 This routine updates the speed flag in all Channel Vcs
 It assumes that the new speed is different from the old speed

Arguments:

 pAdapter- Local Adapter intance    
 Speed - new speed
Return Value:


--*/
{

    PAFCB pAfcb = NULL;
    PVCCB pVc = NULL;
    PLIST_ENTRY pAfEntry = NULL;
    PLIST_ENTRY pVcEntry = NULL;
    ULONG MaxPayload = 0;
    ULONG                       SCode = 0;

    TRACE( TL_T, TM_Mp, ( "==> nicUpdateSpeedInAllVCs ") );

    
    switch (Speed)
    {
        case SPEED_FLAGS_100  : 
        {
            SCode = SCODE_100_RATE;
            MaxPayload  = ISOCH_PAYLOAD_100_RATE;
            break;
        }
        case SPEED_FLAGS_200 :
        {
            SCode = SCODE_200_RATE;
            MaxPayload  = ISOCH_PAYLOAD_200_RATE ;
            break;
        }
            
        case SPEED_FLAGS_400 :
        {
            SCode = SCODE_400_RATE;
            MaxPayload  = ISOCH_PAYLOAD_400_RATE;
            break;
        }

        case SPEED_FLAGS_800 :
        {
            SCode = SCODE_800_RATE;
            MaxPayload  = ISOCH_PAYLOAD_400_RATE;
            break;
        }

        case SPEED_FLAGS_1600 :
        {
            SCode = SCODE_1600_RATE;
            MaxPayload  = ISOCH_PAYLOAD_400_RATE;
            break;
        }

        case SPEED_FLAGS_3200 :
        {
            SCode = SCODE_1600_RATE;
            MaxPayload  = ISOCH_PAYLOAD_400_RATE;
            break;
        }

        default :
        {
            ASSERT (Speed <= SPEED_FLAGS_3200 && Speed != 0 );
            
            break;
        }

    }

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    pAfEntry = ListNext (&pAdapter->AFList);

    //
    // Walk through all the Vc and set the value on the channelVcs
    //
    while (pAfEntry != &pAdapter->AFList)
    {

        pAfcb = CONTAINING_RECORD (pAfEntry, AFCB, linkAFCB);

        pAfEntry = ListNext (pAfEntry);

        pVcEntry = ListNext (&pAfcb->AFVCList);

        //
        // Now walk through the VCs on the Af
        //
        while (pVcEntry != &pAfcb->AFVCList)
        {
            pVc = (PVCCB) CONTAINING_RECORD  (pVcEntry, VCHDR, linkAFVcs );

            pVcEntry = ListNext ( pVcEntry );

            //
            // If it is a channel Send Vc update the Speed and Payload
            //
            if (pVc->Hdr.VcType == NIC1394_SendRecvChannel || pVc->Hdr.VcType == NIC1394_SendChannel)
            {
                PCHANNEL_VCCB pChannelVc = (PCHANNEL_VCCB)pVc;

                pChannelVc->Speed = Speed;
                pVc->Hdr.MaxPayload  = MaxPayload;
            }

           

        }  //while (pVcEntry != &pAfcb->AFVCList)



    } //while (pAfEntry != &pAdapter->AFList)


    pAdapter->SCode = SCode;
    
    ADAPTER_RELEASE_LOCK (pAdapter);


    TRACE( TL_T, TM_Mp, ( "<== nicUpdateSpeedInAllVCs ") );

}




VOID 
nicInitializeAllEvents (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:

    Self Explanatory

Arguments:

    
Return Value:

--*/
    // Function Description:
    //   Initialize all the events in the adapter block
    //
    // Arguments
    //   pAdapter - The local host in question. 
    //
    // Return Value:
    // None 
    
{

    TRACE( TL_T, TM_Mp, ( "==> nicInitializeAllEvents " ) );

    NdisInitializeEvent (&pAdapter->RecvFIFOEvent);

    NdisInitializeEvent (&pAdapter->WaitForRemoteNode.NdisEvent);
    pAdapter->WaitForRemoteNode.EventCode = Nic1394EventCode_InvalidEventCode;

    NdisInitializeEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent); 
    pAdapter->BCRData.MakeCallWaitEvent.EventCode = Nic1394EventCode_InvalidEventCode;

    NdisInitializeEvent (&pAdapter->BCRData.BCRWaitForNewRemoteNode.NdisEvent);
    pAdapter->BCRData.BCRWaitForNewRemoteNode.EventCode = Nic1394EventCode_InvalidEventCode;


    NdisInitializeEvent (&pAdapter->BCRData.BCRFreeAddressRange.NdisEvent);
    pAdapter->BCRData.BCRFreeAddressRange.EventCode = Nic1394EventCode_InvalidEventCode;

    TRACE( TL_T, TM_Mp, ( "<== nicInitializeAllEvents " ) );


}




VOID
nicInitializeAdapterLookasideLists (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:

    Initialize all the lookaside lists in the adapter block


Arguments:

    
Return Value:

--*/    
{
    USHORT DefaultDepth = 15;
    
    TRACE( TL_T, TM_Mp, ( "==> nicInitializeAdapterLookasideLists pAdpater %x ", pAdapter ) );

    nicInitializeLookasideList ( &pAdapter->SendLookasideList100,
                                sizeof (PAYLOAD_100_LOOKASIDE_BUFFER),
                                MTAG_CBUF,
                                DefaultDepth );                                

    pAdapter->SendLookasideList100.MaxSendSize = PAYLOAD_100;
    TRACE( TL_V, TM_Mp, ( "  SendLookasideList100 Payload %x", PAYLOAD_100) );
    
    nicInitializeLookasideList ( &pAdapter->SendLookasideList2K,
                                 sizeof (PAYLOAD_2K_LOOKASIDE_BUFFER), 
                                 MTAG_CBUF,
                                 DefaultDepth );

    pAdapter->SendLookasideList2K.MaxSendSize = PAYLOAD_2K;
    TRACE( TL_V, TM_Mp, ( "  SendLookasideList2K Payload %x", PAYLOAD_2K) );
    

    TRACE( TL_T, TM_Mp, ( "<== nicInitializeAdapterLookasideLists  " ) );

}





VOID
nicDeleteAdapterLookasideLists (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:

Delete all the lookaside lists in the adapter block
    
Arguments:

    
Return Value:

--*/
{
    TRACE( TL_T, TM_Mp, ( "==> nicDeleteAdapterLookasideLists pAdapter %x ", pAdapter  ) );

    TRACE( TL_T, TM_Mp, ( "  Delete NonFragmentationLookasideList %x ", &pAdapter->SendLookasideList2K) );

    nicDeleteLookasideList (&pAdapter->SendLookasideList2K);

    TRACE( TL_T, TM_Mp, ( "  Delete FragmentationLookasideList %x ", &pAdapter->SendLookasideList100) );

    nicDeleteLookasideList (&pAdapter->SendLookasideList100);

    TRACE( TL_T, TM_Mp, ( "<== nicDeleteAdapterLookasideLists  " ) );

}







VOID
ReassemblyTimerFunction (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )
/*++

Routine Description:

    Walk through all the pending reassembly operations and 
    take out the ones that need to be freed (Have been untouched
    since the timer last fired)

    Append the ToBeFreed reassemblies into a seperate linked list
    and free them after releasing the spin locks

    If the there are any pending reassemblies then the timer requeues 
    itself



Arguments:

    
Return Value:

--*/
{
    PREMOTE_NODE pRemoteNode = NULL;
    PLIST_ENTRY pRemoteNodeList = NULL;
    PLIST_ENTRY pReassemblyList = NULL;
    LIST_ENTRY ToBeFreedList;
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly = NULL;
    PADAPTERCB pAdapter = (PADAPTERCB) FunctionContext;
    ULONG RefValue = 0;
    STORE_CURRENT_IRQL;
    

    ( TL_T, TM_Mp, ( "==> ReassemblyTimerFunction pAdapter %x", pAdapter ) );

    InitializeListHead(&ToBeFreedList);

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    pRemoteNodeList = ListNext (&pAdapter->PDOList);
    pAdapter->Reassembly.PktsInQueue =0;        

    //
    // Walking through the remote nodes
    //
    while (pRemoteNodeList != &pAdapter->PDOList)
    {
        pRemoteNode = CONTAINING_RECORD(pRemoteNodeList, REMOTE_NODE, linkPdo);

        pRemoteNodeList = ListNext (pRemoteNodeList);

        RefValue = pRemoteNode->Ref.ReferenceCount; ;

        //
        // Reference the remote node, so we can guarantee its presence
        //
        if (REMOTE_NODE_ACTIVE (pRemoteNode) == FALSE)
        {
            //
            // The remote node is going away. Skip this remote node
            //
            
            continue;
        }

        if (nicReferenceRemoteNode (pRemoteNode, ReassemblyTimer )== FALSE )
        {
            //
            // The remote node is going away. Skip this remote node
            //
            
            continue;
        }

         
        REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK (pRemoteNode);
        //
        // Now walking through all the reassembly structures on that remote node
        //
        
        

        pReassemblyList = ListNext(&pRemoteNode->ReassemblyList);

        while (pReassemblyList  != &pRemoteNode->ReassemblyList)
        {
            pReassembly = CONTAINING_RECORD (pReassemblyList, 
                                             NDIS1394_REASSEMBLY_STRUCTURE, 
                                             ReassemblyListEntry);

            pReassemblyList = ListNext(pReassemblyList);


            //
            // If the reassembly has not been touched since the last timer it needs to be freed.
            // Other threads can ask us to free the reassembly by setting the aborted flag
            //
            if (REASSEMBLY_TEST_FLAG (pReassembly, REASSEMBLY_FREED) == TRUE)
            {

                continue;

            }
            
            if (REASSEMBLY_TEST_FLAG (pReassembly, (REASSEMBLY_NOT_TOUCHED| REASSEMBLY_ABORTED)) == TRUE)
            {
                
                REASSEMBLY_SET_FLAG (pReassembly, REASSEMBLY_FREED);
                //
                // We  have the lock, so we can remove this reassembly structure from the remote node
                //
                TRACE( TL_V, TM_Reas, ( "Removing Reassembly %x", pReassembly) );
                
                RemoveEntryList(&pReassembly->ReassemblyListEntry);

                //
                //  dereference the remote node . ref was made when the reassembly was added 
                // to the remote node
                //
                nicDereferenceRemoteNode (pRemoteNode, ReassemblyTimer_Removing );

                nicDereferenceReassembly (pReassembly, "ReassemblyTimerFunction - Removing reassembly");

                //
                // add this reassembly to the to be freed list.
                //
                InsertTailList(&ToBeFreedList,&pReassembly->ReassemblyListEntry);
            }
            else
            {
                //
                // Mark the Reassembly as Not Touched. If a fragment is received, it will clear the flag
                //
                REASSEMBLY_SET_FLAG (pReassembly, REASSEMBLY_NOT_TOUCHED);

                pAdapter->Reassembly.PktsInQueue ++;        
            }
                    
        }//     while (pReassemblyList  != &pRemoteNode->ReassemblyList)


        REMOTE_NODE_REASSEMBLY_RELEASE_LOCK(pRemoteNode);

        nicDereferenceRemoteNode(pRemoteNode , ReassemblyTimer );

        
        
    } //while (pRemoteNodeList != &pAdapter->PDOList)


    //
    // Clear the timer set flag , so that any new reassenblies will restart the timer
    //
    pAdapter->Reassembly.bTimerAlreadySet = FALSE;

    ADAPTER_RELEASE_LOCK (pAdapter);
    //
    // Now we walk the ToBeFreedList and free each of the reasembly structures
    //
    if (IsListEmpty (&ToBeFreedList) == FALSE)
    {
        nicAbortReassemblyList (&ToBeFreedList);
    }


    if (pAdapter->Reassembly.PktsInQueue > 0)
    {
        //
        // Requeue the timer, as there are still fragments remaining in the list.
        // This will fail in the case, that the adapter is being halted or Set
        // To Low Power
        //
        ASSERT (ADAPTER_TEST_FLAG (pAdapter, fADAPTER_NoMoreReassembly) == FALSE);
        nicQueueReassemblyTimer(pAdapter, FALSE);

    }

    
    pAdapter->Reassembly.CompleteEvent.EventCode = nic1394EventCode_ReassemblyTimerComplete;

    NdisSetEvent (&pAdapter->Reassembly.CompleteEvent.NdisEvent);
    

    
    TRACE( TL_T, TM_Mp, ( "<== ReassemblyTimerFunction   " ) );
    MATCH_IRQL;


}

NDIS_STATUS 
nicAddIP1394ToConfigRom (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:


    Adds thE IP1394 Config Rom entry to the OHCI device.

Arguments:

    
Return Value:

--*/
{   
    HANDLE hCromData = NULL;
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    PMDL pConfigRomMdl = NULL;
    
    TRACE( TL_T, TM_Mp, ( "==> nicAddIP1394ToConfigRom  pAdapter %x", pAdapter ) );


    NdisStatus  = nicSetLocalHostPropertiesCRom(pAdapter,
                                               (PUCHAR)&Net1394ConfigRom,
                                               sizeof(Net1394ConfigRom),
                                               SLHP_FLAG_ADD_CROM_DATA,
                                               &hCromData,
                                               &pConfigRomMdl);
    
    ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        pAdapter->hCromData = hCromData;
        pAdapter->pConfigRomMdl = pConfigRomMdl;
    }
    
    TRACE( TL_T, TM_Mp, ( "<== nicAddIP1394ToConfigRom  pAdapter %x", pAdapter ) );
    return NdisStatus;

}


NDIS_STATUS
nicMCmRegisterAddressFamily (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:

    This function will only be called once per local host
    This will cause the ARP module to send Create Vc's etc


Arguments:

    
Return Value:

--*/
{   
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    BOOLEAN fDoRegister = TRUE;

    TRACE( TL_T, TM_Mp, ( "==> nicCmRegisterAddressFamily pAdapter %x", pAdapter ) );

    do 
    {
        

        // Register the address family of our call manager with NDIS for the
        // newly bound adapter.  We use the mini-port form of
        // RegisterAddressFamily instead of the protocol form because
        // we are a miniport/callmanager combo. The mini-port form
        // causes the call manager VC context to
        // automatically map to the mini-port VC context, which is exactly
        // what we want.
        //
        // NDIS notifies all call manager clients of the new family we
        // register.
        //
        {
            NDIS_CALL_MANAGER_CHARACTERISTICS ncmc;
            CO_ADDRESS_FAMILY family;

            NdisZeroMemory( &family, sizeof(family) );
            family.MajorVersion = NDIS_MajorVersion;
            family.MinorVersion = NDIS_MinorVersion;
            family.AddressFamily = CO_ADDRESS_FAMILY_1394;

            NdisZeroMemory( &ncmc, sizeof(ncmc) );
            ncmc.MajorVersion = NDIS_MajorVersion;
            ncmc.MinorVersion = NDIS_MinorVersion;
            ncmc.CmCreateVcHandler = NicCmCreateVc;
            ncmc.CmDeleteVcHandler = NicCmDeleteVc;
            ncmc.CmOpenAfHandler = NicCmOpenAf;
            ncmc.CmCloseAfHandler = NicCmCloseAf;

            ncmc.CmRegisterSapHandler = nicRegisterSapHandler;
            ncmc.CmDeregisterSapHandler = nicDeregisterSapHandler;

            ncmc.CmMakeCallHandler = NicCmMakeCall;
            ncmc.CmCloseCallHandler = NicCmCloseCall;

            // NEW for 1394 no ncmc.CmIncomingCallCompleteHandler
            ncmc.CmAddPartyHandler = nicCmAddPartyHandler;
            ncmc.CmDropPartyHandler = nicCmDropPartyHandler; 

            // no CmDropPartyHandler
            // NEW for 1394 no ncmc.CmActivateVcCompleteHandler
            // NEW for 1394 no ncmc.CmDeactivateVcCompleteHandler
            ncmc.CmModifyCallQoSHandler = NicCmModifyCallQoS;
            ncmc.CmRequestHandler = NicCmRequest;
            // no CmRequestCompleteHandler

            TRACE( TL_I, TM_Cm, ( "NdisMCmRegAf" ) );
            
            NdisStatus = NdisMCmRegisterAddressFamily (pAdapter->MiniportAdapterHandle, 
                                                       &family, 
                                                       &ncmc, 
                                                       sizeof(ncmc) );
                                                 
            TRACE( TL_I, TM_Cm, ( "NdisMCmRegAf=$%x", NdisStatus ) );
        }


    } while (FALSE);
    
    TRACE( TL_T, TM_Mp, ( "<== nicCmRegisterAddressFamily NdisStatus %x", NdisStatus  ) );

    return NdisStatus;

}




VOID
nicFreeReassembliesOnRemoteNode (
    IN PREMOTE_NODE pRemoteNode,
    PLIST_ENTRY pToBeFreedList
    )
/*++

Routine Description:
 Free All reassemblies that are on this remote node.
 Acquires the reassembly Lock , pops the reassemblies off the list and then aborts them

 This functions is an exception to our reassembly garbage collection. algorithm as the context of this function
 requires immediate freeing of the reassembly structures
 
 Expects the remote node lock to be held
Arguments:
  pRemote Node - Remote Node that is being pulled out
  
Return Value:


--*/


{
    ULONG NumFreed=0;
    PLIST_ENTRY pReassemblyList = NULL;
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly = NULL;
    
    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Mp, ( "==> nicFreeReassembliesOnRemoteNode  pRemoteNode %x", pRemoteNode) );

    InitializeListHead(pToBeFreedList);

    //
    // Now walking through all the reassembly structures on that remote node
    //

    //
    // If the remtoe node is in the list, it is fair game for us to extract it 
    //
    REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK (pRemoteNode);
    
    pReassemblyList = ListNext(&pRemoteNode->ReassemblyList);

    while (pReassemblyList  != &pRemoteNode->ReassemblyList)
    {
        pReassembly = CONTAINING_RECORD (pReassemblyList, 
                                         NDIS1394_REASSEMBLY_STRUCTURE, 
                                         ReassemblyListEntry);

        pReassemblyList = ListNext(pReassemblyList);

        //
        // Once the reassembly has been marked as free, it should no longer be in the remote 
        // node's list . 
        //
        ASSERT (REASSEMBLY_TEST_FLAG (pReassembly, REASSEMBLY_FREED) == FALSE);
        
            
        REASSEMBLY_SET_FLAG (pReassembly, REASSEMBLY_FREED);
        //
        // We  have the lock, so we can remove this reassembly structure from the remote node
        //
        TRACE( TL_V, TM_Mp, ( "Removing Reassembly %x", pReassembly) );
            
        RemoveEntryList(&pReassembly->ReassemblyListEntry);

        //
        //  dereference the remote node . ref was made when the reassembly was added 
        // to the remote node
        //
        nicDereferenceRemoteNode (pRemoteNode, FreeReassembliesOnRemoteNode );

        nicDereferenceReassembly(pReassembly,  "nicFreeReassembliesOnRemoteNode " );


        //
        // add this reassembly to the to be freed list.
        //
        InsertTailList(pToBeFreedList,&pReassembly->ReassemblyListEntry);
                
    }//     while (pReassemblyList  != &pRemoteNode->ReassemblyList)



    REMOTE_NODE_REASSEMBLY_RELEASE_LOCK(pRemoteNode);

    
    TRACE( TL_T, TM_Mp, ( "<== nicFreeReassembliesOnRemoteNode  NumFreed %x",NumFreed ) );
    MATCH_IRQL;

}
 

UCHAR
nicGetMaxRecFromBytes(
    IN ULONG ByteSize
    )
/*++

Routine Description:
  Converts Size in bytes to MaxRec
  512 - 8
  1024 - 9
Arguments:
  ULONG Bytes Size

Return Value:


--*/
{

    TRACE( TL_T ,TM_Mp, ( "==>nicGetMaxRecFromBytes ByteSize %x",ByteSize) );

    if (ByteSize == ASYNC_PAYLOAD_100_RATE) return MAX_REC_100_RATE;
    if (ByteSize == ASYNC_PAYLOAD_200_RATE) return MAX_REC_200_RATE;
    if (ByteSize == ASYNC_PAYLOAD_400_RATE) return MAX_REC_400_RATE;
    if (ByteSize == ASYNC_PAYLOAD_800_RATE_LOCAL) return MAX_REC_800_RATE_LOCAL;
    if (ByteSize == ASYNC_PAYLOAD_1600_RATE_LOCAL) return MAX_REC_1600_RATE_LOCAL;
    if (ByteSize == ASYNC_PAYLOAD_3200_RATE_LOCAL) return MAX_REC_3200_RATE_LOCAL;
    //
    // Default to 400 for all greater values
    //
    return MAX_REC_400_RATE;
}



UCHAR
nicGetMaxRecFromSpeed(
    IN ULONG Scode
    )
/*++

Routine Description:
  Converts Speed to MaxRec

Arguments:
  ULONG Bytes Size

Return Value:


--*/
{

    TRACE( TL_T ,TM_Mp, ( "==>nicGetMaxRecFromSpeed  Scode %x",Scode) );

    if (Scode == SPEED_FLAGS_100) return MAX_REC_100_RATE;
    if (Scode == SPEED_FLAGS_200  ) return MAX_REC_200_RATE;
    if (Scode == SPEED_FLAGS_400   ) return MAX_REC_400_RATE;
    if (Scode == SPEED_FLAGS_800   ) return MAX_REC_800_RATE_LOCAL  ;
    if (Scode == SPEED_FLAGS_1600   ) return MAX_REC_1600_RATE_LOCAL  ;
    if (Scode == SPEED_FLAGS_3200   ) return MAX_REC_3200_RATE_LOCAL  ;
                      
    //
    //  default
    //
    return MAX_REC_400_RATE;
}


PREMOTE_NODE
nicGetRemoteNodeFromTable (
    ULONG NodeNumber,
    PADAPTERCB pAdapter
    )
/*++

Routine Description:
  Looks up the remote node in a locked table  , references the remote 
  node and returns

Arguments:
  ULONG NodeNumber  

Return Value:
  pRemoteNode

--*/

{
    PREMOTE_NODE pRemoteNode = NULL;

    ADAPTER_ACQUIRE_LOCK (pAdapter);
    pRemoteNode = pAdapter->NodeTable.RemoteNode[NodeNumber];

    if (pRemoteNode != NULL)
    {
        nicReferenceRemoteNode (pRemoteNode, GetRemoteNodeFromTable);
    }
    ADAPTER_RELEASE_LOCK (pAdapter);

    
    return pRemoteNode;

}




NDIS_STATUS
nicFillNicInfo (
    IN PADAPTERCB pAdapter, 
    PNIC1394_NICINFO pInNicInfo,
    PNIC1394_NICINFO pOutNicInfo
    )

/*++

Routine Description:

    Takes the Buffer passed in, makes sure that it is big enough
    and then puts all our statistics into that buffer

Arguments:
    
Return Value:


--*/

{
    NDIS_STATUS Status = NDIS_STATUS_INVALID_DATA;

    do
    {
        //
        // First check internal version
        //
        if (pInNicInfo->Hdr.Version != NIC1394_NICINFO_VERSION)
        {
            TRACE( TL_A, TM_Mp, ( "  NICINFO.Version mismatch. Want %lu got %lu\n",
                        NIC1394_NICINFO_VERSION,
                        pInNicInfo->Hdr.Version
                        ));
            break;
        }

        //
        // Struct-copy the old to the new. It's wasteful, but we don't want
        // to dig into how much of the in buffer contains valid data.
        //
        *pOutNicInfo = *pInNicInfo;

        //
        // Rest is op-specific
        //
        switch(pOutNicInfo->Hdr.Op)
        {

        case NIC1394_NICINFO_OP_BUSINFO:
            Status = nicFillBusInfo(pAdapter, &pOutNicInfo->BusInfo);
            break;

        case NIC1394_NICINFO_OP_REMOTENODEINFO:
            Status = nicFillRemoteNodeInfo(pAdapter, &pOutNicInfo->RemoteNodeInfo);
            break;

        case NIC1394_NICINFO_OP_CHANNELINFO:
            Status = nicFillChannelInfo(pAdapter, &pOutNicInfo->ChannelInfo);
            break;
        case NIC1394_NICINFO_OP_RESETSTATS:
            Status = nicResetStats (pAdapter, &pOutNicInfo->ResetStats);
        default:
            TRACE( TL_A, TM_Mp, ( "  NICINFO.Op (%lu) is unknown.\n",
                        pInNicInfo->Hdr.Op
                        ));
            break;
        
        }

    } while (FALSE);


    return Status;
}



NDIS_STATUS
nicResetStats (
    IN      PADAPTERCB pAdapter, 
    PNIC1394_RESETSTATS     pResetStats 
    )
/*++

Routine Description:

    Self explanatory

Arguments:
    
Return Value:


--*/
{


    NdisZeroMemory (&pAdapter->AdaptStats.TempStats, sizeof (pAdapter->AdaptStats.TempStats) );
    return NDIS_STATUS_SUCCESS;

}


NDIS_STATUS
nicFillBusInfo(
    IN      PADAPTERCB pAdapter, 
    IN  OUT PNIC1394_BUSINFO pBi
    )
/*++

Routine Description:

    Colpied all the statistics that we have into the buffer
    that was passed in.

Arguments:
    
Return Value:


--*/
{
    ULARGE_INTEGER BusMap, ActiveMap;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    NIC_SEND_RECV_STATS* pNicStats = NULL;
    PADAPT_STATS pAdaptStats = &pAdapter->AdaptStats;
    //
    // Fill with Dummy data
    //
    pBi->NumBusResets = pAdaptStats->ulNumResetCallbacks;
    pBi->SecondsSinceBusReset = nicGetSystemTime() - pAdaptStats->ulResetTime;
    
    pBi->Flags =  (BCR_TEST_FLAG( pAdapter, BCR_LocalHostIsIRM) == TRUE ) ? NIC1394_BUSINFO_LOCAL_IS_IRM : 0;


    //
    // CHANNEL RELATED INFORMATION
    //
    NdisStatus = nicQueryChannelMap( pAdapter, &BusMap);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        pBi->Channel.BusMap = BusMap.QuadPart;
    }
    
    //
    // For now
    //
    ActiveMap.QuadPart = pAdapter->ChannelsAllocatedByLocalHost;

    //
    // First zero out some info
    //
    NdisZeroMemory( &pBi->Channel.SendPktStats, sizeof (pBi->Channel.SendPktStats ));
    NdisZeroMemory( &pBi->Fifo.SendPktStats, sizeof (pBi->Fifo.SendPktStats) ) ;

    //
    // Now go through each Vc and extract the relevant information
    //
    ADAPTER_ACQUIRE_LOCK (pAdapter);

    #define GARBAGE 9999    


    pBi->Channel.Bcr = *((PULONG) &pAdapter->BCRData.IRM_BCR);
    pBi->LocalNodeInfo.UniqueID = pAdapter->UniqueId;           // This node's 64-bit Unique ID.
    pBi->LocalNodeInfo.BusGeneration = pAdapter->Generation;    // 1394 Bus generation ID.
    pBi->LocalNodeInfo.NodeAddress = pAdapter->NodeAddress;
    pBi->LocalNodeInfo.MaxRecvBlockSize = pAdapter->MaxRec; 
    pBi->LocalNodeInfo.MaxRecvSpeed = pAdapter->SCode;

    //
    // Fill up Recv Vc Stats
    //
    if (pAdapter->pRecvFIFOVc != NULL)
    {
        PRECVFIFO_VCCB pRecvVc = pAdapter->pRecvFIFOVc;
        
        pBi->Fifo.Recv_Off_Low = pRecvVc->VcAddressRange.AR_Off_Low;
        pBi->Fifo.Recv_Off_High = pRecvVc ->VcAddressRange.AR_Off_High;

        nicCopyPacketStats(&pBi->Fifo.RecvPktStats
                         ,pAdapter->AdaptStats.TempStats.Fifo.ulRecv, 
                         GARBAGE , 
                         GARBAGE ,
                         GARBAGE);

        pBi->Fifo.NumFreeRecvBuffers  = pRecvVc->NumAllocatedFifos - pRecvVc->NumIndicatedFifos;
        pBi->Fifo.MinFreeRecvBuffers = GARBAGE ; // todo
    }
    //
    // Fifo Send Stats
    //
    pNicStats = &pAdaptStats->TempStats.Fifo;
    
    nicCopyPacketStats ( &pBi->Fifo.SendPktStats,  
                    pNicStats->ulSendNicSucess,
                    pNicStats->ulSendNicFail,
                    pNicStats->ulSendBusSuccess,
                    pNicStats->ulSendBusFail );

    nicCopyPacketStats ( &pBi->Fifo.RecvPktStats,  
                    pNicStats->ulRecv,
                    0,
                    0,
                    0);

    //
    // Channel Send Stats
    //
    pNicStats = &pAdapter->AdaptStats.TempStats.Channel;
    nicCopyPacketStats ( &pBi->Channel.SendPktStats,
                    pNicStats->ulSendNicSucess,
                    pNicStats->ulSendNicFail,
                    pNicStats->ulSendBusSuccess,
                    pNicStats->ulSendBusFail );

    //
    // Broadcast channel data - same as channel
    //
    nicCopyPacketStats  ( &pBi->Channel.BcSendPktStats,
                        pNicStats->ulSendNicSucess,
                        pNicStats->ulSendNicFail,
                        pNicStats->ulSendBusSuccess,
                        pNicStats->ulSendBusFail );

    //
    // Recv Channels
    //
    nicCopyPacketStats ( &pBi->Channel.BcRecvPktStats ,
                        pNicStats->ulRecv, 
                        0, 
                        0, 
                        0);

    ADAPTER_RELEASE_LOCK (pAdapter);

    pBi->Channel.ActiveChannelMap= ActiveMap.QuadPart;
    pBi->Fifo.NumOutstandingReassemblies = pAdaptStats->TempStats.ulNumOutstandingReassemblies;
    pBi->Fifo.MaxOutstandingReassemblies =pAdaptStats->TempStats.ulMaxOutstandingReassemblies;
    //pBi->Fifo.NumAbortedReassemblies = ReassemblyCompleted;
    
    
    //
    // Information about remote nodes. More information about each of these nodes
    // may be queried using *OP_REMOTE_NODEINFO
    //
    pBi->NumRemoteNodes = pAdaptStats->ulNumRemoteNodes;

    ADAPTER_ACQUIRE_LOCK (pAdapter);
    {
        UINT i = 0;
        PLIST_ENTRY pRemoteEntry = ListNext(&pAdapter->PDOList);

        while (pRemoteEntry != &pAdapter->PDOList)
        {
            PREMOTE_NODE pRemote = CONTAINING_RECORD (pRemoteEntry,
                                                           REMOTE_NODE,
                                                           linkPdo);
            pRemoteEntry = ListNext(pRemoteEntry);
            
            pBi->RemoteNodeUniqueIDS[i] = pRemote->UniqueId;

            i++;
        }

    }
    
    ADAPTER_RELEASE_LOCK (pAdapter);
    
    return NDIS_STATUS_SUCCESS;
}



NDIS_STATUS
nicFillChannelInfo(
    IN      PADAPTERCB pAdapter, 
    IN OUT  PNIC1394_CHANNELINFO pCi
    )
/*++

Routine Description:

    Simply return success.

Arguments:

    
Return Value:

--*/
{
    return NDIS_STATUS_SUCCESS;
}



NDIS_STATUS
nicFillRemoteNodeInfo(
    IN      PADAPTERCB pAdapter, 
    IN OUT  PNIC1394_REMOTENODEINFO pRni
    )
/*++

Routine Description:

    Captures the information from our Remote Nodes.

Arguments:

    
Return Value:

--*/
{
    NDIS_STATUS NdisStatus;
    REMOTE_NODE *pRemoteNode = NULL;

    do
    {
        //
        // First let's find the remote node, based on the unique ID.
        // nicFindRemoteNodeFromAdapter refs pRemoteNode on success.
        //
        NdisStatus = nicFindRemoteNodeFromAdapter(pAdapter,
                                                  NULL, // pPDO OPTIONAL
                                                  pRni->UniqueID,
                                                  &pRemoteNode);
    
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            pRemoteNode = NULL;
            break;
        }

        NdisStatus  = nicQueryRemoteNodeCaps (pAdapter,
                                              pRemoteNode,
                                              &pRni->MaxSpeedBetweenNodes,
                                              &pRni->EffectiveMaxBlockSize,
                                              &pRni->MaxRec
                                              );

        REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);

        pRni->NodeAddress = *(PUSHORT) &pRemoteNode->RemoteAddress;
    

        if (REMOTE_NODE_ACTIVE (pRemoteNode))
        {
            pRni->Flags = NIC1394_REMOTEINFO_ACTIVE;
        }
        else
        {
            pRni->Flags = NIC1394_REMOTEINFO_UNLOADING; // we assume it's unloading.
        }

        REMOTE_NODE_RELEASE_LOCK (pRemoteNode);
    
        //
        // Don't support the following yet.
        //
        NdisZeroMemory (&pRni->SendFifoPktStats, sizeof (pRni->SendFifoPktStats) );
        NdisZeroMemory (&pRni->SendFifoPktStats, sizeof (pRni->SendFifoPktStats));
        NdisZeroMemory (&pRni->RecvFifoPktStats, sizeof (pRni->SendFifoPktStats));
        NdisZeroMemory (&pRni->RecvChannelPktStats , sizeof (pRni->SendFifoPktStats));
    } while (FALSE);

    if (pRemoteNode != NULL)
    {
        nicDereferenceRemoteNode(pRemoteNode, FillRemoteNodeInfo);
    }

    return NdisStatus;
}





VOID
nicCopyPacketStats (
    NIC1394_PACKET_STATS* pStats,
    UINT    TotNdisPackets,     // Total number of NDIS packets sent/indicated
    UINT    NdisPacketsFailures,// Number of NDIS packets failed/discarded
    UINT    TotBusPackets,      // Total number of BUS-level reads/writes
    UINT    BusPacketFailures   // Number of BUS-level failures(sends)/discards(recv)
    )
/*++

Routine Description:

    Self Explanatory

Arguments:

    
Return Value:

--*/
{

    pStats->TotNdisPackets= TotNdisPackets;     // Total number of NDIS packets sent/indicated
    pStats->NdisPacketsFailures= NdisPacketsFailures;// Number of NDIS packets failed/discarded
    pStats->TotBusPackets = TotBusPackets;      // Total number of BUS-level reads/writes
    pStats->TotBusPackets = BusPacketFailures;  // Number of BUS-level failures(sends)/discards(recv)


}

VOID
nicAddPacketStats(
    NIC1394_PACKET_STATS* pStats,
    UINT    TotNdisPackets,     // Total number of NDIS packets sent/indicated
    UINT    NdisPacketsFailures,// Number of NDIS packets failed/discarded
    UINT    TotBusPackets,      // Total number of BUS-level reads/writes
    UINT    BusPacketFailures   // Number of BUS-level failures(sends)/discards(recv)
    )
/*++

Routine Description:

    Self Explanatory


Arguments:

    
Return Value:

--*/
{

    pStats->TotNdisPackets+= TotNdisPackets;        // Total number of NDIS packets sent/indicated
    pStats->NdisPacketsFailures+= NdisPacketsFailures;// Number of NDIS packets failed/discarded
    pStats->TotBusPackets += TotBusPackets;     // Total number of BUS-level reads/writes
    pStats->TotBusPackets += BusPacketFailures; // Number of BUS-level failures(sends)/discards(recv)


}




VOID
nicInformProtocolsOfReset(
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:

    Informs protocols of reset. Does an NdisMCoIndicateStatus with a locally allocated structure 
    which includes the new Local Node Address and Generation

Arguments:


Return Value:


--*/
{
    NIC1394_STATUS_BUFFER  StatusBuffer;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    
    TRACE( TL_T, TM_Mp, ( "==> nicInformProtocolsOfReset ") );

    do
    {
    
        NdisZeroMemory (&StatusBuffer, sizeof (StatusBuffer) );

        StatusBuffer.Signature = NIC1394_MEDIA_SPECIFIC;

        StatusBuffer.Event = NIC1394_EVENT_BUS_RESET;


        NdisMCoIndicateStatus(pAdapter->MiniportAdapterHandle,
                           NULL,
                           NDIS_STATUS_MEDIA_SPECIFIC_INDICATION,
                           &StatusBuffer,
                           sizeof(StatusBuffer));
    } while (FALSE);



    TRACE( TL_T, TM_Mp, ( "<== nicInformProtocolsOfReset ") );

}

VOID
nicUpdateRemoteNodeCaps(
    PADAPTERCB          pAdapter
)
/*++

Routine Description:

    Update the caps (maxrec, maxspeed-to, max effective buffer size) for all
    nodes that we have connections to.

Arguments:


Return Value:


--*/
{

    ULONG               i = 0;
    ULONG               NumNodes = 0;
    PREMOTE_NODE        pRemoteNode = NULL;
    NODE_ADDRESS        NodeAddress;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_SUCCESS;

    for (i=0; i<NIC1394_MAX_NICINFO_NODES; i++)
    {
        UINT SpeedTo;
        UINT EffectiveMaxBufferSize;
        UINT MaxRec;

        if (pAdapter->NodeTable.RemoteNode[i] == NULL)
        {
            continue;     // ******************* CONTINUE ****************
        }


        ADAPTER_ACQUIRE_LOCK (pAdapter);

        pRemoteNode = pAdapter->NodeTable.RemoteNode[i];
            
        // We check again, with the lock held.
        //
        if (pRemoteNode == NULL || !REMOTE_NODE_ACTIVE (pRemoteNode))
        {
            ADAPTER_RELEASE_LOCK (pAdapter);
            continue;     // ******************* CONTINUE ****************
        }
        nicReferenceRemoteNode (pRemoteNode, UpdateRemoteNodeCaps);
        ADAPTER_RELEASE_LOCK (pAdapter);


        // Specifying FALSE (!from cache) below causes pRemoteNode's cached caps
        // to be refreshed.
        //
        NdisStatus  = nicQueryRemoteNodeCaps (pAdapter,
                                              pRemoteNode,
                                              &SpeedTo,
                                              &EffectiveMaxBufferSize,
                                              &MaxRec
                                              );
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Mp, ( "nicUpdateRemoteNodeCaps couldn't update caps fo node %x", pRemoteNode));
        }
        nicDereferenceRemoteNode (pRemoteNode, UpdateRemoteNodeCaps);
    }
}




VOID
nicQueryInformationWorkItem(
    IN PNDIS_WORK_ITEM pWorkItem,   
    IN PVOID Context 
    )
/*++

Routine Description:

    This is the WorkItem that we have allocated for
    our querying information.

Arguments:


Return Value:


--*/
{
    PADAPTERCB pAdapter= (PADAPTERCB) Context;
    PNIC_WORK_ITEM pNicWorkItem =  (PNIC_WORK_ITEM) pWorkItem;
    NDIS_STATUS Status;

    Status =  nicQueryInformation(
                pAdapter,
                pNicWorkItem->RequestInfo.pVc,
                pNicWorkItem->RequestInfo.pNdisRequest
                );
    //
    // We call at passive, so we should never be pending here.
    //
    ASSERT(Status != NDIS_STATUS_PENDING);

    //
    // Asynchronously complete the work item.
    //
   NdisMCoRequestComplete(
          Status,
          pAdapter->MiniportAdapterHandle,
          pNicWorkItem->RequestInfo.pNdisRequest
          );

    //
    // Deref the work item adapter reference.
    //
    FREE_NONPAGED (pWorkItem);
    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);
    nicDereferenceAdapter(pAdapter, "nicQueryInfoWorkItem");
}




VOID
nicMIndicateStatus(
    IN  PADAPTERCB              pAdapter ,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    )
/*++

Routine Description:

    This function inserts a packet into the send queue. If there is no timer servicing the queue
    then it queues a timer to dequeue the packet in Global Event's context


Arguments:

    Self explanatory 
    
Return Value:
    Success - if inserted into the the queue

--*/
    
{


    if (ADAPTER_TEST_FLAG (pAdapter, fADAPTER_DoStatusIndications) == FALSE)
    {
        return;
    }



    NdisMCoIndicateStatus (pAdapter->MiniportAdapterHandle ,
                        NULL,
                         GeneralStatus,
                         StatusBuffer,
                         StatusBufferSize   
                         );

    
}



NDIS_STATUS
nicAllocateLoopbackPacketPool (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:
    allocate a packet and buffer pool for loopback packet

Arguments:


Return Value:


--*/
    
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    do
    {
        //
        // Allocate a packet pool to indicate loopback receives from.
        //
        NdisAllocatePacketPoolEx(
            &NdisStatus,
            &pAdapter->LoopbackPool.Handle,
            32,
            32,
            sizeof(LOOPBACK_RSVD)
            );

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        pAdapter->LoopbackPool.AllocatedPackets = 0;
        
        
        NdisAllocateBufferPool(
            &NdisStatus,
            &pAdapter->LoopbackBufferPool,
            64
            );
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

    } while (FALSE);
    

    return NdisStatus;
}




VOID
nicFreeLoopbackPacketPool (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:
    free the packet and buffer pool for loopback packet

Arguments:


Return Value:


--*/
{
    if (pAdapter->LoopbackPool.Handle != NULL)
    {
        nicFreePacketPool (&pAdapter->LoopbackPool);
    }

    
    if (pAdapter->LoopbackBufferPool != NULL)
    {
        NdisFreeBufferPool(pAdapter->LoopbackBufferPool);
        pAdapter->LoopbackBufferPool = NULL;
    }

  
    


}


VOID
nicLoopbackPacket(
    IN VCCB* pVc,
    IN PNDIS_PACKET pPacket
    )
/*++

Routine Description:
    Allocate a packet and indicate it up on the Broadcast vc

Arguments:


Return Value:


--*/
{
    NDIS_STATUS Status;
    PNDIS_BUFFER pFirstBuffer;
    ULONG TotalLength;

    PNDIS_PACKET pLoopbackPacket;
    PUCHAR pCopyBuf;
    PNDIS_BUFFER pLoopbackBuffer;
    ULONG BytesCopied;

    ADAPTERCB* pAdapter;
    PLOOPBACK_RSVD pLoopbackRsvd; 

    pAdapter = pVc->Hdr.pAF->pAdapter;

    TRACE( TL_T, TM_Recv, ("NIC1394: loopback pkt %p on VC %p, type %d\n",
        pPacket, pVc, pVc->Hdr.VcType));

    pLoopbackPacket = NULL;
    pLoopbackBuffer = NULL;
    pCopyBuf = NULL;

    do
    {
        nicAllocatePacket(&Status, &pLoopbackPacket, &pAdapter->LoopbackPool);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        NdisQueryPacket(
            pPacket,
            NULL,
            NULL,
            &pFirstBuffer,
            &TotalLength
            );
        
        pCopyBuf = ALLOC_NONPAGED (TotalLength, MTAG_RBUF); 

        if (pCopyBuf == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisAllocateBuffer(
            &Status,
            &pLoopbackBuffer,
            pAdapter->LoopbackBufferPool,
            pCopyBuf,
            TotalLength
            );
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        pLoopbackBuffer->Next = NULL;
        NdisChainBufferAtFront(pLoopbackPacket, pLoopbackBuffer);

        NdisCopyFromPacketToPacket(
            pLoopbackPacket,
            0,
            TotalLength,
            pPacket,
            0,
            &BytesCopied
            );

        //
        // Make sure we can reclaim the packet after the receive indicate
        // returns.  
        //
        // If the status is made async, then the loopback Tag will
        // break in the return packet handler
        //
        NDIS_SET_PACKET_STATUS(pLoopbackPacket, NDIS_STATUS_RESOURCES);

        // Set the Loopback Tag. 
        pLoopbackRsvd = (PLOOPBACK_RSVD) pLoopbackPacket->ProtocolReserved;
        pLoopbackRsvd->LoopbackTag = NIC_LOOPBACK_TAG;
        NdisSetPacketFlags (pLoopbackPacket, NDIS_FLAGS_IS_LOOPBACK_PACKET);
        

        NdisMCoIndicateReceivePacket(
            pVc->Hdr.NdisVcHandle,
            &pLoopbackPacket,
            1);
        
        NdisFreeBuffer(pLoopbackBuffer);
        nicFreePacket(pLoopbackPacket, &pAdapter->LoopbackPool);

        FREE_NONPAGED(pCopyBuf);
    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        if (pCopyBuf)
        {
            FREE_NONPAGED(pCopyBuf);
        }

        if (pLoopbackBuffer)
        {
            NdisFreeBuffer(pLoopbackBuffer);
        }

        if (pLoopbackPacket)
        {
            nicFreePacket(pLoopbackPacket, &pAdapter->LoopbackPool);
        }
    }
}



VOID
nicWriteErrorLog (
    IN PADAPTERCB pAdapter,
    IN NDIS_ERROR_CODE ErrorCode,
    IN ULONG ErrorValue
    )
/*++

Routine Description:

    Self Explanatory - See DDK

Arguments:

    
Return Value:

--*/
{

    NdisWriteErrorLogEntry( pAdapter->MiniportAdapterHandle,
                            ErrorCode,
                            1,
                            ErrorValue
                            );


}





VOID
nicUpdateRemoteNodeTable (
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:

      Go through all the remote nodes in the system and query its Node Address
      Make two tables, one contains all the remote nodes that have been refed. The
      other contains the Nodes according to their Node Addresses(TempNodeTable).
    
      Simple algorithm:
          Take a snapshot of the current RemoteNodes List into RefNodeTable
          Ref all the remote nodes in a local structure.
          Get their new remote node addresses (TempNodeTable)
          Copy the TempNodeTable into the Adapter Structure - it is now official
          Update the address in the remote node themselves
          Dereference the Ref made above



Arguments:

    
Return Value:

--*/
{
    NDIS_STATUS     NdisStatus = NDIS_STATUS_FAILURE;
    PNODE_TABLE     pNodeTable = &pAdapter->NodeTable;
    PLIST_ENTRY     pRemoteNodeList;
    NODE_ADDRESS    RemoteNodeAddress;
    NODE_TABLE      RefNodeTable;
    NODE_TABLE      TempNodeTable;
    ULONG           NumRemoteNodes = 0;
    ULONG           MaxNumRefNodeTable = 0;
    USHORT          RefIndex=0;
    PREMOTE_NODE    pCurrRemoteNode;
    
    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Mp, ( " ==>nicUpdateRemoteNodeTable pAdapter %x, TempNodeTable%x", pAdapter , &TempNodeTable) );


    NdisZeroMemory (&TempNodeTable, sizeof (NODE_TABLE) );
    NdisZeroMemory (&RefNodeTable, sizeof(RefNodeTable));

    NumRemoteNodes = 0;

    
    ADAPTER_ACQUIRE_LOCK (pAdapter);

    pRemoteNodeList = ListNext (&pAdapter->PDOList);

    //
    // Walk through the entire list and make a copy of the current list.
    // Reference each remote node on the list. 
    // The lock will ensure that the list is valid and that no removed remote nodes
    // get into our RefNodeTable list.
    //
    
    while (pRemoteNodeList != &pAdapter->PDOList)
    {
        PREMOTE_NODE pRemoteNode;
        
        pRemoteNode = CONTAINING_RECORD (pRemoteNodeList, REMOTE_NODE, linkPdo);

        //
        // Reference the remote node. This guarantees that the remote node will
        // remain valid and in the list until it is dereferenced (deref happens below)
        //
        nicReferenceRemoteNode (pRemoteNode, UpdateRemoteNodeTable);
        RefNodeTable.RemoteNode[MaxNumRefNodeTable] = pRemoteNode;
        ASSERT (REMOTE_NODE_TEST_FLAG (pRemoteNode,PDO_Removed) == FALSE);

        //
        // Increment the Cursors and go to the next RemoteNode
        //
        pRemoteNodeList = ListNext (pRemoteNodeList);
        MaxNumRefNodeTable++;

    }  //while (pRemoteNodeList != &pAdapter->PDOList)

    ADAPTER_RELEASE_LOCK (pAdapter);

    //
    // Without the lock, call into the Bus Driver to get the remote address
    // of each remote node
    //
    {

        //
        // Initialize the structures
        //
        pCurrRemoteNode = RefNodeTable.RemoteNode[0];
        RefIndex =0;
        
        while (pCurrRemoteNode != NULL)
        {
            // Get the Node Address of the current Remote Node
            //
            NdisStatus =  nicGet1394AddressOfRemoteNode (pCurrRemoteNode,
                                                        &RemoteNodeAddress,
                                                        0);

            if (NdisStatus == NDIS_STATUS_SUCCESS)
            {
                // 
                // Fill in the Temp Remote Node Table
                //
                PREMOTE_NODE    *ppRemoteNode;
                ppRemoteNode = &TempNodeTable.RemoteNode[RemoteNodeAddress.NA_Node_Number];                

                if (*ppRemoteNode == NULL)
                {
                    //
                    // Update the value in the table
                    //
                    *ppRemoteNode = pCurrRemoteNode;
                    NumRemoteNodes ++;
                }

            }

            // Move to the next node in our local RefNodeTable
            //

            RefIndex++;
            pCurrRemoteNode = RefNodeTable.RemoteNode[RefIndex];

        }

    }

    ADAPTER_ACQUIRE_LOCK(pAdapter)
    
    //
    // Use the results of our queries to update our internal structures
    // Regardless of success or failure, copy the temp node table over 
    // into the adapter
    //


    NdisMoveMemory (&pAdapter->NodeTable, &TempNodeTable, sizeof (NODE_TABLE) );

    pAdapter->NumRemoteNodes = NumRemoteNodes;

    //
    // Update the node address within each of these remote nodes
    //
    {
        ULONG NumUpdated = 0;
        USHORT i=0;

        //
        // Update the Remote Node structures with their new Node Addresses
        //
        while (NumUpdated != NumRemoteNodes)
        {
            if (i >= (sizeof(TempNodeTable.RemoteNode)/sizeof(TempNodeTable.RemoteNode[0])))
            {
                // We've gone past the end of the array. Should never do that.
                //
                ASSERT(!"Walked off the end of the NodeTable");
                break;
            }
        
            if (TempNodeTable.RemoteNode[i] != NULL)
            {
                TempNodeTable.RemoteNode[i]->RemoteAddress.NA_Node_Number = i; 

                NumUpdated ++;
            }

            i++; // Use i to check if we have walked off the end of the table
            
            TRACE( TL_V, TM_Mp, ( " UpdatingRemoteNodeAddresses NumUpdated %x, i %x, NumRemoteNodes %x",
                                  NumUpdated, i, NumRemoteNodes) );

        } //        while (TRUE)
    }

    //
    // We're done, Now Dereference the Remote Node References Made above
    //

    pCurrRemoteNode = RefNodeTable.RemoteNode[0];
    RefIndex =0;
    
    while (pCurrRemoteNode != NULL)
    {
        if (REMOTE_NODE_TEST_FLAG (pCurrRemoteNode, PDO_Removed) )
        {
            //
            // If the node is being removed, then do not re-insert it
            // into the node table, by clearing it out of the NodeTable
            //
            ULONG CurrNodeNumber = pCurrRemoteNode->RemoteAddress.NA_Node_Number;
            
            RefNodeTable.RemoteNode[RefIndex] = NULL;


            if (pAdapter->NodeTable.RemoteNode[CurrNodeNumber]  == pCurrRemoteNode)
            {
                pAdapter->NodeTable.RemoteNode[CurrNodeNumber] = NULL;
            }
        }

        nicDereferenceRemoteNode(pCurrRemoteNode, UpdateRemoteNodeTable);
        RefIndex++;
        pCurrRemoteNode = RefNodeTable.RemoteNode[RefIndex];
    }



    ADAPTER_RELEASE_LOCK (pAdapter);

    
    TRACE( TL_T, TM_Mp, ( "<== nicUpdateRemoteNodeTable pAdapter %x, NumRemoteNodes %x", pAdapter, NumRemoteNodes ) );
    MATCH_IRQL;
}


VOID
nicRemoveRemoteNodeFromNodeTable(
    IN PNODE_TABLE pNodeTable,
    IN PREMOTE_NODE pRemoteNode
    )
/*++

Routine Description:

Remove the Remove Node from the Table and decrement any refcounts 
associated with it.

Arguments:

    
Return Value:

--*/
{

    //
    // This function assumes that the adapter lock is held.
    //
    PPREMOTE_NODE ppRemoteNode = NULL;

    //        
    // find the remote node and delete it from the node table.
    //

    //
    // The RemoteNode is probably already in the correct place in the Node Table. We'll look there first
    //
    ppRemoteNode = &pNodeTable->RemoteNode[pRemoteNode->RemoteAddress.NA_Node_Number] ;

    if (*ppRemoteNode != pRemoteNode)
    {
        //
        //We did not find the remote node, now we need to go through all the entries and see 
        // if the remote node is there
        //
        UINT i =0;
        while (i<NIC1394_MAX_NICINFO_NODES)
        {
            ppRemoteNode = &pNodeTable->RemoteNode[i];

            if (*ppRemoteNode == pRemoteNode)
            {
                //
                // we have found the remote node in the node table-- remove it
                //
               *ppRemoteNode = NULL;     
            }
            
            i++;  // try the next node

        } // while ()
    }

    //
    // if we were able to find the remote node either by the 
    // node number or through our iterative search
    // then remove it from the Node Table
    // 
    if (*ppRemoteNode == pRemoteNode)
    {
       *ppRemoteNode = NULL;     
    }
    
    

    
}


VOID
nicVerifyEuidTopology(
    IN PADAPTERCB pAdapter,
    IN PEUID_TOPOLOGY pEuidMap
    )
/*++

Routine Description:

    Update THe node address of each remote node 
    and then fills up the euid Map structre
    
Arguments:


Return Value:


--*/
{
   EUID_TOPOLOGY EuidTopology;
   PLIST_ENTRY pRemoteNodeList;
   PREMOTE_NODE pRemoteNode = NULL;

    //
    // Requery each  remote node for its latest HW address
    //
    nicUpdateRemoteNodeTable (pAdapter);  
    //
    // Recreate the list and verify that the topology has not changed from under us.
    //
    NdisZeroMemory (pEuidMap, sizeof(*pEuidMap));
    ADAPTER_ACQUIRE_LOCK(pAdapter);


    pRemoteNodeList = ListNext (&pAdapter->PDOList);

    //
    // Walk through the entire list and fire of a request for each RemoteNode
    // The lock will ensure that the list is valid
    //
    
    while (pRemoteNodeList != &pAdapter->PDOList)
    {
        USHORT NodeNumber;

        pEuidMap->NumberOfRemoteNodes++;

        pRemoteNode = CONTAINING_RECORD (pRemoteNodeList, REMOTE_NODE, linkPdo);

        pRemoteNodeList = ListNext (pRemoteNodeList);

        NodeNumber = pRemoteNode->RemoteAddress.NA_Node_Number;

        pEuidMap->Node[NodeNumber].Euid = pRemoteNode->UniqueId;
        pEuidMap->Node[NodeNumber].ENetAddress = pRemoteNode->ENetAddress;

    }  //while (pRemoteNodeList != &pAdapter->PDOList)

    ADAPTER_RELEASE_LOCK (pAdapter);

    

}


nicVerifyEuidMapWorkItem (
    NDIS_WORK_ITEM* pWorkItem,
    IN PVOID Context 
    )

/*++

Routine Description:
 
    This routine is a workitem routine.
    It is called whenever we are asked to report back our Mapping and is always
    called in the context of the miniport getting a request from arp1394.sys.
    

Arguments:
   pAdapter Local host

Return Value:


--*/
{
    PNIC_WORK_ITEM pNicWorkItem = (PNIC_WORK_ITEM )pWorkItem;
    PNDIS_REQUEST pRequest = pNicWorkItem->RequestInfo.pNdisRequest;
    PADAPTERCB pAdapter = (PADAPTERCB)Context;
    PEUID_TOPOLOGY pEuidMap = (PEUID_TOPOLOGY) pRequest->DATA.QUERY_INFORMATION.InformationBuffer;


    //
    //  Verify the contents of the Euid Map
    //

    nicVerifyEuidTopology(pAdapter,pEuidMap);
        

    //
    // As we atleast have the old data (before verification), 
    // we should always succeed the request
    //
    NdisMCoRequestComplete(NDIS_STATUS_SUCCESS,
                           pAdapter->MiniportAdapterHandle,
                           pRequest);

   

    FREE_NONPAGED (pNicWorkItem);
    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);

}


VOID
nicQueryEuidNodeMacMap (
    IN PADAPTERCB pAdapter,
    IN PNDIS_REQUEST pRequest
    )
/*++

Routine Description:
    Goes through all the remote nodes and extracts their Euid, Node Number and Mac
    address.

    This function first tries to query each remote node to get 
    its latest address either via by directly asking the remote node or thorough a work item.

    If that fails, then it takes the last known good values and reports it to the Arp module.
    
Arguments:


Return Value:


--*/
{
    PLIST_ENTRY pRemoteNodeList;
    PREMOTE_NODE pRemoteNode;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    PEUID_TOPOLOGY pEuidMap = (PEUID_TOPOLOGY) pRequest->DATA.QUERY_INFORMATION.InformationBuffer;
    PNIC_WORK_ITEM pUpdateTableWorkItem  = NULL;
  

    NdisZeroMemory (pEuidMap, sizeof (*pEuidMap));



    Status = NDIS_STATUS_SUCCESS;

    do
    {


        if (KeGetCurrentIrql() == PASSIVE_LEVEL)
        {
            //
            // This thread queries and completes the request
            //

            nicVerifyEuidTopology(pAdapter, pEuidMap);
            break;

        }

        //
        // We need to update the generation count
        //
        pUpdateTableWorkItem   = ALLOC_NONPAGED (sizeof(NIC_WORK_ITEM), MTAG_WORKITEM); 

        if (pUpdateTableWorkItem !=NULL)
        {
     
            
            //
            // Set the Workitem
            //

            NdisInitializeWorkItem ( &pUpdateTableWorkItem->NdisWorkItem, 
                                  (NDIS_PROC)nicVerifyEuidMapWorkItem,
                                  (PVOID)pAdapter );

            pUpdateTableWorkItem->RequestInfo.pNdisRequest = pRequest;
                                  
            NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

            NdisScheduleWorkItem (&pUpdateTableWorkItem->NdisWorkItem);

            //
            // Only code path that pends the request  -because of the workitem       
            //
            Status = NDIS_STATUS_PENDING;
        }
        else
        {
                         
            //
            //  Allocation failure - We report the results without verifying them.
            //

            ADAPTER_ACQUIRE_LOCK(pAdapter);


            pRemoteNodeList = ListNext (&pAdapter->PDOList);

            //
            // Walk through the entire list and fire of a request for each RemoteNode
            // The lock will ensure that the list is valid
            //
            
            while (pRemoteNodeList != &pAdapter->PDOList)
            {
                USHORT NodeNumber;

                pEuidMap->NumberOfRemoteNodes++;

                pRemoteNode = CONTAINING_RECORD (pRemoteNodeList, REMOTE_NODE, linkPdo);

                pRemoteNodeList = ListNext (pRemoteNodeList);

                NodeNumber = pRemoteNode->RemoteAddress.NA_Node_Number;

                pEuidMap->Node[NodeNumber].Euid = pRemoteNode->UniqueId;
                pEuidMap->Node[NodeNumber].ENetAddress = pRemoteNode->ENetAddress;

            }  //while (pRemoteNodeList != &pAdapter->PDOList)


            
            ADAPTER_RELEASE_LOCK (pAdapter);

            //
            // This thread completes the request with possibly stale data.
            //
            break;

    
        }

    }while (FALSE);


    if (NDIS_STATUS_PENDING != Status)
    {
        NdisMCoRequestComplete(Status,
                              pAdapter->MiniportAdapterHandle,
                              pRequest);

    }

}


NDIS_STATUS
nicSetPower (
    IN PADAPTERCB pAdapter,
    IN NET_DEVICE_POWER_STATE DeviceState
    )
/*++

Routine Description:

    if PowerState is LowPower, then we 
    1) there are no outstanding VCs or AFs open in the miniport
    2) free the Broadcast Channel Register,

    If the PowerState is On, then 
    1) we reallocate the BroadcastChannel Register
    2) if we are in bridge mode, Start the Arp module 
    
Arguments:


Return Value:


--*/
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    switch (DeviceState)
    {
        case NetDeviceStateD0:
        {
            //
            //  Initialize the BCM so it is ready to handle Resets
            //
            
            ADAPTER_CLEAR_FLAG(pAdapter, fADAPTER_LowPowerState);

            NdisStatus = nicInitializeBroadcastChannelRegister (pAdapter); 

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                nicFreeBroadcastChannelRegister(pAdapter);
                break;
            }
            

            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

            nicScheduleBCMWorkItem (pAdapter);

            //
            // If we are in bridge mode, then start the arp module
            //
            if (ADAPTER_TEST_FLAG (pAdapter, fADAPTER_BridgeMode) == TRUE)
            {
                nicQueueRequestToArp(pAdapter, BindArp, NULL);
            }

            //
            // Re-initialize the Reassembly Timer
            //
            nicInitSerializedReassemblyStruct(pAdapter); // cannot fail
    
            NdisStatus = NDIS_STATUS_SUCCESS;
           
        }
        break;
        case NetDeviceStateD1:
        case NetDeviceStateD2:
        case NetDeviceStateD3:
        {

            
            //
            // Free the Broadcast Channel Register
            // 
            nicFreeBroadcastChannelRegister(pAdapter);

            //
            // Wait for the Free to complete.
            //
            NdisWaitEvent (&pAdapter->BCRData.BCRFreeAddressRange.NdisEvent,0);
            NdisResetEvent (&pAdapter->BCRData.BCRFreeAddressRange.NdisEvent);

            

            ADAPTER_SET_FLAG(pAdapter, fADAPTER_LowPowerState);

            //
            // ReStart any pending broadcast channel make calls 
            //
            pAdapter->BCRData.MakeCallWaitEvent.EventCode = nic1394EventCode_FreedAddressRange;
            NdisSetEvent (&pAdapter->BCRData.MakeCallWaitEvent.NdisEvent);


            //
            //  Wait for Outstanding WorItems and timers
            //
            nicDeInitSerializedReassmblyStruct(pAdapter);

            while (pAdapter->OutstandingWorkItems  != 0) 
            {

                NdisMSleep (10000);                       

            } 
            

            NdisStatus = NDIS_STATUS_SUCCESS;

        }
        break;

        default:
        {
            ASSERT (0);
            break;
        }

    }

    ASSERT (NDIS_STATUS_SUCCESS == NdisStatus);
    pAdapter->PowerState = DeviceState;

    return NdisStatus;




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\nt.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// nt.c
//
// IEEE1394 mini-port/call-manager driver
//
// Main routine (DriverEntry) and global data definitions
//
//	12/28/98	adube
//	9/5/99		alid: added callback registeration and interface to enum1394
//



#include "precomp.h"
//-----------------------------------------------------------------------------
// Local prototypes
//-----------------------------------------------------------------------------

extern NDIS_SPIN_LOCK g_DriverLock;
extern LIST_ENTRY g_AdapterList;

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
NicUnloadHandler(
	IN	PDRIVER_OBJECT			DriverObject
	);


// Mark routine to be unloaded after initialization.
//
#pragma NDIS_INIT_FUNCTION(DriverEntry)


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath )


/*++

Routine Description:

     Standard 'DriverEntry' driver initialization entrypoint called by the
     I/0 system at IRQL PASSIVE_LEVEL before any other call to the driver.
    
     On NT, 'DriverObject' is the driver object created by the I/0 system
     and 'RegistryPath' specifies where driver specific parameters are
     stored.  These arguments are opaque to this driver (and should remain
     so for portability) which only forwards them to the NDIS wrapper.
    
     Returns the value returned by NdisMRegisterMiniport, per the doc on
     "DriverEntry of NDIS Miniport Drivers".
    

Arguments:


Return Value:


--*/
    
{
    NDIS_STATUS 					NdisStatus;
    NTSTATUS                        NtStatus = STATUS_SUCCESS;
    NDIS_MINIPORT_CHARACTERISTICS	nmc;
    NDIS_HANDLE						NdisWrapperHandle;
	UNICODE_STRING					CallbackObjectName;
	OBJECT_ATTRIBUTES				ObjectAttr;
	BOOLEAN							fDerefCallbackObject = FALSE, fDeregisterCallback = FALSE;

    TRACE( TL_I, TM_Init, ( " Nic1394 - DriverEntry" ) );

	do
	{
		g_ulMedium = NdisMedium802_3; 


	    // Register  this driver with the NDIS wrapper.  This call must occur
	    // before any other NdisXxx calls.
	    //
	    NdisMInitializeWrapper(
	        &NdisWrapperHandle, DriverObject, RegistryPath, NULL );

	  
	    // Set up the mini-port characteristics table that tells NDIS how to call
	    // our mini-port.
	    //
	    NdisZeroMemory( &nmc, sizeof(nmc) );

	    nmc.MajorNdisVersion = NDIS_MajorVersion;
	    nmc.MinorNdisVersion = NDIS_MinorVersion;


	    // nmc.CheckForHangHandler = CheckForHang;
	    // no DisableInterruptHandler
	    // no EnableInterruptHandler
	    nmc.HaltHandler = NicMpHalt;
	    // no HandleInterruptHandler
	    nmc.InitializeHandler = NicMpInitialize;
	    // no ISRHandler
	    // no QueryInformationHandler (see CoRequestHandler)
	    nmc.ResetHandler = NicMpReset;
	    // no SendHandler (see CoSendPacketsHandler)
	    // no WanSendHandler (see CoSendPacketsHandler)
	    // no SetInformationHandler (see CoRequestHandler)
	    // no TransferDataHandler
	    // no WanTransferDataHandler
	    // nmc.ReturnPacketHandler = NicMpReturnPacket;
	    // no SendPacketsHandler (see CoSendPacketsHandler)
	    // no AllocateCompleteHandler
	    nmc.CoActivateVcHandler = NicMpCoActivateVc;
	    nmc.CoDeactivateVcHandler= NicMpCoDeactivateVc;
	    nmc.CoSendPacketsHandler = NicMpCoSendPackets;
	    nmc.CoRequestHandler = NicMpCoRequest;
	    nmc.ReturnPacketHandler = NicReturnPacket;

		nmc.QueryInformationHandler = NicEthQueryInformation;
		nmc.SetInformationHandler = NicEthSetInformation;
		nmc.SendPacketsHandler = NicMpSendPackets;


		//
		// Create a dummy device object
		//
	    // Register this driver as the IEEE1394 mini-port.  This will result in NDIS
	    // calling back at NicMpInitialize.
	    //

	    TRACE( TL_V, TM_Init, ( "NdisMRegMp" ) );
	    NdisStatus = NdisMRegisterMiniport( NdisWrapperHandle, &nmc, sizeof(nmc) );
	    TRACE( TL_A, TM_Init, ( "NdisMRegMp=$%x", NdisStatus ) );

         //

	    if (NdisStatus == NDIS_STATUS_SUCCESS)
	    {
	        {
	            extern CALLSTATS g_stats;
	            extern NDIS_SPIN_LOCK g_lockStats;

	            NdisZeroMemory( &g_stats, sizeof(g_stats) );
	            NdisAllocateSpinLock( &g_lockStats );
	        }
	        
	        // Initialize driver-wide lock and adapter list.
	        //
	        {

	            NdisAllocateSpinLock( &g_DriverLock );
	            InitializeListHead( &g_AdapterList );
			}

			NdisMRegisterUnloadHandler(NdisWrapperHandle, NicUnloadHandler);


			//
			// create a named Callback object with os
			// then register a callback routine with send a notification to all modules that
			// have a Callback routine registered with this function
			// if enum1394 is already loaded, this will let it know the nic driver is loaded
			// the enum1394 will get the driver registeration entry points from the notification
			// callback and calls NicRegisterDriver to pass the enum entry points
			// if enum1394 is not loaded and gets loaded later, it will send a notication to modules
			// who have registered with this callback object and passes its own driver registeration
			// the purpose of passign the entry points this way vs. exporting them, is to avoid
			// getting loaded as a DLL which fatal for both nic1394 and enum1394
			//

			//
			// every Callback object is identified by a name.
			//
			RtlInitUnicodeString(&CallbackObjectName, NDIS1394_CALLBACK_NAME);

			InitializeObjectAttributes(&ObjectAttr,
									   &CallbackObjectName,
									   OBJ_CASE_INSENSITIVE | OBJ_PERMANENT | OBJ_KERNEL_HANDLE ,
									   NULL,
									   NULL);
									   
			NtStatus = ExCreateCallback(&Nic1394CallbackObject,
										&ObjectAttr,
										TRUE,			// allow creating the object if it does not exist
										TRUE);			// allow mutiple callback registeration

			
			if (!NT_SUCCESS(NtStatus))
			{
			    TRACE( TL_A, TM_All, ("Nic1394 DriverEntry: failed to create a Callback object. Status %lx\n", NtStatus));
				NtStatus = STATUS_UNSUCCESSFUL;
				break;
			}

			fDerefCallbackObject = TRUE;
			
			Nic1394CallbackRegisterationHandle = ExRegisterCallback(Nic1394CallbackObject,
																	Nic1394Callback,
																	(PVOID)NULL);
			if (Nic1394CallbackRegisterationHandle == NULL)
			{
				TRACE(TL_A, TM_All, ("Nic1394 DriverEntry: failed to register a Callback routine%lx\n"));
				NtStatus = STATUS_UNSUCCESSFUL;
				break;
			}
							   
			fDeregisterCallback = TRUE;

			//
			// now notify enum1394 (if it is already loaded) use Arg1 to tell it where
			// the notification is coming from
			//
			ExNotifyCallback(Nic1394CallbackObject,
							(PVOID)NDIS1394_CALLBACK_SOURCE_NIC1394,
							(PVOID)&Nic1394Characteristics);


			NtStatus = STATUS_SUCCESS;
			fDerefCallbackObject = fDeregisterCallback = FALSE;
	    }
	    else
	    {
	        NdisTerminateWrapper( NdisWrapperHandle, NULL );
	        NtStatus = NdisStatus;
	        break;
	    }
	} while (FALSE);


	if (fDerefCallbackObject)
	{
		ObDereferenceObject(Nic1394CallbackObject);
	}

	if (fDeregisterCallback)
	{
		ExUnregisterCallback(Nic1394CallbackRegisterationHandle);
	}
	
	if (NtStatus != STATUS_SUCCESS)
	{
		if (NdisEnum1394DeregisterDriver != NULL)
			NdisEnum1394DeregisterDriver();
	}
	
    return NtStatus;
}







VOID
NicUnloadHandler(
	IN	PDRIVER_OBJECT			DriverObject
	)

/*++

Routine Description:

 The unload Handler undos all the work in Driver Entry
 We Deregister with Enum1394 and the kernel

 
Arguments:


Return Value:


--*/
{
	ASSERT(IsListEmpty(&g_AdapterList));

    UNREFERENCED_PARAMETER(DriverObject);

	if (NdisEnum1394DeregisterDriver != NULL)
	{
		NdisEnum1394DeregisterDriver();
	}

	if (Nic1394CallbackRegisterationHandle != NULL)
	{
		ExUnregisterCallback(Nic1394CallbackRegisterationHandle);
	}
	
	if (Nic1394CallbackObject != NULL)
	{
		ObDereferenceObject(Nic1394CallbackObject);
	}
	
	return;
}


VOID
nicDeregisterWithEnum ()

/*++

Routine Description:

    If we have not already deregistered with Enum1394, we do it now.

Arguments:


Return Value:


--*/
{

	if (NdisEnum1394DeregisterDriver != NULL)
	{
		NdisEnum1394DeregisterDriver();
	}


}


VOID 
nicDeregisterWithKernel ()

/*++

Routine Description:

    We deregister with the Kernel.

Arguments:


Return Value:


--*/
{

	if (Nic1394CallbackRegisterationHandle != NULL)
	{
		ExUnregisterCallback(Nic1394CallbackRegisterationHandle);
	}
	
	if (Nic1394CallbackObject != NULL)
	{
		ObDereferenceObject(Nic1394CallbackObject);
	}


}






//
// the registeration entry for enum1394
// typically this will be only called if enum1394 detects the presence of
// the nic1394 through receiving a call back notification. this is how enum1394
// lets nic1394 know that it is there and ready.
// if nic1394 detects the presence of the enum1394 by receiving a notification
// callbak, it will call NdisEunm1394RegisterDriver and in that case enum1394
// will -not- call Nic1394RegisterDriver.
//
NTSTATUS
NicRegisterEnum1394(
	IN	PNDISENUM1394_CHARACTERISTICS	NdisEnum1394Characteristcis
	)
{
	
	NdisEnum1394RegisterDriver = NdisEnum1394Characteristcis->RegisterDriverHandler;
	NdisEnum1394DeregisterDriver = NdisEnum1394Characteristcis->DeregisterDriverHandler;
	NdisEnum1394RegisterAdapter = NdisEnum1394Characteristcis->RegisterAdapterHandler;
	NdisEnum1394DeregisterAdapter = NdisEnum1394Characteristcis->DeregisterAdapterHandler;

	Nic1394RegisterAdapters();

	return STATUS_SUCCESS;

}

VOID
NicDeregisterEnum1394(
	VOID
	)
{
	PADAPTERCB	pAdapter;
	LIST_ENTRY	*pAdapterListEntry;

	//
	// go through all the adapters and Deregister them if necessary
	//
	NdisAcquireSpinLock (&g_DriverLock);

	for (pAdapterListEntry = g_AdapterList.Flink; 
		pAdapterListEntry != &g_AdapterList; 
		pAdapterListEntry = pAdapterListEntry->Flink)
	{
		pAdapter = CONTAINING_RECORD(pAdapterListEntry, 
		                             ADAPTERCB,
		                             linkAdapter);
		                             
		if (ADAPTER_TEST_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator))
		{
		    nicReferenceAdapter(pAdapter,"NicDeregisterEnum1394");
			NdisReleaseSpinLock(&g_DriverLock);

			NdisEnum1394DeregisterAdapter((PVOID)pAdapter->EnumAdapterHandle);
								   		   
			NdisAcquireSpinLock( &g_DriverLock);
			nicDereferenceAdapter(pAdapter, "NicDeregisterEnum1394");
			
		}
		
		ADAPTER_CLEAR_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator | fADAPTER_FailedRegisteration);
		
	}
	
	NdisReleaseSpinLock(&g_DriverLock);

	NdisEnum1394RegisterDriver = NULL;
	NdisEnum1394DeregisterDriver = NULL;
	NdisEnum1394RegisterAdapter = NULL;
	NdisEnum1394DeregisterAdapter = NULL;
}

VOID
Nic1394Callback(
	PVOID	CallBackContext,
	PVOID	Source,
	PVOID	Characteristics
	)
{
	NTSTATUS	Status;
	UNREFERENCED_PARAMETER(CallBackContext);
	//
	// if we are the one issuing this notification, just return
	//
	if (Source == (PVOID)NDIS1394_CALLBACK_SOURCE_NIC1394)
		return;

	//
	// notification is coming from Nic1394. grab the entry points. call it and
	// let it know that you are here
	//
	ASSERT(Source == (PVOID)NDIS1394_CALLBACK_SOURCE_ENUM1394);

	if (Source != (PVOID)NDIS1394_CALLBACK_SOURCE_ENUM1394)
	{
		return;
	}

	NdisEnum1394RegisterDriver = ((PNDISENUM1394_CHARACTERISTICS)Characteristics)->RegisterDriverHandler;

	ASSERT(NdisEnum1394RegisterDriver != NULL);

	if (NdisEnum1394RegisterDriver == NULL)
	{
		//
		// invalid characteristics
		//
		return;		
	}

	
	Status = NdisEnum1394RegisterDriver(&Nic1394Characteristics);
	
	if (Status == STATUS_SUCCESS)
	{
		NdisEnum1394DeregisterDriver = ((PNDISENUM1394_CHARACTERISTICS)Characteristics)->DeregisterDriverHandler;
		NdisEnum1394RegisterAdapter = ((PNDISENUM1394_CHARACTERISTICS)Characteristics)->RegisterAdapterHandler;
		NdisEnum1394DeregisterAdapter = ((PNDISENUM1394_CHARACTERISTICS)Characteristics)->DeregisterAdapterHandler;
		
		Nic1394RegisterAdapters();
	}
	else
	{
		NdisEnum1394RegisterDriver = NULL;
	}
	
}

//
// This function walks the global list of the adapters and 
// will register those that have not been registered with enum1394
//
VOID
Nic1394RegisterAdapters(
	VOID
	)
{
	PADAPTERCB		pAdapter;
	LIST_ENTRY		*pAdapterListEntry;
	LARGE_INTEGER	LocalHostUniqueId;
	NTSTATUS		NtStatus;
	
	//
	// go through all the adapters and register them if necessary. if there are
	// any remote nodes connected to these adapters, they will be indicated back
	// in the context of registering the adapter
	//
	NdisAcquireSpinLock(&g_DriverLock);

	for (pAdapterListEntry = g_AdapterList.Flink; 
		 pAdapterListEntry != &g_AdapterList; 
		 pAdapterListEntry = pAdapterListEntry->Flink)
	{
		pAdapter = CONTAINING_RECORD(pAdapterListEntry, 
		                             ADAPTERCB,
		                             linkAdapter);
		                             
		if (!ADAPTER_TEST_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator | fADAPTER_FailedRegisteration))
		{
		    nicReferenceAdapter (pAdapter, "Nic1394RegisterAdapters");
			NdisReleaseSpinLock (&g_DriverLock);

			NtStatus = NdisEnum1394RegisterAdapter((PVOID)pAdapter,
													pAdapter->pNextDeviceObject,
													&pAdapter->EnumAdapterHandle,
													&LocalHostUniqueId);
								   		   
			NdisAcquireSpinLock(&g_DriverLock);
			nicDereferenceAdapter(pAdapter, "Nic1394RegisterAdapters");
			
			if (NtStatus == STATUS_SUCCESS)
			{
				ADAPTER_SET_FLAG(pAdapter, fADAPTER_RegisteredWithEnumerator);
			}
			else
			{
				ADAPTER_SET_FLAG(pAdapter, fADAPTER_FailedRegisteration);
			    TRACE(TL_A, TM_All, ("Nic1394RegisterAdapters: failed to register Adapter %lx with enum1394. Status %lx\n", pAdapter, NtStatus));
			}
		}
		
	}
	
	NdisReleaseSpinLock(&g_DriverLock);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\precomp.h ===
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// precomp.h
// IEEE 1394 NDIS mini-port/call-manager driver
//
//  Precompiled common header.
//
// 12/28/1998 JosephJ
//
//

#include <ccdefs.h>
#include <ndis.h>
#include <ndistapi.h>
#include <1394.h>
#include <ndis1394.h>
#include <nic1394.h>
#include <nicarp.h>
#include "a13ioctl.h"
#include "debug.h"
#include "pktlog.h"
#include "priv.h"
#include "mp.h"
#include "cm.h"
#include "send.h"
#include "receive.h"
#include "irp.h"
#include "bcm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\priv.h ===
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// priv.h
//
// IEEE 1394 NDIS mini-port/call-manager driver
//
// Main private header
//
// 12/28/1998 JosephJ Created (adapted from the l2tp project)
//
//


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------


extern ULONG  g_IsochTag;
extern LONG  g_ulMedium;
extern ULONGLONG g_ullOne;


//
// Add checks for #defines that are meant for special purposes and 
// should not be turned on for general use
//
#ifdef PKT_LOG
    #error
#endif 

//-----------------------------------------------------------------------------
// Advance Declarations and simple typedefs
//-----------------------------------------------------------------------------



// Forward declarations.
//
typedef union _VCCB VCCB;
typedef struct _ADAPTERCB ADAPTERCB, *PADAPTERCB;
typedef struct _RECVFIFO_VCCB RECVFIFO_VCCB, *PRECVFIFO_VCCB;
typedef struct _ETHERNET_VCCB ETHERNET_VCCB, *PETHERNET_VCCB;
typedef struct _RECV_FIFO_DATA  RECV_FIFO_DATA, *PRECV_FIFO_DATA;
typedef struct _ISOCH_DESCRIPTOR ISOCH_DESCRIPTOR, *PISOCH_DESCRIPTOR, **PPISOCH_DESCRIPTOR;
typedef struct _TOPOLOGY_MAP TOPOLOGY_MAP, *PTOPOLOGY_MAP, **PPTOPOLOGY_MAP;
typedef struct _CHANNEL_VCCB CHANNEL_VCCB, *PCHANNEL_VCCB;
typedef struct _GASP_HEADER GASP_HEADER;
typedef struct _NDIS1394_FRAGMENT_HEADER NDIS1394_FRAGMENT_HEADER, *PNDIS1394_FRAGMENT_HEADER;
typedef struct _NDIS1394_REASSEMBLY_STRUCTURE NDIS1394_REASSEMBLY_STRUCTURE, *PNDIS1394_REASSEMBLY_STRUCTURE;
typedef struct _REMOTE_NODE REMOTE_NODE, *PREMOTE_NODE;
typedef union  _NDIS1394_UNFRAGMENTED_HEADER NDIS1394_UNFRAGMENTED_HEADER, *PNDIS1394_UNFRAGMENTED_HEADER;
typedef union  _NIC_WORK_ITEM NIC_WORK_ITEM, *PNIC_WORK_ITEM;


#define NIC1394_STATUS_INVALID_GENERATION  ((NDIS_STATUS)STATUS_INVALID_GENERATION)

//-----------------------------------------------------------------------------
// Data types
//-----------------------------------------------------------------------------


//
// This is a table of the Remote nodes and it is used to keep a track of the number of nodes
// on the bus. To stop overflows, yhis structure is usally accessed by 
// NODE_ADDRESS.NA_Node_Number which is a 6 bit entity. 
//
typedef struct _NODE_TABLE
{
    PREMOTE_NODE RemoteNode[NIC1394_MAX_NUMBER_NODES];  

} NODE_TABLE, *PNODE_TABLE;



typedef struct _GASP_HEADER 
{
    union 
    {
        //
        // Ist Quadlet
        //
        struct 
        {
            ULONG               GH_Specifier_ID_Hi:16;  
            ULONG               GH_Source_ID:16;        

        } Bitmap;

        struct 
        {
            USHORT              GH_Specifier_ID_Hi;
            USHORT              GH_Source_ID;

        } u;

        struct 
        {
            USHORT              GH_Specifier_ID_Hi;
            NODE_ADDRESS        GH_NodeAddress;             
        } u1;
        
        ULONG GaspHeaderHigh;

    } FirstQuadlet; 

    union 
    {    
        struct
        {
            ULONG               GH_Version:24;          // Bits 0-23
            ULONG               GH_Specifier_ID_Lo:8;   //Bits 24-31

        } Bitmap;
        
        ULONG GaspHeaderLow;

    } SecondQuadlet;
    
} GASP_HEADER, *PGASP_HEADER;


//
// The Ndis miniport's wrapper around the Packet Pool
//
typedef struct _NIC_PACKET_POOL
{
    ULONG AllocatedPackets;

    NDIS_HANDLE Handle;


} NIC_PACKET_POOL, *PNIC_PACKET_POOL;


//
// The Ndis miniport's wrapper around the Packet Pool
//
typedef struct _NIC_BUFFER_POOL
{
    ULONG AllocatedBuffers;

    NDIS_HANDLE Handle;


} NIC_BUFFER_POOL, *PNIC_BUFFER_POOL;



//
// The structure that defines the lookaside list used by this miniport
//
typedef struct _NIC_NPAGED_LOOKASIDE_LIST 
{
    //
    // The lookaside list structure
    //
    NPAGED_LOOKASIDE_LIST   List;   

    //
    // The size of an individual buffer
    //
    
    ULONG Size;

    //
    // Outstanding Fragments - Interlocked access only
    //
    ULONG OutstandingPackets;

    //
    // Lookaside Lists are used for sends. So this is a maximum 
    // send packet size that this lookaside list can handle
    //
    ULONG MaxSendSize;
    
} NIC_NPAGED_LOOKASIDE_LIST , *PNIC_NPAGED_LOOKASIDE_LIST ;



//
// Structure used for references, Adapted from Ndis
// The Event will be signalled when the refcount goes down to zero
// The filed closing signifies that the object that the reference belongs to is
// closing and it;s refernces will not be incremented anymore
//
typedef struct _REF
{
//  NDIS_SPIN_LOCK              SpinLock;
    ULONG                       ReferenceCount;
    BOOLEAN                     Closing;
    NDIS_EVENT                  RefZeroEvent;
} REF, * PREF;

typedef enum  _EVENT_CODE 
{
    Nic1394EventCode_InvalidEventCode,
    Nic1394EventCode_NewNodeArrived,
    nic1394EventCode_BusReset,
    nic1394EventCode_FreedAddressRange,
    nic1394EventCode_ReassemblyTimerComplete,
    nic1394EventCode_QueryPowerLowPower


} EVENT_CODE, *PEVENT_CODE;

typedef struct _NIC1394_EVENT
{
    NDIS_EVENT NdisEvent;
    EVENT_CODE EventCode;
    
} NIC1394_EVENT, *PNIC1394_EVENT;


typedef ENetAddr MAC_ADDRESS, *PMAC_ADDRESS;


//
// nic Spin lock structure. Keeps track of the file and line numer 
// that last touched the lock
//


#define LOCK_FILE_NAME_LEN              48


typedef struct _NIC_SPIN_LOCK
{
#ifdef TRACK_LOCKS 
        ULONG                   IsAcquired;   // Internal tracking of lock state
        PKTHREAD                OwnerThread; // thread that has the lock
        UCHAR                   TouchedByFileName[LOCK_FILE_NAME_LEN]; // File name which called Acquire Lock
        ULONG                   TouchedInLineNumber; // Line Number in the file
#endif

        NDIS_SPIN_LOCK          NdisLock;  // Actual Lock

} NIC_SPIN_LOCK, *PNIC_SPIN_LOCK;

//
// Statistics Structure - to be collected on a per adapter basis
//
typedef struct _NIC_SEND_RECV_STATS
{
    ULONG ulSendNicSucess;
    ULONG ulSendBusSuccess;
    ULONG ulSendBusFail;
    ULONG ulSendNicFail;
    ULONG ulRecv;


} NIC_SEND_RECV_STATS;


//
// These are stats that can be reset
//
typedef struct _RESETTABLE_STATS
{
    ULONG ulNumOutstandingReassemblies;
    ULONG ulMaxOutstandingReassemblies;
    ULONG ulAbortedReassemblies;
    ULONG ulNumResetsIssued ;
    ULONG ulNumSends;
    ULONG ulNumSendsCompleted;
    ULONG ulNumBusSends;
    ULONG ulNumBusSendsCompleted;
    NIC_SEND_RECV_STATS Fifo;
    NIC_SEND_RECV_STATS Channel;
    
    
} RESETTABLE_STATS, *PRESETTABLE_STATS;

typedef struct _ADAPT_STATS
{
    ULONG ulXmitOk;
    ULONG ulXmitError ;
    ULONG ulRcvOk  ;
    ULONG ulRcvError ;
    ULONG ulNumResetsIssued ;
    ULONG ulNumResetCallbacks ;
    ULONG ulBCMIterations ;
    ULONG ulNumRemoteNodes;
    ULONG ulResetTime;
    RESETTABLE_STATS TempStats;
    
} ADAPT_STATS,  *PADAPT_STATS; 

//
// Can be used to keep data in buckets of 10
//


typedef struct _STAT_BUCKET
{

    ULONG Bucket[16];


} STAT_BUCKET, *PSTAT_BUCKET;


//
// Generic structure to be used to serialize send and receives, workitems
//

typedef struct _NIC_SERIALIZATION
{
    UINT                PktsInQueue;        // Number of packets in queue.
    BOOLEAN             bTimerAlreadySet;
    BOOLEAN             bInitialized;
    USHORT              usPad;
    LIST_ENTRY          Queue;  // Serialized by adapter lock.

    union {
    NDIS_MINIPORT_TIMER Timer;
    NDIS_WORK_ITEM      WorkItem;
    };
    
    NIC1394_EVENT	CompleteEvent;
    
} NIC_SERIALIZATION, *PNIC_SERIALIZATION;



//
// Each request to allocate and address range 
// returns certain values that need to be stored for the 
// request to free the address range. This structure contains 
// those values
//

typedef struct _ADDRESS_RANGE_CONTEXT
{

    //
    // Handle returned by the bus driver
    //
    HANDLE hAddressRange;

    //
    // Address Range returnded by the bus driver
    //
    ADDRESS_RANGE AddressRange;

    //
    // Number of Address returned from the call to 
    // allocate address range
    // 
    ULONG AddressesReturned;

    //
    // Mdl used in allocate address range . can be NULL
    //
    PMDL pMdl;

} ADDRESS_RANGE_CONTEXT, *PADDRESS_RANGE_CONTEXT;



// This structure is the Per Pdo/ per RecvFIFOVc structure. 
// This will be included in every Pdo Strcuture. And should contain  
// the fields that are related to the recvFifo and the Pdo block
// 
typedef struct _RECV_FIFO_DATA
{
    //
    // Indicates whether the address range was allocated regardless of the Make
    // Call State (pending or success)
    // 
    BOOLEAN AllocatedAddressRange;
    
    //
    // Recv Vc's related  data structures
    //
    ADDRESS_RANGE   VcAddressRange;

    // The Bus Driver's Handle to the Address ranges that  
    // the Nic was allocated
    //
    HANDLE hAddressRange;

    // This is the number of address ranges that the bus driver
    // returned. For now, it is expected to be one.
    //
    UINT AddressesReturned;

    // The Recv Fifo Vc that this structure is associated with
    //  
    PRECVFIFO_VCCB pRecvFIFOVc;

    // The Pdo Associated with this structure
    //
    //DEVICE_OBJECT *pPdo;

} RECV_FIFO_DATA, *PRECV_FIFO_DATA;


//
// Flags for the Broadcast Channel
//
#define BCR_LocalHostIsIRM          0x00000001
#define BCR_ChannelAllocated        0x00000002
#define BCR_LocalHostBCRUpdated     0x00000004
#define BCR_MakeCallPending         0x00000008
#define BCR_Initialized             0x00000010
#define BCR_BCMFailed               0x00000020  // Informational purposes only . Do not Test or REad
#define BCR_InformingRemoteNodes    0x00000040
#define BCR_BCMInProgress           0x00000100
#define BCR_LastNodeRemoved         0x00000200
#define BCR_Freed                   0x00000400
#define BCR_BCRNeedsToBeFreed       0x00000800
#define BCR_NewNodeArrived          0x00001000
#define BCR_NoNodesPresent          0x00002000

//
// This is information useful in maintaining the BCR
// Broadcast Channels Register.
//

typedef struct _BROADCAST_CHANNEL_DATA
{

    //
    // Flags
    //
    ULONG Flags;

    //
    // IRM;s BCR. This is the actual record of the bus's IRM. And is meant to indicate the current state 
    //
    NETWORK_CHANNELSR IRM_BCR;

    
    //
    // Broadcast Channels Register for the local host. This is the one a remote node will write to and read from
    // pLocalBcRMdl points to this structure . This is Byteswapped to reppresent the BigEndian 1394 Bus Format
    //
    ULONG LocalHostBCRBigEndian;


    //
    // Mdl pointing to Local Host BCR. Other machines will write to this MDL.
    //
    PMDL pLocalBCRMdl;  


    //
    // Data pointed to by the pRemoteBCRMdl and will copied to IRM_BCR. The data that will be read will
    // be in the BigEndian format Pointed to by RemoteBCRMDl
    //
    ULONG RemoteBCRMdlData;
    
    //
    // MDL pointing to Remote Nodes' BCR. This will be used in reading other machine's 
    // BCR. This points to the RemoteBCRMdlData
    //
    
    PMDL pRemoteBCRMdl;

    //
    // Make a copy of the BCR that is used in informing other nodes 
    // about this node's BCR when the local node is the IRM
    //
    ULONG AsyncWriteBCRBigEndian;

    PMDL pAsyncWriteBCRMdl;

    
    //
    // Local Node Address. This changes from Reset to Reset  
    //
    NODE_ADDRESS LocalNodeAddress;


    ULONG LocalNodeNumber;

    //
    // Address Range Context needed for Broadcast Channels
    // Register
    //
    ADDRESS_RANGE_CONTEXT AddressRangeContext;

    //
    // Topology Buffer
    //
    PTOPOLOGY_MAP               pTopologyMap;

    //
    // Event that the Make call will pend on for completion of the BCM 
    //
    NIC1394_EVENT MakeCallWaitEvent;

    //
    // BoadcastChannelVc
    //
    PCHANNEL_VCCB pBroadcastChanneVc;

    //
    // Locally Allocated Channel Num. Is only valid when the 
    //
    ULONG LocallyAllocatedChannel;

    //
    // The Generation at which the IRM was set. This can then be used to check the 
    // validity of the IRM

    ULONG IrmGeneration;

    //
    // Event To specify that a new node has come in and waiting threads can continue
    //
    NIC1394_EVENT BCRWaitForNewRemoteNode;

    //
    // Event to synchronize the shutting down of the adapter and freeing the address range
    //
    NIC1394_EVENT BCRFreeAddressRange;
    
} BROADCAST_CHANNEL_DATA, *PBROADCAST_CHANNEL_DATA;




//
// Flags for the PDO Control Block
//
#define PDO_NotValid                            0x00000001
#define PDO_Activated                           0x00000002 
#define PDO_Removed                             0x00000004
#define PDO_BeingRemoved                        0x00000008
#define PDO_AllocateAddressRangeFailure         0x00000010
#define PDO_AllocateAddressRangeSucceeded       0x00000020
#define PDO_AddressRangeFreed                   0x00000040
#define PDO_AllocateAddressRangeFlags           0x000000F0
#define PDO_ResetRegistered                     0x00000100
#define PDO_NotInsertedInTable                  0x00000200  // Informational purposes


typedef struct  
_REMOTE_NODE
{
    // The Tag should MTAG_REMOTE_NODE
    //
    
    ULONG ulTag;

    //
    // The Vurrent Node Address
    //
    NODE_ADDRESS RemoteAddress;

    //
    // Ushort Gap 
    //
    USHORT Gap;
    
    // The PDO itself
    //
    
    PDEVICE_OBJECT pPdo;

    // This is the pointer to the next field in the PDO
    //
    LIST_ENTRY linkPdo;

    // 64 bit Unique Id associated with a 1394 Node
    //
    UINT64 UniqueId;

    //
    // Enum1394 handle for the node
    //
    PVOID Enum1394NodeHandle;


    // flags can be one of the following. Essentially marks the PDO as 
    // good or bad
    //  
    ULONG ulFlags;

    // Back link to the Adapter that PDO hangs off
    //
    PADAPTERCB pAdapter;

    // The refcount associated with the Pdo
    //
    REF Ref;

    // This is the linked list of VCs, that are using the Pdo to preform
    //
    LIST_ENTRY VcList;

    // All the fields that are related to the Recv Fifo are present in this
    // structure
    //
    RECV_FIFO_DATA RecvFIFOData;

    //
    // Lock to synchronize all the reassembly operations in the Node
    //
    NIC_SPIN_LOCK ReassemblyLock;
    
    //
    // Linked list of Reassembly Structure 
    //
    LIST_ENTRY ReassemblyList;

    // This structure maintains cached information about the remote node.
    //
    struct
    {
        UINT SpeedTo;                     // From GetMaxSpeedBetweenNodes.
        UINT MaxRec;                      // From the node's config ROM.
        UINT EffectiveMaxBufferSize;      // Computed from the SpeedTo, MaxRec,
                                          // and local speed.

    } CachedCaps;

    //
    // Ethernet Address - to be used by the bridge to recognize packets
    // originating from this node. An MD5 Signature of the Euid
    //
    ENetAddr ENetAddress;

}
REMOTE_NODE, *PREMOTE_NODE, **PPREMOTE_NODE;

//
// These flags are common to the Adapter 
//

//
//fADAPTER_IndicatedMediaDisonnect  - indicateds that the miniport has already
//                                    called NdisMIndicateStatus
//

#define fADAPTER_Halting                        0x00000001
#define fADAPTER_RegisteredWithEnumerator       0x00000002
#define fADAPTER_FailedRegisteration            0x00000004
#define fADAPTER_IndicatedMediaDisonnect        0x00000008
#define fADAPTER_InvalidGenerationCount         0x00000010
//#define fADAPTER_BCMWorkItem                  0x00000020
#define fADAPTER_RegisteredAF                   0x00000040
#define fADAPTER_Reset10Sec                     0x00000080
#define fADAPTER_FailedInit                     0x00000100
#define fADAPTER_VDOInactive                    0x00000200
#define fADAPTER_FreedRcvTimers                 0x00001000  // debugging purposes
#define fADAPTER_FreedTimers                    0x00002000  // debugging purposes
#define fADAPTER_DeletedLookasideLists          0x00004000  // debugging purposes
#define fADAPTER_UpdateNodeTable                0x00008000  // set if no remote node for reassembly
#define fADAPTER_DoStatusIndications            0x00010000  // if set, call NdisMIndicateStatus 
#define fADAPTER_DeletedWorkItems               0x00100000  // debugging purposes
#define fADAPTER_NoMoreReassembly               0x00200000
#define fADAPTER_RemoteNodeInThisBoot           0x00400000  //was a remote node in this boot
#define fADAPTER_BridgeMode                     0x00800000  // is the Adapter in bridge mode
#define fADAPTER_LowPowerState                  0x01000000  // adapter is in low power state

// Adapter control block defining the state of a single L2TP mini-port
// adapter.  An adapter commonly supports multiple VPN devices.  Adapter
// blocks are allocated in MiniportInitialize and deallocated in MiniportHalt.
//
typedef struct
_ADAPTERCB
{
    // Set to MTAG_ADAPTERCB for easy identification in memory dumps and use
    // in assertions.
    //
    ULONG ulTag;

    // Next/prev adapter control block.
    LIST_ENTRY linkAdapter;

    
    // ACBF_* bit flags indicating various options.  Access restrictions are
    // indicated for each individual flag.  Many of these flags are set
    // permanently at initialization and so have no access limitation.
    //
    //
    ULONG ulFlags;

    //
    // List of PDO control blocks, each representing a remote
    // device.
    //
    LIST_ENTRY PDOList;

    //
    // Reference count on this control block.  The reference pairs are:
    //
    //
    // Access is via ReferenceAdapter and DereferenceAdapter only.
    // Serialization is via interlocked operations.
    //
    LONG lRef;


    //
    // This is the adapter-wide lock, serializing access to everything except
    // to the contents of VCs, which are serialized by their own lock.
    //
    NDIS_SPIN_LOCK lock;

    //
    // Generation Count of the physical Bus 1394
    // 
    UINT Generation;

    
    //
    // NDIS's handle for this mini-port adapter passed to us in
    // MiniportInitialize.  This is passed back to various NdisXxx calls.
    //
    NDIS_HANDLE MiniportAdapterHandle;

    //
    // unique ID for the local host controller this adapter is representing
    //
    UINT64 UniqueId;

    //
    // List of address-family control blocks, each representing
    // an open address family binding.
    //
    LIST_ENTRY AFList;


    //
    // List of Recv-FIFO control blocks, each representing one
    // local receive FIFO.
    //
    PRECVFIFO_VCCB pRecvFIFOVc;

    //
    // This event is used to wake up the work Item that will complete
    // the RecvFIFO make call
    //
    NDIS_EVENT RecvFIFOEvent;

    //
    // The is the LocalHost information that is used in identifying 
    // the local host. This contains the PDO and the Unique ID 
    // for the Host and is a per Adapter quantity
    //
    PDEVICE_OBJECT pNextDeviceObject;
     
    // Stores information about the Hardware Status of the NIc
    //
    NDIS_HARDWARE_STATUS HardwareStatus;

    // Store the MediaConnectStatus that Ndis requests
    //

    NDIS_MEDIA_STATE                MediaConnectStatus;

    // NodeAddress of the physical bus  
    //
    NODE_ADDRESS NodeAddress;

    //
    // enum1394 handle for the adapter
    //
    PVOID   EnumAdapterHandle;

    //
    // BCR Related Information is stored here
    //
    BROADCAST_CHANNEL_DATA BCRData;

    //
    // Bitmap Channnels allocated by this adapter
    //
    ULONGLONG ChannelsAllocatedByLocalHost;

    //
    // Speed - of the local network
    //
    ULONG SpeedMbps;

    //
    // Speed according to the 1394 speed codes
    //
    ULONG Speed;

        
    //
    // Gasp header that will bew inserted before every Broadcast write
    //
    
    GASP_HEADER GaspHeader;

    //
    // Lookaside List to handle packets of 2k 
    //

    NIC_NPAGED_LOOKASIDE_LIST SendLookasideList2K;

    //
    // Small Lookaside list for packets less than 100 bytes
    //
    NIC_NPAGED_LOOKASIDE_LIST SendLookasideList100; 

    //
    // Datagram Label Number - used in fragmentation
    //
    ULONG dgl;

    USHORT MaxRec;
    USHORT Gap;
    //
    // Node Table - Mapping of Node Address with RemoteNodes
    //
    NODE_TABLE NodeTable;

    //
    // Number of remote nodes present 
    //
    ULONG NumRemoteNodes;
    //
    // Timer used for reassembly invalidation
    //
    NDIS_MINIPORT_TIMER ReassemblyTimer;

    //
    // Packet pool for loopback packets.
    //
    NIC_PACKET_POOL LoopbackPool;

    //
    // Buffer pool for loopback packets.
    //
    NDIS_HANDLE LoopbackBufferPool;


    //
    // Handle for the config rom that was added to the bus driver
    //
    HANDLE hCromData;

    //
    // WaitForRemoteNode - threads which need to wait for
    // the arrival of a remote node use this event
    //
    NIC1394_EVENT WaitForRemoteNode;


    //
    // Config Rom Mdl that points to the config rom string
    //
    PMDL pConfigRomMdl;

    PREMOTE_NODE pLastRemoteNode;
    
    //
    // Packet Log (used only for tracking packets).
    //
    PNIC1394_PKTLOG pPktLog;

    //
    // Per adapter stats 
    //
    ADAPT_STATS AdaptStats;
    //
    // Read/WriteCapabilities
    //
    GET_LOCAL_HOST_INFO2 ReadWriteCaps;

    //
    // SCode - speed of the bus
    //
    ULONG SCode;

    //
    // Max packet size that this adapter can read
    //
    ULONG MaxSendBufferSize; 
    ULONG MaxRecvBufferSize; 
    ULONG CurrentLookahead;

    //
    // PacketFilter - Ethernet structs
    //

    PETHERNET_VCCB pEthernetVc;
    ULONG           CurPacketFilter ;
    ULONG           ProtocolOptions;
    MAC_ADDRESS     McastAddrs[MCAST_LIST_SIZE];
    ULONG           McastAddrCount;
    ULONG           CurLookAhead ;
    MAC_ADDRESS     MacAddressEth;


    //
    // ReceivePacket Serialization
    //
    NIC_SERIALIZATION  SerRcv;

    NIC_SERIALIZATION SerSend;

    NIC_SERIALIZATION Status;

    NIC_SERIALIZATION Reassembly;

    NIC_SERIALIZATION LoadArp;

    // 
    // Outstanding work Items
    ULONG OutstandingWorkItems;

    //
    // Outstanding Reassemblies
    //
    ULONG OutstandingReassemblies; 

    //
    // Miniport Name
    //
    WCHAR AdapterName[ADAPTER_NAME_SIZE];

    //
    // Size of Name in Bytes
    //
    ULONG AdapterNameSize;

    //
    // Ioctl Sent to the Arp module
    //

    ARP1394_IOCTL_COMMAND ArpIoctl;

    //
    // Is Arp Started
    //

    BOOLEAN fIsArpStarted;

    //
    // Power State - informational use
    //
    NET_DEVICE_POWER_STATE PowerState;

    
} ADAPTERCB, *PADAPTERCB;


//
// Address Family Flags
//

#define ACBF_Allocated                      0x00000001
#define ACBF_Initialized                    0x00000002  
#define ACBF_ClosePending                   0x00000100
#define ACBF_CloseComplete                  0x00000200


// Address family control block, describing the state of an ndis address family.
// Each block may have zero or more VCs associated with it.
//
typedef struct
_AFCB
{
    // Set to MTAG_AFCB for easy identification in memory dumps and use in
    // assertions.
    //
    ULONG ulTag;

    // ACBF_* bit flags indicating various options.  Access restrictions are
    // indicated for each individual flag.  Many of these flags are set
    // permanently at initialization and so have no access limitation.
    //
    //
    ULONG ulFlags;


    // Reference count on this control block.  The reference pairs are:
    //
    // (a) A reference is added when this block is linked to the adapter's
    //     list of af blocks, and removed when it is unlinked.
    //
    // (a) A reference is added when a call on a VCCB is created
    //     removed when it is deleted.
    //
    // Access is via ReferenceTunnel and DereferenceTunnel only which use
    // 'ADAPTERCB.lockTunnels' for protection.
    //
    LONG lRef;

    // Links to the prev/next AFCB in the owning adapter's AF list.
    // Access to the list links is protected by 'ADAPTERCB.lock'.
    //
    LIST_ENTRY linkAFCB;


    // List of all VCs associated with this address family. 
    // Access is protected by the adapter lock.
    //
    LIST_ENTRY AFVCList;

    // Back pointer to owning adapter's control block.
    //
    PADAPTERCB pAdapter;

    // NDIS's handle for our Address Family as passed to our CmOpenAfHandler
    // or NULL if none.
    //
    NDIS_HANDLE NdisAfHandle;


}
AFCB, *PAFCB;




// Call statistics block.
//
typedef struct
_CALLSTATS
{
    // System time call reached established state.  When the block is being
    // used for cumulative statistics of multiple calls, this is the number of
    // calls instead.
    //
    LONGLONG llCallUp;

    // Duration in seconds of now idle call.
    //
    ULONG ulSeconds;

    // Total data bytes received and sent.
    //
    ULONG ulDataBytesRecd;
    ULONG ulDataBytesSent;

    // Number of received packets indicated up.
    //
    ULONG ulRecdDataPackets;
   
   // TODO: add more stats if required.

    ULONG ulSentPkts;

    //
    // NDis Packet failures
    //
    ULONG ulSendFailures;   

    //
    // Bus AsyncWrite or Stream failires
    //

    ULONG ulBusSendFailures;
    
    ULONG ulBusSendSuccess;

}
CALLSTATS;

typedef
NDIS_STATUS
(*PFN_INITVCHANDLER) (
        VCCB *pVc
    );




typedef
NDIS_STATUS
(*PFN_SENDPACKETHANDLER) (
        VCCB *pVc,
        NDIS_PACKET * pPacket
    );

typedef
NDIS_STATUS
(*PFN_CLOSECALLHANDLER) (
    VCCB *pVc
    );

typedef 
VOID
(*PFN_RETURNHANDLER) (
    VCCB *pVc,
    PNDIS_PACKET *pPacket
    );

// Table of vc-type-specific handler functions.
//
typedef struct  _VC_HANDLERS
{
    PFN_INITVCHANDLER MakeCallHandler;
    PFN_CLOSECALLHANDLER CloseCallHandler;
    PFN_SENDPACKETHANDLER SendPackets;

} VC_HANDLERS;


typedef enum _NIC1394_VC_TYPE
{
    NIC1394_Invalid_Type,
    NIC1394_SendRecvChannel,
    NIC1394_RecvFIFO,
    NIC1394_SendFIFO,
    NIC1394_MultiChannel,
    NIC1394_Ethernet,
    NIC1394_SendChannel,
    NIC1394_RecvChannel,
    Nic1394_NoMoreVcTypes

} NIC1394_VC_TYPE, *PNIC1394_VC_TYPE;



// Virtual circuit control block header defining the state of a single VC that
// is common to all the different types of VCs.
//
typedef struct
_VCHDR
{
    // Set to MTAG_VCCB_* for easy identification in memory dumps and use in
    // assertions.
    //
    ULONG ulTag;
    


    // The Pdo Block that will be used to perform all the operations  for this Vc 
    //
    //

    PREMOTE_NODE pRemoteNode;

    //
    // pLocalHostVdo - local host's VDO  that will be used for all channel and 
    // recv fifo allocations
    //
    PDEVICE_OBJECT pLocalHostVDO;

    // Links to the prev/next VCCB in the owning AF's control block.
    // Access is protected by 'ADAPTERCB.lock'.
    //
    LIST_ENTRY linkAFVcs;

    //  The VCType and Destination of the call that has been set up on the VC
    //  The VCType can be either Isoch or Async, Sends or Recieve. Each type
    //  of VC has an address associated with it
    
    NIC1394_VC_TYPE VcType;

    
    // This stores the generation of the physical adapter. And should match the value
    // kept in the adapter block
    PUINT pGeneration;


    // VCBF_* bit flags indicating various options and states.  Access is via
    // the interlocked ReadFlags/SetFlags/ClearFlags routines.
    //
    // VCBF_IndicateReceivedTime: Set if MakeCall caller sets the
    //     MediaParameters.Flags RECEIVE_TIME_INDICATION flag requesting the
    //     TimeReceived field of the NDIS packet be filled with a timestamp.
    //
    // VCBF_CallClosableByClient: Set when a call is in a state where
    //     NicCmCloseCall requests to initiate clean-up should be accepted.
    //     This may be set when VCBF_CallClosableByPeer is not, which means we
    //     have indicated an incoming close to client and are waiting for him
    //     to do a client close in response (in that weird CoNDIS way).  The
    //     flag is protected by 'lockV'.
    //
    // VCBF_VcCreated: Set when the VC has been created successfully.  This is
    //     the "creation" that occurs with the client, not the mini-port.
    // VCBF_VcActivated: Set when the VC has been activated successfully.
    // VCBM_VcState: Bit mask including each of the above 3 NDIS state flags.
    //
    // VCBF_VcDeleted: Set when the DeleteVC handler has been called on this
    //     VC.  This guards against NDPROXY double-deleting VCs which it has
    //     been known to do.
    //
    // The pending bits below are mutually exclusive (except ClientClose which
    // may occur after but simultaneous with ClientOpen), and so require lock
    // protection by 'lockV':
    //
    // VCBF_ClientOpenPending: Set when client attempts to establish a call,
    //     and the result is not yet known.
    // VCBF_ClientClosePending: Set when client attempts to close an
    //     established call and the result is not yet known.  Access is
    //     protected by 'lockV'.
    // VCBM_Pending: Bit mask that includes each of the 4 pending flags.
    //
    // VCBF_ClientCloseCompletion: Set when client close completion is in
    //     progress.
    //
    // VCBF_WaitCloseCall: Set when the client is expected to call our call
    //     manager's CloseCall handler.  This is strictly a debug aid.
    //
    // VCBF_FreedResources - VC This is a channel VC and because the last           
    //      node in the network was being removed, its resources have been freed
    
    ULONG ulFlags;
        #define VCBF_IndicateTimeReceived   0x00000001
        #define VCBF_CallClosableByClient   0x00000002
        #define VCBF_VcCreated              0x00000100
        #define VCBF_VcActivated            0x00000200
        #define VCBF_VcDispatchedCloseCall  0x00000400
        #define VCBF_MakeCallPending        0x00002000
        #define VCBF_CloseCallPending       0x00008000
        #define VCBF_VcDeleted              0x00010000
        #define VCBF_MakeCallFailed         0x00020000
        #define VCBF_CloseCallCompleted     0x00040000
        #define VCBF_WaitCloseCall          0x00200000
        #define VCBF_NewPdoIsActivatingFifo 0x01000000
        #define VCBF_PdoIsBeingRemoved      0x02000000
        #define VCBF_NeedsToAllocateChannel 0x04000000
        #define VCBF_GenerationWorkItem     0x10000000
        #define VCBF_AllocatedChannel       0x20000000
        #define VCBF_BroadcastVc            0x40000000
        #define VCBF_FreedResources         0x80000000

        #define VCBM_VcState                0x00000700
        #define VCBM_Pending                0x0000F000
        #define VCBM_NoActiveCall           0x000F0000
        #define VCBM_PdoFlags               0x0F000000


    // Back pointer to owning address family control block.
    //
    AFCB* pAF;


    // Reference count on the active call.
    // References may only be added
    // when the VCCB_VcActivated flag is set, and this is enforced by
    // ReferenceCall.  The reference pairs are:
    //
    // (a) A reference is added when a VC is activated and removed when it is
    //     de-activated.
    //
    // (b) A reference is added when the send handler accepts a packet.
    //
    // The field is accessed only by the ReferenceCall and DereferenceCall
    // routines, which protect the field with 'lock'.
    //
    REF CallRef;

    // Reference count on this VC control block.  The reference pairs are:
    //
    // (a) NicCoCreateVc adds a reference that is removed by NicCoDeleteVc.
    //     This covers all clients that learn of the VCCB via NDIS.
    //
    // The field is accessed only by the ReferenceVc and DereferenceVc
    // routines, which protect with Interlocked routines.
    //
    LONG lRef;


    //
    // This is a copy the parameters that are passed to the VC in 
    // a Make Call. Each VC needs to keep a copy. This is stored here
    //
    
    NIC1394_MEDIA_PARAMETERS Nic1394MediaParams;
    

    // NDIS BOOKKEEPING ------------------------------------------------------

    // NDIS's handle for this VC passed to us in MiniportCoCreateVcHandler.
    // This is passed back to NDIS in various NdisXxx calls.
    //
    NDIS_HANDLE NdisVcHandle;

    // This linked list is used to designate all the VCs that are using a single PdoCb
    // The head of this list resides in a REMOTE_NODE. So that when a Pdo goes away, we can go and
    // close all the Vcs that are dependent on it. No RecvFIFO included

    LIST_ENTRY SinglePdoVcLink;
    
    // CALL SETUP ------------------------------------------------------------

    // Address of the call parameters passed down in CmMakeCall.  This field
    // will only be valid until the NdisMCmMakeCallComplete notification for
    // the associated call is made, at which time it is reset to NULL.  Access
    // is via Interlocked routines.
    //
    PCO_CALL_PARAMETERS pCallParameters;

    UINT    MTU;

    // This is the initialize handler used to initialize the Vc
    // Each Vc has its own specific initialize handler so that all the 
    // data structures that specific to it, can be filled
    //
    VC_HANDLERS VcHandlers;
    

    // STATISTICS ------------------------------------------------------------

    // Statistics for the current call.  Access is protected by 'lock'.
    //
    CALLSTATS stats;

    // This is a pointer to the lock in the adapater
    // structure. 
    PNDIS_SPIN_LOCK plock;

    //
    // MaxPayload that this VC will send in a single IRP
    // To be used in Lookaside lists
    //
    ULONG MaxPayload;

}
VCHDR;

//
// Virtual circuit control block defining the state of a single SendFIFO VC.
//
typedef struct
_SENDFIFO_VCCB
{
    // Common header for all types of VCs
    //
    VCHDR Hdr;

    
    // Prev/next in the list of SendFIFO VCs for a particular destination
    // PDO
    //
    LIST_ENTRY SendFIFOLink;

    // SendFIFO-specific VC Info
    //
    NIC1394_FIFO_ADDRESS     FifoAddress;

    // Shortcuts to the Values we were passed in the Make call 
    // that activated the VC
    //
    //      UINT MaxSendBlockSize;
    UINT  MaxSendSpeed;

    
} SENDFIFO_VCCB, *PSENDFIFO_VCCB;


// Virtual circuit control block defining the state of a single RecvFIFO VC.
//
typedef struct
_RECVFIFO_VCCB
{
    // Common header for all types of VCs
    //
    VCHDR Hdr;

    // Prev/next in the list of RecvFIFO VCs for a particular Recv FIFO
    // address.
    //
    LIST_ENTRY RecvFIFOLink;

    // Packet Pool Handle 
    //
    NIC_PACKET_POOL PacketPool;

    //NDIS_HANDLE PacketPoolHandle;

    // Slist Header. All buffers are posted here, using Interlocked routines
    //

    SLIST_HEADER FifoSListHead;

    // Slist Spin lock that protects the Slist
    //
    KSPIN_LOCK FifoSListSpinLock;

    //
    // Num Fifo Elements allocated
    //
    ULONG NumAllocatedFifos;

    // Num of Fifo that have been indicated to the miniport
    // Count of Fifo that the Nic has not returned to the bus driver
    //
    ULONG NumIndicatedFifos;
    
    // This is the address range that is returned in the allocate
    // address irb. Will be changed to a pointer or an array
    //
    
    ADDRESS_RANGE   VcAddressRange;

    // This is the number of address ranges that the bus driver
    // returned. For now, it is expected to be one.
    //
    UINT AddressesReturned;


    //
    // Handle to the address range
    //
    HANDLE hAddressRange;

    //
    // Buffer pool
    //
    NIC_BUFFER_POOL BufferPool;

    //NIC_WORK_ITEM FifoWorkItem;

    BOOLEAN FifoWorkItemInProgress ;

    UINT NumOfFifosInSlistInCloseCall; 

    
} RECVFIFO_VCCB, *PRECVFIFO_VCCB;


// Virtual circuit control block defining the state of a single CHANNEL VC.
//
typedef struct
_CHANNEL_VCCB
{
    // Common header for all types of VCs
    //
    VCHDR Hdr;

    // Prev/next in the list of channel VCs for a particular destination
    // channel
    //
    LIST_ENTRY ChannelLink;


    // Channel-specific VC Info
    //
    UINT    Channel;

    // The speed at which this Channel will stream data
    //
    UINT Speed;

    // Indicates the Sy field in packets that will indicated up
    //
    ULONG ulSynch;

    // the Tag used in submitting asyncstream irps
    //
    ULONG ulTag;

    // MaxBytesPerFrameRequested and available
    //
    ULONG MaxBytesPerFrameRequested;
    ULONG BytesPerFrameAvailable;

    // Handle to the Resources allocated 
    //
    HANDLE hResource;

    // Speeds Requested and speed returned
    //
    ULONG SpeedRequested;
    ULONG SpeedSelected;

    // Maximum Buffer Size
    //
    ULONG MaxBufferSize;

    // Num of descriptors that were attached to the resources
    //
    ULONG NumDescriptors;

    // Pointer to an array of isochDescriptors used in AttachBuffers
    //
    PISOCH_DESCRIPTOR       pIsochDescriptor;   

    // PacketPool Handle
    //
    NIC_PACKET_POOL PacketPool;

    //NDIS_HANDLE hPacketPoolHandle;
    //
    // Temporary
    //
    UINT PacketLength;

    //
    // Number of Isoch Descriptors that the Bus driver has indicated to the miniport
    //
    ULONG NumIndicatedIsochDesc;


    //
    // Event to signal that the last of the Isoch descriptors have
    // been returned to the bus driver. Only set when Vc is closing (after IsochStop)
    //
    NDIS_EVENT LastDescReturned;

    //
    // Channel Map used in Multichannel Vcs
    //
    ULARGE_INTEGER uliChannelMap;

    
} CHANNEL_VCCB, *PCHANNEL_VCCB;


typedef struct
_ETHERNET_VCCB
{
    // Common header for all types of VCs
    //
    VCHDR Hdr;


    NIC_PACKET_POOL     PacketPool;
    
} ETHERNET_VCCB, *PETHERNET_VCCB;





// The following union has enough space to hold any of the type-specific
// VC control blocks.
//
typedef union _VCCB
{
    VCHDR Hdr;
    CHANNEL_VCCB ChannelVc;
    SENDFIFO_VCCB SendFIFOVc;
    RECVFIFO_VCCB RecvFIFOVc;
    ETHERNET_VCCB EthernetVc;
    
} VCCB, *PVCCB;

// The next structure is used when sending a packet, to store context 
// information in an NdisPacket. These are pointers to the Vc and the Irb   
// and are stored in the MiniportWrapperReserved field of the NdisPacket
// and has a limit of 2 PVOIDs
//
typedef union _PKT_CONTEXT
{
        struct 
        {
            PVCCB pVc;
            PVOID  pLookasideListBuffer;
        
        } AsyncWrite;

        struct 
        {
            PVCCB pVc;
            PVOID  pLookasideListBuffer;

        } AsyncStream;

        //
        // For receives make sure the first element is the Vc or we will break;
        //
        struct
        {
            PRECVFIFO_VCCB pRecvFIFOVc;
            PADDRESS_FIFO pIndicatedFifo;

        } AllocateAddressRange;

        struct 
        {   
            PCHANNEL_VCCB pChannelVc;
            PISOCH_DESCRIPTOR pIsochDescriptor;
            
        } IsochListen;

        struct
        {
            //
            // First DWORD is the Vc
            //
            PVCCB pVc;

            //
            // Second is the isoch descriptor or Fifo
            //
            union 
            {
                PISOCH_DESCRIPTOR pIsochDescriptor;  // channels use isoch desc

                PADDRESS_FIFO pIndicatedFifo;   // fifo use AddressFifo

                PVOID   pCommon;  // to be used in the common code path
    
            } IndicatedStruct;

        } Receive;

        struct 
        {
            
            PNDIS_PACKET pOrigPacket;

        } EthernetSend;

        

} PKT_CONTEXT,*PPKT_CONTEXT,**PPPKT_CONTEXT; 


typedef struct _NDIS1394_FRAGMENT_HEADER
{
    union 
    {
        struct 
        {
            ULONG   FH_fragment_offset:12;
            ULONG   FH_rsv_0:4;
            ULONG   FH_buffersize:12;
            ULONG   FH_rsv_1:2;
            ULONG   FH_lf:2;

        } FirstQuadlet;

        struct 
        {
            ULONG   FH_EtherType:16;
            ULONG  FH_buffersize:12;
            ULONG   FH_rsv_1:2;
            ULONG   FH_lf:2;

    
        } FirstQuadlet_FirstFragment;

        ULONG FH_High;
    } u;

    union
    {
        struct 
        {
        
            ULONG FH_rsv:16;
            ULONG FH_dgl:16;

        } SecondQuadlet;

        ULONG FH_Low;
    } u1;
    
} NDIS1394_FRAGMENT_HEADER, *PNDIS1394_FRAGMENT_HEADER;







#define LOOKASIDE_HEADER_No_More_Framgents                  1
#define LOOKASIDE_HEADER_SendPacketFrees                    2
#define LOOKASIDE_HEADER_SendCompleteFrees                  4


//
// This structure is used with the above flags to maintain state within the lookaside buffer
//


typedef  union _LOOKASIDE_BUFFER_STATE
{
    struct 
    {
        USHORT Refcount;
        USHORT Flags;
    } u;

    LONG FlagRefcount;

} LOOKASIDE_BUFFER_STATE, *PLOOKASIDE_BUFFER_STATE;


typedef enum _BUS_OPERATION 
{
    InvalidOperation,
    AsyncWrite,
    AsyncStream,
    AddressRange,
    IsochReceive
    

} BUS_OPERATION, *PBUS_OPERATION;


//
// This will be used as a local variable
// during a send operation and will
// keep all the state information 
// regarding fragmentation
//
typedef struct _FRAGMENTATION_STRUCTURE
{
    //
    // Start of the buffer that will be used in the send.
    // Usually from a lookaside list
    //
    PVOID pLookasideListBuffer;
    

    //
    // Fragment Length
    //
    ULONG FragmentLength ; 

    //
    // Start of the this fragment to be used
    //
    PVOID pStartFragment;   

    //
    // Specified if an async write or an asyncstream operation is occurring
    //
    BUS_OPERATION AsyncOp;

    //
    // LookasideBuffer associated with the fragmentation
    //
    PVOID pLookasideBuffer;


    //
    // Start  of the next fragment
    //
//  PVOID pStartNextFragment;
    //
    // Length of each fragment
    //
    ULONG MaxFragmentLength;

    //
    // NumFragments that will be generated
    //
    ULONG NumFragmentsNeeded ;

    //
    // Current NdisBuffer which is being fragmented
    //
    PNDIS_BUFFER pCurrNdisBuffer;

    //
    // Length that needs to be copied in CurrNdisBuffer
    //
    ULONG NdisBufferLengthRemaining;

    //
    // Point to which copying has occurred in the pCurrNdisBuffer
    //
    PVOID pSourceAddressInNdisBuffer;
    
    //
    // UnFragment Header from this NdisPacket
    //

    NDIS1394_UNFRAGMENTED_HEADER UnfragmentedHeader;

    //
    // Fragmented Header to be used by all the fragments 
    // generated by this NdisPackets
    //
    

    NDIS1394_FRAGMENT_HEADER FragmentationHeader;
    
    
    //
    // Status of the lf field in the fragment header. Also serves as an 
    // implicit flag about the state of the fragmentation
    //
    NDIS1394_FRAGMENT_LF lf;

    //
    // Length of the Ip Datagram, to be used as the buffersize in fragment header
    //
    USHORT IPDatagramLength;

    //
    // An AsyncStream will have a gasp header as well . So the starting 
    // offset can either be either 8 or 16. Only applicable for fragmentation code path
    //
    ULONG TxHeaderSize;

    //
    // Pointer to the lookaside list that this buffer was allocated from
    // 
    PNIC_NPAGED_LOOKASIDE_LIST pLookasideList;

    //
    // Adapter - local host
    //
    PADAPTERCB pAdapter;

    //
    // Pointer to the IRB to be used in the current fragment
    //
    PIRB pCurrentIrb;

    //
    // Current Fragment Number 
    // 
    ULONG CurrFragmentNum;

    PVOID pStartOfFirstFragment;
    
}FRAGMENTATION_STRUCTURE, *PFRAGMENTATION_STRUCTURE;                



typedef struct _LOOKASIDE_BUFFER_HEADER 
{

    //
    // Refcount
    //
    ULONG OutstandingFragments; 
    
    //
    // NumOfFragments generated by the NdisPacket So Far
    //
    ULONG FragmentsGenerated;

    //
    // Will this Buffer contain fragments
    //
    BOOLEAN IsFragmented; 
    
    //
    // Pointer to the NdisPacket whose data is being transmitted
    // by the lookaside buffer
    //
    PNDIS_PACKET pNdisPacket;

    //
    // pVc Pointer to the Vc on which the packet was indicated
    // Used to complete the packet
    //
    PVCCB pVc;

    //
    // Pointer to the lookaside list that this buffer was allocated from
    // 
    PNIC_NPAGED_LOOKASIDE_LIST pLookasideList;

    //
    // Bus Op AsyncStream or AsyncWrite. 
    // AsyncWrite reference the RemoteNode. AsuncWrite does not
    //
    BUS_OPERATION AsyncOp;

    //
    // Start of Data
    //
    PVOID pStartOfData;

    
} LOOKASIDE_BUFFER_HEADER, *PLOOKASIDE_BUFFER_HEADER;

typedef enum _ENUM_LOOKASIDE_LIST
{
    NoLookasideList,
    SendLookasideList100,
    SendLookasideList2K,
    
} ENUM_LOOKASIDE_LIST, *PENUM_LOOKASIDE_LIST;


//
// Unfragmented Buffer
//
typedef struct _UNFRAGMENTED_BUFFER
{
    LOOKASIDE_BUFFER_HEADER Header;

    IRB Irb;

    UCHAR  Data [1];

} UNFRAGMENTED_BUFFER, *PUNFRAGMENTED_BUFFER;



#define PAYLOAD_100 100

//
// A simple packet with no fragmentation . This will primarily be used for the IP Acks and ARP req
//
typedef struct _PAYLOAD_100_LOOKASIDE_BUFFER
{

    LOOKASIDE_BUFFER_HEADER Header;

    IRB Irb;

    UCHAR  Data [PAYLOAD_100 + sizeof (GASP_HEADER)];

} PAYLOAD_100_LOOKASIDE_BUFFER;

//
// This lookaside will handle packets upto 2K. 
//
// Calculate the theoretical maximum number of fragments that can occur for a 
// a 2K Packet
//
#define PAYLOAD_2K ASYNC_PAYLOAD_400_RATE

#define NUM_FRAGMENT_2K ((PAYLOAD_2K/ASYNC_PAYLOAD_100_RATE)  +1)

typedef struct _PAYLOAD_2K_LOOKASIDE_BUFFER
{

    LOOKASIDE_BUFFER_HEADER Header;

    //
    // There can be a maximum of 2048 bytes in 1 Async Packet fragment
    // on ASYNC_PAYLOAD_400 so this will cater to 
    // that, but it will be prepared for the worst
    //
    //
    IRB Irb[NUM_FRAGMENT_2K];

    //
    // We get a data size large enough to handle 2048 bytes of data chopped up 
    // into the max num of fragments and leave room for header (fragmentation and Gasp)
    // To access we'll just use simple pointer arithmetic
    //
    
    UCHAR Data[PAYLOAD_2K+ (NUM_FRAGMENT_2K *(sizeof (GASP_HEADER)+sizeof (NDIS1394_FRAGMENT_HEADER)))];

} PAYLOAD_2K_LOOKASIDE_BUFFER, *PPAYLOAD_2K_LOOKASIDE_BUFFER;



//
// The 1394 fragment that is passed down can have a gasp header, fragmentation header, 
// unfragmented header. Define Types to format these headers so that we can make 
// compiler do the pointer arithmetic for us.
//
typedef union _PACKET_FORMAT
{


    struct
    {
        GASP_HEADER GaspHeader;

        NDIS1394_FRAGMENT_HEADER FragmentHeader;
        
        UCHAR Data[1];

    } AsyncStreamFragmented;

    struct
    {
        GASP_HEADER GaspHeader;

        NDIS1394_UNFRAGMENTED_HEADER NonFragmentedHeader;

        UCHAR Data[1];

    } AsyncStreamNonFragmented;

    struct 
    {
        NDIS1394_FRAGMENT_HEADER FragmentHeader;
        
        UCHAR Data[1];
        
    } AsyncWriteFragmented;


    struct 
    {
        NDIS1394_UNFRAGMENTED_HEADER NonFragmentedHeader;

        UCHAR Data[1];

    }AsyncWriteNonFragmented;


    struct 
    {
        //
        // Isoch receive header has a prefix, isoch header, gasp header
        //
        ULONG Prefix;

        ISOCH_HEADER IsochHeader;

        GASP_HEADER GaspHeader;

        NDIS1394_UNFRAGMENTED_HEADER NonFragmentedHeader;

        UCHAR Data[1];
        

    } IsochReceiveNonFragmented;


    struct 
    {
        //
        // Isoch receive header has a prefix, isoch header, gasp header
        //

        ULONG Prefix;

        ISOCH_HEADER IsochHeader;

        GASP_HEADER GaspHeader;

        NDIS1394_FRAGMENT_HEADER FragmentHeader;

        UCHAR Data[1];


    }IsochReceiveFragmented;

}PACKET_FORMAT, DATA_FORMAT, *PPACKET_FORMAT, *PDATA_FORMAT;


//
// Used as an Info Struct for Out of Order Reassembly
//

typedef struct _REASSEMBLY_CURRENT_INFO 
{
    PMDL                pCurrMdl;
    PNDIS_BUFFER        pCurrNdisBuffer;
    PADDRESS_FIFO       pCurrFifo;
    PISOCH_DESCRIPTOR   pCurrIsoch;

} REASSEMBLY_CURRENT_INFO,  *PREASSEMBLY_CURRENT_INFO ;

typedef enum _REASSEMBLY_INSERT_TYPE
{
        Unacceptable,
        InsertAsFirst,
        InsertInMiddle,
        InsertAtEnd

}REASSEMBLY_INSERT_TYPE, *PREASSEMBLY_INSERT_TYPE;

//
// This is used as a descriptor for indicated fragments that are waiting for reassembly
//

typedef struct _FRAGMENT_DESCRIPTOR
{
    ULONG Offset;  // Offset of the incoming fragment
    ULONG IPLength;  // Length of the fragment
    PNDIS_BUFFER pNdisBuffer; // NdisBufferpointing to actual data
    PMDL pMdl;  // Mdl that belongs to the bus 
    NDIS1394_FRAGMENT_HEADER  FragHeader; // Fragment header of the Descriptor
    
    union 
    {
        PADDRESS_FIFO pFifo;
        PISOCH_DESCRIPTOR pIsoch;
        PVOID pCommon;
        PSINGLE_LIST_ENTRY pListEntry;
        
    }IndicatedStructure;
    

} FRAGMENT_DESCRIPTOR, *PFRAGMENT_DESCRIPTOR;

//
// Reassembly structure : An instance of the reassembly is created for
// every packet that is being reassembled. It contains all the relevant 
// bookkeeping information
// 
// This needs to be allocated from a lookaside list
// Each PDO will contain a list of all outstanding packets that are being reassembled/
//

//
// REASSEMBLY_NOT_TOUCHED  - Each reassembly structure will be marked as Not touched 
//                            in the timer routine. If the flag is not cleared by the next
//                            invocation of the timer, this structure will be freed
// REASSMEBLY_FREED -         The structure is about to be thrown away.
#define REASSEMBLY_NOT_TOUCHED      1
#define REASSEMBLY_FREED            2
#define REASSEMBLY_ABORTED          4





typedef struct  _NDIS1394_REASSEMBLY_STRUCTURE
{

    //
    // Reference Count - Interlocked access only
    //
    ULONG Ref;

    // 
    // Next Reassembly Structure
    //
    LIST_ENTRY ReassemblyListEntry;

    //
    // Tag - used for memory validatation
    //
    ULONG Tag;
    //
    // Receive Operation
    //
    BUS_OPERATION ReceiveOp;


    //
    // Dgl  - Datagram label. Unique for every reassembly structure gernerated by this local host
    //
    USHORT Dgl;

    //
    // Ether type of the reassembled packet . Populated in the first fragment
    //
    USHORT EtherType;
    //
    // pRemoteNode  -> RemoteNode + Dgl are unique for each reassembly structure
    //
    PREMOTE_NODE pRemoteNode;
    
    //
    // Flags pertaining to the reassembly
    //
    ULONG Flags;

    //
    // ExpectedFragmentOffset is computed by the LAST Fragment's Offset + 
    // length of fragment. Does not account for gaps in the reassembled packet.
    // 
    ULONG ExpectedFragmentOffset;   // Last is based on offset,  not time of indication

    //
    // Buffer Size - total length of the datagram being reassembled
    //
    ULONG BufferSize;

    //
    // Bytes Received So far
    //
    ULONG BytesRecvSoFar;

    //
    // Head NdisBuffer
    //
    PNDIS_BUFFER pHeadNdisBuffer;
    
    //
    // LastNdisBuffer that was appended to the packet 
    //
    PNDIS_BUFFER pTailNdisBuffer;

    //
    // Mdl chain Head - pointing to the actual indicated fragment
    //
    PMDL pHeadMdl;

    //
    //Mdl Chain Tail - pointing to the last Mdl in the list
    //  
    PMDL pTailMdl ;
    //
    // Packet that is being reassembled
    //
    PNDIS_PACKET pNdisPacket;

    //
    // NumOfFragmentsSoFar;
    //
    ULONG NumOfFragmentsSoFar; 
    
    //
    // Pointer to the head of the MDL chain that the 1394 bus
    // driver is indicating up. Will be used to return the buffers to 
    // the BusDriver
    //
    union
    {
        PADDRESS_FIFO pAddressFifo;
        PISOCH_DESCRIPTOR pIsochDescriptor;
        PVOID pCommon;
    } Head;

    //
    // Last -  Last Mdl that was appended to this packet in the reassembly structure
    //

    union 
    {
        PADDRESS_FIFO pAddressFifo;
        PISOCH_DESCRIPTOR pIsochDescriptor;
        PVOID pCommon;

    } Tail;

    //
    // Flag to signal if any out of order fragments were received. Default FALSE
    //
    BOOLEAN OutOfOrder;

    //
    // Flag to indicate if all fragments are completed . Default False
    //
    BOOLEAN fReassemblyComplete;

    //
    // Vc that this packet is being assembled for 
    //
    PVCCB pVc;

    //
    // MaxIndex in the Fragment Table. 
    // At all times, MaxOffset points to an first empty element in the array
    //
    ULONG MaxOffsetTableIndex;

    //
    // FragmentOffset Table
    //
    FRAGMENT_DESCRIPTOR FragTable[MAX_ALLOWED_FRAGMENTS]; 

    
} NDIS1394_REASSEMBLY_STRUCTURE, *PDIS1394_REASSEMBLY_STRUCTURE, *PPDIS1394_REASSEMBLY_STRUCTURE;


//
// This structure is local to each Isoch descriptor or fifo that is indicated up
// to the nic1394 miniport. It stores all the local information extracted
// from the GASP header and Isoch Header
//

typedef struct
{
    BUS_OPERATION   RecvOp;         // Fifo or Isoch Receive
    PDATA_FORMAT    p1394Data;      // Start of 1394 pkt
    ULONG           Length1394;     // Length of the 1394 data
    PVOID           pEncapHeader;   // Points to start of frag/defrag encap header
    ULONG           DataLength;     // length of the packet, from the EncapHeader
    BOOLEAN         fGasp;          // Has GASP header
    NDIS1394_UNFRAGMENTED_HEADER UnfragHeader; // Unfragmented header 
    NDIS1394_FRAGMENT_HEADER FragmentHeader;  // Fragment Header
    PGASP_HEADER    pGaspHeader;    // Gasp Header
    PVOID           pIndicatedData; // Data indicated up, includes the isoch header, unfrag headers
    PMDL            pMdl;
    //
    // Following information from the fragmented/unfragmented header...
    //
    BOOLEAN         fFragmented;    // Is fragmented
    BOOLEAN         fFirstFragment; // Is the First fragment
    ULONG           BufferSize;
    ULONG           FragmentOffset;
    USHORT          Dgl;            // Dgl 
    ULONG           lf;             // Lf - Fragmented or not
    ULONG           EtherType;      // Ethertype
    PNDIS_BUFFER    pNdisBuffer;    // Ndis buffer - used to indicate data up.
    PVOID           pNdisBufferData;   // Points to the start of the data that the Ndis Buffer points to  

    //
    // Sender specific information here
    //
    USHORT           SourceID;
    PREMOTE_NODE    pRemoteNode;

    //
    // Vc Specific Information here
    //
    PVCCB           pVc;
    PNIC_PACKET_POOL pPacketPool;

    //
    // Indication data
    //
    union
    {
        PADDRESS_FIFO       pFifoContext;
        PISOCH_DESCRIPTOR   pIsochContext;
        PVOID               pCommon; // to be used in the common code path

    }NdisPktContext;

} NIC_RECV_DATA_INFO, *PNIC_RECV_DATA_INFO;




//
// Fragment Header as defined in the IP/1394 spec. Each packet greater than the MaxPayload
// will be split up into fragments and this header will be attached.
//

#define FRAGMENT_HEADER_LF_UNFRAGMENTED 0
#define FRAGMENT_HEADER_LF_FIRST_FRAGMENT 1
#define FRAGMENT_HEADER_LF_LAST_FRAGMENT 2
#define FRAGMENT_HEADER_LF_INTERIOR_FRAGMENT 3


typedef struct _INDICATE_RSVD
{
    PNDIS_PACKET pPacket;
    PVCCB pVc;
    PADAPTERCB pAdapter;
    LIST_ENTRY   Link;
    ULONG   Tag;

} INDICATE_RSVD, *PINDICATE_RSVD;



typedef struct _RSVD
{
    
    UCHAR   Mandatory[PROTOCOL_RESERVED_SIZE_IN_PACKET]; // mandatory ndis requirement
    INDICATE_RSVD IndicateRsvd; // to be used as extra context


} RSVD, *PRSVD;



//
// Used only in Win9x as a context for the send timer routine
//
typedef struct _NDIS_SEND_CONTEXT
{
    LIST_ENTRY Link;
    PVCCB pVc;
    

}NDIS_SEND_CONTEXT, *PNDIS_SEND_CONTEXT;


typedef struct _NDIS_STATUS_CONTEXT
{
    LIST_ENTRY                  Link;
    IN  NDIS_STATUS             GeneralStatus;
    IN  PVOID                   StatusBuffer;
    IN  UINT                    StatusBufferSize;


}NDIS_STATUS_CONTEXT, *PNDIS_STATUS_CONTEXT;



//
// This is the Irb structure used by the Bus Driver. 
// There is extra room allocated at the end for the miniport's Context
//

typedef struct _NDIS1394_IRB
{
    //
    // Original Irb used by the bus driver
    //
    IRB Irb;

    //
    // Adapter - local host -optional
    //
    PADAPTERCB pAdapter;

    //
    // remote node to which the Irp was sent - optional
    //
    PREMOTE_NODE pRemoteNode;

    //
    // VC for which the Irp was sent. - optional 
    //
    PVCCB pVc;

    //
    // Context if any - optinal 
    //
    PVOID Context;


}NDIS1394_IRB, *PNDIS1394_IRB;


//
// The following structure is used to log the cause of a Reference or Dereference.
// It is ignored unless LOG_REMOTE_NODE_REF is not zero
//

typedef enum _REMOTE_NODE_REF_CAUSE {

    FindIrmAmongRemoteNodes,
    InformAllRemoteNodesOfBCM,        
    UpdateNodeTable,
    FindRemoteNodeFromAdapter,
    SubmitIrp_Synch,
    AddRemoteNode,
    ReassemblyTimer,
    GetRemoteNodeFromTable,
    UpdateRemoteNodeCaps,
    UpdateRemoteNodeTable,
    UpdateLocalHostSpeed,
    InitializeReassemblyStructure,
    FreeAllPendingReassemblyStructures,
    AsyncWriteSendPackets,
    FindRemoteNodeFromAdapterFail,
    RemoveRemoteNode,
    ReassemblyTimer_Removing,
    FreeReassembliesOnRemoteNode,
    FillRemoteNodeInfo,
    InsertFragmentInReassembly,
    AsyncSendComplete,    


} REMOTE_NODE_REF_CAUSE;



#pragma pack (push, 1)


typedef ULONG IP_ADDRESS;

//* Structure of an Ethernet header (taken from ip\arpdef.h).
typedef struct  ENetHeader {
    ENetAddr    eh_daddr;
    ENetAddr    eh_saddr;
    USHORT      eh_type;
} ENetHeader;



// Structure of an Ethernet ARP packet.
//
typedef struct {
    ENetHeader  header;
    USHORT      hardware_type; 
    USHORT      protocol_type;
    UCHAR       hw_addr_len;
    UCHAR       IP_addr_len; 
    USHORT      opcode;                  // Opcode.
    ENetAddr    sender_hw_address;
    IP_ADDRESS  sender_IP_address;
    ENetAddr    target_hw_address;
    IP_ADDRESS  target_IP_address;

} ETH_ARP_PKT, *PETH_ARP_PKT;



#pragma pack (pop)

// These are ethernet arp specific  constants
//
#define ARP_ETH_ETYPE_IP    0x800
#define ARP_ETH_ETYPE_ARP   0x806
#define ARP_ETH_REQUEST     1
#define ARP_ETH_RESPONSE    2
#define ARP_ETH_HW_ENET     1
#define ARP_ETH_HW_802      6

typedef enum _ARP_ACTION {

    LoadArp = 1,
    UnloadArp ,
    UnloadArpNoRequest,
    BindArp
}ARP_ACTION , *PARP_ACTION; 


typedef struct _ARP_INFO{
    //
    // List entry to handle serialization of requests to ARP
    // 

    LIST_ENTRY Link;

    //
    // Action to be done by the Arp module
    //
    ARP_ACTION Action;

    //
    // Request to be compeleted - optional
    //
    PNDIS_REQUEST pRequest;

} ARP_INFO, *PARP_INFO;



//-----------------------------------------------------------------------------
// Macros/inlines
//-----------------------------------------------------------------------------

// These basics are not in the DDK headers for some reason.
//
#define min( a, b ) (((a) < (b)) ? (a) : (b))
#define max( a, b ) (((a) > (b)) ? (a) : (b))

#define InsertBefore( pNewL, pL )    \
{                                    \
    (pNewL)->Flink = (pL);           \
    (pNewL)->Blink = (pL)->Blink;    \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}

#define InsertAfter( pNewL, pL )     \
{                                    \
    (pNewL)->Flink = (pL)->Flink;    \
    (pNewL)->Blink = (pL);           \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}


// Winsock-ish host/network byte order converters for short and long integers.
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))
#define htonl( a ) ((((a) & 0xFF000000) >> 24) | \
                    (((a) & 0x00FF0000) >> 8)  | \
                    (((a) & 0x0000FF00) << 8)  | \
                    (((a) & 0x000000FF) << 24))
#endif
#define ntohs( a ) htons(a)
#define ntohl( a ) htonl(a)

// Place in a TRACE argument list to correspond with a format of "%d.%d.%d.%d"
// to print network byte-ordered IP address 'x' in human readable form.
//
#define IPADDRTRACE( x ) ((x) & 0x000000FF),         \
                         (((x) >> 8) & 0x000000FF),  \
                         (((x) >> 16) & 0x000000FF), \
                         (((x) >> 24) & 0x000000FF)

// Place in a TRACE argument list to correspond with a format of "%d" to print
// a percentage of two integers, or an average of two integers, or those
// values rounded.
//
#define PCTTRACE( n, d ) ((d) ? (((n) * 100) / (d)) : 0)
#define AVGTRACE( t, c ) ((c) ? ((t) / (c)) : 0)
#define PCTRNDTRACE( n, d ) ((d) ? (((((n) * 1000) / (d)) + 5) / 10) : 0)
#define AVGRNDTRACE( t, c ) ((c) ? (((((t) * 10) / (c)) + 5) / 10) : 0)

// All memory allocations and frees are done with these ALLOC_*/FREE_*
// macros/inlines to allow memory management scheme changes without global
// editing.  For example, might choose to lump several lookaside lists of
// nearly equal sized items into a single list for efficiency.
//
// NdisFreeMemory requires the length of the allocation as an argument.  NT
// currently doesn't use this for non-paged memory, but according to JameelH,
// Windows95 does.  These inlines stash the length at the beginning of the
// allocation, providing the traditional malloc/free interface.  The
// stash-area is a ULONGLONG so that all allocated blocks remain ULONGLONG
// aligned as they would be otherwise, preventing problems on Alphas.
//
__inline
VOID*
ALLOC_NONPAGED(
    IN ULONG ulBufLength,
    IN ULONG ulTag )
{
    CHAR* pBuf;

    NdisAllocateMemoryWithTag(
        &pBuf, (UINT )(ulBufLength + MEMORY_ALLOCATION_ALIGNMENT), ulTag );
    if (!pBuf)
    {
        return NULL;
    }

    ((ULONG* )pBuf)[ 0 ] = ulBufLength;
    ((ULONG* )pBuf)[ 1 ] = ulTag;
    return (pBuf + MEMORY_ALLOCATION_ALIGNMENT);
}

__inline
VOID
FREE_NONPAGED(
    IN VOID* pBuf )
{
    ULONG ulBufLen;

    ulBufLen = *((ULONG* )(((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT));
    NdisFreeMemory(
        ((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT,
        (UINT )(ulBufLen + MEMORY_ALLOCATION_ALIGNMENT),
        0 );
}

#define ALLOC_NDIS_WORK_ITEM( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistWorkItems )
#define FREE_NDIS_WORK_ITEM( pA, pNwi ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistWorkItems, (pNwi) )

#define ALLOC_TIMERQITEM( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistTimerQItems )
#define FREE_TIMERQITEM( pA, pTqi ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistTimerQItems, (pTqi) )

#define ALLOC_TUNNELCB( pA ) \
    ALLOC_NONPAGED( sizeof(TUNNELCB), MTAG_TUNNELCB )
#define FREE_TUNNELCB( pA, pT ) \
    FREE_NONPAGED( pT )

#define ALLOC_VCCB( pA ) \
    ALLOC_NONPAGED( sizeof(VCCB), MTAG_VCCB )
#define FREE_VCCB( pA, pV ) \
    FREE_NONPAGED( pV )

#define ALLOC_TIMERQ( pA ) \
    ALLOC_NONPAGED( sizeof(TIMERQ), MTAG_TIMERQ )
#define FREE_TIMERQ( pA, pTq ) \
    FREE_NONPAGED( pTq )

//
// Log packet macro
//
#ifdef PKT_LOG

#define NIC1394_ALLOC_PKTLOG(_pAdapter)                                     \
            nic1394AllocPktLog(_pAdapter)

#define NIC1394_DEALLOC_PKTLOG(_pAdapter)                                       \
            Nic1394DeallocPktLog(_pAdapter)

#define NIC1394_LOG_PKT(_pAdapter, _Flags, _SourceID, _DestID, _pvData, _cbData)\
                    (((_pAdapter)->pPktLog) ?                                   \
                        Nic1394LogPkt(                                          \
                                (_pAdapter)->pPktLog,                           \
                                (_Flags),                                       \
                                (_SourceID),                                    \
                                (_DestID),                                      \
                                (_pvData),                                      \
                                (_cbData)                                       \
                                )                                               \
                    : 0)
#else

#define NIC1394_ALLOC_PKTLOG(_pAdapter)                                     
#define NIC1394_DEALLOC_PKTLOG(_pAdapter)                                   
#define NIC1394_LOG_PKT(_pAdapter, _Flags, _SourceID, _DestID, _pvData, _cbData)

#endif

#define NIC1394_LOGFLAGS_RECV_CHANNEL               0x00000001
#define NIC1394_LOGFLAGS_SEND_FIFO                  0x00000010
#define NIC1394_LOGFLAGS_SEND_CHANNEL               0x00000011
#define NIC1394_LOGFLAGS_RECV_FIFO                  0x00000100
#define NIC1394_LOGFLAGS_BCM_FAILED                 0x00001000
#define NIC1394_LOGFLAGS_BCM_IS_IRM_TIMEOUT         0x00002000
#define NIC1394_LOGFLAGS_BCM_NOT_IRM_TIMEOUT        0x00004000
#define NIC1394_LOGFLAGS_BCM_IRM_NOT_FOUND          0x00008000

#if 0 
//
// To get the MaxRec we extract the 0xf000 nibble
//
#define GET_MAXREC_FROM_BUSCAPS(_pBus, _pMaxRec)        \ 
{                                                       \
    ULONG _LitEnd = SWAPBYTES_ULONG(_pBus);             \
    _LitEnd = _LitEnd & 0xf000;                         \
    _LitEnd = _LitEnd >>  12;                           \
    *(_pBusRec) = _LitEnd;                              \
}
#endif

//
// To get the MaxRec we extract the 0xf000 nibble
//
#define GET_MAXREC_FROM_BUSCAPS(_Bus)       (((_Bus) & 0xf00000) >> 20); 


//-----------------------------------------------------------------------------
//    F L A G S   &   L O C K S              
//-----------------------------------------------------------------------------



//
// These macros are just present to make accessing the VC's flags easier 
// and concentrate the implementations at one place
//
#define VC_TEST_FLAG(_V, _F)                ((nicReadFlags(&(_V)->Hdr.ulFlags) & (_F))!= 0)
#define VC_SET_FLAG(_V, _F)                 (nicSetFlags(&(_V)->Hdr.ulFlags, (_F)))
#define VC_CLEAR_FLAGS(_V, _F)              (nicClearFlags(&(_V)->Hdr.ulFlags , (_F)))
#define VC_TEST_FLAGS(_V, _F)               ((nicReadFlags(&(_V)->Hdr.ulFlags) & (_F)) == (_F))
#define VC_READ_FLAGS(_V)                   ((nicReadFlags(&(_V)->Hdr.ulFlags) 
#define VC_ACTIVE(_V)                       (((_V)->Hdr.ulFlags & (VCBF_CloseCallPending | VCBF_VcDeleted | VCBF_VcActivated |VCBF_MakeCallPending )) == VCBF_VcActivated)



#define REMOTE_NODE_TEST_FLAG(_P, _F    )           ((nicReadFlags(&(_P)->ulFlags) & (_F))!= 0)
#define REMOTE_NODE_SET_FLAG(_P, _F)                (nicSetFlags(&(_P)->ulFlags, (_F)))
#define REMOTE_NODE_CLEAR_FLAGS(_P, _F)             (nicClearFlags(&(_P)->ulFlags , (_F)))
#define REMOTE_NODE_TEST_FLAGS(_P, _F)              ((nicReadFlags(&(_P)->ulFlags) & (_F)) == (_F))
#define REMOTE_NODE_READ_FLAGS(_P)                  ((nicReadFlags(&(_P)->ulFlags) 
#define REMOTE_NODE_ACTIVE(_P)                      (((_P)->ulFlags & (PDO_Activated | PDO_BeingRemoved)) == PDO_Activated)

#define ADAPTER_TEST_FLAG(_A, _F)               ((nicReadFlags(&(_A)->ulFlags) & (_F))!= 0)
#define ADAPTER_SET_FLAG(_A, _F)                (nicSetFlags(&(_A)->ulFlags, (_F)))
#define ADAPTER_CLEAR_FLAG(_A, _F)              (nicClearFlags(&(_A)->ulFlags , (_F)))
#define ADAPTER_TEST_FLAGS(_A, _F)              ((nicReadFlags(&(_A)->ulFlags) & (_F)) == (_F))
#define ADAPTER_READ_FLAGS(_A)                  ((nicReadFlags(&(_A)->ulFlags) 
#define ADAPTER_ACTIVE(_A)                      ((((_A)->ulFlags) & fADAPTER_VDOInactive) != fADAPTER_VDOInactive)

#define BCR_TEST_FLAG(_A, _F)               ((nicReadFlags(&(_A)->BCRData.Flags) & (_F))!= 0)
#define BCR_SET_FLAG(_A, _F)                (nicSetFlags(&(_A)->BCRData.Flags, (_F)))
#define BCR_CLEAR_FLAG(_A, _F)              (nicClearFlags(&(_A)->BCRData.Flags , (_F)))
#define BCR_CLEAR_ALL_FLAGS(_A)            ((_A)->BCRData.Flags = 0) 
#define BCR_TEST_FLAGS(_A, _F)              ((nicReadFlags(&(_A)->BCRData.Flags) & (_F)) != 0)
#define BCR_READ_FLAGS(_A)                  ((nicReadFlags(&(_A)->BCRData.Flags) 
#define BCR_IS_VALID(_B)                    ((_B)->NC_One == 1 && (_B)->NC_Valid ==1)
#define IS_A_BCR(_B)                        ((_B)->NC_One == 1 )

#define LOOKASIDE_HEADER_SET_FLAG(_H, _F)       (nicSetFlags(&(_H)->State.u.Flags, (_F)))
#define LOOKASIDE_HEADER_TEST_FLAG(_H, _F)      ((nicReadFlags(&(_H)->State.u.Flags) & (_F))!= 0)
    
#define REASSEMBLY_ACTIVE(_R)               (((_R)->Flags & (REASSEMBLY_ABORTED | REASSEMBLY_FREED)) == 0)
#define REASSEMBLY_TEST_FLAG(_R,_F)         ((nicReadFlags(&(_R)->Flags) & (_F))!= 0)
#define REASSEMBLY_SET_FLAG(_R,_F)          (nicSetFlags(&(_R)->Flags, (_F)))
#define REASSEMBLY_CLEAR_FLAG(_R,_F)        (nicClearFlags(&(_R)->Flags , (_F)))


#define NIC_GET_SYSTEM_ADDRESS_FOR_MDL(_M) MmGetSystemAddressForMdl(_M)
#define NIC_GET_BYTE_COUNT_FOR_MDL(_M) MmGetMdlByteCount(_M)

#define nicNdisBufferVirtualAddress(_N)     NdisBufferVirtualAddress(_N)
#define nicNdisBufferLength(_N)             NdisBufferLength(_N)

//
// These macros are used to assert that the IRQL level remains the same
// at the beginning and end of a function
//
#if DBG

#define STORE_CURRENT_IRQL                  UCHAR OldIrql = KeGetCurrentIrql();
#define MATCH_IRQL                          ASSERT (OldIrql == KeGetCurrentIrql() ); 

#else

#define STORE_CURRENT_IRQL                  
#define MATCH_IRQL                          
#endif // if DBG



#define nicInitializeCallRef(_pV)           nicInitializeRef (&(_pV)->Hdr.CallRef);
#define nicCloseCallRef(_pV)                nicCloseRef (&(_pV)->Hdr.CallRef);



//
// Macros used to acquire and release lock by the data structures (Vc, AF, Adapter)
// Right now, they all point to the same lock (i.e.) the lock in the Adapter structure
//

#define VC_ACQUIRE_LOCK(_pVc)               NdisAcquireSpinLock (_pVc->Hdr.plock);
#define VC_RELEASE_LOCK(_pVc)               NdisReleaseSpinLock (_pVc->Hdr.plock);

#define AF_ACQUIRE_LOCK(_pAF)               NdisAcquireSpinLock (&_pAF->pAdapter->lock);
#define AF_RELEASE_LOCK(_pAF)               NdisReleaseSpinLock (&_pAF->pAdapter->lock);

#define ADAPTER_ACQUIRE_LOCK(_pA)           NdisAcquireSpinLock (&_pA->lock);
#define ADAPTER_RELEASE_LOCK(_pA)           NdisReleaseSpinLock (&_pA->lock);

#define REMOTE_NODE_ACQUIRE_LOCK(_pP)       NdisAcquireSpinLock (&_pP->pAdapter->lock);
#define REMOTE_NODE_RELEASE_LOCK(_pP)       NdisReleaseSpinLock (&_pP->pAdapter->lock);

#define REASSEMBLY_ACQUIRE_LOCK(_R)         REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK(_R->pRemoteNode);
#define REASSEMBLY_RELEASE_LOCK(_R)         REMOTE_NODE_REASSEMBLY_RELEASE_LOCK(_R->pRemoteNode);

#ifdef TRACK_LOCKS


#define REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK(_Remote)                                    \
    nicAcquireSpinLock (&_Remote->ReassemblyLock , __FILE__ , __LINE__);


#define REMOTE_NODE_REASSEMBLY_RELEASE_LOCK(_Remote)                                                \
    nicReleaseSpinLock (&_Remote->ReassemblyLock , __FILE__ , __LINE__);




#else

#define REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK(_Remote)        NdisAcquireSpinLock (&_Remote->ReassemblyLock.NdisLock);
#define REMOTE_NODE_REASSEMBLY_RELEASE_LOCK(_Remote)        NdisReleaseSpinLock (&_Remote->ReassemblyLock.NdisLock);
  
#endif


#define REASSEMBLY_APPEND_FRAG_DESC(_pR, _Off, _Len)                        \
    _pR->FragTable[_pR->MaxOffsetTableIndex].Offset =_Off;                  \
    _pR->FragTable[_pR->MaxOffsetTableIndex].IPLength  = _Len;              \
    _pR->MaxOffsetTableIndex++;


//-----------------------------------------------------------------------------
//           S T A T S   &    F A I L U R E    M A C R O S 
//-----------------------------------------------------------------------------


// Used to distinguish stats collected that are collected in the various code paths

typedef enum 
{
    ChannelCodePath,
    FifoCodePath,
    ReceiveCodePath,
    NoMoreCodePaths
};


#if TRACK_FAILURE

extern ULONG            BusFailure;
extern ULONG            MallocFailure;
extern ULONG            IsochOverwrite;
extern ULONG            MaxIndicatedFifos;

#define nicInitTrackFailure()           BusFailure = 0;MallocFailure= 0;

#define nicIncrementBusFailure()        NdisInterlockedIncrement(&BusFailure);
#define nicIncrementMallocFailure()     NdisInterlockedIncrement(&MallocFailure);
#define nicIsochOverwritten()           NdisInterlockedIncrement(&IsochOverwrite);

#define  nicStatsRecordNumIndicatedFifos(_Num)                      \
        {                                                           \
            ULONG _N_ = (_Num);                                     \
            MaxIndicatedFifos = max((_N_), MaxIndicatedFifos);      \
        }

#define nicIncChannelSendMdl()     NdisInterlockedIncrement(&MdlsAllocated[ChannelCodePath]);
#define nicIncFifoSendMdl()         NdisInterlockedIncrement(&MdlsAllocated[FifoCodePath]);

#define nicDecChannelSendMdl()     NdisInterlockedIncrement(&MdlsFreed[ChannelCodePath]);
#define nicDecFifoSendMdl()         NdisInterlockedIncrement(&MdlsFreed[FifoCodePath]);

#define nicIncChannelRecvBuffer()     NdisInterlockedIncrement(&NdisBufferAllocated[ChannelCodePath]);
#define nicIncFifoRecvBuffer()         NdisInterlockedIncrement(&NdisBufferAllocated[FifoCodePath]);

#define nicDecChannelRecvBuffer()     NdisInterlockedIncrement(&NdisBufferFreed[ChannelCodePath]);
#define nicDecFifoRecvBuffer()         NdisInterlockedIncrement(&NdisBufferFreed[FifoCodePath]);


#define nicIncRecvBuffer(_bisFifo)    \
{                               \
    if (_bisFifo)               \
    {    nicIncFifoRecvBuffer(); }    \
        else                    \
    {    nicIncChannelRecvBuffer();} \
}

#define nicDecRecvBuffer(_bisFifo)    \
{                               \
    if (_bisFifo)               \
     {   nicDecFifoRecvBuffer();  }   \
    else                    \
     {   nicDecChannelRecvBuffer(); }\
}
        
       
#else

#define nicInitTrackFailure()           
#define nicIncrementBusFailure()        
#define nicIncrementMallocFailure()     
#define nicIsochOverwritten()           
#define  nicStatsRecordNumIndicatedFifos(_Num)                      
#define nicIncChannelSendMdl()     
#define nicIncFifoSendMdl()         
#define nicDecChannelSendMdl()     
#define nicDecFifoSendMdl()         
#define nicFreeMdlRecordStat()

#endif



#define nicInitQueueStats()
#define nicSetCountInHistogram(_PktsInQueue, _Stats)    
#define nicSetMax(_nicMax, _PktsInQueue)                
#define nicIncrementRcvTimerCount()
#define nicIncrementSendTimerCount()

//
// Isoch descriptor macros - Used in the send/recv code path
//
typedef enum 
{
    IsochNext,
    IsochTag,
    IsochChannelVc,
    MaxIsochContextIndex
    
} IsochContextIndex;

//
// The following structure is used to add more contexts to a work item.
// NOTE: the Adapter is passed in as the context always.
//
typedef  union _NIC_WORK_ITEM
{
    NDIS_WORK_ITEM NdisWorkItem;

    struct{
        NDIS_WORK_ITEM NdisWorkItem;
        PNDIS_REQUEST pNdisRequest;
        VCCB* pVc;
    } RequestInfo;

    struct{
        NDIS_WORK_ITEM NdisWorkItem;
        ULONG Start;
        PNDIS_REQUEST pNdisRequest;
    } StartArpInfo;


    struct {
        NDIS_WORK_ITEM NdisWorkItem;
    } Fifo;

} NIC_WORK_ITEM, *PNIC_WORK_ITEM;

#define STORE_CHANNELVC_IN_DESCRIPTOR(_pI,_pVc)     (_pI)->DeviceReserved[IsochChannelVc]  =(ULONG_PTR) _pVc
#define GET_CHANNELVC_FROM_DESCRIPTOR(_pI) (_pI)->DeviceReserved[IsochChannelVc]  

#define MARK_ISOCH_DESCRIPTOR_INDICATED(_pI)                                        \
    (_pI)->DeviceReserved[IsochTag]  = (ULONG)NIC1394_TAG_INDICATED;                \
    (_pI)->DeviceReserved[IsochNext]  = 0;


#define MARK_ISOCH_DESCRIPTOR_IN_REASSEMBLY(_pI)                                    \
    (_pI)->DeviceReserved[IsochTag]  = (ULONG)NIC1394_TAG_REASSEMBLY;               

#define CLEAR_DESCRIPTOR_OF_NDIS_TAG(_pI)                                           \
    (_pI)->DeviceReserved[IsochTag] = 0;


#define APPEND_ISOCH_DESCRIPTOR(_Old, _New)                                         \
    (_Old)->DeviceReserved[IsochNext]  = (ULONG_PTR)&((_New)->DeviceReserved[IsochNext]);


#define NEXT_ISOCH_DESCRIPTOR(_pI) (_pI)->DeviceReserved[IsochNext]


#define CLEAR_DESCRIPTOR_NEXT(_pI) (_pI)->DeviceReserved[IsochNext] = 0;

#define GET_MDL_FROM_IRB(_pM, _pI, _Op)                                             \
    if (_Op==AsyncWrite)                                                            \
    {                                                                               \
        _pM = _pI->u.AsyncWrite.Mdl;                                                \
    }                                                                               \
    else                                                                            \
    {                                                                               \
        ASSERT (_Op == AsyncStream);                                                \
        _pM = _pI->u.AsyncStream.Mdl ;                                              \
    }               
    
//
// Macros used to walk a doubly linked list. Only macros that are not defined in ndis.h
// The List Next macro will work on Single and Doubly linked list as Flink is a common
// field name in both
//

/*
PLIST_ENTRY 
ListNext (
    IN PLIST_ENTRY 
    );
    
PSINGLE_LIST_ENTRY 
ListNext (
    IN PSINGLE_LIST_ENTRY 
    );
*/
#define ListNext(_pL)                       (_pL)->Flink

/*
PLIST_ENTRY
ListPrev (
    IN LIST_ENTRY *
    );
*/        
#define ListPrev(_pL)                       (_pL)->Blink

#define OnlyElementInList(_pL)               (_pL->Flink == _pL->Blink ? TRUE : FALSE)

#define BREAK(_TM_Mode, _String)                        \
{                                                       \
        TRACE( TL_A, _TM_Mode, ( _String ) );           \
        break;                                          \
}                       



// USHORT
// SWAPBYTES_USHORT(USHORT  Val )
//
#define SWAPBYTES_USHORT(Val)   \
                ((((Val) & 0xff) << 8) | (((Val) & 0xff00) >> 8))


// ULONG
// SWAPBYTES_ULONG(ULONG    Val )
//

#define SWAPBYTES_ULONG(Val)    \
                ((((Val) & 0x000000ff) << 24)   |   \
                 (((Val) & 0x0000ff00) << 8)    |   \
                 (((Val) & 0x00ff0000) >> 8)    |   \
                 (((Val) & 0xff000000) >> 24) )



//
// nicRemoveEntry List
// Just add a check to make sure that we are actually pointing to a valid next
//
#define nicRemoveEntryList(_L)                  \
{                                               \
    ASSERT ((_L)->Flink != (_L));               \
    RemoveEntryList (_L);                       \
}
//#define nicFreeToNPagedLookasideList(_L, _E) NdisFreeToNPagedLookasideList(_L, _E)        
//#define nicDeleteLookasideList(_L) NdisDeleteNPagedLookasideList(_L)

//
// Timing Query Routines
//
#define nicQueryTickCount()                     \
    LARGE_INTEGER   TickStart;                  \
    KeQueryTickCount(&TickStart);   

#define nicPrintElapsedTicks(_s)                                                        \
{                                                                                       \
    LARGE_INTEGER       TickEnd, TickDiff;                                              \
    ULONG Increment = KeQueryTimeIncrement() ;                                          \
    KeQueryTickCount(&TickEnd);                                                         \
    TickDiff.QuadPart = TickEnd.QuadPart - TickStart.QuadPart;                          \
    TickDiff.QuadPart =  (TickDiff.QuadPart  * Increment);                              \
    DbgPrint (_s);                                                                      \
    DbgPrint("  TickStart %x %x, Time End %x %x Time Diff %x %x Increment %x\n",TickStart.HighPart , TickStart.LowPart , TickEnd.HighPart, TickEnd.LowPart, TickDiff.HighPart, TickDiff.LowPart, Increment);     \
}


#define nicEntryTimeStamp()                                 \
    UINT EntryMilliSec;                                     \
    EntryMilliSec= nicGetSystemTimeMilliSeconds();      
    



#if DO_TIMESTAMPS

void
nicTimeStamp(
    char *szFormatString,
    UINT Val
    );
    
#define  TIMESTAMP(_FormatString)           nicTimeStamp("TIMESTAMP %lu:%lu.%lu nic1394 " _FormatString "\n" , 0)
#define  TIMESTAMP1(_FormatString, _Val)        nicTimeStamp( "TIMESTAMP %lu:%lu.%lu ARP1394 " _FormatString  "\n" , (_Val))



#else // !DO_TIMESTAMPS


#define  TIMESTAMP(_FormatString)
#define  TIMESTAMP1(_FormatString, _Val)

#endif // !DO_TIMESTAMPS


#if ENTRY_EXIT_TIME 

#define TIMESTAMP_ENTRY(_String)            TIMESTAMP(_String)
#define TIMESTAMP_EXIT(_String)             TIMESTAMP(_String)

#else

#define TIMESTAMP_ENTRY(s);
#define TIMESTAMP_EXIT(s);

#endif


#if INIT_HALT_TIME

#define TIMESTAMP_INITIALIZE()   TIMESTAMP("==>InitializeHandler");
#define TIMESTAMP_HALT()       TIMESTAMP("<==Halt");

#else

#define TIMESTAMP_INITIALIZE()
#define TIMESTAMP_HALT()


#endif

//-----------------------------------------------------------------------------
//              S T A T I S T I C    M A C R O S
//-----------------------------------------------------------------------------


//
// Reasembly counts
//
#define nicReassemblyStarted(_pAdapter)     \
{                                       \
    NdisInterlockedIncrement( &(_pAdapter->AdaptStats.TempStats.ulNumOutstandingReassemblies)); \
    NdisInterlockedIncrement ( &(_pAdapter->Reassembly.PktsInQueue)); \
    NdisInterlockedIncrement ( &(_pAdapter->OutstandingReassemblies));\
}


#define nicReassemblyCompleted(_A)      \
{                                       \
    NdisInterlockedDecrement(&(_A->AdaptStats.TempStats.ulNumOutstandingReassemblies));\
    NdisInterlockedDecrement(&(_A->Reassembly.PktsInQueue));\
    NdisInterlockedDecrement ( &(_A->OutstandingReassemblies));\
}


#define nicReassemblyAborted(_A)    \
{                                   \
    NdisInterlockedDecrement ( &(_A->OutstandingReassemblies));     \
    NdisInterlockedIncrement (&(_A->AdaptStats.TempStats.ulAbortedReassemblies)); \
}


// 
//  Top level stat collection macros
//

#define nicIncrementRcvVcPktCount(_Vc, _Pkt)        \
{                                                   \
    if ((_Vc)->Hdr.VcType == NIC1394_RecvFIFO)      \
    {                                               \
        nicIncrementFifoRcvPktCount(_Vc, _Pkt);     \
    }                                               \
    else                                            \
    {                                               \
        nicIncrementChannelRcvPktCount(_Vc, _Pkt);  \
    }                                               \
}

#define nicIncrementVcSendPktCount(_Vc, _Pkt)       \
{                                                   \
    if ((_Vc)->Hdr.VcType == NIC1394_SendFIFO)      \
    {                                               \
        nicIncrementFifoSendPktCount(_Vc, _Pkt);    \
    }                                               \
    else                                            \
    {                                               \
        nicIncrementChannelSendPktCount(_Vc, _Pkt); \
    }                                               \
}


#define nicIncrementVcSendFailures(_Vc, _Pkt)       \
{                                                   \
    if ((_Vc)->Hdr.VcType == NIC1394_SendFIFO)      \
    {                                               \
        nicIncrementFifoSendFailures(_Vc, _Pkt);    \
    }                                               \
    else                                            \
    {                                               \
        nicIncrementChannelSendFailures(_Vc, _Pkt); \
    }                                               \
}


#define nicIncrementVcBusSendFailures(_Vc, _Pkt)        \
{                                                       \
    if ((_Vc)->Hdr.VcType == NIC1394_SendFIFO)          \
    {                                                   \
        nicIncrementFifoBusSendFailures(_Vc, _Pkt);     \
    }                                                   \
    else                                                \
    {                                                   \
        nicIncrementChannelBusSendFailures(_Vc, _Pkt);  \
    }                                                   \
}

#define nicIncrementVcBusSendSucess(_Vc, _Pkt)          \
{                                                       \
    if ((_Vc)->Hdr.VcType == NIC1394_SendFIFO)          \
    {                                                   \
        nicIncrementFifoBusSendSucess(_Vc, _Pkt);       \
    }                                                   \
    else                                                \
    {                                                   \
        nicIncrementChannelBusSendSucess(_Vc, _Pkt);    \
    }                                                   \
}




//
// Fifo counts
//
#define nicIncrementFifoSendPktCount(_Vc, _Pkt)         NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Fifo.ulSendNicSucess));
#define nicIncrementFifoSendFailures(_Vc, _Pkt)         NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Fifo.ulSendNicFail));
#define nicIncrementFifoBusSendFailures(_Vc,_Pkt)               NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Fifo.ulSendBusFail));
#define nicIncrementFifoBusSendSucess(_Vc,_Pkt)                 NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Fifo.ulSendBusSuccess));
#define nicIncrementFifoRcvPktCount(_Vc, _Pkt)              NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Fifo.ulRecv));

//
// Channel Counts
//
#define nicIncrementChannelSendPktCount(_Vc, _Pkt)      NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Channel.ulSendNicSucess));
#define nicIncrementChannelSendFailures(_Vc, _Pkt)      NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Channel.ulSendNicFail));
#define nicIncrementChannelBusSendFailures(_Vc,_Pkt)                NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Channel.ulSendBusFail));
#define nicIncrementChannelBusSendSucess(_Vc, _Pkt)             NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Channel.ulSendBusSuccess));
#define nicIncrementChannelRcvPktCount(_Vc, _Pkt)           NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Channel.ulRecv));



//
// Generic counts
//

#define nicIncrementSendCompletes(_Vc)  NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.ulNumSendsCompleted   )); \
                                NdisInterlockedIncrement(&NicSendCompletes);

#define nicIncrementSends(_Vc)  NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.ulNumSends)); \
                                NdisInterlockedIncrement (&NicSends);


#define nicIncrementBusSends(_Vc)  NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.ulNumBusSends)); \
                                   NdisInterlockedIncrement (&BusSends);


#define nicIncrementBusSendCompletes(_Vc)  NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.ulNumBusSendsCompleted )); \
                                NdisInterlockedIncrement(&BusSendCompletes);



//-----------------------------------------------------------------------------
//                  N I C   E R R O R    C O D E S 
//-----------------------------------------------------------------------------
#define NIC_ERROR_CODE_INVALID_UNIQUE_ID_0          0xbad0000
#define NIC_ERROR_CODE_INVALID_UNIQUE_ID_FF         0xbadffff



//-----------------------------------------------------------------------------
//           R E M O T E    N O D E    F U N C T I O N S
//-----------------------------------------------------------------------------



#if 0
VOID
NicMpNotifyHandler(
    IN  PDEVICE_OBJECT              RemoteNodePhysicalDeviceObject,
    IN  PDEVICE_OBJECT              LocalHostPhysicalDeviceObject,
    IN  ULONG                       UniqueId0,
    IN  ULONG                       UniqueId1,
    IN  NDIS1394ENUM_NOTIFY_CODE    NotificationCode
    );
#endif



NDIS_STATUS
nicInitializeRemoteNode(
    OUT REMOTE_NODE **ppRemoteNode,
    IN   PDEVICE_OBJECT p1394DeviceObject,
    IN   UINT64 UniqueId 
    );

NTSTATUS
nicAddRemoteNode(
    IN  PVOID                   Nic1394AdapterContext,          // Nic1394 handle for the local host adapter 
    IN  PVOID                   Enum1394NodeHandle,             // Enum1394 handle for the remote node      
    IN  PDEVICE_OBJECT          RemoteNodePhysicalDeviceObject, // physical device object for the remote node
    IN  ULONG                   UniqueId0,                      // unique ID Low for the remote node
    IN  ULONG                   UniqueId1,                      // unique ID High for the remote node
    OUT PVOID *                 pNic1394NodeContext             // Nic1394 context for the remote node
    );

NTSTATUS
nicRemoveRemoteNode(
    IN  PVOID                   Nic1394NodeContext      // Nic1394 context for the remote node
    );


NDIS_STATUS
nicFindRemoteNodeFromAdapter( 
    IN PADAPTERCB pAdapter,
    IN PDEVICE_OBJECT pRemotePdo,
    IN UINT64 UniqueId,
    IN OUT REMOTE_NODE ** ppRemoteNode
    );


NDIS_STATUS
nicGetLocalHostPdoBlock (
    IN PVCCB pVc,
    IN OUT REMOTE_NODE **ppRemoteNode
    );





NDIS_STATUS
nicRemoteNodeRemoveVcCleanUp (
    IN PREMOTE_NODE pRemoteNode
    );


UINT
nicNumOfActiveRemoteNodes(
    IN PADAPTERCB pAdapter 
    );


BOOLEAN
nicReferenceRemoteNode (
    IN REMOTE_NODE *pRemoteNode,
    IN REMOTE_NODE_REF_CAUSE Cause
    );


BOOLEAN
nicDereferenceRemoteNode (
    IN REMOTE_NODE *pRemoteNode,
    IN REMOTE_NODE_REF_CAUSE    Cause
    );


VOID
nicInitalizeRefRemoteNode(
    IN REMOTE_NODE *pRemoteNode
    );


BOOLEAN
nicCloseRefRemoteNode(
    IN REMOTE_NODE *pRemoteNode
    );
    

//-----------------------------------------------------------------------------
//          U T I L I T Y       F U N C T I O N S 
//-----------------------------------------------------------------------------

VOID
nicCallCleanUp(
    IN VCCB* pVc
    );


VOID
nicClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask
    );

BOOLEAN
nicCloseRef(
    IN PREF RefP
   );


VOID
nicReferenceAdapter(
    IN ADAPTERCB* pAdapter ,
    IN PCHAR pDebugPrint
    );

BOOLEAN
nicDereferenceCall(
    IN VCCB* pVc,
    IN PCHAR pDebugPrint
    );


BOOLEAN
nicDereferenceRef(
    IN PREF RefP,
    IN PLONG pRefCount
    );

VOID
nicDereferenceAdapter(
    IN PADAPTERCB pAdapter, 
    IN PCHAR pDebugPrint
    );



VOID
nicDereferenceVc(
    IN VCCB* pVc
    );




NDIS_STATUS
nicExecuteWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN ULONG ulArg3,
    IN ULONG ulArg4
    );


VOID
nicInitializeRef(
    IN PREF  RefP
        );


ULONG
nicReadFlags(
    IN ULONG* pulFlags
    );


VOID
nicReferenceAdapter(
    IN ADAPTERCB* pAdapter,
    IN PCHAR pDebugPrint
    );
    

BOOLEAN
nicReferenceCall(
    IN VCCB* pVc,
    IN PCHAR pDebugPrint
    );

    
BOOLEAN
nicReferenceRef(
    IN  PREF RefP,
    OUT PLONG pNumber
    );

VOID
nicReferenceVc(
    IN VCCB* pVc
    );

NDIS_STATUS
nicScheduleWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext
    );


VOID
nicSetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask
    );

CHAR*
nicStrDup(
    IN CHAR* psz
    );

CHAR*
nicStrDupNdisString(
    IN NDIS_STRING* pNdisString
    );

CHAR*
nicStrDupSized(
    IN CHAR* psz,
    IN ULONG ulLength,
    IN ULONG ulExtra
    );

VOID
nicUpdateGlobalCallStats(
    IN VCCB *pVc
    );

NDIS_STATUS
NtStatusToNdisStatus (
    NTSTATUS NtStatus 
    );


VOID
PrintNdisPacket (
    ULONG TM_Comp,
    PNDIS_PACKET pMyPacket
    );





VOID
nicAllocatePacket(
    OUT PNDIS_STATUS pNdisStatus,
    OUT PNDIS_PACKET *ppNdisPacket,
    IN PNIC_PACKET_POOL pPacketPool
    );


VOID
nicFreePacket(
    IN PNDIS_PACKET pNdisPacket,
    IN PNIC_PACKET_POOL pPacketPool
    );

VOID
nicFreePacketPool (
    IN PNIC_PACKET_POOL pPacketPool
    );


VOID
nicAcquireSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock,
    IN PUCHAR   FileName,
    IN UINT LineNumber
    );
    

VOID
nicReleaseSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock,
    IN PUCHAR   FileName,
    IN UINT LineNumber
);

VOID
nicInitializeNicSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock
    );


VOID 
nicFreeNicSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock
    );


VOID
nic1394DeallocPktLog(
    IN ADAPTERCB* pAdapter
    );

    
VOID
nic1394AllocPktLog(
    IN ADAPTERCB* pAdapter
    );

VOID
Nic1394LogPkt (
    PNIC1394_PKTLOG pPktLog,
    ULONG           Flags,
    ULONG           SourceID,
    ULONG           DestID,
    PVOID           pvData,
    ULONG           cbData
);

VOID
Nic1394InitPktLog(
    PNIC1394_PKTLOG pPktLog
    );



ULONG 
SwapBytesUlong(
    IN ULONG Val
    );

VOID
nicUpdatePacketState (
    IN PNDIS_PACKET pPacket,
    IN ULONG Tag
    );

UINT
nicGetSystemTime(
    VOID
    );
    
UINT
nicGetSystemTimeMilliSeconds(
    VOID
    );

 
VOID
nicGetFakeMacAddress(
    UINT64 *Euid, 
    MAC_ADDRESS *MacAddr
    );

VOID
nicWriteErrorLog (
    IN PADAPTERCB pAdapter,
    IN NDIS_ERROR_CODE ErrorCode,
    IN ULONG ErrorValue
    );

NDIS_STATUS
nicScheduleWorkItem (
    IN PADAPTERCB pAdapter,
    IN PNDIS_WORK_ITEM pWorkItem
    );

//-----------------------------------------------------------------------------
//          G L O B A L    V A R I A B L E S
//-----------------------------------------------------------------------------

UINT NumChannels;
//-----------------------------------------------------------------------------
//          E N U M E R A T O R         F U N C T I O N S 
//-----------------------------------------------------------------------------


extern ENUM1394_REGISTER_DRIVER_HANDLER     NdisEnum1394RegisterDriver;
extern ENUM1394_DEREGISTER_DRIVER_HANDLER   NdisEnum1394DeregisterDriver;
extern ENUM1394_REGISTER_ADAPTER_HANDLER    NdisEnum1394RegisterAdapter;
extern ENUM1394_DEREGISTER_ADAPTER_HANDLER  NdisEnum1394DeregisterAdapter;

extern NIC1394_CHARACTERISTICS Nic1394Characteristics;


NTSTATUS
NicRegisterEnum1394(
    IN  PNDISENUM1394_CHARACTERISTICS   NdisEnum1394Characteristcis
    );
    
VOID
NicDeregisterEnum1394(
    VOID
    );

VOID
Nic1394Callback(
    PVOID   CallBackContext,
    PVOID   Source,
    PVOID   Characteristics
    );

VOID
Nic1394RegisterAdapters(
    VOID
    );

NTSTATUS
Nic1394BusRequest(
    PDEVICE_OBJECT              DeviceObject,
    PIRB                        Irb
    );

NTSTATUS
Nic1394PassIrpDownTheStack(
    IN  PIRP            pIrp,
    IN  PDEVICE_OBJECT  pNextDeviceObject
    );

NTSTATUS
Nic1394IrpCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    );

VOID 
nicDumpMdl (
    IN PMDL pMdl,
    IN ULONG LengthToPrint,
    IN CHAR *str
    );
    
VOID
nicDumpPkt (
    IN PNDIS_PACKET pPacket,
    CHAR * str
    );

VOID
nicCheckForEthArps (
    IN PNDIS_PACKET pPkt
    );

VOID
nicGetMacAddressFromEuid (
	UINT64 *pEuid,
	MAC_ADDRESS *pMacAddr
	);
  


VOID
nicInitializeLoadArpStruct(
    PADAPTERCB pAdapter
    );

extern PCALLBACK_OBJECT             Nic1394CallbackObject;
extern PVOID                        Nic1394CallbackRegisterationHandle;


//-----------------------------------------------------------------------------
//          S T A T I S T I C    B U C K E T S          
//-----------------------------------------------------------------------------



extern STAT_BUCKET      SendStats;
extern STAT_BUCKET      RcvStats;
extern ULONG            nicMaxRcv;
extern ULONG            nicMaxSend;
extern ULONG            SendTimer;  // In ms
extern ULONG            RcvTimer; // In ms
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\receive.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// receive.c
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port Receive routines
//
// 2/13/1998 ADube Created, 
//

#include <precomp.h>
#define MAX_NUM_SLIST_ENTRY 0x10
#define FRAGMENT_NUM_INVALID ((UINT)-1)
//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
nicAllocateAddressRangeCallback( 
    IN PNOTIFICATION_INFO NotificationInfo 
);

VOID
nicAllocateAddressRangeDebugSpew(
    IN PIRB pIrb 
    );

NDIS_STATUS
nicGetInitializedAddressFifoElement(
    IN     UINT BufferLength, 
    IN OUT PADDRESS_FIFO *ppElement 
    );

NDIS_STATUS
nicGetEmptyAddressFifoElement(
    IN PADDRESS_FIFO *ppElement
    );
    
VOID
nicReceivePacketWorkItem(
    PNDIS_WORK_ITEM pWorkItem,
    PVOID   pContext
    );

VOID
nicAllocateRemainingFifoWorkItem (
    PNDIS_WORK_ITEM pNdisWorkItem, 
    IN PVOID Context
    );

VOID
nicFifoAllocationScheme (
    PRECVFIFO_VCCB pRecvFIFOVc
);

ULONG           ReassemblyAllocated = 0;
extern ULONG           NdisBufferAllocated[NoMoreCodePaths];
extern ULONG           NdisBufferFreed[NoMoreCodePaths];

//-----------------------------------------------------------------------------
// prototype implementation (alphabetically)
//-----------------------------------------------------------------------------


NDIS_STATUS
nicAllocateAddressRange(
    IN PADAPTERCB pAdapter,
    IN PRECVFIFO_VCCB pRecvFIFOVc
    )

/*++

Routine Description:
    This function will use the AllocateAddressRange Bus Api
    To do this it must initialize an S-list with structures
    Allocate and Initialize an Irb and an Irp and call the nic
    nicSubmitIrp routine
    This funcion is used by VCs. This routine will complete synchronously

        
Arguments:
    pAdapter - provides the PDO on which the IRP is sent,
    pRecvFIFOVc - Recv Fifo Vc on which the address range is allocated


Return Value:
        Success - if all allocations and Irp succeeds.

--*/
{

    PIRB                    pIrb = NULL;
    PIRP                    pIrp = NULL; 
    PSLIST_HEADER           pSlistHead = NULL;
    UINT                    cnt = 0;   
    PDEVICE_OBJECT          pPdo = NULL;
    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    UINT                    Length;
    ADDRESS_OFFSET          AddressOffset;
    UINT                    MaxNumSlistEntry = MAX_NUM_SLIST_ENTRY;
    BOOLEAN                 bRefCall = FALSE;
    STORE_CURRENT_IRQL;
    
        
    ASSERT (pRecvFIFOVc == pAdapter->pRecvFIFOVc);
    
    ASSERT (pRecvFIFOVc != NULL);

    TRACE( TL_T, TM_Recv, ( "==>nicAllocateAddressRange, pAdapter 8x, pRecvFIFOVc %x", pAdapter, pRecvFIFOVc ) );

    
    do
    {
        // Increment the Refcount on the VC, so we can gaurantee its presence
        //
        VC_ACQUIRE_LOCK (pRecvFIFOVc)   

        //
        // Add a reference to the pdo block. 
        // This reference is added to guarantee its presence
        // Removed in Free Address Range or at the end of the function
        //
        
        bRefCall =  nicReferenceCall ((PVCCB) pRecvFIFOVc, "nicAllocateAddressRange" ) ;

        VC_RELEASE_LOCK (pRecvFIFOVc);

        if ( bRefCall == FALSE )
        {
            //
            // This will only fail if the Vc is not activated
            //
            NdisStatus = NDIS_STATUS_FAILURE;
        
            break;
        }
        
        //
        //  Allocate an IRB                                                                                                                                
        //
        
        NdisStatus = nicGetIrb (&pIrb);
    
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }
    
        ASSERT (pIrb != NULL);
        
        //
        // Initalize the IrB with the correct values
        // AllocateAddressRange
        //

        ASSERT (pRecvFIFOVc->Hdr.Nic1394MediaParams.Destination.AddressType == NIC1394AddressType_FIFO);
        
        AddressOffset.Off_High = pRecvFIFOVc->Hdr.Nic1394MediaParams.Destination.FifoAddress.Off_High;

        AddressOffset.Off_Low = pRecvFIFOVc->Hdr.Nic1394MediaParams.Destination.FifoAddress.Off_Low;

        ASSERT (pRecvFIFOVc->Hdr.MTU !=0 );
        
        Length = pRecvFIFOVc->Hdr.MTU;
                
        nicInitAllocateAddressIrb( pIrb,    
                                pAdapter,
                                0,
                                Length,
                                0,
                                ACCESS_FLAGS_TYPE_WRITE|ACCESS_FLAGS_TYPE_BROADCAST,
                                NOTIFY_FLAGS_AFTER_WRITE,
                                &AddressOffset,
                                pRecvFIFOVc);
            
        //
        // Allocate an Irp
        //

    
        NdisStatus = nicGetIrp (pAdapter->pNextDeviceObject, &pIrp);
                                                                                                                                                             
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        ASSERT(pIrp != NULL);
    
        NdisStatus = nicSubmitIrp_LocalHostSynch(pAdapter,
                                               pIrp,
                                               pIrb );
                           

        //
        // Make this a synchronous call as this is during init
        //
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Recv, ( "nicAllocateAddressRange SUBMIT IRP FAILED NdisStatus %.8x", NdisStatus ) );

            break;
            
        }


        //
        // Check to see if the IoCallDriver succeeded
        //

        if(pIrp->IoStatus.Status == STATUS_SUCCESS)
        {
            NdisStatus = nicAllocateAddressRangeSucceeded (pIrb, pRecvFIFOVc);
            

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }
        else
        {
            ASSERT (pIrp->IoStatus.Status != STATUS_MORE_PROCESSING_REQUIRED);
            // else mark status as failure
            //
            // 
            //This means dereference will happen in this function
            NdisStatus = NDIS_STATUS_FAILURE;
            
        }
        //
        // we need to clean up the Irb and the Irp
        //

        
    } while (FALSE);

    //
    // Clean up -dereference the Call if things failed
    // If we successfully completed the Irp then all the references made above
    // will be dereferenced when the remote node goes away or the
    // Call is closed
    //
    // Deref the references that were made above. 
   
    VC_ACQUIRE_LOCK (pRecvFIFOVc);

    if (! NT_SUCCESS (NdisStatus))
    {
        if (bRefCall == TRUE)
        {
            nicDereferenceCall ( (PVCCB) pRecvFIFOVc , "nicAllocateAddressRange");

        }
        
    }
    
    VC_RELEASE_LOCK (pRecvFIFOVc);

    // We don't care about the status as we are just freeing locally allocated memory
    //
    if (pIrb != NULL)
    {
        nicFreeIrb (pIrb);
    }
    
    if (pIrp!= NULL)
    {
        nicFreeIrp (pIrp);
    }


    MATCH_IRQL

    TRACE( TL_T, TM_Recv, ( "<==nicAllocateAddressRange, pVc %.8x, Status %.8x ", pRecvFIFOVc, NdisStatus ) );

    return NdisStatus;

}
 



VOID
nicAllocateAddressRangeCallback( 
    IN PNOTIFICATION_INFO pNotificationInfo 
    )
/*++

Routine Description:
    This is the callback routine for the AllocateAddressRange that was done on a VC.
    We update statistics and then call the common Receive function.

Arguments:
    NotificationInfo - This structure contains the VC as context, the source of the packet
    and the length of the payload received by the ohci driver.

Return Value:


--*/
{
    PADAPTERCB pAdapter = (PADAPTERCB) pNotificationInfo->Context;
    PRECVFIFO_VCCB pRecvFIFOVc = pAdapter->pRecvFIFOVc;
    PNODE_ADDRESS pSenderNodeAddress = NULL;

    //
    // Debug spew for debugging
    //
    
    TRACE( TL_V, TM_Recv, ( "    Mdl is at %.8x",pNotificationInfo->Mdl ) );
       
    TRACE( TL_V, TM_Recv, ( "    ulLength is %.8x",pNotificationInfo->nLength) );
    
    TRACE( TL_V, TM_Recv, ( "    pNotificationInfo->RequestPacket %x, ", pNotificationInfo->RequestPacket) );

    TRACE( TL_V, TM_Recv, ( "    tLabel %x, ", ((PASYNC_PACKET)pNotificationInfo->RequestPacket)->AP_tLabel) );

    pSenderNodeAddress = & (((PASYNC_PACKET)pNotificationInfo->RequestPacket)->AP_Source_ID);

    TRACE( TL_V, TM_Recv, ( "    Senders' NodeAddress %x, ", pSenderNodeAddress->NA_Node_Number ) );

    TRACE (TL_V, TM_Reas,("tLabel %x    ", ((PASYNC_PACKET)pNotificationInfo->RequestPacket)->AP_tLabel));

    NdisInterlockedIncrement (&pRecvFIFOVc->NumIndicatedFifos);
    
    pNotificationInfo->Fifo->FifoList.Next = NULL;
    pNotificationInfo->Fifo->FifoMdl->Next = NULL;

    nicFifoAllocationScheme (pRecvFIFOVc);

    nicStatsRecordNumIndicatedFifos(pRecvFIFOVc->NumIndicatedFifos);

    nicReceiveCommonCallback (pNotificationInfo, 
                             (PVCCB)pRecvFIFOVc ,
                             AddressRange,
                             pNotificationInfo->Mdl );
}






NDIS_STATUS
nicAllocateAddressRangeSucceeded (
    IN PIRB pIrb,
    IN OUT PRECVFIFO_VCCB   pRecvFIFOVc
    )
/*++

Routine Description:

     This function updates all the Vc, PdoCb structures once the allocate address range Irb has succeeded
     If the Irp succeeds but the rempte node is going away then it will free the address range before
     returning
     The Irb is used to initialize the fields.  


Arguments:
     pIrb : The Irb that was used in the Irp that just succeeded
     pRecvFIFOVc: The RecvFifoVc that started the AllocateAddressRange


Return Value:
     Success: If the address returned is correct.

--*/    
{

    NDIS_STATUS             NdisStatus = NDIS_STATUS_FAILURE;
    BOOLEAN                 fPdoBeingRemoved = FALSE;
    NIC1394_FIFO_ADDRESS *pFifoAddress = NULL; 
    BOOLEAN                 fFirstAddressRangeOnVc = FALSE;

    //
    // These are pointers to the locations that the newly allocated address range needs to be copied to 
    //

    ADDRESS_RANGE           *pSrcAddressRange = &pIrb->u.AllocateAddressRange.p1394AddressRange[0];
    ADDRESS_RANGE           *pVcAddressRange = &pRecvFIFOVc->VcAddressRange;

    TRACE( TL_T, TM_Recv, ( "==>nicAllocateAddressRangeSucceeded pIrb %.8x, ", pIrb) );


    ASSERT (pIrb->u.AllocateAddressRange.AddressesReturned == 1);

    //
    // we expect this to be populated or 
    //
    ASSERT (pRecvFIFOVc != NULL);


    //
    // If both high and low are zero, the bus driver is doing something wrong, return  Failure
    //

    if (pSrcAddressRange->AR_Off_Low ==0 && pSrcAddressRange ->AR_Off_High == 0)
    {   
        // Some fun with DeMorgan's theorem
        ASSERT (pSrcAddressRange->AR_Off_Low!=0 || pSrcAddressRange ->AR_Off_High!=0);
        return NDIS_STATUS_FAILURE;
    }
    
    //
    // Copy the Address Ranges returned. For now just copy locally without allocating extra memory
    //

    pFifoAddress = &pRecvFIFOVc->Hdr.Nic1394MediaParams.Destination.FifoAddress;

    VC_ACQUIRE_LOCK (pRecvFIFOVc);

    do 
    {

        

        //
        // check to see if we need to update the Recv Fifo's structures. This needs to be done if the addresses are zeroes
        //
        if (pFifoAddress->Off_Low  == 0 && pFifoAddress->Off_High  == 0)
        {

            fFirstAddressRangeOnVc = TRUE;
            
            pFifoAddress->Off_Low  = pSrcAddressRange->AR_Off_Low;
            pFifoAddress->Off_High = pSrcAddressRange->AR_Off_High;


            pVcAddressRange->AR_Off_Low = pSrcAddressRange->AR_Off_Low;
            pVcAddressRange->AR_Off_High = pSrcAddressRange->AR_Off_High;
            pVcAddressRange->AR_Length = pSrcAddressRange->AR_Length;


        }
        else 
        {
            ASSERT (pFifoAddress->Off_Low == pSrcAddressRange->AR_Off_Low);
            ASSERT (pFifoAddress->Off_High == pSrcAddressRange->AR_Off_High);

        }

        pRecvFIFOVc->AddressesReturned = pIrb->u.AllocateAddressRange.AddressesReturned;
        pRecvFIFOVc->hAddressRange = pIrb->u.AllocateAddressRange.hAddressRange;

    
        //
        // If we reached this far, we have succeeded
        //
        NdisStatus = NDIS_STATUS_SUCCESS;   

    } while (FALSE);

    VC_RELEASE_LOCK (pRecvFIFOVc);
    TRACE( TL_T, TM_Recv, ( "   hAddressRange %x, NumReturned %x , Low %x , Hi %x, Length %x", 
                             pRecvFIFOVc->hAddressRange ,
                             pRecvFIFOVc->AddressesReturned,
                             pSrcAddressRange->AR_Off_Low,
                             pSrcAddressRange->AR_Off_High,
                             pSrcAddressRange->AR_Length) );




    TRACE( TL_T, TM_Recv, ( "<==nicAllocateAddressRangeSucceeded Status %.8x", NdisStatus ) );

    return NdisStatus;
}


VOID
nicFreeAddressFifo(
    IN PADDRESS_FIFO pAddressFifo,
    IN PRECVFIFO_VCCB pRecvFIFOVc 
    )
/*++

Routine Description:
    Takes a single AddressFifo element, frees it and dereferences the 
    VC on which it was allocated.

Arguments:
    pAddressFifo - The AddressFifo being freed.
    pRecvFIFOVc - VC on which the Address fifo was allocated.


Return Value:


--*/

{

    PVOID SystemAddress = NIC_GET_SYSTEM_ADDRESS_FOR_MDL (pAddressFifo->FifoMdl);
    UINT Length = MmGetMdlByteCount(pAddressFifo->FifoMdl);

    ASSERT (SystemAddress!=NULL);
    ASSERT (Length != 0);
    
    TRACE( TL_T, TM_Recv, ( "==>nicFreeAddressFifo") );

    if (SystemAddress != NULL)
    {
        nicFreeLocalBuffer(Length, SystemAddress);
    }
    
    nicFreeMdl (pAddressFifo->FifoMdl);

    FREE_NONPAGED((PVOID)pAddressFifo);

    //
    // Dereference the reference added when this AddressFifo was inserted into the list
    //

    nicDereferenceCall ((PVCCB)pRecvFIFOVc, "nicFreeAddressFifo");

    

    TRACE( TL_T, TM_Recv, ( "<==nicFreeAddressFifo") );

    return ;
}


VOID
nicFreeAllocateAddressRangeSList(
    IN PRECVFIFO_VCCB pRecvFIFOVc 
    )
/*++

Routine Description:
    
   This function should pop entries from the Slist
   Each entry is an Adress_fifo element containing an MDl
   The function should call nicFreeAddressFifo to free the Address FIFO element
     

Arguments:
    pRecvFIFOVc - RecvFIfoVc which has the list of Fifo Entries 
                  which need to be freed.

Return Value:


--*/
{

    PADDRESS_FIFO       pAddressFifoElement = NULL;
    SLIST_ENTRY   *pSingleListEntry = NULL;
    UINT                NumFreed = 0;

    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Recv, ( "==>nicFreeAllocateAddressRangeSList, Num %.8x", 
                              ExQueryDepthSList (&pRecvFIFOVc->FifoSListHead) ) );

    while ( ExQueryDepthSList (&pRecvFIFOVc->FifoSListHead) != 0)
    {
        pSingleListEntry= ExInterlockedPopEntrySList ( &pRecvFIFOVc->FifoSListHead,
                                                  &pRecvFIFOVc->FifoSListSpinLock );

        //
        // This will dereference the call
        //
        pAddressFifoElement = CONTAINING_RECORD (pSingleListEntry, ADDRESS_FIFO, FifoList);

        ASSERT (pAddressFifoElement != NULL);

        //
        // This will dereference the Vc and free the address fifo
        //
        nicFreeAddressFifo ( pAddressFifoElement, 
                                          pRecvFIFOVc ); 
        NumFreed ++;                                          
    }

    VC_ACQUIRE_LOCK (pRecvFIFOVc);

    ASSERT ( ExQueryDepthSList (&pRecvFIFOVc->FifoSListHead) == 0);
    
    pRecvFIFOVc->FifoSListHead.Alignment = 0;
    pRecvFIFOVc->NumOfFifosInSlistInCloseCall = NumFreed;

    VC_RELEASE_LOCK (pRecvFIFOVc);


    MATCH_IRQL;

    TRACE( TL_T, TM_Recv, ( "<==nicFreeAllocateAddressRangeSList, NumFreed %x", NumFreed  ) );
    return ;

}






NDIS_STATUS
nicFillAllocateAddressRangeSList(
    PRECVFIFO_VCCB pRecvFIFOVc,
    UINT *Num )
/*++

Routine Description:
      Function inits the Slist that will be sent down with the 
      AllocateAddressRange Irb

      It is the responsibility of the caller to free the Allocated memory
    

Arguments:
      RecvFifoVc - VC to be linked with the Slist
      Num - Num  of AddressFifo Elements that are inserted into the SList

Return Value:

    Num  - Contains the number of Fifo elements that were inserted into the Slist
    Status - Success if all allocations succeeded.
    
--*/
    
     
{


    PADDRESS_FIFO pRecvFifoElement = NULL;
    NDIS_STATUS NdisStatus;
    UINT cnt = 0;
    BOOLEAN bRef = FALSE;

    TRACE( TL_T, TM_Recv, ( "==>nicFillAllocateAddressRangeSList" ) );

    ASSERT (pRecvFIFOVc != NULL);

    ASSERT (pRecvFIFOVc->Hdr.MTU != 0);


    do
    {
  
        NdisStatus = nicGetInitializedAddressFifoElement (pRecvFIFOVc->Hdr.MTU, 
                                                    &pRecvFifoElement);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        ASSERT (pRecvFifoElement  != NULL);
 
        ExInterlockedPushEntrySList ( &pRecvFIFOVc->FifoSListHead,
                                     (PSLIST_ENTRY)&pRecvFifoElement->FifoList,
                                     &pRecvFIFOVc->FifoSListSpinLock);

        //
        // Add this once for every Address Fifo element inserted 
        // Will be decremented by  a call to nicFreeAddressFifo
        //
        VC_ACQUIRE_LOCK (pRecvFIFOVc);

        bRef = nicReferenceCall ((PVCCB) pRecvFIFOVc, "nicFillAllocateAddressRangeSList");

        VC_RELEASE_LOCK (pRecvFIFOVc);
        
        if (bRef == FALSE)
        {
            NdisStatus = NDIS_STATUS_VC_NOT_ACTIVATED;
            break;
        }

        TRACE( TL_V, TM_Recv, ( "cnt %.8x, Num %.8x, ",cnt, *Num) );

    } while (++cnt < *Num);

    //
    // Need to handle failure cases and also return number allocated
    //
    *Num = cnt;

    
    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_V, TM_Recv, ( "nicFillAllocateAddressRangeSList Failed, num allotted %.8x, MTU %,8x ",cnt ,pRecvFIFOVc->Hdr.MTU ) );

        nicFreeAllocateAddressRangeSList (pRecvFIFOVc);

        ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);
    }

    TRACE( TL_T, TM_Recv, ( "==>nicFillAllocateAddressRangeSList Num %.8x, MTU %.8x",cnt,pRecvFIFOVc->Hdr.MTU ) );

    return NdisStatus;
}





NDIS_STATUS
nicGetInitializedAddressFifoElement(
    IN     UINT BufferLength, 
    IN OUT PADDRESS_FIFO *ppElement 
    )
/*++

Routine Description:
    
     This function return a single  AddressFifo element, 
     with an MDL pointing to locally owned allocated memory
     The size of the memory needs to be specified at MTU of
     the VC that this belongs to and is the BufferLength. 
    
     Get locally owned buffer, get address fifo , init MDL with
     local buffer. return the AddressFifo
    

Arguments:
    BufferLength - The length of the buffer that the Address_fifo contains, 
    *ppElement - output variable


Return Value:

    *ppElement - contains the allocated structure
    Status - On a failure, it contains the appropriate failure code.

--*/


{


    PVOID pLocalBuffer = NULL;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;

    TRACE( TL_T, TM_Recv, ( "==>nicGetAddressInitializedFifoElement" ) );
    
    ASSERT (BufferLength != 0);
    do
    {
        if (BufferLength == 0)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            TRACE( TL_A, TM_Recv, ( "BufferLength is 0" ) );

            break;
        }
        //
        // Get Locally owned memory for the data
        // 
        NdisStatus = nicGetLocalBuffer (BufferLength, &pLocalBuffer);
        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            (*ppElement) = NULL;
            break;
        }

        //
        // Get Empty memory for the Address Fifo element
        //
        NdisStatus = nicGetEmptyAddressFifoElement (ppElement);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            nicFreeLocalBuffer (BufferLength, 
                            pLocalBuffer);

            (*ppElement) = NULL;
            
            break;
        }

        //
        // Get an MDL and initialze the MDL with the buffer 
        // and initialize the fifo ,with MDL. 
        //
        NdisStatus = nicGetMdl ( BufferLength,
                   pLocalBuffer,
                   &((*ppElement)->FifoMdl));

        if (NdisStatus != NDIS_STATUS_SUCCESS || (*ppElement)->FifoMdl == NULL)
        {
            nicFreeLocalBuffer (BufferLength, 
                            pLocalBuffer);

            FREE_NONPAGED (*ppElement);

            (*ppElement) = NULL;

        }

    } while(FALSE);
    

    TRACE( TL_T, TM_Recv, ( "<==nicGetInitializedAddressFifoElement, Status %.8x, AddressFifo at %.8x, LocalBuffer at %.8x", 
                              NdisStatus, *ppElement,MmGetMdlVirtualAddress((*ppElement)->FifoMdl ) ) );
    
    return NdisStatus;

}


NDIS_STATUS
nicGetEmptyAddressFifoElement(
    IN PADDRESS_FIFO *ppElement
    )
/*++

Routine Description:

    Allocates and zeroes and empty Address_Fifo structure.
    
Arguments:
    ppElement - Output value

Return Value:
    On failure ppElement contains NULL and the appropriate Status 
    is returned
    

--*/
{


    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    ULONG Size = 0;
    TRACE( TL_T, TM_Recv, ( "==>nicGetEmptyAddressFifoElement" ) );

    Size = sizeof (ADDRESS_FIFO );
    
    *ppElement = ALLOC_NONPAGED (Size, MTAG_FIFO);

    if (*ppElement != NULL)
    {
        NdisZeroMemory (*ppElement, Size);
        
        NdisStatus = NDIS_STATUS_SUCCESS;
    }

    TRACE( TL_T, TM_Recv, ( "<==nicGetEmptyAddressFifoElement, Status % .8x, at %.8x",NdisStatus,*ppElement ) );
       

    return NdisStatus;


}



NDIS_STATUS
nicGetNdisBuffer(
    IN UINT Length,
    IN PVOID pLocalBuffer,
    IN OUT PNDIS_BUFFER *ppNdisBuffer 
    )
/*++

Routine Description:

    Given a buffer and Length, this function allocates an NdisBuffer (MDL) to point
    to that buffer

Arguments:
    Length - Length of the buffer,
    pLocalBuffer - pointer to the buffer,
    *ppNdisBuffer  output variable that contains the MDL


Return Value:
    Status - Appropriate Status code
    ppNDisBuffer - NDisBuffer if allocation succeeds.

--*/
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    ASSERT (pLocalBuffer != NULL);
    ASSERT (Length > 0);
    ASSERT (ppNdisBuffer != NULL);
    
    TRACE( TL_T, TM_Recv, ( "==>nicGetNdisBuffer Local Buffer %.8x, Length %.8x", pLocalBuffer, Length) );

    if ( Length > 0 &&
       pLocalBuffer != NULL &&
       ppNdisBuffer != NULL)
    {
        NdisAllocateBuffer( &NdisStatus,
                            ppNdisBuffer,
                            NULL,
                            pLocalBuffer,
                            Length );
    }
    else
    {
        nicIncrementMallocFailure();
        NdisStatus = NDIS_STATUS_FAILURE;
    }


    TRACE( TL_T, TM_Recv, ( "<==nicGetNdisBuffer  Buffer %x, NdisStatus %.8x", *ppNdisBuffer, NdisStatus  ) );
    return NdisStatus;

}





NDIS_STATUS
nicInitAllocateAddressIrb(
   IN PIRB                  pIrb,   
   IN PVOID                 pContext,   
   IN ULONG                 fulFlags,
   IN ULONG                 nLength,
   IN ULONG                 MaxSegmentSize,
   IN ULONG                 fulAccessType,
   IN ULONG                 fulNotificationOptions,
   IN PADDRESS_OFFSET       pOffset,
   IN PRECVFIFO_VCCB        pRecvFIFOVc
   )
/*++

Routine Description:
    
    Initializes the allocate adddress Irb with the 
    values passed to the function
    
    And adds constants for certain preknown values (e.g. callback, context)

    Spew as much debug as possible
    
   
Arguments:
    Are taken from the AllocateAddress Irb from 1394.h


Return Value:
    None

--*/
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    ASSERT (pRecvFIFOVc != NULL);

    TRACE( TL_T, TM_Recv, ( "==>nicInitAllocateAddressIrb" ) );

    pIrb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;
    pIrb->Flags = 0;
    pIrb->u.AllocateAddressRange.Mdl = NULL;
    pIrb->u.AllocateAddressRange.fulFlags = 0;
    pIrb->u.AllocateAddressRange.nLength = nLength;
    pIrb->u.AllocateAddressRange.MaxSegmentSize = 0;
    pIrb->u.AllocateAddressRange.fulAccessType = fulAccessType;
    pIrb->u.AllocateAddressRange.fulNotificationOptions = NOTIFY_FLAGS_AFTER_WRITE;
    pIrb->u.AllocateAddressRange.Callback = nicAllocateAddressRangeCallback;
    pIrb->u.AllocateAddressRange.Context = pContext; // should be pAdapter

    
    pIrb->u.AllocateAddressRange.Required1394Offset.Off_High = pOffset->Off_High;
    pIrb->u.AllocateAddressRange.Required1394Offset.Off_Low = pOffset->Off_Low;

    pIrb->u.AllocateAddressRange.FifoSListHead = &pRecvFIFOVc->FifoSListHead;
    pIrb->u.AllocateAddressRange.FifoSpinLock = &pRecvFIFOVc->FifoSListSpinLock;
    
    pIrb->u.AllocateAddressRange.AddressesReturned = 0;
    pIrb->u.AllocateAddressRange.p1394AddressRange = &pRecvFIFOVc->VcAddressRange;

    



    TRACE(TL_V, TM_Recv, ("nLength = 0x%x\n", pIrb->u.AllocateAddressRange.nLength));
    TRACE(TL_V, TM_Recv, ("MaxSegmentSize = 0x%x\n", pIrb->u.AllocateAddressRange.MaxSegmentSize));
    TRACE(TL_V, TM_Recv, ("fulAccessType = 0x%x\n", pIrb->u.AllocateAddressRange.fulAccessType));
    TRACE(TL_V, TM_Recv, ("fulNotificationOptions = 0x%x\n", pIrb->u.AllocateAddressRange.fulNotificationOptions));
    TRACE(TL_V, TM_Recv, ("Callback = 0x%x\n", pIrb->u.AllocateAddressRange.Callback));
    TRACE(TL_V, TM_Recv, ("Context = 0x%x\n", pIrb->u.AllocateAddressRange.Context));
    TRACE(TL_V, TM_Recv, ("Required1394Offset->Off_High = 0x%x\n", pIrb->u.AllocateAddressRange.Required1394Offset.Off_High));
    TRACE(TL_V, TM_Recv, ("Required1394Offset->Off_Low = 0x%x\n", pIrb->u.AllocateAddressRange.Required1394Offset.Off_Low));
    TRACE(TL_V, TM_Recv, ("FifoSListHeader = 0x%x\n", pIrb->u.AllocateAddressRange.FifoSListHead));
    TRACE(TL_V, TM_Recv, ("FifoSListSpinLock = 0x%x\n", pIrb->u.AllocateAddressRange.FifoSpinLock));
    TRACE(TL_V, TM_Recv, ("AddressesReturned = 0x%x\n", pIrb->u.AllocateAddressRange.AddressesReturned));
    TRACE(TL_V, TM_Recv, ("p1394AddressRange = 0x%x\n", pIrb->u.AllocateAddressRange.p1394AddressRange));


    TRACE( TL_T, TM_Recv, ( "<==nicInitAllocateAddressIrb" ) );
       
    return NdisStatus;

}




VOID 
nicFifoReturnPacket (
    IN PVCCB pVc,
    IN PNDIS_PACKET pMyPacket
    )

/*++

Routine Description:
       For FIFO's, this will reinsert the buffer (MDL) into  the Fifo SList
       Checks to see if the VC is active and then return it ot the SList . 
       Free the FifoElement otherwise 

Arguments:
    pVc - VC on which the packet is being returned.
    pMyPacket - that contains the packet that contains the Fifo list


Return Value:


--*/
{
    PRECVFIFO_VCCB          pRecvFIFOVc  = (PRECVFIFO_VCCB) pVc; 
    PNDIS_BUFFER            pMyNdisBuffer;
    PADAPTERCB              pAdapter = pRecvFIFOVc->Hdr.pAF->pAdapter;
    BOOLEAN                 fVcActive = FALSE;
    PADDRESS_FIFO           pAddressFifo;
    PPKT_CONTEXT            pPktContext = (PPKT_CONTEXT)&pMyPacket->MiniportReserved;   
    
    
    TRACE( TL_T, TM_Recv, ( "==>nicFifoReturnPacket pVc %x, pPacket %x, pAdapter %x, ", 
                             pRecvFIFOVc, pMyPacket, pAdapter) );


    //
    // Either the reassembly structure has the indicated Fifo's or if no reassembly was done
    // then the PktContext has it.
    //
    pAddressFifo = pPktContext->AllocateAddressRange.pIndicatedFifo;    

    // 
    // Do not push it back in the list if the VC is about to close. 
    // However, we push it back in, if the VC has not been activated yet
    //

    
    nicReturnFifoChain ( pAddressFifo , pRecvFIFOVc) ;
    

    //
    // Now we have to free the packet and ndis buffers that we got in the 
    // Calback code
    //
    TRACE( TL_V, TM_Recv, ( " AllocateAddress Range - Free Packet and Free Buffer" ) );

    nicReturnNdisBufferChain  (pMyPacket->Private.Head, pVc);

    nicFreePacket(pMyPacket, &pRecvFIFOVc->PacketPool);
    

    TRACE( TL_T, TM_Recv, ( "<==nicFifoReturnPacket "  ) );


    return;

}

VOID
nicReturnNdisBufferChain (
    IN PNDIS_BUFFER pNdisBuffer ,
    IN PVCCB pVc
    )
/*++

Routine Description:

    This functions frees a list of NDIS Buffers
    
Arguments:

    pNdisBuffer - NdisBufferChain
    VC  - not used except for statistics.

Return Value:


--*/
{
    PNDIS_BUFFER pNext;
    BOOLEAN fIsFifo = (pVc->Hdr.VcType == NIC1394_RecvFIFO);

    if (pNdisBuffer == NULL)
    {
        ASSERT (pNdisBuffer != NULL);
        return;
    }


    while (pNdisBuffer != NULL)
    {
        pNext = pNdisBuffer->Next;

        NdisFreeBuffer(pNdisBuffer);

        nicDecRecvBuffer(fIsFifo);
        pNdisBuffer = pNext;
    } 

}









VOID
nicReturnFifoChain (
    IN PADDRESS_FIFO pAddressFifo,
    IN PRECVFIFO_VCCB pRecvFIFOVc
    )
/*++

Routine Description:
    This takes a chain of Address Fifos and returns it to the slist if 
    the VC is active or frees the AddressFifo if the VC is not active

Arguments:
    pAddressFifo - Address Fifo that needs to be returned,
    pRecvFIFOVc - The VC which owns the AddressFifo


Return Value:

    None
    
--*/
{
    
    TRACE( TL_T, TM_Recv, ( "==> nicReturnFifoChain pAddressFifo %x, pRecvFifoVc %x", pAddressFifo, pRecvFIFOVc) );


    VC_ACQUIRE_LOCK (pRecvFIFOVc);

    //
    // lets update the value again, before we insert the Address Fifo back in to the Slist
    // If there are any remote nodes present and the VC is active 
    // , then we should insert this back into the SList
    //
    

    if  ( VC_ACTIVE (pRecvFIFOVc) == TRUE )
    {     

        //
        // Return all the AddressFifo elements to the slist
        // Do this with the lock held so no one can change the
        // VC state from under us
        //

            
        while (pAddressFifo != NULL)
        {
            PADDRESS_FIFO pNextFifo = (PADDRESS_FIFO)(pAddressFifo->FifoList.Next);

            ExInterlockedPushEntrySList ( &pRecvFIFOVc->FifoSListHead,
                                          (PSLIST_ENTRY)&pAddressFifo ->FifoList,
                                          &pRecvFIFOVc->FifoSListSpinLock);
        
            TRACE( TL_V, TM_Recv, ( "  VcActive Address Fifo %x, Next Fifo %x",pAddressFifo , pNextFifo) );

            pAddressFifo = pNextFifo;

            NdisInterlockedDecrement (&pRecvFIFOVc->NumIndicatedFifos);


        }

        VC_RELEASE_LOCK (pRecvFIFOVc);

    }
    else  //VC_ACTIVE (pRecvFIFOVc) == TRUE 
    {

        VC_RELEASE_LOCK (pRecvFIFOVc);
        //
        // free all the Address Fifo after releasing the lock
        //
            
        while (pAddressFifo != NULL)
        {
            PADDRESS_FIFO pNextFifo = (PADDRESS_FIFO)(pAddressFifo->FifoList.Next);

            // 
            // Free the Mdl and Address Fifo structure and decrease the refcount
            // on the call. Do not touch the Vc after this
            //

            TRACE( TL_V, TM_Recv, ( "  Vc NOT Active  Address Fifo %x, Next Fifo %x",pAddressFifo , pNextFifo) );

            nicFreeAddressFifo(pAddressFifo ,
                               pRecvFIFOVc);
        
            NdisInterlockedDecrement (&pRecvFIFOVc->NumIndicatedFifos);

            pAddressFifo = pNextFifo;

        }


    }

    TRACE( TL_T, TM_Recv, ( "<== nicReturnFifoChain ") );

    return; 
}




VOID
nicInternalReturnPacket(
    IN  PVCCB                   pVc ,
    IN  PNDIS_PACKET            pPacket
    )
/*++

Routine Description:
    Finds out what type of Vc is being indicated and calls the appropriate VC return packets handler

Arguments:
    MiniportAdapterContext  - the pAdapter structure,
    pPacket - pPacket that the protocol returns


Return Value:


--*/
{
    PPKT_CONTEXT    pPktContext = (PPKT_CONTEXT)&pPacket->MiniportReserved;


    switch (pVc->Hdr.VcType)
    {
        case NIC1394_SendRecvChannel:
        case NIC1394_RecvChannel:
        {
            nicChannelReturnPacket (pVc, pPacket );
            break;
        }
        case NIC1394_RecvFIFO:
        {
    
            nicFifoReturnPacket ( pVc, pPacket);        
            break;
        }

        
        default :
        {
            
            ASSERT (0);
            break;
        }



    }
    

    return;


}

VOID
NicReturnPacket(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            pPacket
    )
/*++

Routine Description:
    This is the return packets handler. 
    This functikon handles all the instrumentation to catch outstanding packets and 
    then calls the internal return packets function

Arguments:
    MiniportAdapterContext  - the pAdapter structure,
    pPacket - pPacket that the protocol returns


Return Value:


--*/
{

    PADAPTERCB      pAdapter = (PADAPTERCB) MiniportAdapterContext;
    PPKT_CONTEXT    pPktContext = (PPKT_CONTEXT)&pPacket->MiniportReserved;
    PINDICATE_RSVD  pIndicateRsvd  = NULL;
    PRSVD           pRsvd = NULL;

    //
    // The first parameter of the MiniportReserved will always contain the VC
    //

    PVCCB pVc = (PVCCB)pPktContext->AllocateAddressRange.pRecvFIFOVc;


    TRACE( TL_T, TM_Recv, ( "==> NicReturnPacket pPacket %x ", pPacket) );

    do
    {

        //
        // Mark the packet as returned
        //
        pRsvd =(PRSVD)(pPacket->ProtocolReserved);
        pIndicateRsvd = &pRsvd->IndicateRsvd;

        ASSERT (pIndicateRsvd->Tag == NIC1394_TAG_INDICATED);
        
        pIndicateRsvd->Tag =  NIC1394_TAG_RETURNED;

        nicInternalReturnPacket (pVc, pPacket);

    }while (FALSE);
    
    TRACE( TL_T, TM_Recv, ( " <== NicReturnPacket ") );

    return;
}



NDIS_STATUS
nicFindReassemblyStructure (
    IN PREMOTE_NODE pRemoteNode,
    IN USHORT Dgl,
    IN BUS_OPERATION BusOp,
    IN PVCCB pVc,
    OUT PNDIS1394_REASSEMBLY_STRUCTURE* ppReassembly
    )
/*++

Routine Description:

      Walk through all the reassembly operations on this remote node
      and see if one is present 
    
      If no reassembly is found, it will allocate and initialie a structure. 
      All within the context of the reassembly  lock  
    
     Arguments
     Return Value:
    
    

Arguments:

      pRemoteNode - Remote Node that is sending the fragments
      dgl  - identifier for reassembly packet

      Together they are unique for each reassembly operation

      BusOp - Isoch or Fifo
      pVc - on which the fragment has been indicated.
      ppReassembly - Output variable that is filled if the Reassembly is found.


Return Value:

    ppReassembly - Contains the allocated/found structure
    Status - appropriate failure code on failure.

--*/
{

    PNDIS1394_REASSEMBLY_STRUCTURE      pTempReassembly = NULL;
    PNDIS1394_REASSEMBLY_STRUCTURE      pReassembly = NULL;
    PLIST_ENTRY                         pReassemblyList = NULL;
    NDIS_STATUS                         NdisStatus = NDIS_STATUS_FAILURE;


    TRACE( TL_T, TM_Recv, ( "==>nicFindReassemblyStructure  pRemoteNode %x, dgl %x " , pRemoteNode , Dgl) );

    //
    // Acquire the reassebly lock . Only let go when either a reassembly structure is found or a new 
    // reassembly structure is inserted into the remote node's reassembly list
    //
    REMOTE_NODE_ACQUIRE_LOCK (pRemoteNode);
    REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK (pRemoteNode)

    pReassemblyList = pRemoteNode->ReassemblyList.Flink;

    //
    // Find the reassembly with the same dgl 
    // 
    
    while ( pReassemblyList != &pRemoteNode->ReassemblyList)
    {   
        pTempReassembly = CONTAINING_RECORD (pReassemblyList ,
                                               NDIS1394_REASSEMBLY_STRUCTURE,
                                               ReassemblyListEntry );
                                               
    
        TRACE( TL_V, TM_Recv, ( "Current Dgl %x, dgl %x " , pTempReassembly->Dgl , Dgl) );

        if (pTempReassembly->Dgl == Dgl)
        {
            pReassembly = pTempReassembly;
            break;
        }

        pReassemblyList  = pReassemblyList->Flink;
    }

    

    do 
    {
        //
        // If we have found a valid reassembly then return
        //

        if (pReassembly != NULL )
        {
            *ppReassembly = pReassembly ;

            NdisStatus = NDIS_STATUS_SUCCESS;
        }
        else
        {   
            //
            // If the number of outstanding reassemblies is excessive, do not 
            // allocate a new Reassembly strucutre. Drop the packet.
            //
            PADAPTERCB pAdapter = pRemoteNode->pAdapter;
            
            if (pAdapter->OutstandingReassemblies > NIC1394_MAX_REASSEMBLY_THRESHOLD)
            {
                NdisStatus = NDIS_STATUS_FAILURE;
                break;

            }
            
            //
            // We need to allocate and initialize  a reassembly structure
            // 
            NdisStatus = nicGetReassemblyStructure (&pReassembly);
            

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {

                BREAK (TM_Recv, ("    nicGetReassemblyStructure nicGetReassemblyStructure FAILED") ); 
            }

            NdisStatus = nicInitializeReassemblyStructure (pReassembly, 
                                                       Dgl, 
                                                       pRemoteNode, 
                                                       pVc, 
                                                       BusOp);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
            
                pReassembly = NULL;
                BREAK (TM_Recv, ("    nicFindReassemblyStructure nicInitializeReassemblyStructure FAILED" ) );
            }

        }
        
    } while (FALSE);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        //
        // Increment the ref count. Ref Count will be freed when the fragment is inserted into 
        // the reassembly structure or the packet indicated up
        //
        nicReferenceReassembly ( pReassembly, "nicFindReassemblyStructure " );
        
    }
    
    REMOTE_NODE_REASSEMBLY_RELEASE_LOCK (pRemoteNode)
    REMOTE_NODE_RELEASE_LOCK (pRemoteNode);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        //
        // Update output parameters
        //
        *ppReassembly = pReassembly;

    }
    TRACE( TL_T, TM_Recv, ( "<==nicFindReassemblyStructure NdisStatus %x, *ppReassembly %x" , NdisStatus ,*ppReassembly ) );

    return NdisStatus ;
}



NDIS_STATUS
nicGetReassemblyStructure ( 
    IN OUT PNDIS1394_REASSEMBLY_STRUCTURE* ppReassembly
    )
/*++

Routine Description:
      Just allocates a structure and returns
    
     Arguments
      
    
    
     Return Value:
      Success - if succeeded 
    
     Called with the lock held

Arguments:

      ppReassembly - to point to the newly allocated structure

Return Value:

      Success - if succeeded 
    
     Called with the lock held


--*/
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    TRACE( TL_T, TM_Recv, ( "==>nicGetReassemblyStructure  ppReassembly %x", ppReassembly ) );

    *ppReassembly = ALLOC_NONPAGED (sizeof (NDIS1394_REASSEMBLY_STRUCTURE), MTAG_REASSEMBLY);

    if (*ppReassembly == NULL)
    {
        nicIncrementMallocFailure();
        NdisStatus = NDIS_STATUS_FAILURE;

    }
    else
    {
        NdisZeroMemory (*ppReassembly, sizeof (NDIS1394_REASSEMBLY_STRUCTURE) );
        NdisStatus = NDIS_STATUS_SUCCESS;
        (*ppReassembly)->Tag = MTAG_REASSEMBLY;
        ReassemblyAllocated++;  
    }

    

    TRACE( TL_T, TM_Recv, ( " <==nicGetReassemblyStructure  NdisStatus %x, pReassembly %x", NdisStatus, *ppReassembly) );
    return NdisStatus;
}



VOID
nicFreeReassemblyStructure ( 
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly
    )

/*++

Routine Description:
    Just Frees the structure and returns

Arguments:
    ppReassembly - to point to the newly allocated structure


Return Value:
    None    

--*/
{
    TRACE( TL_T, TM_Recv, ( "== nicFreeReassemblyStructure  ppReassembly %x", pReassembly ) );

    pReassembly->Tag = MTAG_FREED;

    NdisInterlockedDecrement (&ReassemblyAllocated);
    
    nicDereferenceReassembly (pReassembly, "nicFreeReassemblyStructure ");

    return;
}


NDIS_STATUS
nicInitializeReassemblyStructure (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    IN USHORT Dgl,
    IN PREMOTE_NODE pRemoteNode,
    IN PVCCB pVc,
    IN BUS_OPERATION ReceiveOp
    )
/*++

Routine Description:
    Goes in and assigns values to all the fields in the structure

Arguments:
      pReassembly = pReassembly structure all zeroed out,
      Dgl,- Datagram Label to be used in reassembly 
      pRemoteNode - pRemoteNode pointing to the sender
      ReceiveOp - ISoch or Fifo
      Vc - On which the packet came in.
    

Return Value:

    Success : - If remote node active and this has been inserted into the remote node's list
    Failure - If remote Node is not active   
    Called with the lock held
    
--*/
{
    BOOLEAN fRemoteNodeActive = FALSE;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    PADAPTERCB pAdapter = pVc->Hdr.pAF->pAdapter;
    
    TRACE( TL_T, TM_Recv, ( "==> nicInitializeReassemblyStructure pReassembly %x, ReceiveOp %x", pReassembly, ReceiveOp ) );

    TRACE( TL_T, TM_Recv, ( "     pRemoteNode %x, Dgl %x, pVc %x ", pReassembly, Dgl, pVc ) );

    //
    // Increment the reassembly count
    //
    nicReassemblyStarted(pAdapter);
    pAdapter->AdaptStats.TempStats.ulMaxOutstandingReassemblies = 
                    max(pAdapter->AdaptStats.TempStats.ulMaxOutstandingReassemblies,
                         pAdapter->AdaptStats.TempStats.ulNumOutstandingReassemblies);

    
    //
    // Dgl  - Datagram label. Unique for every reassembly structure gernerated by this local host
    //
    pReassembly->Dgl = Dgl;


    //
    // pRemoteNode  -> RemoteNode + Dgl are unique for each reassembly structure
    //
    pReassembly->pRemoteNode = pRemoteNode;
    
    
    //
    // ExpectedFragmentOffset is computed by the Last Fragment's Offset + 
    // length of fragment. Does not account for gaps in the reassembled packet.
    // 
    pReassembly->ExpectedFragmentOffset = 0;



    //
    // LastNdisBuffer that was appended to the packet 
    //
    pReassembly->pTailNdisBuffer = NULL;

    //
    // Packet that is being reassembled
    //
    pReassembly->pNdisPacket = NULL;


    pReassembly->Head.pAddressFifo = NULL;
    pReassembly->Tail.pAddressFifo = NULL;
    pReassembly->ReceiveOp = ReceiveOp;
    pReassembly->pVc = pVc;
    

    //
    // Reference the remote node. This will be derefernced when the packet is returned
    //

    fRemoteNodeActive = (REMOTE_NODE_ACTIVE (pRemoteNode));

    TRACE( TL_V, TM_Recv, ( "  nicInitializeReassemblyStructure fRemoteNodeActive %x", fRemoteNodeActive) );


    if (fRemoteNodeActive  == TRUE) 
    {
        //
        // REfcount made as the reassembly will happen on the remote node. 
        // REfcount released when the last fragment is complete
        //
        nicReferenceRemoteNode (pRemoteNode, InitializeReassemblyStructure);

        InsertTailList(&pRemoteNode->ReassemblyList, &pReassembly->ReassemblyListEntry);

        //
        // Reerence REassembly . Ref removed when this is removed from the Remote node list
        //
        nicReferenceReassembly (pReassembly, "nicInitializeReassembly" );
    }
    

    if (fRemoteNodeActive  == FALSE)
    {
        //
        // Temporary assert 
        //

        FREE_NONPAGED (pReassembly);
        
        NdisStatus = NDIS_STATUS_FAILURE;
    }
    else
    {
        NdisStatus = NDIS_STATUS_SUCCESS;
    }

    //
    // reference the reassembly for its creation. Dereferenced in the Indicate Packet Code path
    //
    nicReferenceReassembly (pReassembly, " nicInitializeReassemblyStructure ");

    TRACE( TL_T, TM_Recv, ( "<== nicInitializeReassemblyStructure NdisStatus %x, pReassembly%x ", NdisStatus,pReassembly ) );

    return NdisStatus;
}


VOID
nicAbortReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly
    )
/*++

Routine Description:

    This thread can get called in one of two cases. 1) If the Remote node is going away
    and 2) if the Reassembly has timed out. In the former case, we have Remote Node lock and 
    that will stop any thread from accessing this list. In the latter case, the Reassembly struct
    has been removed from the Remote Node's Reassembly List while the RemoteNode lock was held. 
    This Reassembly structure now cannot be accessed by the Reassembly code or the RemoveRemoteNode code,
    no lock is held in the second case.
    
    This function will free all allocated NdisBuffers and return all AddressFifo 
    elements to the bus driver (or frees them if the VC is closing down).
    
Arguments

    pReasssembly - Reassembly structure that needs to be freed
        
Return Value:
      None

--*/
{

    PNDIS_BUFFER pNdisBuffer = NULL;
    PRECVFIFO_VCCB pRecvFIFOVc = NULL;
    PCHANNEL_VCCB pChannelVc  = NULL;
    PADAPTERCB pAdapter = pReassembly->pVc->Hdr.pAF->pAdapter;
    STORE_CURRENT_IRQL;

    
    
    TRACE( TL_T, TM_Recv, ( "==> nicAbortReassembly  pReassembly %x", pReassembly ) );

    
    //
    // Free all the ndis buffers and so forth
    //
    if (pReassembly != NULL)
    {   
        //
        // First Chain the reassembly array into a linked so our return functions can deal with it
        //
        nicChainReassembly (pReassembly);

        if (pReassembly->pHeadNdisBuffer != NULL)
        {
            nicReturnNdisBufferChain(pReassembly->pHeadNdisBuffer, pReassembly->pVc);         
        }

        switch (pReassembly->ReceiveOp)
        {
            case AddressRange:
            {
                pRecvFIFOVc = (PRECVFIFO_VCCB) pReassembly->pVc;


                //
                // Time to return all of our address fifos
                //
                nicReturnFifoChain (pReassembly->Head.pAddressFifo,
                                    pRecvFIFOVc
                                    );
                            
                pReassembly->Head.pAddressFifo = NULL;
                break;
            }

            case IsochReceive:
            {
                pChannelVc = (PCHANNEL_VCCB)pReassembly->pVc;

                nicReturnDescriptorChain ( pReassembly->Head.pIsochDescriptor,
                                       pChannelVc);
                                       
                pReassembly->Head.pIsochDescriptor = NULL;
                break;
            }


            default:
            {

                ASSERT (0);
            }


        }


    }
    else
    {
        ASSERT (0);
    }

    //
    // Now deref the reassembly and free it.
    //
    nicReassemblyAborted (pAdapter);
    nicFreeReassemblyStructure (pReassembly);

    TRACE( TL_T, TM_Recv, ( "<== nicAbortReassembly  pReassembly %x", pReassembly ) );
    MATCH_IRQL;
    return;
}



NDIS_STATUS
nicDoReassembly ( 
    IN PNIC_RECV_DATA_INFO pRcvInfo,
    OUT PNDIS1394_REASSEMBLY_STRUCTURE *ppReassembly,
    PBOOLEAN pfReassemblyComplete
    )
/*++

Routine Description:
       Does the reassembly work . 
       Allocates an ndisbuffer pointing to the data .
       Does In order or out of order reassembly
        
Arguments:
        pRcvInfo  - pRcv Information
        pReassembly reassmbly structure associated with this fragment
        pfReassemblyComplete - Is the REassembly complete
Return Value:
        Success - if this fragment was successfully associated with a reassembly structure

--*/
{
    NDIS_STATUS                                 NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS_BUFFER                                pNdisBuffer = NULL;
    PNDIS1394_REASSEMBLY_STRUCTURE              pReassembly = NULL;
    BOOLEAN                                     fInOrder = FALSE;
    BOOLEAN                                     fNeedToReleaseReassemblyLock = FALSE;
    BOOLEAN                                     fReassemblyComplete = FALSE;
    PADAPTERCB                                  pAdapter = pRcvInfo->pRemoteNode->pAdapter;

    STORE_CURRENT_IRQL;
    
    TRACE( TL_T, TM_Recv, ( "==> nicDoReassembly ppReassembly %x pRcvInfo %x",
                           ppReassembly, pRcvInfo ) );

    
    do
    {
        //
        // Get an NdisBuffer pointing to the data 
        //
        NdisStatus = nicGetNdisBufferForReassembly( pRcvInfo, &pNdisBuffer);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // If we break from here, the reassmbly will never get completed and the 
            // garbage collector will eventually free this.
            //
            pNdisBuffer = NULL;
            BREAK (TM_Send, ("nicDoReassembly  nicGetNdisBufferForReassembly FAILED" ) );

        }

                
        //
        // Either there is a reassembly currently going or one will be allocated and initialized
        //
        
        NdisStatus = nicFindReassemblyStructure (pRcvInfo->pRemoteNode, 
                                            pRcvInfo->Dgl, 
                                            pRcvInfo->RecvOp, 
                                            (PVCCB)pRcvInfo->pVc,
                                            &pReassembly);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            pReassembly=NULL;
            BREAK (TM_Recv, ("    nicDoReassembly  nicFindReassemblyStructure FAILED")); 
        }
    

        //
        // Now we start doing the actual work . Acquire the 
        // reassembly lock so no one else can touch the reassembly
        //
        
        
        ASSERT (pReassembly != NULL);
        TRACE( TL_V, TM_Recv, ( " ExpectedFragmentOffset  %x FragmentHeader Offset %x, ",
                               pReassembly->ExpectedFragmentOffset , pRcvInfo->FragmentOffset) );

        //
        // Code expects that if the reassembly is not Null, then the lock is acquired. 
        //
        REASSEMBLY_ACQUIRE_LOCK (pReassembly);
        fNeedToReleaseReassemblyLock = TRUE;

        
        if (REASSEMBLY_ACTIVE (pReassembly) == FALSE)
        {
            //
            // Drop the reassembly, as this structure is about to be freed
            // 
            NdisStatus = NDIS_STATUS_FAILURE;
            break;

        }


        //
        // This is the new reassembly scheme, which uses a table and does out of order and inorder
        // reassembly
        //
        

        NdisStatus = nicInsertFragmentInReassembly (pReassembly,
                                              pRcvInfo);
                                      

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // Do not assert
            //
            TRACE (TL_V,  TM_Reas, ("nicDoReassembly nicInsertFragmentInReassembly  FAILED") );
            break;
        }


        fReassemblyComplete = pReassembly->fReassemblyComplete;


        
    } while (FALSE);

    //
    // Release the reassembly lock (if acquired)
    //
    if (fNeedToReleaseReassemblyLock == TRUE)
    {
        REASSEMBLY_RELEASE_LOCK (pReassembly);

        if (fReassemblyComplete  == TRUE)
        {
            //
            // Dereference the remote node as we are removing the reassembly from the remote node
            //
            nicDereferenceReassembly (pReassembly, "nicInsertFragmentInReassembly " );
            //
            // now dereference the remote node. ref was added when the reassembly was
            // inserted into the remote node's list
            //
            nicDereferenceRemoteNode(pReassembly->pRemoteNode, InsertFragmentInReassembly );   

            pReassembly->pRemoteNode = NULL;

        }
    }
    //
    // Clean up time. First handle the failure case. 
    // If reassembly is != NULL, then free the lock 
    // and free the reassembly structure
    //

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        *ppReassembly = pReassembly; 

        //
        // Queue a Reassembly timer, if reassembly was not complete
        //
        if (fReassemblyComplete == FALSE)
        {   
            nicQueueReassemblyTimer(pAdapter, FALSE);
        }
    }   

    if (NdisStatus != NDIS_STATUS_SUCCESS )
    {
        //
        // Free any locally allocated structures.
        //
        if (pNdisBuffer)
        {
            NdisFreeBuffer (pNdisBuffer);
        }
        //
        // Return NULL as output. The Reassembly structure is  
        // in the remote node's list. The timer routine will pick it up
        //

        //
        // Deref the ref made the REassembly was found/
        //
        if (pReassembly != NULL)
        {
             nicDereferenceReassembly (pReassembly, "nicDoReassembly - failure" );
        }
        
        *ppReassembly = pReassembly = NULL;

    }

    *pfReassemblyComplete = fReassemblyComplete;


    TRACE( TL_T, TM_Recv, ( "<== nicDoReassembly NdisStatus %x, , pReassembly %x, Complete %x", NdisStatus, *ppReassembly, *pfReassemblyComplete  ) );
    MATCH_IRQL;
    
    return NdisStatus;  

}





NDIS_STATUS
nicGetNdisBufferForReassembly(
    IN PNIC_RECV_DATA_INFO pRcvInfo,
    OUT PNDIS_BUFFER *ppNdisBuffer
    )
/*++

Routine Description:
Function Description:
    This function gets an Ndis Buffer that points to the start of the data
    that the Mdl points to. The Data starts from the point after the 
    Fragmentation Header
    
    If this is the First fragment, then 32 bytes of the fragment header are also
    copied to make room for the header that the ARP  module expects

Arguments
       pRcvInfo - Pointer to the Receive Tracking structure
       ppNdisBuffer - Output
    
Return Value:
      Success  - if the mem alloc succeeded, appropriate failure code otherwise
      NdisBuffer - Buffer pointing ot the data ,
    

--*/
{
    NDIS_STATUS                 NdisStatus = NDIS_STATUS_FAILURE;
    PVOID                       pStartValidData = NULL;
    ULONG                       ulValidDataLength = 0;
    PNDIS1394_FRAGMENT_HEADER   pNonByteSwappedFragmentHeader  = NULL;
    USHORT                      Dgl;
    PNDIS_BUFFER                pNdisBuffer = NULL;
    ULONG                       IsochPrefix = ISOCH_PREFIX_LENGTH;
    PPACKET_FORMAT              pIndicatedData = NULL;

    TRACE( TL_T, TM_Recv, ( "==> nicGetNdisBufferForReassembly ") );
    do
    {
        //
        // Get a pointer to the start of the data, ie. it should point past the encapsulation header
        //
        pStartValidData = (PVOID)((ULONG_PTR)pRcvInfo->pEncapHeader + sizeof(NDIS1394_FRAGMENT_HEADER));

        ulValidDataLength  = pRcvInfo->DataLength - sizeof (NDIS1394_FRAGMENT_HEADER);
        //
        // if this is the first fragment, then leave room for the Unfragmented header that will need 
        // to be added before sending it up to the IP module
        // 
        if (pRcvInfo->fFirstFragment == TRUE)
        {
            ULONG ExtraData = (sizeof(NDIS1394_FRAGMENT_HEADER) - sizeof (NDIS1394_UNFRAGMENTED_HEADER)) ;

            pStartValidData = (PVOID)((ULONG_PTR)pStartValidData - ExtraData);

            ulValidDataLength  += ExtraData ;
        }
        
        
        NdisStatus = nicGetNdisBuffer ( ulValidDataLength,   
                                   pStartValidData,
                                   &pNdisBuffer);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK (TM_Recv, ( "nicGetNdisBufferForReassembly: nicGetNdisBuffer Failed" ) );
        }

        nicIncRecvBuffer(pRcvInfo->pVc->Hdr.VcType == NIC1394_RecvFIFO);

        *ppNdisBuffer = pNdisBuffer;
        pRcvInfo->pNdisBuffer = pNdisBuffer;
        pRcvInfo->pNdisBufferData = pStartValidData;
        
    }while (FALSE);



    TRACE( TL_T, TM_Recv, ( "<== nicGetNdisBufferForReassembly NdisStatus %x, *ppNdisbuffer %x, pStartValidData%x ,ulValidDataLength %x", 
                             NdisStatus, *ppNdisBuffer, pStartValidData, ulValidDataLength) );



    return NdisStatus;

}


VOID
nicAddUnfragmentedHeader (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    IN PVOID pEncapHeader
    )
/*++

Routine Description:
   Its purpose is to add the fragment header that arp expects.
   There is room in the Head NdisBuffer to do this
     
   We own the buffer, so we can manipulate the data
    

Arguments:
    pReassembty Structure - contains all the necessary reasembly info
    pEncapHeader - Pointer to where th Unfragmented header will be stored

Return Value:
    None

--*/


{
    
    PNDIS1394_UNFRAGMENTED_HEADER pHeader = NULL;
    ASSERT (sizeof(NDIS1394_UNFRAGMENTED_HEADER) == sizeof(ULONG));
    TRACE( TL_T, TM_Recv, ( "==> nicAddUnfragmentedHeader  %x, pEncapHeader %x", pReassembly, pEncapHeader) );


    pHeader = (PNDIS1394_UNFRAGMENTED_HEADER) pEncapHeader;

    //
    // Now we add the unfragmented header. first zero it, then add the approriate values
    //
    pHeader->HeaderUlong = 0;   
    pHeader->u.FH_lf = lf_Unfragmented;
    pHeader->u.FH_EtherType = pReassembly->EtherType;

    //
    // Convert the header  to network order and indicate it up.
    //
    pHeader->HeaderUlong = SWAPBYTES_ULONG (pHeader->HeaderUlong);

    
    
    TRACE( TL_T, TM_Recv, ( "<== nicAddUnfragmentedHeader  pReasembly %x, pHeader %x ", pReassembly, pHeader->HeaderUlong) );
    
    return;
}





VOID
nicAbortReassemblyList (
    PLIST_ENTRY pToBeFreedList
    )
/*++

Routine Description:
    Walks the list and calls nicAbortReassembly on each structure
       
    Does not do any lock or refcount work as all the  Reassembly structures are 
    off the Remote node and cannot be accessed by any other thread.
    

Arguments:
   pToBeFreedList - list of reassembly structures that are going to be freed


Return Value:
    None

--*/
{

    PLIST_ENTRY pReassemblyList  = ListNext (pToBeFreedList);
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly = NULL;

    TRACE( TL_T, TM_Recv, ( "==> nicAbortReassemblyList  pToBeFreedList %x",  pToBeFreedList));


    while (pReassemblyList  != pToBeFreedList)
    {
        pReassembly = CONTAINING_RECORD(pReassemblyList, 
                                        NDIS1394_REASSEMBLY_STRUCTURE, 
                                        ReassemblyListEntry);

        pReassemblyList = ListNext(pReassemblyList);

        TRACE( TL_T, TM_Recv, ( "       Aborting pReassembly %x",  pReassembly));
        
        nicAbortReassembly(pReassembly);
    }

}


VOID
nicFreeAllPendingReassemblyStructures(
    IN PADAPTERCB pAdapter
    )
/*++

Routine Description:
   When we are notified of a reset we need to go and invalidate all
   reassemblies
   
   This will always be called from the Reset code path . and will be at dispatch
   It will clear out all the remote node reaassembly and mark them as aborted.
   The Timer routine will then pick them up and free it

   Does not actually free anything. Just marks them as aborted
    

Arguments:
    Adapter - Adapter on which the Reset occurred.

Return Value:


--*/
{
    PLIST_ENTRY pRemoteNodeList = NULL;
    PREMOTE_NODE pRemoteNode = NULL;
    PLIST_ENTRY pReassemblyList = NULL;
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly = NULL;
    ULONG NumMarkedAborted = 0;
    
    TRACE( TL_T, TM_Recv, ( "==> nicFreeAllPendingReassemblyStructures "));

    
    pRemoteNodeList = ListNext(&pAdapter->PDOList);

    ADAPTER_ACQUIRE_LOCK (pAdapter);

    //
    // Walking through the remote nodes
    //
    while (pRemoteNodeList != &pAdapter->PDOList)
    {
        pRemoteNode = CONTAINING_RECORD(pRemoteNodeList, 
                                        REMOTE_NODE, 
                                        linkPdo);

        pRemoteNodeList = ListNext (pRemoteNodeList);
        

        //
        // Reference the remote node, so we can guarantee its presence
        //
        if (REMOTE_NODE_ACTIVE (pRemoteNode)== FALSE) 
        {
            //
            // The remote node is going away. Skip this remote node
            //
            continue;
        }
        if (nicReferenceRemoteNode (pRemoteNode, FreeAllPendingReassemblyStructures )== FALSE )
        {
            //
            // The remote node is going away. Skip this remote node
            //
            continue;
        }

        //
        // Now walking through all the reassembly structures on that remote node
        //
        REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK(pRemoteNode);
        
        pReassemblyList = ListNext (&pRemoteNode->ReassemblyList);

        while (pReassemblyList  != &pRemoteNode->ReassemblyList)
        {
            pReassembly = CONTAINING_RECORD (pReassemblyList, 
                                             NDIS1394_REASSEMBLY_STRUCTURE, 
                                             ReassemblyListEntry);

            pReassemblyList = ListNext(pReassemblyList);


            //
            // If the reassembly has not been touched since the last timer it needs to be freed.
            // Other threads can ask us to free the reassembly by setting the aborted flag
            //
            if (REASSEMBLY_TEST_FLAG (pReassembly, REASSEMBLY_ABORTED) == FALSE);
            {

                REASSEMBLY_SET_FLAG (pReassembly, REASSEMBLY_ABORTED);
            
                NdisInterlockedIncrement (&NumMarkedAborted);
            }
        }


        REMOTE_NODE_REASSEMBLY_RELEASE_LOCK(pRemoteNode);

        nicDereferenceRemoteNode (pRemoteNode, FreeAllPendingReassemblyStructures );   

    }

    
    ADAPTER_RELEASE_LOCK (pAdapter);
    


    TRACE( TL_T, TM_Recv, ( "<== nicFreeAllPendingReassemblyStructures NumMarkedAborted  %x"));


}



ULONG
nicReferenceReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    PCHAR pString
    )
/*++

Routine Description:
    This is the return packets handler. 
    This functikon handles all the instrumentation to catch outstanding packets and 
    then calls the internal return packets function

Arguments:
    MiniportAdapterContext  - the pAdapter structure,
    pPacket - pPacket that the protocol returns


Return Value:


--*/
{   
    ULONG Ref;
    
    Ref = NdisInterlockedIncrement (&pReassembly->Ref);

    TRACE( TL_V, TM_Ref, ( "**nicReferenceReassembly  pReassembly %x, to %d, %s ", pReassembly, pReassembly->Ref, pString) );

    return Ref;


}









ULONG
nicDereferenceReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    PCHAR pString
    )
/*++

Routine Description:
    Dereference the Reassembly strucure

    In the case that the ref hits zero, the Reassembly structure is no longer
    in the Remote Node List so no other thread other than the caller has 
    access to this strcuture.
    
Arguments:
    pReassembly - pReassembly strucure to be dereferenced,
    PCHAR - Character string for debugging purposes.
   
Return Value:


--*/
{   
    ULONG Ref;
    
    Ref = NdisInterlockedDecrement (&pReassembly->Ref);

    TRACE( TL_V, TM_Ref, ( "**nicDereferenceReassembly  pReassembly %x, to %d, %s ", pReassembly, pReassembly->Ref, pString) );

    if ( Ref ==0 )
    {
        
        TRACE( TL_V, TM_Ref, ( "**FREEING pReassembly %x,  ", pReassembly) );
        FREE_NONPAGED (pReassembly);
    }

    return Ref;
}





VOID
nicIndicateNdisPacketToNdis (
    PNDIS_PACKET pPacket, 
    PVCCB pVc, 
    PADAPTERCB pAdapter
    )

/*++

Routine Description:
    This is to be used to indicate packets to NDIS . 
    Assumption - There will be only one packet in the array
    
Arguments:
    ppPacket  - Packet Array
    pVc -Vc on which the packet came in.
    Adapter - Adapter in which the packet came in


Return Value:
    None.

--*/
{
    NDIS_STATUS             NdisStatus = NDIS_STATUS_SUCCESS;
    PRSVD                   pRsvd = NULL;
    PNDIS_MINIPORT_TIMER    pRcvTimer= NULL;
    PINDICATE_RSVD          pIndicateRsvd = NULL;


    TRACE( TL_T, TM_Recv, ( "==> nicIndicateNdisPacketToNdis  pPacket %x, pVc %x, pAdapter %x ",
                            pPacket , pVc, pAdapter));

    TRACE (TL_V, TM_Reas, ("Indicating packet " ));                            

    
    do
    {
        NdisInterlockedIncrement (&pAdapter->AdaptStats.ulRcvOk);

        nicDumpPkt (pPacket,"Indicating Rcv ");

        
        ASSERT (pPacket != NULL);   

        //
        // Set up the Context for the indication
        //
        pRsvd =(PRSVD)(pPacket->ProtocolReserved);
        pIndicateRsvd = &pRsvd->IndicateRsvd;


        //
        // Update the tag increment counter and indicate rcv
        //

        pIndicateRsvd->Tag =  NIC1394_TAG_INDICATED;

        ASSERT (pPacket != NULL);

        nicIncrementRcvVcPktCount(pVc,pPacket);

        NdisMCoIndicateReceivePacket(pVc->Hdr.NdisVcHandle, &pPacket, 1);

        ASSERT (pAdapter->MiniportAdapterHandle != NULL);
        NdisMCoReceiveComplete(pAdapter->MiniportAdapterHandle);


    }while (FALSE);





    TRACE( TL_T, TM_Recv, ( "<==nicIndicateNdisPacketToNdis  %x"));



}



NDIS_STATUS
nicValidateRecvDataIsoch(
    IN  PMDL                pMdl,
    IN  PISOCH_DESCRIPTOR  pIsochDescriptor,
    IN  PVCCB               pVc,
    OUT PNIC_RECV_DATA_INFO pRcvInfo
    )
/*++

Routine Description:

    This function ensures that the length of the received packet is within reason.
    In the Isoch case, we do not know the exact number of bytes received, so we check 
    against the Mdl Length in the isoch Descriptor

    
Arguments:


Return Value:


--*/
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;

    do
    {
        NODE_ADDRESS NodeAddress;
        PGASP_HEADER pGaspHeader;
        //
        // Isoch header is already byte swapped
        //
        pRcvInfo->DataLength = pRcvInfo->p1394Data->IsochReceiveFragmented.IsochHeader.IH_Data_Length;

        if (pRcvInfo->DataLength <= (UINT)FIELD_OFFSET(DATA_FORMAT,IsochReceiveFragmented.Data))
        {
            // Too small. Note that for simplicitly we check for the 
            // fragmented case.
            //
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }           

        pRcvInfo->fGasp = TRUE;

        //
        // The total length of the data indicated by the bus driver
        //
        pRcvInfo->Length1394 = pRcvInfo->DataLength + sizeof (ISOCH_HEADER) + sizeof(ULONG); // Account for the prefix and isoch header

        //
        // Validate the Received length. Isoch Descriptors do not give us the actual length of the received packet, so
        // we rely on the MDL length.
        //
        if ((pRcvInfo->DataLength < sizeof(GASP_HEADER)) || pRcvInfo->DataLength > pIsochDescriptor->ulLength)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // The valid data does not include the gasp header
        //
        pRcvInfo->DataLength -= sizeof (GASP_HEADER);


        pRcvInfo->NdisPktContext.pIsochContext = pIsochDescriptor;

        pRcvInfo->pPacketPool = &((PCHANNEL_VCCB) pVc)->PacketPool;

        //
        // Get the source Info out. 
        //
        //
        // pRcvInfo->p1394Data points to the start of the Mdl's VA that was indicated by the bus driver
        //
        pGaspHeader = &pRcvInfo->p1394Data->IsochReceiveFragmented.GaspHeader;

        //
        // Byte swap the Gasp Header in the actual data. we own the buffer, so we can byte swap it   
        //
        pGaspHeader->FirstQuadlet.GaspHeaderHigh = SWAPBYTES_ULONG(pGaspHeader->FirstQuadlet.GaspHeaderHigh);
        pGaspHeader->SecondQuadlet.GaspHeaderLow = SWAPBYTES_ULONG(pGaspHeader->SecondQuadlet.GaspHeaderLow);

        TRACE (TL_V, TM_Recv, (" Gasp Hi %x, Gasp Lo %x.",  
                                pGaspHeader->FirstQuadlet.GaspHeaderHigh,
                                pGaspHeader->SecondQuadlet.GaspHeaderLow ) );

        pRcvInfo->pGaspHeader = pGaspHeader;
        
        pRcvInfo->SourceID = pGaspHeader->FirstQuadlet.u1.GH_NodeAddress.NA_Node_Number;

        pRcvInfo->SourceID = pGaspHeader->FirstQuadlet.u1.GH_NodeAddress.NA_Node_Number;

        NdisStatus = NDIS_STATUS_SUCCESS;


    } while (FALSE);

    return NdisStatus;
}



NDIS_STATUS
nicValidateRecvDataFifo(
    IN  PMDL                pMdl,
    IN  PNOTIFICATION_INFO pFifoContext,
    IN  PVCCB               pVc,
    OUT PNIC_RECV_DATA_INFO pRcvInfo
    )
/*++

Routine Description:

    This routine verifies that the length is not too small
    This routine initializes the RecvDataInfo for the default (unfragmented case).
    If the data is unfragmented the main recv routine will then call the Fragmented version of this routine

    This initializes the length and StartData and fGasp fields of the struct only 

Arguments:
    pMdl - Mdl that was indicated up by the bus driver
    RecvOp - Is this part of isoch callback, or AddrRange Callback
    pIndicatedStruct - NotificationInfo or IsochDescriptor
    pRcvInfo - Recv Structure that will be updated

Return Value:
    Success  - if all the operations succeeded  

--*/
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    do
    {
        pRcvInfo->DataLength = pFifoContext->nLength;
        
        if (pRcvInfo->DataLength <= (UINT)FIELD_OFFSET(DATA_FORMAT, AsyncWriteFragmented.Data))
        {
            // Too small. Note that for simplicitly we check for the 
            // fragmented case.
            //
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        pRcvInfo->fGasp = FALSE;

        //
        //In Fifo receives the DataLength is equal to the total amount of data indicated by the bus driver
        //
        pRcvInfo->Length1394 = pRcvInfo->DataLength;            
        
        pRcvInfo->NdisPktContext.pFifoContext = pFifoContext ->Fifo;

        pRcvInfo->pPacketPool = &((PRECVFIFO_VCCB) pVc)->PacketPool;

        pRcvInfo->SourceID =  ((PASYNC_PACKET)pFifoContext->RequestPacket)->AP_Source_ID.NA_Node_Number;

        NdisStatus = NDIS_STATUS_SUCCESS;

    }while (FALSE);

    return NdisStatus;


}


NDIS_STATUS
nicValidateRecvData(
    IN  PMDL                pMdl,
    IN  BUS_OPERATION       RecvOp,
    IN  PVOID               pIndicatedStruct,
    IN  PVCCB               pVc,
    OUT PNIC_RECV_DATA_INFO pRcvInfo
    )
/*++

Routine Description:

    This routine verifies that the length is not too small
    This routine initializes the RecvDataInfo for the default (unfragmented case).
    If the data is unfragmented the main recv routine will then call the Fragmented version of this routine

    This initializes the length and StartData and fGasp fields of the struct only 
Arguments:
    pMdl - Mdl that was indicated up by the bus driver
    RecvOp - Is this part of isoch callback, or AddrRange Callback
    pIndicatedStruct - NotificationInfo or IsochDescriptor
    pRcvInfo - Recv Structure that will be updated

Return Value:
    Success  - if all the operations succeeded  

--*/
{
    NDIS_STATUS                         NdisStatus = NDIS_STATUS_FAILURE;
    PDATA_FORMAT                        pData = NULL;
    NDIS1394_UNFRAGMENTED_HEADER        EncapHeader;
    PNDIS1394_UNFRAGMENTED_HEADER   pEncapHeader = NULL;
    NDIS1394_FRAGMENT_LF                lf;
    ULONG                               UlongLf;


    NdisZeroMemory (pRcvInfo , sizeof (NIC_RECV_DATA_INFO) );

    TRACE( TL_T, TM_Recv, ( "==>nicValidateRecvData pMdl %x, RecvOp %x, pIndicatedStruct %x, pRcvInfo %x", 
                                pMdl, RecvOp , pIndicatedStruct, pRcvInfo));

    ASSERT (RecvOp ==  IsochReceive || RecvOp == AddressRange);

    pRcvInfo->RecvOp = RecvOp;
    pRcvInfo->pVc = pVc;
    
    do
    {   
        if (pMdl == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            BREAK (TM_Recv, ("nicValidateRecvData  , no Mdl present") );
        }

        pRcvInfo->p1394Data = (PPACKET_FORMAT)NIC_GET_SYSTEM_ADDRESS_FOR_MDL (pMdl);

        if (pRcvInfo->p1394Data  == NULL)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

    
        //
        // Check minimum valid packet size . Checks whether the data length that was passed to us includes
        // at least the first byte of data
        //
        
        if (RecvOp == IsochReceive)
        {
            NdisStatus = nicValidateRecvDataIsoch (pMdl, 
                                                 (PISOCH_DESCRIPTOR)pIndicatedStruct,
                                                 pVc,
                                                 pRcvInfo
                                                 );

            if (NdisStatus != NDIS_STATUS_SUCCESS)           
            {
                // Validation failed . exit
                break;
            }           
            
            //
            // Get to the Encap header. Should be at the same position for Fragmented and nonfragmented 
            //
            pEncapHeader = &pRcvInfo->p1394Data->IsochReceiveNonFragmented.NonFragmentedHeader;

        }
        else
        {

            NdisStatus = nicValidateRecvDataFifo(pMdl,(PNOTIFICATION_INFO)pIndicatedStruct,pVc,pRcvInfo);

            if (NdisStatus != NDIS_STATUS_SUCCESS)           
            {
                // Failure
                break;
            }

            pEncapHeader  = &pRcvInfo->p1394Data->AsyncWriteNonFragmented.NonFragmentedHeader;


        }

        //
        // Byteswap Unfrag Header into a local variable
        //
        //EncapHeader.HeaderUlong = SwapBytesUlong (pEncapHeader->HeaderUlong);

        EncapHeader.HeaderUlong = SWAPBYTES_ULONG (pEncapHeader->HeaderUlong);

        EncapHeader.HeaderUlong  = pEncapHeader->HeaderUlong & 0x000000C0;
        EncapHeader.HeaderUlong  = EncapHeader.HeaderUlong >> 6;
        
        pRcvInfo->lf = EncapHeader.HeaderUlong ; 
    
        //
        // Update the lf
        //
    
        pRcvInfo->lf = EncapHeader.HeaderUlong;
        TRACE (TL_V, TM_Reas,("Header %x\n",pRcvInfo->lf ) );

        ASSERT (EncapHeader.HeaderUlong <= lf_InteriorFragment);


        if (pRcvInfo->lf != lf_Unfragmented)
        {
            pRcvInfo->fFragmented = TRUE;
        }
        else
        {
            pRcvInfo->fFragmented = FALSE;
        }

        if (pRcvInfo->DataLength > pVc->Hdr.MTU)
        {
            //
            // This cannot belong to us
            //
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }
        NdisStatus = NDIS_STATUS_SUCCESS;


        pRcvInfo->pEncapHeader = (PVOID)pEncapHeader;
        
        //
        // Spew out all the information discovered
        //
        TRACE ( TL_V, TM_Recv, ( "lf %x, p1394Data %x, Length1394 %x, DataLength %x, pEncapHeader %x " , 
                                pRcvInfo->lf,
                                pRcvInfo->p1394Data, 
                                pRcvInfo->Length1394, 
                                pRcvInfo->DataLength, 
                                pRcvInfo->pEncapHeader ) );

        
    } while (FALSE);

    TRACE( TL_T, TM_Recv, ( "<==nicValidateRecvData %x", NdisStatus));
    return NdisStatus;
}





VOID
nicInitRecvDataFragmented (
    IN  PMDL                pMdl,
    IN  BUS_OPERATION       RecvOp,
    IN  PVOID               pIndicatedStruct,
    OUT PNIC_RECV_DATA_INFO pRcvInfo
    )
/*++

Routine Description:
    The routine will extract from the packet all the information that is required for reassembly
    and store it in the pRcvInfo
    
Arguments:
    pMdl - Indicated Mdl
    RecvOp - IsochReceive ot AddressRange Callback
    pIndicatedStruct - IsochDesc or Address Fifo
    pRcvInfo - output structure

Return Value:
    None

--*/
{

    PNOTIFICATION_INFO                  pNotificationInfo = NULL;
    PGASP_HEADER                        pGaspHeader = NULL;
    PNDIS1394_FRAGMENT_HEADER           pEncapHeader = NULL; 

    
    TRACE( TL_T, TM_Recv, ( "==> nicInitRecvDataFragmented pMdl, %x, RecvOp %x, pIndicatedStruct %x, pRcvInfo %x", 
                                 pMdl, RecvOp, pIndicatedStruct, pRcvInfo));

    do
    {   
        pRcvInfo->pMdl  = pMdl;
        
        
        if (RecvOp == IsochReceive)
        {
            
            pRcvInfo->NdisPktContext.pIsochContext = (PISOCH_DESCRIPTOR) pIndicatedStruct;

        }
        else
        {
            pNotificationInfo = (PNOTIFICATION_INFO) pIndicatedStruct;
            
         
            pRcvInfo->NdisPktContext.pFifoContext = pNotificationInfo->Fifo;

        }

        
        //
        // Now byte swap the fragment header so it can be correctly interpreted
        //
        pEncapHeader = (PNDIS1394_FRAGMENT_HEADER )pRcvInfo->pEncapHeader;
        
        pRcvInfo->FragmentHeader.u.FH_High = SWAPBYTES_ULONG(pEncapHeader->u.FH_High);
        pRcvInfo->FragmentHeader.u1.FH_Low = SWAPBYTES_ULONG(pEncapHeader->u1.FH_Low);
        
        //
        // Now get the Dgl 
        //
        pRcvInfo->Dgl = (USHORT)pRcvInfo->FragmentHeader.u1.SecondQuadlet.FH_dgl;

        if (pRcvInfo->lf == lf_FirstFragment)
        {
            pRcvInfo->fFirstFragment = TRUE;
            pRcvInfo->EtherType  = pRcvInfo->FragmentHeader.u.FirstQuadlet_FirstFragment.FH_EtherType;
            pRcvInfo->FragmentOffset   = 0;

        }
        else
        {
            pRcvInfo->fFirstFragment = FALSE            ;
            pRcvInfo->FragmentOffset  = pRcvInfo->FragmentHeader.u.FirstQuadlet.FH_fragment_offset;

        }



        
        
        pRcvInfo->BufferSize = pRcvInfo->FragmentHeader.u.FirstQuadlet.FH_buffersize ;

        //
        // Spew out all the information that has been found
        //
        TRACE ( TL_V, TM_Recv, (" SourceId %x, FragHead Hi %x, FragHead Lo %x, Dgl %x, fFirstFragment %x",
                                pRcvInfo->SourceID,
                                pRcvInfo->FragmentHeader.u.FH_High, 
                                pRcvInfo->FragmentHeader.u1.FH_Low ,
                                pRcvInfo->Dgl,
                                pRcvInfo->fFirstFragment ) );

        TRACE ( TL_V, TM_Recv, ("  Fragment Offset %x, bufferSize %x", pRcvInfo->FragmentOffset, pRcvInfo->BufferSize));                                
        ASSERT (pRcvInfo->SourceID < 64);                           

    } while (FALSE);




    

    TRACE( TL_T, TM_Recv, ( "<==nicInitRecvDataFragmented " ));

}



NDIS_STATUS
nicInsertFragmentInReassembly (
    PNDIS1394_REASSEMBLY_STRUCTURE  pReassembly,
    PNIC_RECV_DATA_INFO pRcvInfo
    )
/*++

Routine Description:
 
    Checks for over laps and if valid then copies current fragment
    into the table

    This function does the validation for overlaps
  
Arguments:
    PNDIS1394_REASSEMBLY_STRUCTURE  pReassembly,
    PNDIS_BUFFER pNdisBuffer,
    PMDL pMdl,
    PVOID pIndicatedStructure,
    ULONG FragOffset,
    ULONG IPLength


Return Value:


--*/

{

    NDIS_STATUS     NdisStatus = NDIS_STATUS_SUCCESS; 
    BOOLEAN         fFragPositionFound = FALSE;
    ULONG           FragmentNum = 0;
    BOOLEAN         Completed = FALSE;
    PNDIS_BUFFER    pNdisBuffer = pRcvInfo->pNdisBuffer;
    PMDL            pMdl = pRcvInfo->pMdl;
    PVOID           pIndicatedStructure = pRcvInfo->NdisPktContext.pCommon;
    ULONG           FragOffset = pRcvInfo->FragmentOffset;
    ULONG           IPLength = pRcvInfo->DataLength - sizeof (NDIS1394_FRAGMENT_HEADER);
    

    TRACE( TL_T, TM_Recv, ( "==> nicInsertFragmentInReassembly " ));
    

    do
    {
        if (pReassembly->BufferSize != 0 && 
            FragOffset >= pReassembly->BufferSize )
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // First Find the correct entry in the frag table.
        //

        nicFindInsertionPosition (pReassembly, 
                                  FragOffset, 
                                  IPLength, 
                                  &FragmentNum);

        if (FragmentNum == FRAGMENT_NUM_INVALID ||
            FragmentNum > (MAX_ALLOWED_FRAGMENTS-1))
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        if (pReassembly->FragTable[FragmentNum].IPLength != 0)
        {
            //
            // we must copy the current fragments descriptors  in the table 
            // so as not to overwrite the table
            //
            LONG OffsetIndex =0;
            
            //
            // First lets check for overlaps. Do we overlap the last fragment.
            // At this point, FragmentNum contains the record for the 
            // next fragment in the reassembly
            //
            if (FragmentNum != 0)
            {
                ULONG PrevFragmentOffset = pReassembly->FragTable[FragmentNum-1].Offset ;
                ULONG PrevFramentLength = pReassembly->FragTable[FragmentNum-1].IPLength ;

                ULONG EndOfPrevFragment = PrevFramentLength + PrevFragmentOffset ;
                
                if (EndOfPrevFragment  >  FragOffset)
                {
                    NdisStatus = NDIS_STATUS_FAILURE;
                    break;
                }
    
            }

            //
            // Do we overlap the next fragment
            //
            if (FragmentNum < pReassembly->MaxOffsetTableIndex)
            {
                ULONG EndOfCurrentFragment = FragOffset + IPLength;
                ULONG StartOfNextFragment = pReassembly->FragTable[FragmentNum].Offset ;
                    

                if (EndOfCurrentFragment  > StartOfNextFragment)
                {
                    NdisStatus = NDIS_STATUS_FAILURE;
                    break;
            
                }
            }
            
            //
            // Now make room for this fragment
            //
            OffsetIndex = pReassembly->MaxOffsetTableIndex ; 

            if (OffsetIndex >= MAX_ALLOWED_FRAGMENTS)
            {
                NdisStatus = NDIS_STATUS_FAILURE;
                ASSERT(OffsetIndex > MAX_ALLOWED_FRAGMENTS) ;
                break;
            }
            
            //
            // Signed compare and move the records ahead by one
            //
            while (OffsetIndex >= (LONG)FragmentNum)
            {
                pReassembly->FragTable[OffsetIndex+1].Offset  =  pReassembly->FragTable[OffsetIndex].Offset ;
                pReassembly->FragTable[OffsetIndex+1].IPLength =  pReassembly->FragTable[OffsetIndex].IPLength;
                pReassembly->FragTable[OffsetIndex+1].pMdl =  pReassembly->FragTable[OffsetIndex].pMdl;
                pReassembly->FragTable[OffsetIndex+1].pNdisBuffer=  pReassembly->FragTable[OffsetIndex].pNdisBuffer;
                pReassembly->FragTable[OffsetIndex+1].pNdisBuffer=  pReassembly->FragTable[OffsetIndex].pNdisBuffer;
                pReassembly->FragTable[OffsetIndex+1].IndicatedStructure.pCommon = pReassembly->FragTable[OffsetIndex].IndicatedStructure.pCommon ;
                pReassembly->FragTable[OffsetIndex+1].FragHeader =  pReassembly->FragTable[OffsetIndex].FragHeader;
                
                OffsetIndex --;                     
            }

        }

        pNdisBuffer->Next = NULL;
        pMdl->Next = NULL;

        //
        // Copy the current fragment into the table
        //
        pReassembly->FragTable[FragmentNum].Offset = FragOffset;
        pReassembly->FragTable[FragmentNum].IPLength = IPLength;
        pReassembly->FragTable[FragmentNum].pNdisBuffer = pNdisBuffer;
        pReassembly->FragTable[FragmentNum].pMdl    = pMdl;
        pReassembly->FragTable[FragmentNum].FragHeader =  pRcvInfo->FragmentHeader;
        
        if (pReassembly->ReceiveOp == IsochReceive)
        {
            pReassembly->FragTable[FragmentNum].IndicatedStructure.pCommon = &((PISOCH_DESCRIPTOR)pIndicatedStructure)->DeviceReserved[IsochNext];
        }
        else
        {
            pReassembly->FragTable[FragmentNum].IndicatedStructure.pFifo = (PADDRESS_FIFO)pIndicatedStructure;
        }
        
        pReassembly->BytesRecvSoFar += IPLength;
        //
        // Now increment the Max offset
        //

        pReassembly->MaxOffsetTableIndex ++;
        
        if (pReassembly->BufferSize == 0)
        {       
            pReassembly->BufferSize = pRcvInfo->BufferSize;
        }

        //
        // Add the unfragmented header here as we have to extract the EtherType here
        //
        if (pRcvInfo->fFirstFragment == TRUE)
        {
                
            pReassembly->EtherType = (USHORT)pRcvInfo->EtherType;

            nicAddUnfragmentedHeader (pReassembly, pRcvInfo->pNdisBufferData );
            

        }

        //
        // According to the RFC, the buffersize of the reassembled packet
        // is 1 less than the number of bytes in the packet
        //
        if (pReassembly->BytesRecvSoFar  == pReassembly->BufferSize + 1)
        {

            nicChainReassembly (pReassembly);

            pReassembly->fReassemblyComplete = TRUE;

            RemoveEntryList (&pReassembly->ReassemblyListEntry);


        }
        


    } while (FALSE);
    

    TRACE( TL_T, TM_Recv, ( "<== nicInsertFragmentInReassembly Status %x, Complete ", NdisStatus , pReassembly->fReassemblyComplete  ));

    return NdisStatus;
}










VOID
nicFindInsertionPosition (
    PNDIS1394_REASSEMBLY_STRUCTURE  pReassembly, 
    ULONG FragOffset, 
    ULONG IPLength, 
    PULONG pFragmentNum
    )
/*++

Routine Description:
 
    This functions figures out where should the new fragment be inserted into 
    our tracking array. If this is our first fragment, 0 is returned. If the offset 
    is greater than the last fragment, the next available position in the array is 
    returned.

    If the new framgent is somewhere in the middle, than the position is based on
    the offset of the newly arrived packet in relation to the already arrived fragment's 
    offset
  
Arguments:
    pReassembly,  - Our tracking structure
    FragOffset - The Offset of the new fragment
    IPLength,  - The length of the new fragment
    pFragmentNum - the output variable


Return Value:


--*/

{

    ULONG FragmentNum = 0;
    

    do
    {
        //
        // First Do quick checks for Inorder reassembly
        //

        //
        // Is it the first arrived fragment
        //
        if (pReassembly->MaxOffsetTableIndex == 0 || 
            FragOffset < pReassembly->FragTable[0].Offset +pReassembly->FragTable[0].IPLength  )
        {
            FragmentNum = 0;    
            break;
        }

        //
        // Do we need to insert it in the last position
        //
        if ((pReassembly->FragTable[pReassembly->MaxOffsetTableIndex-1].Offset +
            pReassembly->FragTable[pReassembly->MaxOffsetTableIndex-1].IPLength ) <=
            FragOffset)
        {

            FragmentNum = pReassembly->MaxOffsetTableIndex; 

            break;
        }

        //
        // Now walk the table and try to find the correct offset
        // We know there is atleast one entry and the current fragment
        // goes is not the last entry
        //
        while ( FragmentNum != pReassembly->MaxOffsetTableIndex)
        {
            if (FragOffset < pReassembly->FragTable[FragmentNum].Offset)
            {
                //
                //We have found the Correct position
                //
                break;
            }

            FragmentNum++;

            

        }
        ASSERT (FragmentNum != pReassembly->MaxOffsetTableIndex); 

        FragmentNum = FRAGMENT_NUM_INVALID;        


    } while (FALSE);


        
    *pFragmentNum = FragmentNum;

    
}




VOID 
nicChainReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE  pReassembly
    )
/*++

Routine Description:
 Chains the mdl, ndis buffers and indicated structures
 This can be called from abort on the reasssembly complete code path

Arguments:
    pReassembly

Return Value:


--*/

{

    ULONG i = 0;


    //
    // first chain all fragments save the last one
    //
    while (i< pReassembly->MaxOffsetTableIndex-1)
    {
        PFRAGMENT_DESCRIPTOR pCurr = & pReassembly->FragTable[i];
        PFRAGMENT_DESCRIPTOR pNext = & pReassembly->FragTable[i+1];
        
        ASSERT (pNext->IPLength != 0);

        pCurr->pMdl->Next = pNext->pMdl;
        pCurr->pNdisBuffer->Next = pNext->pNdisBuffer;
        pCurr->IndicatedStructure.pListEntry->Next = pNext->IndicatedStructure.pListEntry;

        i++;
    }


    //
    // Clear the next pointers for the last descriptor
    //
    {
        PFRAGMENT_DESCRIPTOR pLast = & pReassembly->FragTable[pReassembly->MaxOffsetTableIndex-1];
        pLast->pMdl->Next = NULL;
        pLast->pNdisBuffer->Next = NULL;
        pLast->IndicatedStructure.pListEntry->Next = NULL;

    }   

    pReassembly->pHeadNdisBuffer = pReassembly->FragTable[0].pNdisBuffer;
    pReassembly->pHeadMdl = pReassembly->FragTable[0].pMdl;

    if (pReassembly->ReceiveOp == IsochReceive)
    {
        //
        // The pointer currently has the Next field. But the Head expects that start of an IsochDescriptor
        //
        pReassembly->Head.pCommon = CONTAINING_RECORD (pReassembly->FragTable[0].IndicatedStructure.pCommon,
                                                        ISOCH_DESCRIPTOR,
                                                        DeviceReserved[IsochNext] );

    }
    else
    {
        pReassembly->Head.pCommon = pReassembly->FragTable[0].IndicatedStructure.pCommon;
    }

    

}



NDIS_STATUS
nicInitSerializedReassemblyStruct(
    PADAPTERCB pAdapter
    )
/*++

Routine Description:
  Initialize the Reassembly serialization structure

Arguments:
  padapter

Return Value:
 Success

--*/
{


    NdisZeroMemory (&pAdapter->Reassembly, sizeof(pAdapter->Reassembly));
    InitializeListHead(&pAdapter->Reassembly.Queue); // Not be Used

    NdisInitializeEvent (&pAdapter->Reassembly.CompleteEvent.NdisEvent);
    pAdapter->Reassembly.CompleteEvent.EventCode = Nic1394EventCode_InvalidEventCode;

    NdisMInitializeTimer (&pAdapter->Reassembly.Timer,
                         pAdapter->MiniportAdapterHandle,
                         ReassemblyTimerFunction ,
                         pAdapter);



    return NDIS_STATUS_SUCCESS;

}


VOID
nicDeInitSerializedReassmblyStruct(
    PADAPTERCB pAdapter
    )
/*++

Routine Description:
 Deinits the Reassembly routine routine

  if the timer is set, it waits the timer out.
 As all the reassemblies will be marked as aborted in nicFreeAllPendingReassemblies (below)
 it queues a timer one last time to go in and delete all the reassembly structures.
 
Arguments:


Return Value:


--*/
{
 

    do
    {
        
        BOOLEAN bTimerAlreadySet = FALSE;
        //
        // If this adapter is halting, then mark all reassemblies as aborted
        //
        nicFreeAllPendingReassemblyStructures(pAdapter);


        //
        // First wait for any pending timer to fire.
        //
        ADAPTER_ACQUIRE_LOCK (pAdapter);
        bTimerAlreadySet = pAdapter->Reassembly.bTimerAlreadySet ;               
        if (bTimerAlreadySet == TRUE)
        {
            //
            // if the (bTimerAlreadySet==TRUE ), it means we can clear/init the event. 
            // Because the TimerAlreadySet is cleared and the Event is always set within
            // the same Acquire-Release Spinlock
            //
            NdisResetEvent (&pAdapter->Reassembly.CompleteEvent.NdisEvent);
            pAdapter->Reassembly.CompleteEvent.EventCode = Nic1394EventCode_InvalidEventCode;
        
            
        }
        ADAPTER_RELEASE_LOCK(pAdapter);


        if (bTimerAlreadySet == TRUE)
        {
            NdisWaitEvent (&pAdapter->Reassembly.CompleteEvent.NdisEvent,WAIT_INFINITE); 
        }

        //
        // Reset the event , to prepare for the next wait.
        //
        pAdapter->Reassembly.CompleteEvent.EventCode = Nic1394EventCode_InvalidEventCode;

        NdisResetEvent (&pAdapter->Reassembly.CompleteEvent.NdisEvent);


        //
        // Now enqueue the timer one last time to free all pending reassemblies.
        // and Stop any further reassembly timers 
        //

        nicQueueReassemblyTimer (pAdapter,TRUE); 


        //
        // Wait for the last timer to fire.
        //

        bTimerAlreadySet = pAdapter->Reassembly.bTimerAlreadySet ;               

        //
        // Only do the wait, if nicQueueReassembly Timer actually queued a reassembly timer
        //
        if (bTimerAlreadySet == TRUE)
        {   
            NdisWaitEvent (&pAdapter->Reassembly.CompleteEvent.NdisEvent,WAIT_INFINITE); 
        }



    } while (FALSE);
    
        
 

}



NDIS_STATUS
nicQueueReassemblyTimer(
    PADAPTERCB pAdapter,
    BOOLEAN fIsLastTimer
    )
/*++

Routine Description:

  Queues a timer to be fired in one second. 
  If there is already a timer active it quietly exists

Arguments:
  Self explanatory

Return Value:


--*/
    
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fSetTimer = FALSE;

    do
    {
    

        ADAPTER_ACQUIRE_LOCK (pAdapter);



        //
        // If the timer is not set, then this thread must set it
        //


        if (pAdapter->Reassembly.bTimerAlreadySet == FALSE && // timer is not set
            pAdapter->Reassembly.PktsInQueue > 0 &&   // there are packets to be reassembled
            ADAPTER_TEST_FLAG (pAdapter,fADAPTER_NoMoreReassembly) == FALSE ) // the adapter is not halting
        {
            fSetTimer = TRUE;
            pAdapter->Reassembly.bTimerAlreadySet = TRUE;
        }

        if (fIsLastTimer == TRUE)
        {
            //
            // Stop any further reassembly timers 
            //

            ADAPTER_SET_FLAG (pAdapter, fADAPTER_NoMoreReassembly);
        }


        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Now queue the timer
        //
        
        if (fSetTimer == TRUE)
        {
            //
            //  Set the timer
            //
                         

            
            TRACE( TL_V, TM_Recv, ( "   Set Timer "));

            NdisMSetTimer ( &pAdapter->Reassembly.Timer, 2000);

    
        }


        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    ASSERT (Status == NDIS_STATUS_SUCCESS);
    return Status;
}


VOID
nicFifoAllocationScheme (
    PRECVFIFO_VCCB pRecvFIFOVc
)
/*++

Routine Description:
 If there are less than 20 fifo allocated, it starts a workitem to 
 allocate a lot more fifos

Arguments:
   

Return Value:


--*/
{

    BOOLEAN fQueueWorkItemInThisThread = FALSE;
    PNIC_WORK_ITEM pFifoWorkItem = NULL;

    do
    {
        if (pRecvFIFOVc->NumAllocatedFifos != NUM_RECV_FIFO_FIRST_PHASE)
        {
            break ; 
        }

        if (pRecvFIFOVc->FifoWorkItemInProgress == TRUE)        
        {
            break;
        } 
        
        pFifoWorkItem  = ALLOC_NONPAGED (sizeof(NIC_WORK_ITEM), MTAG_WORKITEM); 

        if (pFifoWorkItem == NULL)
        {
            break;
        }

        VC_ACQUIRE_LOCK(pRecvFIFOVc);

        if (VC_ACTIVE (pRecvFIFOVc)  && 
            pRecvFIFOVc->FifoWorkItemInProgress == FALSE)        
        {
            fQueueWorkItemInThisThread = TRUE;


            pRecvFIFOVc->FifoWorkItemInProgress = TRUE;

            // Add reference to the VC . Derefed in the WorkItem
            //
            nicReferenceCall((VCCB*)pRecvFIFOVc, "Queueing miniport Work Item\n");
        }

        VC_RELEASE_LOCK (pRecvFIFOVc);

        if (fQueueWorkItemInThisThread  == FALSE)
        {
            break;
        }

        //
        // Queue the workitem
        //
        NdisInitializeWorkItem ( &pFifoWorkItem->NdisWorkItem, 
                                 (NDIS_PROC) nicAllocateRemainingFifoWorkItem,
                                 (PVOID) pRecvFIFOVc);

        NdisScheduleWorkItem (&pFifoWorkItem->NdisWorkItem);

    } while (FALSE);

    if (fQueueWorkItemInThisThread  == FALSE  && 
        pFifoWorkItem != NULL)
    {
        FREE_NONPAGED (pFifoWorkItem);
    }

    
}



VOID
nicAllocateRemainingFifoWorkItem (
    PNDIS_WORK_ITEM pNdisWorkItem, 
    IN PVOID Context
    )
/*++

Routine Description:
    This follows a simple algorithm. It simply allocates fifos 
    until we reach our expected number of 100

Arguments:
   

Return Value:


--*/
{
    PRECVFIFO_VCCB pRecvFIFOVc = NULL;
    BOOLEAN fIsVcActive = FALSE;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    

    pRecvFIFOVc = (PRECVFIFO_VCCB) (Context);
    
    fIsVcActive = VC_ACTIVE(pRecvFIFOVc);

    do
    {
        PADDRESS_FIFO pRecvFifoElement = NULL;

        fIsVcActive = VC_ACTIVE(pRecvFIFOVc);

        if (fIsVcActive == FALSE)
        {
            break;
        }

        NdisStatus = nicGetInitializedAddressFifoElement (pRecvFIFOVc->Hdr.MTU, 
                                                    &pRecvFifoElement);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        ASSERT (pRecvFifoElement  != NULL);
         
        ExInterlockedPushEntrySList ( &pRecvFIFOVc->FifoSListHead,
                                     (PSLIST_ENTRY)&pRecvFifoElement->FifoList,
                                     &pRecvFIFOVc->FifoSListSpinLock);

        //
        // Add this once for every Address Fifo element inserted 
        // Will be decremented by  a call to nicFreeAddressFifo
        //
        VC_ACQUIRE_LOCK (pRecvFIFOVc);

        nicReferenceCall ((PVCCB) pRecvFIFOVc, "nicWorkItemFileSList");

        pRecvFIFOVc->NumAllocatedFifos++;

        VC_RELEASE_LOCK (pRecvFIFOVc);
      

    } while (pRecvFIFOVc->NumAllocatedFifos < NUM_RECV_FIFO_BUFFERS);

    pRecvFIFOVc->FifoWorkItemInProgress = FALSE;

    nicDereferenceCall ((PVCCB)pRecvFIFOVc,"nicAllocateRemainingFifoWorkItem" );

    FREE_NONPAGED(pNdisWorkItem);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\receive.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// receive.h
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port Receive routines
//
// 2/13/1998 ADube Created
//

#define ISOCH_PREFIX_LENGTH (sizeof(LONG) + sizeof (ISOCH_HEADER))

VOID
nicAbortReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly
    );


VOID
nicAllocateAddressRangeCallback( 
    IN PNOTIFICATION_INFO NotificationInfo 
);

VOID
nicAllocateAddressRangeDebugSpew(
    IN PIRB pIrb 
    );

NDIS_STATUS
nicAllocateAddressRangeSucceeded (
    IN PIRB pIrb,
    IN OUT PRECVFIFO_VCCB    pRecvFIFOVc
    );



NDIS_STATUS
nicGetInitializedAddressFifoElement(
    IN     UINT BufferLength, 
    IN OUT PADDRESS_FIFO *ppElement 
    );



NDIS_STATUS
nicInitAllocateAddressIrb(
   IN PIRB                  pIrb,   
   IN PVOID                 pContext,   
   IN ULONG                 fulFlags,
   IN ULONG                 nLength,
   IN ULONG                 MaxSegmentSize,
   IN ULONG                 fulAccessType,
   IN ULONG                 fulNotificationOptions,
   IN PADDRESS_OFFSET       pOffset,
   IN PRECVFIFO_VCCB        pRecvFIFOVc
   );





NDIS_STATUS
nicGetEmptyAddressFifoElement(
    IN PADDRESS_FIFO *ppElement
    );
    


NDIS_STATUS
nicAllocateAddressRange(
    IN PADAPTERCB pAdapter,
    IN PRECVFIFO_VCCB pRecvFIFOVc
    );

NDIS_STATUS
nicFillAllocateAddressRangeSList(
    IN RECVFIFO_VCCB *pRecvFIFO,
    IN UINT *Num 
    );

NDIS_STATUS
nicFreeRecvFifoAddressRange(
    IN REMOTE_NODE *pRemoteNode
    );


NDIS_STATUS
nicFreeRecvFifoAddressRangeOnAllRemoteNodes (
    IN PADAPTERCB pAdapter 
    );          

NDIS_STATUS
nicFreeAllAllocatedAddressRangesOnPdo (
    IN PREMOTE_NODE pRemoteNode
    );
    

VOID
nicFreeAllocateAddressRangeSList(
    IN PRECVFIFO_VCCB pRecvFIFOVc 
    );
    

NDIS_STATUS
nicGetNdisBuffer(
    IN UINT Length,
    IN PVOID pLocalBuffer,
    IN OUT PNDIS_BUFFER *ppNdisBuffer 
    );

VOID
nicFreeAddressFifo(
    IN PADDRESS_FIFO pAddressFifo,
    IN PRECVFIFO_VCCB pRecvFIFOVc 
    );
    



VOID 
nicFifoReturnPacket (
    IN PVCCB pVc,
    IN PNDIS_PACKET pMyPacket
    );
    

// 
// Isoch Functions
//

NDIS_STATUS
nicAllocateAndInitializeIsochDescriptors (
    IN PCHANNEL_VCCB pChannelVc,
    IN UINT NumDescriptors,
    IN UINT BufferLength,
    IN OUT PPISOCH_DESCRIPTOR  ppIsochDescriptor
    );


NDIS_STATUS
nicFreeIsochDescriptors(
    IN UINT Num,
    IN PISOCH_DESCRIPTOR  pIsochDescriptor,
    IN PVCCB pVc
    );

NDIS_STATUS
nicFreeSingleIsochDescriptor(
    IN PISOCH_DESCRIPTOR  pIsochDescriptor,
    IN PVCCB pVc
    );

VOID
nicReturnNdisBufferChain (
    IN PNDIS_BUFFER pNdisBuffer,
    IN PVCCB pVc
    );


VOID 
nicChannelReturnPacket (
    IN PVCCB pVc,
    IN PNDIS_PACKET pMyPacket
    );



NDIS_STATUS
nicFindReassemblyStructure (
    IN PREMOTE_NODE pRemoteNode,
    IN USHORT dgl,
    IN BUS_OPERATION BusOp,
    IN PVCCB pVc,
    OUT PNDIS1394_REASSEMBLY_STRUCTURE* ppReassembly
    );




NDIS_STATUS
nicGetReassemblyStructure ( 
    IN PNDIS1394_REASSEMBLY_STRUCTURE* ppReassembly
    );




VOID
nicFreeReassemblyStructure ( 
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly
    );





NDIS_STATUS
nicInitializeReassemblyStructure (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    IN USHORT Dgl,
    IN PREMOTE_NODE pRemoteNode,
    IN PVCCB pVc,
    IN BUS_OPERATION ReceiveOp
    );


    





VOID
nicReturnFifoChain (
    IN PADDRESS_FIFO pAddressFifo,
    IN PRECVFIFO_VCCB pRecvFifoVc
    );




VOID
nicReturnDescriptorChain ( 
    IN PISOCH_DESCRIPTOR pIsochDescriptor ,
    IN PCHANNEL_VCCB pChannelVc
    );


VOID
nicInternalReturnPacket(
    IN  PVCCB                   pVc ,
    IN  PNDIS_PACKET            pPacket
    );

//
// Generic Receive functions 
//


VOID
NicReturnPacket(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            pPacket
    );

    
VOID
nicIndicateNdisPacketToNdis (
    PNDIS_PACKET pPacket, 
    PVCCB pVc, 
    PADAPTERCB pAdapter
    );


VOID
RcvIndicateTimer (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );


    

VOID
nicIndicateMultiplePackets(
    PNDIS_PACKET *ppPacket, 
    NDIS_HANDLE NdisVcHandle, 
    PADAPTERCB pAdapter,
    ULONG NumPackets
    );






VOID
nicAbortReassemblyList (
    PLIST_ENTRY pToBeFreedList
    );




VOID
nicFreeAllPendingReassemblyStructures(
    IN PADAPTERCB pAdapter
    );





ULONG
nicDereferenceReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    PCHAR pString
    );




ULONG
nicReferenceReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    PCHAR pString
    );  




NDIS_STATUS
nicValidateRecvData(
    IN  PMDL                pMdl,
    IN  BUS_OPERATION       RecvOp,
    IN  PVOID               pIndicatedStruct,
    IN PVCCB                pVc,
    OUT PNIC_RECV_DATA_INFO pInfo
    );

VOID
nicInitRecvDataFragmented (
    IN  PMDL                pMdl,
    IN  BUS_OPERATION       RecvOp,
    IN  PVOID               pIndicatedStruct,
    OUT PNIC_RECV_DATA_INFO pRcvInfo
    );




NDIS_STATUS
nicReceiveInOrderReassembly (
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    PVOID pIndicatedStructure,
    PNDIS_BUFFER pNdisBuffer,
    PVOID pNdisBufferStartData,
    ULONG   IPLength,
    PNDIS1394_FRAGMENT_HEADER     pHeader,
    IN ULONG FragOffset
    );


NDIS_STATUS
nicReceiveOutOfOrderReassembly (
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    PVOID pIndicatedStructure,
    PNDIS_BUFFER pNdisBuffer,
    PVOID pNdisBufferStartData,
    ULONG   IPLength,
    PNDIS1394_FRAGMENT_HEADER     pHeader,
    IN ULONG FragOffset
    );


VOID
nicInsertEarliestFragment (
    PMDL pMdl,
    PNDIS_BUFFER pNdisBuffer,
    PVOID pStartData,
    PVOID pIndicatedStructure,
    ULONG CurrFragOffset,
    ULONG IPLength,
    PNDIS1394_FRAGMENT_HEADER     pHeader,
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly
    );


BOOLEAN
nicIsOutOfOrderReassemblyComplete (
    IN  PNDIS1394_REASSEMBLY_STRUCTURE pReassembly
    );


    

NDIS_STATUS
nicValidateOutOfOrder(
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    IN ULONG CurrFragOffset,
    IN ULONG IPLength,
    OUT PULONG pFragmentNum,
    OUT PREASSEMBLY_INSERT_TYPE pInsertionManner,
    OUT PBOOLEAN pfAbort
    );


NDIS_STATUS
nicDoReassembly ( 
    IN PNIC_RECV_DATA_INFO pRcvInfo,
    OUT PNDIS1394_REASSEMBLY_STRUCTURE *ppReassembly,
    PBOOLEAN pfReassemblyComplete
    );


VOID
nicAddUnfragmentedHeader (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    IN PVOID pEncapHeader
    );
    

VOID
nicReceiveCommonCallback (
    IN PVOID pIndicatedStruct,
    IN PVCCB pVc,
    BUS_OPERATION RecvOp,
    PMDL pMdl
    );


NDIS_STATUS
nicGetNdisBufferForReassembly(
    IN PNIC_RECV_DATA_INFO pRcvInfo,
    OUT PNDIS_BUFFER *ppNdisBuffer
    );






NDIS_STATUS
nicInsertFragmentInReassembly (
    PNDIS1394_REASSEMBLY_STRUCTURE  pReassembly,
    PNIC_RECV_DATA_INFO pRcvInfo
    );






VOID
nicFindInsertionPosition (
    PNDIS1394_REASSEMBLY_STRUCTURE  pReassmbly, 
    ULONG FragOffset, 
    ULONG IPLength, 
    PULONG pFragmentNum
    );





VOID 
nicChainReassembly (
    PNDIS1394_REASSEMBLY_STRUCTURE  pReassembly
    );



VOID
nicRecvNoRemoteNode(
    PADAPTERCB pAdapter
    );


VOID
nicInsertNodeAddressAtHead (
    IN PNDIS_PACKET pPacket, 
    IN PNIC_RECV_DATA_INFO pRcvInfo
    );

VOID
nicUpdateNodeTable(
    NDIS_WORK_ITEM* pUpdateTable,
    IN PVOID Context 
    );


NDIS_STATUS
nicInitSerializedReassemblyStruct(
    PADAPTERCB pAdapter
    );

VOID
nicDeInitSerializedReassmblyStruct(
    PADAPTERCB pAdapter
    );

NDIS_STATUS
nicQueueReassemblyTimer(
    PADAPTERCB pAdapter,
    BOOLEAN fIsLastTimer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\tools\ipfwadm\common.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

	common.h

Abstract:

	IEEE1394 ARP Admin Utility.

	Usage:

		a13adm 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	06-10-1999	Created

--*/

#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <devioctl.h>
#include <setupapi.h>

#define PROTOCOL_RESERVED_SIZE_IN_PACKET (4 * sizeof(PVOID)) // from ndis.h
#define USER_MODE 1
#include <nic1394.h>
#include <nicarp.h>
#include <rfc2734.h>
#include <a13ioctl.h>


VOID
DoCmd(
  	PARP1394_IOCTL_COMMAND pCmd
);

BOOL
GetBinaryData(
	TCHAR *tszPathName,
	TCHAR *tszSection,
	TCHAR *tszKey,
	UCHAR *pchData,
	UINT  cbMaxData,
	UINT *pcbDataSize
	);

extern CHAR *g_szPacketName;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\util.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// util.c
//
// IEEE1394 mini-port/call-manager driver
//
// General utility routines
//
// 12/28/1998 JosephJ Created, adapted from the l2tp sources.
//


#include "precomp.h"



//-----------------------------------------------------------------------------
// General utility routines (alphabetically)
//-----------------------------------------------------------------------------

VOID
nicSetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = *pulFlags;
        ulNewFlags = ulFlags | ulMask;
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}

VOID
nicClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = *pulFlags;
        ulNewFlags = ulFlags & ~(ulMask);
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}

ULONG
nicReadFlags(
    IN ULONG* pulFlags )

    // Read the value of '*pulFlags' as an interlocked operation.
    //
{
    return *pulFlags;
}



//
// Reference And Dereference functions taken directly from Ndis
//



BOOLEAN
nicReferenceRef(
    IN  PREF                RefP,
    OUT PLONG              pNumber
    )

/*++

Routine Description:

    Adds a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference was added.
    FALSE if the object was closing.

--*/

{
    BOOLEAN rc = TRUE;
    KIRQL   OldIrql;

    TRACE( TL_V, TM_Ref, ( "nicReferenceRef, %.8x", RefP ) );


    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else
    {
        *pNumber = NdisInterlockedIncrement (&RefP->ReferenceCount);
    }


    TRACE( TL_V, TM_Ref, ( "nicReferenceRef, Bool %.2x, Ref %d", rc, RefP->ReferenceCount ) );

    return(rc);
}


BOOLEAN
nicDereferenceRef(
    IN  PREF                RefP,
    IN  PLONG               pRefCount
    )

/*++

Routine Description:

    Removes a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference count is now 0.
    FALSE otherwise.

--*/

{
    BOOLEAN rc = FALSE;
    KIRQL   OldIrql;
    ULONG NewRef;

    TRACE( TL_V, TM_Ref, ( "==>nicDeReferenceRef, %x", RefP ) );


    NewRef = NdisInterlockedDecrement (&RefP->ReferenceCount);

    if ((signed long)NewRef  < 0)
    {
        ASSERT ( !"Ref Has Gone BELOW ZERO");
    }

    if (NewRef  == 0)
    {
        rc = TRUE;
        NdisSetEvent (&RefP->RefZeroEvent);

    }

    *pRefCount = NewRef;


    TRACE( TL_V, TM_Ref, ( "<==nicDeReferenceRef, %.2x, RefCount %d", rc, NewRef  ) );
            
    return(rc);
}


VOID
nicInitializeRef(
    IN  PREF                RefP
    )

/*++

Routine Description:

    Initialize a reference count structure.

Arguments:

    RefP - The structure to be initialized.

Return Value:

    None.

--*/

{
    TRACE( TL_V, TM_Ref, ( "==>nicInitializeRef, %.8x", RefP ) );


    RefP->Closing = FALSE;
    RefP->ReferenceCount = 1;
    
    NdisInitializeEvent (&RefP->RefZeroEvent);

    TRACE( TL_V, TM_Ref, ( "<==nicInitializeRef, %.8x", RefP ) );
}


BOOLEAN
nicCloseRef(
    IN  PREF                RefP
    )

/*++

Routine Description:

    Closes a reference count structure.

Arguments:

    RefP - The structure to be closed.

Return Value:

    FALSE if it was already closing.
    TRUE otherwise.

--*/

{
    KIRQL   OldIrql;
    BOOLEAN rc = TRUE;

    TRACE( TL_N, TM_Ref, ( "==>ndisCloseRef, %.8x", RefP ) );


    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else RefP->Closing = TRUE;


    TRACE( TL_N, TM_Ref, ( "<==ndisCloseRef, %.8x, RefCount %.8x", RefP, RefP->ReferenceCount ) );
            
    return(rc);
}



//
// The following #define is used to track RemoteNode references in memory.
//
//

#define LOG_REMOTE_NODE_REF 0

#if LOG_REMOTE_NODE_REF
typedef enum _REF_CHANGE
{
    IncrementRef =1,
    DecrementRef


}REF_CHANGE, *PREF_CHANGE;

typedef struct _REMOTE_NODE_TRACKER
{

    PREMOTE_NODE pRemoteNode;
   
    
    REMOTE_NODE_REF_CAUSE Cause;

    ULONG RefNumber;

    REF_CHANGE Change;

}REMOTE_NODE_TRACKER, *PREMOTE_NODE_TRACKER;


#define REMOTE_NODE_TRACKER_SIZE 5000

REMOTE_NODE_TRACKER RemTracker[REMOTE_NODE_TRACKER_SIZE];
ULONG RemTrackerIndex = 0;

VOID
nicFillRemoteNodeTracker(
    IN PREMOTE_NODE pRemoteNode,
    IN REMOTE_NODE_REF_CAUSE  Cause,
    IN ULONG RefCount,
    IN REF_CHANGE  Change
    )

{
    LONG RemIndex= 0;
    RemIndex = NdisInterlockedIncrement (&RemTrackerIndex);

    if (RemIndex >= REMOTE_NODE_TRACKER_SIZE)
    {
        RemIndex = 0;
        RemTrackerIndex=0;
    }

    RemTracker[RemIndex].pRemoteNode = pRemoteNode;
    RemTracker[RemIndex].Cause = Cause;
    RemTracker[RemIndex].RefNumber = RefCount;
    RemTracker[RemIndex].Change = Change;
 
}
#endif


//
//
// These are self expanatory Remote Node  Reference functions
// which will be turned into macros once we have functionality 
// working
//


BOOLEAN
nicReferenceRemoteNode (
    IN REMOTE_NODE *pPdoCb,
    IN REMOTE_NODE_REF_CAUSE Cause
    )
/*++

Routine Description:
    

Arguments:


Return Value:

--*/
{
    BOOLEAN bRefClosing = FALSE;
    ULONG RefNumber =0;


    bRefClosing = nicReferenceRef (&pPdoCb->Ref, &RefNumber);

#if LOG_REMOTE_NODE_REF
    nicFillRemoteNodeTracker(pPdoCb, Cause, RefNumber,IncrementRef);
#endif    
    
    TRACE( TL_V, TM_RemRef, ( "**nicReferenceRemoteNode pPdoCb %x, to %d, ret %x ", 
                          pPdoCb, pPdoCb->Ref.ReferenceCount,  bRefClosing  ) );

    return bRefClosing ; 
}


BOOLEAN
nicDereferenceRemoteNode (
    IN REMOTE_NODE *pPdoCb,
    IN REMOTE_NODE_REF_CAUSE Cause
    )
/*++

Routine Description:
    

Arguments:


Return Value:

--*/
{
    BOOLEAN bRet;
    ULONG RefCount = 0;
    TRACE( TL_V, TM_RemRef, ( "**nicDereferenceRemoteNode  %x to %d", 
                              pPdoCb , pPdoCb->Ref.ReferenceCount -1 ) );


    bRet = nicDereferenceRef (&pPdoCb->Ref, &RefCount );

#if LOG_REMOTE_NODE_REF
    nicFillRemoteNodeTracker(pPdoCb, Cause, RefCount,DecrementRef);
#endif
    return bRet;
}


VOID
nicInitalizeRefRemoteNode(
    IN REMOTE_NODE *pPdoCb
    )
/*++

Routine Description:
    
    Closes Ref on the remote node
Arguments:

    IN REMOTE_NODE *pPdoCb - RemoteNode

Return Value:

    None
--*/
{
    TRACE( TL_N, TM_Ref, ( "**nicinitalizeRefPdoCb pPdoCb %.8x", pPdoCb   ) );

    nicInitializeRef (&pPdoCb->Ref);
}


BOOLEAN
nicCloseRefRemoteNode(
    IN REMOTE_NODE *pPdoCb
    )
/*++

Routine Description:
    
    Closes Ref on the remote node
Arguments:

    IN REMOTE_NODE *pPdoCb - RemoteNode

Return Value:

    Return value of nicCloseRef

--*/


{
    TRACE( TL_N, TM_Ref, ( "**nicClosePdoCb pPdoCb %.8x", pPdoCb   ) );

    return nicCloseRef (&pPdoCb->Ref);
}


NDIS_STATUS
NtStatusToNdisStatus (
    NTSTATUS NtStatus 
    )

/*++

Routine Description:
    
    Dumps the packet , if the appropriate Debuglevels are set

Arguments:

    NTSTATUS NtStatus  - NtStatus to be converted


Return Value:

    NdisStatus - NtStatus' corresponding NdisStatus

--*/


{
    NDIS_STATUS NdisStatus;
    
    switch (NtStatus)
    {
        case STATUS_SUCCESS:
        {
            NdisStatus = NDIS_STATUS_SUCCESS;
            break;
        }

        case STATUS_UNSUCCESSFUL:
        {   
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        case STATUS_PENDING:
        {
            NdisStatus = NDIS_STATUS_PENDING;
            break;
        }

        case STATUS_INVALID_BUFFER_SIZE:
        {
            NdisStatus = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        case STATUS_INSUFFICIENT_RESOURCES:
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        case STATUS_INVALID_GENERATION:
        {
            NdisStatus = NDIS_STATUS_DEST_OUT_OF_ORDER;
            break;
        }
        case STATUS_ALREADY_COMMITTED:
        {
            NdisStatus = NDIS_STATUS_RESOURCE_CONFLICT;
            break;
        }

        case STATUS_DEVICE_BUSY:
        {
            NdisStatus = NDIS_STATUS_MEDIA_BUSY;
            break;
        }

        case STATUS_INVALID_PARAMETER:
        {
            NdisStatus = NDIS_STATUS_INVALID_DATA;
            break;

        }
        case STATUS_DEVICE_DATA_ERROR:
        {
            NdisStatus = NDIS_STATUS_DEST_OUT_OF_ORDER;
            break;
        }

        case STATUS_TIMEOUT:
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }
        case STATUS_IO_DEVICE_ERROR:
        {
            NdisStatus = NDIS_STATUS_NETWORK_UNREACHABLE;
            break;
        }
        default:
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            TRACE( TL_A, TM_Send, ( "Cause: Don't know, INVESTIGATE %x", NtStatus  ) );

        }

    }

    return NdisStatus;



}




VOID
nicAllocatePacket(
    OUT PNDIS_STATUS pNdisStatus,
    OUT PNDIS_PACKET *ppNdisPacket,
    IN PNIC_PACKET_POOL pPacketPool
    )
/*++

Routine Description:
    
    Calls the ndis API to allocate a packet. 


Arguments:

    pNdisStatus  - pointer to NdisStatus 

    *ppNdisPacket - Ndis packet Allocated by Ndis,

    pPacketPool - packet pool from which the packet is allocated


Return Value:

    return value of the call to Ndis

--*/

{
    KIRQL OldIrql;



    NdisAllocatePacket (pNdisStatus,
                        ppNdisPacket,
                        pPacketPool->Handle );
    

    if (*pNdisStatus == NDIS_STATUS_SUCCESS)
    {
            PRSVD pRsvd = NULL;
            PINDICATE_RSVD  pIndicateRsvd = NULL;
            pRsvd =(PRSVD)((*ppNdisPacket)->ProtocolReserved);

            pIndicateRsvd = &pRsvd->IndicateRsvd;

            pIndicateRsvd->Tag  = NIC1394_TAG_ALLOCATED;

            NdisInterlockedIncrement (&pPacketPool->AllocatedPackets);

    }
    else
    {
        *ppNdisPacket = NULL;
        nicIncrementMallocFailure();
    }


}




VOID
nicFreePacket(
    IN PNDIS_PACKET pNdisPacket,
    IN PNIC_PACKET_POOL pPacketPool
    )
/*++

Routine Description:
    
    Free the packet and decrements the outstanding Packet count.

Arguments:

    IN PNDIS_PACKET pNdisPacket - Packet to be freed
    IN PNIC_PACKET_POOL pPacketPool  - PacketPool to which the packet belongs 


Return Value:

    None

--*/

{

    KIRQL OldIrql;
    PRSVD pRsvd = NULL;
    PINDICATE_RSVD pIndicateRsvd = NULL;

    pRsvd =(PRSVD)(pNdisPacket->ProtocolReserved);

    pIndicateRsvd = &pRsvd->IndicateRsvd;

    pIndicateRsvd->Tag  = NIC1394_TAG_FREED;

    NdisInterlockedDecrement (&pPacketPool->AllocatedPackets);

    NdisFreePacket (pNdisPacket);

}



VOID
nicFreePacketPool (
    IN PNIC_PACKET_POOL pPacketPool
    )
/*++

Routine Description:

    frees the packet pool after waiting for the outstanding packet count to go to zero      

Arguments:

    IN PNIC_PACKET_POOL pPacketPool  - PacketPool which is to be freed


Return Value:

    None

--*/
{
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
    

    while (NdisPacketPoolUsage (pPacketPool->Handle)!=0)
    {
        TRACE( TL_V, TM_Cm, ( "  Waiting PacketPool %x, AllocatedPackets %x", 
        pPacketPool->Handle, pPacketPool->AllocatedPackets  ) );   

        NdisMSleep (10000);
    }
    
    NdisFreePacketPool (pPacketPool->Handle);

    pPacketPool->Handle = NULL;
    ASSERT (pPacketPool->AllocatedPackets   == 0);
}

VOID
nicAcquireSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock,
    IN PUCHAR   FileName,
    IN UINT LineNumber
    )
/*++

Routine Description:

    Acquires a spin lock and if the Dbg, then it will spew out the line and file

Arguments:

    NIC_SPIN_LOCK - Lock to be acquired

Return Value:

    None

--*/
{
    
        PKTHREAD                pThread;

        TRACE (TL_V, TM_Lock, ("Lock %x, Acquired by File %s, Line %x" , pNicSpinLock, FileName, LineNumber)) ; 

        NdisAcquireSpinLock(&(pNicSpinLock->NdisLock));

#if TRACK_LOCKS     
        pThread = KeGetCurrentThread();


        pNicSpinLock->OwnerThread = pThread;
        NdisMoveMemory(pNicSpinLock->TouchedByFileName, FileName, LOCK_FILE_NAME_LEN);
        pNicSpinLock->TouchedByFileName[LOCK_FILE_NAME_LEN - 1] = 0x0;
        pNicSpinLock->TouchedInLineNumber = LineNumber;
        pNicSpinLock->IsAcquired++;

#endif
}



VOID
nicReleaseSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock,
    IN PUCHAR   FileName,
    IN UINT LineNumber
)
/*++

Routine Description:

    Release a spin lock and if Dbg is On, then it will spew out the line and file

Arguments:

    pNicSpinLock - Lock to be Release
    FileName - File Name
    LineNumber - Line

Return Value:

    None

--*/
{
    
        PKTHREAD                pThread;

        TRACE (TL_V, TM_Lock, ("Lock %x, Released by File %s, Line %x" , pNicSpinLock, FileName, LineNumber)) ; 

#if TRACK_LOCKS     
        
        pThread = KeGetCurrentThread();

        NdisMoveMemory(pNicSpinLock->TouchedByFileName, FileName, LOCK_FILE_NAME_LEN);
        pNicSpinLock->TouchedByFileName[LOCK_FILE_NAME_LEN - 1] = 0x0;
        pNicSpinLock->TouchedInLineNumber = LineNumber;
        pNicSpinLock->IsAcquired--;
        pNicSpinLock->OwnerThread = 0;
#endif
        NdisReleaseSpinLock(&(pNicSpinLock->NdisLock));

}




VOID
nicInitializeNicSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock
    )
/*++

Routine Description:

    Initializes the lock in the SpinLock

Arguments:
    pNicSpinLock - SpinLock
    
Return Value:

    None

--*/
{
    NdisAllocateSpinLock (&pNicSpinLock->NdisLock); 
}


VOID 
nicFreeNicSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock
    )
/*++

Routine Description:

        Frees the spinlock
        
Arguments:
    pNicSpinLock - SpinLock
    
Return Value:

    None

--*/
{
    ASSERT ((ULONG)pNicSpinLock->NdisLock.SpinLock == 0);
    NdisFreeSpinLock (&pNicSpinLock->NdisLock); 
}


UINT
nicGetSystemTime(
    VOID
    )
/*++
    Returns system time in seconds.

    Since it's in seconds, we won't overflow unless the system has been up 
for over
    a  100 years :-)
--*/
{
    LARGE_INTEGER Time;
    NdisGetCurrentSystemTime(&Time);
    Time.QuadPart /= 10000000;          //100-nanoseconds to seconds.

    return Time.LowPart;
}


UINT
nicGetSystemTimeMilliSeconds(
    VOID
    )
/*++
    Returns system time in seconds.

    Since it's in seconds, we won't overflow unless the system has been up 
for over
    a  100 years :-)
--*/
{
    LARGE_INTEGER Time;
    NdisGetCurrentSystemTime(&Time);
    Time.QuadPart /= 10000;          //10-nanoseconds to seconds.

    return Time.LowPart;
}




ULONG 
SwapBytesUlong(
    IN ULONG Val)
{
            return  ((((Val) & 0x000000ff) << 24)   |   (((Val) & 0x0000ff00) << 8) |   (((Val) & 0x00ff0000) >> 8) |   (((Val) & 0xff000000) >> 24) );
}




void
nicTimeStamp(
    char *szFormatString,
    UINT Val
    )
/*++

Routine Description:
  Execute and print a time stamp
 
Arguments:


Return Value:


--*/
{
    UINT Minutes;
    UINT Seconds;
    UINT Milliseconds;
    LARGE_INTEGER Time;


    NdisGetCurrentSystemTime(&Time);



    Time.QuadPart /= 10000;         //10-nanoseconds to milliseconds.
    Milliseconds = Time.LowPart; // don't care about highpart.
    Seconds = Milliseconds/1000;
    Milliseconds %= 1000;
    Minutes = Seconds/60;
    Seconds %= 60;


    DbgPrint( szFormatString, Minutes, Seconds, Milliseconds, Val);
}


VOID
nicDumpPkt (
    IN PNDIS_PACKET pPacket,
    CHAR * str
    )
/*++

Routine Description:
    This functions is used for Debugging in runtime. If the global variable
    is set, then it will spew out the MDLs onto the debuggger.

Arguments:


Return Value:


--*/
    
{
    PNDIS_BUFFER pBuffer;
    extern BOOLEAN g_ulNicDumpPacket ;
    
    if ( g_ulNicDumpPacket == FALSE)
    {
        return ;
    }


    pBuffer = pPacket->Private.Head;


    DbgPrint (str);
    DbgPrint ("Packet %p TotLen %x", pPacket, pPacket->Private.TotalLength);
     
    do
    {
        ULONG Length = nicNdisBufferLength (pBuffer);
        PUCHAR pVa = nicNdisBufferVirtualAddress (pBuffer);


        DbgPrint ("pBuffer %p, Len %x \n", pBuffer, Length);    
        Dump( pVa, Length, 0, 1 );

        pBuffer = pBuffer->Next;


    } while (pBuffer != NULL);



}


VOID 
nicDumpMdl (
    IN PMDL pMdl,
    IN ULONG LengthToPrint,
    IN CHAR *str
    )
{

    ULONG MdlLength ;
    PUCHAR pVa;
    extern BOOLEAN g_ulNicDumpPacket ;

    if ( g_ulNicDumpPacket == FALSE )
    {
        return;
    }

    MdlLength =  MmGetMdlByteCount(pMdl);
    //
    // if Length is zero then use MdlLength
    //
    if (LengthToPrint == 0)
    {
        LengthToPrint = MdlLength;
    }
    //
    // Check for invalid length
    // 
    
    if (MdlLength < LengthToPrint)
    {
        return;
    }

    pVa =  MmGetSystemAddressForMdlSafe(pMdl,LowPagePriority );

    if (pVa == NULL)
    {
        return;
    }
    
    DbgPrint (str);
    DbgPrint ("pMdl %p, Len %x\n", pMdl, LengthToPrint);    
    
    Dump( pVa, LengthToPrint, 0, 1 );


}



NDIS_STATUS
nicScheduleWorkItem (
    IN PADAPTERCB pAdapter,
    IN PNDIS_WORK_ITEM pWorkItem
    )
/*++

Routine Description:

    This function schedules a WorkItem to fire.
    It references the Adapter object by incrementing the number of 
    outstanding workitems. 

    In case of failure, it decrements the count.


Arguments:

    Self explanatory 
    
Return Value:
    Success - appropriate failure code from NdisScheduleWorkItem

--*/
{

    NDIS_STATUS NdisStatus  = NDIS_STATUS_FAILURE;

    NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

    NdisStatus = NdisScheduleWorkItem (pWorkItem);

    if(NDIS_STATUS_SUCCESS != NdisStatus)
    {

        NdisInterlockedDecrement (&pAdapter->OutstandingWorkItems);

    }

    return NdisStatus;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\tools\ipfwadm\cmd.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

	cmd.c

Abstract:

	 IEEE1394 ARP Admin Utility.

	Usage:

		a13adm 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	04-10-1999	Created

--*/

#include "common.h"

#ifndef NDIS_STATUS
#define NDIS_STATUS		ULONG
#endif

#define ANSI_ARP_CLIENT_DOS_DEVICE_NAME "\\\\.\\ARP1394"

#define DUMMY 0
#define FAKE_DUMP 0

VOID
DoBusInfoCmd(
    HANDLE DeviceHandle,
  	PARP1394_IOCTL_COMMAND pCmd
  	);

#if DUMMY

BOOL
DummyDeviceIoControl(
	HANDLE		DeviceHandle,
	UINT		Ioctl,
  	PARP1394_IOCTL_COMMAND pInCmd,
  	UINT		Size,
  	PARP1394_IOCTL_COMMAND pOutCmd,
  	UINT		OutSize,
  	PUINT		pBytesReturned,
  	PVOID		Blah
  	);

#define DeviceIoControl	DummyDeviceIoControl

#endif // DUMMY

HANDLE
OpenDevice(
	CHAR	*pDeviceName
);

extern CHAR *g_szPacketName;

VOID
CloseDevice(
	HANDLE		DeviceHandle
);

VOID
DumpArpCache(
		PARP1394_IOCTL_GET_ARPCACHE pGetCacheCmd
		);

VOID
DumpPacketStats(
	PARP1394_IOCTL_GET_PACKET_STATS pStatsCmd
	);

VOID
DumpTaskStats(
	PARP1394_IOCTL_GET_TASK_STATS pStatsCmd
	);


VOID
DumpArpStats(
	PARP1394_IOCTL_GET_ARPCACHE_STATS pStatsCmd
	);

VOID
DumpCallStats(
PARP1394_IOCTL_GET_CALL_STATS pStatsCmd
	);

VOID
DumpPacketCounts(
	PARP1394_PACKET_COUNTS pPktCounts,
	BOOL				  fRecv,
	char *szDescription
	);

VOID
Dump1394UniqueID(
	UINT64 UniqueID
	);

VOID
DumpNicInfo(
	ARP1394_IOCTL_NICINFO *pNicInfo
	);


#if OBSOLETE
VOID
DumpBusInfo(
    PNIC1394_BUSINFO pBi
    );
#endif // OBSOLETE

VOID
DumpChannelInfo(
    PNIC1394_CHANNELINFO pCi
    );

VOID
DumpRemoteNodeInfo(
    PNIC1394_REMOTENODEINFO pRni
    );

VOID
arpDumpChannelMap(
		UINT64 Map
		);

VOID
arpDumpPktStats(
		char *szPrefix,
		NIC1394_PACKET_STATS *pPs
		);
VOID
DumpEuidMapInfo(
	PARP1394_IOCTL_EUID_NODE_MAC_INFO pEuidInfo
	);




VOID
DoCmd(
  	PARP1394_IOCTL_COMMAND pCmd
)
{
	BOOL 	fRet = FALSE;
	PUCHAR 	pc;
	HANDLE	DeviceHandle;
	DWORD 	BytesReturned;
    BOOL fDumpNicInfo=FALSE;

    // Special case -- DumpNicInfo.
    //
    if (pCmd->Hdr.Op == ARP1394_IOCTL_OP_GET_NICINFO)
    {
        PNIC1394_NICINFO pNi =  &pCmd->IoctlNicInfo.Info;

        if (pNi->Hdr.Op ==  NIC1394_NICINFO_OP_BUSINFO)
        {
            fDumpNicInfo = TRUE;
        }
    }
	pc = (PUCHAR)&pCmd->Hdr.IfIpAddress;

	// Open device
	//
	DeviceHandle = OpenDevice(ANSI_ARP_CLIENT_DOS_DEVICE_NAME);
	if (DeviceHandle == INVALID_HANDLE_VALUE)
	{
		printf("Could not access IP/1394 ARP Client module.\n");
	}
	else if (fDumpNicInfo)
    {
        DoBusInfoCmd(DeviceHandle, pCmd);
		CloseDevice(DeviceHandle);
    }
    else
	{
		BOOL fResetStats = (pCmd->Hdr.Op == ARP1394_IOCTL_OP_RESET_STATS);

		printf("Opened handle 0x%p\n", DeviceHandle);


		// Submit Ioctl
		//
		fRet =	DeviceIoControl(
						DeviceHandle,
						ARP_IOCTL_CLIENT_OPERATION,
						pCmd,
						sizeof(*pCmd),
						pCmd,
						sizeof(*pCmd),
						&BytesReturned,
						NULL
						);

		//
		// Special case "resetstats" -- we reset both ARP and NIC stats
		//
		if (fResetStats)
		{
  			ARP1394_IOCTL_COMMAND Cmd = *pCmd;
			PNIC1394_NICINFO	pNi = &Cmd.IoctlNicInfo.Info;
			Cmd.Hdr.Op 		= ARP1394_IOCTL_OP_GET_NICINFO;
			pNi->Hdr.Version 	= NIC1394_NICINFO_VERSION;
			pNi->Hdr.Op 		= NIC1394_NICINFO_OP_RESETSTATS;

			// Submit Ioctl
			//
			fRet =	DeviceIoControl(
							DeviceHandle,
							ARP_IOCTL_CLIENT_OPERATION,
							&Cmd,
							sizeof(Cmd),
							&Cmd,
							sizeof(Cmd),
							&BytesReturned,
							NULL
							);
		}
	
		//	Close device
		//
		CloseDevice(DeviceHandle);

		if (!fRet)
		{
			printf("Request failed with error code 0x%08lx\n", GetLastError());
		}
	}

	if (!fRet)
	{
		return;				// 	EARLY RETURN
		BytesReturned=0;
	}

	// Display results.
	//
	switch(pCmd->Hdr.Op)
	{
	case ARP1394_IOCTL_OP_GET_ARPCACHE:
		DumpArpCache(&pCmd->GetArpCache);
		break;

	case ARP1394_IOCTL_OP_ADD_STATIC_ENTRY:
		{
			PARP1394_IOCTL_ADD_ARP_ENTRY pAddCmd =  &pCmd->AddArpEntry;

			printf(
				"Added the following static arp entry to IF %d.%d.%d.%d:\n",
				pc[0], pc[1], pc[2], pc[3]
				);

			pc = (PUCHAR)&pAddCmd->IpAddress;

			printf(
				"    %d.%d.%d.%d -> ",
					pc[0], pc[1], pc[2], pc[3]
				);

			Dump1394UniqueID(pAddCmd->HwAddress.UniqueID);
			printf("\n");
		}
		break;

	case ARP1394_IOCTL_OP_DEL_STATIC_ENTRY:
		{
			PARP1394_IOCTL_DEL_ARP_ENTRY pDelCmd =  &pCmd->DelArpEntry;

			printf(
		"Deleted all entries from IF %d.%d.%d.%d for the following destinations:\n",
				pc[0], pc[1], pc[2], pc[3]
				);

			pc = (PUCHAR)&pDelCmd->IpAddress;

			printf(
				"    %d.%d.%d.%d\n",
					pc[0], pc[1], pc[2], pc[3]
				);
		}
		break;

	case ARP1394_IOCTL_OP_GET_PACKET_STATS:
		DumpPacketStats(&pCmd->GetPktStats);
		break;

	case ARP1394_IOCTL_OP_GET_TASK_STATS:
		DumpTaskStats(&pCmd->GetTaskStats);
		break;

	case ARP1394_IOCTL_OP_GET_ARPCACHE_STATS:
		DumpArpStats(&pCmd->GetArpStats);
		break;

	case ARP1394_IOCTL_OP_GET_CALL_STATS:
		DumpCallStats(&pCmd->GetCallStats);
		break;

	case ARP1394_IOCTL_OP_RESET_STATS:
		printf(
			"Reset arp and nic statistics collection on IF %d.%d.%d.%d.\n\n",
			pc[0], pc[1], pc[2], pc[3]
			);
		break;

	case ARP1394_IOCTL_OP_REINIT_INTERFACE:
		printf(
			"Reinited IF %d.%d.%d.%d.\n\n",
			pc[0], pc[1], pc[2], pc[3]
			);
		break;

	case ARP1394_IOCTL_OP_RECV_PACKET:
		printf(
			"Simulated receive of %lu-byte packet \"%s\" on IF %d.%d.%d.%d.\n\n",
			pCmd->RecvPacket.PacketSize,
			g_szPacketName,
			pc[0], pc[1], pc[2], pc[3]
			);
		break;

	case ARP1394_IOCTL_OP_ETHERNET_START_EMULATION:
		printf(
			"Requested ARP to START Ethernet emulation on adapter \"%s\"\n\n",
			g_szPacketName
			);
        break;

	case ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION:
		printf(
			"Requested ARP to STOP Ethernet emulation on adapter \"%s\"\n\n",
			g_szPacketName
			);
        break;

	case ARP1394_IOCTL_OP_GET_NICINFO:
		DumpNicInfo(&pCmd->IoctlNicInfo);
		break;
		
	case ARP1394_IOCTL_OP_GET_EUID_NODE_MAC_TABLE:
		DumpEuidMapInfo(&pCmd->EuidNodeMacInfo);
		break;

	default:
		printf("HAIII!!!\n");
		break;

	}
}



VOID
DumpArpCache(
		PARP1394_IOCTL_GET_ARPCACHE pGetCacheCmd
		)
{
	UINT u;
	PARP1394_ARP_ENTRY pEntry = pGetCacheCmd->Entries;
	PUCHAR pc;

#if FAKE_DUMP
	pGetCacheCmd->NumEntriesInArpCache = 30;
	pGetCacheCmd->NumEntriesUsed = 2;
	pGetCacheCmd->Index = 0;
	((PULONG)&(pEntry[0].HwAddress.UniqueID))[0] = 0x12;
	((PULONG)&(pEntry[0].HwAddress.UniqueID))[1] = 0x34;
	pEntry[0].IpAddress = 0x0100000a;
	((PULONG)&(pEntry[1].HwAddress.UniqueID))[0] = 0x56;
	((PULONG)&(pEntry[1].HwAddress.UniqueID))[1] = 0x78;
	pEntry[1].IpAddress = 0x0200000a;
#endif // FAKE_DUMP

	pc = (PUCHAR)&pGetCacheCmd->Hdr.IfIpAddress;
	printf("Arp Cache of IF %d.%d.%d.%d [", pc[0], pc[1], pc[2], pc[3]);

	Dump1394UniqueID(pGetCacheCmd->LocalHwAddress.UniqueID);
	printf(
		" (%04lx:%08lx)]\n",
		pGetCacheCmd->LocalHwAddress.Off_Low,
		pGetCacheCmd->LocalHwAddress.Off_High
		);

	for (u=0;u<pGetCacheCmd->NumEntriesUsed;u++,pEntry++)
	{
		PUCHAR pc1 = (PUCHAR)&pEntry->IpAddress;
		printf(
			"    %d.%d.%d.%d -> ",
				pc1[0], pc1[1], pc1[2], pc1[3]
			);
		Dump1394UniqueID(pEntry->HwAddress.UniqueID);
		printf("\n");
	}
}


VOID
DumpPacketStats(
	PARP1394_IOCTL_GET_PACKET_STATS pStatsCmd
	)
{
	PUCHAR pc;


	pc = (PUCHAR)&pStatsCmd->Hdr.IfIpAddress;
	printf("Packet stats for IF %d.%d.%d.%d\n", pc[0], pc[1], pc[2], pc[3]);

	printf("                 Duration: %d seconds\n", pStatsCmd->StatsDuration);

	printf("              Total sends: %d\n", pStatsCmd->TotSends);
	printf("               Fast sends: %d\n", pStatsCmd->FastSends);
	printf("             Medium sends: %d\n", pStatsCmd->MediumSends);
	printf("               Slow sends: %d\n", pStatsCmd->SlowSends);
	printf("                Backfills: %d\n", pStatsCmd->BackFills);
	printf("          Header buf uses: %d\n", pStatsCmd->HeaderBufUses);
	printf("    Header buf cache hits: %d\n", pStatsCmd->HeaderBufCacheHits);

	//
	// Some recv stats
	//
	printf("           Total receives: %d\n", pStatsCmd->TotRecvs);
	printf("         No-copy receives: %d\n", pStatsCmd->NoCopyRecvs);
	printf("            Copy receives: %d\n", pStatsCmd->CopyRecvs);
	printf("        Resource receives: %d\n", pStatsCmd->ResourceRecvs);

	//
	// Packet counts
	//
	DumpPacketCounts(&pStatsCmd->SendFifoCounts, FALSE, "FIFO sends");
	DumpPacketCounts(&pStatsCmd->RecvFifoCounts, TRUE, "FIFO receives");
	DumpPacketCounts(&pStatsCmd->SendChannelCounts, FALSE, "Channel sends");
	DumpPacketCounts(&pStatsCmd->RecvChannelCounts, TRUE, "Channel receives");
}


VOID
DumpTaskStats(
	PARP1394_IOCTL_GET_TASK_STATS pStatsCmd
	)
{
	PUCHAR pc;

	pc = (PUCHAR)&pStatsCmd->Hdr.IfIpAddress;
	printf("Task stats for IF %d.%d.%d.%d\n", pc[0], pc[1], pc[2], pc[3]);

	printf("                 Duration: %d seconds\n", pStatsCmd->StatsDuration);
	printf("              Total tasks: %d\n", pStatsCmd->TotalTasks);
	printf("            Current tasks: %d\n", pStatsCmd->CurrentTasks);

	//
	// Task times
	//
	{

		int i;
	
		#if 0
		|<=1us   | ...100us |...1ms   |...10ms  | >10ms
		---------+--------+----------+---------+---------+--------
		|10000000| 10000000 |10000000 |10000000 |     100
		|(100000)| (100000) |(100000  |(100000) |    (100)
		#endif // 0
	
		printf("Task times:\n");
		printf("    |<=1ms    |...100ms |...1s    |...10s   | >10s\n");
		printf("    +---------+---------+---------+---------+--------\n");
		printf("   ");
		for (i=0;i<ARP1394_NUM_TASKTIME_SLOTS;i++)
		{
		#if FAKE_DUMP
			pStatsCmd->TimeCounts[i] = i*100000;
		#endif // FAKE_DUMP
			printf(" |%8lu", pStatsCmd->TimeCounts[i]);
		}
		printf("\n");
	}
}


VOID
DumpArpStats(
	PARP1394_IOCTL_GET_ARPCACHE_STATS pStatsCmd
	)
{
	PUCHAR pc;

	pc = (PUCHAR)&pStatsCmd->Hdr.IfIpAddress;
	printf("Arp cache stats for IF %d.%d.%d.%d\n", pc[0], pc[1], pc[2], pc[3]);

	printf("                 Duration: %d seconds\n", pStatsCmd->StatsDuration);
	printf("            Total queries: %d\n", pStatsCmd->TotalQueries);
	printf("       Successful queries: %d\n", pStatsCmd->SuccessfulQueries);
	printf("           Failed queries: %d\n", pStatsCmd->FailedQueries);
	printf("          Total responses: %d\n", pStatsCmd->TotalResponses);
	printf("            Total lookups: %d\n", pStatsCmd->TotalLookups);
	printf("         Links per lookup: %d\n", pStatsCmd->TraverseRatio);
}


VOID
DumpCallStats(
PARP1394_IOCTL_GET_CALL_STATS pStatsCmd
	)
{
	PUCHAR pc;
	pc = (PUCHAR)&pStatsCmd->Hdr.IfIpAddress;
	printf("Call stats for IF %d.%d.%d.%d\n", pc[0], pc[1], pc[2], pc[3]);

	printf(
	 	"         Total send FIFO make-calls: %d\n",
	 	pStatsCmd->TotalSendFifoMakeCalls
	 	);
	printf(
	 	"    Successful send FIFO make-calls: %d\n",
	 	pStatsCmd->SuccessfulSendFifoMakeCalls
	 	);
	printf(
	 	"        Failed send FIFO make-calls: %d\n",
	 	pStatsCmd->FailedSendFifoMakeCalls
	 	);
	printf(
	 	"      Incoming closes on send FIFOs: %d\n",
	 	pStatsCmd->IncomingClosesOnSendFifos
	 	);

	printf(
	 	"           Total channel make-calls: %d\n",
	 	pStatsCmd->TotalChannelMakeCalls
	 	);
	printf(
	 	"      Successful channel make-calls: %d\n",
	 	pStatsCmd->SuccessfulChannelMakeCalls
	 	);
	printf(
	 	"          Failed channel make-calls: %d\n",
	 	pStatsCmd->FailedChannelMakeCalls
	 	);
	printf(
	 	"        Incoming closes on channels: %d\n",
	 	pStatsCmd->IncomingClosesOnChannels
	 	);
}


VOID
DumpPacketCounts(
	PARP1394_PACKET_COUNTS pPktCounts,
	BOOL				  fRecv,
	char *szDescription
	)
{
	int i,j;
	char *rgTitles[ARP1394_NUM_PKTSIZE_SLOTS+1] = 
	{
	"   <= 128",
	"  129-256",
	"  257-1K ",
	"   1K-2K ",
	"    > 2K ",
	"         "
	};

#if 0
size\time|<=1us   | ...100us |...1ms   |...10ms  | >10ms
---------+--------+----------+---------+---------+--------
  <= 128 |10000000| 10000000 |10000000 |10000000 |     100
         |(100000)| (100000) |(100000  |(100000) |    (100)
  ...256 |10000000| 10000000 |10000000 |10000000 |10000000
         |(100000)| (100000) |(100000  |(100000) |    (100)
   ...1K |10000000| 10000000 |10000000 |10000000 |10000000
         |(100000)| (100000) |(100000  |(100000) |    (100)
   ...2K |10000000| 10000000 |10000000 |10000000 |10000000
         |(100000)| (100000) |(100000  |(100000) |    (100)
    > 2K |10000000| 10000000 |10000000 |10000000 |10000000
         |(100000)| (100000) |(100000  |(100000) |    (100)
#endif // 0

	printf("\n%s packet counts:\n", szDescription);

	if (fRecv)
	{
		printf(" size     |         \n");
		printf(" ---------+---------\n");
	}
	else
	{
		printf(" size\\time|<=100us  |...1ms   |...10ms  |...100ms | >100ms\n");
		printf(" ---------+---------+---------+---------+---------+--------\n");
	}

	for (i=0;i<ARP1394_NUM_PKTSIZE_SLOTS;i++)
	{
		UINT u;
		UINT GoodCounts=0;
		UINT BadCounts=0;

		//
		// Compute total goodcounts and badcounts for this size bin.
		//
		for (j=0;j<ARP1394_NUM_PKTTIME_SLOTS;j++)
		{
			GoodCounts += pPktCounts->GoodCounts[i][j];
			BadCounts  += pPktCounts->BadCounts[i][j];
		}

		if (GoodCounts ==0 && BadCounts==0)
		{
			continue;	// No packets in this size bin.
		}

		printf("%s", rgTitles[i]);
		for (j=0;j<ARP1394_NUM_PKTTIME_SLOTS;j++)
		{
			u =  (fRecv)? GoodCounts : pPktCounts->GoodCounts[i][j];

			if (u)
			{
				printf(" |%8lu", u);
			}
			else
			{
				printf(" |        ");
			}
			if (fRecv) break;
		}

		printf("\n%s",rgTitles[ARP1394_NUM_PKTSIZE_SLOTS]);
		for (j=0;j<ARP1394_NUM_PKTTIME_SLOTS;j++)
		{
			u =  (fRecv)? BadCounts : pPktCounts->BadCounts[i][j];
			if (u)
			{
				printf(" |(%6lu)", u);
			}
			else
			{
				printf(" |        ");
			}
			if (fRecv) break;
		}
		printf("\n");
	}
}

HANDLE
OpenDevice(
	CHAR	*pDeviceName
)
{
	DWORD	DesiredAccess;
	DWORD	ShareMode;
	LPSECURITY_ATTRIBUTES	lpSecurityAttributes = NULL;

	DWORD	CreationDistribution;
	DWORD	FlagsAndAttributes;
	HANDLE	TemplateFile;
	HANDLE	Handle;

	DesiredAccess = GENERIC_READ|GENERIC_WRITE;
	ShareMode = 0;
	CreationDistribution = OPEN_EXISTING;
	FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
	TemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

#if DUMMY

	Handle = (HANDLE) 0x1;

#else // !DUMMY

	Handle = CreateFile(
				pDeviceName,
				DesiredAccess,
				ShareMode,
				lpSecurityAttributes,
				CreationDistribution,
				FlagsAndAttributes,
				TemplateFile
			);
#endif // !DUMMY

	return (Handle);
}

VOID
CloseDevice(
	HANDLE		DeviceHandle
)
{
#if !DUMMY
	CloseHandle(DeviceHandle);
#endif
}

VOID Dump1394UniqueID(UINT64 UniqueID)
{
	unsigned char *pc = (char *) &UniqueID;

	printf(
		"%02lx-%02lx-%02lx-%02lx-%02lx-%02lx-%02lx-%02lx",
		pc[4], pc[5], pc[6], pc[7],
		pc[0], pc[1], pc[2], pc[3]
		);
}

VOID DumpENetAddress(ENetAddr ENetAddress)
{
	unsigned char *pc = (char *) &ENetAddress;

	printf(
		"%02lx-%02lx-%02lx-%02lx-%02lx-%02lx",
		pc[0], pc[1], pc[2], pc[3],pc[4], pc[5]);
}

#if DUMMY

BOOL
nicFillBusInfo(
    IN OUT  PNIC1394_BUSINFO pBi
    );

BOOL
nicFillChannelInfo(
    IN OUT  PNIC1394_CHANNELINFO pCi
    );

BOOL
nicFillRemoteNodeInfo(
    IN OUT  PNIC1394_REMOTENODEINFO pRni
    );


BOOL
nicFillNicInfo (
	PNIC1394_NICINFO pInNicInfo,
	PNIC1394_NICINFO pOutNicInfo
	)
{
	BOOL Ret = FALSE;

#if 0
		pBi->ChannelMapLow  	= (0x1<<1) | (0x1<<3) | (0x1<<5) | (0x1<<7);
		pBi->ChannelMapHigh  	= (0x1<<8) | (0x1<<10) | (0x1<<12) | (0x1<<14);
		pBi->NumBusResets		= 12345;
		pBi->SecondsSinceLastBusReset = 3600;
		pBi->NumRemoteNodes		= 3;

		pLi = &pBi->LocalNodeInfo;
		pLi->UniqueID 		 = 0xabcd;
		pLi->NodeAddress 	 = 	  0x31;
		pLi->MaxRecvBlockSize=0x32;
		pLi->MaxRecvSpeed	 =0x33;

		pRi = pBi->RemoteNodeInfo;

		u = pBi->NumRemoteNodes;
		for (; u; u--, pRi++)
		{
			if (u==1) 		pRi->Flags = ARP1394_IOCTL_REMOTEFLAGS_ACTIVE;
			else if (u==2)	pRi->Flags = ARP1394_IOCTL_REMOTEFLAGS_LOADING;
			else 			pRi->Flags  = ARP1394_IOCTL_REMOTEFLAGS_UNLOADING;
			pRi->UniqueID 			= u;
			pRi->NodeAddress 		= u+1;
			pRi->MaxRecvBlockSize	=u+2;
			pRi->MaxRecvSpeed		=u+3;
			pRi->MaxSpeedBetweenNodes=u+4;
		}
#endif // 0

	do
	{
		//
		// First check internal version
		//
		if (pInNicInfo->Hdr.Version != NIC1394_NICINFO_VERSION)
		{
			printf("DummyIoctl:  NICINFO.Version mismatch. Want %lu got %lu\n",
						NIC1394_NICINFO_VERSION,
						pInNicInfo->Hdr.Version
						);
			break;
		}

		//
		// Struct-copy the old to the new. It's wasteful, but we don't want
		// to dig into how much of the in buffer contains valid data.
		//
		*pOutNicInfo = *pInNicInfo;

		//
		// Rest is op-specific
		//
		switch(pOutNicInfo->Hdr.Op)
		{

		case NIC1394_NICINFO_OP_BUSINFO:
			Ret = nicFillBusInfo(&pOutNicInfo->BusInfo);
			break;

		case NIC1394_NICINFO_OP_REMOTENODEINFO:
			Ret = nicFillRemoteNodeInfo(&pOutNicInfo->RemoteNodeInfo);
			break;

		case NIC1394_NICINFO_OP_CHANNELINFO:
			Ret = nicFillChannelInfo(&pOutNicInfo->ChannelInfo);
			break;

		case NIC1394_NICINFO_OP_RESETSTATS:
			printf("DummyIoctl: RESETTING NIC STATS!\n");
			Ret = TRUE;
			break;

		default:
			printf( "DummyIoctl:  NICINFO.Op (%lu) is unknown.\n",
						pInNicInfo->Hdr.Op
						);
			break;
		}

	} while (FALSE);

	return Ret;
}


NIC1394_LOCAL_NODE_INFO
BogusLocalNodeInfo =
{
	456,	//UniqueID
	457,	//BusGeneration
	4,		//NodeAddress
	0,		//Reserved
	2,		//MaxRecvBlockSize
	3,		//MaxRecvSpeed
};

NIC1394_PACKET_STATS
BogusPktStats = 
{
	345,	// TotNdisPackets
	346,	// NdisPacketsFailures
	347,	// TotBusPackets
	348	// BusPacketFailures
};

BOOL
nicFillBusInfo(
	IN	OUT	PNIC1394_BUSINFO pBi
	)
{
	//
	// Fill with Dummy data
	//
	pBi->NumBusResets = 1234;
	pBi->SecondsSinceBusReset = 1235;
	pBi->Flags =  NIC1394_BUSINFO_LOCAL_IS_IRM;
	pBi->NumOutstandingIrps = 1236;

	pBi->LocalNodeInfo = BogusLocalNodeInfo;

	//
	// CHANNEL RELATED INFORMATION
	//
	pBi->Channel.BusMap = 0x123;
	pBi->Channel.ActiveChannelMap = 0x456;

	pBi->Channel.Bcr = 0x790;
	pBi->Channel.BcSendPktStats = BogusPktStats;
	pBi->Channel.BcRecvPktStats = BogusPktStats;
	
	pBi->Channel.SendPktStats = BogusPktStats;
	pBi->Channel.RecvPktStats = BogusPktStats;	

	//
	// FIFO RELATED INFORMATION.
	//
	pBi->Fifo.Recv_Off_Low = 0x1bc;
	pBi->Fifo.Recv_Off_High = 0xdef;

	pBi->Fifo.RecvPktStats = BogusPktStats;
	pBi->Fifo.SendPktStats = BogusPktStats;

	pBi->Fifo.NumFreeRecvBuffers  = 33;
	pBi->Fifo.MinFreeRecvBuffers  = 34;

	pBi->Fifo.NumOutstandingReassemblies = 8;
	pBi->Fifo.MaxOutstandingReassemblies = 9;

	strcpy(pBi->Private.FormatA, "    0x%08lx Gadzooks\n");
	pBi->Private.A0 = 0x99;
	//
	// Information about remote nodes. More information about each of these nodes
	// may be queried using *OP_REMOTE_NODEINFO
	//
	pBi->NumRemoteNodes = 1;
	pBi->RemoteNodeUniqueIDS[0] = 0x1234;
	
	return TRUE;
}

BOOL
nicFillChannelInfo(
	IN OUT	PNIC1394_CHANNELINFO pCi
	)
{
	return TRUE;
}

BOOL
nicFillRemoteNodeInfo(
	IN OUT	PNIC1394_REMOTENODEINFO pRni
	)
{
	pRni->UniqueID = 0xabc;
	pRni->NodeAddress = 2;
	pRni->EffectiveMaxBlockSize = 3;
	pRni->MaxRec = 4;
	pRni->MaxSpeedBetweenNodes = 5;
	pRni->Flags = NIC1394_REMOTEINFO_ACTIVE;

	pRni->SendFifoPktStats = BogusPktStats;
	pRni->RecvFifoPktStats = BogusPktStats;
	pRni->RecvChannelPktStats = BogusPktStats;

	return TRUE;
}



BOOL
DummyDeviceIoControl(
	HANDLE		DeviceHandle,
	UINT		Ioctl,
  	PARP1394_IOCTL_COMMAND pInCmd,
  	UINT		Size,
  	PARP1394_IOCTL_COMMAND pOutCmd,
  	UINT		OutSize,
  	PUINT		pBytesReturned,
  	PVOID		Blah
  	)
{
	BOOL fRet = FALSE;

	if (Ioctl !=  ARP_IOCTL_CLIENT_OPERATION) return FALSE;


	switch(pInCmd->Hdr.Op)
	{

	default:
	printf ("UNKNOWN IOCTL!\n");
	fRet = TRUE;
	break;

	case  ARP1394_IOCTL_OP_RESET_STATS:
	printf ("RESET ARP STATS!\n");
	break;

	case ARP1394_IOCTL_OP_RECV_PACKET:
	printf ("DUMMY IOCTL: Prrocessing ioctl RECV packet.\n");
	fRet = TRUE;
	break;

	case ARP1394_IOCTL_OP_GET_NICINFO:
	{
		fRet =  nicFillNicInfo (
					&pInCmd->IoctlNicInfo.Info,
					&pOutCmd->IoctlNicInfo.Info
					);
	}
	break;

	}

	return fRet;
}
#endif // DUMMY

VOID
DumpNicInfo(
	ARP1394_IOCTL_NICINFO *pINi
	)
{
	PNIC1394_NICINFO pNi =  &pINi->Info;
	unsigned char *pc = (PUCHAR)&pINi->Hdr.IfIpAddress;

	do
	{
		//
		// First check internal version
		//
		if (pNi->Hdr.Version != NIC1394_NICINFO_VERSION)
		{
			printf("  NICINFO.Version mismatch. Want %lu got %lu\n",
						NIC1394_NICINFO_VERSION,
						pNi->Hdr.Version
						);
			break;
		}

		//
		// Rest is op-specific
		//
		switch(pNi->Hdr.Op)
		{

		case NIC1394_NICINFO_OP_BUSINFO:
			printf("\nUnexpected commande!\n"); // We handle this command earlier.
			break;

		case NIC1394_NICINFO_OP_REMOTENODEINFO:
			printf("\nNode information for node %lu on IF %d.%d.%d.%d\n\n",
					pNi->RemoteNodeInfo.NodeAddress,
					pc[0], pc[1], pc[2], pc[3]);
			DumpRemoteNodeInfo(&pNi->RemoteNodeInfo);
			break;

		case NIC1394_NICINFO_OP_CHANNELINFO:
			printf("\nChannel information for channel %lu on IF %d.%d.%d.%d\n\n",
					pNi->ChannelInfo.Channel,
					pc[0], pc[1], pc[2], pc[3]);
			DumpChannelInfo(&pNi->ChannelInfo);
			break;

		case NIC1394_NICINFO_OP_RESETSTATS:
			printf("\nReset NIC stats for IF %d.%d.%d.%d\n\n",
					pc[0], pc[1], pc[2], pc[3]);
			break;

		default:
			printf( "  NICINFO.Op (%lu) is unknown.\n",
						pNi->Hdr.Op
						);
			break;
		}

	} while (FALSE);

}


#if OBSOLETE
VOID
DumpBusInfo(
    PNIC1394_BUSINFO pBi
    )
{
	PUCHAR pc;

	printf(
"   Generation: %02lu; Bus resets: %02lu; Last reset: %lu seconds ago.",
		pBi->LocalNodeInfo.BusGeneration,
		pBi->NumBusResets,
		pBi->SecondsSinceBusReset
		);

	printf(
"   Outstanding IRPs: %02lu;",
		pBi->NumOutstandingIrps
		);
	//
	// Flags
	//
	if (pBi->Flags & NIC1394_BUSINFO_LOCAL_IS_IRM)
	{
		printf(
"  Flags: IRM\n"
			);
	}
	else
	{
		printf(
"  Flags: <none>\n"
			);
	}

	//
	// CHANNEL INFO
	//
	printf("\n   Channel information:\n");

    	printf ("           Channels in bus map:");
	arpDumpChannelMap( pBi->Channel.BusMap);
	printf ("       Locally active channels:");
	arpDumpChannelMap( pBi->Channel.ActiveChannelMap);


	printf(
"       BCR: 0x%08lx\n", 
		pBi->Channel.Bcr
		);
		
	arpDumpPktStats("        BC Sends:", &pBi->Channel.BcSendPktStats);
	arpDumpPktStats("        BC Recvs:", &pBi->Channel.BcRecvPktStats);

	//
	// RECV FIFO
	//
	printf("\n   Recv FIFO information:\n");
	printf(
		"        Addr: 0x%lx:0x%lx; Free recv bufs:%lu (%lu max)\n",
		pBi->Fifo.Recv_Off_High,
		pBi->Fifo.Recv_Off_Low,
		pBi->Fifo.NumFreeRecvBuffers,
		pBi->Fifo.MinFreeRecvBuffers
		);
	printf(
		"        Recv reassemblies: %lu outstanding; %lu max outstanding; %lu aborted\n",
		pBi->Fifo.NumOutstandingReassemblies,
		pBi->Fifo.MaxOutstandingReassemblies,
		pBi->Fifo.NumAbortedReassemblies
		);
	
	//
	// Private information
	//
	if (*pBi->Private.FormatA || *pBi->Private.FormatB)
	{
		printf("\n   Private information:\n");

		if  (*pBi->Private.FormatA)
		{
			printf(
				pBi->Private.FormatA,
				pBi->Private.A0,
				pBi->Private.A1,
				pBi->Private.A2,
				pBi->Private.A3
				);
		}

		if  (*pBi->Private.FormatB)
		{
			printf(
				pBi->Private.FormatB,
				pBi->Private.B0,
				pBi->Private.B1,
				pBi->Private.B2,
				pBi->Private.B3
				);
		}
	}

	{

		UINT64 *pUID;
		PNIC1394_LOCAL_NODE_INFO pLi;

		UINT u = pBi->NumRemoteNodes;
		 
		printf("\n   Node Information:\n");
		
			printf(
"     GUID                    Node Size Speed SpeedTo State\n"
				);

		pLi = &pBi->LocalNodeInfo;
		printf("    *");
		Dump1394UniqueID(pLi->UniqueID);
		printf(
			"  %02lx   %02lx   %02lx           %s\n",
			pLi->NodeAddress,
			pLi->MaxRecvBlockSize,
			pLi->MaxRecvSpeed,
			"local"
			);

		pUID = pBi->RemoteNodeUniqueIDS;
		for (; u; u--, pUID++) // pRi++
		{
#if 0
		    ARP1394_IOCTL_REMOTE_NODE_INFO Ri;
		    PARP1394_IOCTL_REMOTE_NODE_INFO pRi = NULL;
			char *szState = "unknown";

			printf("     ");
			Dump1394UniqueID(*pUID);
            
            if (GetRemoteNodeInfo(
            
            if (pRi!=NULL)
            {

                if (pRi->Flags & ARP1394_IOCTL_REMOTEFLAGS_ACTIVE)
                {
                    szState = "active";
                }
                if (pRi->Flags & ARP1394_IOCTL_REMOTEFLAGS_LOADING)
                {
                    szState = "loading";
                }
                if (pRi->Flags & ARP1394_IOCTL_REMOTEFLAGS_UNLOADING)
                {
                    szState = "unloading";
                }
                printf(
                    "  %02lx   %02lx   %02lx    %02lx     %s\n",
                    pRi->NodeAddress,
                    pRi->MaxRecvBlockSize,
                    pRi->MaxRecvSpeed,
                    pRi->MaxSpeedBetweenNodes,
                    szState
                    );
            }
			printf("\n");
#endif // 0
		}
	}

}
#endif // OBSOLETE

VOID
DumpChannelInfo(
    PNIC1394_CHANNELINFO pCi
    )
{
	printf("DUMP OF CHANNELINFO\n");
}

VOID
DumpRemoteNodeInfo(
    PNIC1394_REMOTENODEINFO pRni
    )
{
	printf("DUMP OF REMOTENODEINFO\n");
}


VOID
arpDumpChannelMap(
		UINT64 Map
		)
{
	UINT ChannelMapLow = (UINT) (Map & 0xffffffff);
	UINT ChannelMapHigh = (UINT) (Map >> 32);


	if (ChannelMapLow==0 && ChannelMapHigh==0)
	{
		printf (" <none>\n");
	}
	else
	{
		UINT c;
		#define Bit(_Val, _Bit) (((_Val) & (1<<_Bit))!=0)

		for (c=0;c<32;c++)
		{
			if (Bit(ChannelMapLow, c))
			{
				printf (" %lu", c);
			}
		}
		for (c=0;c<32;c++)
		{
			if (Bit(ChannelMapHigh, c))
			{
				printf (" %lu", c+32);
			}
		}
		printf ("\n");
	}
}

VOID
arpDumpPktStats(
		char *szPrefix,
		NIC1394_PACKET_STATS *pPs
		)
{
	printf("%s ndis: %06lu total, %05lu failed; bus: %06lu total, %05lu failed\n",
		szPrefix,
		pPs->TotNdisPackets,
		pPs->NdisPacketsFailures,
		pPs->TotBusPackets,
		pPs->BusPacketFailures
		);
}

VOID
DoBusInfoCmd(
    HANDLE DeviceHandle,
  	PARP1394_IOCTL_COMMAND pCmd
  	)
{
    PNIC1394_NICINFO pNi = &pCmd->IoctlNicInfo.Info;
    PNIC1394_BUSINFO pBi = &pNi->BusInfo;
	unsigned char *pc = (PUCHAR)&pCmd->Hdr.IfIpAddress;
    BOOL fRet;
	DWORD 	BytesReturned;

    if (pCmd->Hdr.Op != ARP1394_IOCTL_OP_GET_NICINFO
        || pNi->Hdr.Op !=  NIC1394_NICINFO_OP_BUSINFO)
    {
        printf("DoBusInfoCmd: unexpected pCmd!\n");
        return;
    }


    // Submit NICINFO.BUSINFO Ioctl
    //
    fRet =	DeviceIoControl(
                    DeviceHandle,
                    ARP_IOCTL_CLIENT_OPERATION,
                    pCmd,
                    sizeof(*pCmd),
                    pCmd,
                    sizeof(*pCmd),
                    &BytesReturned,
                    NULL
                    );

    //  
    //
    if (!fRet)
    {
        printf("Request failed with error code 0x%08lx\n", GetLastError());
        return;
    }


	printf(
"   Generation: %02lu; Bus resets: %02lu; Last reset: %lu seconds ago.",
		pBi->LocalNodeInfo.BusGeneration,
		pBi->NumBusResets,
		pBi->SecondsSinceBusReset
		);

#if 0
	printf(
"   Outstanding IRPs: %02lu;",
		pBi->NumOutstandingIrps
		);
#endif // 0

	//
	// Flags
	//
	if (pBi->Flags & NIC1394_BUSINFO_LOCAL_IS_IRM)
	{
		printf(
"  Flags: IRM\n"
			);
	}
	else
	{
		printf(
"  Flags: <none>\n"
			);
	}

	//
	// CHANNEL INFO
	//
	printf("\n   Channel information:\n");

	printf ("           Channels in bus map:");
	arpDumpChannelMap(pBi->Channel.BusMap);
    	printf ("       Locally active channels:");
	arpDumpChannelMap( pBi->Channel.ActiveChannelMap);


	printf(
"       BCR: 0x%08lx\n", 
		pBi->Channel.Bcr
		);
		
	arpDumpPktStats("        BC Sends:", &pBi->Channel.BcSendPktStats);
	arpDumpPktStats("        BC Recvs:", &pBi->Channel.BcRecvPktStats);

	//
	// RECV FIFO
	//
	printf("\n   FIFO information:\n");
	printf(
		"        Addr: 0x%lx:0x%lx; Free recv bufs:%lu (%lu max)\n",
		pBi->Fifo.Recv_Off_High,
		pBi->Fifo.Recv_Off_Low,
		pBi->Fifo.NumFreeRecvBuffers,
		pBi->Fifo.MinFreeRecvBuffers
		);
	printf(
		"        Recv reassemblies: %lu outstanding; %lu max outstanding; %lu aborted\n",
		pBi->Fifo.NumOutstandingReassemblies,
		pBi->Fifo.MaxOutstandingReassemblies,
		pBi->Fifo.NumAbortedReassemblies
		);
	
	arpDumpPktStats("        FIFO Sends:", &pBi->Fifo.SendPktStats);
	arpDumpPktStats("        FIFO Recvs:", &pBi->Fifo.RecvPktStats);

	//
	// Private information
	//
	if (*pBi->Private.FormatA || *pBi->Private.FormatB)
	{
		printf("\n   Private information:\n");

		if  (*pBi->Private.FormatA)
		{
			printf(
				pBi->Private.FormatA,
				pBi->Private.A0,
				pBi->Private.A1,
				pBi->Private.A2,
				pBi->Private.A3
				);
		}

		if  (*pBi->Private.FormatB)
		{
			printf(
				pBi->Private.FormatB,
				pBi->Private.B0,
				pBi->Private.B1,
				pBi->Private.B2,
				pBi->Private.B3
				);
		}
	}

	{

		UINT64 *pUID;
		PNIC1394_LOCAL_NODE_INFO pLi;

		UINT u = pBi->NumRemoteNodes;
		 
		printf("\n   Node Information:\n");
		
			printf(
"     GUID                    Node Maxrec SpeedTo State\n"
				);

		pLi = &pBi->LocalNodeInfo;
		printf("    *");
		Dump1394UniqueID(pLi->UniqueID);
		printf(
			"  %02lx    %02lx   %02lx     %s\n",
			pLi->NodeAddress,
			pLi->MaxRecvBlockSize,
			pLi->MaxRecvSpeed,
			"local"
			);

		pUID = pBi->RemoteNodeUniqueIDS;
		for (; u; u--, pUID++) // pRi++
		{
			char *szState = "unknown";

			printf("     ");
			Dump1394UniqueID(*pUID);
            
            {
                ARP1394_IOCTL_COMMAND Cmd = *pCmd;
                PNIC1394_NICINFO	pNi2 = &Cmd.IoctlNicInfo.Info;
                Cmd.Hdr.Op 		= ARP1394_IOCTL_OP_GET_NICINFO;
                pNi2->Hdr.Version 	= NIC1394_NICINFO_VERSION;
                pNi2->Hdr.Op 		=  NIC1394_NICINFO_OP_REMOTENODEINFO;
                pNi2->RemoteNodeInfo.UniqueID = *pUID;
                pNi2->RemoteNodeInfo.NodeAddress = 0;
    
                // Submit Ioctl
                //
                fRet =	DeviceIoControl(
                                DeviceHandle,
                                ARP_IOCTL_CLIENT_OPERATION,
                                &Cmd,
                                sizeof(Cmd),
                                &Cmd,
                                sizeof(Cmd),
                                &BytesReturned,
                                NULL
                                );
                if (fRet == FALSE)
                {
                    printf ("  <error reading node info>\n");
                }
                else
                {
                    PNIC1394_REMOTENODEINFO pRi =  &pNi2->RemoteNodeInfo;

                    if (pRi->Flags &  NIC1394_REMOTEINFO_ACTIVE)
                    {
                        szState = "active";
                    }
                    if (pRi->Flags &  NIC1394_REMOTEINFO_LOADING)
                    {
                        szState = "loading";
                    }
                    if (pRi->Flags &  NIC1394_REMOTEINFO_UNLOADING)
                    {
                        szState = "unloading";
                    }
                    printf(
			            "  %02lx    %02lx   %02lx     %s\n",
                        pRi->NodeAddress,
                        pRi->MaxRec,
                        pRi->MaxSpeedBetweenNodes,
                        szState
                        );
                }
		    }
		}
    }
}


VOID
DumpEuidMapInfo(
	PARP1394_IOCTL_EUID_NODE_MAC_INFO pEuidInfo
	)
{
	PEUID_TOPOLOGY pMap = &pEuidInfo->Map;
	UINT i =0;

	printf ("Number of Remote Nodes = %x\n",pMap->NumberOfRemoteNodes);

	if (pMap->NumberOfRemoteNodes ==0)
	{
		return;
	}
	printf ("Table :-\n");
		
	// iterate through the number of remote nodes and print them out.
	printf ("Node    UniqueId                  MacAddress\n");

	while (i<pMap->NumberOfRemoteNodes)
	{
		// Skip this node if it is an invalid node
		if (pMap->Node[i].Euid ==0)
		{
			continue;
		}

		printf ("%x       ",i);
		Dump1394UniqueID(pMap->Node[i].Euid);
		printf("   ");
		DumpENetAddress (pMap->Node[i].ENetAddress);
		printf("\n");
		i++;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\send.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// send.h
//
// IEEE1394 mini-port/call-manager driver
//
// Send.h - Mini-port Send routines
//
// 06/20/1999 ADube Created, 
//



NDIS_STATUS
AsyncStreamSendPacketsHandler (
    IN PVCCB pChannelVc,
    IN PNDIS_PACKET pPacket 
    );


NDIS_STATUS
AsyncWriteSendPacketsHandler(
    IN VCCB *pVC,
    IN NDIS_PACKET *Packet 
    );


NDIS_STATUS
nicCopyNdisBufferChainToBuffer(
    IN     PNDIS_BUFFER pInMdl,
    IN OUT PVOID        pLocalBuffer, 
    IN     UINT         Length 
    );


VOID
nicFreeIrb(
    IN PIRB pIrb 
    );


VOID
nicFreeIrp(
    IN PIRP pIrp 
    );


VOID
nicFreeLocalBuffer(
    IN UINT Length,
    IN PVOID pLocalBuffer 
    );


NDIS_STATUS
nicGetIrb(
    OUT PIRB *ppIrb 
    );


NDIS_STATUS
nicGetIrp(
    IN  PDEVICE_OBJECT pPdo,
    OUT PIRP *ppIrp 
    );


VOID
nicFreeMdl( 
    IN  PMDL pMdl 
    );


NDIS_STATUS
nicGetLocalBuffer(
    IN  ULONG Length,
    OUT PVOID *ppLocalBuffer 
    );

PVOID
nicGetLookasideBuffer(
    IN  PNIC_NPAGED_LOOKASIDE_LIST pLookasideList
    );


NDIS_STATUS
nicGetMdl(
    IN UINT     Length,
    IN PVOID    LocalBuffer,
    OUT PMDL    *ppMyMdl
    );


NDIS_STATUS
nicGetMdlToTransmit(
    IN PNDIS_PACKET     pPacket, 
    OUT PMDL            *ppMyMdl 
    );


NDIS_STATUS
DummySendPacketsHandler(
    IN PVCCB        pVc,
    IN PNDIS_PACKET  pPacket 
    );

VOID
nicSendFailureInvalidGeneration(
    PVCCB pVc
    );
    

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------


NTSTATUS
AsyncStreamDummySendComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pMyIrp,
    IN PVOID           Context   
    );
    

NTSTATUS
AsyncWriteStreamSendComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pMyIrp,
    IN PVOID           Context   
    );


NTSTATUS
AsyncStreamSendComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pMyIrp,
    IN PVOID            Context 
    );


NDIS_STATUS
nicFreeAsyncWritePacketDataStructures(
    IN PVCCB pVc,
    IN PIRP  pIrp               OPTIONAL,
    IN PVOID pLocalBuffer       OPTIONAL,
    IN PNIC_NPAGED_LOOKASIDE_LIST   pLookasideList   OPTIONAL
  );


NDIS_STATUS
nicEthernetVcSend(
    IN PVCCB        pVc,
    IN PNDIS_PACKET  pPacket 
    );





VOID
nicInitAsyncStreamIrb(
    IN     PCHANNEL_VCCB pChannelVc, 
    IN     PMDL pMdl, 
    IN OUT PIRB pIrb
    );


VOID
nicInitAsyncWriteIrb(
    IN     PSENDFIFO_VCCB pVc, 
    IN     PMDL pMyMdl, 
    IN OUT PIRB pMyIrb
    );




NDIS_STATUS
nicInsertGaspHeader (
    IN PADAPTERCB pAdapter,
    IN PNDIS_PACKET pNdisPacket
    );


NDIS_STATUS
nicGetGaspHeader (
    IN OUT PNDIS_BUFFER *ppNdisBuffer
    );



VOID
nicFreeGaspHeader (
    IN PNDIS_BUFFER pGaspNdisBuffer
    );

VOID
nicFreeToNPagedLookasideList (
    IN PNIC_NPAGED_LOOKASIDE_LIST pLookasideList,
    IN PVOID    pBuffer
    );
    
VOID
nicMakeGaspHeader (
    IN PADAPTERCB pAdapter,
    IN PGASP_HEADER pGaspHeader
    );

NDIS_STATUS
nicCopyOneFragment (
    PFRAGMENTATION_STRUCTURE pFragment
    );

VOID
nicCopyUnfragmentedHeader ( 
    IN PNIC1394_UNFRAGMENTED_HEADER pDestUnfragmentedHeader,
    IN PVOID pSrcUnfragmentedHeader
    );
    




NDIS_STATUS
nicFirstFragmentInitialization (
    IN PNDIS_BUFFER pStartNdisBuffer,
    IN ULONG DatagramLabelLong,
    OUT PFRAGMENTATION_STRUCTURE  pFragment          
    );


VOID
nicInitializeLookasideListHeader (
    IN OUT PLOOKASIDE_BUFFER_HEADER pHeader,
    IN PNDIS_PACKET pNdisPacket,
    IN PVCCB pVc,
    IN PNDIS_BUFFER pCurrNdisBuffer,
    IN BUS_OPERATION AsyncOp,
    IN PADAPTERCB pAdapter
    );
    

NDIS_STATUS
nicCopyNdisPacketToUnfragmentedBuffer(
    IN PNIC_NPAGED_LOOKASIDE_LIST  pLookasideList,
    IN PNDIS_BUFFER pStartNdisBuffer,
    IN ULONG PacketLength,
    IN BUS_OPERATION AsyncOp,
    IN PGASP_HEADER pGaspHeader,
    OUT PVOID*  ppStartFragmentAddress,
    OUT PVOID *ppLookasideListBuffer
    );

    

VOID
nicAddFragmentHeader (
    IN PVOID pStartFragmentData, 
    IN PFRAGMENTATION_STRUCTURE pFragmentStructure,
    IN ULONG BufferSize
    );




NDIS_STATUS
nicFreeAsyncStreamPacketDataStructures(
    IN PVCCB pVc,
    IN PIRP  pIrp               OPTIONAL,
    IN PVOID pLocalBuffer       OPTIONAL,
    IN PNIC_NPAGED_LOOKASIDE_LIST   pLookasideList   OPTIONAL
  );


VOID
nicGetGenerationWorkItem(
    NDIS_WORK_ITEM* pGetGenerationWorkItem,
    IN PVOID Context 
    );

VOID
nicMpCoSendComplete (
    NDIS_STATUS NdisStatus,
    PVCCB pVc,
    PNDIS_PACKET pPacket
    );



VOID
nicSendTimer (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );



UINT
nicNumFragmentsNeeded (
    UINT PacketLength ,
    UINT MaxPayload,
    UINT FragmentOverhead
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\nic\sys\send.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// send.c
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port Send routines
//
// 12/28/1998 ADube Created,
//
    
//
//  A Send follows this simple algorithm:
//  Copy incoming data to local buffers
//  Create an Mdl for the local copy
//  Store the IRB and VC in the ndispacket
//  Use the ndispacket as context in the irp's completion routine
//  

#include <precomp.h>

//-----------------------------------------------------------------------------
// Global counts
//-----------------------------------------------------------------------------
extern UINT BusSendCompletes;
extern UINT NicSendCompletes;
extern UINT BusSends;
extern ULONG MdlsAllocated[NoMoreCodePaths];
extern ULONG MdlsFreed[NoMoreCodePaths];

//-----------------------------------------------------------------------------
// prototypes implementations (alphabetically)
//-----------------------------------------------------------------------------

NDIS_STATUS
nicCopyNdisBufferChainToBuffer(
    IN PNDIS_BUFFER pInBuffer,
    IN OUT PVOID pLocalBuffer,
    IN UINT BufferLength )
{


    //
    //  This function copies the data the belongs to the 
    //  pInMdl chain to the local Buffer. 
    //  BufferLength is used for validation purposes only
    //  Fragmentation and insertion of headers will take place here
    //


    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    UINT LocalBufferIndex = 0;      // Used as an index to the LocalBuffer, used for validation
    UINT MdlLength = 0;             
    PVOID MdlAddress = 0;
    PNDIS_BUFFER pCurrBuffer;

    TRACE( TL_T, TM_Send, ( "==>nicCopyNdisBufferChainToBuffer pNdisbuffer %x, Buffer %x, Length %x",
                           pInBuffer, pLocalBuffer,BufferLength ) );

    ASSERT (pLocalBuffer != NULL);

    pCurrBuffer = pInBuffer;
    
    do
    {

        MdlLength = nicNdisBufferLength(pCurrBuffer);
        MdlAddress= nicNdisBufferVirtualAddress(pCurrBuffer);

        if (MdlLength != 0)
        {
            if (MdlAddress == NULL)
            {
                NdisStatus = NDIS_STATUS_FAILURE;
                TRACE (TL_A, TM_Send, ("Ndis Buffer at %x", pCurrBuffer) );
                BREAK (TM_Send, ("   nicCopyNdisBufferChainToBuffer: Mdl Address = NULL") );

            }

            if ( LocalBufferIndex + MdlLength > BufferLength)
            {

                ASSERT(LocalBufferIndex + MdlLength <= BufferLength);

                NdisStatus = NDIS_STATUS_BUFFER_TOO_SHORT;

                BREAK (TM_Send, ("nicCopyNdisBufferChainToBuffer Copy Failed" ) );
            }

            //
            //  Copy the Data to local memory.
            //


            NdisMoveMemory((PVOID)((ULONG_PTR)pLocalBuffer+LocalBufferIndex),
                        MdlAddress,
                        MdlLength);

            LocalBufferIndex += MdlLength;
        }

        pCurrBuffer = pCurrBuffer->Next;

    } while (pCurrBuffer!= NULL);

    TRACE( TL_T, TM_Send, ( "<==nicCopyNdisBufferChainToBuffer %x",NdisStatus ) );

    return NdisStatus;

}


VOID
nicFreeIrb(PIRB pIrb)
    //
    //  Frees the Memory occcupied by the Irb
    //

{    
    ASSERT(pIrb != NULL);

    TRACE( TL_T, TM_Irp, ( "==>nicFreeIrb %x", pIrb ) );

    if (pIrb != NULL)
    {
        FREE_NONPAGED(pIrb); 
    }
    
    TRACE( TL_T, TM_Irp, ( "<==nicFreeIrb") );
    
    return;


}


VOID
nicFreeIrp(PIRP pIrp)

    //
    //  Frees the memory occupied by the  Irp
    //


{
    ASSERT(pIrp != NULL);   

    TRACE( TL_T, TM_Irp, ( "==>nicFreeIrp at %x",pIrp ) );

    if (pIrp != NULL)
    {
        IoFreeIrp(pIrp);
    }
    
    TRACE( TL_T, TM_Irp, ( "<==nicFreeIrp") );


    return;


}



VOID
nicFreeLocalBuffer (
    IN UINT Length,
    IN PVOID Address )
    //
    //  Free the Memory pointed to by Address.
    //  The Length parameter is superfluous and will be removed
    //  once I am sure we don;t need it
    //
{
    

    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;

    ASSERT(Address != NULL);

    TRACE( TL_T, TM_Send, ( "==>nicFreeLocalBuffer , Address %x", Address) );

    if (Address != NULL)
    {
        FREE_NONPAGED((PVOID)Address);
    }
    
    TRACE( TL_T, TM_Send, ( "<==niFreeLocalBuffer, NdisStatus %x",NdisStatus ) );
    

    return;

}


VOID
nicFreeMdl(PMDL pMdl)
    //
    //  This frees the memory belonging to the Mdl. Does not free the  
    //  memory that the Mdl Points to
    //

{

    ASSERT (pMdl != NULL)
    
    TRACE( TL_T, TM_Send, ( "==> nicFreeMdl pMdl %x", pMdl ) );
    
    if (pMdl != NULL)
    {
        IoFreeMdl(pMdl);
    }
    
    TRACE( TL_T, TM_Send, ( "<== nicFreeMdl") );

    return ;
}

VOID
nicFreeToNPagedLookasideList (
    IN PNIC_NPAGED_LOOKASIDE_LIST pLookasideList,
    IN PVOID    pBuffer
    )

    // Function Description:
    //   Return the local buffer to the lookaside list
    //
    // Atguments
    // Lookaside list and its buffer
    // Return Value:
    // None 
{

    
    TRACE( TL_T, TM_Send, ( "==> nicFreeToNPagedLookasideList , Lookaside list %x, plocalbuffer %x",pLookasideList, pBuffer ) );

    NdisFreeToNPagedLookasideList (&pLookasideList->List, pBuffer);     
    NdisInterlockedDecrement (&pLookasideList->OutstandingPackets);

    TRACE( TL_T, TM_Send, ( "<== nicFreeToNPagedLookasideList ") );


}



NDIS_STATUS
nicGetIrb(
    OUT     PIRB *ppIrb )


    //
    // This function is to be used in retrieving a free IRB.
    // that will be supplied as an argument for an IRP
    //
    //  Initially, this will simple allocate an IRB 
    //  Intiailization could be added here
    //
    
{

    NDIS_STATUS NdisStatus;

    
    TRACE( TL_T, TM_Irp, ( "==>nicGetIrb" ) );
    
    *ppIrb = (PIRB)ALLOC_NONPAGED ( sizeof(IRB), MTAG_HBUFPOOL );

    if (*ppIrb != NULL)
    {   
        NdisZeroMemory ( *ppIrb, sizeof(IRB) );
        NdisStatus = NDIS_STATUS_SUCCESS;
        TRACE( TL_V, TM_Send, ( "   nicGetIrb: Irb allocated at %x", *ppIrb ) );

    }
    else
    {
        nicIncrementMallocFailure();
        NdisStatus = NDIS_STATUS_FAILURE;
    }
    
    TRACE( TL_T, TM_Irp, ( "<==nicGetIrb NdisStatus %x",NdisStatus ) );
    
    return NdisStatus;
}


NDIS_STATUS
nicGetIrp(
    IN  PDEVICE_OBJECT pPdo,
    OUT PIRP *ppIrp 
    )


    //
    // This function returns am irp to the calling routine
    // The irp is free and is owned by the nic1394. 
    // NEED TO CHANGE THE STACK SIZE
    //
{

    NDIS_STATUS NdisStatus;
    PIRP  pIrp;
    CCHAR StackSize =0; 

    ASSERT (pPdo != NULL);
    
    TRACE( TL_T, TM_Irp, ( "==>nicGetIrp Pdo %x", pPdo ) );

    if (pPdo == NULL)
    {
        ASSERT (pPdo != NULL);      
        NdisStatus = NDIS_STATUS_FAILURE;
        *ppIrp = NULL;
        return NdisStatus;
    }


    //
    //  Allocate the Irp with the correct stacksize
    //
    StackSize = pPdo->StackSize+1;

    pIrp = IoAllocateIrp (StackSize, FALSE);

    do
    {
    
        if (pIrp == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        TRACE( TL_V, TM_Send, ( "  Irp allocated at %x, Stacksize %x",pIrp , StackSize ) );

        *ppIrp = pIrp;
    
        //
        // Initialize the Irp
        //

        IoInitializeIrp ( *ppIrp, sizeof(IRP), StackSize );

        if (*ppIrp != NULL)
        {
            NdisStatus = NDIS_STATUS_SUCCESS;
        }
        else
        {
            nicIncrementMallocFailure();
            NdisStatus = NDIS_STATUS_FAILURE;
        }
    
    } while (FALSE);

    TRACE( TL_T, TM_Irp, ( "<==nicGetIrp ,irp %x",*ppIrp  ) );
    
    return NdisStatus;
}



NDIS_STATUS
nicGetLocalBuffer(
    OPTIONAL IN  ULONG Length,
    OUT PVOID *ppLocalBuffer 
    )

    //
    //  This function allocates memory of size 'Length' and returns 
    //  a pointer to this memory 
    //
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;

    TRACE( TL_T, TM_Send, ( "==>nicGetLocalBuffer  Length %x",  Length ) );
    
    //
    // There is a bug in the Nic if this is zero
    // 
    ASSERT (Length != 0 );


    //
    // There is no lookaside list, We need to allocate memory
    //
    *ppLocalBuffer = ALLOC_NONPAGED (Length, MTAG_FBUFPOOL);
        

    if (*ppLocalBuffer != NULL)
    {
        NdisStatus = NDIS_STATUS_SUCCESS;   
    }
    else
    {
        nicIncrementMallocFailure();
        NdisStatus = NDIS_STATUS_FAILURE;
    }

    
    TRACE( TL_T, TM_Send, ( "<==nicGetLocalBuffer, NdisStatus %x at %x",NdisStatus,*ppLocalBuffer ) );
    
    return NdisStatus;

}





PVOID
nicGetLookasideBuffer(
    IN  PNIC_NPAGED_LOOKASIDE_LIST pLookasideList
    )
    // Function Description:
    //    Allocate an buffer from the lookaside list.
    //    will be changed to a macro
    //
    //
    //
    // Arguments
    //  Lookaside list - from which the buffer is allocated
    //
    //
    // Return Value:
    //  Return buffer can be NULL
    //
{

    PVOID pLocalBuffer = NULL;
    
    TRACE( TL_T, TM_Send, ( "==>nicGetLookasideBuffer pLookasideList %x", pLookasideList) );
    
    ASSERT (pLookasideList != NULL);

    //
    // Optimize the lookaside list code path
    //
    pLocalBuffer = NdisAllocateFromNPagedLookasideList (&pLookasideList->List);

    if (pLocalBuffer != NULL)
    {   
        NdisZeroMemory (pLocalBuffer, pLookasideList->Size); 
        NdisInterlockedIncrement (&pLookasideList->OutstandingPackets);
    }
    else
    {
        nicIncrementMallocFailure();
    }

        
    
    TRACE( TL_T, TM_Send, ( "<==nicGetLookasideBuffer, %x", pLocalBuffer ) );
    
    return pLocalBuffer ;

}



NDIS_STATUS
nicGetMdl(
    IN UINT Length,
    IN PVOID pLocalBuffer,
    OUT PMDL *ppMyMdl)


    //
    //  Return a locally owned Mdl to the caller.
    //  This will also initialize the MDl with the localbuffer
    //  Initial implementation will allocate mdls
    //  
{

    NDIS_STATUS NdisStatus;
    
    TRACE( TL_T, TM_Send, ( "==>nicGetMdl" ) );
    
    ASSERT(pLocalBuffer != NULL);

    //
    // Allocate an MDl to point to the structure
    //
    (*ppMyMdl) = IoAllocateMdl( pLocalBuffer,
                             Length,
                             FALSE,
                             FALSE,
                             NULL );
    
    //
    //  Initialize the data structures with correct values
    //

    if (*ppMyMdl != NULL)
    {
        MmBuildMdlForNonPagedPool(*ppMyMdl);

        (*ppMyMdl)->Next = NULL;
        
        NdisStatus = NDIS_STATUS_SUCCESS;
    }
    else
    {
        nicIncrementMallocFailure();
        NdisStatus =  NDIS_STATUS_FAILURE;
        *ppMyMdl = NULL;
    }
    
    
    
    TRACE( TL_T, TM_Send, ( "<==nicGetMdl, Mdl %x, LocalBuffer %x",
                                        *ppMyMdl, pLocalBuffer) );
    
    return NdisStatus;
}






VOID
nicInitAsyncStreamIrb(
    IN     PCHANNEL_VCCB pChannelVc, 
    IN     PMDL pMdl, 
    IN OUT PIRB pIrb
    )
    
    // This function initializes the Irb that will be used in the Irb
    // It specifically handles the AsyncStream IRB
    // It arguments are the Vc block (for destination address), 
    // Mdl (Memory desctiptor for the data and a pointer to the 
    // Irb structure that will be initialized 




{
    ASSERT (pMdl != NULL);
    ASSERT (pIrb != NULL);

    NdisZeroMemory (pIrb, sizeof (IRB) );
    pIrb->FunctionNumber = REQUEST_ASYNC_STREAM;
    pIrb->Flags = 0;
    pIrb->u.AsyncStream.nNumberOfBytesToStream = MmGetMdlByteCount(pMdl);
    pIrb->u.AsyncStream.fulFlags = 0;

    //
    // See comments for ISOCH_TAG 
    //
    pIrb->u.AsyncStream.ulTag = g_IsochTag; 
    pIrb->u.AsyncStream.nChannel = pChannelVc->Channel;
    pIrb->u.AsyncStream.ulSynch = pChannelVc->ulSynch;
    pIrb->u.AsyncStream.nSpeed = (INT)pChannelVc->Speed;
    pIrb->u.AsyncStream.Mdl = pMdl;
    
        
        
    TRACE( TL_V, TM_Send, ( "Number of Bytes to Stream %x ", pIrb->u.AsyncStream.nNumberOfBytesToStream  ) );
    TRACE( TL_V, TM_Send, ( "fulFlags %x ", pIrb->u.AsyncStream.fulFlags  ) );
    TRACE( TL_V, TM_Send, ( "ulTag %x ", pIrb->u.AsyncStream.ulTag ) );
    TRACE( TL_V, TM_Send, ( "Channel %x", pIrb->u.AsyncStream.nChannel  ) );
    TRACE( TL_V, TM_Send, ( "Synch %x", pIrb->u.AsyncStream.ulSynch  ) );
    TRACE( TL_V, TM_Send, ( "Speed %x", pIrb->u.AsyncStream.nSpeed  ) );
    TRACE( TL_V, TM_Send, ( "Mdl %x", pIrb->u.AsyncStream.Mdl ) );

}


VOID
nicInitAsyncWriteIrb(
    IN     PSENDFIFO_VCCB pSendFIFOVc, 
    IN     PMDL pMyMdl, 
    IN OUT PIRB pMyIrb
    )
    
    // This function initializes the Irb that will be used in the Irb
    // It specifically handles the AsyncWrite IRB
    // It arguments are the Vc block (for destination address), 
    // Mdl (Memory desctiptor for the data and a pointer to the 
    // Irb structure that will be initialized 




{

        //
        // Sanity check
        //
        ASSERT ((*(PULONG)pMyIrb) == 0)

        pMyIrb->u.AsyncWrite.nNumberOfBytesToWrite = MmGetMdlByteCount(pMyMdl);
        pMyIrb->u.AsyncWrite.nBlockSize = 0;
        pMyIrb->u.AsyncWrite.fulFlags = 0;
        pMyIrb->u.AsyncWrite.Mdl = pMyMdl;
    
        pMyIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
        pMyIrb->Flags = 0;
        pMyIrb->u.AsyncWrite.nSpeed = (UCHAR)pSendFIFOVc->MaxSendSpeed ;

        pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = pSendFIFOVc->FifoAddress.Off_High;
        pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low = pSendFIFOVc->FifoAddress.Off_Low;
        pMyIrb->u.AsyncWrite.ulGeneration = *pSendFIFOVc->Hdr.pGeneration;

    
        pMyIrb->u.AsyncWrite.nBlockSize = 0;
        pMyIrb->u.AsyncWrite.fulFlags = ASYNC_FLAGS_NONINCREMENTING;

        pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_ID.NA_Bus_Number = 0x3ff;
        
        
        
        TRACE(TL_V, TM_Send, ("DestinationAddress.IA_Destination_ID.NA_Bus_Number = 0x%x\n", pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_ID.NA_Bus_Number) );
        TRACE(TL_V, TM_Send, ("DestinationAddress.IA_Destination_ID.NA_Node_Number = 0x%x\n", pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_ID.NA_Node_Number) );
        TRACE(TL_V, TM_Send, ("DestinationAddress.IA_Destination_Offset.Off_High = 0x%x at 0x%x\n", pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High, &pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High) );
        TRACE(TL_V, TM_Send, ("DestinationAddress.IA_Destination_Offset.Off_Low = 0x%x at 0x%x\n", pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low,&pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low) );
        TRACE(TL_V, TM_Send, ("nNumberOfBytesToWrite = 0x%x\n", pMyIrb->u.AsyncWrite.nNumberOfBytesToWrite));
        TRACE(TL_V, TM_Send, ("nBlockSize = 0x%x\n", pMyIrb->u.AsyncWrite.nBlockSize));
        TRACE(TL_V, TM_Send, ("fulFlags = 0x%x\n", pMyIrb->u.AsyncWrite.fulFlags));
        TRACE(TL_V, TM_Send, ("Mdl = 0x%x\n", pMyIrb->u.AsyncWrite.Mdl ));
        TRACE(TL_V, TM_Send, ("ulGeneration = 0x%x at 0x%x \n", pMyIrb->u.AsyncWrite.ulGeneration, &pMyIrb->u.AsyncWrite.ulGeneration));
        TRACE(TL_V, TM_Send, ("chPriority = 0x%x\n", pMyIrb->u.AsyncWrite.chPriority));
        TRACE(TL_V, TM_Send, ("nSpeed = 0x%x\n", pMyIrb->u.AsyncWrite.nSpeed));

}





NDIS_STATUS
DummySendPacketsHandler(
    IN PVCCB        pVc,
    IN PNDIS_PACKET  pPacket 
    )
    //
    // To be used on a non-send VC
    //
{

    return NDIS_STATUS_FAILURE;

}




VOID
nicSendFailureInvalidGeneration(
    PVCCB pVc
    )

    
    // Function Description:
    //
    //  An AsyncStream or AnsyncWrite Irp  may be completed
    //  with a status of InvalidGeneration. This function will try and
    //  get a new generation, so that future sends will not be blocked
    //
    // Arguments
    //
    //
    //
    // Return Value:
    //
    //
    //
    //

{
    NDIS_STATUS NdisStatus  = NDIS_STATUS_FAILURE;
    PADAPTERCB pAdapter = pVc->Hdr.pAF->pAdapter;
    
    TRACE( TL_T, TM_Send, ( "==>nicSendFailureInvalidGeneration ") );

    ASSERT (pVc != NULL);
    
    do
    {
        PNDIS_WORK_ITEM pGetGenerationWorkItem  = NULL;
        BOOLEAN fWorkItemAlreadyLaunched  = FALSE;
        BOOLEAN fQueueWorkItem = FALSE;

        
        TRACE( TL_A, TM_Send, ( "Cause: Invalid generation on the asyncwrite packet"  ) );

        VC_ACQUIRE_LOCK (pVc);

        if (VC_ACTIVE(pVc) == TRUE)
        {
            fQueueWorkItem = TRUE;
        }
        
        fWorkItemAlreadyLaunched = (VC_TEST_FLAGS (pVc, VCBF_GenerationWorkItem));
        
        if (fWorkItemAlreadyLaunched)
        {
            //
            // If the Work Item has already been launched, then do not launch another instance
            //
            fQueueWorkItem = FALSE;
        }
        
        if ( fQueueWorkItem )
        {
            nicReferenceCall (pVc, "nicSendFailureInvalidGeneration");
        }
        
        VC_RELEASE_LOCK (pVc);

        

        if (fQueueWorkItem == FALSE)
        {
            // this thread simply exits 
            break;
        }
        //
        // We need to update the generation count
        //
        pGetGenerationWorkItem = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM); 

        if (pGetGenerationWorkItem == NULL)
        {
            TRACE( TL_A, TM_Cm, ( "Local Alloc failed for WorkItem - GetGeneration FAILED" ) );

            break;
        }

        VC_ACQUIRE_LOCK (pVc);

        VC_SET_FLAG(pVc, VCBF_GenerationWorkItem    );
        
        VC_RELEASE_LOCK (pVc);

        NdisInitializeWorkItem ( pGetGenerationWorkItem , 
                              (NDIS_PROC)nicGetGenerationWorkItem,
                              (PVOID)pVc );
        NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

        NdisScheduleWorkItem (pGetGenerationWorkItem );

        NdisStatus = NDIS_STATUS_SUCCESS;

    } while (FALSE);





    TRACE( TL_T, TM_Send, ( "<==nicSendFailureInvalidGeneration %x", NdisStatus) );



}



VOID
nicMakeGaspHeader (
    IN PADAPTERCB pAdapter,
    IN PGASP_HEADER pGaspHeader
    )
    // Function Description:
    //   This function will take the adapter structure and construct a Gasp Header out of it. 
    //   This will be used to make the AsyncStream packets.
    //  
    //
    //
    // Arguments
    //  pAdapter - Local Host in question
    //  pGaspHeader - Location where the Gasp Header is to be stored
    //
    // Return Value:
    //  None
    //

{
    USHORT              SourceID;
    NODE_ADDRESS        LocalNodeAddress;
    NDIS_STATUS         NdisStatus;

    TRACE( TL_T, TM_Send, ( "==>nicMakeGaspHeader  padapter %x, pGaspNdisBuffer %x ", pAdapter, pGaspHeader) );
    
    ASSERT (pGaspHeader != NULL);
    

    TRACE( TL_V, TM_Send, ( "pAdapter->NodeAddress %x", pAdapter->NodeAddress) );
        

    SourceID = *((PUSHORT)&pAdapter->NodeAddress);

    if(SourceID ==0)
    {
        NdisStatus  = nicGet1394AddressFromDeviceObject (pAdapter->pNextDeviceObject, 
                                                          &LocalNodeAddress, 
                                                          USE_LOCAL_NODE);

        if ( NdisStatus == NDIS_STATUS_SUCCESS)
        {       
            SourceID = *((PUSHORT)&LocalNodeAddress);

            ADAPTER_ACQUIRE_LOCK (pAdapter);

            pAdapter->NodeAddress = LocalNodeAddress;
                
            ADAPTER_RELEASE_LOCK (pAdapter);
        }
        //
        // Do not handle failure. As the BCM or a Reset will fix this problem
        //
    }


    TRACE( TL_V, TM_Send, ( "SourceId %x at %x", SourceID, &SourceID) );
    
    pGaspHeader->FirstQuadlet.Bitmap.GH_Source_ID = SourceID ; 

    pGaspHeader->FirstQuadlet.Bitmap.GH_Specifier_ID_Hi = GASP_SPECIFIER_ID_HI;
    
    pGaspHeader->SecondQuadlet.Bitmap.GH_Specifier_ID_Lo = GASP_SPECIFIER_ID_LO;

    pGaspHeader->SecondQuadlet.Bitmap.GH_Version = 1;       

    pGaspHeader->FirstQuadlet.GaspHeaderHigh = SWAPBYTES_ULONG (pGaspHeader->FirstQuadlet.GaspHeaderHigh );
    pGaspHeader->SecondQuadlet.GaspHeaderLow  = SWAPBYTES_ULONG (pGaspHeader->SecondQuadlet.GaspHeaderLow   );

    TRACE( TL_V, TM_Send, ( "Gasp Header High %x", pGaspHeader->FirstQuadlet.GaspHeaderHigh) );
    TRACE( TL_V, TM_Send, ( "Gasp Header Low  %x", pGaspHeader->SecondQuadlet.GaspHeaderLow  ) );

    TRACE( TL_T, TM_Send, ( "<==nicFreeGaspHeader %x, %x ", pGaspHeader->FirstQuadlet.GaspHeaderHigh, pGaspHeader->SecondQuadlet.GaspHeaderLow  ) );


}



NTSTATUS
AsyncWriteStreamSendComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pMyIrp,
    IN PVOID            Context   
    )


    //
    //  N.B.  this completes both Fifo and channels
    //
    //
    //  This function is Completion handler for the Irp used to send data.
    //  This function will invoke NDisCoSendComplete Handler
    //  Needs to use the VC Handle stored in the MiniportReserved[0] 
    //  of the packet. 
    //  We free all the data structures allocated on the way down,  
    //  by SendPacketsHandler (the Irb. Irp and Local memory used and Mdl) 
    //
    //  The LookasideHeader->OutstandingFragments should normally be one for 
    //  the defualt ( non-fragmented) case. However, if a failure in SendPackets
    //  occurs, Outstanding fragments  will be zero or the context will be null, 
    //  in that case we will only free the lookaside buffer (if it exists) and exit,  
    //  it will be the responsibility of the SendPacketsHandler
    //  to fail the packet.
    //

{

    
    NDIS_STATUS                 NdisStatus  = NDIS_STATUS_SUCCESS;  
    NTSTATUS                    IrpStatus   = STATUS_UNSUCCESSFUL;
    PVOID                       pLookasideListBuffer  = Context;  
    PLOOKASIDE_BUFFER_HEADER    pLookasideHeader = (PLOOKASIDE_BUFFER_HEADER)pLookasideListBuffer ; 
    PNDIS_PACKET                pPacket = NULL;
    PVCCB                       pVc = NULL; 
    PREMOTE_NODE                pRemoteNode = NULL;
    NDIS_HANDLE                 NdisVcHandle = NULL;
    ULONG                       OutstandingFragments  = 0;
    BUS_OPERATION               AsyncOp;
    PNIC_NPAGED_LOOKASIDE_LIST  pLookasideList = NULL;
    STORE_CURRENT_IRQL;


    TRACE( TL_T, TM_Send, ( "==>AsyncWriteStreamSendComplete, pMyIrp %x, Context %x", 
                                 pMyIrp, Context   ) );

    do 
    {
        if (pLookasideHeader == NULL)
        {
            TRACE( TL_V, TM_Send, ( "   AsyncSendComplete -  pLookasideHeader == NULL") );
            break;

        }
    

        //
        // This means that a lookaside buffer was allocated and
        // perhaps MDLS were allocated 
        //  if this is the last fragment, Free all the MDLs first
        //

        //
        // Get all the valuable information out of the header. 
        //

        pPacket         = pLookasideHeader->pNdisPacket;
        pVc             = pLookasideHeader->pVc; 
        pRemoteNode     = pVc->Hdr.pRemoteNode;
        pLookasideList  = pLookasideHeader->pLookasideList;
        AsyncOp         = pLookasideHeader->AsyncOp;

        ASSERT (AsyncOp != InvalidOperation);
        
        TRACE( TL_V, TM_Send, ( " Vc %x,, pLookaside Buffer %x, pPacket, %x", 
                                pVc, pLookasideHeader ,pPacket  ) );

        ASSERT (pLookasideList != NULL);

        //
        // This will tell us if this thread has received the last fragment
        // OustandingPackets == 0 gets to free the MDLS, and complete the packet
        //
        OutstandingFragments = NdisInterlockedDecrement (&pLookasideHeader->OutstandingFragments );


        if (OutstandingFragments == 0)
        {
            //
            // If there are no more fragments, then we need to 
            // free all the allocated structures ( the MDLS) on this buffer
            //
            
            ULONG  MdlsToFree = pLookasideHeader->FragmentsGenerated;

            PIRB pIrb = &((PUNFRAGMENTED_BUFFER)pLookasideHeader)->Irb;
            

            //
            // The maximum number of MDLS we can have is equal to
            // the maximum number of Fragments that were generated
            //
            while (MdlsToFree != 0)
            {
                PMDL pMdl = NULL;

                GET_MDL_FROM_IRB (pMdl, pIrb, AsyncOp);
                

                TRACE( TL_V, TM_Send, ( " Freeing Mdl %x of Irb %x ", 
                                         pMdl, pIrb) );

        
                if (pMdl != NULL)
                {
                    nicFreeMdl (pMdl);
                    if (pVc->Hdr.VcType == NIC1394_SendFIFO)  
                    {                                           
                        nicDecFifoSendMdl();                    
                    }                                           
                    else                                           
                    {                                           
                        nicDecChannelSendMdl();                 
                    }                                           
                
                }

                //
                // Set up for the next iteration
                //
                MdlsToFree --; 

                pIrb = (PVOID)((ULONG_PTR)pIrb + sizeof (IRB));


            } //while (MdlsToFree  != 0)



        } //if (OutstandingFragments == 0)


        //
        //  Map the NT_STATUS belonging to the Irp to an NdisStatus and call NdisMCoSendComplete
        //  Print Debug Output to help in testing. Need to Add more status cases  
        //
        if (pMyIrp == NULL)
        {   
            TRACE( TL_V, TM_Send, ( "   AsyncSendComplete - pIrp is NULL") );
            IrpStatus = STATUS_UNSUCCESSFUL;
        }
        else
        {
            

            //
            // We have a valid IRP, lets see if we failed the IRP and why
            // 
            IrpStatus   = pMyIrp->IoStatus.Status;

            nicIncrementBusSendCompletes(pVc);
        }
        
        if (IrpStatus != STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Send, ( "==>IRP FAILED StatusCode = %x",IrpStatus  ) );

            nicIncrementBusFailure();
            nicIncrementVcBusSendFailures(pVc, pPacket);

            //
            // The generation of the bus has changed. Lets get a new one.
            //
            
            if (IrpStatus == STATUS_INVALID_GENERATION)
            {
                nicSendFailureInvalidGeneration((PVCCB)pVc);
            }
            
            NdisStatus = NtStatusToNdisStatus(IrpStatus);
            
            NdisInterlockedIncrement (&pVc->Hdr.pAF->pAdapter->AdaptStats.ulXmitError);
        }
        else
        {
            NdisInterlockedIncrement(&pVc->Hdr.pAF->pAdapter->AdaptStats.ulXmitOk);
            nicIncrementVcBusSendSucess(pVc, pPacket);
        }

        //
        // Free the Irp and don't touch it after this
        //
        if (pMyIrp != NULL)
        {
            nicFreeIrp (pMyIrp);
            pMyIrp = NULL;
        }
        
        //
        // At this point, we know that the IRP went down to the bus driver
        // We know if this is the last fragment. So lets figure out if we need
        // to Complete the packet
        //

        if (OutstandingFragments != 0)
        {
            //
            // We need to wait for other fragments to complete
            //
            TRACE( TL_V, TM_Send, ( "   AsyncSendComplete = NOT  the last fragment") );

            break;

        }
        
    
        //
        // This means that this thread has marked the lookaside header as 'to be freed'
        // and it is this thread's responsibility to free it.
        //
        NdisVcHandle = pVc->Hdr.NdisVcHandle;
        
        TRACE( TL_V, TM_Send, ( "Calling NdisCoSendComplete, status %x, VcHandle %x, pPacket %x",
                                NdisStatus,NdisVcHandle, pPacket ) );

        
        nicMpCoSendComplete (NdisStatus,
                            pVc,
                            pPacket);


        nicFreeToNPagedLookasideList (pLookasideList, pLookasideListBuffer); 

        nicDereferenceCall (pVc, "AsyncWriteStreamSendComplete");

        //
        // Remove the reference on the PDO that the IRP was sent to
        //
        if (AsyncOp == AsyncWrite)
        {
            //
            // Async Write references the remote node 
            //
            ASSERT (pRemoteNode != NULL);
            nicDereferenceRemoteNode (pRemoteNode, AsyncSendComplete);
        }
        

    } while (FALSE);


    TRACE( TL_T, TM_Send, ( "<== AsyncWriteStreamSendComplete, NdisStatus %x,IrpStatus %x ",
                             NdisStatus, IrpStatus ) );
  
    //
    // ALWAYS RETURN STATUS_MORE_PROCESSING_REQUIRED
    //

    MATCH_IRQL;

    return STATUS_MORE_PROCESSING_REQUIRED;
}




NDIS_STATUS
AsyncWriteSendPacketsHandler(
    IN PVCCB        pVc,
    IN PNDIS_PACKET  pPacket 
    )
    
    //
    //  This is the VC handler when packet is sent using the 
    //  AsyncWrite 1394 Bus Api
    //  This function, copies the contents of the packet to locally 
    //  owned memory, sets up the Irb and the Irp and calls 
    //  nicSubmitIrp which is the generic cal to do a IoCallDriver
    // 
    // The return value is success, if the I/o was successfully pended
{
    
    PSENDFIFO_VCCB                  pSendFIFOVc = (SENDFIFO_VCCB*)pVc;
    PMDL                            pMyMdl = NULL;
    PIRB                            pMyIrb = NULL;
    PIRP                            pMyIrp = NULL;
    BOOLEAN                         fVcActive = TRUE;
    PREMOTE_NODE                    pRemoteNode = NULL;
    NDIS_STATUS                     NdisStatus = NDIS_STATUS_FAILURE;
    NTSTATUS                        NtStatus = STATUS_UNSUCCESSFUL;
    ULONG                           PacketLength = 0;
    PVOID                           pLookasideListBuffer  = NULL;
    PADAPTERCB                      pAdapter = NULL;
    USHORT                          FragmentLength = 0;
    PNDIS_BUFFER                    pStartNdisBuffer = NULL;
    PVOID                           pStartPacketData  = NULL;
    PLOOKASIDE_BUFFER_HEADER        pLookasideHeader = NULL;
    PNIC_NPAGED_LOOKASIDE_LIST      pLookasideList = NULL;
    ENUM_LOOKASIDE_LIST             WhichLookasideList = NoLookasideList;
    FRAGMENTATION_STRUCTURE         Fragment;
    ULONG                           NumFragmentsNeeded ;
    STORE_CURRENT_IRQL;

    NdisZeroMemory (&Fragment, sizeof (FRAGMENTATION_STRUCTURE));
    
    TRACE( TL_T, TM_Send, ( "==>AsyncWriteSendPacketHandler, Vc %x,Packet %x, FragmentationStruct %x", 
                           pSendFIFOVc, pPacket , &Fragment ) );

    pRemoteNode = pSendFIFOVc->Hdr.pRemoteNode;
    ASSERT (pRemoteNode != NULL);



    do 
    {
        
        VC_ACQUIRE_LOCK (pSendFIFOVc);

        //
        // Make sure that the Vc is Activated and that no close calls 
        // are pending or that we have already completed a close call
        //

        
        if ( VC_ACTIVE (pSendFIFOVc) == FALSE || REMOTE_NODE_ACTIVE(pRemoteNode) == FALSE)
        {
            fVcActive = FALSE;  
        }

        if (VC_TEST_FLAG( pSendFIFOVc, VCBF_GenerationWorkItem) == TRUE)
        {
            TRACE( TL_N, TM_Send, ( "AsyncWriteSendPacketHandler, Getting a new Gen, Fail send ") );

            fVcActive = FALSE;  
        }

        //
        // This reference will either be dereferenced below in a call to FreeSendPacketDataStructure
        // below or a call to FreeSendPacketDataStructure made from the Irp's completion routine
        //

        if (fVcActive == TRUE)
        {
            nicReferenceCall (pVc, "AsyncWriteSendPacketsHandler");

            nicReferenceRemoteNode (pRemoteNode, AsyncWriteSendPackets);

        }
        
        VC_RELEASE_LOCK (pSendFIFOVc);

        if (fVcActive  == FALSE)
        {
            TRACE( TL_N, TM_Send, ( "AsyncWriteSendPacketHandler, VC Not Active, Vc %x Flag %x", pSendFIFOVc,pSendFIFOVc->Hdr.ulFlags ) );

            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        pAdapter = pSendFIFOVc->Hdr.pAF->pAdapter;
        
        //
        //  Copy NdisBuffer in Packet to Local Memory and get an Mdl that points 
        //  to this memory 
        //
        NdisQueryPacket( pPacket,
                         NULL,
                         NULL,
                         NULL,
                         &PacketLength);

        ASSERT (pPacket->Private.Head != NULL);

        //
        // Spew out the packet if necessary
        //
        nicDumpPkt (pPacket, "AsyncWriteSendPacketsHandler");
        
        //
        // Initialize the start variables
        //

        pStartNdisBuffer = pPacket->Private.Head;
        pStartPacketData = nicNdisBufferVirtualAddress (pStartNdisBuffer);

        if (pStartPacketData == NULL)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            TRACE( TL_N, TM_Send, ( "AsyncWriteSendPacketHandler, pStartPacketData ") );

            break;
        }

        TRACE( TL_V, TM_Send, ( "PacketLength %x", PacketLength) );

        //
        // Make a decision on which lookaside list to use. If the tx is unfragmented 
        // then copy over the ndis packet as well
        //

        //
        // first choose the lookaside list. the actual lookaside list is chosen so that the 
        // each can accomodate the maximum number of fragments at its payload
        //
        //
        if (PacketLength < PAYLOAD_100)
        {
            pLookasideList = &pAdapter->SendLookasideList100;
            WhichLookasideList = SendLookasideList100;
            TRACE( TL_V, TM_Send, ( " PAYLOAD_100 Lookaside List %x", 
                                    &pAdapter->SendLookasideList100) );

        }
        else 
        if (PacketLength < PAYLOAD_2K)
        {
            pLookasideList = &pAdapter->SendLookasideList2K;
            WhichLookasideList = SendLookasideList2K;
            TRACE( TL_V, TM_Send, ( " PAYLOAD_2K Lookaside List %x", 
                                    &pAdapter->SendLookasideList2K) );


        } 
        else
        {
            //
            // Large Sends not supported
            // TODO : Add code for local allocation
            //
            ASSERT (!"SendPacket Too Large - Not supported Yet" );
            break;  
        }

        //
        // are we going to fragment
        // 
        ASSERT (pLookasideList != NULL)

        //
        // We are not going to fragment. Optimize this path
        //
        pLookasideListBuffer = nicGetLookasideBuffer (pLookasideList);
        
        if (pLookasideListBuffer == NULL )
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            BREAK (TM_Send, ("nicGetLookasideBuffer  FAILED") );
        }

        //
        // Initialize the header with relevant information that the send complete
        // will need
        //
    
        pLookasideHeader = (PLOOKASIDE_BUFFER_HEADER)pLookasideListBuffer;
        pLookasideHeader->IsFragmented          = FALSE;  // Default
        pLookasideHeader->FragmentsGenerated    = 0;
        pLookasideHeader->pLookasideList        = pLookasideList;
        pLookasideHeader->pNdisPacket           = pPacket;
        pLookasideHeader->pVc                   =(PVCCB)pVc;
        pLookasideHeader->AsyncOp               = AsyncWrite;

        //
        // Initialize the Fragment structure
        //
        //
        //  Do we fragment or not. Base it on the MaxPayload possible
        //
        
        TRACE( TL_V, TM_Send, ( "    PacketLength %x, pSendFIFOVc->MaxPayload%x ", 
                                 PacketLength ,pSendFIFOVc->Hdr.MaxPayload) );


        if (PacketLength <= pSendFIFOVc->Hdr.MaxPayload)
        {
            //
            // No need to fragment here. We will use the UNFRAGMENTED Layout
            //
            // First Get a local buffer from our lookaside list
            //
            PUNFRAGMENTED_BUFFER pUnfragmentedBuffer = (PUNFRAGMENTED_BUFFER )pLookasideHeader;

            NumFragmentsNeeded = 1;

            NdisStatus = nicCopyNdisBufferChainToBuffer (pStartNdisBuffer, 
                                                        (PVOID)&pUnfragmentedBuffer ->Data[0],
                                                         pLookasideList->MaxSendSize );
                                             
    
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                pLookasideHeader->OutstandingFragments  = 1;  // this is our refcount
                BREAK ( TM_Send, ( "   AsyncStreamSendPacketHandler, nicCopyNdisPacketToUnfragmentedBuffer Failed ") );
            }
    
            ASSERT (pLookasideListBuffer != NULL);

            // 
            // Initialize all the variable needed by the Next section of the code.
            // This deals with setting up the Mdl and the IRB
            //
            
            pStartNdisBuffer = NULL;

            Fragment.pStartFragment = (PVOID) &pUnfragmentedBuffer ->Data[0];
            Fragment.FragmentLength  = PacketLength;
            Fragment.pCurrNdisBuffer = NULL;

            pLookasideHeader->FragmentsGenerated = 1; 
            pLookasideHeader->IsFragmented = FALSE;                                    
            pLookasideHeader->OutstandingFragments  = 1;  // this is our refcount
        
        }
        else
        {
            //
            // We need to fragment
            //
            ULONG Dgl = NdisInterlockedIncrement(&pAdapter->dgl);

            //
            // Fragments will be needed . Make sure the calculation for numFragments catches the boundary conditions
            //

            
            NumFragmentsNeeded = nicNumFragmentsNeeded (PacketLength,
                                                        pSendFIFOVc->Hdr.MaxPayload,
                                                        sizeof (NDIS1394_FRAGMENT_HEADER) );


            //
            // Initialize the fragment structure. The unfragmented code path
            // does not care about these fields
            //

            //
            // This structure is local to this function and this thread. 
            //
            Fragment.TxHeaderSize = sizeof (NDIS1394_FRAGMENT_HEADER);
            Fragment.pLookasideListBuffer = pLookasideListBuffer;
            Fragment.AsyncOp = AsyncWrite;
            Fragment.pAdapter = pRemoteNode->pAdapter;
            Fragment.pLookasideList = pLookasideList;
            Fragment.IPDatagramLength = (USHORT)PacketLength - sizeof (NDIS1394_UNFRAGMENTED_HEADER); 
            
            //
            // Get Start of first Dest fragment
            //
            Fragment.MaxFragmentLength = pSendFIFOVc->Hdr.MaxPayload;                                                                   
            Fragment.NumFragmentsNeeded = NumFragmentsNeeded;
        
            

            
            // 
            // Set up the Fragment Headers that will be used in fragmentation
            //

            NdisStatus = nicFirstFragmentInitialization (pPacket->Private.Head,
                                                     Dgl,
                                                     &Fragment);


            if (pLookasideListBuffer  == NULL || NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK (TM_Send, (" AsyncWriteSendPacketsHandler: nicFirstFragmentInitialization : FAILED" )) ;
            }       

            ASSERT (pLookasideListBuffer != NULL);
            
            pLookasideHeader->IsFragmented = TRUE;                                     
            pLookasideHeader->OutstandingFragments  = NumFragmentsNeeded ;  // this is our refcount
            
        }


        TRACE( TL_V, TM_Send, ( "NumFragments  %x, pSendFIFOVc->MaxSendSize %x, Packet Size %x", 
                                 NumFragmentsNeeded,pSendFIFOVc->Hdr.MaxPayload, PacketLength) );


        //
        // Now begin the loop which will send n fragments
        //
        do 
        {   

            //
            // Do we need to fragment. If so , extract one fragment out of the NdisPacket
            //
            if (pLookasideHeader->IsFragmented == TRUE )
            {   
            
                //
                // We copy one fragment over and this will allocate the lookaside list
                //

                NdisStatus = nicCopyOneFragment (&Fragment);
                
                if (NDIS_STATUS_SUCCESS != NdisStatus)
                {
                    BREAK ( TM_Send, ( "   AsyncWriteSendPacketHandler, nicCopyOneFragment  Failed ") );
                }
                                              
                //
                // Get the pointer to the Irb here . Amd set it up for the next time
                //
                pMyIrb = Fragment.pCurrentIrb;
                Fragment.pCurrentIrb = (PIRB)((ULONG_PTR)Fragment.pCurrentIrb + sizeof (IRB) );
                TRACE( TL_V, TM_Send, ( " pMyIrb  %x, Next Irb %x  ", pMyIrb  , Fragment.pCurrentIrb ) );

            }
            else
            {
                //
                // No Curr NdisBuffer as this packet was never fragmented. 
                //
                
                ASSERT (pLookasideHeader->IsFragmented == FALSE);                                      

                pMyIrb =  &((PUNFRAGMENTED_BUFFER )pLookasideHeader)->Irb;
            }
            
            //
            // At this point we have one fragment that needs to be transmitted.
            // Data structures have been updated to set up the MDL and the IRB
            //
            ASSERT (Fragment.pStartFragment != NULL);

            NdisStatus = nicGetMdl (Fragment.FragmentLength  , 
                                    Fragment.pStartFragment, 
                                    &pMyMdl);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                pMyMdl = NULL;
                BREAK ( TM_Send, ( "   AsyncWriteSendPacketHandler, nicCopyNdisBufferChainToBuffer Failed ") );
            }       

            nicIncFifoSendMdl();
            //
            //  Fill in the Irb with the correct values from the VC
            //  Stuff we need to add to the send VC - BlockSize,Generation
            //  

            nicInitAsyncWriteIrb(pSendFIFOVc, pMyMdl, pMyIrb);

            //
            // Get a free Irp 
            //

            NdisStatus  = nicGetIrp (pRemoteNode->pPdo, &pMyIrp); 
        
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                pMyIrp = NULL;
                break;
            }
            //
            // At this point, we have a guarantee that the Completion routine will be called
            //
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

            //
            // Dump the Fragment 
            //
            nicDumpMdl (pMyMdl , 0, "AsyncWrite Fragment");

            NIC1394_LOG_PKT(
                pAdapter,
                NIC1394_LOGFLAGS_SEND_FIFO,
                pAdapter->BCRData.LocalNodeNumber,          // SourceID
                pRemoteNode->RemoteAddress.NA_Node_Number,  // DestID
                Fragment.pStartFragment, 
                Fragment.FragmentLength
                );


            //
            // This function implements the common functionality to be implemented by
            // all other send/recv cals to IoCallDriver
            //
            //
            // We IGNORE the NtStatus as the completion handler will be called
            //
            nicIncrementBusSends(pVc);
                    
            NtStatus = nicSubmitIrp(pRemoteNode->pPdo,
                                    pMyIrp,
                                    pMyIrb,
                                    AsyncWriteStreamSendComplete,
                                   (PVOID)pLookasideListBuffer);

            TRACE( TL_V, TM_Send, ( " pCurrNdisBuffer  %x, NdisStatus %x ", Fragment.pCurrNdisBuffer , NdisStatus ) );

            
        } while (Fragment.pCurrNdisBuffer != NULL && NdisStatus == NDIS_STATUS_SUCCESS);

    
    } while (FALSE);

    //
    // DO NOT touch the packet if status == NDIS_STATUS_SUCCESS. 
    //

    
    //
    //  CleanUp if any of the allocations failed. We do not have a pointer
    //  to the LocalBuffer (it is embedded in the Mdl)  so it remains NULL
    //
    //  NdisStatus != Success means that we never got to nicSubmitIrp
    //
    
    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {   

        ASSERT (pMyIrp == NULL);

        //
        // fVc Active makes sure that we actually got around to allocating 
        // and referencing structures
        //
        
        if (fVcActive == TRUE)
        {

            if (pLookasideListBuffer != NULL)
            {

                //
                // Complete this fragment, as we never submit'd the IRP to
                // the 1394 bus driver
                //
                AsyncWriteStreamSendComplete(NULL, // PDO
                                             NULL, 
                                             pLookasideListBuffer);

                NdisStatus =NDIS_STATUS_SUCCESS;
            }                                  
            else
            {

                //
                // This thread needs to decrement the refcounts as 
                // AsyncWriteStreamSendComplete was not called
                //
                nicDereferenceCall ((PVCCB) pSendFIFOVc, "AsyncWriteSendPacketsHandler");

                nicDereferenceRemoteNode (pRemoteNode, AsyncWriteSendPackets);

            }

            
        }

    }


    

    TRACE( TL_T, TM_Send, ( "<==AsyncWriteSendPacketHandler, NdisStatus  %x", NdisStatus ) );
    MATCH_IRQL;

    return NdisStatus;
}



NDIS_STATUS
nicCopyOneFragment (
    PFRAGMENTATION_STRUCTURE pFragment
    )
    
    // Function Description:
    //   This creates one fragment filled with valid data and returns it.
    //   The is complex because the Current NDisBuffer could end before the fragment
    //   or vice versa. 
    //   
    //   Information from this fragment is stored and will be used in the next fragment
    //
    // Arguments
    // pFragment - Copies one fragment into the next available fragement.
    //
    // Return Value:
    // Status - Success
    //
    //
{
    NDIS_STATUS                         NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS_BUFFER                        pCurrNdisBuffer = pFragment->pCurrNdisBuffer;
    PVOID                               pSourceAddressInNdisBuffer = pFragment->pSourceAddressInNdisBuffer;
    ULONG                               FragmentLengthRemaining = pFragment->MaxFragmentLength;
    USHORT                              FragmentLength=0;
    PVOID                               pSource = NULL;
    PVOID                               pDestination = NULL;
    PVOID                               pStartFragmentData = NULL;
    ULONG                               NdisBufferLengthRemaining = pFragment->NdisBufferLengthRemaining;
    ULONG                               LengthToCopy = 0;
    ULONG                               FragmentCopyStatus=0;
    PLOOKASIDE_BUFFER_HEADER            pLookasideHeader = NULL;
    enum 
    {
        FRAGMENT_COPY_Invalid,
        FRAGMENT_COPY_NdisBufferCompleted,
        FRAGMENT_COPY_NdisBufferAndFragmentCompleted,
        FRAGMENT_COPY_FragmentCompleted
    };
    
    TRACE( TL_T, TM_Send, ( "==>nicCopyOneFragment  pFragment %x", pFragment )  );
    ASSERT (pCurrNdisBuffer != NULL);
    do 
    {

        //
        //  lets get the destination. We need to account for 
        //  ther fragment size and add it to the previous start address
        //

        {
            ULONG   CurrFragOffset;

            CurrFragOffset  = pFragment->MaxFragmentLength * (pFragment->CurrFragmentNum++);
            
            pStartFragmentData  = (PVOID) ((ULONG_PTR) pFragment->pStartOfFirstFragment + CurrFragOffset );
        
        }



        pFragment->pStartFragment  = pStartFragmentData;

        TRACE( TL_V, TM_Send, ( " pStartFragmentData  %x", pStartFragmentData) );

        pLookasideHeader = (PLOOKASIDE_BUFFER_HEADER)pFragment->pLookasideListBuffer;



        //
        // Do the bookkeeping , Increase refcount and num of fragments used. Refcount decremented in FreeSendDataStructures
        // 

        NdisInterlockedIncrement (&pLookasideHeader->FragmentsGenerated);

        //
        // The Start of the data beginning with the fragment header goes here or in the 
        // case of async stream fragment header and gasp header go here
        //
        ASSERT (pFragment->TxHeaderSize  == 8 || pFragment->TxHeaderSize  == 16);

        
        pDestination = (PVOID) ((ULONG_PTR)pStartFragmentData + pFragment->TxHeaderSize );

        FragmentLengthRemaining -= pFragment->TxHeaderSize;

        //
        // Now we start the copy. Keep on copying into the current fragment until the MaxLength is reached 
        // or the NdisBufferChain is exhausted
        //

        pSource = pSourceAddressInNdisBuffer; 


        do
        {


            TRACE( TL_T, TM_Send, ( " LengthNdisBuffer  %x, FragmentLengthRemaining %x, pCurrNdisBuffer %x", 
                    NdisBufferLengthRemaining , FragmentLengthRemaining ,pCurrNdisBuffer ) ); 

            if (FragmentLengthRemaining > NdisBufferLengthRemaining )
            {
                //
                // Copy the complete NdisBuffer over
                //

                LengthToCopy = NdisBufferLengthRemaining; 
                FragmentCopyStatus = FRAGMENT_COPY_NdisBufferCompleted;

            }

            
            if (FragmentLengthRemaining < NdisBufferLengthRemaining )
            {
                //
                // Copy only as much as required
                //

                LengthToCopy = FragmentLengthRemaining;
                FragmentCopyStatus = FRAGMENT_COPY_FragmentCompleted;
                    
            }
            
            if (FragmentLengthRemaining == NdisBufferLengthRemaining  )
            {
                //
                // Copy the complete  Ndis Buffer , move  to the next ndis buffer
                // and update the NdisBufferLengthRemaining field  
                //
                LengthToCopy = NdisBufferLengthRemaining; 
                FragmentCopyStatus = FRAGMENT_COPY_NdisBufferAndFragmentCompleted;


            }

            //
            // Sanity check to make sure we are not overwriting into free memory.
            // As this should never happen, there is no recovery mechanism in place.
            //
            ASSERT (((PUCHAR)pDestination +  LengthToCopy) <=  (((PUCHAR) pLookasideHeader) + (pLookasideHeader->pLookasideList->Size) ));
            
            //
            // Do the copy
            //
                    
            TRACE ( TL_V, TM_Send, (" nicCopyOneFragment  pSource  %x , pDestination %x, Length %x", pSource, pDestination, LengthToCopy ) );
            
            NdisMoveMemory (pDestination, pSource, LengthToCopy);
            

            //
            // Update the fragment length remaininig and Total Buffer Size
            //
            FragmentLengthRemaining  -= LengthToCopy;

            FragmentLength += (USHORT)LengthToCopy;

            pDestination = (PVOID) ((ULONG_PTR) pDestination + LengthToCopy);
            //
            // Update the NdisBuffer variables 
            //
            ASSERT (pCurrNdisBuffer != NULL);
    
            TRACE( TL_V, TM_Send, ( " FragmentCopyStatus %x", FragmentCopyStatus) ); 

            switch (FragmentCopyStatus)
            {
                case FRAGMENT_COPY_NdisBufferCompleted:
                case FRAGMENT_COPY_NdisBufferAndFragmentCompleted:
                {
                    
                    //
                    // Move to the next Ndisbuffer
                    //
                    pCurrNdisBuffer = pCurrNdisBuffer->Next;
    
                    if (pCurrNdisBuffer  != NULL)
                    {
                        NdisBufferLengthRemaining = nicNdisBufferLength (pCurrNdisBuffer);

                        pSourceAddressInNdisBuffer = nicNdisBufferVirtualAddress(pCurrNdisBuffer);

                        if (pSourceAddressInNdisBuffer == NULL)
                        {
                            NdisStatus = NDIS_STATUS_RESOURCES;
                            BREAK (TM_Send, ("nicNdisBufferVirtualAddress FAILED " ) );                         
                        }

                        //
                        // Set up the values for the next iteration
                        //
                        pSource = pSourceAddressInNdisBuffer;
                        NdisBufferLengthRemaining   = nicNdisBufferLength (pCurrNdisBuffer);

                    }
                    else
                    {
                        //
                        // we have reached the end of the NdisPAcket. Mark the fragment header as such
                        //
                        pFragment->lf = lf_LastFragment;
                    }
                        
                    break;
                }
                
                case FRAGMENT_COPY_FragmentCompleted:
                {   
                    //
                    // Fragment has completed. Do not move to the next NdisBuffer
                    // However update StartCopy Address  in the NdisBuffer
                    // 
                    pSourceAddressInNdisBuffer  = (PVOID) ((ULONG_PTR) pSource + LengthToCopy );    

                    NdisBufferLengthRemaining -= LengthToCopy ;
                    
                    break;
                }


                default :
                {
                    ASSERT (0);
                }

            }

            TRACE( TL_T, TM_Send, ( "      LengthToCopy %x, FragmentLength %x, ", LengthToCopy, FragmentLength) ); 
            TRACE( TL_T, TM_Send, ( "      FragmentLengthRemaining %x, pCurrNdisBuffer %x",FragmentLengthRemaining , pCurrNdisBuffer ) ); 
            

        }while (FragmentLengthRemaining  > 0 && pCurrNdisBuffer != NULL);       


            
        
        //
        // Now that we have the buffer size. Add the fragment header
        //
        
        nicAddFragmentHeader (pStartFragmentData, 
                                pFragment,
                                FragmentLength);
                                     
                            
        TRACE( TL_T, TM_Send, ( " Fragment Header added %x", *(PULONG)pStartFragmentData) ); 

        NdisStatus = NDIS_STATUS_SUCCESS;

    }while (FALSE);

    //
    // Now update the output parameters.
    //

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {

        //
        // Update the Lookaside Header structure, to reflect the new position of all the pointers
        //
        pFragment->pCurrNdisBuffer  = pCurrNdisBuffer; 
        pFragment->pSourceAddressInNdisBuffer = pSourceAddressInNdisBuffer;

        //
        // Update the fragment structure with the length remaining in the NdisBuffer
        //
    
        pFragment->NdisBufferLengthRemaining = NdisBufferLengthRemaining ;
        pFragment->FragmentLength =  FragmentLength + pFragment->TxHeaderSize;  

        

    }
    

    TRACE( TL_T, TM_Send, ( "<==nicCopyOneFragment   pStartFragmentData %x, pLookasideListBuffer %x, pSourceAddressInNdisBuffer %x, NdisStatus %x", 
                            pStartFragmentData, pSourceAddressInNdisBuffer, NdisStatus) );

    return NdisStatus;
}










VOID
nicCopyUnfragmentedHeader ( 
    IN PNIC1394_UNFRAGMENTED_HEADER pDestUnfragmentedHeader,
    IN PVOID pSrcUnfragmentedHeader
    )
    // Function Description:
    //  Expect the  Src to be a big Endian  unfragmented packet header
    //  It will reverse the byte order in a temp variable and copy it into the 
    //  Destination provided.
    //
    // Arguments
    //   pDestUnfragmentedHeader - Destination (Little Endian
    //   pSrcUnfragmentedHeader - Source (Big Endian)
    //
    // Return Value:
    //
    //   Success if all the pointers and copy is valid
    //
{

    ULONG UnfragmentedHeader;
    
    TRACE( TL_T, TM_Send, ( "==> nicCopyUnfragmentedHeader  pDestUnfragmentedHeader %x, pSrcUnfragmentedHeader %x", 
                            pDestUnfragmentedHeader, pSrcUnfragmentedHeader ) );

    ASSERT (pSrcUnfragmentedHeader != NULL && pDestUnfragmentedHeader != NULL) ;
    
    *((PULONG)pDestUnfragmentedHeader) = SWAPBYTES_ULONG ( *(PULONG) pSrcUnfragmentedHeader);

    TRACE( TL_T, TM_Send, ( "pDestUnfragmentedHeader %x, ", *(PULONG)pDestUnfragmentedHeader) );

    
    TRACE( TL_T, TM_Send, ( " <== nicCopyUnfragmentedHeader   " ) );

}




NDIS_STATUS
nicFirstFragmentInitialization (
    IN PNDIS_BUFFER pStartNdisBuffer,
    IN ULONG DatagramLabelLong,
    IN OUT PFRAGMENTATION_STRUCTURE  pFragment           
    )
    // Function Description:
    //   This will set up the fragement headers that are required for 
    //   transmitting multiple fragments.
    //   Sets up the first source and destination for the first fragment
    //
    // Arguments
    //  pAdapter - to be used to get the dgl label and the lookaside list
    //  pStartOfData - start of the packet data . To be used in extracting the Unfragmented Header 
    //  ppLookasideListBuffer Points to the allocated lookaside buffer
    //  pplookasideheader - points to the lookaside header
    //
    // Return Value:
    //  Success if the allocation succeeds
    //
    //
{

    NDIS_STATUS                   NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS1394_FRAGMENT_HEADER   pHeader = NULL;
    PVOID                       pPacketStartData = NULL;
    USHORT                      dgl = (USHORT) DatagramLabelLong;

    
    TRACE( TL_T, TM_Send, ( "==> nicFirstFragmentInitialization  pStartNdisBuffer%x,  pFragment%x dgl %x ", 
                             pStartNdisBuffer, pFragment,    dgl ) );

    do
    {

        //
        // Get the start address for the 1st NdisBuffer.    This contains
        // the unfragmented header
        //
        pPacketStartData = nicNdisBufferVirtualAddress(pStartNdisBuffer);

        if (pPacketStartData == NULL) 
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            BREAK (TM_Send, ("NdisBufferVirtual Address is NULL " ) );
        }


        pFragment->UnfragmentedHeader.HeaderUlong = 
                SWAPBYTES_ULONG (((PNDIS1394_UNFRAGMENTED_HEADER)pPacketStartData)->HeaderUlong);

        TRACE ( TL_V, TM_Send, (" Unfragmented Header %x, pPacketStartData %x", 
                                   pFragment->UnfragmentedHeader.HeaderUlong , pPacketStartData) );

        TRACE ( TL_V, TM_Send, (" original Header lf %x, etherType %x", 
                                   pFragment->UnfragmentedHeader.u.FH_lf,
                                   pFragment->UnfragmentedHeader.u.FH_EtherType) );

                                   
    
        //
        // Now construct a fragmentation header to be used by all the fragments.
        //
        pHeader  = &pFragment->FragmentationHeader;

            
        pHeader ->u.FirstQuadlet.FH_lf = lf_FirstFragment;
        pHeader ->u.FirstQuadlet.FH_buffersize = pFragment->IPDatagramLength-1;
        
        pHeader ->u.FirstQuadlet_FirstFragment.FH_EtherType 
                        = pFragment->UnfragmentedHeader.u.FH_EtherType;
        
        pHeader ->u1.SecondQuadlet.FH_dgl = dgl;

        TRACE ( TL_V, TM_Send, (" fragmented Header Hi %x   Lo %x", 
                                   pHeader->u.FH_High, 
                                   pHeader->u1.FH_Low) );

        TRACE ( TL_V, TM_Send, (" fragmented Header lf %x  EtherType  %x", 
                                   pHeader ->u.FirstQuadlet_FirstFragment.FH_lf ,
                                   pHeader ->u.FirstQuadlet_FirstFragment.FH_EtherType ) );

        //
        // temporaty debug spew
        //
        TRACE (TL_V, TM_Send, (" copy Header at %x, Orig Header at %x", 
                               &pHeader ->u.FirstQuadlet_FirstFragment, 
                               pFragment->UnfragmentedHeader) );
        
        //
        // Initialize the fragmentation structure with packet's first ndis buffer
        //
        pFragment->pSourceAddressInNdisBuffer = NdisBufferVirtualAddress (pStartNdisBuffer);

        if (pFragment->pSourceAddressInNdisBuffer  == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;   

        }

        //
        // Set up the copy source . The first four bytes of data contain the unfragmented header.
        // We need to skip past these bytes and start the copy from the next byte
        // 
        pFragment->pSourceAddressInNdisBuffer  = (PVOID) ((ULONG_PTR)pFragment->pSourceAddressInNdisBuffer  +
                                                         sizeof (NDIS1394_UNFRAGMENTED_HEADER) );
        
        
        pFragment->NdisBufferLengthRemaining = NdisBufferLength (pStartNdisBuffer) - sizeof (NDIS1394_UNFRAGMENTED_HEADER);
        pFragment->pCurrNdisBuffer = pStartNdisBuffer;
        //
        // Set up the destination
        //
        pFragment->pStartFragment = (PVOID)((ULONG_PTR)pFragment->pLookasideListBuffer 
                                                  + (pFragment->NumFragmentsNeeded*sizeof(IRB)));


        ((PLOOKASIDE_BUFFER_HEADER)pFragment->pLookasideListBuffer)->pStartOfData = pFragment->pStartFragment;
        
        pFragment->pStartOfFirstFragment = pFragment->pStartFragment ;
        pFragment->CurrFragmentNum = 0;


        pFragment->lf = lf_FirstFragment;

        //
        // The First IRB will reside at the end of the lookaside-header 
        //
        pFragment->pCurrentIrb = &((PUNFRAGMENTED_BUFFER)pFragment->pLookasideListBuffer)->Irb;
        
        TRACE( TL_T, TM_Send, ( " pStartFragment %x, pFragment %x,NumFragmentsNeeded %x,MaxFragmentLength %x  ", 
                                  pFragment->pStartFragment, 
                                  pFragment->NumFragmentsNeeded,
                                  pFragment->MaxFragmentLength) );

        
        NdisStatus = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    
    
    TRACE( TL_T, TM_Send, ( " <== nicFirstFragmentInitialization  NdisStautus %x, pFragment %x, ", 
                             NdisStatus, pFragment) );

    return NdisStatus;
}





VOID
nicAddFragmentHeader (
    IN PVOID pStartFragmentData, 
    IN PFRAGMENTATION_STRUCTURE pFragmentStructure,
    IN ULONG FragmentLength
    )
    // Function Description:
    //   Copies the Fragment header over after byteswapping it.
    //   For the the first time, the ether type and so forth is already initialized and waiting to be copied.
    //   This funciotn also sets up the values for the next invocation of this function
    // Arguments
    //   pStartFragmentData - Start of the fragment. Header goes after the gasp header if necessary .
    //   pFragmentationHeader - Header to copy over
    //   fIsFirstFragment - TRUE if this is the first fragment and needs a special header
    // Return Value:
    //   None
    //
{
    
    PNDIS1394_FRAGMENT_HEADER  pDestFragmentHeader = (PNDIS1394_FRAGMENT_HEADER)pStartFragmentData;
    PNDIS1394_FRAGMENT_HEADER  pSrcFragmentHeader = &pFragmentStructure->FragmentationHeader;   
    
    
    TRACE( TL_T, TM_Send, ( "==> nicAddFragmentHeader pStartFragmentData %x, pFragmentationHeader %x, , FragmentLength %x,  lf %x", 
                            pStartFragmentData , pSrcFragmentHeader , FragmentLength, pFragmentStructure->lf) );

    if (pFragmentStructure->AsyncOp == AsyncStream)
    {
        //
        // First Copy the GaspHeader
        //
        NdisMoveMemory (pStartFragmentData , 
                          &pFragmentStructure->pAdapter->GaspHeader, 
                          sizeof (GASP_HEADER) );

        //
        // Increment the pointers so that the fragment header will be copied after the gasp header
        //
        pStartFragmentData = (PVOID) ((ULONG_PTR) pStartFragmentData + sizeof (GASP_HEADER) );
        pDestFragmentHeader  = (PVOID) pStartFragmentData;
        
        TRACE( TL_T, TM_Send, ( " nicAddFragmentHeader Added Gasp Header from  %x ", 
                               pFragmentStructure->pAdapter->GaspHeader) );
        
    }


    //
    // Sanity check , are we overwriting anybody ?
    //
    ASSERT (*(PULONG)pDestFragmentHeader == 0);
    ASSERT (*(PULONG)pFragmentStructure->pCurrentIrb == 0);

    TRACE( TL_V, TM_Send, ( " pSrcFragmentHeader Hi %x,Lo %x", 
                             pSrcFragmentHeader->u.FH_High, pSrcFragmentHeader->u1.FH_Low) ); 

    //
    //  Copy over the lf;
    //
    pSrcFragmentHeader->u.FirstQuadlet.FH_lf = pFragmentStructure->lf;

    //
    // Now copy over the 8 bytes of the fragment header and byteswap them into big endian
    //

    
    pDestFragmentHeader->u.FH_High =  SWAPBYTES_ULONG ( pSrcFragmentHeader->u.FH_High);

    pDestFragmentHeader->u1.FH_Low = SWAPBYTES_ULONG ( pSrcFragmentHeader->u1.FH_Low);

    TRACE( TL_V, TM_Send, ( "  Fragment Offset %x", pSrcFragmentHeader->u.FirstQuadlet.FH_fragment_offset   ) );

    //
    // PREPARE the FRAGMENT STRUCTURE FOR THE NEXT ITERATION
    //

    //
    // Set the first fragment completed flag to true and set up the header for the next fragment
    //
    if (pFragmentStructure->lf == lf_FirstFragment)
    {
        pFragmentStructure->lf = lf_InteriorFragment;
        pSrcFragmentHeader->u.FirstQuadlet.FH_fragment_offset = 0;

    }

    //
    // Increase the fragment offset for use in the next fragment
    //
    pSrcFragmentHeader->u.FirstQuadlet.FH_fragment_offset += FragmentLength;





    TRACE( TL_T, TM_Send, ( "<== nicAddFragmentHeader lf %x", pFragmentStructure->lf) );

}


NDIS_STATUS
AsyncStreamSendPacketsHandler (
    IN PVCCB pVc,
    IN PNDIS_PACKET pPacket 
    )
    // Function Description:
    //  This function is used to send packets to the bus 
    //  via the async stream irp. the Ndis Packet is copied 
    //  to locally owned buffers and mdls and then sent
    //  down to the bus driver
    //
    //  This code is borrowed heavily from the AsyncStreamIrp code below
    //
    // Arguments
    // pChannelVc - The Vc which needs to send the packets
    // pPacket - the packet being transmitted
    //
    // Return Value:
    // NdisStatus - if all allocations and irp operations complete 
    // successfully, and the i/o will be completed asynchronously
    //
{
    NDIS_STATUS                     NdisStatus = NDIS_STATUS_FAILURE;
    NTSTATUS                        NtStatus = STATUS_UNSUCCESSFUL;
    PCHANNEL_VCCB                   pChannelVc = (PCHANNEL_VCCB) pVc;
    BOOLEAN                         fVcActive = TRUE;
    PMDL                            pMyMdl = NULL;
    PIRB                            pMyIrb = NULL;
    PIRP                            pMyIrp = NULL;
    ULONG                           PacketLength = 0;
    PVOID                           pLookasideListBuffer = NULL;
    PADAPTERCB                      pAdapter = NULL;
    PNDIS_BUFFER                    pStartNdisBuffer = NULL ;
    PVOID                           pStartPacketData= NULL ;
    PNIC_NPAGED_LOOKASIDE_LIST      pLookasideList = NULL;
    PLOOKASIDE_BUFFER_HEADER        pLookasideHeader = NULL;
    ULONG                           NumFragmentsNeeded = 0;
    FRAGMENTATION_STRUCTURE         Fragment;
    STORE_CURRENT_IRQL;


    NdisZeroMemory (&Fragment, sizeof (FRAGMENTATION_STRUCTURE));
    
    TRACE( TL_T, TM_Send, ( "==>AsyncStreamSendPacketsHandler , pVc  %x, pPacket %x", 
                                 pChannelVc , pPacket ) );
    
    pAdapter = pChannelVc->Hdr.pAF->pAdapter;
    //
    // This reference will either be dereferenced below in a call to FreeSendPacketDataStructure
    // below or a call to FreeSendPacketDataStructure made from the Irp's completion routine
    //
    


    do 
    {
        VC_ACQUIRE_LOCK (pVc);



        //
        // Make sure that the Vc is Activated and that no close calls 
        // are pending or that we have already completed a close call
        //

        
        if ( VC_ACTIVE (pChannelVc) == FALSE || ADAPTER_ACTIVE(pAdapter) == FALSE)
        {
            fVcActive = FALSE;  
        }

        if (VC_TEST_FLAG( pChannelVc, VCBF_GenerationWorkItem) == TRUE)
        {
            TRACE( TL_N, TM_Send, ( "AsyncStreamSendPacketHandler, Getting a new Gen, Fail send ") );

            fVcActive = FALSE;  
        }

        if (fVcActive == TRUE)
        {
            nicReferenceCall (pVc, "AsyncStreamSendPacketsHandler");
        }
        
        VC_RELEASE_LOCK (pVc);

        if (fVcActive  == FALSE)
        {
            TRACE( TL_N, TM_Send, ( "AsyncStreamSendPacketHandler, VC Not Active VC %x , Flag %x", pVc, pVc->Hdr.ulFlags ) );

            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        
        //
        //  Copy NdisBuffer in Packet to Local Memory and get an Mdl that points 
        //  to this memory (we get 1 Mdl only)
        NdisQueryPacket( pPacket,
                       NULL,
                       NULL,
                       NULL,
                       &PacketLength);

        ASSERT (pPacket->Private.Head != NULL);


        pStartNdisBuffer = pPacket->Private.Head;
        pStartPacketData = nicNdisBufferVirtualAddress (pStartNdisBuffer);

        if (pStartPacketData == NULL)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            TRACE( TL_N, TM_Send, ( "AsyncStreamSendPacketHandler, pStartPacketData ") );

            break;
        }


        TRACE( TL_V, TM_Send, ( "PacketLength %x", PacketLength) );



        NumFragmentsNeeded = nicNumFragmentsNeeded (PacketLength,
                                                    pChannelVc->Hdr.MaxPayload,
                                                    sizeof (NDIS1394_FRAGMENT_HEADER) + ISOCH_PREFIX_LENGTH );

        TRACE( TL_V, TM_Send, ( "NumFragments  %x, pVc->MaxSendSize", 
                                 NumFragmentsNeeded,pVc->Hdr.MaxPayload) );

        //
        // first choose the lookaside list
        //
        //

        
        if (PacketLength < PAYLOAD_100)
        {
            pLookasideList = &pAdapter->SendLookasideList100;
            TRACE( TL_V, TM_Send, ( " PAYLOAD_100 Lookaside List %x", 
                                    &pAdapter->SendLookasideList100) );

        }
        else 
        if (PacketLength < PAYLOAD_2K)
        {
            pLookasideList = &pAdapter->SendLookasideList2K;
            TRACE( TL_V, TM_Send, ( " PAYLOAD_2K Lookaside List %x", 
                                    &pAdapter->SendLookasideList2K) );


        }
        else
        {
            //
            // Add code for local allocation
            //
            ASSERT (0);
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // are we going to fragment
        // 
        ASSERT (pLookasideList != NULL)

        //
        // We are not going to fragment. Optimize this path
        //
        pLookasideListBuffer = nicGetLookasideBuffer (pLookasideList);
        
        if (pLookasideListBuffer == NULL )
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            BREAK (TM_Send, ("nicGetLookasideBuffer  FAILED") );
        }

        //
        // Dump out the packet if necessary
        //
        nicDumpPkt (pPacket, "AsyncWriteStreamPacketsHandler");

        //
        // Initialize the header with relevant information that the send complete
        // will need
        //


        pLookasideHeader = (PLOOKASIDE_BUFFER_HEADER)pLookasideListBuffer;
        pLookasideHeader->IsFragmented          = FALSE;  // Default
        pLookasideHeader->FragmentsGenerated    = 0;
        pLookasideHeader->pLookasideList        = pLookasideList;
        pLookasideHeader->pNdisPacket           = pPacket;
        pLookasideHeader->pVc                   =(PVCCB)pVc;
        pLookasideHeader->AsyncOp               = AsyncStream;
        pLookasideHeader->OutstandingFragments = NumFragmentsNeeded ;

        //
        // Initialize the Fragment structure
        //
        //
        //  Do we fragment or not. Base it on the MaxPayload field
        //
        
        TRACE( TL_V, TM_Send, ( "   Fragment  PacketLength %x, pVc->MaxPayload %x ", 
                                 PacketLength ,pVc->Hdr.MaxPayload) );

                                 
        //
        // Do we need to fragment. Use the number of fragments generated to figure it out
        //
        
        if (NumFragmentsNeeded == 1)
        {
            //
            // No need to fragment here. We will use the UNFRAGMENTED Layout
            //
            // First Get a local buffer from our lookaside list
            //
            PUNFRAGMENTED_BUFFER pUnfragmentedBuffer = (PUNFRAGMENTED_BUFFER )pLookasideHeader;
            PPACKET_FORMAT pDestination = (PPACKET_FORMAT)&pUnfragmentedBuffer->Data[0];
            //
            // Add the gasp header
            //
            NdisMoveMemory ((PVOID)&pDestination->AsyncStreamNonFragmented.GaspHeader, 
                            &pAdapter->GaspHeader,
                            sizeof (GASP_HEADER) );


            //
            // copy the data over,  to the location just after the Gasp Header
            // In the unfragmented case, the packet already has the correct header
            //
            NdisStatus = nicCopyNdisBufferChainToBuffer (pStartNdisBuffer, 
                                                         (PVOID)&pDestination->AsyncStreamNonFragmented.NonFragmentedHeader,
                                                         pLookasideList->MaxSendSize);
                                             
    
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK ( TM_Send, ( "   AsyncStreamSendPacketHandler, nicCopyNdisPacketToUnfragmentedBuffer Failed ") );
            }
    
            
            ASSERT (pLookasideListBuffer != NULL);

            // 
            // Initialize all the variable needed by the Next section of the code.
            // This deals with setting up the Mdl and the IRB
            //
            
            pStartNdisBuffer = NULL;

            Fragment.pStartFragment = (PVOID)pDestination;
            Fragment.FragmentLength  = PacketLength + sizeof (GASP_HEADER);
            Fragment.pCurrNdisBuffer = NULL;

            pLookasideHeader->FragmentsGenerated = 1; 
            pLookasideHeader->IsFragmented = FALSE;                                    
            
        }
        else
        {
            //
            // We need to fragment
            //
            ULONG Dgl = NdisInterlockedIncrement(&pAdapter->dgl);

            //
            // Initialize the fragment header. The unfragmented code path
            // does not care about these fields
            //
            Fragment.TxHeaderSize = sizeof (NDIS1394_FRAGMENT_HEADER) + sizeof (GASP_HEADER);
            Fragment.AsyncOp = AsyncStream;
            Fragment.pLookasideList = pLookasideList;
            Fragment.pAdapter = pAdapter;
            Fragment.pLookasideListBuffer = pLookasideListBuffer;
            Fragment.IPDatagramLength = (USHORT)PacketLength - sizeof (NDIS1394_UNFRAGMENTED_HEADER);   

            Fragment.MaxFragmentLength = pChannelVc->Hdr.MaxPayload;                                                                    
            Fragment.NumFragmentsNeeded = NumFragmentsNeeded;

            //
            // Allocate from the fragmented pool and initialize the fragment header structure
            //
            

            NdisStatus = nicFirstFragmentInitialization (pPacket->Private.Head,
                                                         Dgl,
                                                         &Fragment);


            if (pLookasideListBuffer  == NULL || NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK (TM_Send, (" AsyncStreamSendPacketsHandler: nicFirstFragmentInitialization : FAILED" )) ;
            }       

            ASSERT (pLookasideListBuffer != NULL);
            
            pLookasideHeader->IsFragmented = TRUE;                                     
                                       
            
        }


        //
        // Now begin the loop which will send n fragments
        //
        do 
        {   

            //
            // Do we need to fragment. If so , extract one fragment out of the NdisPacket
            //
            if (pLookasideHeader->IsFragmented == TRUE )
            {   
            
                //
                // We copy one fragment over and this will allocate the lookaside list
                //

                NdisStatus = nicCopyOneFragment (&Fragment);
                if (NDIS_STATUS_SUCCESS != NdisStatus)
                {
                    BREAK ( TM_Send, ( "   AsyncStreamSendPacketHandler, nicCopyOneFragment  Failed ") );
                }
                                              
                //
                // Get the pointer to the Irb here. and set it up for the next time
                //
                //
                pMyIrb = Fragment.pCurrentIrb;
                Fragment.pCurrentIrb = (PIRB)((ULONG_PTR)Fragment.pCurrentIrb + sizeof (IRB) );
                
            }
            else
            {
                //
                // No Curr NdisBuffer as this packet was never fragmented. 
                //
                
                ASSERT (pLookasideHeader->IsFragmented == FALSE);                                      

                pMyIrb =  &((PUNFRAGMENTED_BUFFER )pLookasideHeader)->Irb;
            }
            
            //
            // At this point we have one fragment that needs to be transmitted.
            // Data structures have been updated to set up the MDL and the IRB
            //

            NdisStatus = nicGetMdl (Fragment.FragmentLength  , 
                                    Fragment.pStartFragment , 
                                    &pMyMdl);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK ( TM_Send, ( "   AsyncStreamSendPacketHandler, nicCopyNdisBufferChainToBuffer Failed ") );
            }       

            nicIncChannelSendMdl()
            //
            //  Fill in the Irb with the correct values from the VC
            //  Stuff we need to add to the send VC - BlockSize,Generation
            //  

            nicInitAsyncStreamIrb((PCHANNEL_VCCB)pVc, pMyMdl, pMyIrb);

            //
            // Get a free Irp 
            //

            NdisStatus  = nicGetIrp (pAdapter->pNextDeviceObject, &pMyIrp); 
        
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                break;
            }
            //
            // At this point, we have a guarantee that the Completion routine will be called
            //

            //
            // Dump the Fragment 
            //
            nicDumpMdl (pMyMdl , 0, "AsyncStream Fragment");

            NIC1394_LOG_PKT(
                pAdapter,
                NIC1394_LOGFLAGS_SEND_CHANNEL,
                pAdapter->BCRData.LocalNodeNumber,          // SourceID
                pChannelVc->Channel,
                Fragment.pStartFragment, 
                Fragment.FragmentLength
                );

            //
            // This function implements the common functionality to be implemented by
            // all other send/recv cals to IoCallDriver
            //

            //
            // We IGNORE the NtStatus as the completion handler will be called
            //
            nicIncrementBusSends(pVc);
            
            NtStatus = nicSubmitIrp(pAdapter->pNextDeviceObject,
                                    pMyIrp,
                                    pMyIrb,
                                    AsyncWriteStreamSendComplete,
                                   (PVOID)pLookasideListBuffer);

            TRACE( TL_V, TM_Send, ( " pCurrNdisBuffer  %x, NdisStatus %x ", Fragment.pCurrNdisBuffer , NdisStatus ) );

            
            
        } while (Fragment.pCurrNdisBuffer != NULL && NdisStatus == NDIS_STATUS_SUCCESS);

    
    } while (FALSE);

    //
    // DO NOT touch the packet if status == NDIS_STATUS_SUCCESS. 
    //

    
    //
    //  CleanUp if any of the allocations failed. We do not have a pointer
    //  to the LocalBuffer (it is embedded in the Mdl)  so it remains NULL
    //
    //  NdisStatus != Success means that we never got to nicSubmitIrp
    //
    
    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {   

        ASSERT (pMyIrp == NULL);

        //
        // fVc Active makes sure that we actually got around to allocating 
        // and referencing structures
        //
        
        if (fVcActive == TRUE)
        {

            if (pLookasideListBuffer != NULL)
            {

                //
                // Complete this fragment, as we never submit'd the IRP to
                // the 1394 bus driver
                //
                AsyncWriteStreamSendComplete(NULL, // PDO
                                             NULL, 
                                             pLookasideListBuffer);

                NdisStatus =NDIS_STATUS_SUCCESS;
            }                                  
            else
            {

                //
                // This thread needs to decrement the refcounts as 
                // AsyncWriteStreamSendComplete was not called
                //
                nicDereferenceCall ((PVCCB) pVc, "AsyncStreamSendPacketsHandler");

            }

        }

    }


    

    TRACE( TL_T, TM_Send, ( "<==AsyncStreamSendPacketHandler, NdisStatus  %x", NdisStatus ) );
    MATCH_IRQL;

    //
    // Make sure this is NDIS_STATUS_PENDING if the Irp was sent down or 
    // AsyncWriteStreamSendCOmplete was called.
    //
    return NdisStatus;
}
        

NDIS_STATUS
nicEthernetVcSend(
    IN PVCCB        pVc,
    IN PNDIS_PACKET  pPacket 
    )
/*++

Routine Description:
  reroutes all sends on this VC as an CL receive
  It allocates a packet, moves the NDIS buffer chain into  the new packet
  , sets status to Resources (to force a copy) and indicates the packet upto
  the protocols.

Arguments:
    pVc Ethernet VC on which this Send came in.
    pPacket - which needs to be indicated up to the protocols.


Return Value:
    Failure if the call to Allocate an NDIS packet fails.

--*/
{

    PETHERNET_VCCB      pEthernetVc = (PETHERNET_VCCB)pVc;
    PADAPTERCB          pAdapter = pVc->Hdr.pAF->pAdapter;
    BOOLEAN             fVcActive = FALSE;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS_PACKET        pMyPacket = NULL;
    NDIS_STATUS         IndicatedStatus= NDIS_STATUS_FAILURE;
    PPKT_CONTEXT        pPktContext = NULL;
    
    TRACE( TL_T, TM_Send, ( "==>nicEthernetVcSend, pVc   %x, pPacket %x", 
                                 pVc , pPacket ) );

    do
    {

    
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        if (VC_ACTIVE (pEthernetVc)==TRUE)
        {
            fVcActive = TRUE;
            nicReferenceCall (pVc, "nicEthernetVcSend" ) ;
            
        }

        ADAPTER_RELEASE_LOCK (pAdapter);
        
        if (fVcActive == FALSE)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        nicAllocatePacket (&NdisStatus,
                       &pMyPacket ,
                       &pEthernetVc->PacketPool ); 

        if (NdisStatus != NDIS_STATUS_SUCCESS || pMyPacket == NULL)
        {
            pMyPacket = NULL;
            BREAK (TM_Send, "Ethernet VC - AllocatePacket failed" ) ;
        }


        pMyPacket->Private.Head = pPacket->Private.Head;
        pMyPacket->Private.Tail = pPacket->Private.Tail;
        

        IndicatedStatus = NDIS_STATUS_RESOURCES;
        NDIS_SET_PACKET_STATUS(pMyPacket, IndicatedStatus);

        //
        // Set up the context
        // 
        pPktContext = (PPKT_CONTEXT)&pMyPacket->MiniportReservedEx; 
        pPktContext->EthernetSend.pOrigPacket = pPacket;    

        //
        // Dump the packet
        //
        {
            nicDumpPkt (pMyPacket, "Conn Less Rcv ");
        }
        //
        // Now indicate the packet
        //

        //
        // Bluff the OOB Size. To get past an assert on debug Ndis
        //
        NDIS_SET_PACKET_HEADER_SIZE (pMyPacket, 14); 
        NdisMIndicateReceivePacket (pAdapter->MiniportAdapterHandle,
                                &pMyPacket,
                                1);
        

        
        pPktContext = (PPKT_CONTEXT)&pMyPacket->MiniportReservedEx; 
        ASSERT ( pPacket == pPktContext->EthernetSend.pOrigPacket );

        nicMpCoSendComplete (NDIS_STATUS_SUCCESS,
                             pVc,
                             pPacket);


        //
        // We have successfully pended the Io/ 
        // Now the completion routine will be called
        //
        NdisStatus = NDIS_STATUS_SUCCESS;
        

    } while (FALSE);

    if (pMyPacket != NULL)
    {
        //
        // Free the locally allcoate packet
        //
        nicFreePacket(pMyPacket, &pEthernetVc->PacketPool);
    }

    if (fVcActive == TRUE)
    {
        nicDereferenceCall (pVc, "nicEthernetVcSend" ) ;

    }



    TRACE( TL_T, TM_Send, ( "<==nicEthernetVcSend, ") );

    return NdisStatus;
}






VOID
nicGetGenerationWorkItem(
    NDIS_WORK_ITEM* pGetGenerationWorkItem,
    IN PVOID Context 
    )
    // Function Description:
    // Work Item used to submit a Get Generation IRP at Passive Level
    //
    // Arguments
    //
    // Return Value:
    //    Generation - 



{
    PVCCB               pVc = (PVCCB) Context;
    PADAPTERCB          pAdapter = pVc->Hdr.pAF->pAdapter;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    UINT                Generation = 0;

    TRACE( TL_T, TM_Mp, ( "==>nicGetGenerationWorkItem, pVc", Context ) );


    NdisStatus = nicGetGenerationCount (pAdapter , &Generation);


    //
    // Update the generation
    //
    VC_ACQUIRE_LOCK (pVc);
    
    if (NdisStatus == NDIS_STATUS_SUCCESS && Generation > *pVc->Hdr.pGeneration )
    {
        pAdapter->Generation = Generation;
    
    }
    
    VC_CLEAR_FLAGS(pVc, VCBF_GenerationWorkItem);
    
    VC_RELEASE_LOCK (pVc);

    // Dereference the call, this will allow the close call to complete. Do not touch VC after this.
    //
    nicDereferenceCall(pVc, "nicSendFailureInvalidGeneration");

    

    TRACE( TL_T, TM_Mp, ( "<==nicGetGenerationWorkItem, Gen %x", Generation) );

    FREE_NONPAGED (pGetGenerationWorkItem);
    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);

}

VOID
nicUpdatePacketState (
    IN PNDIS_PACKET pPacket,
    IN ULONG Tag
    )
/*++

Routine Description:
    Validates and then updates that packet tag. So we can heep track of the packet

Arguments:


Return Value:


--*/
{

    switch (Tag)
    {
        case NIC1394_TAG_COMPLETED:
        {

            *(PULONG)(&pPacket->MiniportReserved[0]) = NIC1394_TAG_COMPLETED;

            break;
        }

        case NIC1394_TAG_IN_SEND:
        {
            *(PULONG)(&pPacket->MiniportReserved[0]) = NIC1394_TAG_IN_SEND;
            break;      
        }

        default:
        {
            ASSERT (!"Invalid Tag on NdisPacket");
        }

    }


}




VOID
nicMpCoSendComplete (
    NDIS_STATUS NdisStatus,
    PVCCB pVc,
    PNDIS_PACKET pPacket
    )
/*++

Routine Description:
  Wrapper function around NdisMCoSendComplete

Arguments:


Return Value:


--*/
{

        nicIncrementSendCompletes (pVc);
        
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            nicIncrementVcSendPktCount(pVc, pPacket);
        }
        else
        {
            nicIncrementVcSendFailures (pVc, pPacket);
        }

        nicUpdatePacketState (pPacket, NIC1394_TAG_COMPLETED);

        NdisMCoSendComplete(NdisStatus,
                            pVc->Hdr.NdisVcHandle,
                            pPacket);


}



UINT
nicNumFragmentsNeeded (
    UINT PacketLength ,
    UINT MaxPayload,
    UINT FragmentOverhead
    )
/*++

Routine Description:

     Now account for the Fragment headers as well. A fragment header will be added 
     at the head of each fragment.  The Unfragmented header at the head of the data
     will be removed
                
                


Arguments:

    FragmentOverhead - the size of the fragment header, in the asyncstream it includes the gasp header+fragment header.
                      for asyncwrite it is just the fragmentation header

Return Value:


--*/

                
    
{

        UINT NewPacketSize; 
        UINT TotalCapacitySoFar;
        UINT NumFragmentsNeeded ;

        ASSERT (PacketLength  != 0 );
        ASSERT (MaxPayload != 0) ;
        ASSERT (FragmentOverhead != 0);

        //
        // This division takes care of the case where PacketLength 
        // is an integral multiple of the MaxPayload.  Since we add 1 to the fragment
        // it takes care of the overhead added by the fragment headers
        //
        NumFragmentsNeeded = (PacketLength / MaxPayload) + 1;

         

        //
        // If we add the fragment and gasp header to our fragments, we
        // might need another fragment due to an overflow
        //

        //
        // Calculate the new packet size after fragmentation 
        //
        {
            //
            // Add the length of the fragment headers 
            //
            NewPacketSize = PacketLength + (NumFragmentsNeeded * FragmentOverhead);

            //
            // Now remove the default non-fragment header
            //
            NewPacketSize -= sizeof (NDIS1394_UNFRAGMENTED_HEADER)   ;
        }

        //
        // 
        //
        
        TotalCapacitySoFar = NumFragmentsNeeded * MaxPayload;
        
        if ( NewPacketSize > TotalCapacitySoFar)
        {
            //
            // We'll need one more fragment
            //
            NumFragmentsNeeded ++;
        }

        return NumFragmentsNeeded ; 

}





VOID
nicCheckForEthArps (
    IN PNDIS_PACKET pPkt
    )
/*++

Routine Description:

    It will print the pkt if an eth arp or arp response goes 
    through nic1394
                
Arguments:

Return Value:


--*/
{

    PNDIS_BUFFER pBuffer;
    ULONG Len;
    ENetHeader* pENetHeader = NULL;
    PETH_ARP_PKT pArp = NULL;
    USHORT PacketType;
    USHORT opcode;
    extern ULONG g_ulDumpEthPacket ;
    do
    {

        if (g_ulDumpEthPacket == 0)
        {
            break;
        }

        pBuffer = pPkt->Private.Head;
        Len = NdisBufferLength (pBuffer);

        if (Len < sizeof (ENetHeader) )
        {
            ASSERT (Len >= sizeof (ENetHeader) );
            break;
        }

        pENetHeader = (ENetHeader*) NdisBufferVirtualAddress (pBuffer);

        if (pENetHeader == NULL)
        {
            ASSERT ( pENetHeader != NULL);
            break;
        }

        PacketType = ntohs (pENetHeader->eh_type);

        
        if (PacketType == ARP_ETH_ETYPE_IP)
        {
            break;
        }

        if (PacketType == ARP_ETH_ETYPE_ARP)
        {
            DbgPrint ("Arp Pkt - ");
        }

        pArp = (ETH_ARP_PKT*)pENetHeader;

        opcode = ntohs(pArp->opcode);

        if (opcode == ARP_ETH_REQUEST )
        {
            DbgPrint ("Request ");
        }
        else if (opcode == ARP_ETH_RESPONSE )
        {
            DbgPrint ("Response ");
        }
        else
        {
            break;
        }

        // Print the packet
        DbgPrint("\n");
 
        {

            ENetAddr    Addr;

            Addr = pArp->sender_hw_address;

            DbgPrint ("Sender Hw Addr %x %x %x %x %x %x \n",
                        Addr.addr[0],
                        Addr.addr[1],
                        Addr.addr[2],
                        Addr.addr[3],
                        Addr.addr[4],
                        Addr.addr[5]);
                        
            DbgPrint ("Ip Addr %x\n",pArp->sender_IP_address);

            Addr = pArp->target_hw_address;

            DbgPrint ("Target Hw Addr %x %x %x %x %x %x \n",
                        Addr.addr[0],
                        Addr.addr[1],
                        Addr.addr[2],
                        Addr.addr[3],
                        Addr.addr[4],
                        Addr.addr[5]);
                        
            DbgPrint ("Ip Addr %x\n",pArp->target_IP_address);

        }
        

    } while (FALSE);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\tools\ipfwadm\ini.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

	ini.c

Abstract:

	 IEEE1394 ARP Admin Utility.

	Usage:

		a13adm 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	04-10-1999	Created

--*/

#include "common.h"

BOOL
GetBinaryData(
	TCHAR *tszPathName,
	TCHAR *tszSection,
	TCHAR *tszKey,
	UCHAR *pchData,
	UINT  cbMaxData,
	UINT *pcbDataSize
	)
{
	BOOL fRet = FALSE;
	INFCONTEXT InfCtxt;
	INFCONTEXT LineCtxt;
	HINF hInf = NULL;
	UINT uLine = 0;

	do
	{

    	hInf = SetupOpenInfFile(tszPathName, NULL, INF_STYLE_WIN4, &uLine);

		if (hInf == INVALID_HANDLE_VALUE)
		{
			UINT Error = GetLastError();

			if (Error == 0xe0000100)
			{
				printf( "\nBadly formatted ini file %s\n", tszPathName);
				printf( "Make sure the file contains the following section:\n"
						"    [Version]\n"
						"    Signature=\"$CHICAGO$\"\n\n"
						);
			}
			else if (Error == 0x2)
			{
				printf("\nCould not find INI file %s\n", tszPathName);
			}
			hInf = NULL;
			break;
		}

		fRet = SetupFindFirstLine(
				hInf,
				tszSection,
				tszKey,
				&LineCtxt
				);

		if (!fRet)
		{
			printf( "\nError 0x%08lx finding key \"%s\" in section \"%s\"\n        in file %s\n",
					 GetLastError(), tszKey, tszSection, tszPathName);
			break;
		}

		fRet = SetupGetBinaryField(
				&LineCtxt,
				1,
				pchData,
				cbMaxData,
				pcbDataSize
				);

		if (!fRet)
		{
			#if 0
			printf(
				TEXT("SetupGetBinaryField fails. Err = %08lu\n"),
				GetLastError()
				);
			#endif // 0
			printf( "\nError 0x%08lx reading data from key \"%s\" in section \"%s\"\n        in file %s\n",
					 GetLastError(), tszKey, tszSection, tszPathName);
			break;
		}

	} while (FALSE);

    if (hInf != NULL)
	{
        SetupCloseInfFile(hInf);
		hInf = NULL;
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarp\aac.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	aas.c

Abstract:

	ATM ARP Admin Utility.

	Usage:

		atmarp 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	06-10-1998	Created (adapted from atmlane admin utility).

Notes:

	Modelled after atmlane utility.

--*/

#include "common.h"
#include "..\atmarpc\ioctl.h"
#include "atmmsg.h"


#define MAX_ATMARPC_ADAPTERS	64
#define MAX_ATMARPC_LISS		64
#define MAX_ATMARPC_NAME_LEN	256
#define MAX_ATMARPC_ARP_ENTRIES	4096
#define MAX_ATMARPC_CONNECTIONS	4096

//
//	Globals
//
static CHAR							DefaultDeviceName[] =  "\\\\.\\ATMARPC";
static CHAR							*pDeviceName = DefaultDeviceName;

BOOLEAN
AACCheckVersion(
	HANDLE		DeviceHandle
)
{
	ULONG						Version;
	ULONG						BytesReturned;

	printf("In AACCheckversion\n");
	if (!DeviceIoControl(
				DeviceHandle,
				ARPC_IOCTL_QUERY_VERSION,
				(PVOID)&Version,
				sizeof(Version),
				(PVOID)&Version,
				sizeof(Version),
				&BytesReturned,
				0))
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ARPC_VERSION_INFO);
		return FALSE;
	}	

	if (Version != ARPC_IOCTL_VERSION)
	{
		DisplayMessage(FALSE, MSG_ERROR_INVALID_ARPC_INFO_VERSION);
		return FALSE;
	}

	return TRUE;
}

	
void
DoAAC(OPTIONS *po)
{
	HANDLE	DeviceHandle;
	char 	InterfacesBuffer[1024];
	ULONG		cbInterfaces = sizeof(InterfacesBuffer);


	DisplayMessage(FALSE, MSG_ARPC_BANNER);

	DeviceHandle = OpenDevice(pDeviceName);
	if (DeviceHandle == INVALID_HANDLE_VALUE)
	{
		DisplayMessage(FALSE, MSG_ERROR_OPENING_ARPC);
		return;
	}

	//
	//	First check the version
	//
	if (!AACCheckVersion(DeviceHandle))
	{
		CloseDevice(DeviceHandle);
		return;
	}

	CloseDevice(DeviceHandle);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarp\externs.h ===
//
//	Private types
//
typedef struct {
	DWORD				Message;
	LPSTR				String;
} MESSAGE_STRING, *PMESSAGE_STRING;

#define MSG_NO_MESSAGE			0


typedef struct
{
	BOOL DispStats;
	BOOL DispCache;
	BOOL DoResetStats;

} OPTIONS;

//
//  LoadMessageTable
//
//  Loads internationalizable strings into a table, replacing the default for
//  each. If an error occurs, the English language default is left in place.
//
//
VOID
LoadMessageTable(
	PMESSAGE_STRING	Table,
	UINT MessageCount
);

VOID
DisplayMessage(
	IN	BOOLEAN			Tabbed,
	IN	DWORD			MessageId,
	...
);


HANDLE
OpenDevice(
	CHAR	*pDeviceName
);



VOID
CloseDevice(
	HANDLE		DeviceHandle
);

void DoAAS(OPTIONS *po);
void DoAAC(OPTIONS *po);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarp\common.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	common.h

Abstract:

	ATM ARP Admin Utility.

	Usage:

		atmarp 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	06-10-1998	Created (adapted from atmlane admin utility).

Notes:

	Modelled after atmlane utility.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <winerror.h>
#include <winsock.h>

#include <ntddndis.h>
#include <atm.h>

#include "externs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarp\aas.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	aas.c

Abstract:

	ATM ARP Admin Utility.

	Usage:

		atmarp 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	06-10-1998	Created (adapted from atmlane admin utility).

Notes:

	Modelled after atmlane utility.

--*/

#include "common.h"
#include "..\atmarps\arp.h"
#include "..\atmarps\ioctl.h"
#include "atmmsg.h"


//
//	Globals
//
static CHAR							DefaultDeviceName[] =  "\\\\.\\AtmArpServer";
static CHAR							*pDeviceName = DefaultDeviceName;


//
//  LoadMessages - courtesy IPCONFIG
//
//  Loads all internationalizable messages into the various tables
//
VOID
LoadMessages(
)
{
}


BOOL
CheckVersion(
	HANDLE		DeviceHandle
)
{
    return TRUE;
}


BOOL
AasGetInterfaces(
	HANDLE		DeviceHandle,
	PINTERFACES pInterfaces,
	ULONG		cbInterfaces
)
{
	ULONG		BytesReturned;
	BOOL		Result = FALSE;

	if (DeviceIoControl(
				DeviceHandle,
				ARPS_IOCTL_QUERY_INTERFACES,
				(PVOID)pInterfaces,
				cbInterfaces,
				(PVOID)pInterfaces,
				cbInterfaces,
				&BytesReturned,
				0))
	{
		UINT u = pInterfaces->NumberOfInterfaces;
		//
		// Fixup pointers
		//
		for (u=0;u<pInterfaces->NumberOfInterfaces;u++)
		{
			INTERFACE_NAME *pInterface = (pInterfaces->Interfaces)+u;
			pInterface->Buffer = (PWSTR)(  (ULONG_PTR)pInterface->Buffer
								 		 + (PUCHAR)pInterface);

			//
			// check that all this is valid...
			//
			if (   ((PUCHAR)pInterface->Buffer < (PUCHAR) pInterface)
				|| (   ((PUCHAR)pInterface->Buffer + pInterface->Length)
					 > ((PUCHAR)pInterfaces + cbInterfaces)))
			{
				printf("WHOA THERE!\n");
				DebugBreak();
			}
			else
			{
			#if 0
				printf("INTERFACE: Len=%lu, Name=\"%c%c%c%c...\n",
					pInterface->Length,
					pInterface->Buffer[0],
					pInterface->Buffer[1],
					pInterface->Buffer[2],
					pInterface->Buffer[3]
					);
			#endif // 0
			}
		}

		Result = TRUE;
	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_INTERFACE_LIST);
	}

	return Result;
}


BOOL
AasGetArpCache(
	HANDLE			DeviceHandle,
	INTERFACE_NAME *pInterface,
	PIOCTL_QUERY_CACHE
					pArpCache,
	ULONG			cbArpCache
)
{
	ULONG		BytesReturned;
	BOOL		Result = FALSE;
	UINT		BufferOffset;

	BufferOffset = FIELD_OFFSET(struct QUERY_ARP_CACHE_INPUT_PARAMS, Name) +
						sizeof(pArpCache->Name);
	pArpCache->Name.Buffer = (PWSTR)sizeof(pArpCache->Name);
	pArpCache->Name.Length = pInterface->Length;
	pArpCache->Name.MaximumLength = pInterface->MaximumLength;
	memcpy((PUCHAR)pArpCache + BufferOffset,
			pInterface->Buffer,
			pInterface->MaximumLength);

	Result =	DeviceIoControl(
					DeviceHandle,
					ARPS_IOCTL_QUERY_ARPCACHE,
					(PVOID)pArpCache,
					BufferOffset + pInterface->Length,
					(PVOID)pArpCache,
					cbArpCache,
					&BytesReturned,
					NULL);

	if (Result)
	{
	#if 0
		printf(
			"DeviceIoCtl: cbRet = %lu, cArps=%lu, cArpsInBuf=%lu\n",
			BytesReturned,
			pArpCache->Entries.TotalNumberOfEntries,
			pArpCache->Entries.NumberOfEntriesInBuffer
			);
	#endif // 0

	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ARP_CACHE);
	}

	return Result;
}

BOOL
AasGetMarsCache(
	HANDLE			DeviceHandle,
	INTERFACE_NAME *pInterface,
	PIOCTL_QUERY_MARS_CACHE
					pMarsCache,
	ULONG			cbMarsCache
)
{
	ULONG		BytesReturned;
	BOOL		Result = FALSE;
	UINT		BufferOffset;

	BufferOffset = FIELD_OFFSET(struct QUERY_MARS_CACHE_INPUT_PARAMS, Name) +
						sizeof(pMarsCache->Name);

	pMarsCache->Name.Buffer = (PWSTR)sizeof(pMarsCache->Name);
	pMarsCache->Name.Length = pInterface->Length;
	pMarsCache->Name.MaximumLength = pInterface->MaximumLength;
	memcpy((PUCHAR)pMarsCache + BufferOffset,
			pInterface->Buffer,
			pInterface->MaximumLength);

	Result =	DeviceIoControl(
					DeviceHandle,
					ARPS_IOCTL_QUERY_MARSCACHE,
					(PVOID)pMarsCache,
					BufferOffset + pInterface->Length,
					(PVOID)pMarsCache,
					cbMarsCache,
					&BytesReturned,
					NULL);

	if (Result)
	{
	#if 0
		printf(
			"DeviceIoCtl: cbRet = %lu, Sig=0x%lx, cMars=%lu, cMarsInBuf=%lu\n",
			BytesReturned,
			pMarsCache->MarsCache.Sig,
			pMarsCache->MarsCache.TotalNumberOfEntries,
			pMarsCache->MarsCache.NumberOfEntriesInBuffer
			);
	#endif // 0

	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_MARS_CACHE);
	}

	return Result;
}

BOOL
AasGetArpStats(
	HANDLE			DeviceHandle,
	INTERFACE_NAME *pInterface,
	PARP_SERVER_STATISTICS
					pArpStats
)
{
	ULONG		BytesReturned;
	BOOL		Result = FALSE;

	// printf ( " In AasGetArpStats\n");

	//
	// Temporarily fixup buffer pointer
	//
	pInterface->Buffer = (PWSTR)(  (PUCHAR)pInterface->Buffer
								- (PUCHAR)pInterface);

	Result =	DeviceIoControl(
					DeviceHandle,
					ARPS_IOCTL_QUERY_ARP_STATISTICS,
					(PVOID)pInterface,
					(UINT) (((ULONG_PTR)pInterface->Buffer)+pInterface->Length),
					(PVOID)pArpStats,
					sizeof(*pArpStats),
					&BytesReturned,
					NULL);

	//
	// Restore buffer pointer
	//
	pInterface->Buffer = (PWSTR)(  (ULONG_PTR)pInterface->Buffer
								+ (PUCHAR)pInterface);

	if (Result)
	{
	#if 0
		printf(
			"DeviceIoCtl: cbRet = %lu, TotRcvPkts=%lu\n",
			BytesReturned,
			pArpStats->TotalRecvPkts
			);
	#endif // 0

	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ARP_STATS);
	}

	return Result;
}

BOOL
AasGetMarsStats(
	HANDLE			DeviceHandle,
	INTERFACE_NAME *pInterface,
	PMARS_SERVER_STATISTICS
					pMarsStats
)
{
	ULONG		BytesReturned;
	BOOL		Result = FALSE;

	// printf ( " In AasGetMarsStats\n");

	//
	// Temporarily fixup buffer pointer
	//
	pInterface->Buffer = (PWSTR)(  (PUCHAR)pInterface->Buffer
								- (PUCHAR)pInterface);

	Result =	DeviceIoControl(
					DeviceHandle,
					ARPS_IOCTL_QUERY_MARS_STATISTICS,
					(PVOID)pInterface,
					(UINT) (((ULONG_PTR)pInterface->Buffer)+pInterface->Length),
					(PVOID)pMarsStats,
					sizeof(*pMarsStats),
					&BytesReturned,
					NULL);

	//
	// Restore buffer pointer
	//
	pInterface->Buffer = (PWSTR)(  (ULONG_PTR)pInterface->Buffer
								+ (PUCHAR)pInterface);

	if (Result)
	{
	#if 0
		printf(
			"DeviceIoCtl: cbRet = %lu, TotRcvPkts=%lu\n",
			BytesReturned,
			pMarsStats->TotalRecvPkts
			);
	#endif // 0

	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_MARS_STATS);
	}

	return Result;
}

BOOL
AasResetStatistics(
	HANDLE			DeviceHandle,
	INTERFACE_NAME *pInterface
)
{
	ULONG		BytesReturned;
	BOOL		Result = FALSE;

	//
	// Temporarily fixup buffer pointer
	//
	pInterface->Buffer = (PWSTR)(  (PUCHAR)pInterface->Buffer
								- (PUCHAR)pInterface);

	Result =	DeviceIoControl(
					DeviceHandle,
					ARPS_IOCTL_RESET_STATISTICS,
					(PVOID)pInterface,
					(UINT) (((ULONG_PTR)pInterface->Buffer)+pInterface->Length),
					NULL,
					0,
					&BytesReturned,
					NULL);

	//
	// Restore buffer pointer
	//
	pInterface->Buffer = (PWSTR)(  (ULONG_PTR)pInterface->Buffer
								+ (PUCHAR)pInterface);

	if (Result)
	{
		DisplayMessage(FALSE, MSG_STATS_RESET_STATS);
	#if 0
		printf(
			"DeviceIoCtl: cbRet = %lu, TotRcvPkts=%lu\n",
			BytesReturned,
			pMarsStats->TotalRecvPkts
			);
	#endif // 0

	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_RESETTING_STATS);
	}

	return Result;
}


#if 0

LPSTR
ElanStateToString(ULONG In)
{
	switch(In)
	{
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
			return (ElanState[In].String);
		default:
			return (ElanState[0].String);
	}
}


LPSTR
ElanLanTypeToString(ULONG In)
{
	switch(In)
	{
		case 0:
			return LanType[1].String;
		case 1:
			return LanType[2].String;
		case 2:
			return LanType[3].String;
		default:
			return LanType[0].String;
	}
}

LPSTR
ElanMaxFrameSizeToString(ULONG In)
{
	switch(In)
	{	
		case 0:
			return Misc[3].String;
		case 1:
			return "1516";
		case 2:
			return "4544";
		case 3:
			return "9234";
		case 4:
			return "18190";
		default:
			return " ? ";
	}
}

LPSTR
McastVcTypeToString(ULONG In)
{
	switch(In)
	{	
		case 0:
			return McastSendVcType[1].String;
		case 1:
			return McastSendVcType[2].String;
		case 2:
			return McastSendVcType[3].String;
		default:
			return McastSendVcType[0].String;
	}
}

PUCHAR
MacAddrToString(PVOID In)
    {
    static UCHAR String[20];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR EthAddr = (PUCHAR) In;
    UINT i;
    PUCHAR s;
    
    for (i = 0, s = String; i < 6; i++, EthAddr++)
        {
        *s++ = HexChars[(*EthAddr)>>4];
        *s++ = HexChars[(*EthAddr)&0xf];
        *s++ = '.';
        }
    *(--s) = '\0';
    return String; 
    }
#endif // 0


PUCHAR
IpAddrToString(IPADDR		*pIpAddr)
{
	PUCHAR puc = (PUCHAR) pIpAddr;
    static UCHAR String[80];
    wsprintf(String, "%u.%u.%u.%u", puc[0], puc[1], puc[2], puc[3]);
    return String; 
}

PUCHAR
AtmAddrToString(ATM_ADDRESS *pAtmAddress)
{
    static UCHAR String[80];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR AtmAddr = (PUCHAR) &(pAtmAddress->Address);
    PUCHAR s = String;

    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 1
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 2
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 3
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 4
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 5
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 6
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 7
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 8
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 9
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 10
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 11
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 12
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 13
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 14
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 15
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 16
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 17
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 18
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 19
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 20
    *s = '\0';
    return String; 
}


VOID
AasDisplayArpCache(
	PIOCTL_QUERY_CACHE pArpCache
)
{
	PARPENTRY			pEntry = pArpCache->Entries.Entries;
	UINT i;

	for (i = 0; i < pArpCache->Entries.NumberOfEntriesInBuffer; i++)
	{
		DisplayMessage(FALSE, MSG_AAS_ARP_CACHE_ENTRY,
			IpAddrToString(&(pEntry->IpAddr)),
			AtmAddrToString(&pEntry->AtmAddress));

		pEntry ++;
	}

}

VOID
AasDisplayMarsCache(
	PIOCTL_QUERY_MARS_CACHE pMarsCache
)
{

	PMARSENTRY			pEntry = pMarsCache->MarsCache.Entries;
	UINT i;

	for (i = 0;
		 i < pMarsCache->MarsCache.NumberOfEntriesInBuffer;
		 i++, pEntry++)
	{
		UINT j;
		char* szIpAddr =  IpAddrToString(&(pEntry->IpAddr));
		char  rgBlanks[128];

		ATM_ADDRESS *pAtmAddr = (ATM_ADDRESS*)
								((PUCHAR)pEntry + pEntry->OffsetAtmAddresses);

		FillMemory(rgBlanks, lstrlen(szIpAddr), ' ');
		rgBlanks[lstrlen(szIpAddr)]=0;
	#if 0
		printf("Entry[i] @ 0x%lx: Ip=%u.%u.%u.%u NumAddr=%lu Offset=%lu\n",
					pEntry,
					((PUCHAR)&pEntry->IpAddr)[0],
					((PUCHAR)&pEntry->IpAddr)[1],
					((PUCHAR)&pEntry->IpAddr)[2],
					((PUCHAR)&pEntry->IpAddr)[3],
					pEntry->NumAtmAddresses,
					pEntry->OffsetAtmAddresses);
	#endif // 0


		for (j = 0;
			 j < pEntry->NumAtmAddresses;
			 j++, pAtmAddr++)
		{
			// printf("\t pAddr=%lx\n", pAtmAddr);

			if (!j)
			{
				if (pEntry->IpAddr == 0)
				{
					DisplayMessage(FALSE, MSG_AAS_ARP_PROMIS_CACHE_ENTRY,
						AtmAddrToString(pAtmAddr));
				}
				else
				{
					DisplayMessage(FALSE, MSG_AAS_ARP_CACHE_ENTRY,
						IpAddrToString(&(pEntry->IpAddr)),
						AtmAddrToString(pAtmAddr));
				}

			}
			else
			{
				DisplayMessage(FALSE, MSG_AAS_ARP_CACHE_ENTRY,
					rgBlanks,
					AtmAddrToString(pAtmAddr));
			}
		}

	}

}

VOID
AasDisplayArpStats(
	PARP_SERVER_STATISTICS pArpStats
)
{
#if 0
    Recvd Pkts: ->TotalRecvPkts 			(->DiscardedRecvPkts discarded)
	Arp Entries:	->CurrentArpEntries current	( ->MaxArpEntries max)
    Arp Responses: ->Acks acks  ( ->Naks naks)
    Client VCs: ->CurrentClientVCs current (->MaxClientVCs max)
    Incoming Calls: ->TotalIncomingCalls total (->FailedIncomingCalls failed)

      Received: 10000 	total		(100 discarded)
	   Entries: 10		current		(15  max)
     Responses: 1000 	acks 		(200 naks)
    Client VCs: 5 		current 	(12  max)
Incoming Calls: 500 	total 		(20  failed)
#endif //

	DisplayMessage(FALSE,  MSG_AAS_C01_ARP_STATS);

	DisplayMessage(FALSE, MSG_STATS_ELAPSED_TIME, 	pArpStats->ElapsedSeconds);
	DisplayMessage(FALSE, MSG_ARPS_RECVD_PKTS, 		pArpStats->TotalRecvPkts,
													pArpStats->DiscardedRecvPkts);
	DisplayMessage(FALSE, MSG_ARPS_ARP_ENTRIES, 	pArpStats->CurrentArpEntries,
													pArpStats->MaxArpEntries);
	DisplayMessage(FALSE, MSG_ARPS_ARP_RESPONSES, 	pArpStats->Acks,
													pArpStats->Naks);
	DisplayMessage(FALSE, MSG_ARPS_CLIENT_VCS, 		pArpStats->CurrentClientVCs,
													pArpStats->MaxClientVCs);
	DisplayMessage(FALSE, MSG_ARPS_INCOMING_CALLS, 	pArpStats->TotalIncomingCalls);
													// pArpStats->TotalActiveVCs
}

VOID
AasDisplayMarsStats(
	PMARS_SERVER_STATISTICS pMarsStats
)
{
	DisplayMessage(FALSE,  MSG_AAS_C02_MARS_STATS);

	DisplayMessage(FALSE, MSG_MARS_RECVD_PKTS, 		pMarsStats->TotalRecvPkts,
													pMarsStats->DiscardedRecvPkts);
	DisplayMessage(FALSE, MSG_MARS_RECVD_MCDATA_PKTS,pMarsStats->TotalMCDataPkts,
													pMarsStats->DiscardedMCDataPkts,
													pMarsStats->ReflectedMCDataPkts);
	DisplayMessage(FALSE, MSG_MARS_MEMBERS, 		pMarsStats->CurrentClusterMembers,
													pMarsStats->MaxClusterMembers);
	DisplayMessage(FALSE, MSG_MARS_PROMIS, 			pMarsStats->CurrentPromiscuous,
    												pMarsStats->MaxPromiscuous);
	DisplayMessage(FALSE, MSG_MARS_ADD_PARTY, 		pMarsStats->TotalCCVCAddParties,
													pMarsStats->FailedCCVCAddParties);
	DisplayMessage(FALSE, MSG_MARS_REGISTRATION,	pMarsStats->RegistrationRequests,
													pMarsStats->FailedRegistrations);
	DisplayMessage(FALSE, MSG_MARS_JOINS,	 		pMarsStats->TotalJoins,
													pMarsStats->FailedJoins,
													pMarsStats->DuplicateJoins);
	DisplayMessage(FALSE, MSG_MARS_LEAVES,	 		pMarsStats->TotalLeaves,
													pMarsStats->FailedLeaves);
	DisplayMessage(FALSE, MSG_MARS_REQUESTS, 		pMarsStats->TotalRequests);
	DisplayMessage(FALSE, MSG_MARS_RESPONSES,	 	pMarsStats->VCMeshAcks
												    +pMarsStats->MCSAcks,
												    pMarsStats->Naks);
	DisplayMessage(FALSE, MSG_MARS_VC_MESH,	 		pMarsStats->SuccessfulVCMeshJoins,
												    pMarsStats->VCMeshAcks);
	DisplayMessage(FALSE, MSG_MARS_GROUPS,	 		pMarsStats->CurrentGroups,
    												pMarsStats->MaxGroups);
	DisplayMessage(FALSE, MSG_MARS_GROUP_SIZE,	 	pMarsStats->MaxAddressesPerGroup);

}


	
void
DoAAS(OPTIONS *po)
{
	HANDLE	DeviceHandle;
	char 	InterfacesBuffer[1024];
	PINTERFACES pInterfaces = (PINTERFACES) InterfacesBuffer;
	ULONG		cbInterfaces = sizeof(InterfacesBuffer);


#if 0
	PUNICODE_STRING				pAdapterName;
	PUNICODE_STRING				pElanName;
	ULONG						i, j;
	BOOL						Result;
#endif // 0
	
	DisplayMessage(FALSE, MSG_ATMARPS_BANNER);

	DeviceHandle = OpenDevice(pDeviceName);
	if (DeviceHandle == INVALID_HANDLE_VALUE)
	{
		DisplayMessage(FALSE, MSG_ERROR_OPENING_ATMARPS);
		return;
	}

	//
	//	First check the version
	//
	if (!CheckVersion(DeviceHandle))
	{
		CloseDevice(DeviceHandle);
		return;
	}

	//
	//	get the list of available adapters
	//
	if (!AasGetInterfaces(DeviceHandle, pInterfaces, cbInterfaces))
	{
		CloseDevice(DeviceHandle);
		return;
	}

	// printf ( " Looping through interfaces...\n");
	//
	//	Loop thru the interfaces, displaying info about each.
	//
	{
		UINT u=0;

		for (u=0;u<pInterfaces->NumberOfInterfaces;u++)
		{
			CHAR 	Buffer[4000];
			ULONG	cbBuffer = sizeof(Buffer);
			PIOCTL_QUERY_CACHE pArpCache
								 = (PIOCTL_QUERY_CACHE) Buffer;
			PIOCTL_QUERY_MARS_CACHE pMarsCache
								 = (PIOCTL_QUERY_MARS_CACHE) Buffer;
			INTERFACE_NAME *pInterface = (pInterfaces->Interfaces)+u;
			PARP_SERVER_STATISTICS  pArpStats  = (PARP_SERVER_STATISTICS)  Buffer;
			PMARS_SERVER_STATISTICS pMarsStats = (PMARS_SERVER_STATISTICS) Buffer;
			UINT		StartIndex;

			//
			// Display the interface name -- must be null terminated.
			//
			{
				WCHAR *pwc = pInterface->Buffer+pInterface->Length/sizeof(WCHAR);
				WCHAR wc = *pwc;
				*pwc = 0;
				DisplayMessage(FALSE, MSG_ADAPTER, pInterface->Buffer );
				*pwc = wc;
			}

			if (po->DispCache)
			{
				StartIndex = pArpCache->StartEntryIndex = 0;

				DisplayMessage(FALSE,  MSG_AAS_C00_ARP_CACHE);

				while (AasGetArpCache(DeviceHandle, pInterface, pArpCache, cbBuffer) &&
						pArpCache->Entries.NumberOfEntriesInBuffer)
				{
					AasDisplayArpCache(pArpCache);
					StartIndex += pArpCache->Entries.NumberOfEntriesInBuffer;
					pArpCache->StartEntryIndex = StartIndex;
					if (StartIndex == pArpCache->Entries.TotalNumberOfEntries)
					{
						break;
					}
				}
	
				StartIndex = pMarsCache->StartEntryIndex = 0;

				DisplayMessage(FALSE,  MSG_AAS_C00_MARS_CACHE);

				while (AasGetMarsCache(DeviceHandle, pInterface, pMarsCache, cbBuffer) &&
						pMarsCache->MarsCache.NumberOfEntriesInBuffer)
				{
					AasDisplayMarsCache(pMarsCache);
					StartIndex += pMarsCache->MarsCache.NumberOfEntriesInBuffer;
					pMarsCache->StartEntryIndex = StartIndex;
				}
			}

			if (po->DispStats)
			{
				if (AasGetArpStats(DeviceHandle, pInterface, pArpStats))
				{
					AasDisplayArpStats(pArpStats);
				}
	
				if (AasGetMarsStats(DeviceHandle, pInterface, pMarsStats))
				{
					AasDisplayMarsStats(pMarsStats);
				}
			}

			if (po->DoResetStats)
			{
				AasResetStatistics(DeviceHandle, pInterface);
			}
		}
	}

#if 0
	//
	//	Loop thru the adapters getting each adapter's elan list
	//
	pAdapterName = &pAdapterList->AdapterList;
	for (i = 0; i < pAdapterList->AdapterCountReturned; i++)
	{
		DisplayMessage(FALSE, MSG_ADAPTER, 
			(PWSTR)((PUCHAR)pAdapterName + sizeof(UNICODE_STRING)));

		if (GetElanList(DeviceHandle, pAdapterName))
		{

			//
			//	Loop thru the elan list getting ELAN info
			//
			pElanName = &pElanList->ElanList;
			for (j = 0; j < pElanList->ElanCountReturned; j++)
			{
				DisplayMessage(FALSE, MSG_ELAN, 
					(PWSTR)((PUCHAR)pElanName + sizeof(UNICODE_STRING)));

				if (GetElanInfo(DeviceHandle, pAdapterName, pElanName))
				{
					DisplayElanInfo();
				}

				if (GetElanArpTable(DeviceHandle, pAdapterName, pElanName))
				{
					DisplayElanArpTable();
				}

				if (GetElanConnTable(DeviceHandle, pAdapterName, pElanName))
				{
					DisplayElanConnTable();
				}

				//
				//	next elan
				//
				pElanName = (PUNICODE_STRING)((PUCHAR)pElanName +
						sizeof(UNICODE_STRING) + pElanName->Length);
			}

		}

		//
		//	next adapter
		//
		pAdapterName = (PUNICODE_STRING)((PUCHAR)pAdapterName +
				sizeof(UNICODE_STRING) + pAdapterName->Length);
	}
#endif // 0

	CloseDevice(DeviceHandle);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\tools\ipfwadm\ipfwadm.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

	ipfwadm.c	-- actually calls down the the ip/1394 arp module.

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	04-12-1999	Created

--*/

#include "common.h"


#define NUM_ARPENTRIES_TO_GET 10
#define PROGRAM "ipfwadm"

typedef struct
{
	ARP1394_IOCTL_COMMAND Cmd;

	// MUST IMMEDIATELY follow Cmd -- space for Cmd.GetArpCache.Entries
	//
	ARP1394_ARP_ENTRY Reserved[NUM_ARPENTRIES_TO_GET];

} OPTIONS;


HANDLE
OpenDevice(
	CHAR	*pDeviceName
);


VOID
CloseDevice(
	HANDLE		DeviceHandle
);

BOOL
ParseCmdLine(
	int argc, 
	char * argv[]
	);

BOOL
ParseIpAddress(
	PCHAR 	buf,
	PULONG	pIpAddress
	);

BOOL
ParseHwAddress(
	PCHAR 						buf,
	PARP1394_IOCTL_HW_ADDRESS	pHwAddr
	);

BOOL
ValidateCommand(PARP1394_IOCTL_COMMAND pCmd);

BOOL
ParsePacket(
	PCHAR buf,
	UCHAR *data,
	UINT  cbData,
	UINT *pcbPacketSize
	);

BOOL
ParseAdapter(
	PCHAR buf,
	UCHAR *data,
	UINT  cbData,
	UINT *pcbAdapterSize
	);

OPTIONS g;

void 
Usage(void);
	
VOID __cdecl
main(
	INT			argc,
	CHAR		*argv[]
)
{

	//
	// Parse args, determine if this is concerns the arp client or server.
	//
	if (!ParseCmdLine(argc, argv))
	{
		return;
	}

	DoCmd(&g.Cmd);

}

void 
Usage(void)
{
	//
	// Also hidden compat options: -s, -d, -g
	//

	printf( "\nWindows 2000 IP/1394 Utility\n\n");

	printf(
		PROGRAM " -a\n"
		PROGRAM " -add inet_addr hw_addr      [-n if_addr]\n"
		PROGRAM " -del inet_addr              [-n if_addr]\n"
		PROGRAM " -stats [arp|call|pkts|tsks] [-n if_addr]\n"
		PROGRAM " -resetstats                 [-n if_addr]\n"
		PROGRAM " -purgecache                 [-n if_addr]\n"
		PROGRAM " -reinit                     [-n if_addr]\n"
		PROGRAM " -send  pkt                  [-n if_addr]\n"
		PROGRAM " -recv  pkt                  [-n if_addr]\n"
		PROGRAM " -bstart  adapter\n"
		PROGRAM " -bstop   adapter\n"
		PROGRAM " -nicinfo [a|n node|c channel|reset]   [-n if_addr]\n"
		PROGRAM " --                          [-n if_addr]\n"
		PROGRAM " -euidmap\n"
		"\n"
		);

	printf(
"  -a            Displays current ARP entries. If more than one ip/1394 network\n"
"                interface exist, entries for each ARP table are displayed.\n"
		);

	printf(
"  -add          Adds the host and associates the Internet address inet_addr\n"
"                with the Physical address hw_addr. The entry is permanent.\n"
		);

	printf(
"  -del          Deletes the host specified by inet_addr.\n"
		);

	printf(
"  -stats        Displays arp/call/packet/task statistics.\n"
		);

	printf(
"  -resetstats   Resets statistics collection.\n"
		);

	printf(
"  -purgecache   Deletes all dynamic arp entries.\n"
		);

	printf(
"  -reinit       Deactivates and then reactivates the interface.\n"
		);

	printf(
"  -send pkt     Sends the specified packet on the broadcast channel.\n"
		);

	printf(
"  -recv pkt     Simulates a receive of the specified packet on the.\n"
"                broadcast channel.\n"
		);

	printf(
"  -nicinfo      Displays information about the 1394 network adapter.\n"
"                    -a        displays adapter-wide information\n"
"                    -n node   displays information about the node with node ID \"node\"\n"
"                    -c channel   displays information about channel \"channel\"\n"
		);

	printf(
"  -bstart adapter    Starts Ethernet emulation (bridging) on the specified adapter.\n"
		);

	printf(
"  -bstop adapter     Stops Ethernet emulation (bridging) on the specified adapter.\n"
		);

	printf(
"  --            Takes commands from standard input. Commands are options\n"
"                without the '-' prefix. Use ^C or 'q' to exit the program.\n"
		);

	printf(
"  -n if_addr    Displays information for the network interface specified\n"
"                by if_addr.  If not present, the first applicable interface will\n"
"                be used.\n"
		);

	printf(
"  inet_addr     Specifies an internet address.\n"
		);

	printf(
"  hw_addr       Specifies a physical address (64-bit Unique ID). The Physical\n"
"                address is given as 8 hexadecimal bytes separated by hyphens.\n"
		);

	printf(
"  pkt           Specifies the key name under the [Packets] section of\n"
"                " PROGRAM ".INI. The value of the key contains the packet data.\n"
		);

	printf(
"  euidmap		Prints The Euid, Node Address and Fake Mac Address \n"
"               assigned to a Remote Node\n"
		);
	
	printf(
"\nExample:\n"
"  > " PROGRAM " -s 157.55.85.212   00-aa-00-62-c6-09-01-02  .... Adds a static entry.\n"
"  > " PROGRAM " -a                                          .... Displays the arp table.\n"
"  > " PROGRAM " -stats arp -n 10.0.0.1                      .... Displays arp statistics\n"
"                                                           for interface 10.0.0.1.\n"
		);

}

UINT FindOption(
	char *lptOpt, 
	char **ppVal,
	BOOL fCmdLine
	);

enum
{
	DO_DISP_HELP,
	DO_GET_ARPCACHE,
	DO_ADD_ARPENTRY,
	DO_DEL_ARPENTRY,
	DO_GET_STATS,
	DO_RESET_STATS,
	DO_REINIT_IF,
	DO_SWITCH_TO_STDIN,
	DO_SPECIFIC_IF,
	DO_GET_NICINFO,

	DO_X_ARP,
	DO_X_CALL,
	DO_X_TSKS,
	DO_X_PKTS,
	DO_X_ALL,

	DO_NI_CHANNELINFO,


    DO_BSTART,
    DO_BSTOP,
	DO_EUIDMAP,
	UNKNOWN_OPTION,

    // Put the at the end
    //
	DO_NI_BUSINFO = DO_GET_ARPCACHE, // Because both are "a"
	DO_NI_NODEINFO = DO_SPECIFIC_IF,
};

struct _CmdOptions {
    char *  lptOption;
    UINT    uOpt;
} CmdOptions[]    =
{
	{"?"			, DO_DISP_HELP		    },
	{"a"			, DO_GET_ARPCACHE		}, // Also DO_NI_BUSINFO
	{"s"			, DO_ADD_ARPENTRY		},
	{"g"			, DO_ADD_ARPENTRY		},
	{"add"			, DO_ADD_ARPENTRY		},
	{"del"			, DO_DEL_ARPENTRY		},
	{"stats"		, DO_GET_STATS			},
	{"resetstats"	, DO_RESET_STATS		},
	{"reinit"		, DO_REINIT_IF			},
	{"-"			, DO_SWITCH_TO_STDIN	},
	{"n"			, DO_SPECIFIC_IF		}, // Also DO_NI_NODEINFO
	{"nicinfo"		, DO_GET_NICINFO		},
	{"bstart"		, DO_BSTART		},
	{"bstop"		, DO_BSTOP		},
	{"euidmap"		, DO_EUIDMAP   },

	// Following are sub-options of /stats...
	//
	{"arp"			, DO_X_ARP				},
	{"call"			, DO_X_CALL				},
	{"tsks"			, DO_X_TSKS				},
	{"pkts"			, DO_X_PKTS				},
	{"pkt"			, DO_X_PKTS				},

	// Following are sub-options of /nicinfo...
	//
	// {"b"			, DO_NI_BUSINFO			},
	// {"n"			, DO_NI_NODEINFO		},
	{"c"			, DO_NI_CHANNELINFO		}
};

INT iCmdOptionsCounts = sizeof(CmdOptions)/sizeof(struct _CmdOptions);


BOOL
ParseCmdLine(
	int argc, 
	char * argv[]
	)
{
	BOOL	bRetVal = TRUE;
	int		iIndx=1;
	UINT	uOpt;
	char	*pVal;

	ZeroMemory(&g.Cmd, sizeof(g.Cmd));
	ZeroMemory(&g.Reserved, sizeof(g.Reserved));

	while(bRetVal && iIndx < argc)
	{
		
		uOpt = FindOption(argv[iIndx++], &pVal, TRUE);

		switch(uOpt)
		{
	
		case DO_GET_ARPCACHE:
			//
			// "arp13 -a\n"
			//
			{
				PARP1394_IOCTL_GET_ARPCACHE pGetCacheCmd =  &g.Cmd.GetArpCache;

				if (argc != 2)
				{
					printf("Too many arguments for '-a'\n");
					bRetVal = FALSE;
					break;
				}

				pGetCacheCmd->Hdr.Version 			= ARP1394_IOCTL_VERSION;
				pGetCacheCmd->Hdr.Op 				= ARP1394_IOCTL_OP_GET_ARPCACHE;
				pGetCacheCmd->NumEntriesAvailable   = NUM_ARPENTRIES_TO_GET;
			}
			break;
		
		case DO_ADD_ARPENTRY:
			//
			// "arp13 -add inet_addr hw_addr"
			//
			{
				PARP1394_IOCTL_ADD_ARP_ENTRY pAddCmd =  &g.Cmd.AddArpEntry;
				bRetVal = FALSE;

				if ((iIndx+1) < argc)
				{
					bRetVal = ParseIpAddress(argv[iIndx++], &pAddCmd->IpAddress);
					if (!bRetVal) break;
	
					bRetVal = ParseHwAddress(argv[iIndx++], &pAddCmd->HwAddress);
				}
				else
				{
					printf("Not enough arguments for '-add'\n");
				}

				if (!bRetVal) break;

				pAddCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;
				pAddCmd->Hdr.Op 		= ARP1394_IOCTL_OP_ADD_STATIC_ENTRY;

			}
			break;
		
		case DO_DEL_ARPENTRY:
			//
			// "arp13 -del inet_addr"
			//
			{
				PARP1394_IOCTL_DEL_ARP_ENTRY pDelCmd =  &g.Cmd.DelArpEntry;
				bRetVal = FALSE;

				if (iIndx < argc)
				{
					bRetVal = ParseIpAddress(argv[iIndx++], &pDelCmd->IpAddress);
				}
				else
				{
					printf("Not enough arguments for '-del'\n");
				}

				if (!bRetVal) break;

				pDelCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;
				pDelCmd->Hdr.Op 		= ARP1394_IOCTL_OP_DEL_STATIC_ENTRY;

			}
			break;
		
		case DO_GET_STATS:
			//
			// "arp13 -stats [arp|call|tsks|pkts]"
			//
			{
				PARP1394_IOCTL_COMMAND pCmd =  &g.Cmd;
				INT StatsOp;


				if (iIndx >= argc)
				{
					StatsOp = DO_X_ARP;
				}
				else
				{
					StatsOp =  FindOption(argv[iIndx++], &pVal, FALSE);
				}
				
				pCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;

				switch(StatsOp)
				{
				case DO_X_ARP:
					pCmd->Hdr.Op 	=  ARP1394_IOCTL_OP_GET_ARPCACHE_STATS;
					break;

				case DO_X_CALL:
					pCmd->Hdr.Op 	=  ARP1394_IOCTL_OP_GET_CALL_STATS;
					break;
					break;

				case DO_X_TSKS:
					pCmd->Hdr.Op 	=  ARP1394_IOCTL_OP_GET_TASK_STATS;
					break;
					break;

				case DO_X_PKTS:
					pCmd->Hdr.Op 	=  ARP1394_IOCTL_OP_GET_PACKET_STATS;
					break;

				default:
					// Assume default and put parsed value back.
					//
					StatsOp = DO_X_ARP;
					iIndx--;
					break;
				}
			}
			break;
		
		case DO_RESET_STATS:
			//
			// "arp13 -resetstats"
			//
			{
				PARP1394_IOCTL_RESET_STATS pResetStatsCmd =  &g.Cmd.ResetStats;

				pResetStatsCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;
				pResetStatsCmd->Hdr.Op 			= ARP1394_IOCTL_OP_RESET_STATS;
			}
			break;

		case DO_REINIT_IF:
			//
			// "arp13 -reinit"
			//
			{
				PARP1394_IOCTL_REINIT_INTERFACE pReinitIfCmd;
				pReinitIfCmd = &g.Cmd.ReinitInterface;

				pReinitIfCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;
				pReinitIfCmd->Hdr.Op 		= ARP1394_IOCTL_OP_REINIT_INTERFACE;
			}
			break;

		case DO_BSTART:
		case DO_BSTOP:
			//
			// "arp13 -bstart adapter"
			//
			{
                UINT Size;
                PARP1394_IOCTL_ETHERNET_NOTIFICATION pEthCmd = 
                                                        &g.Cmd.EthernetNotification;
				bRetVal = FALSE;

				if (iIndx < argc)
				{
					bRetVal = ParseAdapter(
								argv[iIndx++],
								(PUCHAR) pEthCmd->AdapterName,
								sizeof(pEthCmd->AdapterName)-sizeof(WCHAR),
								&Size
								);
                    pEthCmd->AdapterName[Size/2]=0;
				}
				else
				{
					printf("Not enough arguments for '-send pkt'\n");
				}

				if (!bRetVal) break;

                pEthCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;
		        if (uOpt == DO_BSTART)
                {
                    // printf("BRIDGE START\n");
                    pEthCmd->Hdr.Op 	= ARP1394_IOCTL_OP_ETHERNET_START_EMULATION;
                }
                else
                {
                    // printf("BRIDGE STOP\n");
                    pEthCmd->Hdr.Op 	= ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION;
				}
			}
            break;

		case DO_GET_NICINFO:
			//
			// ipfwadm -nicinfo [a|n node_id |c channel_number]
			//
			{
				PNIC1394_NICINFO	pNi = &g.Cmd.IoctlNicInfo.Info;
				INT NicOp;
				UINT Num;


				if (iIndx >= argc)
				{
					NicOp = DO_NI_BUSINFO;	// Default
				}
				else
				{
					NicOp =  FindOption(argv[iIndx++], &pVal, FALSE);
				}
				
				
				g.Cmd.Hdr.Version 	= ARP1394_IOCTL_VERSION;
				g.Cmd.Hdr.Op 		= ARP1394_IOCTL_OP_GET_NICINFO;
				pNi->Hdr.Version 	= NIC1394_NICINFO_VERSION;

				//
				// Parse the sub-command
				//
				switch(NicOp)
				{
				default:
					// Assume default and put parsed value back.
					//
					iIndx--;
					
					// FALL THROUGH

				case DO_NI_BUSINFO:
					pNi->Hdr.Op = NIC1394_NICINFO_OP_BUSINFO;
					break;

				case DO_NI_NODEINFO:
					pNi->Hdr.Op = NIC1394_NICINFO_OP_REMOTENODEINFO;

					// Read mandatory node number
					//
					bRetVal = FALSE;
					if (iIndx < argc)
					{
						if (sscanf(argv[iIndx++], "%d", &Num)==1)
						{
							bRetVal = TRUE;
						}
					}
					if (bRetVal)
					{
						pNi->RemoteNodeInfo.NodeAddress = (USHORT) Num;
					}
					else
					{
						printf("Missing node id\n");
					}
					break;

				case DO_NI_CHANNELINFO:
					pNi->Hdr.Op = NIC1394_NICINFO_OP_CHANNELINFO;

					// Read mandatory channel number
					//
					bRetVal = FALSE;
					if (iIndx < argc)
					{
						if (sscanf(argv[iIndx++], "%d", &Num)==1)
						{
							bRetVal = TRUE;
						}
					}
					if (bRetVal)
					{
						pNi->ChannelInfo.Channel = Num;
					}
					else
					{
						printf("Missing channel number\n");
					}
					break;
				}
			}
			break;

		case DO_EUIDMAP:
			{
				PARP1394_IOCTL_EUID_NODE_MAC_INFO pMapInfo = &g.Cmd.EuidNodeMacInfo;

				pMapInfo->Hdr.Version 	= ARP1394_IOCTL_VERSION;
				pMapInfo->Hdr.Op 		= ARP1394_IOCTL_OP_GET_EUID_NODE_MAC_TABLE;				
				printf("Receved EuidMap");
			}
			break;
		case DO_SWITCH_TO_STDIN:
			//
			// "arp13 --"
			//
			printf("Switch to stdin UNIMPLEMENTED.\n");
			bRetVal = FALSE;
			break;
		
		case DO_SPECIFIC_IF:
	        //
			//  "-n if_addr"
			//
			{
				PARP1394_IOCTL_HEADER pHdr =  &g.Cmd.Hdr;

				bRetVal = ParseIpAddress(argv[iIndx++], &pHdr->IfIpAddress);
				if (!bRetVal) break;
			}
			break;

		default:
			printf("Unknown option:  %s\n", argv[iIndx-1]); // fall through
			//
			// FALL THROUGH...
			//

		case DO_DISP_HELP:
			Usage();
			bRetVal = FALSE;
			break;
		}
	}

	if (argc<=1)
	{
		//
		// Display help...
		//
		Usage();
	}

	if (bRetVal)
	{
		bRetVal = ValidateCommand(&g.Cmd);
	}

	return bRetVal;
}


UINT FindOption(
	char *lptOpt, 
	char **ppVal,
	BOOL	fCmdLine
	)
{
	int		i;
	UINT    iLen;
	char	c = *lptOpt;

	// if (fCmdLine), expect, and skip past the '-', or '/'...
	//
	if (fCmdLine)
	{
		if (c == '-' || c == '/')
		{
			lptOpt++;
		}
		else
		{
			return UNKNOWN_OPTION;			// EARLY RETURN
		}
	}
	
	for(i = 0; i < iCmdOptionsCounts; i++)
	{
		if(strlen(lptOpt) >= (iLen = strlen(CmdOptions[i].lptOption)))
		{
			if(0 == strcmp(lptOpt, CmdOptions[i].lptOption))
			{
				*ppVal = lptOpt + iLen;
				return CmdOptions[i].uOpt;
			}
		}
	}

    return UNKNOWN_OPTION;
}

BOOL
ParseIpAddress(
	PCHAR 	buf,
	PULONG	pIpAddress
	)
/*++

Routine Description:

	Parse IP address in buf the form a.b.c.d and return the parsed value
	in *pIpAddress in network byte order.

Return Value:

	TRUE iff correctly formed IP address. False otherwise.

--*/
{
	BOOL fRet = FALSE;

	do
	{
		INT rgi[4];
		INT i;

		i = sscanf(buf, "%d.%d.%d.%d", rgi+0, rgi+1, rgi+2, rgi+3);
	
		if (i<4) break;

	
		fRet = TRUE;

		for (i=0; i<4; i++)
		{
			INT iTmp = rgi[i];
			if (iTmp == -1)
			{
				iTmp = 255;
			}
			if (iTmp<0 || iTmp>255)
			{
				fRet = FALSE;
				break;
			}

			rgi[i] = iTmp;
		}

		if (!fRet) break;

		// Construct IP address in network byte order.
		//
		{
			ULONG u = (ULONG) rgi[0];
			u |= ((ULONG)rgi[1])<<8;
			u |= ((ULONG)rgi[2])<<16;
			u |= ((ULONG)rgi[3])<<24;
			*pIpAddress = u;
		}

	#if 0
		printf(
			"(%d.%d.%d.%d)->0x%08lx\n",
			rgi[0], rgi[1], rgi[2], rgi[3], *pIpAddress
			);
	#endif // 0


	} while (FALSE);

	if (!fRet)
	{
		printf("Invalid IP address: %s\n", buf);
	}

	return fRet;
}


BOOL
ParseHwAddress(
	PCHAR 						buf,
	PARP1394_IOCTL_HW_ADDRESS	pHwAddr
	)
/*++

Routine Description:

	Parse IEEE1394 HW address in buf the form of 8 bytes separated by hyphens.
	Return the parsed value in *pHwAddr in network byte order.

Return Value:

	TRUE iff correctly formed HW address. False otherwise.

--*/
{
	BOOL fRet = FALSE;

	do
	{
		ULONG rgu[8];
		INT i;

		i = sscanf(
				buf,
				"%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx",
				 rgu+0, rgu+1, rgu+2, rgu+3,
				 rgu+4, rgu+5, rgu+6, rgu+7
				);
	
		if (i<8) break;
	
		fRet = TRUE;

		for (i=0; i<8; i++)
		{
			ULONG u = rgu[i];

			if (u>255)
			{
				fRet = FALSE;
				break;
			}
			((PUCHAR)(&pHwAddr->UniqueID))[i] = (UCHAR) u;
		}

		if (!fRet) break;

	#if 0
		printf(
			"(%d-%d-%d-%d-%d-%d-%d-%d) -> 0x%08lx:0x%08lx\n",
			rgu[0], rgu[1], rgu[2], rgu[3],
			rgu[4], rgu[5], rgu[6], rgu[7],
			((PULONG)(&pHwAddr->UniqueID))[0],
			((PULONG)(&pHwAddr->UniqueID))[1]
			);
	#endif // 0

	} while (FALSE);

	if (!fRet)
	{
		printf("Invalid HW address: %s\n", buf);
	}
	return fRet;
}

BOOL
ValidateCommand(PARP1394_IOCTL_COMMAND pCmd)
{
	BOOL fRet = FALSE;

	if (pCmd->Hdr.Version != ARP1394_IOCTL_VERSION) return FALSE; // EARLY RETURN

	switch(pCmd->Hdr.Op)
	{
	case ARP1394_IOCTL_OP_GET_ARPCACHE:
		{
			PARP1394_IOCTL_GET_ARPCACHE pGetCacheCmd =  &pCmd->GetArpCache;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_ARPCACHE;\n"
				"    IpIf      = 0x%08lx;\n"
				"    NumAvail  = %lu;\n"
				"};\n",
				pGetCacheCmd->Hdr.IfIpAddress,
				pGetCacheCmd->NumEntriesAvailable
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_ADD_STATIC_ENTRY:
		{
			PARP1394_IOCTL_ADD_ARP_ENTRY pAddCmd =  &pCmd->AddArpEntry;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = ADD_ENTRY;\n"
				"    IpIf      = 0x%08lx;\n"
				"    IpAddress = 0x%08lx;\n"
				"    HwAddress = 0x%08lx:0x%08lx;\n"
				"};\n",
				pAddCmd->Hdr.IfIpAddress,
				pAddCmd->IpAddress,
				((PULONG)&pAddCmd->HwAddress)[0],
				((PULONG)&pAddCmd->HwAddress)[1]
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_DEL_STATIC_ENTRY:
		{
			PARP1394_IOCTL_DEL_ARP_ENTRY pDelCmd =  &pCmd->DelArpEntry;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = DEL_ENTRY;\n"
				"    IpIf      = 0x%08lx;\n"
				"    IpAddress = 0x%08lx;\n"
				"};\n",
				pDelCmd->Hdr.IfIpAddress,
				pDelCmd->IpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_GET_PACKET_STATS:
		{
			PARP1394_IOCTL_GET_PACKET_STATS pStatsCmd =  &pCmd->GetPktStats;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_PACKET_STATS;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pStatsCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_GET_TASK_STATS:
		{
			PARP1394_IOCTL_GET_TASK_STATS pStatsCmd =  &pCmd->GetTaskStats;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_TASK_STATS;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pStatsCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_GET_ARPCACHE_STATS:
		{
			PARP1394_IOCTL_GET_ARPCACHE_STATS pStatsCmd =  &pCmd->GetArpStats;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_ARPCACHE_STATS;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pStatsCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_GET_CALL_STATS:
		{
			PARP1394_IOCTL_GET_CALL_STATS pStatsCmd =  &pCmd->GetCallStats;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_CALL_STATS;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pStatsCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_RESET_STATS:
		{
			PARP1394_IOCTL_RESET_STATS pStatsCmd =  &pCmd->ResetStats;
		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_RESET_STATS;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pStatsCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_REINIT_INTERFACE:
		{
			PARP1394_IOCTL_REINIT_INTERFACE pReinitCmd =  &pCmd->ReinitInterface;
		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_REINIT_INTERFACE;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pReinitCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

    case ARP1394_IOCTL_OP_ETHERNET_START_EMULATION:
    case ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION:
		{
			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_GET_NICINFO:
		{
			PARP1394_IOCTL_NICINFO pNicInfoCmd =  &pCmd->IoctlNicInfo;
		#if 0
			printf(
				"CMD = \n{"
				"    Op        = NICINFO;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pNicInfoCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_GET_EUID_NODE_MAC_TABLE:
		{
			fRet = TRUE;
		}
	default:
		break;

	}

	return fRet;
};


CHAR *g_szPacketName;

BOOL
ParsePacket(
	PCHAR buf,
	UCHAR *data,
	UINT  cbData,
	UINT *pcbPacketSize
	)
{
	char Path[256];
	UINT u;
	BOOL fRet = FALSE;


	g_szPacketName = buf;

    u = GetCurrentDirectory(sizeof(Path), Path);

    if (u==0)
    {
    	printf("Couldn't get current directory.\n");
    	return FALSE;
    }
    strcat(Path, "\\");
    strcat(Path, PROGRAM);
    strcat(Path, ".ini");
    // printf("INI file location = %s\n", Path);

	fRet = GetBinaryData(
			Path,
			"Packets",
			buf,
			data,
			cbData,
			pcbPacketSize
			);

#if 0


	static IP1394_MCAP_PKT Pkt =
	{
		{
			H2N_USHORT(0),		// Node id
			H2N_USHORT(NIC1394_ETHERTYPE_MCAP)
		},

		H2N_USHORT(
			sizeof(IP1394_MCAP_PKT) - sizeof(NIC1394_UNFRAGMENTED_HEADER)),
		0, // reserved
		IP1394_MCAP_OP_ADVERTISE, // IP1394_MCAP_OP_SOLICIT
		{
			sizeof(IP1394_MCAP_GD),
			IP1394_MCAP_GD_TYPE_V1,
			0, //  reserved;
			60, // expiration;
			2,  // channel
			2,  // speed
			0,  // reserved2;
			0,  // bandwidth;
			0x010000e1 // IP multicast group  address 225.0.0.1
		}
	};

	PIP1394_MCAP_PKT pPkt;
	pPkt = &Pkt;

	if (cbData >= sizeof(Pkt))
	{
		printf ("ParsePacket: MCAP packet of size %lu.\n", sizeof(Pkt));
		*(PIP1394_MCAP_PKT) data = *pPkt;
		*pcbPacketSize = sizeof (Pkt);
		fRet = TRUE;
	}
	else
	{
		printf ("ParsePacket: buffer size too small.\n");
	}
#endif // 0


	return fRet;
}

BOOL
ParseAdapter(
	PCHAR buf,
	UCHAR *data,
	UINT  cbData,
	UINT *pcbAdapterSize
	)
{
	char Path[256];
	UINT u;
	BOOL fRet = FALSE;


	g_szPacketName = buf;

    u = GetCurrentDirectory(sizeof(Path), Path);

    if (u==0)
    {
    	printf("Couldn't get current directory.\n");
    	return FALSE;
    }
    strcat(Path, "\\");
    strcat(Path, PROGRAM);
    strcat(Path, ".ini");
    // printf("INI file location = %s\n", Path);

	fRet = GetBinaryData(
			Path,
			"Adapters",
			buf,
			data,
			cbData,
			pcbAdapterSize
			);

	return fRet;
}

typedef struct
{
    
    IP1394_MCAP_PKT Pkt;
    IP1394_MCAP_GD Gd2;

} MYPKT2;

typedef struct
{
    
    IP1394_MCAP_PKT Pkt;
    IP1394_MCAP_GD Gd2;
    IP1394_MCAP_GD Gd3;

} MYPKT3;

typedef struct
{
    
    IP1394_MCAP_PKT Pkt;
    IP1394_MCAP_GD Gd2;
    IP1394_MCAP_GD Gd3;
    IP1394_MCAP_GD Gd4;

} MYPKT4;

#define SWAPBYTES_USHORT(Val)	\
				((((Val) & 0xff) << 8) | (((Val) & 0xff00) >> 8))
#define H2N_USHORT(Val)	SWAPBYTES_USHORT(Val)

IP1394_MCAP_PKT Pkt1  =
{
    {
        H2N_USHORT(0),		// Node id
        H2N_USHORT(NIC1394_ETHERTYPE_MCAP)
    },

    H2N_USHORT(
        sizeof(IP1394_MCAP_PKT) - sizeof(NIC1394_UNFRAGMENTED_HEADER)),
    0, // reserved
    IP1394_MCAP_OP_ADVERTISE, // IP1394_MCAP_OP_SOLICIT
    {
        sizeof(IP1394_MCAP_GD),
        IP1394_MCAP_GD_TYPE_V1,
        0, //  reserved;
        60, // expiration;
        2,  // channel
        2,  // speed
        0,  // reserved2;
        0,  // bandwidth;
        0x010000e1 // IP multicast group  address 225.0.0.1
    }
};


MYPKT2 Pkt2 = 
{
    {
        {
            H2N_USHORT(0),		// Node id
            H2N_USHORT(NIC1394_ETHERTYPE_MCAP)
        },
    
        H2N_USHORT(
            sizeof(MYPKT2) - sizeof(NIC1394_UNFRAGMENTED_HEADER)),
        0, // reserved
        IP1394_MCAP_OP_ADVERTISE, // IP1394_MCAP_OP_SOLICIT
        {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x010000e1 // IP multicast group  address 225.0.0.1
        }
    },
    {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x020000e1 // IP multicast group  address 225.0.0.2
    }
};


MYPKT3 Pkt3 = 
{
    {
        {
            H2N_USHORT(0),		// Node id
            H2N_USHORT(NIC1394_ETHERTYPE_MCAP)
        },
    
        H2N_USHORT(
            sizeof(MYPKT3) - sizeof(NIC1394_UNFRAGMENTED_HEADER)),
        0, // reserved
        IP1394_MCAP_OP_ADVERTISE, // IP1394_MCAP_OP_SOLICIT
        {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x010000e1 // IP multicast group  address 225.0.0.1
        }
    },
    {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x020000e1 // IP multicast group  address 225.0.0.2
    },
    {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x030000e1 // IP multicast group  address 225.0.0.3
    }
};

MYPKT4 Pkt4 = 
{
    {
        {
            H2N_USHORT(0),		// Node id
            H2N_USHORT(NIC1394_ETHERTYPE_MCAP)
        },
    
        H2N_USHORT(
            sizeof(MYPKT4) - sizeof(NIC1394_UNFRAGMENTED_HEADER)),
        0, // reserved
        IP1394_MCAP_OP_ADVERTISE, // IP1394_MCAP_OP_SOLICIT
        {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x010000e1 // IP multicast group  address 225.0.0.1
        }
    },
    {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x020000e1 // IP multicast group  address 225.0.0.2
    },
    {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x030000e1 // IP multicast group  address 225.0.0.3
    },
    {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x040000e1 // IP multicast group  address 225.0.0.4
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarp\atmarp.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	atmlane.c

Abstract:

	ATM ARP Admin Utility.

	Usage:

		atmarp 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	06-10-1998	Created (adapted from atmlane admin utility).

Notes:

	Modelled after atmlane utility.

--*/

#include "common.h"
#include "atmmsg.h"

BOOL
ParseCmdLine(
	int argc, 
	char * argv[]
	);

OPTIONS g;

void 
Usage(void);
	
VOID __cdecl
main(
	INT			argc,
	CHAR		*argv[]
)
{

	//
	// Parse args, determine if this is concerns the arp client or server.
	//
	if(!ParseCmdLine(argc, argv)){
		Usage();
		return;
	}

	DoAAS(&g);

	//
	// Following tries to open atmarpc.sys...
	//
	// DoAAC(&g);

}

void 
Usage(void)
{
	printf( "\n  Windows NT IP/ATM Information\n\n");
	printf(
		"USAGE:     atmarp [/s] [/c] [/reset]\n");

	printf(
		"  Options\n"
		"      /?       Display this help message.\n"
		"      /s       Display statistics for the ARP and MARS server.\n"
		"      /c       Display the ARP and MARS caches.\n"
		"      /reset   Reset the ARP and MARS statistics.\n\n"
		);
	
	printf(
		"The default is to display only the ARP and MARS statistics.\n\n"
		);
}

UINT FindOption(
	char *lptOpt, 
	char **ppVal
	);

enum
{
DISP_HELP,
DISP_STATS,
DISP_CACHES,
DO_RESET,
UNKNOWN_OPTION
};

struct _CmdOptions {
    char *  lptOption;
    UINT    uOpt;
} CmdOptions[]    = {
                      {"/?"		, DISP_HELP		    },
                      {"-?"		, DISP_HELP		    },
                      {"/s"		, DISP_STATS		},
                      {"-s"		, DISP_STATS		},
                      {"/c"		, DISP_CACHES		},
                      {"-c"		, DISP_CACHES		},
                      {"/reset"	, DO_RESET			},
                      {"-reset"	, DO_RESET			}
                    };
INT iCmdOptionsCounts = sizeof(CmdOptions)/sizeof(struct _CmdOptions);


BOOL
ParseCmdLine(
	int argc, 
	char * argv[]
	)
{
	BOOL	bRetVal = TRUE;
	int		iIndx;
	UINT	uOpt;
	char	*pVal;

	for(iIndx = 1; iIndx < argc; iIndx++)
	{
		
		uOpt = FindOption(argv[iIndx], &pVal);

		switch(uOpt){

		case DISP_STATS:
			g.DispStats = TRUE;
			break;

		case DISP_CACHES:
			g.DispCache = TRUE;
			break;

		case DO_RESET:
			g.DoResetStats = TRUE;
			break;
		
		default:
			printf("Unknown option - %s\n", argv[iIndx]); // fall through
		case DISP_HELP:
			bRetVal = FALSE;
		}
	}

	if (argc<=1)
	{
		//
		// Set default
		//
		g.DispStats = TRUE;
	}

	return bRetVal;
}


UINT FindOption(
	char *lptOpt, 
	char **ppVal
	)
{
int		i;
UINT    iLen;

    for(i = 0; i < iCmdOptionsCounts; i++){
		if(strlen(lptOpt) >= (iLen = strlen(CmdOptions[i].lptOption)))
			if(0 == _strnicmp(lptOpt, CmdOptions[i].lptOption, iLen)){
				*ppVal = lptOpt + iLen;
				return CmdOptions[i].uOpt;
			}
	}

    return UNKNOWN_OPTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarp\utils.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	utils.c

Abstract:

	ATM ARP Admin Utility.

	Usage:

		atmarp 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	06-10-1998	Created (adapted from atmlane admin utility).

Notes:

	Modelled after atmlane utility.

--*/

#include "common.h"

//
//  LoadMessageTable
//
//  Loads internationalizable strings into a table, replacing the default for
//  each. If an error occurs, the English language default is left in place.
//
//
VOID
LoadMessageTable(
	PMESSAGE_STRING	Table,
	UINT MessageCount
)
{
    LPTSTR string;
    DWORD count;

    //
    // for all messages in a MESSAGE_STRING table, load the string from this
    // module, replacing the default string in the table (only there in case
    // we get an error while loading the string, so we at least have English
    // to fall back on)
    //

    while (MessageCount--) {
        if (Table->Message != MSG_NO_MESSAGE) {

            //
            // we really want LoadString here, but LoadString doesn't indicate
            // how big the string is, so it doesn't give us an opportunity to
            // allocate exactly the right buffer size. FormatMessage does the
            // right thing
            //

            count = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                  | FORMAT_MESSAGE_FROM_HMODULE,
                                  NULL, // use default hModule
                                  Table->Message,
                                  0,    // use default language
                                  (LPTSTR)&string,
                                  0,    // minimum size to allocate
                                  NULL  // no arguments for inclusion in strings
                                  );
            if (count) {

                //
                // Format message returned the string: replace the English
                // language default
                //

                Table->String = string;
            } else {

                //
                // this is ok if there is no string (e.g. just %0) in the .mc
                // file
                //

                Table->String = TEXT("");
            }
        }
        ++Table;
    }
}


VOID
DisplayMessage(
	IN	BOOLEAN			Tabbed,
	IN	DWORD			MessageId,
	...
)
{
	va_list		pArg;
	CHAR		MessageBuffer[2048];
	INT			Count;

	va_start(pArg, MessageId);

	Count = FormatMessage(
				FORMAT_MESSAGE_FROM_HMODULE,
				NULL,				// default hModule
				MessageId,
				0,					// default language
				MessageBuffer,
				sizeof(MessageBuffer),
				&pArg
				);

	va_end(pArg);

	if (Tabbed)
	{
		putchar('\t');
	}

	printf(MessageBuffer);
}

HANDLE
OpenDevice(
	CHAR	*pDeviceName
)
{
	DWORD	DesiredAccess;
	DWORD	ShareMode;
	LPSECURITY_ATTRIBUTES	lpSecurityAttributes = NULL;

	DWORD	CreationDistribution;
	DWORD	FlagsAndAttributes;
	HANDLE	TemplateFile;
	HANDLE	Handle;

	DesiredAccess = GENERIC_READ|GENERIC_WRITE;
	ShareMode = 0;
	CreationDistribution = OPEN_EXISTING;
	FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
	TemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

	Handle = CreateFile(
				pDeviceName,
				DesiredAccess,
				ShareMode,
				lpSecurityAttributes,
				CreationDistribution,
				FlagsAndAttributes,
				TemplateFile
			);

	return (Handle);
}


VOID
CloseDevice(
	HANDLE		DeviceHandle
)
{
	CloseHandle(DeviceHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\aawmi.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	aawmi.h

Abstract:

	Structures and definitions for WMI support in ATMARP Client.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     12-17-97    Created

Notes:

--*/

#ifndef _AAWMI__H
#define _AAWMI__H



#define ATMARP_MOF_RESOURCE_NAME		L"AtmArpMofResource"
#define ATMARP_WMI_VERSION				1

//
//  Get a pointer to the ATMARP Interface structure from
//  the Device Extension field in a Device Object.
//
#define AA_PDO_TO_INTERFACE(_pDevObj)	\
			(*(PATMARP_INTERFACE *)((_pDevObj)->DeviceExtension))


//
//  A local smaller ID is used to simplify processing.
//
typedef ULONG		ATMARP_GUID_ID;

#define AAGID_QOS_TC_SUPPORTED					((ATMARP_GUID_ID)0)
#define AAGID_QOS_TC_INTERFACE_UP_INDICATION	((ATMARP_GUID_ID)1)
#define AAGID_QOS_TC_INTERFACE_DOWN_INDICATION	((ATMARP_GUID_ID)2)
#define AAGID_QOS_TC_INTERFACE_CHG_INDICATION	((ATMARP_GUID_ID)3)


typedef
NTSTATUS
(*PAA_WMI_QUERY_FUNCTION)(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
	);

typedef
NTSTATUS
(*PAA_WMI_SET_FUNCTION)(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						BytesNeeded
	);


typedef
VOID
(*PAA_WMI_ENABLE_EVENT_FUNCTION)(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	BOOLEAN						bEnable
	);



//
//  Info about each supported GUID.
//
typedef struct _ATMARP_WMI_GUID
{
	ATMARP_GUID_ID					MyId;
	GUID							Guid;
	ULONG							Flags;
	PAA_WMI_QUERY_FUNCTION			QueryHandler;
	PAA_WMI_SET_FUNCTION			SetHandler;
	PAA_WMI_ENABLE_EVENT_FUNCTION	EnableEventHandler;

} ATMARP_WMI_GUID, *PATMARP_WMI_GUID;

//
//  Definitions of bits in Flags in ATMARP_WMI_GUID
//
#define AWGF_EVENT_ENABLED			((ULONG)0x00000001)
#define AWGF_EVENT_DISABLED			((ULONG)0x00000000)
#define AWGF_EVENT_MASK				((ULONG)0x00000001)


//
//  Per-interface WMI information.
//
typedef struct _ATMARP_IF_WMI_INFO
{
	NDIS_STRING						InstanceName;	// Instance name for all GUIDs
													// on this Interface.
	PDEVICE_OBJECT					pDeviceObject;
	ULONG							GuidCount;		// # elements in array below.
	ATMARP_WMI_GUID					GuidInfo[1];

} ATMARP_IF_WMI_INFO, *PATMARP_IF_WMI_INFO;



#endif _AA_WMI__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\aaqos.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	aaqos.h

Abstract:

	QOS structures and definitions for the ATMARP module.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-07-96    Created

Notes:

--*/

#ifndef _AAQOS__H
#define _AAQOS__H

//
//  Encapsulation method used on a VC.
//
typedef enum
{
	ENCAPSULATION_TYPE_LLCSNAP,		// LLC/SNAP encapsulation
	ENCAPSULATION_TYPE_NULL			// NULL encapsulation

} ATMARP_VC_ENCAPSULATION_TYPE, *PATMARP_VC_ENCAPSULATION_TYPE;


//
//  Flow specifications for an ATMARP connection.
//
typedef struct _ATMARP_FLOW_SPEC
{
	ULONG							SendAvgBandwidth;		// Bytes/sec
	ULONG							SendPeakBandwidth;		// Bytes/sec
	ULONG							SendMaxSize;			// Bytes
	SERVICETYPE						SendServiceType;
	ULONG							ReceiveAvgBandwidth;	// Bytes/sec
	ULONG							ReceivePeakBandwidth;	// Bytes/sec
	ULONG							ReceiveMaxSize;			// Bytes
	SERVICETYPE						ReceiveServiceType;
	ATMARP_VC_ENCAPSULATION_TYPE	Encapsulation;
	ULONG							AgingTime;

} ATMARP_FLOW_SPEC, *PATMARP_FLOW_SPEC;


//
//  Filter specifications for an ATMARP connection.
//
typedef struct _ATMARP_FILTER_SPEC
{
	ULONG							DestinationPort;// IP port number

} ATMARP_FILTER_SPEC, *PATMARP_FILTER_SPEC;

//
//  The wild-card IP port number matches all destination ports
//
#define AA_IP_PORT_WILD_CARD		((ULONG)-1)

//
// The instance name of a flow is a FIXED size array, of the form below,
// and is embedded in the ATMARP_FLOW_INFO struct.
// The 8-character all-zeros field is filled in with the "flow number", which
// is guaranteed to be unique across all existing flows within atmarpc (
// the number may be recycled as flows come and go).
// The "A993E347" constant is a random number that represents a signature
// that with high probability is unique to atmarpc.
//
// We should re-visit this naming scheme once QOS mandates a more structured
// mechanism for naming flows.
//
#define AA_FLOW_INSTANCE_NAME_TEMPLATE	L"00000000:A993E347"
#define AA_FLOW_INSTANCE_NAME_LEN \
		((sizeof(AA_FLOW_INSTANCE_NAME_TEMPLATE)/sizeof(WCHAR))-1)

//
//  The FLOW INFO structure represents a flow instantiated by, for
//  example, RSVP.
//
//  One of these structures is created when the Generic Packet Classifier
//  (GPC) notifies us about a flow creation.
//
typedef struct _ATMARP_FLOW_INFO
{
	struct _ATMARP_FLOW_INFO *		pNextFlow;
	struct _ATMARP_FLOW_INFO *		pPrevFlow;
#ifdef GPC
	PVOID							VcContext;
	GPC_HANDLE						CfInfoHandle;
	WCHAR							FlowInstanceName[AA_FLOW_INSTANCE_NAME_LEN];
#endif // GPC
	ULONG							PacketSizeLimit;
	ATMARP_FILTER_SPEC				FilterSpec;
	ATMARP_FLOW_SPEC				FlowSpec;

} ATMARP_FLOW_INFO, *PATMARP_FLOW_INFO;


#ifdef QOS_HEURISTICS


typedef enum _ATMARP_FLOW_TYPES
{
	AA_FLOW_TYPE_LOW_BW,
	AA_FLOW_TYPE_HIGH_BW,
	AA_FLOW_TYPE_MAX

} ATMARP_FLOW_TYPES;


//
//  Default QOS parameters for a Low Bandwidth VC
//
#define AAF_DEF_LOWBW_SEND_BANDWIDTH			6000	// Bytes/Sec
#define AAF_DEF_LOWBW_RECV_BANDWIDTH			6000	// Bytes/Sec
#define AAF_DEF_LOWBW_SERVICETYPE			SERVICETYPE_BESTEFFORT
#define AAF_DEF_LOWBW_ENCAPSULATION			ENCAPSULATION_TYPE_LLCSNAP
#define AAF_DEF_LOWBW_AGING_TIME				  30	// Seconds
#define AAF_DEF_LOWBW_SEND_THRESHOLD		    1024	// Bytes

#define AAF_DEF_HIGHBW_SEND_BANDWIDTH		  250000	// Bytes/Sec
#define AAF_DEF_HIGHBW_RECV_BANDWIDTH			6000	// Bytes/Sec
#define AAF_DEF_HIGHBW_SERVICETYPE			SERVICETYPE_GUARANTEED
#define AAF_DEF_HIGHBW_ENCAPSULATION		ENCAPSULATION_TYPE_LLCSNAP
#define AAF_DEF_HIGHBW_AGING_TIME				  10	// Seconds

#endif // QOS_HEURISTICS

//
//  Filter and Flow spec extractor function template:
//  Given a packet, it extracts flow and filter info out of it.
//
typedef
VOID
(*PAA_GET_PACKET_SPEC_FUNC)(
	IN	PVOID						Context,
	IN	PNDIS_PACKET				pNdisPacket,
	OUT	PATMARP_FLOW_INFO			*ppFlowInfo,
	OUT	PATMARP_FLOW_SPEC *			ppFlowSpec,
	OUT	PATMARP_FILTER_SPEC *		ppFilterSpec
);

#define NULL_PAA_GET_PACKET_SPEC_FUNC	((PAA_GET_PACKET_SPEC_FUNC)NULL)

//
//  Flow-spec matcher function template
//
typedef
BOOLEAN
(*PAA_FLOW_SPEC_MATCH_FUNC)(
	IN	PVOID					Context,
	IN	PATMARP_FLOW_SPEC		pSourceFlowSpec,
	IN	PATMARP_FLOW_SPEC		pTargetFlowSpec
);

#define NULL_PAA_FLOW_SPEC_MATCH_FUNC	((PAA_FLOW_SPEC_MATCH_FUNC)NULL)


//
//  Filter-spec matcher function template
//
typedef
BOOLEAN
(*PAA_FILTER_SPEC_MATCH_FUNC)(
	IN	PVOID					Context,
	IN	PATMARP_FILTER_SPEC		pSourceFilterSpec,
	IN	PATMARP_FILTER_SPEC		pTargetFilterSpec
);

#define NULL_PAA_FILTER_SPEC_MATCH_FUNC	((PAA_FILTER_SPEC_MATCH_FUNC)NULL)


#ifdef GPC

#define GpcRegisterClient		(pAtmArpGlobalInfo->GpcCalls.GpcRegisterClientHandler)
#define GpcClassifyPacket		(AtmArpGpcClassifyPacketHandler)
#define GpcDeregisterClient		(pAtmArpGlobalInfo->GpcCalls.GpcDeregisterClientHandler)
#define GpcGetCfInfoClientContext (AtmArpGpcGetCfInfoClientContextHandler)

#endif // GPC

#endif	// _AAQOS__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\adapter.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	adapter.c	- Adapter Interface routines.

Abstract:

	Handlers for adapter events are here. The only exception is the
	CoReceivePacket handler, which is in arppkt.c.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-12-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'PADA'

ULONG		MCastSendOk = 0;
ULONG		MCastSendFail = 0;
ULONG		MCastRcv = 0;


INT
AtmArpBindAdapterHandler(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					BindContext,
	IN	PNDIS_STRING				pDeviceName,
	IN	PVOID						SystemSpecific1,
	IN	PVOID						SystemSpecific2
)

/*++

Routine Description:

	This is called by NDIS when it has an adapter for which there is a
	binding to the ATMARP client.

	We first allocate an Adapter structure. Then we open our configuration
	section for this adapter and save the handle in the Adapter structure.
	Finally, we open the adapter.

	We don't do anything more for this adapter until NDIS notifies us of
	the presence of a Call manager (via our AfRegisterNotify handler).

Arguments:

	pStatus				- Place to return status of this call
	BindContext			- Not used, because we don't pend this call 
	pDeviceName			- The name of the adapter we are requested to bind to
	SystemSpecific1		- Opaque to us; to be used to access configuration info
	SystemSpecific2		- Opaque to us; not used.

Return Value:

	Always TRUE. We set *pStatus to an error code if something goes wrong before we
	call NdisOpenAdapter, otherwise NDIS_STATUS_PENDING.

--*/
{
	PATMARP_ADAPTER				pAdapter;			// Pointer to new adapter structure
	PATMARP_ADAPTER *			ppAdapter;			// Used in case we need to delink
	NDIS_STATUS					Status;
	NDIS_STATUS					OpenStatus;
	UINT						MediumIndex;
	ULONG						Length;
	PNDIS_STRING				pAdapterConfigString;
#ifdef ATMARP_WIN98
	PANSI_STRING				pAnsiConfigString;
	NDIS_STRING					UnicodeConfigString;
#endif

	AADEBUGP(AAD_LOUD,
		 ("BindAdapter: Context 0x%x, pDevName 0x%x, SS1 0x%x, SS2 0x%x\n",
					BindContext, pDeviceName, SystemSpecific1, SystemSpecific2));

#if DBG
	if (AaSkipAll)
	{
		AADEBUGP(AAD_ERROR, ("BindAdapter: aborting\n"));
		*pStatus = NDIS_STATUS_NOT_RECOGNIZED;
		return ((INT)TRUE);
	}
#endif // DBG

	//
	//  Initialize.
	//
	pAdapter = NULL_PATMARP_ADAPTER;
	Status = NDIS_STATUS_SUCCESS;
#ifdef ATMARP_WIN98
	UnicodeConfigString.Buffer = NULL;
#endif

	do
	{
#ifndef ATMARP_WIN98
		pAdapterConfigString = (PNDIS_STRING)SystemSpecific1;
#else
		//
		//  SS1 is a pointer to an ANSI string. Convert it to Unicode.
		//
		pAnsiConfigString = (PANSI_STRING)SystemSpecific1;
		AA_ALLOC_MEM(UnicodeConfigString.Buffer, WCHAR, sizeof(WCHAR)*(pAnsiConfigString->MaximumLength));
		if (UnicodeConfigString.Buffer == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		UnicodeConfigString.MaximumLength = sizeof(WCHAR) * (pAnsiConfigString->MaximumLength);
		UnicodeConfigString.Length = 0;
		NdisAnsiStringToUnicodeString(&UnicodeConfigString, pAnsiConfigString);
		pAdapterConfigString = &UnicodeConfigString;
#endif

		//
		//  Check if this is a device we have already bound to.
		//
		if (AtmArpIsDeviceAlreadyBound(pDeviceName))
		{
			Status = NDIS_STATUS_NOT_ACCEPTED;
			AADEBUGP(AAD_WARNING, ("BindAdapter: already bound to %Z\n", pDeviceName));
			break;
		}

		//
		//  Allocate an Adapter structure
		//
		Length = sizeof(ATMARP_ADAPTER) + pDeviceName->MaximumLength + sizeof(WCHAR) + pAdapterConfigString->MaximumLength;

		AA_ALLOC_MEM(pAdapter, ATMARP_ADAPTER, Length);
		if (pAdapter == NULL_PATMARP_ADAPTER)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Initialize the Adapter structure
		//
		AA_SET_MEM(pAdapter, 0, Length);
#if DBG
		pAdapter->aaa_sig = aaa_signature;
#endif // DBG
		AA_INIT_BLOCK_STRUCT(&(pAdapter->Block));

		pAdapter->SystemSpecific1 = SystemSpecific1;
		pAdapter->SystemSpecific2 = SystemSpecific2;
		pAdapter->BindContext = BindContext;

		pAdapter->DeviceName.MaximumLength = pDeviceName->MaximumLength;
		pAdapter->DeviceName.Length = pDeviceName->Length;
		pAdapter->DeviceName.Buffer = (PWCHAR)((PUCHAR)pAdapter + sizeof(ATMARP_ADAPTER));

		AA_COPY_MEM(pAdapter->DeviceName.Buffer,
					pDeviceName->Buffer,
					pDeviceName->Length);

		//
		//  Copy in the string to be used when we want to open our
		//  configuration key for this adapter.
		//
		pAdapter->ConfigString.MaximumLength = pAdapterConfigString->MaximumLength;
		pAdapter->ConfigString.Length = pAdapterConfigString->Length;
		pAdapter->ConfigString.Buffer = (PWCHAR)((PUCHAR)pAdapter + sizeof(ATMARP_ADAPTER)+ pDeviceName->MaximumLength) + sizeof(WCHAR);

		AA_COPY_MEM(pAdapter->ConfigString.Buffer,
					pAdapterConfigString->Buffer,
					pAdapterConfigString->Length);

		AA_INIT_BLOCK_STRUCT(&pAdapter->UnbindBlock);

		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		//
		//  Link this Adapter structure to the global list of adapters.
		//
		pAtmArpGlobalInfo->AdapterCount++;
		pAdapter->pNextAdapter = pAtmArpGlobalInfo->pAdapterList;
		pAtmArpGlobalInfo->pAdapterList = pAdapter;

		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);


		//
		//  Open the adapter
		//
		pAdapter->Medium = NdisMediumAtm;

		NdisOpenAdapter(
			&Status,
			&OpenStatus,
			&(pAdapter->NdisAdapterHandle),
			&(MediumIndex),						// place to return selected medium index
			&pAdapter->Medium,					// Array of medium types
			1,									// Size of Media list
			pAtmArpGlobalInfo->ProtocolHandle,
			(NDIS_HANDLE)pAdapter,				// our context for the adapter binding
			pDeviceName,
			0,									// Open options
			(PSTRING)NULL						// Addressing Info...
			);

		if (Status != NDIS_STATUS_PENDING)
		{
			AtmArpOpenAdapterCompleteHandler(
					(NDIS_HANDLE)pAdapter,
					Status,
					OpenStatus
					);
		}

		Status = NDIS_STATUS_PENDING;

		break;

	}
	while (FALSE);


	if (Status != NDIS_STATUS_PENDING)
	{
		//
		//  We didn't make it upto NdisOpenAdapter. Clean up.
		//
		AADEBUGP(AAD_WARNING, ("BindAdapter: failed with Status 0x%x\n", Status));

		if (pAdapter != NULL_PATMARP_ADAPTER)
		{
			//
			//  Free it. We know we haven't linked it to the global
			//  list of adapters.
			//
			AA_FREE_MEM(pAdapter);
		}
	}

#ifdef ATMARP_WIN98
	if (UnicodeConfigString.Buffer != NULL)
	{
		AA_FREE_MEM(UnicodeConfigString.Buffer);
	}
#endif // ATMARP_WIN98

	*pStatus = Status;

	AADEBUGP(AAD_INFO, ("BindAdapterHandler: returning Status 0x%x\n", Status));
	return ((INT)TRUE);
}



VOID
AtmArpUnbindAdapterHandler(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					UnbindContext
)
/*++

Routine Description:

	This routine is called by NDIS when it wants us to unbind
	from an adapter. Or, this may be called from within our Unload
	handler. We undo the sequence of operations we performed
	in our BindAdapter handler.

Arguments:

	pStatus					- Place to return status of this operation
	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMARP Adapter structure.
	UnbindContext			- This is NULL if this routine is called from
							  within our Unload handler. Otherwise (i.e.
							  NDIS called us), we retain this for later use
							  when calling NdisCompleteUnbindAdapter.

Return Value:

	None. We set *pStatus to NDIS_STATUS_PENDING always.

--*/
{
	PATMARP_ADAPTER			pAdapter;
	PATMARP_INTERFACE		pInterface;
	PATMARP_INTERFACE		pNextInterface;
	NDIS_STATUS				Status;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

    

	AA_GET_ENTRY_IRQL(EntryIrq);

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;
	AA_STRUCT_ASSERT(pAdapter, aaa);

	AADEBUGP(AAD_INFO, ("UnbindAdapterHandler: pAdapter 0x%x, UnbindContext 0x%x\n",
					pAdapter, UnbindContext));

	*pStatus = NDIS_STATUS_PENDING;

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	//
	//  Save the unbind context for a possible later call to
	//  NdisCompleteUnbindAdapter.
	//  
	pAdapter->UnbindContext = UnbindContext;
	pAdapter->Flags |= AA_ADAPTER_FLAGS_UNBINDING;

	//
	//  Wait for any AF register processing to finish.
	//
	while (pAdapter->Flags & AA_ADAPTER_FLAGS_PROCESSING_AF)
	{
		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		AADEBUGP(AAD_FATAL, ("UnbindAdapter: pAdapter %x, Afregister going on!!!\n", pAdapter));
		Status = AA_WAIT_ON_BLOCK_STRUCT(&(pAdapter->UnbindBlock));
		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	}

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	//
	//  If there are no Interfaces on this adapter, we are done.
	//
	if (pAdapter->pInterfaceList == NULL_PATMARP_INTERFACE)
	{
		AtmArpCompleteUnbindAdapter(pAdapter);
		AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
		return;
	}

	//
	//  Mark all interfaces on this adapter.
	//
	for (pInterface = pAdapter->pInterfaceList;
		 pInterface != NULL_PATMARP_INTERFACE;
		 pInterface = pNextInterface)
	{
		pNextInterface = pInterface->pNextInterface;

		AA_ACQUIRE_IF_LOCK(pInterface);
		pInterface->AdminState = pInterface->State = IF_STATUS_DOWN;
		pInterface->LastChangeTime = GetTimeTicks();
		AA_RELEASE_IF_LOCK(pInterface);
	}

	//
	//  Now, bring down each of these interfaces. For each interface,
	//  we tear down the ARP table, and shut down the Call Manager
	//  interface. When this is complete, we will call IP's DelInterface
	//  entry point.
	//
	for (pInterface = pAdapter->pInterfaceList;
		 pInterface != NULL_PATMARP_INTERFACE;
		 pInterface = pNextInterface)
	{
		pNextInterface = pInterface->pNextInterface;

		AtmArpShutdownInterface(pInterface);
	}

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return;
}



VOID
AtmArpCompleteUnbindAdapter(
	IN	PATMARP_ADAPTER				pAdapter
)
/*++

Routine Description:

	Complete the process of adapter unbinding. All Interfaces on this
	adapter are assumed to have been removed.

	If we are unbinding from the adapter as a result of NDIS' call to
	our UnbindAdapter handler, we complete that here.

Arguments:

	pAdapter		- Pointer to the adapter being unbound.

Return Value:

	None

--*/
{
	NDIS_HANDLE			UnbindContext;
	PATMARP_ADAPTER *	ppAdapter;
	NDIS_STATUS			Status;

	UnbindContext = pAdapter->UnbindContext;

	AADEBUGP(AAD_INFO, ("CompleteUnbindAdapter: pAdapter 0x%x, UnbindContext 0x%x\n",
				pAdapter, UnbindContext));

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	if (pAdapter->Flags & AA_ADAPTER_FLAGS_CLOSING)
	{
		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		return;
	}

	pAdapter->Flags |= AA_ADAPTER_FLAGS_CLOSING;

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

#if ATMOFFLOAD
	//
	// Disable offload if enabled...
	//
	AtmArpDisableOffload(pAdapter);
#endif // ATMOFFLOAD

	NdisCloseAdapter(
		&Status,
		pAdapter->NdisAdapterHandle
		);

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmArpCloseAdapterCompleteHandler(
			(NDIS_HANDLE) pAdapter,
			Status
			);
	}

}


VOID
AtmArpOpenAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status,
	IN	NDIS_STATUS					OpenErrorStatus
)
/*++

Routine Description:

	This is called by NDIS when a previous call to NdisOpenAdapter
	that had pended has completed. We now complete the BindAdapter
	that lead to this.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMARP Adapter structure.
	Status					- Status of OpenAdapter
	OpenErrorStatus			- Error code in case of failure.

Return Value:

	None

--*/
{
	PATMARP_ADAPTER			pAdapter;
	PATMARP_ADAPTER *		ppAdapter;
	NDIS_HANDLE				BindAdapterContext;

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;

	AA_STRUCT_ASSERT(pAdapter, aaa);

	BindAdapterContext = pAdapter->BindContext;

	if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		//  Remove the adapter from the global list.
		//
		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		ppAdapter = &(pAtmArpGlobalInfo->pAdapterList);
		while (*ppAdapter != pAdapter)
		{
			ppAdapter = &((*ppAdapter)->pNextAdapter);
		}
		*ppAdapter = pAdapter->pNextAdapter;

		pAtmArpGlobalInfo->AdapterCount--;

		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		AA_FREE_MEM(pAdapter);
	}
#if ATMOFFLOAD
	else
	{
		//
		// Query and enable offloading
		//
		Status = AtmArpQueryAndEnableOffload(pAdapter);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			//
			// AtmArpQueryAndEnableOffload is not supposed to return unless
			// there's a fatal error -- we don't expect  this.
			//
			AA_ASSERT(FALSE);
		}
	}
#endif //ATMOFFLOAD

	AADEBUGP(AAD_INFO, ("OpenAdapterComplete: pAdapter 0x%x, Status 0x%x\n",
					pAdapter, Status));

	(*(pAtmArpGlobalInfo->pIPBindCompleteRtn))(
		Status,
		BindAdapterContext
		);

	return;
}



VOID
AtmArpCloseAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This is called by NDIS when a previous call to NdisCloseAdapter
	that had pended has completed. The thread that called NdisCloseAdapter
	would have blocked itself, so we simply wake it up now.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMARP Adapter structure.
	Status					- Status of CloseAdapter

Return Value:

	None

--*/
{
	PATMARP_ADAPTER			pAdapter;
	NDIS_HANDLE				UnbindContext;
	PATMARP_ADAPTER *	ppAdapter;

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;

	AA_STRUCT_ASSERT(pAdapter, aaa);

	UnbindContext = pAdapter->UnbindContext;

	AADEBUGP(AAD_INFO, ("CloseAdapterCompleteHandler: pAdapter 0x%x, UnbindContext 0x%x\n",
				pAdapter, UnbindContext));

	pAdapter->NdisAdapterHandle = NULL;

	//
	//  Remove the adapter from the global list.
	//
	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	ppAdapter = &(pAtmArpGlobalInfo->pAdapterList);
	while (*ppAdapter != pAdapter)
	{
		ppAdapter = &((*ppAdapter)->pNextAdapter);
	}
	*ppAdapter = pAdapter->pNextAdapter;

	pAtmArpGlobalInfo->AdapterCount--;

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	//
	//  Free any structures attached to the adapter structure.
	//
	if (pAdapter->pDescrString != (PUCHAR)NULL)
	{
		AA_FREE_MEM(pAdapter->pDescrString);
	}
    if (pAdapter->IPConfigString.Buffer != NULL)
    {
        AA_FREE_MEM(pAdapter->IPConfigString.Buffer);
    }

	//
	//  Release the adapter structure.
	//
	AA_FREE_MEM(pAdapter);

	//
	//  If NDIS had requested us to Unbind, complete the
	//  request now.
	//
	if (UnbindContext != (NDIS_HANDLE)NULL)
	{
		NdisCompleteUnbindAdapter(
			UnbindContext,
			NDIS_STATUS_SUCCESS
			);
	}
	else
	{
		//
		//  We initiated the unbind from our Unload handler,
		//  which would have been waiting for us to complete.
		//  Wake up that thread now.
		//
		AA_SIGNAL_BLOCK_STRUCT(&(pAtmArpGlobalInfo->Block), NDIS_STATUS_SUCCESS);
	}

}



VOID
AtmArpSendCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This is the Connection-less Send Complete handler, which signals
	completion of such a Send. Since we don't ever use this feature,
	we don't expect this routine to be called.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_ERROR, ("SendCompleteHandler unexpected\n"));
	AA_ASSERT(FALSE);
}



VOID
AtmArpTransferDataCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status,
	IN	UINT						BytesTransferred
)
/*++

Routine Description:

	This is the Connection-less Transfer Data Complete handler, which
	signals completion of a call to NdisTransferData. Since we never
	call NdisTransferData, this routine should never get called.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_ERROR, ("TransferDataComplete Handler unexpected!\n"));
	AA_ASSERT(FALSE);
}



VOID
AtmArpResetCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This routine is called when the miniport indicates that a Reset
	operation has just completed. We ignore this event.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMARP Adapter structure.
	Status					- Status of the reset operation.

Return Value:

	None

--*/
{
	PATMARP_ADAPTER			pAdapter;

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;
	AA_STRUCT_ASSERT(pAdapter, aaa);

	AADEBUGP(AAD_INFO, ("Reset Complete on Adapter 0x%x\n", pAdapter));
}



VOID
AtmArpRequestCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This is called by NDIS when a previous call we made to NdisRequest() has
	completed. We would be blocked on our adapter structure, waiting for this
	to happen -- wake up the blocked thread.

Arguments:

	ProtocolBindingContext	- Pointer to our Adapter structure
	pNdisRequest			- The request that completed
	Status					- Status of the request.

Return Value:

	None

--*/
{
	PATMARP_ADAPTER				pAdapter;

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;
	AA_STRUCT_ASSERT(pAdapter, aaa);

	AA_SIGNAL_BLOCK_STRUCT(&(pAdapter->Block), Status);
	return;
}



NDIS_STATUS
AtmArpReceiveHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN  NDIS_HANDLE             	MacReceiveContext,
	IN  PVOID                   	pHeaderBuffer,
	IN  UINT                    	HeaderBufferSize,
	IN  PVOID                   	pLookAheadBuffer,
	IN  UINT                    	LookaheadBufferSize,
	IN  UINT                    	PacketSize
)
/*++

Routine Description:

	This is our Connection-less receive handler. Since we only use
	Connection oriented services, this routine should never get called.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_ERROR, ("Connectionless ReceiveHandler unexpected\n"));
	AA_ASSERT(FALSE);

	return(NDIS_STATUS_NOT_RECOGNIZED);
}



VOID
AtmArpReceiveCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
)
/*++

Routine Description:

	This is called by NDIS when the miniport is done with receiving
	a bunch of packets, meaning that it is now time to start processing
	them. We simply pass this on to IP (on all IF's configured on this
	adapter).

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMARP Adapter structure.

Return Value:

	None

--*/
{
	PATMARP_ADAPTER				pAdapter;
	PATMARP_INTERFACE			pInterface;

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;
	AA_STRUCT_ASSERT(pAdapter, aaa);

	for (pInterface = pAdapter->pInterfaceList;
		 pInterface != NULL_PATMARP_INTERFACE;
		 pInterface = pInterface->pNextInterface)
	{
		(*(pInterface->IPRcvCmpltHandler))();
	}
}




INT
AtmArpReceivePacketHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	This is the Connectionless receive handler, which should never be
	called, since we only use Connection Oriented miniport services.

Arguments:

	<Ignored>

Return Value:

	Reference count on the received packet. We always return 0.

--*/
{
	AADEBUGP(AAD_ERROR, ("ReceivePacket Handler unexpected!\n"));
	AA_ASSERT(FALSE);

	return(0);
}



VOID
AtmArpStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
)
/*++

Routine Description:

	This routine is called when the miniport indicates an adapter-wide
	status change. We ignore this.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_INFO, ("Status Handler: Bind Ctx 0x%x, Status 0x%x\n",
					ProtocolBindingContext,
					GeneralStatus));
}



VOID
AtmArpStatusCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
)
/*++

Routine Description:

	This routine is called when the miniport wants to tell us about
	completion of a status change (?). Ignore this.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_INFO, ("Status Complete Handler: Bind Ctx 0x%x\n",
					ProtocolBindingContext));
}

VOID
AtmArpCoSendCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	This routine is called by NDIS when the ATM miniport is finished
	with a packet we had previously sent via NdisCoSendPackets. We first
	check if this packet was generated by us (e.g. ATMARP protocol packet):
	if so, we free this here. Otherwise (packet sent by the IP layer), we
	first remove any header buffer that we had attached to the packet and
	free it, before calling IP's entry point for Transmit Complete.

Arguments:

	Status					- Status of the NdisCoSendPackets.
	ProtocolVcContext		- Our context for the VC on which the packet was sent
							  (i.e. pointer to ATMARP VC).
	pNdisPacket				- The packet whose "send" is being completed.

Return Value:

	None

--*/
{
	PATMARP_VC						pVc;
	PATMARP_INTERFACE				pInterface;
	PacketContext					*PC;			// IP/ARP Info about this packet
	PNDIS_BUFFER					pNdisBuffer;	// First Buffer in this packet
	UINT							TotalLength;
	AA_HEADER_TYPE					HdrType;
	ATMARP_VC_ENCAPSULATION_TYPE	Encapsulation;
	ULONG							rc;

	pVc = (PATMARP_VC)ProtocolVcContext;
	AA_STRUCT_ASSERT(pVc, avc);

#ifdef VC_REFS_ON_SENDS

	AA_ACQUIRE_VC_LOCK(pVc);

	pInterface = pVc->pInterface;
	Encapsulation = pVc->FlowSpec.Encapsulation;

	rc = AtmArpDereferenceVc(pVc);		// SendComplete

	if (rc != 0)
	{
		pVc->OutstandingSends--;

		if (AA_IS_FLAG_SET(
				pVc->Flags,
				AA_VC_CLOSE_STATE_MASK,
				AA_VC_CLOSE_STATE_CLOSING) &&
			(pVc->OutstandingSends == 0))
		{
			AtmArpCloseCall(pVc);
			//
			//  VC lock is released above.
			//
		}
		else
		{
			AA_RELEASE_VC_LOCK(pVc);
		}
	}

#else

	pInterface = pVc->pInterface;
	Encapsulation = pVc->FlowSpec.Encapsulation;

#endif // VC_REFS_ON_SENDS

	AA_ASSERT(pNdisPacket->Private.Head != NULL);
#if DBG
#if DBG_CO_SEND
	{
		PULONG		pContext;
		extern 	ULONG	OutstandingSends;

		pContext = (PULONG)&(pNdisPacket->WrapperReserved[0]);;
		// Check for duplicate completion:
		AA_ASSERT(*pContext != 'BbBb');
		*pContext = 'BbBb';
		NdisInterlockedDecrement(&OutstandingSends);
	}
#endif // DBG_CO_SEND
#endif // DBG

	NdisQueryPacket(
			pNdisPacket,
			NULL,			// we don't need PhysicalBufferCount
			NULL,			// we don't need BufferCount
			NULL,			// we don't need FirstBuffer (yet)
			&TotalLength
			);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		AA_IF_STAT_ADD(pInterface, OutOctets, TotalLength);
	}
	else if (Status == NDIS_STATUS_RESOURCES)
	{
		AA_IF_STAT_INCR(pInterface, OutDiscards);
	}
	else if (Status != NDIS_STATUS_SUCCESS)
	{
		AA_IF_STAT_INCR(pInterface, OutErrors);
	}


	PC = (PacketContext *)pNdisPacket->ProtocolReserved;

	AADEBUGP(AAD_EXTRA_LOUD,
		("CoSend complete[%s]: VC 0x%x, Pkt 0x%x, Status 0x%x:\n",
				((PC->pc_common.pc_owner != PACKET_OWNER_LINK)? "IP": "ARP"),
				pVc, pNdisPacket, Status));

	//
	//  Check who generated this packet.
	//
	if (PC->pc_common.pc_owner != PACKET_OWNER_LINK)
	{
		//
		//  Belongs to IP. Check if we had prepended an LLC/SNAP header.
		//
		if (Encapsulation == ENCAPSULATION_TYPE_LLCSNAP)
		{
			PUCHAR		pPacket;
			UINT		Length;

#ifdef BACK_FILL
			NdisQueryPacket(pNdisPacket, NULL, NULL, &pNdisBuffer, NULL);
			AA_ASSERT(pNdisBuffer != NULL);
			NdisQueryBuffer(pNdisBuffer, &pPacket, &Length);

			//
			//  Commmon part first: find the header type, and update
			//  statistics.
			//
			if (pPacket[5] == LLC_SNAP_OUI2)
			{
				HdrType = AA_HEADER_TYPE_UNICAST;
				if (Status == NDIS_STATUS_SUCCESS)
				{
					AA_IF_STAT_INCR(pInterface, OutUnicastPkts);
				}
			}
			else
			{
				HdrType = AA_HEADER_TYPE_NUNICAST;
				if (Status == NDIS_STATUS_SUCCESS)
				{
					AA_IF_STAT_INCR(pInterface, OutNonUnicastPkts);
					INCR_STAT(MCastSendOk);
				}
				else
				{
					INCR_STAT(MCastSendFail);
				}
			}

			//
			//  Now check if we had attached a header buffer or not.
			//
			if (AtmArpDoBackFill && AA_BACK_FILL_POSSIBLE(pNdisBuffer))
			{
				ULONG		HeaderLength;

				//
				//  We would have back-filled IP's buffer with the LLC/SNAP
				//  header. Remove the back-fill.
				//
				HeaderLength = ((HdrType == AA_HEADER_TYPE_UNICAST)?
									sizeof(AtmArpLlcSnapHeader) :
#ifdef IPMCAST
									sizeof(AtmArpMcType1ShortHeader));
#else
									0);
#endif // IPMCAST
				(PUCHAR)pNdisBuffer->MappedSystemVa += HeaderLength;
				pNdisBuffer->ByteOffset += HeaderLength;
				pNdisBuffer->ByteCount -= HeaderLength;
			}
			else
			{
				//
				//  The first buffer would be our header buffer. Remove
				//  it from the packet and return to our pool.
				//
				NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
				AtmArpFreeHeader(pInterface, pNdisBuffer, HdrType);
			}
#else
			//
			//  Free the LLC/SNAP header buffer.
			//
			NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
			AA_ASSERT(pNdisBuffer != NULL);
			NdisQueryBuffer(pNdisBuffer, &pPacket, &Length);
			if (pPacket[5] == LLC_SNAP_OUI2)
			{
				HdrType = AA_HEADER_TYPE_UNICAST;
				if (Status == NDIS_STATUS_SUCCESS)
				{
					AA_IF_STAT_INCR(pInterface, OutUnicastPkts);
				}
			}
			else
			{
				HdrType = AA_HEADER_TYPE_NUNICAST;
				if (Status == NDIS_STATUS_SUCCESS)
				{
					AA_IF_STAT_INCR(pInterface, OutNonUnicastPkts);
					INCR_STAT(MCastSendOk);
				}
				else
				{
					INCR_STAT(MCastSendFail);
				}
			}

			AtmArpFreeHeader(pInterface, pNdisBuffer, HdrType);
#endif // BACK_FILL
		}

#ifdef PERF
		AadLogSendComplete(pNdisPacket);
#endif // PERF

		//
		//  Inform IP of send completion.
		//
		(*(pInterface->IPTxCmpltHandler))(
					pInterface->IPContext,
					pNdisPacket,
					Status
					);
	}
	else
	{
		//
		//  Packet generated by the ATMARP module. This would be an
		//  ATMARP protocol packet, so free the NDIS buffer now.
		//
		NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
		AA_ASSERT(pNdisBuffer != NULL);

#if DBG
		{
			ULONG	ArpPktLength;
			PUCHAR	ArpPktStart;

			NdisQueryBuffer(pNdisBuffer, (PVOID)&ArpPktStart, &ArpPktLength);
			AADEBUGPDUMP(AAD_EXTRA_LOUD+100, ArpPktStart, ArpPktLength);
		}
#endif // DBG

		AtmArpFreeProtoBuffer(pInterface, pNdisBuffer);
		AtmArpFreePacket(pInterface, pNdisPacket);
	}

	return;
}





VOID
AtmArpCoStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
)
/*++

Routine Description:

	This routine is called when the miniport indicates a status
	change, possibly on a VC. Ignore this.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_INFO, ("CoStatus Handler: Bind Ctx 0x%x, VC Ctx 0x%x, Status 0x%x\n",
					ProtocolBindingContext,
					ProtocolVcContext,
					GeneralStatus));
}


/*++
AtmArpCoReceivePacketHandler -- is in arppkt.c
--*/


#ifdef _PNP_POWER_


NDIS_STATUS
AtmArpPnPReconfigHandler(
	IN	PATMARP_ADAPTER				pAdapter OPTIONAL,
	IN	PNET_PNP_EVENT				pNetPnPEvent
)
/*++

Routine Description:

	Handle a reconfig message on the specified adapter. If no adapter
	is specified, it is a global parameter that has changed.

Arguments:

	pAdapter		-  Pointer to our adapter structure
	pNetPnPEvent	-  Pointer to reconfig event

Return Value:

	NDIS_STATUS_SUCCESS always, for now.

--*/
{
	ATMARPC_PNP_RECONFIG_REQUEST UNALIGNED *	pArpReconfigReq;
	PIP_PNP_RECONFIG_REQUEST				pIpReconfigReq;
	NDIS_STATUS								Status;

	pIpReconfigReq = (PIP_PNP_RECONFIG_REQUEST)pNetPnPEvent->Buffer;

	AA_ASSERT(pIpReconfigReq->arpConfigOffset != 0);

	pArpReconfigReq = (ATMARPC_PNP_RECONFIG_REQUEST UNALIGNED *)
						((PUCHAR)pIpReconfigReq + pIpReconfigReq->arpConfigOffset);
	
	AADEBUGP(AAD_WARNING, ("AtmArpPnPReconfig: pIpReconfig 0x%x, arpConfigOffset 0x%x\n",
				pIpReconfigReq, pIpReconfigReq->arpConfigOffset));


    do
    {
    	PATMARP_INTERFACE				pInterface;
    	PATMARP_INTERFACE				pNextInterface;
    	NDIS_STRING				        IPReconfigString;
    	//
    	// Locate the IP interface string passed in...
    	//
    	ULONG uOffset = pArpReconfigReq->IfKeyOffset;

    	if (uOffset == 0)
    	{
            Status = NDIS_STATUS_FAILURE;
            break;
    	}
    	else
    	{
    		//
    		//  ((PUCHAR)pArpReconfigReq + uOffset) points to a
    		// "counted unicode string", which means that it's an array
    		// of words, with the 1st word being the length in characters of
    		// the string (there is no terminating null) and the following
    		// <length> words being the string itself.
    		// We need to create an NDIS_STRING based on this buffer in order
    		// to compare it with each interface's config string.
    		//
        	PWCH pwc = (PWCH) ((PUCHAR)pArpReconfigReq + uOffset);
    		IPReconfigString.Length = sizeof(WCHAR)*pwc[0];
    		IPReconfigString.MaximumLength = IPReconfigString.Length;
    		IPReconfigString.Buffer = pwc+1;

    	}

        //
        //  Do we have a binding context?
        //
        if (pAdapter == NULL_PATMARP_ADAPTER)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }
      

		//
		// We wrap the search in a try-except clause because the passed-in
		// structure could be bogus. Note that we will only test at most
		// as many characters of the passed-in string as the lengths of
		// our internal set of interface config strings.
		//
		try
		{
			//
			// Find the interface associated with this request.
			//
			AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
			for (pInterface = pAdapter->pInterfaceList;
 				pInterface != NULL_PATMARP_INTERFACE;
 				pInterface = pNextInterface)
			{
				BOOLEAN		IsEqual = FALSE;

				pNextInterface = pInterface->pNextInterface;
				AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		
				//
				// Compare the IPReconfigString
				// JJ TODO: NdisEqualUnicodeString must be called in PASSIVE level
				// 			we know that the reconfig call is done at passive level,
				//			but how to assert that fact here?
				//			AA_ASSERT(EntryIrq == PASSIVE_LEVEL);
				//
				IsEqual = NdisEqualUnicodeString(
							&IPReconfigString,
							&(pInterface->IPConfigString),
							TRUE							// case insensitive
							);

				AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
				if (IsEqual)
				{
					break;		// found it!
				}
			}
			AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		}
		except (EXCEPTION_EXECUTE_HANDLER)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}
    
    	//
    	// JJ We should find the interface if this adapter has any interfaces
    	// at all -- else it means that we're being sent bogus reconfig
    	// information.
    	//
    	AA_ASSERT(pInterface!= NULL || pAdapter->pInterfaceList==NULL);

        if (pInterface != NULL_PATMARP_INTERFACE)
        {

	        AA_ACQUIRE_IF_LOCK(pInterface);

            //
            // Set it's state to indicate that a reconfig is pending.
            // and save away pNetPnPEvent for completion later.
            //
            if (   pInterface->ReconfigState != RECONFIG_NOT_IN_PROGRESS
                || pInterface->pReconfigEvent != NULL)
            {
	            AA_RELEASE_IF_LOCK(pInterface);
                //
                // We should not get here because this means that
                // we were asked to reconfigure when there was a
                // pending reconfiguration, which is not supposed to happen.
                //
                Status = NDIS_STATUS_FAILURE;
			    AA_ASSERT(FALSE);
            }
            else
            {
                pInterface->ReconfigState = RECONFIG_SHUTDOWN_PENDING;
                pInterface->pReconfigEvent = pNetPnPEvent;
		        pInterface->AdminState = IF_STATUS_DOWN;
                AtmArpReferenceInterface(pInterface); // Reconfig

	            AA_RELEASE_IF_LOCK(pInterface);

                //
                // Initiate shutdown in preparation of a restart.
                // AtmArpShutdown is responsible for
                // completing the ndis reconfig request asynchronously.
                //
                AtmArpShutdownInterface(pInterface);
                Status = NDIS_STATUS_PENDING;
            }

        }
        else
        {

            //
            // We didn't find the interface, fail the request...
            //
        
            Status = NDIS_STATUS_FAILURE;
        }
    } while (FALSE);


	return (Status);
}


NDIS_STATUS
AtmArpPnPEventHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNET_PNP_EVENT				pNetPnPEvent
)
/*++

Routine Description:

	This is the NDIS entry point called when NDIS wants to inform
	us about a PNP/PM event happening on an adapter. If the event
	is for us, we consume it. Otherwise, we pass this event along
	to IP along the first Interface on this adapter.

	When IP is done with it, it will call our IfPnPEventComplete
	routine.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMARP Adapter structure.

	pNetPnPEvent			- Pointer to the event.

Return Value:

	None

--*/
{
	PATMARP_ADAPTER					pAdapter;
	PATMARP_INTERFACE				pInterface;
	NDIS_STATUS						Status;

	PIP_PNP_RECONFIG_REQUEST		pIpReconfigReq;
	ULONG							Length;

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;

#ifdef NT
	do
	{
		pIpReconfigReq = (PIP_PNP_RECONFIG_REQUEST)pNetPnPEvent->Buffer;
		Length = pNetPnPEvent->BufferLength;

		//
		//  Is this directed to us?
		//
		if (pNetPnPEvent->NetEvent == NetEventReconfigure)
		{
			if (Length < sizeof(IP_PNP_RECONFIG_REQUEST))
			{
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			if (pIpReconfigReq->arpConfigOffset != 0)
			{
				Status = AtmArpPnPReconfigHandler(pAdapter, pNetPnPEvent);
				break;
			}
		}

		//
		//  This belongs to IP. Do we have a binding context?
		//
		if (pAdapter == NULL_PATMARP_ADAPTER)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		AA_STRUCT_ASSERT(pAdapter, aaa);
		pInterface = pAdapter->pInterfaceList;

		if ((pInterface != NULL_PATMARP_INTERFACE) &&
			(pInterface->IPContext != NULL))
		{
			AA_ASSERT(pInterface->IPPnPEventHandler != NULL);
			Status = (*pInterface->IPPnPEventHandler)(
						pInterface->IPContext,
						pNetPnPEvent
						);
		}
		else
		{
			Status = NDIS_STATUS_SUCCESS;
		}
		break;
	}
	while (FALSE);
#else
	Status = NDIS_STATUS_SUCCESS;
#endif // NT

	AADEBUGP(AAD_INFO,
			("PnPEventHandler: pIF 0x%x, pEvent 0x%x, Evt 0x%x, Status 0x%x\n",
				 pInterface, pNetPnPEvent, pNetPnPEvent->NetEvent, Status));

	return (Status);
}

#endif // _PNP_POWER_


NDIS_STATUS
AtmArpSendAdapterNdisRequest(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
)
/*++

Routine Description:

	Send an NDIS Request to query an adapter for information.
	If the request pends, block on the ATMARP Adapter structure
	till it completes.

Arguments:

	pAdapter				- Points to ATMARP Adapter structure
	pNdisRequest			- Pointer to NDIS request structure
	RequestType				- Set/Query information
	Oid						- OID to be passed in the request
	pBuffer					- place for value(s)
	BufferLength			- length of above

Return Value:

	The NDIS status of the request.

--*/
{
	NDIS_STATUS			Status;

	//
	//  Fill in the NDIS Request structure
	//
	pNdisRequest->RequestType = RequestType;
	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = 0;
	}

	AA_INIT_BLOCK_STRUCT(&(pAdapter->Block));

	NdisRequest(
		&Status,
		pAdapter->NdisAdapterHandle,
		pNdisRequest
		);

	if (Status == NDIS_STATUS_PENDING)
	{
		Status = AA_WAIT_ON_BLOCK_STRUCT(&(pAdapter->Block));
	}

	return (Status);
}





NDIS_STATUS
AtmArpGetAdapterInfo(
	IN	PATMARP_ADAPTER			pAdapter
)
/*++

Routine Description:

	Query an adapter for hardware-specific information that we need:
		- burnt in hardware address (ESI part)
		- Max packet size
		- line rate

Arguments:

	pAdapter		- Pointer to ATMARP adapter structure

Return Value:

	NDIS_STATUS_SUCCESS on success.
	Failure code on some non-ignorable failure (such as
	device doesn't support MTU >= 8196).

--*/
{
	NDIS_STATUS				Status;
	NDIS_REQUEST			NdisRequest;
	ULONG					Value;

	//
	//  Initialize.
	//
	AA_SET_MEM(pAdapter->MacAddress, 0, AA_ATM_ESI_LEN);


	do
	{
		//
		//  Description string: we first query this with a 0 length buffer
		//  length, so that we get the actual # of bytes needed. Then we
		//  allocate a buffer for the descriptor string, and use that to
		//  get the actual string.
		//
		Status = AtmArpSendAdapterNdisRequest(
							pAdapter,
							&NdisRequest,
							NdisRequestQueryInformation,
							OID_GEN_CO_VENDOR_DESCRIPTION,
							(PVOID)(pAdapter->pDescrString),
							0
							);
	
		if ((Status == NDIS_STATUS_INVALID_LENGTH) ||
			(Status == NDIS_STATUS_BUFFER_TOO_SHORT))
		{
			//
			//  Now allocate a buffer of the right length.
			//
			pAdapter->DescrLength = NdisRequest.DATA.QUERY_INFORMATION.BytesNeeded;
			AA_ALLOC_MEM(pAdapter->pDescrString, UCHAR, pAdapter->DescrLength);
			if (pAdapter->pDescrString != (PUCHAR)NULL)
			{
				Status = AtmArpSendAdapterNdisRequest(
									pAdapter,
									&NdisRequest,
									NdisRequestQueryInformation,
									OID_GEN_CO_VENDOR_DESCRIPTION,
									(PVOID)(pAdapter->pDescrString),
									pAdapter->DescrLength
									);
			}
			else
			{
				pAdapter->DescrLength = 0;
			}
			AADEBUGP(AAD_LOUD, ("GetAdapterInfo: Query VENDOR Descr2 ret 0x%x, DescrLen %d\n",
 							Status, pAdapter->DescrLength));
		}
		else
		{
			AADEBUGP(AAD_LOUD, ("GetAdapterInfo: Query VENDOR Descr1 ret 0x%x\n", Status));
		}
	
	
		//
		//  MAC Address:
		//
		Status = AtmArpSendAdapterNdisRequest(
							pAdapter,
							&NdisRequest,
							NdisRequestQueryInformation,
							OID_ATM_HW_CURRENT_ADDRESS,
							(PVOID)(pAdapter->MacAddress),
							AA_ATM_ESI_LEN
							);
	
		//
		//  Max Frame Size:
		//
		Status = AtmArpSendAdapterNdisRequest(
							pAdapter,
							&NdisRequest,
							NdisRequestQueryInformation,
							OID_ATM_MAX_AAL5_PACKET_SIZE,
							(PVOID)(&(pAdapter->MaxPacketSize)),
							sizeof(ULONG)
							);
	
		if (Status != NDIS_STATUS_SUCCESS)
		{
			//
			//  Use the default.
			//
			pAdapter->MaxPacketSize = AA_DEF_ATM_MAX_PACKET_SIZE;
		}
	
		if (pAdapter->MaxPacketSize > AA_MAX_ATM_MAX_PACKET_SIZE)
		{
			pAdapter->MaxPacketSize = AA_MAX_ATM_MAX_PACKET_SIZE;
		}
	
		//
		// Check that the adapter support the minimum.
		//
		if (pAdapter->MaxPacketSize < AA_MIN_ATM_MAX_PACKET_SIZE)
		{
			AADEBUGP(AAD_FATAL,
 				("GetAdapterInfo: (FATAL) MaxPacketSize of (%lu) is too small.\n",
									pAdapter->MaxPacketSize));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
	
	
	
		//
		//  Link speed:
		//
		Status = AtmArpSendAdapterNdisRequest(
							pAdapter,
							&NdisRequest,
							NdisRequestQueryInformation,
							OID_GEN_CO_LINK_SPEED,
							(PVOID)(&(pAdapter->LineRate)),
							sizeof(pAdapter->LineRate)
							);
	
		if ((Status != NDIS_STATUS_SUCCESS) ||
			(pAdapter->LineRate.Inbound == 0) ||
			(pAdapter->LineRate.Outbound == 0))
		{
			//
			//  Use the default.
			//
			pAdapter->LineRate.Outbound = pAdapter->LineRate.Inbound = AA_DEF_ATM_LINE_RATE;
			AADEBUGP(AAD_LOUD, ("Using default line rate %d bytes/sec\n",
									AA_DEF_ATM_LINE_RATE));
		}
		else
		{
			//
			//  Convert from 100 bits/sec to bytes/sec
			//
			pAdapter->LineRate.Outbound = (pAdapter->LineRate.Outbound * 100)/8;
			pAdapter->LineRate.Inbound = (pAdapter->LineRate.Inbound * 100)/8;
			AADEBUGP(AAD_LOUD, ("Got line rates from miniport: In %d, Out %d bytes/sec\n",
						pAdapter->LineRate.Outbound,
						pAdapter->LineRate.Inbound));
		}

		Status = NDIS_STATUS_SUCCESS;

	} while(FALSE);

	return Status;
}




NDIS_STATUS
AtmArpSendNdisRequest(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
)
/*++

Routine Description:

	Send an NDIS (non-Connection Oriented) request to the Miniport. We
	allocate an NDIS_REQUEST structure, link the supplied buffer to it,
	and send the request. If the request does not pend, we call our
	completion routine from here.

Arguments:

	pAdapter				- Pointer to our Adapter structure representing
							  the adapter to which the request is to be sent
	pNdisRequest			- Pointer to NDIS request structure
	RequestType				- Set/Query information
	Oid						- OID to be passed in the request
	pBuffer					- place for value(s)
	BufferLength			- length of above

Return Value:

	Status of the NdisRequest.

--*/
{
	NDIS_STATUS			Status;

	//
	//  Fill in the NDIS Request structure
	//
	pNdisRequest->RequestType = RequestType;
	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = 0;
	}

	NdisRequest(
			&Status,
			pAdapter->NdisAdapterHandle,
			pNdisRequest);
		
	return (Status);
}



VOID
AtmArpShutdownInterface(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Bring down the specified ARP interface.

	We tear down the ARP table, and shut down the Call Manager
	interface. When this is complete, we will call IP's DelInterface
	entry point.

Arguments:

	pInterface				- Points to the Interface to be shut down.

Return Value:

	None

--*/
{
	IP_STATUS				Status;
	INT						i;
	ULONG					rc;
	PATMARP_IP_ENTRY		pIpEntry;
	PATMARP_ATM_ENTRY		pAtmEntry;
	PATMARP_ATM_ENTRY		pNextAtmEntry;
	PATMARP_VC				pVc;
	PATMARP_VC				pNextVc;
	PATMARP_ADAPTER			pAdapter;
	BOOLEAN					WasRunning;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	pAdapter = pInterface->pAdapter;

	//
	//  Wait for any AF register processing to finish.
	//
	while (pAdapter->Flags & AA_ADAPTER_FLAGS_PROCESSING_AF)
	{
		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		AADEBUGP(AAD_FATAL, ("ShutdownIf: IF %p, pAdapter %x, Afregister going on!!!\n",
				 pInterface, pAdapter));
		Status = AA_WAIT_ON_BLOCK_STRUCT(&(pAdapter->UnbindBlock));
		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	}

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	//
	//  Stop any timer running on this interface
	//
	AA_ACQUIRE_IF_LOCK(pInterface);

	if (AtmArpStopTimer(&(pInterface->Timer), pInterface))
	{
		rc = AtmArpDereferenceInterface(pInterface);	// Timer ref
		AA_ASSERT(rc != 0);
	}
#ifdef IPMCAST
	//
	//  Stop any Multicast timer running on this interface
	//
	if (AtmArpStopTimer(&(pInterface->McTimer), pInterface))
	{
		rc = AtmArpDereferenceInterface(pInterface);	// Timer ref
		AA_ASSERT(rc != 0);
	}
#endif
	AA_RELEASE_IF_LOCK(pInterface);

	//
	//  Deregister all SAPs so that we don't get any more
	//  incoming calls.
	//
	AtmArpDeregisterSaps(pInterface);
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	//
	// We set the ARP Table state to "down" -- this will ensure that it
	// will not grow while we are shutting down.
	//
	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
	pInterface->ArpTableUp = FALSE;

	//
	//  Go through the ARP Table and abort all IP entries
	//
	for (i = 0; i < ATMARP_TABLE_SIZE; i++)
	{
		while (pInterface->pArpTable[i] != NULL_PATMARP_IP_ENTRY)
		{
			pIpEntry = pInterface->pArpTable[i];

			AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
			AA_REF_IE(pIpEntry, IE_REFTYPE_TMP);	// Shutdown Interface
			AA_RELEASE_IE_LOCK_DPC(pIpEntry);

		    AA_RELEASE_IF_TABLE_LOCK(pInterface);

			AA_ACQUIRE_IE_LOCK(pIpEntry);
			if (AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP))	// Shutdown Interface
			{
				AtmArpAbortIPEntry(pIpEntry);
				//
				//  IE Lock is released within the above.
				//
			}
			AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
		}
	}
	AA_RELEASE_IF_TABLE_LOCK(pInterface);

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

#ifdef IPMCAST
	//
	//  Delete all Join Entries
	//

	AA_ACQUIRE_IF_LOCK(pInterface);

	{
		PATMARP_IPMC_JOIN_ENTRY	pJoinEntry;
		PATMARP_IPMC_JOIN_ENTRY	pNextJoinEntry;

		for (pJoinEntry = pInterface->pJoinList;
 			pJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY;
 			pJoinEntry = pNextJoinEntry)
		{
			WasRunning = AtmArpStopTimer(&(pJoinEntry->Timer), pInterface);
			pNextJoinEntry = pJoinEntry->pNextJoinEntry;

			if (WasRunning)
			{
				rc = AA_DEREF_JE(pJoinEntry);	// ShutdownIF: timer stopped
			}
			else
			{
				rc = pJoinEntry->RefCount;
			}

			if (rc != 0)
			{
				(VOID)AA_DEREF_JE(pJoinEntry);	// ShutdownIF: kill Join Entry
			}
		}

		pInterface->pJoinList = NULL_PATMARP_IPMC_JOIN_ENTRY;
	}

	AA_RELEASE_IF_LOCK(pInterface);

#endif

	//
	// We set the AtmEntry list state to "down" (this will ensure that it
	// will not grow while we are shutting down), then
	// go through the list of ATM Entries on this interface, and
	// abort all of them.
	//

	AA_ACQUIRE_IF_ATM_LIST_LOCK(pInterface);
	pInterface->AtmEntryListUp = FALSE;

	pNextAtmEntry = pInterface->pAtmEntryList;

	if (pNextAtmEntry != NULL_PATMARP_ATM_ENTRY)
	{
		AA_ACQUIRE_AE_LOCK_DPC(pNextAtmEntry);
		AA_REF_AE(pNextAtmEntry, AE_REFTYPE_TMP);		// ShutdownInterface
		AA_RELEASE_AE_LOCK_DPC(pNextAtmEntry);
	}

	while (pNextAtmEntry != NULL_PATMARP_ATM_ENTRY)
	{
		pAtmEntry = pNextAtmEntry;
		pNextAtmEntry = pAtmEntry->pNext;

		//
		// Note that we still have the lock to pInterface when
		// we aquire the lock to pAtmEntry below. This order of aquiring
		// locks must be strictly followed everywhere in order to prevent
		// a deadlock.
		//
		// We can't release the LIST_LOCK without first addrefing pAtmEntry,
		// otherwise while both locks are free someone else can delref and
		// possibly deallocate pAtmEntry.
		//
		if (pNextAtmEntry != NULL_PATMARP_ATM_ENTRY)
		{
			AA_ACQUIRE_AE_LOCK_DPC(pNextAtmEntry);
			AA_REF_AE(pNextAtmEntry, AE_REFTYPE_TMP);		// ShutdownInterface
			AA_RELEASE_AE_LOCK_DPC(pNextAtmEntry);
		}

		AA_RELEASE_IF_ATM_LIST_LOCK(pInterface);

		AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

		AA_ACQUIRE_AE_LOCK(pAtmEntry);

		if (AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP) != 0)	// ShutdownInterface
		{
			AtmArpInvalidateAtmEntry(
				pAtmEntry,
				TRUE		// we ARE shutting down
				);
			//
			//  The ATM Entry lock is released within the above.
			//
		}

		AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
		AA_ACQUIRE_IF_ATM_LIST_LOCK(pInterface);
	}
	AA_RELEASE_IF_ATM_LIST_LOCK(pInterface);
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	//
	//  Go through the list of unresolved VCs on this interface,
	//  and close all of them.
	//
	AA_ACQUIRE_IF_LOCK(pInterface);
	pVc = pInterface->pUnresolvedVcs;
	pInterface->pUnresolvedVcs = NULL_PATMARP_VC;

	while (pVc != NULL_PATMARP_VC)
	{
		pNextVc = pVc->pNextVc;

		AA_RELEASE_IF_LOCK(pInterface);

		AA_ACQUIRE_VC_LOCK(pVc);
		if (AtmArpDereferenceVc(pVc) != 0)	// Unresolved VC list entry
		{
			AtmArpCloseCall(pVc);
			//
			//  the VC lock is released within the above.
			//
		}
		
		pVc = pNextVc;
		AA_ACQUIRE_IF_LOCK(pInterface);
	}

	AA_RELEASE_IF_LOCK(pInterface);
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);


	//
	//  Close the Call Manager interface.
	//
	AtmArpCloseCallMgr(pInterface);

}




BOOLEAN
AtmArpIsDeviceAlreadyBound(
	IN	PNDIS_STRING				pDeviceName
)
/*++

Routine Description:

	Check if we have already bound to a device (adapter).

Arguments:

	pDeviceName		- Points to device name to be checked.

Return Value:

	TRUE iff we already have an Adapter structure representing
	this device.

--*/
{
	PATMARP_ADAPTER	pAdapter;
	BOOLEAN			bFound = FALSE;

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	for (pAdapter = pAtmArpGlobalInfo->pAdapterList;
		 pAdapter != NULL_PATMARP_ADAPTER;
		 pAdapter = pAdapter->pNextAdapter)
	{
		if ((pDeviceName->Length == pAdapter->DeviceName.Length) &&
			(AA_MEM_CMP(pDeviceName->Buffer,
						pAdapter->DeviceName.Buffer,
						pDeviceName->Length) == 0))
		{
			bFound = TRUE;
			break;
		}
	}

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	return (bFound);
}

#if ATMOFFLOAD

NDIS_STATUS
AtmArpQueryAndEnableOffload(
	IN	PATMARP_ADAPTER				pAdapter
)
/*++

Routine Description:

	Query the capabilities of the adapter and set all recognized offload capabilities.
	Set pMaxOffLoadSize and pMinSegmentCount to the corresponding values, and
	also set pInterface->OffloadFlags to the set of enabled tasks.


Arguments:

	pAdapter		- The adapter on which to enable offloading.

Return Value:

	TRUE iff the operation was either succesful or no tasks were enabled. False
	if there was a fatal error.

--*/
{
	NDIS_STATUS 				Status 		= STATUS_BUFFER_OVERFLOW;
	PNDIS_TASK_OFFLOAD_HEADER 	pHeader		= NULL;

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	pAdapter->Offload.Flags 			= 0;
	pAdapter->Offload.MaxOffLoadSize	= 0;
	pAdapter->Offload.MinSegmentCount	= 0;
	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	do
	{
        PNDIS_TASK_OFFLOAD  		pTask;
		ULONG						Flags 			= 0;
		UINT 						MaxOffLoadSize	= 0;
		UINT 						MinSegmentCount	= 0;
		NDIS_TASK_IPSEC     		ipsecCaps;
		UINT						BufferSize		= 0;
		NDIS_REQUEST				NdisRequest;

		//
		// Query capabilities
		//
		{
			NDIS_TASK_OFFLOAD_HEADER Header;
			AA_SET_MEM(&Header, 0, sizeof(Header));
	
			Header.EncapsulationFormat.Flags.FixedHeaderSize = 1;
			Header.EncapsulationFormat.EncapsulationHeaderSize =
													AA_PKT_LLC_SNAP_HEADER_LENGTH;
			Header.EncapsulationFormat.Encapsulation = 
													LLC_SNAP_ROUTED_Encapsulation;
			Header.Version = NDIS_TASK_OFFLOAD_VERSION;
			Header.Size = sizeof(Header);
	
			AADEBUGP(AAD_INFO, ("Querying for Task offload\n"));
	
			Status =  AtmArpSendAdapterNdisRequest(
						pAdapter,
						&NdisRequest,
						NdisRequestQueryInformation,
						OID_TCP_TASK_OFFLOAD,
						&Header,
						sizeof(Header)
						);

			if ((Status == NDIS_STATUS_INVALID_LENGTH) ||
				(Status == NDIS_STATUS_BUFFER_TOO_SHORT)) {
	
				//
				// Alloc the proper-sized buffer and query a 2nd time...
				//

				BufferSize = NdisRequest.DATA.QUERY_INFORMATION.BytesNeeded;

				AA_ALLOC_MEM(pHeader, NDIS_TASK_OFFLOAD_HEADER, BufferSize);
	
				if (pHeader != NULL)
				{
					*pHeader = Header; // struct copy.

					Status =  AtmArpSendAdapterNdisRequest(
								pAdapter,
								&NdisRequest,
								NdisRequestQueryInformation,
								OID_TCP_TASK_OFFLOAD,
								pHeader,
								BufferSize
								);
				}
			}
		}

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_INFO, ("Query Offload failed. Status=%x\n", Status));
			break;
		}

		if (	pHeader == NULL
		    ||	pHeader->OffsetFirstTask == 0)
		{
			AADEBUGP(AAD_INFO, ("No tasks to offload\n"));
			break;
		}

		AA_ASSERT(pHeader->OffsetFirstTask == sizeof(NDIS_TASK_OFFLOAD_HEADER));

		AADEBUGP(AAD_WARNING,
			("Something to Offload. Offload buffer size %x\n", BufferSize));

		//
        // Parse the buffer for Checksum and tcplargesend offload capabilities
		//
		for (
			pTask =  (NDIS_TASK_OFFLOAD *) ((UCHAR *)pHeader
											 + pHeader->OffsetFirstTask);
			1; // we break when done
			pTask = (PNDIS_TASK_OFFLOAD) ((PUCHAR)pTask + pTask->OffsetNextTask))
		{

			if (pTask->Task == TcpIpChecksumNdisTask)
			{
				//
				//this adapter supports checksum offload
				//check if tcp and/or  ip chksums bits are present
				//

				PNDIS_TASK_TCP_IP_CHECKSUM ChecksumInfo
						= (PNDIS_TASK_TCP_IP_CHECKSUM) pTask->TaskBuffer;

				// if (ChecksumInfo->V4Transmit.V4Checksum) (commented out in arpc.c)
				{

						AADEBUGP(AAD_INFO, ("V4 Checksum offload\n"));

						if (ChecksumInfo->V4Transmit.TcpChecksum) {
							Flags |= TCP_XMT_CHECKSUM_OFFLOAD;
							AADEBUGP(AAD_INFO, (" Tcp Checksum offload\n"));
						}

						if (ChecksumInfo->V4Transmit.IpChecksum) {
							Flags |= IP_XMT_CHECKSUM_OFFLOAD;
							AADEBUGP(AAD_INFO, (" IP xmt Checksum offload\n"));
						}

						if (ChecksumInfo->V4Receive.TcpChecksum) {
							Flags |= TCP_RCV_CHECKSUM_OFFLOAD;
							AADEBUGP(AAD_INFO, (" Tcp Rcv Checksum offload\n"));
						}

						if (ChecksumInfo->V4Receive.IpChecksum) {
							Flags |= IP_RCV_CHECKSUM_OFFLOAD;
							AADEBUGP(AAD_INFO, (" IP rcv  Checksum offload\n"));
						}
				}

			}
			else if (pTask->Task == TcpLargeSendNdisTask)
			{

				PNDIS_TASK_TCP_LARGE_SEND TcpLargeSend, in_LargeSend =
								(PNDIS_TASK_TCP_LARGE_SEND)pTask->TaskBuffer;

				Flags |= TCP_LARGE_SEND_OFFLOAD;

				MaxOffLoadSize = in_LargeSend->MaxOffLoadSize;
				MinSegmentCount = in_LargeSend->MinSegmentCount;

				AADEBUGP(AAD_INFO, (" Tcp large send!! \n"));

			}
			else if (pTask->Task == IpSecNdisTask)
			{
				PNDIS_TASK_IPSEC pIPSecCaps =
										(PNDIS_TASK_IPSEC) pTask->TaskBuffer;
				//
				// Save off the capabilities for setting them later.
				//
				ipsecCaps = *pIPSecCaps;


                //
                // CryptoOnly is assumed if we have IpSecNdisTask
                //
                Flags |= IPSEC_OFFLOAD_CRYPTO_ONLY;

                //
                // Do Support first
                //

                if (pIPSecCaps->Supported.AH_ESP_COMBINED) {
                       Flags |= IPSEC_OFFLOAD_AH_ESP;
                       AADEBUGP(AAD_INFO, ("AH_ESP\n"));
                }

                if (pIPSecCaps->Supported.TRANSPORT_TUNNEL_COMBINED) {
                       Flags |= IPSEC_OFFLOAD_TPT_TUNNEL;
                       AADEBUGP(AAD_INFO, ("TPT_TUNNEL\n"));
                }

                if (pIPSecCaps->Supported.V4_OPTIONS) {
                       Flags |= IPSEC_OFFLOAD_V4_OPTIONS;
                       AADEBUGP(AAD_INFO, ("V4_OPTIONS\n"));
                }

                if (pIPSecCaps->Supported.RESERVED) {
                       pIPSecCaps->Supported.RESERVED = 0;
                       //Flags |= IPSEC_OFFLOAD_QUERY_SPI;
                       AADEBUGP(AAD_INFO, ("QUERY_SPI\n"));
                }

                //
                // Do V4AH next
                //

                if (pIPSecCaps->V4AH.MD5) {
                       Flags |= IPSEC_OFFLOAD_AH_MD5;
                       AADEBUGP(AAD_INFO, ("MD5\n"));
                }

				if (pIPSecCaps->V4AH.SHA_1) {
					Flags |= IPSEC_OFFLOAD_AH_SHA_1;
					AADEBUGP(AAD_INFO, ("SHA\n"));
				}

				if (pIPSecCaps->V4AH.Transport) {
					Flags |= IPSEC_OFFLOAD_AH_TPT;
					AADEBUGP(AAD_INFO, ("AH_TRANSPORT\n"));
				}

				if (pIPSecCaps->V4AH.Tunnel) {
					Flags |= IPSEC_OFFLOAD_AH_TUNNEL;
					AADEBUGP(AAD_INFO, ("AH_TUNNEL\n"));
				}

				if (pIPSecCaps->V4AH.Send) {
					Flags |= IPSEC_OFFLOAD_AH_XMT;
					AADEBUGP(AAD_INFO, ("AH_XMT\n"));
				}

				if (pIPSecCaps->V4AH.Receive) {
					Flags |= IPSEC_OFFLOAD_AH_RCV;
					AADEBUGP(AAD_INFO, ("AH_RCV\n"));
				}

				//
				// Do V4ESP next
				//

				if (pIPSecCaps->V4ESP.DES) {
					Flags |= IPSEC_OFFLOAD_ESP_DES;
					AADEBUGP(AAD_INFO, ("ESP_DES\n"));
				}

				if (pIPSecCaps->V4ESP.RESERVED) {
				    pIPSecCaps->V4ESP.RESERVED = 0;
					//Flags |= IPSEC_OFFLOAD_ESP_DES_40;
					AADEBUGP(AAD_INFO, ("ESP_DES_40\n"));
				}

				if (pIPSecCaps->V4ESP.TRIPLE_DES) {
					Flags |= IPSEC_OFFLOAD_ESP_3_DES;
					AADEBUGP(AAD_INFO, ("ESP_3_DES\n"));
				}

				if (pIPSecCaps->V4ESP.NULL_ESP) {
					Flags |= IPSEC_OFFLOAD_ESP_NONE;
					AADEBUGP(AAD_INFO, ("ESP_NONE\n"));
				}

				if (pIPSecCaps->V4ESP.Transport) {
					Flags |= IPSEC_OFFLOAD_ESP_TPT;
					AADEBUGP(AAD_INFO, ("ESP_TRANSPORT\n"));
				}

				if (pIPSecCaps->V4ESP.Tunnel) {
					Flags |= IPSEC_OFFLOAD_ESP_TUNNEL;
					AADEBUGP(AAD_INFO, ("ESP_TUNNEL\n"));
				}

				if (pIPSecCaps->V4ESP.Send) {
					Flags |= IPSEC_OFFLOAD_ESP_XMT;
					AADEBUGP(AAD_INFO, ("ESP_XMT\n"));
				}

				if (pIPSecCaps->V4ESP.Receive) {
					Flags |= IPSEC_OFFLOAD_ESP_RCV;
					AADEBUGP(AAD_INFO, ("ESP_RCV\n"));
				}
			}

			if (pTask->OffsetNextTask == 0)
			{
				break; // No more tasks.
			}

		} // for

		//
		// Done parsing supported tasks.
        // Now construct the set of tasks we actually want to enable.
        //
        if (Flags)
        {
        	UINT *pPrevOffset = &pHeader->OffsetFirstTask;

			AADEBUGP(AAD_WARNING, ("Enabling H/W capabilities: %lx\n", Flags));

        	//
        	// Zero out the buffer beyond the task offload header structure
        	//
			AA_SET_MEM(pTask, 0, BufferSize-sizeof(*pHeader));
        	pHeader->OffsetFirstTask = 0;
        	pTask = (NDIS_TASK_OFFLOAD *) (pHeader+1);
	
			if ((Flags & TCP_XMT_CHECKSUM_OFFLOAD) ||
				(Flags & IP_XMT_CHECKSUM_OFFLOAD) ||
				(Flags & TCP_RCV_CHECKSUM_OFFLOAD) ||
				(Flags & IP_RCV_CHECKSUM_OFFLOAD))
			{
	
				PNDIS_TASK_TCP_IP_CHECKSUM ChksumBuf =
						 (PNDIS_TASK_TCP_IP_CHECKSUM)pTask->TaskBuffer;

				*pPrevOffset = (UINT) ((PUCHAR)pTask - (PUCHAR)pHeader);
				pPrevOffset  = &pTask->OffsetNextTask;

				pTask->Task = TcpIpChecksumNdisTask;
				pTask->TaskBufferLength = sizeof(NDIS_TASK_TCP_IP_CHECKSUM);
	
				if (Flags & TCP_XMT_CHECKSUM_OFFLOAD)
				{
					ChksumBuf->V4Transmit.TcpChecksum = 1;
					//ChksumBuf->V4Transmit.V4Checksum = 1;
				}
	
				if (Flags & IP_XMT_CHECKSUM_OFFLOAD)
				{
					ChksumBuf->V4Transmit.IpChecksum = 1;
					//ChksumBuf->V4Transmit.V4Checksum = 1;
				}
	
				if (Flags & TCP_RCV_CHECKSUM_OFFLOAD)
				{
					ChksumBuf->V4Receive.TcpChecksum = 1;
					//ChksumBuf->V4Receive.V4Checksum = 1;
				}
	
				if (Flags & IP_RCV_CHECKSUM_OFFLOAD)
				{
					ChksumBuf->V4Receive.IpChecksum = 1;
					//ChksumBuf->V4Receive.V4Checksum = 1;
				}
	
				//
				// Point to place where next task goes...
				//
				pTask = (PNDIS_TASK_OFFLOAD) (ChksumBuf+1);
	
			}
	
			if (Flags & TCP_LARGE_SEND_OFFLOAD)
			{
	
				PNDIS_TASK_TCP_LARGE_SEND out_LargeSend =
						 (PNDIS_TASK_TCP_LARGE_SEND)pTask->TaskBuffer;
	
				*pPrevOffset = (UINT) ((PUCHAR)pTask - (PUCHAR)pHeader);
				pPrevOffset  = &pTask->OffsetNextTask;

				pTask->Task = TcpLargeSendNdisTask;
				pTask->TaskBufferLength = sizeof(NDIS_TASK_TCP_LARGE_SEND);
	
				out_LargeSend->MaxOffLoadSize = MaxOffLoadSize;
				out_LargeSend->MinSegmentCount = MinSegmentCount;
	
				//
				// Point to place where next task goes...
				//
				pTask = (PNDIS_TASK_OFFLOAD) (out_LargeSend+1);
			}
	
			if ((Flags & (IPSEC_OFFLOAD_AH_XMT |
										IPSEC_OFFLOAD_AH_RCV |
										IPSEC_OFFLOAD_ESP_XMT |
										IPSEC_OFFLOAD_ESP_RCV)))
			{
	
				PNDIS_TASK_IPSEC pIPSecCaps =
							 (PNDIS_TASK_IPSEC)pTask->TaskBuffer;
	
				*pPrevOffset = (UINT) ((PUCHAR)pTask - (PUCHAR)pHeader);
				pPrevOffset  = &pTask->OffsetNextTask;

				//
				// plunk down the advertised capabilities
				//
	
				pTask->Task = IpSecNdisTask;
				pTask->TaskBufferLength = sizeof(NDIS_TASK_IPSEC);
	
				//
				// Point to place where next task goes...
				//
				pTask = (PNDIS_TASK_OFFLOAD) (pIPSecCaps+1);
			}
		}

		//
		// Having constructed the set of tasks to enable, we actually attempt
		// to enable them...
		//
		if (pHeader->OffsetFirstTask)
		{
			//
			//  At least one task to enable, let's enable ...
			//
			UINT SetBufferSize =  (UINT) ((PUCHAR)pTask - (PUCHAR)pHeader);

			AA_ASSERT(SetBufferSize <= BufferSize);
			AADEBUGP(AAD_WARNING,
			("Setting offload tasks: %x bytes. Miniport returned %x bytes\n",
			SetBufferSize, BufferSize));

			Status =  AtmArpSendAdapterNdisRequest(
						pAdapter,
						&NdisRequest,
						NdisRequestSetInformation,
						OID_TCP_TASK_OFFLOAD,
						pHeader,
						SetBufferSize
						);

			if (Status != NDIS_STATUS_SUCCESS)
			{
	
				AADEBUGP(AAD_WARNING,
					("ARP: Failed to set offload tasks: %lx, status: %lx\n",
					 Flags, Status));
			}
			else
			{
				AADEBUGP(AAD_WARNING,
					("ARP: Succeeded setting offload tasks: %lx:\n", Flags));

				AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
				pAdapter->Offload.Flags 			= Flags;
				pAdapter->Offload.MaxOffLoadSize	= MaxOffLoadSize;
				pAdapter->Offload.MinSegmentCount	= MinSegmentCount;
				AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
			}
		}

    } while (FALSE);


	if (pHeader != NULL)
	{
		AA_FREE_MEM(pHeader);
	}

	//
	// We return success unless there was a fatal error and there was none...
	//

    return NDIS_STATUS_SUCCESS;
}


VOID
AtmArpDisableOffload(
	IN	PATMARP_ADAPTER			pAdapter
)
/*++

Routine Description:

	Disable offload capabilities, if enabled for this interface.

Arguments:

	pAdapter		- The adapter on which to disable offloading.

Return Value:

	TRUE iff the operation was either succesful or no tasks were enabled. False
	if there was a fatal error.

--*/
{
	ULONG Flags;
	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	Flags =  pAdapter->Offload.Flags;
	pAdapter->Offload.Flags = 0;
	pAdapter->Offload.MaxOffLoadSize	= 0;
	pAdapter->Offload.MinSegmentCount	= 0;

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	if (Flags)
	{
		NDIS_REQUEST				NdisRequest;
		NDIS_TASK_OFFLOAD_HEADER 	Header;
		AA_SET_MEM(&Header, 0, sizeof(Header));
	
		Header.EncapsulationFormat.Flags.FixedHeaderSize = 1;
		Header.EncapsulationFormat.EncapsulationHeaderSize = 2;
		Header.EncapsulationFormat.Encapsulation = 
												LLC_SNAP_ROUTED_Encapsulation;
		Header.Version = NDIS_TASK_OFFLOAD_VERSION;
		Header.Size = sizeof(Header);

		//
		// Header.OffsetFirstTask == 0 tells the miniport to disable all tasks.
		//
	
		AADEBUGP(AAD_WARNING, ("Disabling all offloaded tasks for this adapter\n"));
	
		AtmArpSendAdapterNdisRequest(
					pAdapter,
					&NdisRequest,
					NdisRequestSetInformation,
					OID_TCP_TASK_OFFLOAD,
					&Header,
					sizeof(Header)
					);
	}

}

#endif // ATMOFFLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\arpcfg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arpcfg.c - Configuration routines

Abstract:

	Routines to read in configuration information for the ATMARP client.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-09-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'GFCA'

//
//  Size of local temp buffer
//
#define WORK_BUF_SIZE		200


#define ASCII_TO_INT(val)		\
			( ( ((val) >= '0') && ('9' >= (val)) ) ? ((val) - '0') :	\
			  ( ((val) >= 'a') && ('z' >= (val)) ) ? ((val) - 'a' + 10) :	\
			  ( ((val) >= 'A') && ('Z' >= (val)) ) ? ((val) - 'A' + 10) :	\
			  0 )


//
//  Parameters for reading in a ULONG from configuration into an Interface
//  structure.
//
typedef struct _AA_READ_CONFIG_PARAMS
{
	ULONG			StructOffset;	// Offset of param from beginning of struct
	PWCHAR			ParameterName;	// Name in config database
	ULONG			DefaultValue;
} AA_READ_CONFIG_PARAMS, *PAA_READ_CONFIG_PARAMS;

#define AA_MAKE_RCP(Off, Name, Dflt)	\
		{ Off, Name, Dflt }

#define LIS_CONFIG_ENTRY(Field, Name, Dflt)	\
		AA_MAKE_RCP(FIELD_OFFSET(struct _ATMARP_INTERFACE, Field), Name, Dflt)

#define AA_BANDWIDTH_UNSPECIFIED		((ULONG)-1)
#define AA_PACKET_SIZE_UNSPECIFIED		((ULONG)-1)
#define AA_MTU_UNSPECIFIED				((ULONG)-1)
#define AA_SPEED_UNSPECIFIED			((ULONG)-1)

//
//  List of ULONG parameters for an LIS
//
AA_READ_CONFIG_PARAMS AtmArpLISConfigTable[] =
{
	LIS_CONFIG_ENTRY(SapSelector, L"SapSelector", AA_DEF_SELECTOR_VALUE),
	LIS_CONFIG_ENTRY(HeaderPool[AA_HEADER_TYPE_UNICAST].MaxHeaderBufs, L"MaxHeaderBufs", AA_DEF_MAX_HEADER_BUFFERS),
	LIS_CONFIG_ENTRY(HeaderPool[AA_HEADER_TYPE_UNICAST].HeaderBufSize, L"HeaderBufSize", AA_PKT_LLC_SNAP_HEADER_LENGTH),
#ifdef IPMCAST
	LIS_CONFIG_ENTRY(HeaderPool[AA_HEADER_TYPE_NUNICAST].MaxHeaderBufs, L"McastMaxHeaderBufs", AA_DEF_MAX_HEADER_BUFFERS),
	LIS_CONFIG_ENTRY(HeaderPool[AA_HEADER_TYPE_NUNICAST].HeaderBufSize, L"McastHeaderBufSize", sizeof(AA_MC_PKT_TYPE1_SHORT_HEADER)),
#endif // IPMCAST
	LIS_CONFIG_ENTRY(ProtocolBufSize, L"ProtocolBufSize", AA_DEF_PROTOCOL_BUFFER_SIZE),
	LIS_CONFIG_ENTRY(MaxProtocolBufs, L"MaxProtocolBufs", AA_DEF_MAX_PROTOCOL_BUFFERS),
	LIS_CONFIG_ENTRY(MTU, L"MTU", AA_MTU_UNSPECIFIED),
	LIS_CONFIG_ENTRY(Speed, L"Speed", AA_SPEED_UNSPECIFIED),
	LIS_CONFIG_ENTRY(PVCOnly, L"PVCOnly", AA_DEF_PVC_ONLY_VALUE),
	LIS_CONFIG_ENTRY(ServerConnectInterval, L"ServerConnectInterval", AA_DEF_SERVER_CONNECT_INTERVAL),
	LIS_CONFIG_ENTRY(ServerRegistrationTimeout, L"ServerRegistrationTimeout", AA_DEF_SERVER_REGISTRATION_TIMEOUT),
	LIS_CONFIG_ENTRY(AddressResolutionTimeout, L"AddressResolutionTimeout", AA_DEF_ADDRESS_RESOLUTION_TIMEOUT),
	LIS_CONFIG_ENTRY(ARPEntryAgingTimeout, L"ARPEntryAgingTimeout", AA_DEF_ARP_ENTRY_AGING_TIMEOUT),
	LIS_CONFIG_ENTRY(InARPWaitTimeout, L"InARPWaitTimeout", AA_DEF_INARP_WAIT_TIMEOUT),
	LIS_CONFIG_ENTRY(ServerRefreshTimeout, L"ServerRefreshTimeout", AA_DEF_SERVER_REFRESH_INTERVAL),
	LIS_CONFIG_ENTRY(MinWaitAfterNak, L"MinWaitAfterNak", AA_DEF_MIN_WAIT_AFTER_NAK),
	LIS_CONFIG_ENTRY(MaxRegistrationAttempts, L"MaxRegistrationAttempts", AA_DEF_MAX_REGISTRATION_ATTEMPTS),
	LIS_CONFIG_ENTRY(MaxResolutionAttempts, L"MaxResolutionAttempts", AA_DEF_MAX_RESOLUTION_ATTEMPTS),

	LIS_CONFIG_ENTRY(DefaultFlowSpec.SendPeakBandwidth, L"DefaultSendBandwidth", AA_BANDWIDTH_UNSPECIFIED),
	LIS_CONFIG_ENTRY(DefaultFlowSpec.ReceivePeakBandwidth, L"DefaultReceiveBandwidth", AA_BANDWIDTH_UNSPECIFIED),
	LIS_CONFIG_ENTRY(DefaultFlowSpec.SendMaxSize, L"DefaultSendMaxSize", AA_PACKET_SIZE_UNSPECIFIED),
	LIS_CONFIG_ENTRY(DefaultFlowSpec.ReceiveMaxSize, L"DefaultReceiveMaxSize", AA_PACKET_SIZE_UNSPECIFIED),
	LIS_CONFIG_ENTRY(DefaultFlowSpec.SendServiceType, L"DefaultServiceType", AA_DEF_FLOWSPEC_SERVICETYPE),
	LIS_CONFIG_ENTRY(DefaultFlowSpec.AgingTime, L"DefaultVCAgingTimeout", AA_DEF_VC_AGING_TIMEOUT)
#ifdef IPMCAST
	,
	LIS_CONFIG_ENTRY(MARSConnectInterval, L"MARSConnectInterval", AA_DEF_SERVER_CONNECT_INTERVAL),
	LIS_CONFIG_ENTRY(MARSRegistrationTimeout, L"MARSRegistrationTimeout", AA_DEF_SERVER_REGISTRATION_TIMEOUT),
	LIS_CONFIG_ENTRY(MARSKeepAliveTimeout, L"MARSKeepAliveTimeout", AA_DEF_MARS_KEEPALIVE_TIMEOUT),
	LIS_CONFIG_ENTRY(JoinTimeout, L"JoinTimeout", AA_DEF_MARS_JOIN_TIMEOUT),
	LIS_CONFIG_ENTRY(LeaveTimeout, L"LeaveTimeout", AA_DEF_MARS_LEAVE_TIMEOUT),
	LIS_CONFIG_ENTRY(MaxDelayBetweenMULTIs, L"MaxDelayBetweenMULTIs", AA_DEF_MULTI_TIMEOUT),
	LIS_CONFIG_ENTRY(MulticastEntryAgingTimeout, L"MulticastEntryAgingTimeout", AA_DEF_MCAST_IP_ENTRY_AGING_TIMEOUT),
	LIS_CONFIG_ENTRY(MinRevalidationDelay, L"MinMulticastRevalidationDelay", AA_DEF_MIN_MCAST_REVALIDATION_DELAY),
	LIS_CONFIG_ENTRY(MaxRevalidationDelay, L"MaxMulticastRevalidationDelay", AA_DEF_MAX_MCAST_REVALIDATION_DELAY),
	LIS_CONFIG_ENTRY(MinPartyRetryDelay, L"MinMulticastPartyRetryDelay", AA_DEF_MIN_MCAST_PARTY_RETRY_DELAY),
	LIS_CONFIG_ENTRY(MaxPartyRetryDelay, L"MaxMulticastPartyRetryDelay", AA_DEF_MAX_MCAST_PARTY_RETRY_DELAY),
	LIS_CONFIG_ENTRY(MaxJoinOrLeaveAttempts, L"MaxJoinLeaveAttempts", AA_DEF_MAX_JOIN_LEAVE_ATTEMPTS)

#endif // IPMCAST
};


//
//  Size of above table.
//
#define LIS_CONFIG_ENTRIES	\
		sizeof(AtmArpLISConfigTable)/sizeof(AA_READ_CONFIG_PARAMS)


//
//  Names of LIS parameters and subkey names that don't appear
//  in the above table.
//

#define AA_LIS_IP_CONFIG_STRING					L"IPConfig"
#define AA_LIS_ATMARP_SERVER_LIST_KEY			L"ARPServerList"
#define AA_LIS_MARS_SERVER_LIST_KEY				L"MARServerList"
#define AA_LIS_ATMARP_SERVER_ADDRESS			L"AtmAddress"
#define AA_LIS_ATMARP_SERVER_SUBADDRESS			L"AtmSubaddress"

#define AA_LIS_STATIC_ARP_LIST					L"StaticArpList"

#ifdef DHCP_OVER_ATM
#define AA_LIS_DHCP_SERVER_ATM_ADDRESS			L"DhcpServerAtmAddress"
#endif // DHCP_OVER_ATM


#ifdef QOS_HEURISTICS

#define AA_LIS_FLOW_INFO_KEY					L"FlowInfo"
#define AA_LIS_FLOW_INFO_ENABLED				L"FlowInfoEnabled"

#define FLOW_CONFIG_ENTRY(Field, Name, Dflt)	\
		AA_MAKE_RCP(FIELD_OFFSET(struct _ATMARP_FLOW_INFO, Field), Name, Dflt)


AA_READ_CONFIG_PARAMS AtmArpFlowConfigTable[] =
{
	FLOW_CONFIG_ENTRY(PacketSizeLimit, L"PacketSizeLimit", AAF_DEF_LOWBW_SEND_THRESHOLD),
	FLOW_CONFIG_ENTRY(FlowSpec.SendPeakBandwidth, L"SendBandwidth", AAF_DEF_LOWBW_SEND_BANDWIDTH),
	FLOW_CONFIG_ENTRY(FlowSpec.ReceivePeakBandwidth, L"ReceiveBandwidth", AAF_DEF_LOWBW_RECV_BANDWIDTH),
	FLOW_CONFIG_ENTRY(FlowSpec.SendServiceType, L"ServiceType", AAF_DEF_LOWBW_SERVICETYPE),
	FLOW_CONFIG_ENTRY(FlowSpec.Encapsulation, L"Encapsulation", AAF_DEF_LOWBW_ENCAPSULATION),
	FLOW_CONFIG_ENTRY(FlowSpec.AgingTime, L"AgingTime", AAF_DEF_LOWBW_AGING_TIME),
};

#define AA_FLOW_INFO_ENTRIES		\
			(sizeof(AtmArpFlowConfigTable)/sizeof(AA_READ_CONFIG_PARAMS))


#endif // QOS_HEURISTICS



EXTERN
NDIS_STATUS
AtmArpCfgReadAdapterConfiguration(
	IN	PATMARP_ADAPTER				pAdapter
)
/*++

Routine Description:

	Reads the following adapter configuration information from the
	registry:
		* pAdapter->ConfigString (MultiSz list of LISs for this adapter).

Arguments:

	pAdapter				- Points to our adapter structure.

Return Value:

	NDIS Status code

--*/
{
	NDIS_HANDLE			ConfigHandle;
	NDIS_STATUS			Status;
	PNDIS_STRING		pConfigString = &pAdapter->ConfigString;

	NdisOpenProtocolConfiguration(
						&Status,
						&ConfigHandle,
						pConfigString
						);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		ConfigHandle = NULL;
	}
	else
	{
		//
		//  Read in the IPConfig string. If this is not present,
		//  fail this call.
		//
		NDIS_STRING						IPConfigName = NDIS_STRING_CONST("IPConfig");
		PNDIS_CONFIGURATION_PARAMETER	pParam;

		NdisReadConfiguration(
				&Status,
				&pParam,
				ConfigHandle,
				&IPConfigName,
				NdisParameterMultiString
				);

		if ((Status == NDIS_STATUS_SUCCESS) &&
			(pParam->ParameterType == NdisParameterMultiString))
		{
            NDIS_STRING *pSrcString   = &(pParam->ParameterData.StringData);
            NDIS_STRING *pDestString  = &(pAdapter->IPConfigString);
            PWSTR Buffer = NULL;
            
			AA_ALLOC_MEM(Buffer, WCHAR, pSrcString->Length*sizeof(*Buffer));

            if (Buffer == NULL)
            {
			    Status = NDIS_STATUS_RESOURCES;
            }
            else
            {
                AA_COPY_MEM(
                        Buffer,
                        pSrcString->Buffer,
                        pSrcString->Length
                        );
			    
                pDestString->Buffer = Buffer;
                pDestString->Length = pSrcString->Length;
                pDestString->MaximumLength = pSrcString->Length;
            }
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
		}

	}

	if (ConfigHandle != NULL)
	{
		NdisCloseConfiguration(ConfigHandle);
		ConfigHandle = NULL;
	}

	AADEBUGP(AAD_VERY_LOUD,
			 ("OpenAdapterConfig: pAdapter 0x%x, Status 0x%x\n",
					pAdapter, Status));

	return Status;
}




NDIS_HANDLE
AtmArpCfgOpenLISConfiguration(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	UINT						LISNumber
#ifdef NEWARP
	,
	OUT	PNDIS_STRING				pIPConfigString
#endif // NEWARP
)
/*++

Routine Description:

	Open and return a handle to the configuration section for the
	given LIS.

Arguments:

	pAdapter				- Points to our adapter context.
	LISNumber				- The zero-based index for the LIS.
	pIPConfigString			- Place where we return the IP Configuration
							  string for this interface.
Return Value:

	A valid handle if successful, NULL otherwise.

--*/
{
	NDIS_HANDLE				AdapterConfigHandle;
	NDIS_HANDLE				SubkeyHandle;
	NDIS_STATUS				Status;
	NDIS_STRING				KeyName;

#if DBG
	SubkeyHandle = NULL;
#endif // DBG

	do
	{
        NDIS_STRING			String;
        PWSTR				p;
		NDIS_HANDLE			InterfaceConfigHandle;
		NDIS_STRING			OurSectionName = ATMARP_NAME_STRING;
        ULONG				i;

        //
        //  Get the config string for the specified LIS.
        //
        for (i = 0, p = pAdapter->IPConfigString.Buffer;
             (*p != L'\0') && (i < LISNumber);
             i++)
        {
            NdisInitUnicodeString(&String, p);
            p = (PWSTR)((PUCHAR)p + String.Length + sizeof(WCHAR));
        }

        if (*p == L'\0')
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        NdisInitUnicodeString(pIPConfigString, p);

		NdisOpenProtocolConfiguration(
						&Status,
						&InterfaceConfigHandle,
						pIPConfigString
						);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Get to our configuration section for this interface.
		//
		NdisOpenConfigurationKeyByName(
					&Status,
					InterfaceConfigHandle,
					&OurSectionName,
					&SubkeyHandle
					);

		//
		//  We don't need the main Interface section open anymore.
		//
		NdisCloseConfiguration(InterfaceConfigHandle);

		break;
	}
	while (FALSE);

	AADEBUGP(AAD_VERY_LOUD,
		("OpenLISConfiguration: LIS %d, Status 0x%x, subkey 0x%x\n",
			 LISNumber, Status, SubkeyHandle));


	if (Status == NDIS_STATUS_SUCCESS)
	{
		return (SubkeyHandle);
	}
	else
	{
		return (NULL);
	}
}


NDIS_HANDLE
AtmArpCfgOpenLISConfigurationByName(
	IN PATMARP_ADAPTER			pAdapter,
	IN PNDIS_STRING				pIPConfigString
)
/*++

Routine Description:

	Open and return a handle to the configuration section for the
	given LIS. Same functionality as AtmArpCfgOpenLISConfiguration, except
    that we look up the adapter based on the config string.

Arguments:

	pAdapter				- Points to our adapter context.
	pIPConfigString			- Specifies the configuration registry
							  key name.
Return Value:

	A valid handle if successful, NULL otherwise.

--*/
{
	NDIS_HANDLE				AdapterConfigHandle;
	NDIS_HANDLE				SubkeyHandle;
	NDIS_STATUS				Status;
	NDIS_STRING				KeyName;

#if DBG
	SubkeyHandle = NULL;
#endif // DBG

	do
	{
		NDIS_HANDLE			InterfaceConfigHandle;
		NDIS_STRING			OurSectionName = ATMARP_NAME_STRING;

		NdisOpenProtocolConfiguration(
						&Status,
						&InterfaceConfigHandle,
						pIPConfigString
						);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Get to our configuration section for this interface.
		//
		NdisOpenConfigurationKeyByName(
					&Status,
					InterfaceConfigHandle,
					&OurSectionName,
					&SubkeyHandle
					);

		//
		//  We don't need the main Interface section open anymore.
		//
		NdisCloseConfiguration(InterfaceConfigHandle);

		break;
	}
	while (FALSE);

	AADEBUGP(AAD_VERY_LOUD,
		("OpenLISConfigurationByName: Status 0x%x, subkey 0x%x\n",
			 Status, SubkeyHandle));

	if (Status == NDIS_STATUS_SUCCESS)
	{
		return (SubkeyHandle);
	}
	else
	{
		return (NULL);
	}
}



VOID
AtmArpCfgCloseLISConfiguration(
	NDIS_HANDLE						LISConfigHandle
)
/*++

Routine Description:

	Close a configuration handle for an LIS.

Arguments:

	LISConfigHandle			- Handle to the LIS configuration section.

Return Value:

	None

--*/
{
	NdisCloseConfiguration(LISConfigHandle);
}




NDIS_STATUS
AtmArpCfgReadLISConfiguration(
	IN	NDIS_HANDLE					LISConfigHandle,
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Get all configuration parameters for the specified LIS. We first
	fill in all configurable parameters with default values, and then
	overwrite them with values from the configuration database.

Arguments:

	LISComfigHandle		- the handle returned by AtmArpOpenLISConfiguration
	pInterface			- the ATMARP Interface structure for this LIS.

Return Value:

	NDIS_STATUS_SUCCESS if we were able to read in all config info.
	NDIS_STATUS_RESOURCES if we came across an allocation failure.
	NDIS_STATUS_FAILURE for any other kind of error.

--*/
{
	NDIS_STATUS				Status;
	PAA_READ_CONFIG_PARAMS	pParamEntry;
	ULONG					i;
	PATM_SAP				pAtmSap;
	PATM_ADDRESS			pAtmAddress;	// SAP address
	NDIS_STRING						ParameterName;
	PNDIS_CONFIGURATION_PARAMETER	pNdisConfigurationParameter;


	do
	{
		//
		//  Read in all the ULONGs first.
		//
		pParamEntry = AtmArpLISConfigTable;
		for (i = 0; i < LIS_CONFIG_ENTRIES; i++)
		{
			NdisInitUnicodeString(
							&ParameterName,
							pParamEntry->ParameterName
							);
			NdisReadConfiguration(
							&Status,
							&pNdisConfigurationParameter,
							LISConfigHandle,
							&ParameterName,
							NdisParameterInteger
							);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				//
				//  Error in accessing this parameter -- use the default.
				//
				*(ULONG *)((PUCHAR)pInterface + pParamEntry->StructOffset) =
 									pParamEntry->DefaultValue;
			}
			else
			{
				*(ULONG *)((PUCHAR)pInterface + pParamEntry->StructOffset) =
								pNdisConfigurationParameter->ParameterData.IntegerData;
			}

			pParamEntry++;
		}

		//
		//  Postprocessing. Sanity checks on some values.
		//  Round up some sizes to make them multiples of 4.
		//
		pInterface->ProtocolBufSize = ROUND_TO_8_BYTES(pInterface->ProtocolBufSize);
		pInterface->HeaderPool[AA_HEADER_TYPE_UNICAST].HeaderBufSize = ROUND_UP(pInterface->HeaderPool[AA_HEADER_TYPE_UNICAST].HeaderBufSize);
#ifdef IPMCAST
		pInterface->HeaderPool[AA_HEADER_TYPE_NUNICAST].HeaderBufSize = ROUND_UP(pInterface->HeaderPool[AA_HEADER_TYPE_NUNICAST].HeaderBufSize);
#endif // IPMCAST

		//
		//  More postprocessing: use the SAP Selector value to set up our
		//  "basic" listening SAP.
		//
		pInterface->SapList.pInterface = pInterface;
		pInterface->SapList.Flags = AA_SAP_REG_STATE_IDLE;
		pInterface->SapList.pInfo->SapType = SAP_TYPE_NSAP;
		pInterface->SapList.pInfo->SapLength = sizeof(ATM_SAP) + sizeof(ATM_ADDRESS);
		pAtmSap = (PATM_SAP)(pInterface->SapList.pInfo->Sap);

		AA_COPY_MEM((PUCHAR)&(pAtmSap->Blli), &AtmArpDefaultBlli, sizeof(ATM_BLLI_IE));
		AA_COPY_MEM((PUCHAR)&(pAtmSap->Bhli), &AtmArpDefaultBhli, sizeof(ATM_BHLI_IE));

		pAtmSap->NumberOfAddresses = 1;

		pAtmAddress = (PATM_ADDRESS)pAtmSap->Addresses;
		pAtmAddress->AddressType = SAP_FIELD_ANY_AESA_REST;
		pAtmAddress->NumberOfDigits = ATM_ADDRESS_LENGTH;
		pAtmAddress->Address[ATM_ADDRESS_LENGTH-1] = (UCHAR)(pInterface->SapSelector);

		pInterface->NumberOfSaps = 1;

		//
		//  If the MTU wasn't specified, get it from the adapter.
		//
		if (pInterface->MTU == AA_MTU_UNSPECIFIED)
		{
			pInterface->MTU = pInterface->pAdapter->MaxPacketSize - AA_PKT_LLC_SNAP_HEADER_LENGTH;
		}
		else
		{
			//
			//  If the MTU value isn't within bounds, default to 9180 bytes.
			//
			if ((pInterface->MTU < 9180) || (pInterface->MTU > 65535 - 8))
			{
				pInterface->MTU = 9180;
			}
		}

		//
		//  If the I/F speed wasn't specified, get it from the adapter.
		//
		if (pInterface->Speed == AA_SPEED_UNSPECIFIED)
		{
			//
			//  Convert from bytes/sec to bits/sec
			//
			pInterface->Speed = (pInterface->pAdapter->LineRate.Outbound * 8);
		}
			
		//
		//  Set up default flow parameters, if not specified, from the values
		//  we got from the adapter.
		//
		if (pInterface->DefaultFlowSpec.SendPeakBandwidth == AA_BANDWIDTH_UNSPECIFIED)
		{
			pInterface->DefaultFlowSpec.SendPeakBandwidth = pInterface->pAdapter->LineRate.Outbound;
			pInterface->DefaultFlowSpec.SendAvgBandwidth = pInterface->pAdapter->LineRate.Outbound;
		}

		if (pInterface->DefaultFlowSpec.ReceivePeakBandwidth == AA_BANDWIDTH_UNSPECIFIED)
		{
			pInterface->DefaultFlowSpec.ReceivePeakBandwidth = pInterface->pAdapter->LineRate.Inbound;
			pInterface->DefaultFlowSpec.ReceiveAvgBandwidth = pInterface->pAdapter->LineRate.Inbound;
		}

		if (pInterface->DefaultFlowSpec.SendMaxSize == AA_PACKET_SIZE_UNSPECIFIED)
		{
			pInterface->DefaultFlowSpec.SendMaxSize = pInterface->MTU + AA_PKT_LLC_SNAP_HEADER_LENGTH;
		}

		if (pInterface->DefaultFlowSpec.ReceiveMaxSize == AA_PACKET_SIZE_UNSPECIFIED)
		{
			pInterface->DefaultFlowSpec.ReceiveMaxSize = pInterface->MTU + AA_PKT_LLC_SNAP_HEADER_LENGTH;
		}

		pInterface->DefaultFlowSpec.Encapsulation = AA_DEF_FLOWSPEC_ENCAPSULATION;
		pInterface->DefaultFlowSpec.SendServiceType =
		pInterface->DefaultFlowSpec.ReceiveServiceType = SERVICETYPE_BESTEFFORT;

#ifndef NEWARP

		//
		//  Get IP's ConfigName string for this interface.
		//
		NdisInitUnicodeString(&ParameterName, AA_LIS_IP_CONFIG_STRING);
		NdisReadConfiguration(
						&Status,
						&pNdisConfigurationParameter,
						LISConfigHandle,
						&ParameterName,
						NdisParameterString
						);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_ERROR,
					 ("Failed to read IP Config string, status 0x%x\n", Status));
			break;
		}

		//
		//  Copy the string into our IF structure.
		//
		pInterface->IPConfigString.Length = 
				pNdisConfigurationParameter->ParameterData.StringData.Length;

		AA_COPY_MEM(
				pInterface->IPConfigString.Buffer,
				pNdisConfigurationParameter->ParameterData.StringData.Buffer,
				pInterface->IPConfigString.Length);

#endif // !NEWARP

		//
		//  Get the list of ARP servers: go to the subkey containing the
		//  list.
		//
		if (!pInterface->PVCOnly)
		{
			AtmArpCfgReadAtmAddressList(
							&(pInterface->ArpServerList),
							AA_LIS_ATMARP_SERVER_LIST_KEY,
							LISConfigHandle
							);

			if (pInterface->ArpServerList.ListSize == 0)
			{
				//
				//  Assume PVC only environment.
				//
				pInterface->PVCOnly = TRUE;
				AADEBUGP(AAD_INFO, ("IF 0x%x set to PVC Only\n", pInterface));
			}

#ifdef IPMCAST
			if (!pInterface->PVCOnly)
			{
				AtmArpCfgReadAtmAddressList(
							&(pInterface->MARSList),
							AA_LIS_MARS_SERVER_LIST_KEY,
							LISConfigHandle
							);
			}
#endif // IPMCAST
		}

		//
		//  Get any additional SAPs we are configured with. It doesn't matter
		//  if none are configured.
		//
		(VOID) AtmArpCfgReadSAPList(
							pInterface,
							LISConfigHandle
							);

#ifdef DHCP_OVER_ATM
		//
		//  Get the ATM Address of the DHCP Server, if configured.
		//
		Status = AtmArpCfgReadAtmAddress(
							LISConfigHandle,
							&(pInterface->DhcpServerAddress),
							AA_LIS_DHCP_SERVER_ATM_ADDRESS
							);

		if (Status == NDIS_STATUS_SUCCESS)
		{
			pInterface->DhcpEnabled = TRUE;
		}
#endif // DHCP_OVER_ATM

#ifdef QOS_HEURISTICS
		//
		//  Read in QOS Heuristics, if present.
		//
		Status = AtmArpCfgReadQosHeuristics(
							LISConfigHandle,
							pInterface
							);
#endif // QOS_HEURISTICS


		//
		//  Read in static IP-ATM entries, if present.
		//
		AtmArpCfgReadStaticArpEntries(
							LISConfigHandle,
							pInterface
							);

		Status = NDIS_STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	return (Status);
}



VOID
AtmArpCfgReadAtmAddressList(
	IN OUT	PATMARP_SERVER_LIST		pServerList,
	IN		PWCHAR					pListKeyName,
	IN		NDIS_HANDLE				LISConfigHandle
)
/*++

Routine Description:

	Read in a Server list for an LIS from the configuration database.

	Notes:

	In the first implementation, we had subkeys for everything. The
	layout was:
		ARPServerList\Server1\AtmAddress - REG_SZ
		ARPServerList\Server2\AtmAddress - REG_SZ
	and so on.

	To simplify, we are changing this to:
		ARPServerList - REG_MULTI_SZ, containing multiple
	    ATM Address strings.

Arguments:

	pServerList			- The list to be read into.
	pListKeyName		- Name of key under which the list is present.
	LISConfigHandle		- Handle to LIS configuration key.

Return Value:

	None.
	SIDE EFFECT: *pServerList is updated.

--*/
{
	NDIS_HANDLE				SubkeyHandle;	// Handle for Server list subkey
	NDIS_HANDLE				ServerEntryKeyHandle;
	NDIS_STATUS				Status;
	PATMARP_SERVER_ENTRY	pServerEntry;
	PATMARP_SERVER_ENTRY *	ppNext;			// Used for linking entries.
	NDIS_STRING				SubkeyName;
	INT						ReadCount;

	//
	//  Try the simplified (see Routine Description above) way first.
	//  Just open the given key name as a REG_MULTI_SZ.
	//
	do
	{
		PNDIS_CONFIGURATION_PARAMETER	pParam;
		NDIS_STRING						AddressListName;
		NDIS_STRING						AddressString;
		PWSTR							p;
		INT								i;

		ReadCount = 0;	// How many did we read here?

		//
		//  Read all server addresses configured. Stop only when there are
		//  no more addresses, or we have a resource failure.
		//
		//  First, go to the end of the existing list.
		//
		ppNext = &(pServerList->pList);
		while (*ppNext != NULL_PATMARP_SERVER_ENTRY)
		{
			ppNext = &((*ppNext)->pNext);
		}

		NdisInitUnicodeString(&AddressListName, pListKeyName);

		NdisReadConfiguration(
				&Status,
				&pParam,
				LISConfigHandle,
				&AddressListName,
				NdisParameterMultiString
				);

		if ((Status != NDIS_STATUS_SUCCESS) ||
			(pParam->ParameterType != NdisParameterMultiString))
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Go through the MULTI-string, each of which should be
		//  an ATM address. Allocate a server entry for each and
		//  link it to the list of servers.
		//
		for (p = pParam->ParameterData.StringData.Buffer, i = 0;
			 *p != L'\0';
			 i++)
		{
			NdisInitUnicodeString(&AddressString, p);
			p = (PWSTR)((PUCHAR)p + AddressString.Length + sizeof(WCHAR));

			AA_ALLOC_MEM(pServerEntry, ATMARP_SERVER_ENTRY, sizeof(ATMARP_SERVER_ENTRY));
			if (pServerEntry == NULL_PATMARP_SERVER_ENTRY)
			{
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			AA_SET_MEM(pServerEntry, 0, sizeof(ATMARP_SERVER_ENTRY));

			NdisConvertStringToAtmAddress(
					&Status,
					&AddressString,
					&pServerEntry->ATMAddress
					);

			if (Status == NDIS_STATUS_SUCCESS)
			{
				//
				//  Link this entry to the list of ARP Server entries.
				//
				*ppNext = pServerEntry;
				ppNext = &(pServerEntry->pNext);

				pServerList->ListSize++;
				ReadCount++;
			}
			else
			{
				AA_FREE_MEM(pServerEntry);
			}

		}

		//
		//  Fix up the status so we know what to do next.
		//
		if (ReadCount != 0)
		{
			//
			//  Successfully read in atleast one.
			//
			Status = NDIS_STATUS_SUCCESS;
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
		}

		break;
	}
	while (FALSE);

	if (ReadCount != 0)
	{
		return;
	}

	//
	//  For backward compatibility, try the older method.
	//

	do
	{
		NdisInitUnicodeString(&SubkeyName, pListKeyName);
		NdisOpenConfigurationKeyByName(
					&Status,
					LISConfigHandle,
					&SubkeyName,
					&SubkeyHandle
					);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Read all server addresses configured. Stop only when there are
		//  no more addresses, or we have a resource failure.
		//
		//  First, go to the end of the existing list.
		//
		ppNext = &(pServerList->pList);
		while (*ppNext != NULL_PATMARP_SERVER_ENTRY)
		{
			ppNext = &((*ppNext)->pNext);
		}

		for (;;)
		{
			NdisOpenConfigurationKeyByIndex(
						&Status,
						SubkeyHandle,
						pServerList->ListSize,
						&SubkeyName,
						&ServerEntryKeyHandle
						);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				break;
			}

			AA_ALLOC_MEM(pServerEntry, ATMARP_SERVER_ENTRY, sizeof(ATMARP_SERVER_ENTRY));
			if (pServerEntry == NULL_PATMARP_SERVER_ENTRY)
			{
				NdisCloseConfiguration(ServerEntryKeyHandle);
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			AA_SET_MEM(pServerEntry, 0, sizeof(ATMARP_SERVER_ENTRY));
			Status = AtmArpCfgReadAtmAddress(
							ServerEntryKeyHandle,
							&(pServerEntry->ATMAddress),
							AA_LIS_ATMARP_SERVER_ADDRESS
							);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				AADEBUGP(AAD_ERROR,
					("ReadAtmAddressList: bad status 0x%x reading server entry %d\n",
						Status,
						pServerList->ListSize));

				NdisCloseConfiguration(ServerEntryKeyHandle);
				AA_FREE_MEM(pServerEntry);
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			Status = AtmArpCfgReadAtmAddress(
							ServerEntryKeyHandle,
							&(pServerEntry->ATMSubaddress),
							AA_LIS_ATMARP_SERVER_SUBADDRESS
							);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				AADEBUGP(AAD_ERROR,
					("ReadAtmAddressList: bad status 0x%x reading server entry %d\n",
						Status,
						pServerList->ListSize));

				NdisCloseConfiguration(ServerEntryKeyHandle);
				AA_FREE_MEM(pServerEntry);
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			//
			//  Link this entry to the list of ARP Server entries.
			//
			*ppNext = pServerEntry;
			ppNext = &(pServerEntry->pNext);

			pServerList->ListSize++;

			NdisCloseConfiguration(ServerEntryKeyHandle);
		}

		NdisCloseConfiguration(SubkeyHandle);

		break;
	}
	while (FALSE);

	return;
}



NDIS_STATUS
AtmArpCfgReadSAPList(
	IN	PATMARP_INTERFACE			pInterface,
	IN	NDIS_HANDLE					LISConfigHandle
)
/*++

Routine Description:

	Read in any additional SAPs we are configured to listen on. These are
	used to support additional services over the IP/ATM client, that may be
	accessible via SAP information that is different from the "basic" SAP
	we register on an interface. For example, "well-known" address.

Arguments:

	pInterface			- Pointer to ATMARP Interface structure for this LIS
	LISConfigHandle		- Handle to LIS configuration key.

Return Value:

	For now, NDIS_STATUS_SUCCESS always.

--*/
{
	NDIS_STATUS				Status;

	Status = NDIS_STATUS_SUCCESS;

	// TBD -- code AtmArpCfgReadSAPList
	return (Status);
}



//
//  Special characters in ATM address string stored in config database.
//
#define BLANK_CHAR			L' '
#define PUNCTUATION_CHAR	L'.'
#define E164_START_CHAR		L'+'


NDIS_STATUS
AtmArpCfgReadAtmAddress(
	IN	NDIS_HANDLE					ConfigHandle,
	IN	PATM_ADDRESS				pAtmAddress,
	IN	PWCHAR						pValueName
)
/*++

Routine Description:

	Read in an ATM Address from the configuration database.

Arguments:

	ConfigHandle				- Handle returned by NdisOpenProtoXXX
	pAtmAddress					- where to read in the ATM address
	pValueName					- Pointer to name of value key.

Return Value:

	NDIS_STATUS_SUCCESS if the value was read in successfully
	NDIS_STATUS_FILE_NOT_FOUND if the value was not found
	NDIS_STATUS_FAILURE on any other kind of failure

--*/
{

	NDIS_STRING						ParameterName;
	PNDIS_CONFIGURATION_PARAMETER	pNdisConfigurationParameter;
	NDIS_STATUS						Status;

	NdisInitUnicodeString(&ParameterName, pValueName);

	NdisReadConfiguration(
					&Status,
					&pNdisConfigurationParameter,
					ConfigHandle,
					&ParameterName,
					NdisParameterString
					);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		NdisConvertStringToAtmAddress(
					&Status,
					&(pNdisConfigurationParameter->ParameterData.StringData),
					pAtmAddress
					);
	}

	return (Status);
}



#ifdef QOS_HEURISTICS
NDIS_STATUS
AtmArpCfgReadQosHeuristics(
	IN	NDIS_HANDLE					LISConfigHandle,
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Read in QoS heuristics configured for this interface. If we do find
	these parameters configured, we turn on heuristics by setting the
	packet classification handlers in the Interface structure. If nothing
	is configured, the packet classification routines are NULLed out, and
	all data is "best effort".

Arguments:

	LISConfigHandle				- Handle returned by NdisOpenProtoXXX
	pInterface					- Interface being configured.

Return Value:

	NDIS_STATUS always, as of now.

--*/
{
	NDIS_STATUS				Status;
	NDIS_STRING				SubkeyName;
	NDIS_STRING				ParameterName;
	NDIS_HANDLE				FlowInfoHandle;		// "FlowInfo" under LIS
	NDIS_HANDLE				FlowHandle;			// For each Flow under "FlowInfo"
	INT						NumFlowsConfigured;
	PATMARP_FLOW_INFO		pFlowInfo;
	PATMARP_FLOW_INFO		*ppNextFlow;
	PAA_READ_CONFIG_PARAMS	pParamEntry;
	INT						i;

	PNDIS_CONFIGURATION_PARAMETER	pNdisConfigurationParameter;

	NumFlowsConfigured = 0;

	do
	{
		//
		//  Check if QoS heuristics are enabled.
		//
		NdisInitUnicodeString(
						&ParameterName,
						AA_LIS_FLOW_INFO_ENABLED
						);

		NdisReadConfiguration(
						&Status,
						&pNdisConfigurationParameter,
						LISConfigHandle,
						&ParameterName,
						NdisParameterInteger
						);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_INFO, ("IF 0x%x: could not read %ws\n",
						pInterface, AA_LIS_FLOW_INFO_ENABLED));
			break;
		}

		if (pNdisConfigurationParameter->ParameterData.IntegerData == 0)
		{
			AADEBUGP(AAD_INFO, ("IF 0x%x: Flow Info disabled\n", pInterface));
			break;
		}

		NdisInitUnicodeString(&SubkeyName, AA_LIS_FLOW_INFO_KEY);
		NdisOpenConfigurationKeyByName(
					&Status,
					LISConfigHandle,
					&SubkeyName,
					&FlowInfoHandle
					);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_INFO, ("IF 0x%x: No flows configured\n", pInterface));
			break;
		}

		//
		//  Read in all flows configured. Stop when there are no more
		//  configured flows, or we run out of memory.
		//
		for (;;)
		{
			//
			//  Open the next key under the Flow Info section.
			//
			AA_SET_MEM(&SubkeyName, 0, sizeof(SubkeyName));
			NdisOpenConfigurationKeyByIndex(
					&Status,
					FlowInfoHandle,
					NumFlowsConfigured,
					&SubkeyName,
					&FlowHandle
					);
	
			if (Status != NDIS_STATUS_SUCCESS)
			{
				break;
			}

			AA_ALLOC_MEM(pFlowInfo, ATMARP_FLOW_INFO, sizeof(ATMARP_FLOW_INFO));
			if (pFlowInfo == (PATMARP_FLOW_INFO)NULL)
			{
				NdisCloseConfiguration(FlowHandle);
				break;
			}

			//
			//  Initialize with defaults.
			//
			AA_COPY_MEM(pFlowInfo, &AtmArpDefaultFlowInfo, sizeof(ATMARP_FLOW_INFO));
			pFlowInfo->FlowSpec.SendMaxSize =
			pFlowInfo->FlowSpec.ReceiveMaxSize = pInterface->pAdapter->MaxPacketSize;

			//
			//  Read in configured values.
			//
			pParamEntry = AtmArpFlowConfigTable;
			for (i = 0; i < AA_FLOW_INFO_ENTRIES; i++)
			{
				NdisInitUnicodeString(
								&ParameterName,
								pParamEntry->ParameterName
								);
				NdisReadConfiguration(
								&Status,
								&pNdisConfigurationParameter,
								FlowHandle,
								&ParameterName,
								NdisParameterInteger
								);
	
				if (Status != NDIS_STATUS_SUCCESS)
				{
					//
					//  Error in accessing this parameter -- use the default.
					//
					*(ULONG *)((PUCHAR)pFlowInfo + pParamEntry->StructOffset) =
										pParamEntry->DefaultValue;
				}
				else
				{
					*(ULONG *)((PUCHAR)pFlowInfo + pParamEntry->StructOffset) =
									pNdisConfigurationParameter->ParameterData.IntegerData;
					AADEBUGP(AAD_LOUD,
						("Flow Info #%d: %ws = %d\n",
								NumFlowsConfigured,
								pParamEntry->ParameterName,
								pNdisConfigurationParameter->ParameterData.IntegerData));
				}
	
				pParamEntry++;
			}

			NdisCloseConfiguration(FlowHandle);

			//
			//  Link this in the appropriate point in the list of flows.
			//  We keep the list sorted in ascending order of PacketSizeLimit.
			//
			ppNextFlow = &(pInterface->pFlowInfoList);
			while (*ppNextFlow != (PATMARP_FLOW_INFO)NULL)
			{
				if (pFlowInfo->PacketSizeLimit < (*ppNextFlow)->PacketSizeLimit)
				{
					//
					//  Found the place.
					//
					break;
				}
				else
				{
					ppNextFlow = &((*ppNextFlow)->pNextFlow);
				}
			}
			//
			//  Insert the new Flow at its designated place.
			//
			pFlowInfo->pNextFlow = *ppNextFlow;
			*ppNextFlow = pFlowInfo;

			NumFlowsConfigured ++;
		}

		NdisCloseConfiguration(FlowInfoHandle);
	}
	while (FALSE);

#ifdef GPC
	if (pAtmArpGlobalInfo->GpcClientHandle != NULL)
#else
	if (NumFlowsConfigured > 0)
#endif // GPC
	{
		//
		//  Set the packet classification handlers.
		//
		pInterface->pGetPacketSpecFunc = AtmArpQosGetPacketSpecs;
		pInterface->pFlowMatchFunc = AtmArpQosDoFlowsMatch;
#ifndef GPC
		//
		//  We don't want to look at patterns within the packet.
		//  Let the GPC do it for us.
		//
		pInterface->pFilterMatchFunc = AtmArpQosDoFiltersMatch;
#endif // GPC
	}

	return (NDIS_STATUS_SUCCESS);
}


#endif // QOS_HEURISTICS


VOID
AtmArpCfgReadStaticArpEntries(
	IN		NDIS_HANDLE				LISConfigHandle,
	IN		PATMARP_INTERFACE		pInterface
)
/*++

Routine Description:

	Read in a list of IP-ATM mappings for this interface.

	This information is in a Multi-string in the following format:

	"<IPaddress1>-<ATMaddress1>
	 <IPaddress2>-<ATMaddress2>
	 ...."
	
	NOTE: we don't support subaddress for now.

Arguments:

	LISConfigHandle		- Handle to LIS configuration key.
	pInterface			- Pointer to interface

Return Value:

	None.

--*/
{
	NDIS_STATUS						Status;
	PNDIS_CONFIGURATION_PARAMETER	pParam;
	NDIS_STRING						ArpListKeyName;
	NDIS_STRING						AddressString;
	ATM_ADDRESS						ATMAddress;
	IP_ADDRESS						IPAddress;
	PWSTR							p, q;
	INT								i, j;

	do
	{
		NdisInitUnicodeString(&ArpListKeyName, AA_LIS_STATIC_ARP_LIST);

		NdisReadConfiguration(
				&Status,
				&pParam,
				LISConfigHandle,
				&ArpListKeyName,
				NdisParameterMultiString
				);

		if ((Status != NDIS_STATUS_SUCCESS) ||
			(pParam->ParameterType != NdisParameterMultiString))
		{
			break;
		}

		//
		//  Go through the MULTI-string, each of which should be
		//  an <IP, ATM> tuple. Create a static mapping for each
		//  one successfully read in. Skip invalid entries.
		//
		for (p = pParam->ParameterData.StringData.Buffer, i = 0;
			 *p != L'\0';
			 i++)
		{
			NdisInitUnicodeString(&AddressString, p);

			q = p;

			//
			//  Prepare early for the next iteration in case we
			//  skip this entry and continue on.
			//
			p = (PWSTR)((PUCHAR)p + AddressString.Length + sizeof(WCHAR));

			//
			//  Find the '-' and replace it with a NULL char.
			//
			for (j = 0; j < AddressString.Length; j++, q++)
			{
				if (*q == L'-')
				{
					*q++ = L'\0';

					//
					//  q now points to the character following the hyphen.
					//

					break;
				}
			}

			if (j == AddressString.Length)
			{
				AADEBUGP(AAD_WARNING, ("CfgReadStatic..: did not find - in string: %ws\n",
								AddressString.Buffer));
				continue;
			}

			//
			//  Parse the IP address first.
			//
			if (!AtmArpConvertStringToIPAddress(
					AddressString.Buffer,
					&IPAddress))
			{
				AADEBUGP(AAD_WARNING, ("CfgReadStatic..: bad IP addr string: %ws\n",
											AddressString.Buffer));
				continue;
			}

			//
			//  Convert to net-endian for the call to AtmArpLearnIPToAtm.
			//
			IPAddress = HOST_TO_NET_LONG(IPAddress);

			//
			//  Now parse the ATM Address.
			//
			NdisInitUnicodeString(&AddressString, q);

			NdisConvertStringToAtmAddress(
				&Status,
				&AddressString,
				&ATMAddress
				);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				AADEBUGP(AAD_WARNING, ("CfgReadStatic...: Status %x, bad ATM addr string(%d): %ws\n",
											Status, AddressString.Length, AddressString.Buffer));
				continue;
			}

			//
			//  Got a pair - enter them in the ARP table.
			//
			AADEBUGPMAP(AAD_VERY_LOUD,
				"Static", &IPAddress, &ATMAddress);

			(VOID)AtmArpLearnIPToAtm(
						pInterface,
						&IPAddress,
						(UCHAR)AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&ATMAddress),
						(PUCHAR)&ATMAddress.Address[0],
						(UCHAR)0,	// no subaddress
						(PUCHAR)NULL,
						TRUE	// Static Entry
						);

		}
	}
	while (FALSE);

	return;

}



#define	IP_ADDRESS_STRING_LENGTH	(16+2)	// +2 for double NULL on MULTI_SZ

BOOLEAN
AtmArpConvertStringToIPAddress(
    IN		PWCHAR				AddressString,
	OUT		PULONG				IpAddress
)
/*++

Routine Description

    This function converts an Internet standard 4-octet dotted decimal
	IP address string into a numeric IP address. Unlike inet_addr(), this
	routine does not support address strings of less than 4 octets nor does
	it support octal and hexadecimal octets.

	Copied from tcpip\ip\ntip.c

Arguments

    AddressString    - IP address in dotted decimal notation
	IpAddress        - Pointer to a variable to hold the resulting address

Return Value:

	TRUE if the address string was converted. FALSE otherwise.

--*/
{
    UNICODE_STRING  unicodeString;
	STRING          aString;
	UCHAR           dataBuffer[IP_ADDRESS_STRING_LENGTH];
	NTSTATUS        status;
	PUCHAR          addressPtr, cp, startPointer, endPointer;
	ULONG           digit, multiplier;
	INT             i;

    aString.Length = 0;
	aString.MaximumLength = IP_ADDRESS_STRING_LENGTH;
	aString.Buffer = dataBuffer;

	NdisInitUnicodeString(&unicodeString, AddressString);

	status = NdisUnicodeStringToAnsiString(
	             &aString,
				 &unicodeString
				 );

    if (status != NDIS_STATUS_SUCCESS)
    {
	    return(FALSE);
	}

    *IpAddress = 0;
	addressPtr = (PUCHAR) IpAddress;
	startPointer = dataBuffer;
	endPointer = dataBuffer;
	i = 3;

    while (i >= 0)
	{
        //
		// Collect the characters up to a '.' or the end of the string.
		//
		while ((*endPointer != '.') && (*endPointer != '\0')) {
			endPointer++;
		}

		if (startPointer == endPointer) {
			return(FALSE);
		}

		//
		// Convert the number.
		//

        for ( cp = (endPointer - 1), multiplier = 1, digit = 0;
			  cp >= startPointer;
			  cp--, multiplier *= 10
			) {

			if ((*cp < '0') || (*cp > '9') || (multiplier > 100)) {
				return(FALSE);
			}

			digit += (multiplier * ((ULONG) (*cp - '0')));
		}

		if (digit > 255) {
			return(FALSE);
		}

        addressPtr[i] = (UCHAR) digit;

		//
		// We are finished if we have found and converted 4 octets and have
		// no other characters left in the string.
		//
	    if ( (i-- == 0) &&
			 ((*endPointer == '\0') || (*endPointer == ' '))
		   ) {
			return(TRUE);
		}

        if (*endPointer == '\0') {
			return(FALSE);
		}

		startPointer = ++endPointer;
	}

	return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\arppkt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arppkt.c	- ATMARP Packet Routines.

Abstract:

	Routines that build and parse ARP packets.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     07-29-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'TKPA'


VOID
AtmArpSendPacketOnVc(
	IN	PATMARP_VC					pVc		LOCKIN	NOLOCKOUT,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Send a packet on the specified VC. Apart from calling NDIS to do
	the job, we refresh the aging timer on this VC.

Arguments:

	pVc					- Pointer to ATMARP VC
	pNdisPacket			- Pointer to packet to be sent.

Return Value:

	None

--*/
{
	NDIS_HANDLE			NdisVcHandle;

	if (AA_IS_FLAG_SET(
				pVc->Flags,
				AA_VC_CALL_STATE_MASK,
				AA_VC_CALL_STATE_ACTIVE) &&
		!AA_IS_VC_GOING_DOWN(pVc))
	{
		//
		//  A call is active on this VC, so send the packet.
		//
		AtmArpRefreshTimer(&(pVc->Timer));
		NdisVcHandle = pVc->NdisVcHandle;

#ifdef VC_REFS_ON_SENDS
		AtmArpReferenceVc(pVc);	// SendPacketOnVc
#endif // VC_REFS_ON_SENDS

		pVc->OutstandingSends++;	// SendPacketOnVc

		AA_RELEASE_VC_LOCK(pVc);

		AADEBUGP(AAD_EXTRA_LOUD+50,
			("SendPacketOnVc: pVc 0x%x, Pkt 0x%x, VcHandle 0x%x\n",
					pVc, pNdisPacket, NdisVcHandle));

#ifdef PERF
		AadLogSendUpdate(pNdisPacket);
#endif // PERF
		NDIS_CO_SEND_PACKETS(
				NdisVcHandle,
				&pNdisPacket,
				1
				);
	}
	else
	{
		if (!AA_IS_VC_GOING_DOWN(pVc))
		{
			//
			//  Call must be in progress. Queue this packet; it will
			//  be sent as soon as the call is fully set up.
			//
			AtmArpQueuePacketOnVc(pVc, pNdisPacket);
			AA_RELEASE_VC_LOCK(pVc);
		}
		else
		{
			//
			//  This VC is going down. Complete the send with a failure.
			//
#ifdef VC_REFS_ON_SENDS
			AtmArpReferenceVc(pVc);	// SendPacketOnVc2
#endif // VC_REFS_ON_SENDS

			pVc->OutstandingSends++;	// SendPacketOnVc - failure completion

			AA_RELEASE_VC_LOCK(pVc);

#if DBG
#if DBG_CO_SEND
			{
				PULONG		pContext;
				pContext = (PULONG)&(pNdisPacket->WrapperReserved[0]);;
				*pContext = 'AaAa';
			}
#endif
#endif
			AtmArpCoSendCompleteHandler(
					NDIS_STATUS_FAILURE,
					(NDIS_HANDLE)pVc,
					pNdisPacket
					);
		}
	}
	return;
}




PNDIS_PACKET
AtmArpBuildARPPacket(
	IN	USHORT						OperationType,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PUCHAR *					ppArpPacket,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
)
/*++

Routine Description:

	Build a generic ARP packet with the given attributes.

Arguments:

	OperationType					- Op type (e.g. ARP Request, ARP Reply)
	pInterface						- Pointer to ATMARP Interface
	ppArpPacket						- Pointer to place to return start of packet
	pArpContents					- Pointer to structure describing contents

Return Value:

	Pointer to NDIS packet if successful, NULL otherwise. If successful,
	we also set *ppArpPacket to point to the first byte in the constructed
	ARP packet.

--*/
{
	PNDIS_PACKET			pNdisPacket;
	PNDIS_BUFFER			pNdisBuffer;
	ULONG					BufferLength;	// Length of ARP packet
	ULONG					Length;			// Temp length
	PUCHAR					pPkt;			// Start of allocated packet
	PUCHAR					pBuf;			// Used to walk the packet
	PAA_ARP_PKT_HEADER		pArpHeader;		// ARP packet header

	//
	//  Calculate the length of what we're about to build
	//
	BufferLength = AA_ARP_PKT_HEADER_LENGTH +
					(pArpContents->SrcAtmNumberTypeLen & ~AA_PKT_ATM_ADDRESS_BIT) +
					(pArpContents->SrcAtmSubaddrTypeLen & ~AA_PKT_ATM_ADDRESS_BIT) +
					(pArpContents->DstAtmNumberTypeLen & ~AA_PKT_ATM_ADDRESS_BIT) +
					(pArpContents->DstAtmSubaddrTypeLen & ~AA_PKT_ATM_ADDRESS_BIT) +
					0;

	if (pArpContents->pSrcIPAddress != (PUCHAR)NULL)
	{
		BufferLength += AA_IPV4_ADDRESS_LENGTH;
	}

	if (pArpContents->pDstIPAddress != (PUCHAR)NULL)
	{
		BufferLength += AA_IPV4_ADDRESS_LENGTH;
	}

	pNdisPacket = AtmArpAllocatePacket(pInterface);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		pNdisBuffer = AtmArpAllocateProtoBuffer(
									pInterface,
									BufferLength,
									&(pPkt)
									);

		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			//
			//  Return value:
			//
			*ppArpPacket = pPkt;

			//
			//  Initialize packet with all 0's
			//
			AA_SET_MEM(pPkt, 0, BufferLength);

			pArpHeader = (PAA_ARP_PKT_HEADER)pPkt;

			//
			//  Fixed-location fields:
			//
			pArpHeader->LLCSNAPHeader = AtmArpLlcSnapHeader;
			pArpHeader->LLCSNAPHeader.EtherType = NET_SHORT(AA_PKT_ETHERTYPE_ARP);
			pArpHeader->hrd = NET_SHORT(AA_PKT_ATM_FORUM_AF);
			pArpHeader->pro = NET_SHORT(AA_PKT_PRO_IP);
			pArpHeader->op  = NET_SHORT(OperationType);

			//
			//  Now fill in the variable length fields
			//
			pBuf = pArpHeader->Variable;

			//
			//  Source ATM Number
			//
			Length = (pArpContents->SrcAtmNumberTypeLen & ~AA_PKT_ATM_ADDRESS_BIT);
			if (Length > 0)
			{
				pArpHeader->shtl = pArpContents->SrcAtmNumberTypeLen;
				AA_COPY_MEM(pBuf, pArpContents->pSrcAtmNumber, Length);
				pBuf += Length;
			}

			//
			//  Source ATM subaddress
			//
			Length = (pArpContents->SrcAtmSubaddrTypeLen & ~AA_PKT_ATM_ADDRESS_BIT);
			if (Length > 0)
			{
				pArpHeader->shtl = pArpContents->SrcAtmSubaddrTypeLen;
				AA_COPY_MEM(pBuf, pArpContents->pSrcAtmSubaddress, Length);
				pBuf += Length;
			}

			//
			//  Source Protocol (IP) address
			//
			if (pArpContents->pSrcIPAddress != (PUCHAR)NULL)
			{
				pArpHeader->spln = AA_IPV4_ADDRESS_LENGTH;
				AA_COPY_MEM(pBuf, pArpContents->pSrcIPAddress, AA_IPV4_ADDRESS_LENGTH);

				pBuf += AA_IPV4_ADDRESS_LENGTH;
			}

			//
			//  Target ATM Number
			//
			Length = (pArpContents->DstAtmNumberTypeLen & ~AA_PKT_ATM_ADDRESS_BIT);
			if (Length > 0)
			{
				pArpHeader->thtl = pArpContents->DstAtmNumberTypeLen;
				AA_COPY_MEM(pBuf, pArpContents->pDstAtmNumber, Length);
				pBuf += Length;
			}

			//
			//  Target ATM subaddress
			//
			Length = (pArpContents->DstAtmSubaddrTypeLen & ~AA_PKT_ATM_ADDRESS_BIT);
			if (Length > 0)
			{
				pArpHeader->thtl = pArpContents->DstAtmSubaddrTypeLen;
				AA_COPY_MEM(pBuf, pArpContents->pDstAtmSubaddress, Length);
				pBuf += Length;
			}

			//
			//  Target Protocol (IP) address
			//
			if (pArpContents->pDstIPAddress != (PUCHAR)NULL)
			{
				pArpHeader->tpln = AA_IPV4_ADDRESS_LENGTH;
				AA_COPY_MEM(pBuf, pArpContents->pDstIPAddress, AA_IPV4_ADDRESS_LENGTH);

				pBuf += AA_IPV4_ADDRESS_LENGTH;
			}

			NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
		}
		else
		{
			AtmArpFreePacket(pInterface, pNdisPacket);
			pNdisPacket = (PNDIS_PACKET)NULL;
		}
	}

	AADEBUGP(AAD_EXTRA_LOUD, ("BldArpPkt: pIf 0x%x, Op %d, NdisPkt 0x%x, NdisBuf 0x%x\n",
				pInterface, OperationType, pNdisPacket, pNdisBuffer));

	return (pNdisPacket);
}





VOID
AtmArpSendARPRequest(
	PATMARP_INTERFACE				pInterface,
	IP_ADDRESS UNALIGNED *			pSrcIPAddress,
	IP_ADDRESS UNALIGNED *			pDstIPAddress
)
/*++

Routine Description:

	Send an ARP Request to the server, for the given interface.

	Preconditions: the ATM interface is UP, and the AdminState
	for the interface is IF_STATUS_UP.

	We first build an ARP Request with the given parameters. Then,
	if a Best Effort VC to the server's ATM address exists, the packet
	is sent on this. Other possibilities:
		- the Best Effort VC to the server is being set up: queue it
  		  on the VC
		- No Best Effort VC to the server exists: Create a new VC on this
  		  ATM Entry, make a call with Best Effort flow specs, and queue
  		  the request on this VC.
	
Arguments:

	pInterface				- Pointer to ATMARP Interface structure
	pSrcIPAddress			- Pointer to Source IP Address
	pDstIPAddress			- Pointer to Destination IP Address (to be
							  resolved)

Return Value:

	None

--*/
{
	PATMARP_ATM_ENTRY		pAtmEntry;	// Entry for the server's ATM address
	PATMARP_VC				pVc;		// VC to the server
	PNDIS_PACKET			pNdisPacket;
	PATMARP_FLOW_SPEC		pFlowSpec;
	PUCHAR                  pArpPacket;	// Pointer to ARP packet being constructed

	AA_ARP_PKT_CONTENTS		ArpContents;// Describes the packet we want to build

	NDIS_STATUS				Status;

	AADEBUGP(AAD_INFO,
				("Sending ARP Request on IF 0x%x for IP Addr: %d.%d.%d.%d\n",
					pInterface,
					((PUCHAR)pDstIPAddress)[0],
					((PUCHAR)pDstIPAddress)[1],
					((PUCHAR)pDstIPAddress)[2],
					((PUCHAR)pDstIPAddress)[3]
				));

	AA_ASSERT(pInterface->pCurrentServer != NULL_PATMARP_SERVER_ENTRY);
	AA_ASSERT(pInterface->pCurrentServer->pAtmEntry != NULL_PATMARP_ATM_ENTRY);

	//
	//  Prepare the ARP packet contents structure
	//
	AA_SET_MEM((PUCHAR)&ArpContents, 0, sizeof(AA_ARP_PKT_CONTENTS));
	
	//
	//  Source ATM Number
	//
	ArpContents.pSrcAtmNumber = pInterface->LocalAtmAddress.Address;
	ArpContents.SrcAtmNumberTypeLen =
			AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->LocalAtmAddress));

	//
	//  Source IP Address
	//
	ArpContents.pSrcIPAddress = (PUCHAR)pSrcIPAddress;

	//
	//  Target IP Address
	//
	ArpContents.pDstIPAddress = (PUCHAR)pDstIPAddress;

	//
	//  Build the ARP Request
	//
	pNdisPacket = AtmArpBuildARPPacket(
							AA_PKT_OP_TYPE_ARP_REQUEST,
							pInterface,
							&pArpPacket,
							&ArpContents
							);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		//
		//  Find the ATM Entry for the in-use ATMARP Server:
		//
		AA_ACQUIRE_IF_LOCK(pInterface);
		pAtmEntry = pInterface->pCurrentServer->pAtmEntry;
		AA_RELEASE_IF_LOCK(pInterface);

		AA_ACQUIRE_AE_LOCK(pAtmEntry);

		//
		//  Get at the Best Effort VC going to this ATM address:
		//
		pVc = pAtmEntry->pBestEffortVc;

		if (pVc != NULL_PATMARP_VC)
		{
			ULONG		rc;

			AA_ACQUIRE_VC_LOCK_DPC(pVc);
			AtmArpReferenceVc(pVc);		// temp ref
			AA_RELEASE_VC_LOCK_DPC(pVc);

			AA_RELEASE_AE_LOCK(pAtmEntry);	// Not needed anymore

			//
			//  A VC to the server exists; send this packet on the VC
			//
			AA_ACQUIRE_VC_LOCK(pVc);

			rc = AtmArpDereferenceVc(pVc);	// temp ref

			if (rc != 0)
			{
				AtmArpSendPacketOnVc(pVc, pNdisPacket);
				//
				//  The VC lock is released in SendPacketOnVc
				//
			}
			else
			{
				//
				//  The VC has been deref'ed away! Set up pVc for the
				//  check coming up.
				//
				pVc = NULL_PATMARP_VC;
				AA_ACQUIRE_AE_LOCK(pAtmEntry);
			}

		}

		if (pVc == NULL_PATMARP_VC)
		{
			//
			//  We don't have an appropriate VC to the server, so create
			//  one, and queue this packet for transmission as soon as
			//  the call is made.
			//
			//  AtmArpMakeCall needs the caller to hold the ATM Entry lock.
			//
			AA_GET_CONTROL_PACKET_SPECS(pInterface, &pFlowSpec);
			Status = AtmArpMakeCall(
							pInterface,
							pAtmEntry,
							pFlowSpec,
							pNdisPacket
							);
			//
			//  The AE lock is released within the above.
			//
		}
	}

}





VOID
AtmArpSendInARPRequest(
	IN	PATMARP_VC					pVc
)
/*++

Routine Description:

	Send an InATMARP Request on a VC.

Arguments:

	pVc						- Pointer to ATMARP VC on which we send the request

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PNDIS_PACKET			pNdisPacket;
	PUCHAR                  pArpPacket;	// Pointer to ARP packet being constructed

	AA_ARP_PKT_CONTENTS		ArpContents;// Describes the packet we want to build

	//
	//  Prepare the ARP packet contents structure
	//
	AA_SET_MEM((PUCHAR)&ArpContents, 0, sizeof(AA_ARP_PKT_CONTENTS));

	pInterface = pVc->pInterface;

	//
	//  Source IP Address
	//
	ArpContents.pSrcIPAddress = (PUCHAR)&(pInterface->LocalIPAddress.IPAddress);

	//
	//  Source ATM number
	//
	ArpContents.pSrcAtmNumber = pInterface->LocalAtmAddress.Address;
	ArpContents.SrcAtmNumberTypeLen =
			AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->LocalAtmAddress));

	//
	//  Build the InATMARP Request packet
	//
	pNdisPacket = AtmArpBuildARPPacket(
							AA_PKT_OP_TYPE_INARP_REQUEST,
							pInterface,
							&pArpPacket,
							&ArpContents
							);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
#ifndef VC_REFS_ON_SENDS
		AA_ACQUIRE_VC_LOCK(pVc);
#endif // VC_REFS_ON_SENDS

		AtmArpSendPacketOnVc(pVc, pNdisPacket);
		//
		//  The VC lock is released by SendPacketOnVc
		//
	}
	else
	{
#ifdef VC_REFS_ON_SENDS
		AA_RELEASE_VC_LOCK(pVc);
#endif // VC_REFS_ON_SENDS
	}
}






UINT
AtmArpCoReceivePacketHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	This is routine is called when a packet is received on a VC owned
	by the ATMARP module. If it is an ARP packet, we consume it ourselves.
	Otherwise, we pass it up to IP.

	In any case, we refresh the VC aging timer on this VC.

Arguments:

	ProtocolBindingContext		- Actually a pointer to our Adapter structure
	ProtocolVcContext			- Actually a pointer to our VC structure
	pNdisPacket					- NDIS packet being received.

Return Value:

	0 always, because we don't hold on to ARP packets, and we assume
	IP doesn't either.

--*/
{
	PATMARP_INTERFACE		pInterface;
	PATMARP_VC				pVc;
	UINT					TotalLength;	// Total bytes in packet
	PNDIS_BUFFER			pNdisBuffer;	// Pointer to first buffer
	UINT					BufferLength;
	UINT					IsNonUnicast;	// Is this to a non-unicast destn MAC addr?
	BOOLEAN					Discarded;		// Are we discarding this packet?

	PAA_PKT_LLC_SNAP_HEADER	pPktHeader;		// LLC/SNAP header
	UINT					ReturnCount = 0;

#if DBG
	pPktHeader = NULL;
#endif
	pVc = (PATMARP_VC)ProtocolVcContext;
	AA_STRUCT_ASSERT(pVc, avc);

	pInterface = pVc->pInterface;

	Discarded = FALSE;
	IsNonUnicast = (UINT)FALSE;

	if (pInterface->AdminState == IF_STATUS_UP)
	{
		//
		//  Refresh VC aging on this VC
		//
		AA_ACQUIRE_VC_LOCK(pVc);
		AtmArpRefreshTimer(&(pVc->Timer));
		AA_RELEASE_VC_LOCK(pVc);

		NdisQueryPacket(
					pNdisPacket,
					NULL,
					NULL,
					&pNdisBuffer,
					&TotalLength
					);

		//
		//  We expect atleast the LLC/SNAP header to be present
		//  Note: this precludes Null encapsulation.
		//
		if (TotalLength >= AA_PKT_LLC_SNAP_HEADER_LENGTH)
		{
			AA_IF_STAT_ADD(pInterface, InOctets, TotalLength);

			NdisQueryBuffer(
					pNdisBuffer,
					(PVOID *)&pPktHeader,
					&BufferLength
					);

			AADEBUGP(AAD_EXTRA_LOUD,
		 ("Rcv: VC 0x%x, NDISpkt 0x%x, NDISbuf 0x%x, Buflen %d, Totlen %d, Pkthdr 0x%x\n",
						pVc,
						pNdisPacket,
						pNdisBuffer,
						BufferLength,
						TotalLength,
						pPktHeader));

			AADEBUGPDUMP(AAD_EXTRA_LOUD+20, pPktHeader, BufferLength);

			AA_ASSERT(BufferLength >= AA_PKT_LLC_SNAP_HEADER_LENGTH);

			if (AA_PKT_LLC_SNAP_HEADER_OK(pPktHeader))
			{
				//
				//  If the EtherType is IP, pass up this packet to
				//  the IP layer
				//
				if (pPktHeader->EtherType == NET_SHORT(AA_PKT_ETHERTYPE_IP))
				{
					AADEBUGP(AAD_EXTRA_LOUD,
						("Rcv: VC 0x%x, NDISpkt 0x%x: EtherType is IP, passing up\n"));

#if DBG
					if (AaDataDebugLevel & AAD_DATA_IN)
					{
						IP_ADDRESS			IPAddress;

						if ((pVc->pAtmEntry != NULL_PATMARP_ATM_ENTRY) &&
							(pVc->pAtmEntry->pIpEntryList != NULL_PATMARP_IP_ENTRY))
						{
							IPAddress = pVc->pAtmEntry->pIpEntryList->IPAddress;
						}
						else
						{
							IPAddress = 0;
						}

						AADEBUGP(AAD_WARNING,
							("%d <= %d.%d.%d.%d\n",
								TotalLength,
								((PUCHAR)&IPAddress)[0],
								((PUCHAR)&IPAddress)[1],
								((PUCHAR)&IPAddress)[2],
								((PUCHAR)&IPAddress)[3]));
					}
#endif // DBG
					if (IsNonUnicast)
					{
						AA_IF_STAT_INCR(pInterface, InNonUnicastPkts);
					}
					else
					{
						AA_IF_STAT_INCR(pInterface, InUnicastPkts);
					}

#ifdef _PNP_POWER_
					if (NDIS_GET_PACKET_STATUS(pNdisPacket) != NDIS_STATUS_RESOURCES)
					{
						UINT	HeaderSize;
						UINT	DataSize;
						#define ATMARP_MIN_1ST_RECV_BUFSIZE 512

						HeaderSize = NDIS_GET_PACKET_HEADER_SIZE(pNdisPacket);

						//
						// 2/8/1998 JosephJ
						//		We set DataSize to the total payload size,
						//		unless the first buffer is too small to
						//		hold the IP header. In the latter case,
						//		we set DataSize to be the size of the 1st buffer
						//		(minus the LLS/SNAP header size).
						//
						//		This is to work around a bug in tcpip.
						//
						// 2/25/1998 JosephJ
						//		Unfortunately we have to back out YET AGAIN
						//		because large pings (eg ping -l 4000) doesn't
						//		work -- bug#297784
						//		Hence the "0" in "0 && DataSize" below.
						//		Take out the "0" to put back the per fix.
						//
						DataSize = BufferLength - sizeof(AA_PKT_LLC_SNAP_HEADER);
						if (0 && DataSize >= ATMARP_MIN_1ST_RECV_BUFSIZE)
						{
							DataSize = TotalLength - sizeof(AA_PKT_LLC_SNAP_HEADER);
						}

						(pInterface->IPRcvPktHandler)(
							pInterface->IPContext,
							(PVOID)((PUCHAR)pPktHeader+sizeof(AA_PKT_LLC_SNAP_HEADER)),
							DataSize,
							TotalLength,
							(NDIS_HANDLE)pNdisPacket,
							sizeof(AA_PKT_LLC_SNAP_HEADER),
							IsNonUnicast,
							0,
							pNdisBuffer,
							&ReturnCount
						#if P2MP
							,NULL
						#endif //P2MP
							);
					}
					else
					{
						(pInterface->IPRcvHandler)(
							pInterface->IPContext,
							(PVOID)((PUCHAR)pPktHeader+sizeof(AA_PKT_LLC_SNAP_HEADER)),
							BufferLength - sizeof(AA_PKT_LLC_SNAP_HEADER),
							TotalLength - sizeof(AA_PKT_LLC_SNAP_HEADER),
							(NDIS_HANDLE)pNdisPacket,
							sizeof(AA_PKT_LLC_SNAP_HEADER),
							IsNonUnicast
						#if P2MP
							,NULL
						#endif //P2MP
							);
					}
#else
                    // For Win98:
                    (pInterface->IPRcvHandler)(
                        pInterface->IPContext,
                        (PVOID)((PUCHAR)pPktHeader+sizeof(AA_PKT_LLC_SNAP_HEADER)),
                        BufferLength - sizeof(AA_PKT_LLC_SNAP_HEADER),
                        TotalLength - sizeof(AA_PKT_LLC_SNAP_HEADER),
                        (NDIS_HANDLE)pNdisPacket,
                        sizeof(AA_PKT_LLC_SNAP_HEADER),
                        IsNonUnicast
                    #if P2MP
                        ,NULL
                    #endif //P2MP
                        );

#endif // _PNP_POWER_
				}
				else if (pPktHeader->EtherType == NET_SHORT(AA_PKT_ETHERTYPE_ARP))
				{
					//
					//  An ARP packet: we handle it ourselves
					//
					AA_ASSERT(BufferLength == TotalLength);
					AA_IF_STAT_INCR(pInterface, InUnicastPkts);
					AtmArpHandleARPPacket(
							pVc,
							pPktHeader,
							BufferLength
							);
				}
				else
				{
					//
					//  Discard packet -- bad EtherType
					//
					AADEBUGP(AAD_WARNING, ("VC: 0x%x, Pkt hdr 0x%x, bad EtherType 0x%x\n",
								pVc, pPktHeader, (ULONG)pPktHeader->EtherType));
					Discarded = TRUE;
					AA_IF_STAT_INCR(pInterface, UnknownProtos);
				}
			}
			else
			{
#ifdef IPMCAST
				Discarded = AtmArpMcProcessPacket(
								pVc,
								pNdisPacket,
								pNdisBuffer,
								pPktHeader,
								TotalLength,
								BufferLength
								);
#else
				//
				//  Discard packet -- bad LLC/SNAP
				//
				AADEBUGP(AAD_WARNING, ("VC: 0x%x, Pkt hdr 0x%x, bad LLC/SNAP\n",
								pVc, pPktHeader));
				Discarded = TRUE;
#endif // IPMCAST
			}
		}
		else
		{
			//
			//  Discard packet -- too short
			//
			AADEBUGP(AAD_WARNING, ("VC: 0x%x, Pkt hdr 0x%x, too short: %d\n",
								pVc, pPktHeader, TotalLength));
			Discarded = TRUE;
		}
	}
	else
	{
		//
		//  Discard packet -- IF down
		//
		AADEBUGP(AAD_WARNING, ("pInterface: 0x%x is down, discarding NDIS pkt 0x%x\n",
					pInterface, pNdisPacket));
		Discarded = TRUE;
	}

	if (Discarded)
	{
		AA_IF_STAT_INCR(pInterface, InDiscards);
	}

	return (ReturnCount);
}




VOID
AtmArpHandleARPPacket(
	IN	PATMARP_VC					pVc,
	IN	PAA_PKT_LLC_SNAP_HEADER		pPktHeader,
	IN	ULONG						PacketLength
)
/*++

Routine Description:

	Process a received ARP packet. We complete most of the packet checks
	here, and then branch off to do different things based on the Op type
	in the packet.

	We do not hang on to the packet, i.e. when we return from here,
	the packet is free.

Arguments:

	pVc					- Pointer to ATMARP VC on which packet arrived
	pPktHeader			- Pointer to start of packet (including LLC/SNAP)
	PacketLength		- Length including LLC/SNAP header

Return Value:

	None

--*/
{
	PATMARP_INTERFACE				pInterface;
	PAA_ARP_PKT_HEADER				pArpHeader;
	NDIS_STATUS						Status;

	//
	//  For walking down the packet
	//
	UCHAR UNALIGNED *				pPacket;

	//
	//  For storing pointers to the packet contents. We'll need this
	//  if we have to send a reply packet.
	//
	AA_ARP_PKT_CONTENTS				ArpContents;

	BOOLEAN							SrcAtmBelongsToUs;
	BOOLEAN							SrcIPBelongsToUs;

	//
	//  Initialize (Important: don't remove the zeroing of ArpContents)
	//
	AA_SET_MEM((PUCHAR)&ArpContents, 0, sizeof(AA_ARP_PKT_CONTENTS));
	Status = NDIS_STATUS_SUCCESS;
	pInterface = pVc->pInterface;

	pArpHeader = STRUCT_OF(AA_ARP_PKT_HEADER, pPktHeader, LLCSNAPHeader);

	AADEBUGP(AAD_EXTRA_LOUD+10,
		("HandleARPPkt: VC 0x%x, IF 0x%x, pPktHdr 0x%x, Len %d\n",
				pVc,
				pInterface,
				pPktHeader,
				PacketLength));

	do
	{
		if (PacketLength < AA_ARP_PKT_HEADER_LENGTH)
		{
			AADEBUGP(AAD_WARNING, ("HandleARPPkt: IF 0x%x, PacketLength %d < HdrLen %d\n",
					pInterface, PacketLength, AA_ARP_PKT_HEADER_LENGTH));

			Status = NDIS_STATUS_BUFFER_TOO_SHORT;
			break;
		}

		if ((pArpHeader->hrd != NET_SHORT(AA_PKT_HRD)) ||
			(pArpHeader->pro != NET_SHORT(AA_PKT_PRO)))
		{
			AADEBUGP(AAD_WARNING,
			 ("HandleARPPkt: IF 0x%x, Bad hdr (%d != %d) or pro (%d != %d)\n",
					pInterface,
					pArpHeader->hrd,
					AA_PKT_HRD,
					pArpHeader->pro,
					AA_PKT_PRO));

			Status = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}

		//
		//  Get at the variable part of the packet, and get pointers
		//  to all addresses.
		//
		//  TBD: add more checks on ATM address lengths and combinations
		//	Note: we check for packet length later.
		//
		pPacket = pArpHeader->Variable;

		//
		//  Source ATM Number
		//
		if (pArpHeader->shtl != 0)
		{
			ArpContents.SrcAtmNumberTypeLen = pArpHeader->shtl;
			ArpContents.pSrcAtmNumber = pPacket;
			pPacket += (pArpHeader->shtl & ~AA_PKT_ATM_ADDRESS_BIT);
		}

		//
		//  Source ATM Subaddress
		//
		if (pArpHeader->sstl != 0)
		{
			ArpContents.SrcAtmSubaddrTypeLen = pArpHeader->sstl;
			ArpContents.pSrcAtmSubaddress = pPacket;
			pPacket += (pArpHeader->sstl & ~AA_PKT_ATM_ADDRESS_BIT);
		}

		//
		//  Source IP Address. Older 1577 implementations may send an
		//  IP address field filled with all 0's to denote an unspecified
		//  IP address.
		//
		if (pArpHeader->spln != 0)
		{
			if (pArpHeader->spln != AA_IPV4_ADDRESS_LENGTH)
			{
				AADEBUGP(AAD_WARNING,
					("HandleARPPkt: IF 0x%x, bad spln %d != %d\n",
							pInterface,
							pArpHeader->spln,
							AA_IPV4_ADDRESS_LENGTH));

				Status = NDIS_STATUS_INVALID_ADDRESS;
				break;
			}

			if (!AtmArpIsZeroIPAddress(pPacket))
			{
				ArpContents.pSrcIPAddress = pPacket;
			}
			pPacket += AA_IPV4_ADDRESS_LENGTH;
		}

		//
		//  Target ATM Number
		//
		if (pArpHeader->thtl != 0)
		{
			ArpContents.DstAtmNumberTypeLen = pArpHeader->thtl;
			ArpContents.pDstAtmNumber = pPacket;
			pPacket += (pArpHeader->thtl & ~AA_PKT_ATM_ADDRESS_BIT);
		}

		//
		//  Target ATM Subaddress
		//
		if (pArpHeader->tstl != 0)
		{
			ArpContents.DstAtmSubaddrTypeLen = pArpHeader->tstl;
			ArpContents.pDstAtmSubaddress = pPacket;
			pPacket += (pArpHeader->tstl & ~AA_PKT_ATM_ADDRESS_BIT);
		}

		//
		//  Target IP Address [see comments for Source IP Address]
		//
		if (pArpHeader->tpln != 0)
		{
			if (pArpHeader->tpln != AA_IPV4_ADDRESS_LENGTH)
			{
				AADEBUGP(AAD_WARNING,
					("HandleARPPkt: IF 0x%x, bad tpln %d != %d\n",
							pInterface,
							pArpHeader->tpln,
							AA_IPV4_ADDRESS_LENGTH));

				Status = NDIS_STATUS_INVALID_ADDRESS;
				break;
			}

			if (!AtmArpIsZeroIPAddress(pPacket))
			{
				ArpContents.pDstIPAddress = pPacket;
			}
			pPacket += AA_IPV4_ADDRESS_LENGTH;
		}

		//
		//
		//
		if ((ULONG)(pPacket - (PUCHAR)pArpHeader) >  PacketLength)
		{
				AADEBUGP(AAD_WARNING,
					("HandleARPPkt: IF 0x%x, pPktHdr 0x%x. Length %d TOO SMALL (want %d)\n",
							pInterface,
							pArpHeader,
							PacketLength,
							(pPacket - (PUCHAR)pArpHeader)));

				Status = NDIS_STATUS_BUFFER_TOO_SHORT;
				break;
		}

		//
		//  If this is an ARP NAK packet, swap Source and Target
		//  addresses, in preparation for what follows. This is
		//  because, unlike any other Reply packet where the Source
		//  and Target addresses get swapped, the ARP NAK
		//  packet is a copy of the ARP Request, with only the
		//  Op code changed.
		//
		if (NET_SHORT(pArpHeader->op) == AA_PKT_OP_TYPE_ARP_NAK)
		{
			UCHAR				TypeLen;
			UCHAR UNALIGNED *	pAddress;

			//
			//  IP Addresses:
			//
			pAddress = ArpContents.pSrcIPAddress;
			ArpContents.pSrcIPAddress = ArpContents.pDstIPAddress;
			ArpContents.pDstIPAddress = pAddress;

			//
			//  ATM Number:
			//
			TypeLen = ArpContents.SrcAtmNumberTypeLen;
			ArpContents.SrcAtmNumberTypeLen = ArpContents.DstAtmNumberTypeLen;
			ArpContents.DstAtmNumberTypeLen = TypeLen;
			pAddress = ArpContents.pSrcAtmNumber;
			ArpContents.pSrcAtmNumber = ArpContents.pDstAtmNumber;
			ArpContents.pDstAtmNumber = pAddress;

			//
			//  ATM Subaddress:
			//
			TypeLen = ArpContents.SrcAtmSubaddrTypeLen;
			ArpContents.SrcAtmSubaddrTypeLen = ArpContents.DstAtmSubaddrTypeLen;
			ArpContents.DstAtmSubaddrTypeLen = TypeLen;
			pAddress = ArpContents.pSrcAtmSubaddress;
			ArpContents.pSrcAtmSubaddress = ArpContents.pDstAtmSubaddress;
			ArpContents.pDstAtmSubaddress = pAddress;
		}


		SrcIPBelongsToUs = AtmArpIsLocalIPAddress(
									pInterface,
									ArpContents.pSrcIPAddress
									);

		SrcAtmBelongsToUs = AtmArpIsLocalAtmAddress(
									pInterface,
									ArpContents.pSrcAtmNumber,
									ArpContents.SrcAtmNumberTypeLen
									);

		//
		//  Check if someone else is claiming to be the owner
		//  of "our" IP address:
		//
		if (SrcIPBelongsToUs && !SrcAtmBelongsToUs)
		{
			AADEBUGP(AAD_ERROR,
				 ("Pkt 0x%x: src IP is ours, src ATM is bad!\n", pPktHeader));
			AA_ACQUIRE_IF_LOCK(pInterface);
			pInterface->State = IF_STATUS_DOWN;
			pInterface->LastChangeTime = GetTimeTicks();
			AA_RELEASE_IF_LOCK(pInterface);

			AtmArpStartRegistration(pInterface);

			Status = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}

		//
		//  See if this is directed to someone else: if so, drop it.
		//

		//
		//  Check if the Target IP address is ours. A null IP address is
		//  acceptable (e.g. [In]ARP Request).
		//
		if ((ArpContents.pDstIPAddress != (PUCHAR)NULL) &&
			!AtmArpIsLocalIPAddress(pInterface, ArpContents.pDstIPAddress))
		{
			//
			//  A target IP address is present, and it is not ours
			//
			AADEBUGP(AAD_WARNING,
			("ArpPkt 0x%x has unknown target IP addr (%d.%d.%d.%d)\n",
					 pPktHeader,
					 ArpContents.pDstIPAddress[0],
					 ArpContents.pDstIPAddress[1],
					 ArpContents.pDstIPAddress[2],
					 ArpContents.pDstIPAddress[3]));
			Status = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}

		//
		//  If there is a Target ATM Number, check to see if it is ours.
		//
		if ((ArpContents.pDstAtmNumber != (PUCHAR)NULL) &&
			(!AtmArpIsLocalAtmAddress(
						pInterface,
						ArpContents.pDstAtmNumber,
						ArpContents.DstAtmNumberTypeLen))
		   )
		{
			//
			//  A target ATM number is present, and it is not ours
			//
			AADEBUGP(AAD_WARNING,
					("ArpPkt 0x%x has unknown target ATM addr (0x%x, 0x%x)\n",
					 pPktHeader,
					 ArpContents.DstAtmNumberTypeLen, 
					 ArpContents.pDstAtmNumber));

			Status = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}


		//
		//  Handle the various Op types
		//
		switch (NET_SHORT(pArpHeader->op))
		{
			case AA_PKT_OP_TYPE_ARP_REQUEST:
				AtmArpHandleARPRequest(
						pVc,
						pInterface,
						pArpHeader,
						&ArpContents
						);
				break;

			case AA_PKT_OP_TYPE_ARP_REPLY:
				AtmArpHandleARPReply(
						pVc,
						pInterface,
						pArpHeader,
						&ArpContents,
						SrcIPBelongsToUs,
						SrcAtmBelongsToUs
						);
				break;

			case AA_PKT_OP_TYPE_ARP_NAK:
				AtmArpHandleARPNAK(
						pVc,
						pInterface,
						pArpHeader,
						&ArpContents
						);
				break;

			case AA_PKT_OP_TYPE_INARP_REQUEST:
				AtmArpHandleInARPRequest(
						pVc,
						pInterface,
						pArpHeader,
						&ArpContents
						);
				break;

			case AA_PKT_OP_TYPE_INARP_REPLY:
				AtmArpHandleInARPReply(
						pVc,
						pInterface,
						pArpHeader,
						&ArpContents
						);
				break;

			default:
				AADEBUGP(AAD_WARNING,
					("HandleARPPkt: IF 0x%x, pArpHdr 0x%x, Op %d not known\n",
							pInterface, pArpHeader, NET_SHORT(pArpHeader->op)));

				Status = NDIS_STATUS_NOT_RECOGNIZED;
				break;
		}
		
	}
	while (FALSE);

	return;
}




VOID
AtmArpHandleARPRequest(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
)
/*++

Routine Description:

	Process a received ATMARP Request. All we need to do is send
	an ATMARP Reply, since the calling routine has already verified
	that the Target IP address is ours.

Arguments:

	pVc					- Pointer to VC on which the request arrived
	pInterface			- Pointer to ATMARP Interface containing this VC
	pArpHeader			- Pointer to ARP Header for this packet
	pArpContents		- Parsed contents of received ARP Request packet

Return Value:

	None

--*/
{
	//
	//  Temp locations used for swapping fields
	//
	UCHAR UNALIGNED *			pAddress;
	UCHAR						Length;
	//
	//  ARP Reply packet
	//
	PNDIS_PACKET				pNdisPacket;
	PUCHAR                      pArpPacket;

	//
	//  Swap source and target addresses, and fill in our ATM info
	//  in the source ATM addresses fields.
	//

	//
	//  IP Addresses
	//
	pAddress = pArpContents->pSrcIPAddress;
	pArpContents->pSrcIPAddress = pArpContents->pDstIPAddress;
	pArpContents->pDstIPAddress = pAddress;

	//
	//  ATM Numbers: set the target ATM number to the source ATM
	//  number, but set the source ATM number to the local ATM
	//  address.
	//
	pArpContents->pDstAtmNumber = pArpContents->pSrcAtmNumber;
	pArpContents->DstAtmNumberTypeLen = pArpContents->SrcAtmNumberTypeLen;
	pArpContents->pSrcAtmNumber = (pInterface->LocalAtmAddress.Address);
	pArpContents->SrcAtmNumberTypeLen =
				 AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->LocalAtmAddress));

	//
	//  ATM Subaddresses
	//
	pArpContents->pDstAtmSubaddress = pArpContents->pSrcAtmSubaddress;
	pArpContents->DstAtmSubaddrTypeLen = pArpContents->SrcAtmSubaddrTypeLen;
	pArpContents->pSrcAtmSubaddress = NULL;
	pArpContents->SrcAtmSubaddrTypeLen = 0;

	//
	//  Build the ARP Reply packet
	//
	pNdisPacket = AtmArpBuildARPPacket(
							AA_PKT_OP_TYPE_ARP_REPLY,
							pInterface,
							&pArpPacket,
							pArpContents
							);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		//
		//  And send it off. Since we are in the context of a receive
		//  indication on this VC, we can safely access the VC now.
		//
		AA_ACQUIRE_VC_LOCK(pVc);

		AtmArpSendPacketOnVc(pVc, pNdisPacket);
		//
		//  The VC lock is released by SendPacketOnVc
		//
	}
}



VOID
AtmArpHandleARPReply(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents,
	IN	BOOLEAN						SrcIPAddressIsOurs,
	IN	BOOLEAN						SrcAtmAddressIsOurs
)
/*++

Routine Description:

	Process a received ATMARP Reply packet. There are two major
	cases here:
		(1) We were trying to register one of our IP addresses with
		    the server.
		(2) We were trying to resolve a remote IP address.

	In case (1), if we just registered the first of possibly many
	IP addresses assigned to this interface, we register all the other
	IP addresses.

	In case (2), we set up an IP to ATM mapping and initiate a connection
	if necessary.

Arguments:

	pVc					- Pointer to VC on which the reply arrived
	pInterface			- Pointer to ATMARP Interface containing this VC
	pArpHeader			- Pointer to ARP Header for this packet
	pArpContents		- Parsed contents of received ARP Request packet
	SrcIPAddressIsOurs	- The source IP address is one of ours
	SrcAtmAddressIsOurs	- The source ATM info is ours.

Return Value:

	None

--*/
{
	BOOLEAN				TimerWasRunning;
	BOOLEAN				IsFirstRegistration;
	PIP_ADDRESS_ENTRY	pIPAddressEntry;
	ULONG				rc;		// Ref Count

	AADEBUGP(AAD_LOUD,
		("Handle ARP Reply: pVc 0x%x, pIf 0x%x, IF Flags 0x%x, OurIP %d, OurATM %d\n",
			pVc, pInterface, pInterface->Flags, SrcIPAddressIsOurs, SrcAtmAddressIsOurs));

	AA_ACQUIRE_IF_LOCK(pInterface);

	if (AA_IS_FLAG_SET(
				pInterface->Flags,
				AA_IF_SERVER_STATE_MASK,
				AA_IF_SERVER_REGISTERING))
	{
		//
		//  We just completed registering with the server. Since we don't
		//  send ARP requests to resolve any other addresses while we
		//  are registering, the Source IP address must be ours.
		//

		//
		//  Stop the Registration timer
		//
		TimerWasRunning = AtmArpStopTimer(&(pInterface->Timer), pInterface);
		AA_ASSERT(TimerWasRunning == TRUE);
		if (TimerWasRunning)
		{
			rc = AtmArpDereferenceInterface(pInterface);	// Timer reference
			AA_ASSERT(rc > 0);
		}
		//
		//  We have already verified that the Target addresses are ours.
		//  Check that the source addresses are ours, too.
		//
		if (!SrcIPAddressIsOurs || !SrcAtmAddressIsOurs)
		{
			//
			//  Registration failure. Start recovery.
			//
			AtmArpHandleServerRegistrationFailure(pInterface, pVc);
			//
			//  IF lock is released within the above.
			//
		}
		else
		{
			//
			//  We registered an IP address successfully!
			//
			//  Find the entry for the IP Address that we have registered,
			//  and mark it as registered.
			//
			pIPAddressEntry = &(pInterface->LocalIPAddress);
			while (*((IP_ADDRESS UNALIGNED *)(pArpContents->pSrcIPAddress))
						!= pIPAddressEntry->IPAddress)
			{
				AA_ASSERT(pIPAddressEntry->pNext != (PIP_ADDRESS_ENTRY)NULL);
				pIPAddressEntry = pIPAddressEntry->pNext;
			}
			pIPAddressEntry->IsRegistered = TRUE;

			IsFirstRegistration = pIPAddressEntry->IsFirstRegistration;
			pIPAddressEntry->IsFirstRegistration = FALSE;

			AADEBUGP(AAD_INFO,
				("**** Registered IP Addr: %d.%d.%d.%d on IF 0x%x\n",
					((PUCHAR)&(pIPAddressEntry->IPAddress))[0],
					((PUCHAR)&(pIPAddressEntry->IPAddress))[1],
					((PUCHAR)&(pIPAddressEntry->IPAddress))[2],
					((PUCHAR)&(pIPAddressEntry->IPAddress))[3],
					pInterface));

			AA_SET_FLAG(
					pInterface->Flags,
					AA_IF_SERVER_STATE_MASK,
					AA_IF_SERVER_REGISTERED);

			pInterface->State = IF_STATUS_UP;
			pInterface->LastChangeTime = GetTimeTicks();

			//
			//  Start the Server refresh timer so that we send our ARP info
			//  to the server every so often (default = 15 minutes).
			//
			AtmArpStartTimer(
					pInterface,
					&(pInterface->Timer),
					AtmArpServerRefreshTimeout,
					pInterface->ServerRefreshTimeout,
					(PVOID)pInterface		// Context
					);

			AtmArpReferenceInterface(pInterface);	// Timer reference

			//
			//  If we have any more addresses to register, do so now.
			//
			AtmArpRegisterOtherIPAddresses(pInterface);
			//
			//  IF Lock is freed in the above
			//
#ifdef ATMARP_WMI
			if (IsFirstRegistration)
			{
				//
				//  Send a WMI event, which carries the list of IP Addresses
				//  registered on this IF. We do this only if this is a new
				//  IP address.
				//
				AtmArpWmiSendTCIfIndication(
					pInterface,
                    AAGID_QOS_TC_INTERFACE_UP_INDICATION,
					0
					);
			}
#endif
		}
	}
	else
	{
		//
		//  Resolved an IP to ATM address
		//
		AADEBUGP(AAD_INFO,
			("ARP Reply: Resolved IP Addr: %d.%d.%d.%d\n",
				((PUCHAR)(pArpContents->pSrcIPAddress))[0],
				((PUCHAR)(pArpContents->pSrcIPAddress))[1],
				((PUCHAR)(pArpContents->pSrcIPAddress))[2],
				((PUCHAR)(pArpContents->pSrcIPAddress))[3]
			));

		AA_RELEASE_IF_LOCK(pInterface);

		(VOID)AtmArpLearnIPToAtm(
				pInterface,
				(IP_ADDRESS *)pArpContents->pSrcIPAddress,
				pArpContents->SrcAtmNumberTypeLen,
				pArpContents->pSrcAtmNumber,
				pArpContents->SrcAtmSubaddrTypeLen,
				pArpContents->pSrcAtmSubaddress,
				FALSE		// Not a static entry
				);

	}

	return;
}




VOID
AtmArpHandleARPNAK(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
)
/*++

Routine Description:

	Process a received ARP-NAK packet. If this is in response to
	an ARP Request we had sent to register ourselves, then we close
	the VC to this ARP server, and try the next server in our list of
	servers, after waiting for a while.

	If we were trying to resolve a remote IP address, then we mark
	the ARP IP entry corresponding to this IP address as having
	received a NAK, and free any packets queued on this. We also make
	a timestamp on the Entry so that we don't send another ARP Request
	for the same IP address very soon.

Arguments:
	pVc					- Pointer to VC on which the NAK arrived
	pInterface			- Pointer to ATMARP Interface containing this VC
	pArpHeader			- Pointer to ARP Header for this packet
	pArpContents		- Parsed contents of received ARP Request packet

Return Value:

	None

--*/
{
	BOOLEAN				TimerWasRunning;
	ULONG				rc;				// Ref Count
	PATMARP_IP_ENTRY	pIpEntry;
	PNDIS_PACKET		PacketList = NULL;	// Packets queued for sending

	AA_ACQUIRE_IF_LOCK(pInterface);

	if (AA_IS_FLAG_SET(
				pInterface->Flags,
				AA_IF_SERVER_STATE_MASK,
				AA_IF_SERVER_REGISTERING))
	{
		AADEBUGP(AAD_WARNING,
				("Rcvd ARP NAK while registering: pIf 0x%x\n", pInterface));

		//
		//  Registration was in progress, and it failed. Start recovery.
		//
		AtmArpHandleServerRegistrationFailure(pInterface, pVc);
		//
		//  IF lock is released within the above.
		//
	}
	else
	{
		//
		//  We were trying to resolve an IP address. Get the Address
		//  IP Entry corresponding to this IP address.
		//
		AA_RELEASE_IF_LOCK(pInterface);

		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
		pIpEntry = AtmArpSearchForIPAddress(
							pInterface,
							(IP_ADDRESS *)pArpContents->pSrcIPAddress,
							IE_REFTYPE_TMP,
							FALSE,	// this isn't multicast/broadcast
							FALSE	// Don't create a new one
							);
		AA_RELEASE_IF_TABLE_LOCK(pInterface);

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			AADEBUGP(AAD_INFO,
				("Rcvd ARP NAK: pIf 0x%x, IP addr %d:%d:%d:%d\n",
						pInterface,
						((PUCHAR)(&(pIpEntry->IPAddress)))[0],
						((PUCHAR)(&(pIpEntry->IPAddress)))[1],
						((PUCHAR)(&(pIpEntry->IPAddress)))[2],
						((PUCHAR)(&(pIpEntry->IPAddress)))[3]));

			AA_ACQUIRE_IE_LOCK(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			//
			// AtmArpSerchForIPAddress addrefd pIpEntry for us -- we deref it
			// here now that we've locked it.
			//
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP);

			if (rc > 0)
			{
				//
				//  Take out all packets queued on this entry
				//
				PacketList = pIpEntry->PacketList;
				pIpEntry->PacketList = (PNDIS_PACKET)NULL;
	
				//
				//  The Address resolution timer must be running on this Entry;
				//  stop it.
				//
				TimerWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);
	
				if (TimerWasRunning)
				{
					rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer reference
				}
				else
				{
					rc = pIpEntry->RefCount;
				}
			}

			//
			//  Continue only if the IP Entry hasn't gone away
			//
			if (rc > 0)
			{
				//
				//  Set the IP entry's state so that we don't send any
				//  address resolution traffic for this IP address for
				//  some time.
				//
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_SEEN_NAK);

				//
				//  Start a NAK Delay timer: until this expires, we won't
				//  send any ARP requests for this IP address. This makes
				//  sure that we don't keep pounding on the server with
				//  an unresolvable IP address.
				//
				AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpNakDelayTimeout,
							pInterface->MinWaitAfterNak,
							(PVOID)pIpEntry		// Context
							);

				AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref

				AA_RELEASE_IE_LOCK(pIpEntry);
			}
			// else the IP Entry lock would have been released.


			//
			//  Free any packets that were queued up.
			//
			if (PacketList != (PNDIS_PACKET)NULL)
			{
				AtmArpFreeSendPackets(
							pInterface,
							PacketList,
							FALSE			// No headers on these
							);
			}
		}
		else
		{
			//
			//  No IP Address Entry matching the IP address being
			//  ARP'ed for. Nothing to be done in this case.
			//

		}
	}

	return;

}




VOID
AtmArpHandleInARPRequest(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
)
/*++

Routine Description:

	Process an InARP Request. We send back an InARP Reply packet
	with our address information.

	In case this is a PVC we were trying to resolve, it is possible
	that we are waiting for an InARP Reply ourselves, and the remote
	station came up only now. To speed up the resolution process,
	we restart the InARP Wait timeout so that it expires soon, causing
	another InARP Request to be sent.

Arguments:

	pVc					- Pointer to VC on which the request arrived
	pInterface			- Pointer to ATMARP Interface containing this VC
	pArpHeader			- Pointer to ARP Header for this packet
	pArpContents		- Parsed contents of received ARP Request packet

Return Value:

	None

--*/
{
	//
	//  Temp locations used for swapping fields
	//
	UCHAR UNALIGNED *			pAddress;
	UCHAR						Length;
	//
	//  ARP Reply packet
	//
	PNDIS_PACKET				pNdisPacket;
	PUCHAR                      pArpPacket;

	//
	//  Copy the Source address (IP+ATM) info into the Target address
	//  fields, and fill in the Source info fields with our IP+ATM info.
	//

	//
	//  IP Addresses:
	//
	pArpContents->pDstIPAddress = pArpContents->pSrcIPAddress;
	pArpContents->pSrcIPAddress = (PUCHAR)&(pInterface->LocalIPAddress.IPAddress);

	//
	//  ATM Numbers: set the target ATM number to the source ATM
	//  number, but set the source ATM number to the local ATM
	//  address.
	//
	pArpContents->pDstAtmNumber = pArpContents->pSrcAtmNumber;
	pArpContents->DstAtmNumberTypeLen = pArpContents->SrcAtmNumberTypeLen;
	pArpContents->pSrcAtmNumber = (pInterface->LocalAtmAddress.Address);
	pArpContents->SrcAtmNumberTypeLen =
				 AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->LocalAtmAddress));

	//
	//  ATM Subaddresses
	//
	pArpContents->pDstAtmSubaddress = pArpContents->pSrcAtmSubaddress;
	pArpContents->DstAtmSubaddrTypeLen = pArpContents->SrcAtmSubaddrTypeLen;
	pArpContents->pSrcAtmSubaddress = NULL;
	pArpContents->SrcAtmSubaddrTypeLen = 0;

	//
	//  Build the InARP Reply packet
	//
	pNdisPacket = AtmArpBuildARPPacket(
							AA_PKT_OP_TYPE_INARP_REPLY,
							pInterface,
							&pArpPacket,
							pArpContents
							);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		//
		//  Before we send it off, check if this is a PVC being InARP'ed.
		//  If so, restart the InARP Wait timer so that it expires soon.
		//
		//  It is also possible that this PVC was once resolved, but
		//  the remote end had gone away long enough for us to age out
		//  the corresponding IP entry. This packet might be due to the
		//  remote end coming back up. Start off an Inverse ARP operation
		//  to get our end of the PVC re-resolved.
		//
		AA_ACQUIRE_VC_LOCK(pVc);

		if (AA_IS_FLAG_SET(
					pVc->Flags,
					AA_VC_TYPE_MASK,
					AA_VC_TYPE_PVC) &&

			(AA_IS_FLAG_SET(
					pVc->Flags,
					AA_VC_ARP_STATE_MASK,
					AA_VC_INARP_IN_PROGRESS) ||

			 ((pVc->pAtmEntry != NULL_PATMARP_ATM_ENTRY) &&
			  (pVc->pAtmEntry->pIpEntryList == NULL_PATMARP_IP_ENTRY))))
		{
			BOOLEAN		TimerWasRunning;

#if DBG
			if ((pVc->pAtmEntry != NULL_PATMARP_ATM_ENTRY) &&
			  	(pVc->pAtmEntry->pIpEntryList == NULL_PATMARP_IP_ENTRY))
			{
				AADEBUGP(AAD_LOUD,
					("InARPReq: PVC %p, AtmEntry %p has NULL IP Entry, will InARP again!\n",
						pVc, pVc->pAtmEntry));
			}
#endif
			AA_SET_FLAG(pVc->Flags,
						AA_VC_ARP_STATE_MASK,
						AA_VC_INARP_IN_PROGRESS);

			//
			//  Stop the currently running InARP Wait timer
			//
			TimerWasRunning = AtmArpStopTimer(&(pVc->Timer), pInterface);

			//
			//  Start it again, to fire in 1 second
			//
			AtmArpStartTimer(
						pInterface,
						&(pVc->Timer),
						AtmArpPVCInARPWaitTimeout,
						1,
						(PVOID)pVc		// Context
						);

			if (!TimerWasRunning)
			{
				AtmArpReferenceVc(pVc);		// Timer reference
			}
		}

		AtmArpSendPacketOnVc(pVc, pNdisPacket);
		//
		//  The VC lock is released by SendPacketOnVc
		//
	}
}




VOID
AtmArpHandleInARPReply(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
)
/*++

Routine Description:

	Process an InARP Reply packet, which should be a response to an InARP
	Request we sent earlier.

	There are two circumstances under which we send InARP Requests:
	(1) To obtain the addresses at the other end of a PVC.
	(2) In the process of revalidating an IP Address, if we aren't able
	    to contact the server AND a VC exists to this IP address, we send
	    an InARP Request to revalidate the IP entry.

	In Case (1), we link the PVC to an ATM Address Entry. In Case (2),
	we mark the IP entry for this VC as being "resolved", and start
	data transfer to this IP address.

Arguments:

	pVc					- Pointer to ATMARP VC on which this packet arrived
	pInterface			- Pointer to ATMARP Interface
	pArpHeader			- Pointer to ARP Header for this packet
	pArpContents		- Parsed contents of received ARP Request packet

Return Value:

	None

--*/
{
	PATMARP_ATM_ENTRY		pAtmEntry;	// ATM entry to which this VC is linked
	PATMARP_IP_ENTRY		pIpEntry;		// IP address entry
	BOOLEAN					TimerWasRunning;
	PATMARP_VC *			ppVc;		// Used to unlink VC from unresolved list
	ULONG					rc;			// Ref Count
	PNDIS_PACKET			PacketList;	// Packets queued for sending
	BOOLEAN					IsBroadcast;	// Is the IP Addr a broadcast/Class D addr?


	if (pArpContents->pSrcIPAddress == NULL)
	{
		AADEBUGP(AAD_WARNING,
			("HandleInARPReply: IF %x, Null source address, discarding pkt\n", pInterface));
		return;
	}

	AADEBUGP(AAD_INFO,
			("HandleInARPReply: IF %x, IP addr %d.%d.%d.%d\n",
					pInterface,
					((PUCHAR)pArpContents->pSrcIPAddress)[0],
					((PUCHAR)pArpContents->pSrcIPAddress)[1],
					((PUCHAR)pArpContents->pSrcIPAddress)[2],
					((PUCHAR)pArpContents->pSrcIPAddress)[3]));

	//
	//  Update our ARP cache with this information (regardless of whether
	//  this is a PVC or SVC).
	//
	pIpEntry = AtmArpLearnIPToAtm(
					pInterface,
					(PIP_ADDRESS)pArpContents->pSrcIPAddress,
					pArpContents->SrcAtmNumberTypeLen,
					pArpContents->pSrcAtmNumber,
					pArpContents->SrcAtmSubaddrTypeLen,
					pArpContents->pSrcAtmSubaddress,
					FALSE		// Not a static entry
					);

	//
	//  Acquire the locks that we need, in an ordered fashion...
	//
	AA_ACQUIRE_IF_LOCK(pInterface);

	if (pIpEntry != NULL_PATMARP_IP_ENTRY)
	{
		AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
		AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
		
		pAtmEntry = pIpEntry->pAtmEntry;
		if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
		{
			AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);
		}
	}
	else
	{
		pAtmEntry = NULL_PATMARP_ATM_ENTRY;
	}

	AA_ACQUIRE_VC_LOCK_DPC(pVc);

	if (AA_IS_FLAG_SET(
					pVc->Flags,
					AA_VC_TYPE_MASK,
					AA_VC_TYPE_PVC)  &&
		(pVc->pAtmEntry == NULL_PATMARP_ATM_ENTRY) )
	{
		//
		//  This is an unresolved PVC, whose remote address info
		//  we were trying to InARP for.
		//

		//
		//  Stop the InARP Wait timer running on this VC
		//
		TimerWasRunning = AtmArpStopTimer(&(pVc->Timer), pInterface);
		AA_ASSERT(TimerWasRunning == TRUE);

		if (TimerWasRunning)
		{
			rc = AtmArpDereferenceVc(pVc);	// Timer reference
		}
		else
		{
			rc = pVc->RefCount;
		}

		//
		//  Do the rest only if the VC hasn't gone away.
		//
		if (rc != 0)
		{
			AA_SET_FLAG(
					pVc->Flags,
					AA_VC_ARP_STATE_MASK,
					AA_VC_ARP_STATE_IDLE);

			if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
			{
				//
				//  We are all set now. Take the VC out of the list of
				//  unresolved VCs on this Interface, and put it in the
				//  list of VCs attached to this ATM Entry.
				//
				//  NOTE: we don't dereference the VC because we are just
				//  moving it from one list (Unresolved VCs) to another
				//  (ATM Entry's VC list).
				//
				ppVc = &(pInterface->pUnresolvedVcs);
				while (*ppVc != pVc)
				{
					AA_ASSERT(*ppVc != NULL_PATMARP_VC);
					ppVc = &((*ppVc)->pNextVc);
				}
				*ppVc = pVc->pNextVc;

				AtmArpLinkVcToAtmEntry(pVc, pAtmEntry);
			}
			else
			{
				//
				//  No matching ATM Entry.
				//
				//  We are really low on resources if we are here.
				//  Start the InARP Wait timer; when it fires, we'll try to
				//  send another InARP Request to resolve this VC.
				//
				AADEBUGP(AAD_FATAL,
					("HandleInARPReply: no matching ATM entry: pInterface %x, pVc %x, pIpEntry %x\n",
							pInterface,
							pVc,
							pIpEntry));

				AA_ASSERT(FALSE);

				AtmArpStartTimer(
						pInterface,
						&(pVc->Timer),
						AtmArpPVCInARPWaitTimeout,
						pInterface->InARPWaitTimeout,
						(PVOID)pVc		// Context
						);
				
				AtmArpReferenceVc(pVc);		//  InARP Timer ref

			}

			AA_RELEASE_VC_LOCK_DPC(pVc);

		}
		else
		{
			//
			//  The VC went away while we were InARPing
			//
		}

		//
		//  Release any locks that we still hold.
		//
		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
			{
				AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
			}
			AA_RELEASE_IE_LOCK_DPC(pIpEntry);
		}

		AA_RELEASE_IF_LOCK(pInterface);
	}
	else
	{
		//
		//  Revalidating on a PVC/SVC: case (2) in Routine Description
		//
		AA_SET_FLAG(
				pVc->Flags,
				AA_VC_ARP_STATE_MASK,
				AA_VC_ARP_STATE_IDLE);
		
		//
		//  Stop the INARP timer, if it is running.
		//
		TimerWasRunning = AtmArpStopTimer(&pVc->Timer, pInterface);

		if (TimerWasRunning)
		{
			rc = AtmArpDereferenceVc(pVc);	// InARP reply: stop InARP timer
		}
		else
		{
			rc = pVc->RefCount;
		}

		if (rc != 0)
		{
			AA_RELEASE_VC_LOCK_DPC(pVc);
		}

		//
		//  Update the IP Entry we were revaldating.
		//

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			//
			//  Stop the InARP timer running here
			//
			TimerWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);
			if (TimerWasRunning)
			{
				rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);	// timer ref
			}
			else
			{
				rc = pIpEntry->RefCount;
			}

			//
			//  Continue only if the IP Entry hasn't gone away.
			//
			if (rc > 0)
			{
				//
				//  Update its state
				//
				AA_SET_FLAG(
							pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_RESOLVED
							);

				AADEBUGP(AAD_INFO,
					("InARP Reply: Revalidated pIpEntry 0x%x, IP Addr: %d.%d.%d.%d\n",
							pIpEntry,
							((PUCHAR)(&(pIpEntry->IPAddress)))[0],
							((PUCHAR)(&(pIpEntry->IPAddress)))[1],
							((PUCHAR)(&(pIpEntry->IPAddress)))[2],
							((PUCHAR)(&(pIpEntry->IPAddress)))[3]
							));

				AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);

				//
				//  Start the Aging timer.
				//
				AtmArpStartTimer(
					pInterface,
					&(pIpEntry->Timer),
					AtmArpIPEntryAgingTimeout,
					pInterface->ARPEntryAgingTimeout,
					(PVOID)pIpEntry
					);

				AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref

				//
				//  Take out the list of pending packets on this Entry
				//
				PacketList = pIpEntry->PacketList;
				pIpEntry->PacketList = (PNDIS_PACKET)NULL;

				IsBroadcast = AA_IS_FLAG_SET(pIpEntry->Flags,
											 AA_IP_ENTRY_ADDR_TYPE_MASK,
											 AA_IP_ENTRY_ADDR_TYPE_NUCAST);

				AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
				AA_RELEASE_IE_LOCK_DPC(pIpEntry);
				AA_RELEASE_IF_LOCK(pInterface);

				//
				//  Send out all these packets
				//
				AtmArpSendPacketListOnAtmEntry(
							pInterface,
							pAtmEntry,
							PacketList,
							IsBroadcast
							);
			}
			else
			{
				//
				//  the IP Entry is gone
				//
				AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
				AA_RELEASE_IF_LOCK(pInterface);
			}
		}
		else
		{
			//
			//  No matching IP Entry
			//
			AA_RELEASE_IF_LOCK(pInterface);
		}
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\arpif.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arpif.c

Abstract:

	ARP Interface Entry points. These are called (indirectly) by the IP
	layer. All these entry points have the common prefix "AtmArpIf".

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     07-17-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'FIRA'


#if DBG_QRY
ULONG	AaIgnoreInstance = 0;
#endif

IP_MASK  AtmArpIPMaskTable[] =
{
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSB_MASK,
    CLASSB_MASK,
    CLASSB_MASK,
    CLASSB_MASK,
    CLASSC_MASK,
    CLASSC_MASK,
    CLASSD_MASK,
    CLASSE_MASK
};


VOID
AtmArpReStartInterface(
	IN	PNDIS_WORK_ITEM				pWorkItem,
	IN	PVOID						IfContext
);


#ifndef NEWARP

NDIS_STATUS
AtmArpInitIPInterface(
	VOID
)
/*++

Routine Description:

	Initialize our interface with IP. This consists of querying IP for
	its "Add Interface" and "Delete Interface" entry points.

Arguments:

	None. It is assumed that the caller has a lock to the ATMARP Global
	Info structure.

Return Value:

	NDIS_STATUS_SUCCESS if initialization was successful
	NDIS_STATUS_XXX error code otherwise.

--*/
{
	NDIS_STATUS				Status;
#if !LINK_WITH_IP
    IP_GET_PNP_ARP_POINTERS IPInfo;
    UNICODE_STRING          IPDeviceName;
    PIRP                    pIrp;
    PFILE_OBJECT            pIpFileObject;
    PDEVICE_OBJECT          pIpDeviceObject;
    IO_STATUS_BLOCK         ioStatusBlock;

	//
	//  Initialize.
	//
	pIrp = (PIRP)NULL;
	pIpFileObject = (PFILE_OBJECT)NULL;
	pIpDeviceObject = (PDEVICE_OBJECT)NULL;


	do
	{
		NdisInitUnicodeString(&IPDeviceName, DD_IP_DEVICE_NAME);

		//
		// Get the file and device objects for the IP device.
		//
		Status = IoGetDeviceObjectPointer(
							&IPDeviceName,
							SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
							&pIpFileObject,
							&pIpDeviceObject);

		if ((Status != STATUS_SUCCESS) || (pIpDeviceObject == NULL))
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		// Reference the device object.
		//
		ObReferenceObject(pIpDeviceObject);

		pIrp = IoBuildDeviceIoControlRequest(IOCTL_IP_GET_PNP_ARP_POINTERS,
                                         pIpDeviceObject,
                                         NULL,
                                         0,
                                         &IPInfo,
                                         sizeof (IPInfo),
                                         FALSE,
                                         NULL,
                                         &ioStatusBlock);

		if (pIrp == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		Status = IoCallDriver(pIpDeviceObject, pIrp);

		if (Status != STATUS_SUCCESS)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

    	pAtmArpGlobalInfo->pIPAddInterfaceRtn = IPInfo.IPAddInterface;
    	pAtmArpGlobalInfo->pIPDelInterfaceRtn = IPInfo.IPDelInterface;

    	Status = NDIS_STATUS_SUCCESS;

	}
	while (FALSE);

	if (pIpFileObject != (PFILE_OBJECT)NULL)
	{
		//
		// Dereference the file object
		//
		ObDereferenceObject((PVOID)pIpFileObject);
	}

    if (pIpDeviceObject != (PDEVICE_OBJECT)NULL)
    {
		//
		// Close the device.
		//
		ObDereferenceObject((PVOID)pIpDeviceObject);
	}
#else

   	pAtmArpGlobalInfo->pIPAddInterfaceRtn = IPAddInterface;
   	pAtmArpGlobalInfo->pIPDelInterfaceRtn = (IPDelInterfacePtr)IPDelInterface;

   	Status = NDIS_STATUS_SUCCESS;

#endif // !LINK_WITH_IP

	AADEBUGP(AAD_INFO, ("Init IP Interface: returning Status 0x%x\n", Status));
    return (Status);
}



INT
AtmArpIfDynRegister(
	IN	PNDIS_STRING				pAdapterString,
	IN	PVOID						IPContext,
	IN	IPRcvRtn 					IPRcvHandler,
	IN	IPTxCmpltRtn				IPTxCmpltHandler,
	IN	IPStatusRtn					IPStatusHandler,
	IN	IPTDCmpltRtn				IPTDCmpltHandler,
	IN	IPRcvCmpltRtn				IPRcvCmpltHandler,
	IN	struct LLIPBindInfo			*pBindInfo,
	IN	UINT						NumIFBound
)
/*++

Routine Description:

	This routine is called from the IP layer when it wants to tell us,
	the ARP module, about its handlers for an Interface.

Arguments:

	pAdapterString		- Name of the logical adapter for this interface
	IPContext			- IP's context for this interface
	IPRcvHandler		- Up-call for receives
	IPTxCmpltHandler	- Up-call for transmit completes
	IPStatusHandler		- Up-call to indicate status changes
	IPTDCmpltHandler	- Up-call to indicate completion of Transfer-Data
	IPRcvCmpltHandler	- Up-call to indicate temporary completion of receives
	pBindInfo			- Pointer to bind info with our information
	NumIFBound			- Count for this interface

Return Value:

	(UINT)TRUE always.

--*/
{
	PATMARP_INTERFACE			pInterface;

	pInterface = (PATMARP_INTERFACE)(pBindInfo->lip_context);
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("IfDynRegister: pIf 0x%x\n", pInterface));

	pInterface->IPContext = IPContext;
	pInterface->IPRcvHandler = IPRcvHandler;
	pInterface->IPTxCmpltHandler = IPTxCmpltHandler;
	pInterface->IPStatusHandler = IPStatusHandler;
	pInterface->IPTDCmpltHandler = IPTDCmpltHandler;
	pInterface->IPRcvCmpltHandler = IPRcvCmpltHandler;
	pInterface->IFIndex = NumIFBound;

	return ((UINT)TRUE);
}

#else
// NEWARP

INT
AtmArpIfDynRegister(
	IN	PNDIS_STRING				pAdapterString,
	IN	PVOID						IPContext,
	IN	struct _IP_HANDLERS *		pIpHandlers,
	IN	struct LLIPBindInfo *		pBindInfo,
	IN	UINT						InterfaceNumber
)
/*++

Routine Description:

	This routine is called from the IP layer when it wants to tell us,
	the ARP module, about its handlers for an Interface.

Arguments:

	pAdapterString		- Name of the logical adapter for this interface
	IPContext			- IP's context for this interface
	pIpHandlers			- Points to struct containing the following handlers:
		IPRcvHandler		- Up-call for receives
		IPTxCmpltHandler	- Up-call for transmit completes
		IPStatusHandler		- Up-call to indicate status changes
		IPTDCmpltHandler	- Up-call to indicate completion of Transfer-Data
		IPRcvCmpltHandler	- Up-call to indicate temporary completion of receives
	pBindInfo			- Pointer to bind info with our information
	InterfaceNumber		- ID for this interface

Return Value:

	(UINT)TRUE always.

--*/
{
	PATMARP_INTERFACE			pInterface;

	pInterface = (PATMARP_INTERFACE)(pBindInfo->lip_context);
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("IfDynRegister: pIf 0x%x\n", pInterface));

	pInterface->IPContext = IPContext;
	pInterface->IPRcvHandler = pIpHandlers->IpRcvHandler;
	pInterface->IPTxCmpltHandler = pIpHandlers->IpTxCompleteHandler;
	pInterface->IPStatusHandler = pIpHandlers->IpStatusHandler;
	pInterface->IPTDCmpltHandler = pIpHandlers->IpTransferCompleteHandler;
	pInterface->IPRcvCmpltHandler = pIpHandlers->IpRcvCompleteHandler;
#ifdef _PNP_POWER_
	pInterface->IPPnPEventHandler = pIpHandlers->IpPnPHandler;
	pInterface->IPRcvPktHandler = pIpHandlers->IpRcvPktHandler;
#endif // _PNP_POWER_
	pInterface->IFIndex = InterfaceNumber;

	return ((UINT)TRUE);
}

#endif // !NEWARP


VOID
AtmArpIfOpen(
	IN	PVOID						Context
)
/*++

Routine Description:

	This routine is called when IP is ready to use this interface.
	This is equivalent to setting AdminState to UP.

	We register our SAP with the Call Manager, thus allowing incoming
	calls to reach us. If atleast one local IP address has been set,
	and the ATM interface is ip, we start registering ourselves with
	the server.

Arguments:

	Context		- Actually a pointer to our ATMARP Interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	NDIS_HANDLE				ProtocolSapContext;
	PNDIS_HANDLE			pNdisSapHandle;
	PCO_SAP					pSap;
	BOOLEAN					AtmInterfaceDown;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("IfOpen: pIf 0x%x\n", pInterface));

	AA_ACQUIRE_IF_LOCK(pInterface);

	AA_ASSERT(pInterface->NdisAfHandle != NULL);

	pInterface->AdminState = IF_STATUS_UP;
	AA_INIT_BLOCK_STRUCT(&(pInterface->Block));

	AtmInterfaceDown = !(pInterface->AtmInterfaceUp);

	AA_RELEASE_IF_LOCK(pInterface);

	//
	//  Get the local ATM address if we haven't got it yet.
	//
	if (AtmInterfaceDown)
	{
		AtmArpGetAtmAddress(pInterface);
	}
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	//
	//  Register our SAP(s) with the Call Manager.
	//
	AtmArpRegisterSaps(pInterface);
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);


#ifdef ATMARP_WMI
	//
	//  Make this interface a WMI provider.
	//
	AtmArpWmiInitInterface(pInterface, AtmArpGuidList, AtmArpGuidCount);

#endif // ATMARP_WMI

	AA_ACQUIRE_IF_LOCK(pInterface);

#ifdef IPMCAST
	//
	//  Start multicast registration with MARS.
	//
	AtmArpMcStartRegistration(pInterface);

	//
	//  IF lock is released within the above.
	//
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	AA_ACQUIRE_IF_LOCK(pInterface);
#endif // IPMCAST

	//
	//  All necessary pre-conditions are checked within
	//  AtmArpStartRegistration.
	//
	AtmArpStartRegistration(pInterface);

	//
	//  IF lock is released within the above.
	//

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return;
}




VOID
AtmArpIfClose(
	IN	PVOID						Context
)
/*++

Routine Description:

	IP wants to stop using this Interface. We assume that this is called
	in response to our Up-call to IP's DelInterface entry point.

	We simply dereference the interface, unless we are actually in the process
	of bringing it down and up due to a reconfigure notification.

Arguments:

	Context		- Actually a pointer to our ATMARP Interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;			// Ref Count
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif
    BOOLEAN                 fQueueRestart = FALSE;
    PNDIS_WORK_ITEM         pWorkItem;
    NDIS_STATUS             NdisStatus;

	AA_GET_ENTRY_IRQL(EntryIrq);

	pInterface = (PATMARP_INTERFACE)Context;

	AA_STRUCT_ASSERT(pInterface, aai);

    AA_ACQUIRE_IF_LOCK(pInterface);

    //
    // Ensure that we won't send up an IPDelInterface on this
    // interface.
    //
    pInterface->IPContext = NULL;

    if (pInterface->ReconfigState==RECONFIG_SHUTDOWN_PENDING)
    {
        AA_ALLOC_MEM(pWorkItem, NDIS_WORK_ITEM, sizeof(NDIS_WORK_ITEM));
        if (pWorkItem == NULL)
        {
            AA_ASSERT(FALSE);
        }
        else
        {
            pInterface->ReconfigState=RECONFIG_RESTART_QUEUED;
            fQueueRestart = TRUE;
        }
    }
    else
    {
        AA_ASSERT(pInterface->ReconfigState==RECONFIG_NOT_IN_PROGRESS);
    }

    AA_RELEASE_IF_LOCK(pInterface);

#ifdef ATMARP_WMI

	//
	//  Deregister this Interface as a WMI provider.
	//	We do this even when bringing down the interface for a reconfig
	//  because certain IP information could potentially become stale.
	//
	AtmArpWmiShutdownInterface(pInterface);

#endif // ATMARP_WMI

    if (fQueueRestart)
    {
        //
        // We have a request to reconfigure this interface. So we will
        // keep this structure allocated and queue
        // a work item to bring this interface back up -- reading the latest
        // configuration paramters from the registry.
        //

        //
        // We do not strictly need to  reference the interface here because we
        // expect the interface to be still around. Nevertheless
        // we reference it here and dereference it when the work item fires.
        //
        AtmArpReferenceInterface(pInterface); // ReStart Work Item

        NdisInitializeWorkItem(
            pWorkItem,
            AtmArpReStartInterface,
            (PVOID)pInterface
            );

        NdisStatus = NdisScheduleWorkItem(pWorkItem);
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // Ouch, fall back to simply deleting the interface.
            //
			AA_FREE_MEM(pWorkItem);
			fQueueRestart = FALSE;
        }
    }


    if (!fQueueRestart)
    {

        AADEBUGP(AAD_INFO, ("IfClose: will deallocate pIf 0x%x, RefCount %d\n",
                     pInterface, pInterface->RefCount));
    
        AA_ACQUIRE_IF_LOCK(pInterface);
    
        rc = AtmArpDereferenceInterface(pInterface);
    
        if (rc != 0)
        {
            AA_RELEASE_IF_LOCK(pInterface);
        }
        //
        //  else the Interface is gone.
        //
    
        AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
    }

	return;
}



UINT
AtmArpIfAddAddress(
	IN	PVOID						Context,
	IN	UINT						AddressType,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
#ifndef BUILD_FOR_1381
	,
	IN	PVOID						Context2
#endif // BUILD_FOR_1381
)
/*++

Routine Description:

	The IP layer calls this when a new IP address (or block of IP addresses,
	as determined by AddressType) needs to be added to an Interface.

	We could see any of four address types: Local, Multicast, Broadcast
	and Proxy ARP. In the case of Proxy ARP, the address along with the mask
	can specify a block of contiguous IP addresses for which this host acts
	as a proxy. Currently, we only support the "Local", "Broadcast", and
	"Multicast" types.

	If we just added the only local address for this interface, and the
	ATM interface is up, and AdminState for this interface is UP, we initiate
	address registration with the ARP server.

Arguments:

	Context			- Actually a pointer to the ATMARP Interface structure
	AddressType		- Type of address(es) being added.
	IPAddress		- Address to be added.
	Mask			- For the above.
	Context2		- Additional context (for what?)

Return Value:

	(UINT)TRUE if successful, (UINT)FALSE otherwise.

--*/
{
	PATMARP_INTERFACE		pInterface;
	PIP_ADDRESS_ENTRY		pIpAddressEntry;
	UINT					ReturnStatus;
	BOOLEAN					LockAcquired;

	ReturnStatus = (UINT)FALSE;	// Initialize to Failure

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IF_LOCK(pInterface);
	LockAcquired = TRUE;

	if (AddressType == LLIP_ADDR_LOCAL)
	{
		//
		//  Find a place to put this new address in.
		//
		if (pInterface->NumOfIPAddresses == 0)
		{
			pIpAddressEntry = &(pInterface->LocalIPAddress);
		}
		else
		{
			AA_ALLOC_MEM(pIpAddressEntry, IP_ADDRESS_ENTRY, sizeof(IP_ADDRESS_ENTRY));
			if (pIpAddressEntry != (PIP_ADDRESS_ENTRY)NULL)
			{
				pIpAddressEntry->pNext = pInterface->LocalIPAddress.pNext;
				pInterface->LocalIPAddress.pNext = pIpAddressEntry;
			}
		}

		if (pIpAddressEntry != (PIP_ADDRESS_ENTRY)NULL)
		{
			ReturnStatus = (UINT)TRUE;

			pIpAddressEntry->IPAddress = IPAddress;
			pIpAddressEntry->IPMask = Mask;
			pIpAddressEntry->IsRegistered = FALSE;
			pIpAddressEntry->IsFirstRegistration = TRUE;

			pInterface->NumOfIPAddresses++;
			if (pInterface->NumOfIPAddresses == 1)
			{
				AtmArpStartRegistration(pInterface);
				//
				//  IF Lock is released by above routine.
				//
				LockAcquired = FALSE;
			}
			else
			{
				if (AA_IS_FLAG_SET(
						pInterface->Flags,
						AA_IF_SERVER_STATE_MASK,
						AA_IF_SERVER_REGISTERED) &&
					(!pInterface->PVCOnly))
				{
					AA_RELEASE_IF_LOCK(pInterface);
					LockAcquired = FALSE;
					AtmArpSendARPRequest(
							pInterface,
							&IPAddress,
							&IPAddress
							);
				}
				//
				//  else either 
				//  (a) registration is in progress; at the end of it,
				//  we will register all unregistered IP addresses.
				//  	or
				//  (b) we are in a PVC only environment, no ARP server.
				//
			}
		}
		//
		//  else allocation failure -- fall thru
		//
	}
#ifdef IPMCAST
	else if ((AddressType == LLIP_ADDR_BCAST) || (AddressType == LLIP_ADDR_MCAST))
	{
		if (AddressType == LLIP_ADDR_BCAST)
		{
			pInterface->BroadcastAddress = IPAddress;
		}
		ReturnStatus = AtmArpMcAddAddress(pInterface, IPAddress, Mask);
		//
		// IF Lock is released within the above.
		//
		LockAcquired = FALSE;
	}
#else
	else if (AddressType == LLIP_ADDR_BCAST)
	{
		pInterface->BroadcastAddress = IPAddress;
		ReturnStatus = (UINT)TRUE;
	}
#endif // IPMCAST

	if (LockAcquired)
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}

#ifdef BUILD_FOR_1381
	AADEBUGP(AAD_INFO,
	 ("IfAddAddress: IF 0x%x, Type %d, Addr %d.%d.%d.%d, Mask 0x%x, Ret %d\n",
				pInterface,
				AddressType,
				((PUCHAR)(&IPAddress))[0],
				((PUCHAR)(&IPAddress))[1],
				((PUCHAR)(&IPAddress))[2],
				((PUCHAR)(&IPAddress))[3],
				Mask, ReturnStatus));
#else
	AADEBUGP(AAD_INFO,
	 ("IfAddAddress: IF 0x%x, Type %d, Addr %d.%d.%d.%d, Mask 0x%x, Ret %d, Ctx2 0x%x\n",
				pInterface,
				AddressType,
				((PUCHAR)(&IPAddress))[0],
				((PUCHAR)(&IPAddress))[1],
				((PUCHAR)(&IPAddress))[2],
				((PUCHAR)(&IPAddress))[3],
				Mask, ReturnStatus, Context2));
#endif // BUILD_FOR_1381


	return (ReturnStatus);
}



UINT
AtmArpIfDelAddress(
	IN	PVOID						Context,
	IN	UINT						AddressType,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
)
/*++

Routine Description:

	This is called from the IP layer when an address added via AtmArpIfAddAddress
	is to be deleted.

	Currently, only the "Local" Address type is supported.

	Assumption: the given address was successfully added earlier.

Arguments:

	Context			- Actually a pointer to the ATMARP Interface structure
	AddressType		- Type of address(es) being deleted.
	IPAddress		- Address to be deleted.
	Mask			- For the above.

Return Value:

	(UINT)TRUE if successful, (UINT)FALSE otherwise.

--*/
{
	PATMARP_INTERFACE		pInterface;
	PIP_ADDRESS_ENTRY		pIpAddressEntry;
	PIP_ADDRESS_ENTRY		pPrevIpAddressEntry;
	PIP_ADDRESS_ENTRY		pTmpIpAddressEntry;
	UINT					ReturnValue;

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	if (AddressType == LLIP_ADDR_LOCAL)
	{
		AA_ACQUIRE_IF_LOCK(pInterface);

		//
		//  Search for the entry to be deleted.
		//
		pPrevIpAddressEntry = (PIP_ADDRESS_ENTRY)NULL;
		pIpAddressEntry = &(pInterface->LocalIPAddress);
		while (!IP_ADDR_EQUAL(pIpAddressEntry->IPAddress, IPAddress))
		{
			pPrevIpAddressEntry = pIpAddressEntry;
			pIpAddressEntry = pIpAddressEntry->pNext;
			AA_ASSERT(pIpAddressEntry != (PIP_ADDRESS_ENTRY)NULL);
		}

		//
		//  If it was the only one in the list, there is nothing
		//  to be done. Otherwise, update the list.
		//
		if (pInterface->NumOfIPAddresses > 1)
		{
			//
			//  More than one entry existed. Check if we deleted the
			//  first one.
			//
			if (pPrevIpAddressEntry == (PIP_ADDRESS_ENTRY)NULL)
			{
				//
				//  Copy in the contents of the second entry
				//  into the head of the list, and delete the
				//  second entry.
				//
				AA_ASSERT(pIpAddressEntry == &(pInterface->LocalIPAddress));
				AA_ASSERT(pIpAddressEntry->pNext != (PIP_ADDRESS_ENTRY)NULL);

				pIpAddressEntry->IPAddress = pIpAddressEntry->pNext->IPAddress;
				pIpAddressEntry->IPMask = pIpAddressEntry->pNext->IPMask;
				pTmpIpAddressEntry = pIpAddressEntry->pNext;
				pIpAddressEntry->pNext = pIpAddressEntry->pNext->pNext;

				pIpAddressEntry = pTmpIpAddressEntry;
			}
			else
			{
				pPrevIpAddressEntry->pNext = pIpAddressEntry->pNext;
			}

			AA_FREE_MEM(pIpAddressEntry);
		}

		pInterface->NumOfIPAddresses--;

		AA_RELEASE_IF_LOCK(pInterface);

		ReturnValue = (UINT)TRUE;
	}
	else
#ifdef IPMCAST
	{
		if ((AddressType == LLIP_ADDR_BCAST) || (AddressType == LLIP_ADDR_MCAST))
		{
			AA_ACQUIRE_IF_LOCK(pInterface);
			ReturnValue = AtmArpMcDelAddress(pInterface, IPAddress, Mask);
		}
		else
		{
			ReturnValue = (UINT)FALSE;
		}
	}
#else
	{
		ReturnValue = (UINT)FALSE;
	}
#endif // IPMCAST

	AADEBUGP(AAD_INFO,
		("IfDelAddress: Ctxt 0x%x, Type 0x%x, IPAddr 0x%x, Mask 0x%x, Ret %d\n",
			Context, AddressType, IPAddress, Mask, ReturnValue));

	return (ReturnValue);
}


#ifdef NEWARP
NDIS_STATUS
AtmArpIfMultiTransmit(
	IN	PVOID						Context,
	IN	PNDIS_PACKET *				pNdisPacketArray,
	IN	UINT						NumberOfPackets,
	IN	IP_ADDRESS					Destination,
	IN	RouteCacheEntry *			pRCE		OPTIONAL
#if P2MP
	,
	IN  void *                  ArpCtxt
#endif
)
/*++

Routine Description:

	This is called from the IP layer when it has a sequence of datagrams,
	each in the form of an NDIS buffer chain, to send over an Interface.

Arguments:

	Context				- Actually a pointer to our Interface structure
	pNdisPacketArray	- Array of Packets to be sent on this Interface
	NumberOfPackets		- Length of array
	Destination			- IP address of next hop for this packet
	pRCE				- Optional pointer to Route Cache Entry structure.

Return Value:

	NDIS_STATUS_PENDING if all packets were queued for transmission.
	If one or more packets "failed", we set the packet status to reflect
	what happened to each, and return NDIS_STATUS_FAILURE.

--*/
{
	NDIS_STATUS			Status;
	PNDIS_PACKET *		ppNdisPacket;

	Status = NDIS_STATUS_FAILURE;

	for (ppNdisPacket = pNdisPacketArray;
		 NumberOfPackets > 0;
		 NumberOfPackets--, ppNdisPacket++)
	{
		PNDIS_PACKET			pNdisPacket;

		pNdisPacket = *ppNdisPacket;
		NDIS_SET_PACKET_STATUS(pNdisPacket, NDIS_STATUS_PENDING);
#if DBG
		AA_ASSERT(pNdisPacket->Private.Head != NULL);
#endif // DBG

		Status = AtmArpIfTransmit(
						Context,
						*ppNdisPacket,
						Destination,
						pRCE
					#if P2MP
						,NULL
					#endif
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			NDIS_SET_PACKET_STATUS(*ppNdisPacket, Status);
			break;
		}
	}

	return (Status);
}

#endif // NEWARP

NDIS_STATUS
AtmArpIfTransmit(
	IN	PVOID						Context,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	IP_ADDRESS					Destination,
	IN	RouteCacheEntry *			pRCE		OPTIONAL
#if P2MP
	,
	IN  void *                  ArpCtxt
#endif
)
/*++

Routine Description:

	This is called from the IP layer when it has a datagram (in the form of
	an NDIS buffer chain) to send over an Interface.

	The destination IP address is passed to us in this routine, which may
	or may not be the final destination for the packet. 

	The Route Cache Entry is created by the IP layer, and is used to speed
	up our lookups. An RCE, if specified, uniquely identifies atleast the
	IP destination for this packet. The RCE contains space for the ARP layer
	to keep context information about this destination. When the first packet
	goes out to a Destination, our context info in the RCE will be NULL, and
	we search the ARP Table for the matching IP Entry. However, we then fill
	our context info (pointer to IP Entry) in the RCE, so that subsequent
	transmits aren't slowed down by an IP address lookup.

Arguments:

	Context				- Actually a pointer to our Interface structure
	pNdisPacket			- Packet to be sent on this Interface
	Destination			- IP address of next hop for this packet
	pRCE				- Optional pointer to Route Cache Entry structure.

Return Value:

	Status of the transmit: NDIS_STATUS_SUCCESS, NDIS_STATUS_PENDING, or
	a failure.

--*/
{
	PATMARP_INTERFACE			pInterface;
	PATMARP_IP_ENTRY			pIpEntry;		// IP Entry corresp to Destination
	PATMARP_ATM_ENTRY			pAtmEntry;		// ATM Entry for this destination
	PATMARP_RCE_CONTEXT			pRCEContext;	// Our context in the RCE

	PATMARP_FLOW_INFO			pFlowInfo;		// Flow to which this packet belongs
	PATMARP_FILTER_SPEC			pFilterSpec;	// Filter Spec for this packet
	PATMARP_FLOW_SPEC			pFlowSpec;		// Flow Spec for this packet

	PNDIS_BUFFER				pHeaderBuffer;	// NDIS Buffer for LLC/SNAP header
	PUCHAR						pHeader;		// Pointer to header area
	NDIS_STATUS					Status;			// Return value

	BOOLEAN						IsBroadcastAddress;
	BOOLEAN						CreateNewEntry;	// Should we create a new IP entry?
#ifdef IPMCAST
	BOOLEAN						NeedMcRevalidation;	// If Multicast, do we revalidate?
#endif // IPMCAST
	ULONG						rc;
#if DBG
	AA_IRQL						EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_EXTRA_LOUD,
		("IfTransmit: pIf 0x%x, Pkt 0x%x, Dst 0x%x, pRCE 0x%x\n",
			pInterface, pNdisPacket, Destination, pRCE));

#if DBG
	if (AaDataDebugLevel & (AAD_DATA_OUT|AAD_TRACK_BIG_SENDS))
	{
		ULONG			TotalLength;
		PNDIS_BUFFER	pNdisBuffer;

		NdisQueryPacket(
				pNdisPacket,
				NULL,
				NULL,
				NULL,
				&TotalLength
				);

		if (AaDataDebugLevel & AAD_DATA_OUT)
		{
			AADEBUGP(AAD_WARNING, ("%d (", TotalLength));
			for (pNdisBuffer = pNdisPacket->Private.Head;
 				pNdisBuffer != NULL;
 				pNdisBuffer = pNdisBuffer->Next)
 			{
 				INT	BufLength;

				NdisQueryBuffer(pNdisBuffer, NULL, &BufLength);
 				AADEBUGP(AAD_WARNING, (" %d", BufLength));
 			}
			AADEBUGP(AAD_WARNING, (") => %d.%d.%d.%d\n",
				(ULONG)(((PUCHAR)&Destination)[0]),
				(ULONG)(((PUCHAR)&Destination)[1]),
				(ULONG)(((PUCHAR)&Destination)[2]),
				(ULONG)(((PUCHAR)&Destination)[3])));
		}
		if ((AaDataDebugLevel & AAD_TRACK_BIG_SENDS) && ((INT)TotalLength > AadBigDataLength))
		{
			AADEBUGP(AAD_WARNING, ("%d => %d.%d.%d.%d\n",
				TotalLength,
				(ULONG)(((PUCHAR)&Destination)[0]),
				(ULONG)(((PUCHAR)&Destination)[1]),
				(ULONG)(((PUCHAR)&Destination)[2]),
				(ULONG)(((PUCHAR)&Destination)[3])));
			DbgBreakPoint();
		}
			
	}

#endif // DBG

#ifdef PERF
	AadLogSendStart(pNdisPacket, (ULONG)Destination, (PVOID)pRCE);
#endif // PERF

#ifdef IPMCAST
	NeedMcRevalidation = FALSE;
#endif // IPMCAST
		
	do
	{
		//
		//  Discard this packet if the AdminStatus for this interface
		//  is not UP.
		//
		if (pInterface->AdminState != IF_STATUS_UP)
		{
			Status = NDIS_STATUS_INTERFACE_DOWN;
			break;
		}

		//
		//  Get the filter and flow specs for this packet.
		//
		AA_GET_PACKET_SPECS(pInterface, pNdisPacket, &pFlowInfo, &pFlowSpec, &pFilterSpec);

#ifdef GPC_MAYBE
	//
	//  We may not do this stuff because there are things to be done
	//  (see multicast case below) with the IP entry that would be
	//  missed out if we do this.
	//
		pVc = AA_GET_VC_FOR_FLOW(pFlowInfo);

		if (pVc != NULL_PATMARP_VC)
		{
			AA_ACQUIRE_VC_LOCK(pVc);

			if ((pVc->FlowHandle == pFlowInfo) &&

				AA_IS_FLAG_SET(pVc->Flags,
							   AA_VC_CALL_STATE_MASK,
							   AA_VC_CALL_STATE_ACTIVE) &&

				!AA_IS_VC_GOING_DOWN(pVc)
			   )
			{
				AA_PREPARE_HEADER(pNdisPacket, pInterface, pFlowSpec, &Status);

				if (Status == NDIS_STATUS_SUCCESS)
				{
					AtmArpRefreshTimer(&(pVc->Timer));
					AtmArpReferenceVc(pVc);	// IfTransmit
					pVc->OutstandingSends++;	// IfTransmit

					NdisVcHandle = pVc->NdisVcHandle;

					AA_RELEASE_VC_LOCK(pVc);

					NDIS_CO_SEND(
							NdisVcHandle,
							&pNdisPacket,
							1
							);
					break;
				}
			}

			AA_RELEASE_VC_LOCK(pVc);
			//
			//  Fall through
			//
		}
#endif // GPC
		//
		//  Get the IP Entry for this destination: see if we have
		//  cached information that we can use.
		//
		if (pRCE != (RouteCacheEntry *)NULL)
		{
			pRCEContext = (PATMARP_RCE_CONTEXT)(pRCE->rce_context);

			AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

			pIpEntry = pRCEContext->pIpEntry;

			AADEBUGP(AAD_EXTRA_LOUD,
				("Transmit: Dst 0x%x, RCE 0x%x, RCECntxt 0x%x, IPEntry 0x%x\n",
						Destination, pRCE, pRCEContext, pIpEntry));

			if (pIpEntry != NULL_PATMARP_IP_ENTRY)
			{
				AA_STRUCT_ASSERT(pIpEntry, aip);
				AA_RELEASE_IF_TABLE_LOCK(pInterface);

				AA_ACQUIRE_IE_LOCK(pIpEntry);
				AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

				if (IP_ADDR_EQUAL(pIpEntry->IPAddress, Destination))
				{
					//
					//  The Route Cache points to the right IP Entry.
					//  Either send this packet, or queue it, and get out.
					//

					//
					//  Check if this IP Address has been resolved to an ATM address,
					//  and is "clean" (not aged out).
					//
					if (AA_IS_FLAG_SET(
							pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK, 
							AA_IP_ENTRY_RESOLVED))
					{
						ULONG		AeRefCount;

						AA_ASSERT(pIpEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY);
						pAtmEntry = pIpEntry->pAtmEntry;

						AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);
						AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);// Temp ref: IfTransmit1
						AA_RELEASE_AE_LOCK_DPC(pAtmEntry);

#ifdef IPMCAST
						if (AA_IS_FLAG_SET(
								pIpEntry->Flags,
								AA_IP_ENTRY_MC_VALIDATE_MASK,
								AA_IP_ENTRY_MC_REVALIDATE))
						{
							AA_SET_FLAG(pIpEntry->Flags,
										AA_IP_ENTRY_MC_VALIDATE_MASK,
										AA_IP_ENTRY_MC_REVALIDATING);
							NeedMcRevalidation = TRUE;
						}
#endif // IPMCAST

						IsBroadcastAddress = AA_IS_FLAG_SET(pIpEntry->Flags,
															AA_IP_ENTRY_ADDR_TYPE_MASK,
															AA_IP_ENTRY_ADDR_TYPE_NUCAST);
						AA_RELEASE_IE_LOCK(pIpEntry);

						AA_ACQUIRE_AE_LOCK(pAtmEntry);
						Status = AtmArpSendPacketOnAtmEntry(
											pInterface,
											pAtmEntry,
											pNdisPacket,
											pFlowSpec,
											pFilterSpec,
											pFlowInfo,
											IsBroadcastAddress
											);
						//
						//  The ATM Entry lock is released within the above.
						//  Get rid of the temp ref:
						//
						AA_ACQUIRE_AE_LOCK(pAtmEntry);
						AeRefCount = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);// Temp ref: IfTransmit1
						if (AeRefCount != 0)
						{
							AA_RELEASE_AE_LOCK(pAtmEntry);
						}

						break;	// goto end of processing
					}
					else
					{
						//
						//  We don't have the ATM address yet, but we have an
						//  IP Entry for the Destination IP address. Queue this
						//  packet on the IP Entry, and start Address resolution
						//  if not already started.
						//
						//  But first, a check to avoid starting address resolution
						//  in a PVC-only environment.
						//
						if (pInterface->PVCOnly && (pIpEntry->pAtmEntry == NULL))
						{
							//
							//  This can happen if we had an active PVC and
							//  had learnt an IP address via InARP, and then
							//  the user had deleted the PVC. We would then be
							//  left with an IP entry, but no matching ATM entry.
							//  Abort this entry now.
							//
							AADEBUGP(AAD_FATAL,
								("IfTransmit (PVC 1): IPEntry %x, Ref %d, Flags %x has NULL ATM Entry\n",
									pIpEntry, pIpEntry->RefCount, pIpEntry->Flags));
				
				
							AtmArpAbortIPEntry(pIpEntry);
							//
							//  IP Entry lock is released above.
							//

							Status = NDIS_STATUS_SUCCESS;
							break;
						}

						Status = AtmArpQueuePacketOnIPEntry(
											pIpEntry,
											pNdisPacket
											);
						//
						//  The IP Entry lock is released within the above.
						//
						break;	// goto end of processing
					}
					// NOTREACHED
				}
				else
				{
					//
					//  The cache entry points to the wrong IP Entry. Invalidate
					//  the cache entry, and continue to the hard road.
					//
					AADEBUGP(AAD_INFO,
						("IfTransmit: RCE (0x%x) points to wrong IP Entry (0x%x: %d.%d.%d.%d)\n",
							pRCE,
							pIpEntry,
							((PUCHAR)(&(pIpEntry->IPAddress)))[0],
							((PUCHAR)(&(pIpEntry->IPAddress)))[1],
							((PUCHAR)(&(pIpEntry->IPAddress)))[2],
							((PUCHAR)(&(pIpEntry->IPAddress)))[3]
						));

					AADEBUGP(AAD_INFO,
						("RCE/IP Entry mismatch: Destn IP: %d.%d.%d.%d\n",
							((PUCHAR)&Destination)[0],
							((PUCHAR)&Destination)[1],
							((PUCHAR)&Destination)[2],
							((PUCHAR)&Destination)[3]
						));

					if (AtmArpUnlinkRCE(pRCE, pIpEntry))
					{
						ULONG		IeRefCount;	// Ref Count for IP Entry
	
						//
						//  The IP Entry did have this RCE in its list.
						//
						IeRefCount = AA_DEREF_IE(pIpEntry, IE_REFTYPE_RCE);	// RCE ref
						if (IeRefCount > 0)
						{
							AA_RELEASE_IE_LOCK(pIpEntry);
						}
						//  else the IP Entry is gone
					}
					else
					{
						//
						//  The IP Entry does not have this RCE in its list.
						//
						AA_RELEASE_IE_LOCK(pIpEntry);
					}

					//
					//  Continue processing below.
					//

				}	// else -- if (RCE points to the right IP Entry)
			}	// if (RCE points to non-NULL IP Entry)
			else
			{
				AA_RELEASE_IF_TABLE_LOCK(pInterface);
				//
				//  Continue processing below
				//
			}
		}

		AA_ACQUIRE_IF_LOCK(pInterface);
		IsBroadcastAddress = AtmArpIsBroadcastIPAddress(Destination, pInterface);
		AA_RELEASE_IF_LOCK(pInterface);

#if DHCP_OVER_ATM
		//
		//  Handle Broadcast packets separately.
		//
		if (IsBroadcastAddress)
		{
			Status = AtmArpSendBroadcast(
								pInterface,
								pNdisPacket,
								pFlowSpec,
								pFilterSpec
								);
			break;
		}
#endif // DHCP_OVER_ATM

#ifdef IPMCAST
		if (IsBroadcastAddress)
		{
			AAMCDEBUGP(AAD_EXTRA_LOUD,
				("IfTransmit: pIf 0x%x, to Broadcast addr: %d.%d.%d.%d\n",
						pInterface,
						((PUCHAR)&Destination)[0],
						((PUCHAR)&Destination)[1],
						((PUCHAR)&Destination)[2],
						((PUCHAR)&Destination)[3]));

			if (pInterface->MARSList.ListSize == 0)
			{
				//
				//  Drop this packet.
				//
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			//
			//  Make sure that we send all IP *broadcast* packets to
			//  the All 1's group.
			//
#ifdef MERGE_BROADCASTS
			Destination = pInterface->BroadcastAddress;
#else
			if (!CLASSD_ADDR(Destination))
			{
				Destination = pInterface->BroadcastAddress;
			}
#endif // MERGE_BROADCASTS
		}

#endif // IPMCAST

		//
		//  No Route Cache Entry: search for the IP Entry the hard way.
		//  NOTE: if we are running PVCs only, we won't create a new
		//  IP entry here: the only way a new IP Entry is created is
		//  when we learn the IP+ATM info of the station at the other
		//  end via InARP.
		//
		//  Note: AtmArpSearchForIPAddress addrefs pIpEntry.
		//
		CreateNewEntry = (pInterface->PVCOnly? FALSE: TRUE);

		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
		pIpEntry = AtmArpSearchForIPAddress(
								pInterface,
								&Destination,
								IE_REFTYPE_TMP,
								IsBroadcastAddress,
								CreateNewEntry
								);

		AA_RELEASE_IF_TABLE_LOCK(pInterface);

		if (pIpEntry == NULL_PATMARP_IP_ENTRY)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		
		AA_ACQUIRE_IE_LOCK(pIpEntry);
		AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

		if (pInterface->PVCOnly && (pIpEntry->pAtmEntry == NULL))
		{
			//
			//  This can happen if we had an active PVC and had learnt an IP address
			//  via InARP, and then the user had deleted the PVC. We would then be
			//  left with an IP entry, but no matching ATM entry. Abort this entry
			//  now.
			//
			AADEBUGP(AAD_FATAL,
				("IfTransmit (PVC 2): IPEntry %x, Ref %d, Flags %x has NULL ATM Entry\n",
					pIpEntry, pIpEntry->RefCount, pIpEntry->Flags));

			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP);

			if (rc != 0)
			{
				AtmArpAbortIPEntry(pIpEntry);
				//
				//  IE Lock is released above.
				//
			}

			Status = NDIS_STATUS_SUCCESS;
			break;
		}

		//
		//  Keep a pointer to this IP Entry in the Route Cache Entry
		//  to speed things up for the next packet.
		//
		if (pRCE != (RouteCacheEntry *)NULL)
		{
			AtmArpLinkRCE(pRCE, pIpEntry);
		}

		//
		// Note: AtmArpSerchForIPAddress addrefd pIpEntry for us -- we don't
		// deref it right now because it could be a new entry! Instead,
		// we deref it once we're done with it..
		//

		//
		//  Check if this IP Address has been resolved to an ATM address,
		//  and is "clean" (not aged out).
		//
		if (AA_IS_FLAG_SET(
				pIpEntry->Flags,
				AA_IP_ENTRY_STATE_MASK, 
				AA_IP_ENTRY_RESOLVED))
		{
			AA_ASSERT(pIpEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY);
			pAtmEntry = pIpEntry->pAtmEntry;

			AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);
			AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);// Temp ref: IfTransmit
			AA_RELEASE_AE_LOCK_DPC(pAtmEntry);

#ifdef IPMCAST
			if (AA_IS_FLAG_SET(
					pIpEntry->Flags,
					AA_IP_ENTRY_MC_VALIDATE_MASK,
					AA_IP_ENTRY_MC_REVALIDATE))
			{
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_MC_VALIDATE_MASK,
							AA_IP_ENTRY_MC_REVALIDATING);
				NeedMcRevalidation = TRUE;
			}
#endif // IPMCAST

			{
				//
				//  AtmArpSearchForIPAddress addref'd pIpEntry for us, so
				//	before heading out of here, we deref it...
				//
				ULONG IeRefCount = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP);
				if (IeRefCount > 0)
				{
					AA_RELEASE_IE_LOCK(pIpEntry);
				}
				else
				{
					//
					// It's gone ...
					//
					pIpEntry = NULL_PATMARP_IP_ENTRY;
					AA_ASSERT(!NeedMcRevalidation);
					NeedMcRevalidation = FALSE;		// just to be safe.
				}
			}

			AA_ACQUIRE_AE_LOCK(pAtmEntry);

			Status = AtmArpSendPacketOnAtmEntry(
								pInterface,
								pAtmEntry,
								pNdisPacket,
								pFlowSpec,
								pFilterSpec,
								pFlowInfo,
								IsBroadcastAddress
								);
			//
			//  The ATM Entry lock is released within the above. Get rid of the
			//  temp ref:
			//
			AA_ACQUIRE_AE_LOCK(pAtmEntry);
			if (AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP) != 0) // Temp ref: IfTransmit
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
			}
			break;
		}


		//
		//  We don't have the ATM address yet, but we have an
		//  IP Entry for the Destination IP address. Queue this
		//  packet on the IP Entry, and start Address resolution
		//  if not already started.
		//
		//	SearchForIPAddress addrefd pIpEntry for us. We don't simply
		//  deref it here because it could be a brand new entry, with
		//  refcount == 1. So instead we simply decrement the refcount. Note
		//  that we do hold the lock on it at this time.
		// 
		AA_ASSERT(pIpEntry->RefCount > 0);
		AA_DEREF_IE_NO_DELETE(pIpEntry, IE_REFTYPE_TMP);

		Status = AtmArpQueuePacketOnIPEntry(
							pIpEntry,
							pNdisPacket
							);
		//
		//  The IP Entry lock is released within the above.
		//
		break;
	}
	while (FALSE);

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

#ifdef IPMCAST
	if (NeedMcRevalidation)
	{
		AAMCDEBUGP(AAD_LOUD,
			("IfTransmit(MC): Revalidating pIpEntry 0x%x/0x%x, Addr %d.%d.%d.%d\n",
				pIpEntry, pIpEntry->Flags,
				((PUCHAR)&(pIpEntry->IPAddress))[0],
				((PUCHAR)&(pIpEntry->IPAddress))[1],
				((PUCHAR)&(pIpEntry->IPAddress))[2],
				((PUCHAR)&(pIpEntry->IPAddress))[3]));

		AtmArpMcSendRequest(
					pInterface,
					&Destination
					);
	}
#endif // IPMCAST

#ifdef PERF
	if ((Status != NDIS_STATUS_SUCCESS) && (Status != NDIS_STATUS_PENDING))
	{
		AadLogSendAbort(pNdisPacket);
	}
#endif // PERF

	if (Status != NDIS_STATUS_PENDING)
	{
		Status = NDIS_STATUS_SUCCESS;
	}

	return (Status);

}



NDIS_STATUS
AtmArpIfTransfer(
	IN	PVOID						Context,
	IN	NDIS_HANDLE					Context1,
	IN	UINT						ArpHdrOffset,
	IN	UINT						ProtoOffset,
	IN	UINT						BytesWanted,
	IN	PNDIS_PACKET				pNdisPacket,
	OUT	PUINT						pTransferCount
)
/*++

Routine Description:

	This routine is called from the IP layer in order to copy in the
	contents of a received packet that we indicated up earlier. The
	context we had passed up in the receive indication is given back to
	us, so that we can identify what it was that we passed up.

	We simply call NDIS to do the transfer.

Arguments:

	Context				- Actually a pointer to our Interface structure
	Context1			- Packet context we had passed up (pointer to NDIS packet)
	ArpHdrOffset		- Offset we had passed up in the receive indicate
	ProtoOffset			- The offset into higher layer protocol data to start copy from
	BytesWanted			- The amount of data to be copied
	pNdisPacket			- The packet to be copied into
	pTransferCount		- Where we return the actual #bytes copied

Return Value:

	NDIS_STATUS_SUCCESS always.

--*/
{

	AADEBUGP(AAD_EXTRA_LOUD,
	 ("IfTransfer: Ctx 0x%x, Ctx1 0x%x, HdrOff %d, ProtOff %d, Wanted %d, Pkt 0x%x\n",
			Context,
			Context1,
			ArpHdrOffset,
			ProtoOffset,
			BytesWanted,
			pNdisPacket));

	NdisCopyFromPacketToPacket(
			pNdisPacket,
			0,
			BytesWanted,
			(PNDIS_PACKET)Context1,
			ArpHdrOffset+ProtoOffset,
			pTransferCount
			);

	return (NDIS_STATUS_SUCCESS);
}



VOID
AtmArpIfInvalidate(
	IN	PVOID						Context,
	IN	RouteCacheEntry *			pRCE
)
/*++

Routine Description:

	This routine is called from the IP layer to invalidate a Route Cache
	Entry. If this RCE is associated with one of our IP Entries, unlink
	it from the list of RCE's pointing to that IP entry.

Arguments:

	Context				- Actually a pointer to our Interface structure
	pRCE				- Pointer to Route Cache Entry being invalidated.

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PATMARP_IP_ENTRY		pIpEntry;
	PATMARP_RCE_CONTEXT		pRCEContext;
	ULONG					rc;			// Ref Count for IP Entry
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	AA_ASSERT(pRCE != (RouteCacheEntry *)NULL);

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

	pRCEContext = (PATMARP_RCE_CONTEXT)(&(pRCE->rce_context[0]));

	//
	//  Get the ATMARP IP Entry associated with this RCE.
	//
	pIpEntry = (PATMARP_IP_ENTRY)pRCEContext->pIpEntry;

	if (pIpEntry != NULL_PATMARP_IP_ENTRY)
	{
		AADEBUGP(AAD_LOUD, ("IfInvalidate: pIf 0x%x, pRCE 0x%x, pIpEntry 0x%x\n",
			pInterface, pRCE, pIpEntry));

		AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);

		if (AtmArpUnlinkRCE(pRCE, pIpEntry))
		{
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_RCE); // RCE
			if (rc > 0)
			{
				AA_RELEASE_IE_LOCK_DPC(pIpEntry);
			}
			//
			//  else the IP Entry is gone.
			//
		}
		else
		{
			AA_RELEASE_IE_LOCK_DPC(pIpEntry);
		}
	}

	AA_SET_MEM((PUCHAR)(&(pRCE->rce_context[0])), 0, RCE_CONTEXT_SIZE);

	AA_RELEASE_IF_TABLE_LOCK(pInterface);

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return;
}




BOOLEAN
AtmArpUnlinkRCE(
	IN	RouteCacheEntry *			pRCE,
	IN	PATMARP_IP_ENTRY			pIpEntry
)
/*++

Routine Description:

	Unlink an RCE from the list of RCE's associated with an IP Entry.
	It is assumed that the caller holds locks to the IF Table and
	to the IP Entry.

Arguments:

	pRCE					- RCE to be unlinked.
	pIpEntry				- ATMARP IP Entry from which the RCE is to be
							  removed.

Return Value:

	TRUE if the RCE was indeed in the list for the IP Entry, FALSE
	otherwise.

--*/
{
	BOOLEAN					Found;	// Did we find the RCE?
	RouteCacheEntry **		ppRCE;	// Used for walking the list of RCEs
	PATMARP_RCE_CONTEXT		pRCEContext;

	//
	//  Initialize
	//
	Found = FALSE;

	//
	//  Go down the list of RCEs attached to this IP Entry, and
	//  find this RCE's position. We remember a pointer to the
	//  place that keeps the address of this RCE (i.e. ppRCE),
	//  so that we can remove this RCE from the list quickly.
	//
	ppRCE = &(pIpEntry->pRCEList);
	
	if (pIpEntry->pRCEList != NULL)
	{		
		while (*ppRCE != pRCE)
		{
			pRCEContext = (PATMARP_RCE_CONTEXT)(&((*ppRCE)->rce_context[0]));

			if (pRCEContext->pNextRCE == (RouteCacheEntry *)NULL)
			{
				//
				//  Allow for the RCE to be absent in the list?
				//
				AA_ASSERT(FALSE);	// REMOVELATER
				break;
			}
			else
			{
				//
				//  Walk down the list.
				//
				ppRCE = &(pRCEContext->pNextRCE);
			}
		}
	}

	if (*ppRCE == pRCE)
	{
		//
		//  We found it. Make the predecessor point to the successor.
		//
		pRCEContext = (PATMARP_RCE_CONTEXT)(&(pRCE->rce_context[0]));
		*ppRCE = pRCEContext->pNextRCE;
		pRCEContext->pIpEntry = NULL_PATMARP_IP_ENTRY;
		Found = TRUE;
	}

	return (Found);

}


VOID
AtmArpLinkRCE(
	IN	RouteCacheEntry *			pRCE,
	IN	PATMARP_IP_ENTRY			pIpEntry	LOCKIN LOCKOUT
)
/*++

Routine Description:

	Link an RCE to an IP Entry's list of RCEs. Check if the RCE is already
	present - if so, ignore this.

	The caller is assumed to hold a lock to the IP Entry.

Arguments:

	pRCE					- RCE to be linked.
	pIpEntry				- ATMARP IP Entry to which the RCE is to be
							  linked.

Return Value:

	None

--*/
{
	RouteCacheEntry **		ppRCE;	// Used for walking the list of RCEs
	PATMARP_RCE_CONTEXT		pRCEContext;

	ppRCE = &(pIpEntry->pRCEList);

	//
	//  Check if the RCE is already present.
	//
	while (*ppRCE != NULL)
	{
		if (*ppRCE == pRCE)
		{
			//
			//  Found it.
			//
			break;
		}

		//
		//  Move to the next.
		//
		pRCEContext = (PATMARP_RCE_CONTEXT)(&((*ppRCE)->rce_context[0]));
		ppRCE = &(pRCEContext->pNextRCE);
	}


	if (*ppRCE == NULL)
	{
		//
		//  This RCE is not present in the IP Entry's list. Add it.
		//
		pRCEContext = (PATMARP_RCE_CONTEXT)&(pRCE->rce_context[0]);
		pRCEContext->pIpEntry = pIpEntry;
		pRCEContext->pNextRCE = pIpEntry->pRCEList;
		pIpEntry->pRCEList = pRCE;

		AA_REF_IE(pIpEntry, IE_REFTYPE_RCE);	// RCE ref
	}
	else
	{
		AADEBUGP(AAD_LOUD, ("AtmArpLinkRCE: RCE 0x%x already linked to IP Entry 0x%x\n",
								pRCE, pIpEntry));
	}
}




INT
AtmArpIfQueryInfo(
	IN		PVOID					Context,
	IN		TDIObjectID *			pID,
	IN		PNDIS_BUFFER			pNdisBuffer,
	IN OUT	PUINT					pBufferSize,
	IN		PVOID					QueryContext
)
/*++

Routine Description:

	This is called from the IP layer to query for statistics or other
	information about an interface.

Arguments:

	Context					- Actually a pointer to our ATMARP Interface
	pID						- Describes the object being queried
	pNdisBuffer				- Space for returning information
	pBufferSize				- Pointer to size of above. On return, we fill
							  it with the actual bytes copied.
	QueryContext			- Context value pertaining to the query.

Return Value:

	TDI Status code.

--*/
{
	PATMARP_INTERFACE		pInterface;
	UINT					EntityType;
	UINT					Instance;
	UINT					BufferSize;
	UINT					ByteOffset;
	UINT					BytesCopied;
	INT						ReturnStatus;
	BOOLEAN					DataLeft;
	BOOLEAN					ContextValid;

	UCHAR					InfoBuff[sizeof(IFEntry)];	// Temp space for return value
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
	ULONG					OldDebugLevel;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	EntityType = pID->toi_entity.tei_entity;
	Instance = pID->toi_entity.tei_instance;
	BufferSize = *pBufferSize;

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

#if DBG
	OldDebugLevel = AaDebugLevel;
#endif

	AADEBUGP(AAD_LOUD,
		("IfQueryInfo: pIf 0x%x, pID 0x%x, pBuf 0x%x, Size %d, Ent %d, Inst %d\n",
			pInterface, pID, pNdisBuffer, BufferSize, EntityType, Instance));

	//
	//  Initialize
	//
	ByteOffset = 0;
	ReturnStatus = TDI_INVALID_PARAMETER;

	do
	{
		if (pInterface->AdminState == IF_STATUS_DOWN)
		{
			ReturnStatus = TDI_INVALID_REQUEST;
			break;
		}

		//
		//  Check the Entity and Instance values.
		//
		if ((EntityType != AT_ENTITY || Instance != pInterface->ATInstance) &&
			(EntityType != IF_ENTITY || Instance != pInterface->IFInstance))
		{
			AADEBUGP(AAD_VERY_LOUD,
				("Mismatch: Entity %d, AT_ENTITY %d, Inst %d, IF AT Inst %d, IF_ENTITY %d, IF IF Inst %d\n",
					EntityType,
					AT_ENTITY,
					Instance,
					pInterface->ATInstance,
					IF_ENTITY,
					pInterface->IFInstance
				));

#if DBG_QRY
			if (!AaIgnoreInstance)
			{
				ReturnStatus = TDI_INVALID_REQUEST;
				break;
			}
#else
#ifndef ATMARP_WIN98
			ReturnStatus = TDI_INVALID_REQUEST;
			break;
#endif // !ATMARP_WIN98
#endif // DBG_QRY
		}

		AADEBUGP(AAD_LOUD, ("QueryInfo: pID 0x%x, toi_type %d, toi_class %d, toi_id %d\n",
			pID, pID->toi_type, pID->toi_class, pID->toi_id));

		*pBufferSize = 0;

		if (pID->toi_type != INFO_TYPE_PROVIDER)
		{
			AADEBUGP(AAD_VERY_LOUD, ("toi_type %d != PROVIDER (%d)\n",
					pID->toi_type,
					INFO_TYPE_PROVIDER));

			ReturnStatus = TDI_INVALID_PARAMETER;
			break;
		}

		if (pID->toi_class == INFO_CLASS_GENERIC)
		{
			if (pID->toi_id == ENTITY_TYPE_ID)
			{
				if (BufferSize >= sizeof(UINT))
				{
					AADEBUGP(AAD_VERY_LOUD,
						("INFO GENERIC, ENTITY TYPE, BufferSize %d\n", BufferSize));

					*((PUINT)&(InfoBuff[0])) = ((EntityType == AT_ENTITY) ? AT_ARP: IF_MIB);
					if (AtmArpCopyToNdisBuffer(
							pNdisBuffer,
							InfoBuff,
							sizeof(UINT),
							&ByteOffset) != NULL)
					{

//						*pBufferSize = sizeof(UINT);
						ReturnStatus = TDI_SUCCESS;
					}
					else
					{
						ReturnStatus = TDI_NO_RESOURCES;
					}
				}
				else
				{
					ReturnStatus = TDI_BUFFER_TOO_SMALL;
				}
			}
			else
			{
				ReturnStatus = TDI_INVALID_PARAMETER;
			}

			break;
		}

		if (EntityType == AT_ENTITY)
		{
			//
			//  This query is for an Address Translation Object.
			//
			if (pID->toi_id == AT_MIB_ADDRXLAT_INFO_ID)
			{
				//
				//  Request for the number of entries in the address translation
				//  table, and the IF index.
				//
				AddrXlatInfo            *pAXI;

				AADEBUGP(AAD_VERY_LOUD, ("QueryInfo: AT Entity, for IF index, ATE size\n"));

				if (BufferSize >= sizeof(AddrXlatInfo))
				{
					*pBufferSize = sizeof(AddrXlatInfo);

					pAXI = (AddrXlatInfo *)InfoBuff;
					pAXI->axi_count = pInterface->NumOfArpEntries;
					pAXI->axi_index = pInterface->IFIndex;

					if (AtmArpCopyToNdisBuffer(
							pNdisBuffer,
							InfoBuff,
							sizeof(AddrXlatInfo),
							&ByteOffset) != NULL)
					{
						ReturnStatus = TDI_SUCCESS;
					}
					else
					{
						ReturnStatus = TDI_NO_RESOURCES;
					}
				}
				else
				{
					ReturnStatus = TDI_BUFFER_TOO_SMALL;
				}
				break;
			}

			if (pID->toi_id == AT_MIB_ADDRXLAT_ENTRY_ID)
			{
				//
				//  Request for reading the address translation table.
				//
				AADEBUGP(AAD_VERY_LOUD, ("QueryInfo: AT Entity, for reading ATE\n"));

				AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
				DataLeft = AtmArpValidateTableContext(
									QueryContext,
									pInterface,
									&ContextValid
									);
				if (!ContextValid)
				{
					AA_RELEASE_IF_TABLE_LOCK(pInterface);
					ReturnStatus = TDI_INVALID_PARAMETER;
					break;
				}

				BytesCopied = 0;
				ReturnStatus = TDI_SUCCESS;
				while (DataLeft)
				{
					if ((INT)BufferSize - (INT)BytesCopied >=
							sizeof(IPNetToMediaEntry))
					{
						//
						//  Space left in output buffer.
						//
						DataLeft = AtmArpReadNextTableEntry(
										QueryContext,
										pInterface,
										InfoBuff
										);

						BytesCopied += sizeof(IPNetToMediaEntry);
						pNdisBuffer = AtmArpCopyToNdisBuffer(
										pNdisBuffer,
										InfoBuff,
										sizeof(IPNetToMediaEntry),
										&ByteOffset
										);

						if (pNdisBuffer == NULL)
						{
							BytesCopied = 0;
							ReturnStatus = TDI_NO_RESOURCES;
							break;
						}
					}
					else
					{
						break;
					}
				}

				AA_RELEASE_IF_TABLE_LOCK(pInterface);

				*pBufferSize = BytesCopied;

				if (ReturnStatus == TDI_SUCCESS)
				{
					ReturnStatus = (!DataLeft? TDI_SUCCESS : TDI_BUFFER_OVERFLOW);
				}

				break;
			}

			ReturnStatus = TDI_INVALID_PARAMETER;
			break;
		}

		if (pID->toi_class != INFO_CLASS_PROTOCOL)
		{
			ReturnStatus = TDI_INVALID_PARAMETER;
			break;
		}

		if (pID->toi_id == IF_MIB_STATS_ID)
		{
			//
			//  Request for Interface level statistics.
			//
			IFEntry			*pIFEntry = (IFEntry *)InfoBuff;

			AADEBUGP(AAD_VERY_LOUD, ("QueryInfo: MIB statistics\n"));

			//
			//  Check if we have enough space.
			//
			if (BufferSize < IFE_FIXED_SIZE)
			{
				ReturnStatus = TDI_BUFFER_TOO_SMALL;
				break;
			}

			pIFEntry->if_index = pInterface->IFIndex;
			pIFEntry->if_mtu = pInterface->MTU;
			pIFEntry->if_type = IF_TYPE_OTHER;
			pIFEntry->if_speed = pInterface->Speed;
			pIFEntry->if_adminstatus = pInterface->AdminState;
			if (pInterface->State == IF_STATUS_UP)
			{
				pIFEntry->if_operstatus = IF_OPER_STATUS_OPERATIONAL;
			}
			else
			{
				pIFEntry->if_operstatus = IF_OPER_STATUS_NON_OPERATIONAL;
			}
			pIFEntry->if_lastchange = pInterface->LastChangeTime;
			pIFEntry->if_inoctets = pInterface->InOctets;
			pIFEntry->if_inucastpkts = pInterface->InUnicastPkts;
			pIFEntry->if_innucastpkts = pInterface->InNonUnicastPkts;
			pIFEntry->if_indiscards = pInterface->InDiscards;
			pIFEntry->if_inerrors = pInterface->InErrors;
			pIFEntry->if_inunknownprotos = pInterface->UnknownProtos;
			pIFEntry->if_outoctets = pInterface->OutOctets;
			pIFEntry->if_outucastpkts = pInterface->OutUnicastPkts;
			pIFEntry->if_outnucastpkts = pInterface->OutNonUnicastPkts;
			pIFEntry->if_outdiscards = pInterface->OutDiscards;
			pIFEntry->if_outerrors = pInterface->OutErrors;
			pIFEntry->if_outqlen = 0;
			pIFEntry->if_descrlen = pInterface->pAdapter->DescrLength;

#ifndef ATMARP_WIN98
			pIFEntry->if_physaddrlen = AA_ATM_PHYSADDR_LEN;
			AA_COPY_MEM(
					pIFEntry->if_physaddr,
					&(pInterface->pAdapter->MacAddress[0]),
					AA_ATM_ESI_LEN
					);
			pIFEntry->if_physaddr[AA_ATM_PHYSADDR_LEN-1] = (UCHAR)pInterface->SapSelector;
#else
			//
			//  Win98: winipcfg doesn't like 7 byte long physical address.
			//
			pIFEntry->if_physaddrlen = AA_ATM_ESI_LEN;
			AA_COPY_MEM(
					pIFEntry->if_physaddr,
					&(pInterface->pAdapter->MacAddress[0]),
					AA_ATM_ESI_LEN
					);

			//
			// Since w're only reporting 6 bytes, we need to make the reported
			// MAC address look different from what LANE reports (LANE reports
			// the MAC address). So we simply put the special value 0x0a 0xac
			// (for aac, or "atm arp client") in the 1st USHORTS.
			//
			pIFEntry->if_physaddr[0] = 0x0a;
			pIFEntry->if_physaddr[1] = 0xac;
#endif

			if (AtmArpCopyToNdisBuffer(
					pNdisBuffer,
					InfoBuff,
					IFE_FIXED_SIZE,
					&ByteOffset) == NULL)
			{
				*pBufferSize = 0;
				ReturnStatus = TDI_NO_RESOURCES;
				break;
			}

			if (BufferSize >= (IFE_FIXED_SIZE + pIFEntry->if_descrlen))
			{
				*pBufferSize = IFE_FIXED_SIZE + pIFEntry->if_descrlen;
				ReturnStatus = TDI_SUCCESS;

				if (pIFEntry->if_descrlen != 0)
				{
					if (AtmArpCopyToNdisBuffer(
							pNdisBuffer,
							pInterface->pAdapter->pDescrString,
							pIFEntry->if_descrlen,
							&ByteOffset) == NULL)
					{
						// Failed to copy descr string
						*pBufferSize = IFE_FIXED_SIZE;
						ReturnStatus = TDI_NO_RESOURCES;
					}
				}
			}
			else
			{
				*pBufferSize = IFE_FIXED_SIZE;
				ReturnStatus = TDI_BUFFER_OVERFLOW;
			}
			break;
		}
	}
	while (FALSE);

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	AADEBUGP(AAD_LOUD, ("QueryInfo: returning 0x%x (%s), BufferSize %d\n",
					ReturnStatus,
					((ReturnStatus == TDI_SUCCESS)? "SUCCESS": "FAILURE"),
					*pBufferSize
			));

#if DBG
	AaDebugLevel = OldDebugLevel;
#endif
	return (ReturnStatus);

}


INT
AtmArpIfSetInfo(
	IN		PVOID					Context,
	IN		TDIObjectID *			pID,
	IN		PVOID					pBuffer,
	IN		UINT					BufferSize
)
/*++

Routine Description:

	This is called from the IP layer to set the value of an object
	for an interface.

Arguments:
	Context					- Actually a pointer to our ATMARP Interface
	pID						- Describes the object being set
	pBuffer					- Value for the object
	BufferSize				- Size of above

Return Value:

	TDI Status code.

--*/
{
	AADEBUGP(AAD_ERROR, ("IfSetInfo: pIf 0x%x, Will return failure!\n",
					Context));

	return (TDI_INVALID_REQUEST);	// TBD: support Sets.
}



INT
AtmArpIfGetEList(
	IN		PVOID					Context,
	IN		TDIEntityID *			pEntityList,
	IN OUT	PUINT					pEntityListSize
)
/*++

Routine Description:

	This routine is called when the interface starts up, in order to
	assign all relevant Entity Instance numbers for an interface.
	The ATMARP module belongs to the "AT" and "IF" types. The entity
	list is a list of <Entity type, Instance number> tuples that have
	been filled in by other modules.

	For each of the entity types we support, we find the largest
	instance number in use (by walking thru the Entity list), and
	assign to ourselves the next larger number in each case. Using
	these numbers, we append our tuples to the end of the Entity list,
	if there is enough space.

	NT 5: we may find that our entries are already present, in which
	case we don't create new entries.

	It is assumed that this isn't reentered. If this assumption is
	false, we should acquire our Interface lock in here.

Arguments:

	Context					- Actually a pointer to our ATMARP Interface
	pEntityList				- Pointer to TDI Entity list
	pEntityListSize			- Pointer to length of above list. We update
							  this if we add our entries to the list.

Return Value:

	TRUE if successful, FALSE otherwise.

--*/
{
	PATMARP_INTERFACE	pInterface;
	UINT				EntityCount;	// Total elements in Entity list
	UINT				i;				// Iteration counter
	UINT				MyATInstance;	// "AT" Instance number we assign to ourselves
	UINT				MyIFInstance;	// "IF" Instance number we assign to ourselves
	INT					ReturnValue;
	TDIEntityID *		pATEntity;		// Points to our AT entry
	TDIEntityID *		pIFEntity;		// Points to our IF entry

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	EntityCount = *pEntityListSize;
	pATEntity = NULL;
	pIFEntity = NULL;
	MyATInstance = MyIFInstance = 0;

	AADEBUGP(AAD_INFO, ("IfGetEList: pIf 0x%x, pList 0x%x, Cnt %d\n",
			pInterface, pEntityList, EntityCount));

	do
	{
#ifdef OLD_ENTITY_LIST
		//
		//  We need space for 2 entries; see if this is available.
		//
		if (EntityCount + 2 > MAX_TDI_ENTITIES)
		{
			ReturnValue = FALSE;
			break;
		}

		//
		//  Search for the max used-up instance numbers for the "AT"
		//  and "IF" types.
		//
		MyATInstance = MyIFInstance = 0;
		for (i = 0; i < EntityCount; i++, pEntityList++)
		{
			if (pEntityList->tei_entity == AT_ENTITY)
			{
				MyATInstance = MAX(MyATInstance, pEntityList->tei_instance + 1);
			}
			else if (pEntityList->tei_entity == IF_ENTITY)
			{
				MyIFInstance = MAX(MyIFInstance, pEntityList->tei_instance + 1);
			}
		}

		//
		//  Save our instance numbers for later use.
		//
		pInterface->ATInstance = MyATInstance;
		pInterface->IFInstance = MyIFInstance;

		//
		//  Append our AT and IF entries to the Entity list.
		//  Recall that we just traversed the list fully, so we
		//  are pointing to the right place to add entries.
		//
		pEntityList->tei_entity = AT_ENTITY;
		pEntityList->tei_instance = MyATInstance;
		pEntityList++;
		pEntityList->tei_entity = IF_ENTITY;
		pEntityList->tei_instance = MyIFInstance;

		//
		//  Return the new list size.
		//
		*pEntityListSize += 2;

		ReturnValue = TRUE;
#else


		//
		//  Walk down the list, looking for AT/IF entries matching our
		//  instance values. Also remember the largest AT and IF instance
		//  values we see, so that we can allocate the next larger values
		//  for ourselves, in case we don't have instance values assigned.
		//
		for (i = 0; i < EntityCount; i++, pEntityList++)
		{
			//
			//  Skip invalid entries.
			//
			if (pEntityList->tei_instance == INVALID_ENTITY_INSTANCE)
			{
				continue;
			}

			if (pEntityList->tei_entity == AT_ENTITY)
			{
				if (pEntityList->tei_instance == pInterface->ATInstance)
				{
					//
					//  This is our AT entry.
					//
					pATEntity = pEntityList;
				}
				else
				{
					MyATInstance = MAX(MyATInstance, pEntityList->tei_instance + 1);
				}
			}
			else if (pEntityList->tei_entity == IF_ENTITY)
			{
				if (pEntityList->tei_instance == pInterface->IFInstance)
				{
					//
					//  This is our IF entry.
					//
					pIFEntity = pEntityList;
				}
				else
				{
					MyIFInstance = MAX(MyIFInstance, pEntityList->tei_instance + 1);
				}
			}
		}


		ReturnValue = TRUE;

		//
		//  Update or create our Address Translation entry.
		//
		if (pATEntity)
		{
			//
			//  We found our entry.
			//
			if (pInterface->AdminState == IF_STATUS_DOWN)
			{
				pATEntity->tei_instance = INVALID_ENTITY_INSTANCE;
			}
		}
		else
		{
			//
			//  Grab an entry for ourselves, unless we are shutting down.
			//
			if (pInterface->AdminState == IF_STATUS_DOWN)
			{
				break;
			}

			if (EntityCount >= MAX_TDI_ENTITIES)
			{
				ReturnValue = FALSE;
				break;
			}

			pEntityList->tei_entity = AT_ENTITY;
			pEntityList->tei_instance = MyATInstance;
			pInterface->ATInstance = MyATInstance;

			pEntityList++;
			(*pEntityListSize)++;
			EntityCount++;
		}

		//
		//  Update or create or IF entry.
		//
		if (pIFEntity)
		{
			//
			//  We found our entry.
			//
			if (pInterface->AdminState == IF_STATUS_DOWN)
			{
				pIFEntity->tei_instance = INVALID_ENTITY_INSTANCE;
			}
		}
		else
		{
			//
			//  Grab an entry for ourselves, unless we are shutting down.
			//
			if (pInterface->AdminState == IF_STATUS_DOWN)
			{
				break;
			}

			if (EntityCount >= MAX_TDI_ENTITIES)
			{
				ReturnValue = FALSE;
				break;
			}

			pEntityList->tei_entity = IF_ENTITY;
			pEntityList->tei_instance = MyIFInstance;
			pInterface->IFInstance = MyIFInstance;

			pEntityList++;
			(*pEntityListSize)++;
			EntityCount++;
		}
#endif // OLD_ENTITY_LIST
	}
	while (FALSE);


	AADEBUGP(AAD_INFO,
	 ("IfGetEList: returning %d, MyAT %d, MyIF %d, pList 0x%x, Size %d\n",
		ReturnValue, MyATInstance, MyIFInstance, pEntityList, *pEntityListSize));

	return (ReturnValue);
}



#ifdef _PNP_POWER_

VOID
AtmArpIfPnPComplete(
	IN	PVOID						Context,
	IN	NDIS_STATUS					Status,
	IN	PNET_PNP_EVENT				pNetPnPEvent
)
/*++

Routine Description:

	This routine is called by IP when it completes a previous call
	we made to its PnP event handler.

	If this is the last Interface on the adapter, we complete the
	NDIS PNP notification that lead to this. Otherwise, we indicate
	this same event to IP on the next Interface on the adapter.

Arguments:

	Context					- Actually a pointer to our ATMARP Interface
	Status					- Completion status from IP
	pNetPnPEvent			- The PNP event

Return Value:

	None

--*/
{
	PATMARP_INTERFACE			pInterface;

	pInterface = (PATMARP_INTERFACE)Context;

	AADEBUGP(AAD_INFO,
			("IfPnPComplete: IF 0x%x, Status 0x%x, Event 0x%x\n",
					pInterface, Status, pNetPnPEvent));

	if (pInterface != NULL_PATMARP_INTERFACE)
	{
		AA_STRUCT_ASSERT(pInterface, aai);
		if (pInterface->pNextInterface == NULL_PATMARP_INTERFACE)
		{
			NdisCompletePnPEvent(
					Status,
					pInterface->pAdapter->NdisAdapterHandle,
					pNetPnPEvent
					);
		}
		else
		{
			pInterface = pInterface->pNextInterface;
	
			(*pInterface->IPPnPEventHandler)(
					pInterface->IPContext,
					pNetPnPEvent
					);
		}
	}
	else
	{
		NdisCompletePnPEvent(
					Status,
					NULL,
					pNetPnPEvent
					);
	}

	return;
}

#endif // _PNP_POWER_


#ifdef PROMIS
EXTERN
NDIS_STATUS
AtmArpIfSetNdisRequest(
	IN	PVOID						Context,
	IN	NDIS_OID					Oid,
	IN	UINT						On
)
/*++

Routine Description:

    ARP Ndisrequest handler.
    Called by the upper driver to set the packet filter for the interface.

Arguments:

       Context     - Actually a pointer to our ATMARP Interface
       OID         - Object ID to set/unset
       On          - Set_if, clear_if or clear_card

Return Value:

	Status

--*/
{
    NDIS_STATUS         Status	    = NDIS_STATUS_SUCCESS;
	PATMARP_INTERFACE	pInterface  =  (PATMARP_INTERFACE)Context;

    AADEBUGP(AAD_INFO,("IfSetNdisRequest: pIF =0x%x; Oid=0x%x; On=%u\n",
                pInterface,
                Oid,
                On
                ));

    do
    {
        //
        //  We set IPAddress and mask to span the entire mcast address range...
        //
	    IP_ADDRESS					IPAddress	= IP_CLASSD_MIN; 
	    IP_MASK						Mask		= IP_CLASSD_MASK;
	    UINT						ReturnStatus = TRUE;
		NDIS_OID					PrevOidValue;

        if (Oid != NDIS_PACKET_TYPE_ALL_MULTICAST)
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        AA_STRUCT_ASSERT(pInterface, aai);
        AA_ACQUIRE_IF_LOCK(pInterface);

		PrevOidValue = pInterface->EnabledIPFilters & NDIS_PACKET_TYPE_ALL_MULTICAST;

        if (On)
        {
        	if (PrevOidValue == 0)
        	{
        		pInterface->EnabledIPFilters |= NDIS_PACKET_TYPE_ALL_MULTICAST;

		    	ReturnStatus = AtmArpMcAddAddress(pInterface, IPAddress, Mask);
				//
				// IF lock released above
				//
			}
			else
			{
            	AA_RELEASE_IF_LOCK(pInterface);
			}
        }
        else
        {
        	if (PrevOidValue != 0)
        	{
        		pInterface->EnabledIPFilters &= ~NDIS_PACKET_TYPE_ALL_MULTICAST;

            	ReturnStatus = AtmArpMcDelAddress(pInterface, IPAddress, Mask);
				//
				// IF lock released above
				//
			}
			else
			{
            	AA_RELEASE_IF_LOCK(pInterface);
			}
        }

        if (ReturnStatus != TRUE)
        {
        	//
        	// We've got to restore EnabledIPFilters to it's original value.
        	//
        	AA_ACQUIRE_IF_LOCK(pInterface);
			pInterface->EnabledIPFilters &= ~NDIS_PACKET_TYPE_ALL_MULTICAST;
			pInterface->EnabledIPFilters |= PrevOidValue;
            AA_RELEASE_IF_LOCK(pInterface);

            
			Status = NDIS_STATUS_FAILURE;
        }

    }
    while (FALSE);

    AADEBUGP(AAD_INFO, ("IfSetNdisRequest(pIF =0x%x) returns 0x%x\n",
            pInterface,
            Status
            ));

    return Status;
}
#endif // PROMIS


PNDIS_BUFFER		AtmArpFreeingBuffer = NULL;
PNDIS_PACKET		AtmArpFreeingPacket = NULL;
AA_HEADER_TYPE		AtmArpFreeingHdrType = 0;

VOID
AtmArpFreeSendPackets(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				PacketList,
	IN	BOOLEAN						HdrPresent
)
/*++

Routine Description:

	Free a list of packets that were queued to be sent, but have been
	"aborted". Each packet in this list is one of the following types:
	(a) Belonging to IP (b) Belonging to the ATMARP module. In the case
	of an IP packet, HdrPresent tells us whether or not we had prepended
	an LLC/SNAP header to this packet, and its type: we need this information
	because we need to reclaim such headers.

	Also, in the case of IP packets, we call IP's Transmit Complete up-call,
	to inform IP of a failed transmission.

Arguments:

	pInterface			- Pointer to ATMARP Interface on which these
						  packets would have been sent.
	PacketList			- Pointer to first packet in a list.
	HdrPresent			- Is an LLC/SNAP header present

Return Value:

	None

--*/
{
	PNDIS_PACKET		pNdisPacket;
	PNDIS_PACKET		pNextPacket;
	PNDIS_BUFFER		pNdisBuffer;
	ULONG				NumberOfDiscards;
	PacketContext		*PC;
	AA_HEADER_TYPE		HdrType;

	NumberOfDiscards = 0;

	pNdisPacket = PacketList;

	while (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		NumberOfDiscards++;
		pNextPacket = AA_GET_NEXT_PACKET(pNdisPacket);
		AA_SET_NEXT_PACKET(pNdisPacket, NULL);

		PC = (PacketContext *)pNdisPacket->ProtocolReserved;
		if (PC->pc_common.pc_owner != PACKET_OWNER_LINK)
		{
			//
			//  Belongs to IP.
			//
			if (HdrPresent)
			{
				PUCHAR			pData;
				UINT			Length;

#ifdef BACK_FILL
				NdisQueryPacket(pNdisPacket, NULL, NULL, &pNdisBuffer, NULL);
				AA_ASSERT(pNdisBuffer != NULL);

				NdisQueryBuffer(pNdisBuffer, &pData, &Length);

				if (pData[5] == LLC_SNAP_OUI2)
				{
					HdrType = AA_HEADER_TYPE_UNICAST;
				}
				else
				{
					HdrType = AA_HEADER_TYPE_NUNICAST;
				}

				//
				//  Now check if we had attached a header buffer or not.
				//
				if (AtmArpDoBackFill && AA_BACK_FILL_POSSIBLE(pNdisBuffer))
				{
					ULONG		HeaderLength;

					AADEBUGP(AAD_VERY_LOUD,
					    ("FreeSendPackets: IF %x, Pkt %x Buf %x has been backfilled\n",
					        pInterface, pNdisPacket, pNdisBuffer));

					//
					//  We would have back-filled IP's buffer with the LLC/SNAP
					//  header. Remove the back-fill.
					//
					HeaderLength = ((HdrType == AA_HEADER_TYPE_UNICAST)?
										sizeof(AtmArpLlcSnapHeader) :
#ifdef IPMCAST
										sizeof(AtmArpMcType1ShortHeader));
#else
										0);
#endif // IPMCAST
					(PUCHAR)pNdisBuffer->MappedSystemVa += HeaderLength;
					pNdisBuffer->ByteOffset += HeaderLength;
					pNdisBuffer->ByteCount -= HeaderLength;
				}
				else
				{
					//
					//  The first buffer would be our header buffer. Remove
					//  it from the packet and return to our pool.
					//
					NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);

					AtmArpFreeingBuffer = pNdisBuffer; // to help debugging
					AtmArpFreeingPacket = pNdisPacket; // to help debugging
					AtmArpFreeingHdrType = HdrType;

					AtmArpFreeHeader(pInterface, pNdisBuffer, HdrType);
				}
#else	// BACK_FILL

				//
				//  Free the LLC/SNAP header buffer.
				//
				NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
				AA_ASSERT(pNdisBuffer != NULL);
				NdisQueryBuffer(pNdisBuffer, &pData, &Length);
				if (pData[5] == LLC_SNAP_OUI2)
				{
					HdrType = AA_HEADER_TYPE_UNICAST;
				}
				else
				{
					AA_ASSERT(pData[5] == MC_LLC_SNAP_OUI2);
					HdrType = AA_HEADER_TYPE_NUNICAST;
				}

				AtmArpFreeHeader(pInterface, pNdisBuffer, HdrType);
#endif // BACK_FILL

			}

			//
			//  Inform IP of send completion.
			//
			(*(pInterface->IPTxCmpltHandler))(
						pInterface->IPContext,
						pNdisPacket,
						NDIS_STATUS_FAILURE
						);
		}
		else
		{
			//
			//  Belongs to us.
			//
			NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);

			AtmArpFreeProtoBuffer(pInterface, pNdisBuffer);
			AtmArpFreePacket(pInterface, pNdisPacket);
		}

		//
		//  Go to next packet in the list.
		//
		pNdisPacket = pNextPacket;
	}

	//
	//  Update IF statistics
	//
	AA_IF_STAT_ADD(pInterface, OutDiscards, NumberOfDiscards);

}


#define IPNetMask(a)	AtmArpIPMaskTable[(*(uchar *)&(a)) >> 4]

BOOLEAN
AtmArpIsBroadcastIPAddress(
	IN	IP_ADDRESS					Addr,
	IN	PATMARP_INTERFACE			pInterface		LOCKIN LOCKOUT
)
/*++

Routine Description:

	Check if the given IP address is a broadcast address for the
	interface.

	Copied from the LAN ARP module.

Arguments:

	Addr			- The IP Address to be checked
	pInterface		- Pointer to our Interface structure

Return Value:

	TRUE if the address is a broadcast address, FALSE otherwise.

--*/
{
	IP_ADDRESS				BCast;
	IP_MASK					Mask;
	PIP_ADDRESS_ENTRY		pIpAddressEntry;
	IP_ADDRESS				LocalAddr;

    // First get the interface broadcast address.
    BCast = pInterface->BroadcastAddress;

    // First check for global broadcast.
    if (IP_ADDR_EQUAL(BCast, Addr) || CLASSD_ADDR(Addr))
		return TRUE;

    // Now walk the local addresses, and check for net/subnet bcast on each
    // one.
	pIpAddressEntry = &(pInterface->LocalIPAddress);
	do {
		// See if this one is valid.
		LocalAddr = pIpAddressEntry->IPAddress;
		if (!IP_ADDR_EQUAL(LocalAddr, NULL_IP_ADDR)) {
			// He's valid.
			Mask = pIpAddressEntry->IPMask;

            // First check for subnet bcast.
            if (IP_ADDR_EQUAL((LocalAddr & Mask) | (BCast & ~Mask), Addr))
				return TRUE;

            // Now check all nets broadcast.
            Mask = IPNetMask(LocalAddr);
            if (IP_ADDR_EQUAL((LocalAddr & Mask) | (BCast & ~Mask), Addr))
				return TRUE;
		}

		pIpAddressEntry = pIpAddressEntry->pNext;

	} while (pIpAddressEntry != NULL);

	// If we're here, it's not a broadcast.
	return FALSE;
}


BOOLEAN
AtmArpValidateTableContext(
	IN	PVOID						QueryContext,
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN *					pIsValid
)
/*++

Routine Description:

	Check if a given ARP Table Query context is valid. It is valid if it
	is either NULL (looking for the first entry) or indicates a valid
	ARP Table Entry.

Arguments:

	QueryContext		- The context to be validated
	pInterface			- The IF on which the query is being performed
	pIsValid			- Where we return the validity of the Query Context.


Return Value:

	TRUE if the ARP Table has data to be read beyond the given context,
	FALSE otherwise.

--*/
{
	IPNMEContext        *pNMContext = (IPNMEContext *)QueryContext;
	PATMARP_IP_ENTRY	pIpEntry;
	PATMARP_IP_ENTRY	pTargetIpEntry;
	UINT				i;
	BOOLEAN				ReturnValue;

	i = pNMContext->inc_index;
	pTargetIpEntry = (PATMARP_IP_ENTRY)(pNMContext->inc_entry);

	//
	//  Check if we are starting at the beginning of the ARP Table.
	//
	if ((i == 0) && (pTargetIpEntry == NULL_PATMARP_IP_ENTRY))
	{
		//
		//  Yes, we are. Find the very first entry in the hash table.
		//
		*pIsValid = TRUE;
		do
		{
			if ((pIpEntry = pInterface->pArpTable[i]) != NULL_PATMARP_IP_ENTRY)
			{
				break;
			}
			i++;
		}
		while (i < ATMARP_TABLE_SIZE);

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			pNMContext->inc_index = i;
			pNMContext->inc_entry = pIpEntry;
			ReturnValue = TRUE;
		}
		else
		{
			ReturnValue = FALSE;
		}
	}
	else
	{
		//
		//  We are given a context. Check if it is valid.
		//

		//
		//  Initialize.
		//
		*pIsValid = FALSE;
		ReturnValue = FALSE;

		if (i < ATMARP_TABLE_SIZE)
		{
			pIpEntry = pInterface->pArpTable[i];
			while (pIpEntry != NULL_PATMARP_IP_ENTRY)
			{
				if (pIpEntry == pTargetIpEntry)
				{
					*pIsValid = TRUE;
					ReturnValue = TRUE;
					break;
				}
				else
				{
					pIpEntry = pIpEntry->pNextEntry;
				}
			}
		}
	}

	return (ReturnValue);

}



BOOLEAN
AtmArpReadNextTableEntry(
	IN	PVOID						QueryContext,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PUCHAR						pSpace
)
/*++

Routine Description:

	Read the next ARP Table Entry for the specified interface. The QueryContext
	tells us which entry is to be read.

Arguments:

	QueryContext		- Indicates the entry to be read.
	pInterface			- The IF on which the query is being performed
	pSpace				- where we copy in the desired table entry.

Return Value:

	TRUE if the ARP Table has entries beyond the indicated one, FALSE
	otherwise.

--*/
{
	IPNMEContext		*pNMContext;
	IPNetToMediaEntry	*pIPNMEntry;
	PATMARP_IP_ENTRY	pIpEntry;
	UINT				i;
	BOOLEAN				ReturnValue;

	pNMContext = (IPNMEContext *)QueryContext;
	pIPNMEntry = (IPNetToMediaEntry *)pSpace;

	pIpEntry = (PATMARP_IP_ENTRY)(pNMContext->inc_entry);
	AA_STRUCT_ASSERT(pIpEntry, aip);

	pIPNMEntry->inme_index = pInterface->IFIndex;

	pIPNMEntry->inme_addr = pIpEntry->IPAddress;
	if (AA_IS_FLAG_SET(pIpEntry->Flags, AA_IP_ENTRY_STATE_MASK, AA_IP_ENTRY_RESOLVED))
	{
		AADEBUGP(AAD_EXTRA_LOUD, ("ReadNext: found IP Entry 0x%x, Addr %d.%d.%d.%d\n",
					pIpEntry,
					((PUCHAR)(&(pIpEntry->IPAddress)))[0],
					((PUCHAR)(&(pIpEntry->IPAddress)))[1],
					((PUCHAR)(&(pIpEntry->IPAddress)))[2],
					((PUCHAR)(&(pIpEntry->IPAddress)))[3]
				));

		pIPNMEntry->inme_physaddrlen = AA_ATM_PHYSADDR_LEN;

		AA_ASSERT(pIpEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY);
		AA_COPY_MEM(pIPNMEntry->inme_physaddr,
					&pIpEntry->pAtmEntry->ATMAddress.Address[AA_ATM_ESI_OFFSET],
					AA_ATM_PHYSADDR_LEN);

		if (pIpEntry->Flags & AA_IP_ENTRY_IS_STATIC)
		{
			pIPNMEntry->inme_type = INME_TYPE_STATIC;
		}
		else
		{
			pIPNMEntry->inme_type = INME_TYPE_DYNAMIC;
		}
	}
	else
	{
		pIPNMEntry->inme_physaddrlen = 0;
		pIPNMEntry->inme_type = INME_TYPE_INVALID;
	}

	//
	//  Update the context for the next entry.
	//
	if (pIpEntry->pNextEntry != NULL_PATMARP_IP_ENTRY)
	{
		pNMContext->inc_entry = pIpEntry->pNextEntry;
		ReturnValue = TRUE;
	}
	else
	{
		//
		//  Initialize.
		ReturnValue = FALSE;
		i = pNMContext->inc_index + 1;
		pNMContext->inc_index = 0;
		pNMContext->inc_entry = NULL;

		while (i < ATMARP_TABLE_SIZE)
		{
			if (pInterface->pArpTable[i] != NULL_PATMARP_IP_ENTRY)
			{
				pNMContext->inc_entry = pInterface->pArpTable[i];
				pNMContext->inc_index = i;
				ReturnValue = TRUE;
				break;
			}
			else
			{
				i++;
			}
		}
	}

	return (ReturnValue);


}

VOID
AtmArpReStartInterface(
	IN	PNDIS_WORK_ITEM				pWorkItem,
	IN	PVOID						IfContext
)
/*++

Routine Description:

	Bring back up the IP interface.

Arguments:

    pWorkItem
	IfContextw			- The IF, which is expected to have reconfig
	                      state RECONFIG_QUEUED.

Return Value:

	None

--*/
{


	PATMARP_INTERFACE		pInterface;
	ULONG					rc;
	BOOLEAN                 fRestart = FALSE;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);
#if !BINARY_COMPATIBLE
	AA_ASSERT(EntryIrq == PASSIVE_LEVEL);
#endif

	pInterface = (PATMARP_INTERFACE)IfContext;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_FREE_MEM(pWorkItem);

	AA_ACQUIRE_IF_LOCK(pInterface);

    if (pInterface->ReconfigState != RECONFIG_RESTART_QUEUED)
    {
        //
        // Shouldn't get here.
        //
        AA_ASSERT(FALSE);
    }
    else
    {
        pInterface->ReconfigState = RECONFIG_RESTART_PENDING;
	    fRestart = TRUE;
    }

    rc = AtmArpDereferenceInterface(pInterface); // Reconfig Work item

	AADEBUGP(AAD_WARNING, ("RestartIF: IF %x/%x, fRestart %d, rc %d\n",
			pInterface, pInterface->Flags, fRestart, rc));

	//
	// If we're restarting, there should be at least 2 references to the
	// pInterface -- 1- the old carryover and 2- the pending completion
	// completion of the reconfig event.
	//
    if (rc < 2 || !fRestart) 
    {
        //
        // Must be  at least 2 if we're in the middle of a reconfig!
        //
        AA_ASSERT(!fRestart);

        if (rc != 0)
        {
        	AA_RELEASE_IF_LOCK(pInterface);
        }
    }
    else
    {			
    	//
    	// At this point we know that we are doing a restart of the interface.
    	//
    	// We will extract the pointer to the adapter, the
    	// configuration string for the interface, and the pointer to the
		// pending netPnpEvent  (we'll need these later),
    	// and then do a FORCED DEALLOCATION of the interface.
    	// We will then allocate the interface. We go through this 
    	// deallocate-allocate sequence to make sure that the interface
    	// structure and all it's sub-structures are properly initialized.
    	//
    	// We could have tried to re-use the old interface, but if so we
    	// would have to write code to clean up the old interface. Given
    	// that we expect restarting of the interface to be an infrequent
    	// event, it is more important to conserve code size in this case.
    	//
		NDIS_STRING IPConfigString 		= pInterface->IPConfigString; // struct copy
		PATMARP_ADAPTER	pAdapter 		= pInterface->pAdapter;
		PNET_PNP_EVENT	pReconfigEvent	= pInterface->pReconfigEvent;
		NDIS_STATUS Status 				= NDIS_STATUS_SUCCESS;
	
		do
		{
			NDIS_HANDLE					LISConfigHandle;

			rc = AtmArpDereferenceInterface(pInterface);

			if (rc)
			{
				rc = AtmArpDereferenceInterface(pInterface);
			}

			if (rc != 0)
			{
				AA_RELEASE_IF_LOCK(pInterface);
			}

			pInterface = NULL;

			//
			//  Open the configuration section for this LIS.
			//
			LISConfigHandle = AtmArpCfgOpenLISConfigurationByName(
										pAdapter,
										&IPConfigString
										);
	
			if (LISConfigHandle == NULL)
			{
				//
				//  This is the normal termination condition, i.e.
				//  we reached the end of the LIS list for this
				//  adapter.
				//
				AADEBUGP(AAD_INFO, ("ReStartInterface: cannot open LIS\n"));
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			pInterface =  AtmArpAddInterfaceToAdapter (
							pAdapter,
							LISConfigHandle,
							&IPConfigString
							);

			//
			//  Close the configuration section for this LIS.
			//
			AtmArpCfgCloseLISConfiguration(LISConfigHandle);
			LISConfigHandle = NULL;

			if (pInterface == NULL_PATMARP_INTERFACE)
			{
				Status = NDIS_STATUS_FAILURE;
				break;
			}

		} while(FALSE);

#ifdef _PNP_POWER_
		//
		// Complete the pending PnPReconfig event, if any.
		//
		if (pReconfigEvent)
		{

			NdisCompletePnPEvent(
				Status,
				pAdapter->NdisAdapterHandle,
				pReconfigEvent
				);
			
			AADEBUGP( AAD_INFO,
				("ReStartInterface: IF 0x%x, Status 0x%x, Event 0x%x\n",
						pInterface, Status, pReconfigEvent));
		}
#else
		AA_ASSERT(!pReconfigEvent);
#endif

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\arppkt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arppkt.h

Abstract:

	Definitions for ATMARP packets

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     07-29-96    Created

Notes:

--*/

#ifndef _ARP_PKT__H
#define _ARP_PKT__H




//
//  Rounded-off size of generic Q.2931 IE header
//
#define ROUND_OFF(_size)		(((_size) + 3) & ~0x3)

#define SIZEOF_Q2931_IE	 ROUND_OFF(sizeof(Q2931_IE))
#define SIZEOF_AAL_PARAMETERS_IE	ROUND_OFF(sizeof(AAL_PARAMETERS_IE))
#define SIZEOF_ATM_TRAFFIC_DESCR_IE	ROUND_OFF(sizeof(ATM_TRAFFIC_DESCRIPTOR_IE))
#define SIZEOF_ATM_BBC_IE			ROUND_OFF(sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE))
#define SIZEOF_ATM_BLLI_IE			ROUND_OFF(sizeof(ATM_BLLI_IE))
#define SIZEOF_ATM_QOS_IE			ROUND_OFF(sizeof(ATM_QOS_CLASS_IE))


//
//  Total space required for Information Elements in an outgoing call.
//
#define ATMARP_MAKE_CALL_IE_SPACE (	\
						SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +	\
						SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE )

//
//  Total space required for Information Elements in an outgoing AddParty.
//
#define ATMARP_ADD_PARTY_IE_SPACE (	\
						SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +	\
						SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE )

#define AA_IPV4_ADDRESS_LENGTH		4

#define	CLASSA_MASK		0x000000ff
#define	CLASSB_MASK		0x0000ffff
#define	CLASSC_MASK		0x00ffffff
#define	CLASSD_MASK		0x000000e0
#define	CLASSE_MASK		0xffffffff

//
//  Standard values
//
#define AA_PKT_ATM_FORUM_AF			19
#define AA_PKT_PRO_IP				((USHORT)0x800)

//
//  Values for the LLC SNAP header
//
#define LLC_SNAP_LLC0				((UCHAR)0xAA)
#define LLC_SNAP_LLC1				((UCHAR)0xAA)
#define LLC_SNAP_LLC2				((UCHAR)0x03)
#define LLC_SNAP_OUI0				((UCHAR)0x00)
#define LLC_SNAP_OUI1				((UCHAR)0x00)
#define LLC_SNAP_OUI2				((UCHAR)0x00)


//
//  Values for EtherType
//
#define AA_PKT_ETHERTYPE_IP_NS		((USHORT)0x0008)
#define AA_PKT_ETHERTYPE_IP			((USHORT)0x800)
#define AA_PKT_ETHERTYPE_ARP		((USHORT)0x806)

#include <pshpack1.h>

//
//  LLC SNAP Header
//
typedef struct _AA_PKT_LLC_SNAP_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						EtherType;
} AA_PKT_LLC_SNAP_HEADER;

typedef AA_PKT_LLC_SNAP_HEADER UNALIGNED *PAA_PKT_LLC_SNAP_HEADER;


//
//  ATMARP Packet Common Header format
//
typedef struct _AA_ARP_PKT_HEADER
{
	AA_PKT_LLC_SNAP_HEADER		LLCSNAPHeader;
	USHORT						hrd;			// Hardware Type
	USHORT						pro;			// Protocol Type
	UCHAR						shtl;			// Source HW Addr Type+Length
	UCHAR						sstl;			// Source HW SubAddr Type+Length
	USHORT						op;				// Operation Code
	UCHAR						spln;			// Source Protocol Addr Length
	UCHAR						thtl;			// Target HW Addr Type+Length
	UCHAR						tstl;			// Target HW SubAddr Type+Length
	UCHAR						tpln;			// Target Protocol Addr Length
	UCHAR						Variable[1];	// Start of the variable part
} AA_ARP_PKT_HEADER;

typedef AA_ARP_PKT_HEADER UNALIGNED *PAA_ARP_PKT_HEADER;


#define AA_PKT_LLC_SNAP_HEADER_LENGTH		(sizeof(AA_PKT_LLC_SNAP_HEADER))
#define AA_ARP_PKT_HEADER_LENGTH			(sizeof(AA_ARP_PKT_HEADER)-1)

#include <poppack.h>

//
//  Values for fields in an ARP packet header
//
#define AA_PKT_HRD							((USHORT)0x0013)
#define AA_PKT_PRO							((USHORT)0x0800)
#define AA_PKT_OP_TYPE_ARP_REQUEST			((USHORT)1)
#define AA_PKT_OP_TYPE_ARP_REPLY			((USHORT)2)
#define AA_PKT_OP_TYPE_INARP_REQUEST		((USHORT)8)
#define AA_PKT_OP_TYPE_INARP_REPLY			((USHORT)9)
#define AA_PKT_OP_TYPE_ARP_NAK				((USHORT)10)

#define AA_PKT_ATM_ADDRESS_NSAP				((UCHAR)0x00)
#define AA_PKT_ATM_ADDRESS_E164				((UCHAR)0x40)
#define AA_PKT_ATM_ADDRESS_BIT				((UCHAR)0x40)


//
//  Internal representation of the contents of an
//  ARP packet:
//
typedef struct _AA_ARP_PKT_CONTENTS
{
	UCHAR						SrcAtmNumberTypeLen;
	UCHAR						SrcAtmSubaddrTypeLen;
	UCHAR						DstAtmNumberTypeLen;
	UCHAR						DstAtmSubaddrTypeLen;
	UCHAR UNALIGNED *			pSrcAtmNumber;
	UCHAR UNALIGNED *			pSrcAtmSubaddress;
	UCHAR UNALIGNED *			pDstAtmNumber;
	UCHAR UNALIGNED *			pDstAtmSubaddress;
	UCHAR UNALIGNED *			pSrcIPAddress;
	UCHAR UNALIGNED *			pDstIPAddress;
} AA_ARP_PKT_CONTENTS, *PAA_ARP_PKT_CONTENTS;



/*++
BOOLEAN
AA_PKT_LLC_SNAP_HEADER_OK(
	IN	PAA_PKT_LLC_SNAP_HEADER	pPktHeader
)
Check if a received LLC/SNAP header is valid.
--*/
#define AA_PKT_LLC_SNAP_HEADER_OK(pH)			\
			(((pH)->LLC[0] == LLC_SNAP_LLC0) &&	\
			 ((pH)->LLC[1] == LLC_SNAP_LLC1) && \
			 ((pH)->LLC[2] == LLC_SNAP_LLC2) && \
			 ((pH)->OUI[0] == LLC_SNAP_OUI0) && \
			 ((pH)->OUI[1] == LLC_SNAP_OUI1) && \
			 ((pH)->OUI[2] == LLC_SNAP_OUI2))


/*++
UCHAR
AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(
	IN	PATM_ADDRESS			pAtmAddress
)
Return a one-byte Type+Length field corresponding to an ATM Address
--*/
#define AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(pAtmAddress)							\
			((UCHAR)((pAtmAddress)->NumberOfDigits) |						\
				(((pAtmAddress)->AddressType == ATM_E164) ? 				\
						AA_PKT_ATM_ADDRESS_E164 : AA_PKT_ATM_ADDRESS_NSAP))


/*++
VOID
AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
	IN	UCHAR				TypeLen,
	IN	ATM_ADDRESSTYPE *	pAtmAddressType,
	IN	ULONG *				pAtmAddressLength
)
Convert a Type+Length field in an ATMARP packet to Type, Length
values in an ATM_ADDRESS structure
--*/
#define AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(TypeLen, pAtmType, pAtmLen)	\
		{															\
			*(pAtmType) = 											\
				((((TypeLen) & AA_PKT_ATM_ADDRESS_BIT) == 			\
					AA_PKT_ATM_ADDRESS_E164)? ATM_E164: ATM_NSAP);	\
			*(pAtmLen) =											\
					(ULONG)((TypeLen) & ~AA_PKT_ATM_ADDRESS_BIT);	\
		}

//
//  ATM Address ESI length, and offset from the beginning.
//
#define AA_ATM_ESI_LEN				6
#define AA_ATM_ESI_OFFSET			13


//
//  DHCP constants
//
#define AA_DEST_DHCP_PORT_OFFSET	2
#define AA_DHCP_SERVER_PORT			0x4300
#define AA_DHCP_CLIENT_PORT			0x4400
#define AA_DHCP_MIN_LENGTH			44
#define AA_DHCP_ESI_OFFSET			28


#endif // _ARP_PKT__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\arpproc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arpproc.c	- ARP Procedures

Abstract:

	All Client protocol operations related to IP over ATM are here:
	- Registration with an ARP server
	- Resolving an IP address
	- Maintaining the ARP cache

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     07-17-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'PPRA'


VOID
AtmArpStartRegistration(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Start registering ourselves with the ARP server, on the specified
	interface. The caller is assume to have a lock for the Interface,
	and we release it here.

	We first check if all pre-conditions are satisfied, i.e.:

	1. The Admin State for the interface is UP
	2. The ATM interface is ready
	3. Atleast one IP Address has been configured for the interface
	4. We know the address of atleast one ARP server (SVC environment)

Arguments:

	pInterface		- Pointer to ATMARP Interface structure

Return Value:

	None

--*/
{
	PIP_ADDRESS				pIPAddress;
	BOOLEAN					WasRunning;

	pIPAddress = &pInterface->LocalIPAddress.IPAddress;

	if (pInterface->AdminState == IF_STATUS_UP)
	{
		if (pInterface->PVCOnly)
		{
			//
			//  PVCs only: no registration required
			//
			pInterface->State = IF_STATUS_UP;
			pInterface->LastChangeTime = GetTimeTicks();

			AA_SET_FLAG(
				pInterface->Flags,
				AA_IF_SERVER_STATE_MASK,
				AA_IF_SERVER_REGISTERED);

			AA_RELEASE_IF_LOCK(pInterface);
#ifdef ATMARP_WMI
			AtmArpWmiSendTCIfIndication(
				pInterface,
                AAGID_QOS_TC_INTERFACE_UP_INDICATION,
				0
				);
#endif
		}
		else
		{
			//
			//  We use SVCs; start registering if we know the
			//  address of atleast one ARP server, and we have
			//  atleast one local IP address to register, and
			//  we haven't registered yet, and we are not in
			//  the process of registering currently.
			//
			if ((pInterface->AtmInterfaceUp) &&
				(pInterface->ArpServerList.ListSize > 0) &&
				(pInterface->NumOfIPAddresses > 0) &&
				(AA_IS_FLAG_SET(
						pInterface->Flags,
						AA_IF_SERVER_STATE_MASK,
						AA_IF_SERVER_NO_CONTACT))
			   )
			{
				AADEBUGP(AAD_INFO, ("Starting registration on IF 0x%x\n", pInterface));
		
				AA_SET_FLAG(
						pInterface->Flags,
						AA_IF_SERVER_STATE_MASK,
						AA_IF_SERVER_REGISTERING);
		
				//
				//  Just in case we have left a timer running, stop it.
				//
				WasRunning = AtmArpStopTimer(
									&(pInterface->Timer),
									pInterface
									);

				AtmArpStartTimer(
						pInterface,
						&(pInterface->Timer),
						AtmArpRegistrationTimeout,
						pInterface->ServerRegistrationTimeout,
						(PVOID)pInterface	// Context
						);

				if (!WasRunning)
				{
					AtmArpReferenceInterface(pInterface);	// Timer ref
				}

				AA_RELEASE_IF_LOCK(pInterface);

				AtmArpSendARPRequest(
						pInterface,
						pIPAddress,		// Source IP is ours
						pIPAddress		// Target IP is ours
						);
			}
			else
			{
				//
				//  We don't have all necessary preconditions for
				//  starting registration.
				//
				AA_RELEASE_IF_LOCK(pInterface);
			}
		}
	}
	else
	{
		//
		//  The Interface is down
		//
		AA_RELEASE_IF_LOCK(pInterface);
	}
}



VOID
AtmArpRegisterOtherIPAddresses(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Register all unregistered IP addresses with the ARP server. The caller
	is assumed to hold a lock for the Interface structure, which will be
	released here.

Arguments:

	pInterface				- Pointer to ARMARP Interface

Return Value:

	None

--*/
{
	PIP_ADDRESS_ENTRY		pIPAddressEntry;
	PIP_ADDRESS				pIPAddressList;	// List of addresses we want to register
	INT						AddressCount;	// Size of above list
	PIP_ADDRESS				pIPAddress; 	// Temp, to walk thru lists


	if (pInterface->NumOfIPAddresses > 1)
	{
		//
		//  First make a copy of all addresses we want to register,
		//  while we hold a lock to the Interface.
		//
		AA_ALLOC_MEM(
				pIPAddressList,
				IP_ADDRESS,
				(pInterface->NumOfIPAddresses)*sizeof(IP_ADDRESS));
	
	
		AddressCount = 0;
		if (pIPAddressList != (PIP_ADDRESS)NULL)
		{
			pIPAddress = pIPAddressList;

			pIPAddressEntry = &(pInterface->LocalIPAddress);
			while (pIPAddressEntry != (PIP_ADDRESS_ENTRY)NULL)
			{
				if (!(pIPAddressEntry->IsRegistered))
				{
					//
					//  This one's not registered yet: copy it into our list.
					//
					AA_COPY_MEM(
						(PUCHAR)pIPAddress,
						(PUCHAR)&(pIPAddressEntry->IPAddress),
						sizeof(IP_ADDRESS));
					pIPAddress++;
					AddressCount++;
				}
				pIPAddressEntry = pIPAddressEntry->pNext;
			}

		}

		AA_RELEASE_IF_LOCK(pInterface);

		pIPAddress = pIPAddressList;
		while (AddressCount-- > 0)
		{
			AADEBUGP(AAD_INFO, ("Registering Other IP Address on IF 0x%x: %d.%d.%d.%d\n",
						pInterface,
						((PUCHAR)pIPAddress)[0],
						((PUCHAR)pIPAddress)[1],
						((PUCHAR)pIPAddress)[2],
						((PUCHAR)pIPAddress)[3]));

			AtmArpSendARPRequest(
						pInterface,
						pIPAddress,		// Source IP is ours
						pIPAddress		// Target IP is ours
						);
			pIPAddress++;
		}

		if (pIPAddressList != (PIP_ADDRESS)NULL)
		{
			AA_FREE_MEM(pIPAddressList);
		}

	}
	else
	{
		//
		//  No additional addresses to register.
		//
		AA_RELEASE_IF_LOCK(pInterface);
	}

}



VOID
AtmArpRetryServerRegistration(
	IN	PATMARP_INTERFACE			pInterface		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Retry server registration. This is called because of a failure to
	register with the server (connection failure, or no response or
    NAK response or invalid response to our registration ARP Request).

    If we have tried this server enough times, we move to the next
    ARP server in our list. Wait for a while before retrying.

Arguments:

	pInterface				- Pointer to ARMARP Interface

Return Value:

	None

--*/
{
	if (pInterface->AdminState == IF_STATUS_UP)
	{
		if (pInterface->RetriesLeft > 0)
		{
			//
			//  We still have retries on this server.
			//
			pInterface->RetriesLeft--;
		}
		else
		{
			//
			//  Out of retries on this server. Pick up the next timer in the
			//  list.
			//
			if (pInterface->pCurrentServer->pNext != (PATMARP_SERVER_ENTRY)NULL)
			{
				pInterface->pCurrentServer = pInterface->pCurrentServer->pNext;
			}
			else
			{
				pInterface->pCurrentServer = pInterface->ArpServerList.pList;
			}

			pInterface->RetriesLeft = pInterface->MaxRegistrationAttempts - 1;
		}

		AA_SET_FLAG(
			pInterface->Flags,
			AA_IF_SERVER_STATE_MASK,
			AA_IF_SERVER_NO_CONTACT);


		//
		//  Wait for a while before initiating another
		//  connection to the server. When the timer elapses,
		//  we will try again.
		//
		AtmArpStartTimer(
					pInterface,
					&(pInterface->Timer),
					AtmArpServerConnectTimeout,
					pInterface->ServerConnectInterval,
					(PVOID)pInterface
					);

		AtmArpReferenceInterface(pInterface);	// Timer ref
	}
	//
	//  else the Interface is going down -- do nothing.
	//

	AA_RELEASE_IF_LOCK(pInterface);
}


VOID
AtmArpHandleServerRegistrationFailure(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN NOLOCKOUT,
	IN	PATMARP_VC					pVc			OPTIONAL
)
/*++

Routine Description:

	Handle a failure in the Registration process. We close the VC to the
	ARP server, if one exists, and wait for a while before starting the
	registration process again.

Arguments:

	pInterface			- Pointer to ATMARP interface
	pVc					- (Optional) pointer to VC to ARP Server.

Return Value:

	None

--*/
{
	BOOLEAN		TimerWasRunning;
	ULONG		rc;			// Ref Count on Interface.

	TimerWasRunning = AtmArpStopTimer(&(pInterface->Timer), pInterface);

	if (TimerWasRunning)
	{
		rc = AtmArpDereferenceInterface(pInterface);	// Timer reference
		AA_ASSERT(rc > 0);
	}

	AtmArpRetryServerRegistration(pInterface);
	//
	//  The IF lock is released within the above.
	//

	if (pVc != NULL_PATMARP_VC)
	{
		//
		//  Tear down this VC (to an ARP server).
		//
		//  NOTE: We do this now even though we called RetryServerRegistration
		//  above because we have the knowledge that the routine above
		//  doesn't really start registration: it only starts a timer
		//  on whose expiry we start registration.
		//
		//  First unlink this VC from the ATM Entry it's linked to.
		//
		AA_ACQUIRE_VC_LOCK(pVc);

		//
		//  Now close the call
		//
		AtmArpCloseCall(pVc);
		//
		//  the VC lock is released above
		//
	}
}



BOOLEAN
AtmArpIsZeroIPAddress(
	IN	UCHAR UNALIGNED *			pIPAddress
)
/*++

Routine Description:

	Check if the given IP address is all zeros.

Arguments:

	pIPAddress					- Pointer to IP address in question

Return Value:

	TRUE if the address is all 0's, FALSE otherwise.

--*/
{
	IP_ADDRESS UNALIGNED *			pIPAddrStruct;

	pIPAddrStruct = (IP_ADDRESS UNALIGNED *)pIPAddress;
	return (BOOLEAN)(*pIPAddrStruct == (IP_ADDRESS)0);
}



BOOLEAN
AtmArpIsLocalIPAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	UCHAR UNALIGNED *			pIPAddress
)
/*++

Routine Description:

	Check if the given IP address is one of those assigned to this
	interface.

Arguments:

	pInterface				- Pointer to Interface structure
	pIPAddress				- Pointer to IP address in question

Return Value:

	TRUE if the IP address is one of ours, FALSE otherwise.

--*/
{
	PIP_ADDRESS_ENTRY				pIPAddrEntry;
	IP_ADDRESS UNALIGNED *			pIPAddrStruct;
	BOOLEAN							IsLocal;

	if (pIPAddress != (PUCHAR)NULL)
	{
		pIPAddrStruct = (IP_ADDRESS UNALIGNED *)pIPAddress;

		AA_ACQUIRE_IF_LOCK(pInterface);

		pIPAddrEntry = &(pInterface->LocalIPAddress);

		IsLocal = FALSE;
		do
		{
			if (pIPAddrEntry->IPAddress == *pIPAddrStruct)
			{
				IsLocal = TRUE;
				break;
			}
			else
			{
				pIPAddrEntry = pIPAddrEntry->pNext;
			}
		}
		while (pIPAddrEntry != (PIP_ADDRESS_ENTRY)NULL);

		AA_RELEASE_IF_LOCK(pInterface);
	}
	else
	{
		IsLocal = FALSE;
	}

	AADEBUGP(AAD_VERY_LOUD, ("IsLocalIP(%d:%d:%d:%d): returning %d\n",
					(IsLocal? pIPAddress[0] : 0),
					(IsLocal? pIPAddress[1] : 0),
					(IsLocal? pIPAddress[2] : 0),
					(IsLocal? pIPAddress[3] : 0),
					IsLocal));
	return (IsLocal);
}



BOOLEAN
AtmArpIsLocalAtmAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PUCHAR						pAtmAddrString,
	IN	UCHAR						AtmAddrTypeLen
)
/*++

Routine Description:

	Check if the given ATM address (in "packet" format) is the same as
	our local ATM address.

Arguments:

	pInterface		- Pointer to Interface structure for which the check
					  is being made.
	pAtmAddrString	- String of bytes representing an ATM address
	AtmAddrTypeLen	- Type and Length (ARP packet format) of ATM address

Return Value:

	TRUE if the given address matches the local ATM address for the
	specified interface, FALSE otherwise.

--*/
{
	ATM_ADDRESSTYPE	AddressType;
	ULONG			AddressLength;

	AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(AtmAddrTypeLen, &AddressType, &AddressLength);

	if ((AddressType == pInterface->LocalAtmAddress.AddressType) &&
		(AddressLength == pInterface->LocalAtmAddress.NumberOfDigits) &&
		(AA_MEM_CMP(
				pAtmAddrString,
				pInterface->LocalAtmAddress.Address,
				AddressLength) == 0)
	   )
	{
		return (TRUE);
	}
	else
	{
		return (FALSE);
	}
}




NDIS_STATUS
AtmArpSendPacketOnAtmEntry(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FILTER_SPEC			pFilterSpec	OPTIONAL,
	IN	PATMARP_FLOW_INFO			pFlowInfo	OPTIONAL,
	IN	BOOLEAN						IsBroadcast
)
/*++

Routine Description:

	Send a packet with the specified Filter-Spec and Flow-Spec to
	the ATM address denoted by the ATM Entry. We look for a VC that
	matches the given Specs, and send/queue this packet on the VC.
	If no such VC exists, we make a call with this Flow-Spec.

	NOTE: The caller is assumed to hold a lock to the ATM Entry, which
	we will release here.

Arguments:

	pInterface				- Pointer to ATMARP Interface
	pAtmEntry				- Pointer to ATM Entry on which this packet
							  should be sent
	pNdisPacket				- Packet to be sent
	pFlowSpec				- Flow-Spec for this packet.
	pFilterSpec				- Filter-Spec for this packet.
	pFlowInfo				- Flow to which this packet belongs.
	IsBroadcast				- Is this to a Class-D or broadcast address?

Locks on entry:

Locks on exit:

Return Value:

	None

--*/
{
	PATMARP_VC				pVc;			// VC to send this packet on
	PNDIS_BUFFER			pHeaderBuffer;	// For LLC/SNAP header
	PNDIS_BUFFER			pNdisBuffer;	// First buffer in the IP packet
	NDIS_HANDLE				NdisVcHandle;
	NDIS_STATUS				Status;
	PUCHAR					pHeader;
	AA_HEADER_TYPE			HdrType;

	do
	{
		Status = NDIS_STATUS_SUCCESS;

		//
		// TODO -- the atm entry may not be ACTIVE at this time,
		// you may want to check for this and if so fail the call and free
		// the packet (call AtmArpFreeSendPackets) here itself.
		// As it happens we go on and make a call if possible, etc.
		//

		//  Prepend an LLC/SNAP header if required.
		//
		if (pFlowSpec->Encapsulation == ENCAPSULATION_TYPE_LLCSNAP)
		{
			HdrType = (IsBroadcast? AA_HEADER_TYPE_NUNICAST: AA_HEADER_TYPE_UNICAST);

#ifdef BACK_FILL
			//
			//  We look at the first buffer in the IP packet, to see whether
			//  it has space reserved for low-layer headers. If so, we just
			//  use it up. Otherwise, we allocate a header buffer of our own.
			//
			NdisQueryPacket(pNdisPacket, NULL, NULL, &pNdisBuffer, NULL);
			AA_ASSERT(pNdisBuffer != NULL);
			if (AtmArpDoBackFill && AA_BACK_FILL_POSSIBLE(pNdisBuffer))
			{
				PUCHAR	pArpHeader;
				ULONG	ArpHeaderLength;

				AtmArpBackFillCount++;
				if (HdrType == AA_HEADER_TYPE_UNICAST)
				{
					pArpHeader = (PUCHAR)&AtmArpLlcSnapHeader;
					ArpHeaderLength = sizeof(AtmArpLlcSnapHeader);
				}
#ifdef IPMCAST
				else
				{
					pArpHeader = (PUCHAR)&AtmArpMcType1ShortHeader;
					ArpHeaderLength = sizeof(AtmArpMcType1ShortHeader);
				}
#endif // IPMCAST
				(PUCHAR)pNdisBuffer->MappedSystemVa -= ArpHeaderLength;
				pNdisBuffer->ByteOffset -= ArpHeaderLength;
				pNdisBuffer->ByteCount += ArpHeaderLength;
				pHeader = pNdisBuffer->MappedSystemVa;
				AA_COPY_MEM(pHeader,
							pArpHeader,
							ArpHeaderLength);
			}
			else
			{
				pHeaderBuffer = AtmArpAllocateHeader(pInterface, HdrType, &pHeader);
				if (pHeaderBuffer != (PNDIS_BUFFER)NULL)
				{
					NdisChainBufferAtFront(pNdisPacket, pHeaderBuffer);
				}
				else
				{
					pHeader = NULL;
				}
			}

			if (pHeader != NULL)
			{
#else
			pHeaderBuffer = AtmArpAllocateHeader(pInterface, HdrType, &pHeader);
			if (pHeaderBuffer != (PNDIS_BUFFER)NULL)
			{
				NdisChainBufferAtFront(pNdisPacket, pHeaderBuffer);
#endif // BACK_FILL
#ifdef IPMCAST
				if (HdrType == AA_HEADER_TYPE_NUNICAST)
				{
					PAA_MC_PKT_TYPE1_SHORT_HEADER	pDataHeader;

					//
					//  Fill in our Cluster Member ID
					//
					AAMCDEBUGP(AAD_EXTRA_LOUD+10,
						("(MC)SendPkt: pAtmEntry 0x%x, pHeaderBuffer 0x%x, pHeader 0x%x\n",
								pAtmEntry, pHeaderBuffer, pHeader));

					pDataHeader = (PAA_MC_PKT_TYPE1_SHORT_HEADER)pHeader;
					pDataHeader->cmi = (USHORT)(pInterface->ClusterMemberId);
				}
#endif // IPMCAST
			}
			else
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
				AADEBUGP(AAD_WARNING, ("FAILED TO ALLOCATE HEADER ON IF 0x%x\n",
							pInterface));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}
		}


		//
		//  Search for a VC that has matching flow/filter specs.
		//
		for (pVc = pAtmEntry->pVcList;
			 pVc != NULL_PATMARP_VC;
			 pVc = pVc->pNextVc)
		{
#ifdef GPC
			PVOID		VcFlowHandle;

			VcFlowHandle = pVc->FlowHandle;
#endif // GPC

			if ((!AA_IS_VC_GOING_DOWN(pVc)) &&
				(pVc->FlowSpec.SendPeakBandwidth > 0))
			{
#ifdef GPC
				if (VcFlowHandle == (PVOID)pFlowInfo)
				{
					//
					//  This VC was made for this flow.
					//
					break;
				}

				if (IsBroadcast)
				{
					//
					//  We don't support multiple VCs to a multicast IP
					//  destination. So, stop at the first available VC.
					//
					break;
				}

				//
				//  If this VC is associated with a flow already, don't
				//  send traffic belonging to another flow (explicit or
				//  unclassified best effort) on it.
				//
				if (VcFlowHandle != NULL)
				{
					continue;
				}
#endif // GPC
				if ((pFilterSpec == (PATMARP_FILTER_SPEC)NULL) ||
						AA_FILTER_SPEC_MATCH(pInterface, pFilterSpec, &(pVc->FilterSpec)))
				{
					if (AA_FLOW_SPEC_MATCH(pInterface, pFlowSpec, &(pVc->FlowSpec)))
					{
						break;
					}
				}
			}

			AADEBUGP(AAD_LOUD,
				("pVc %x did not match pkt, Vc has VcHandle %x, SendPeak %d, SendMaxSize %d\n",
						pVc,
						pVc->NdisVcHandle,
						pVc->FlowSpec.SendPeakBandwidth,
						pVc->FlowSpec.SendMaxSize));

			AADEBUGP(AAD_LOUD,
				("Target FlowSpec %x has SendPeak %d, SendMaxSize %d\n",
					pFlowSpec,
					pFlowSpec->SendPeakBandwidth,
					pFlowSpec->SendMaxSize));
		}

		if (pVc != NULL_PATMARP_VC)
		{
			//
			//  Found a VC that matches this packet's requirements.
			//
			AA_ACQUIRE_VC_LOCK_DPC(pVc);

#ifdef GPC
			//
			//  See if the VC and the Flow are unassociated. If so, link
			//  together the VC and the Flow, to speed up future packets.
			//  Take care not to reassociate a VC that's just been unlinked
			//  from a flow.
			//
			if ((pFlowInfo != NULL) &&
				(pVc->FlowHandle == NULL) &&
				(!AA_IS_FLAG_SET(
							pVc->Flags,
							AA_VC_GPC_MASK,
							AA_VC_GPC_IS_UNLINKED_FROM_FLOW))
			   )
			{
				if (NULL == InterlockedCompareExchangePointer(
										&(pFlowInfo->VcContext),
										pVc,
										NULL
										))
				{
					AADEBUGP( AAD_LOUD,
						 ("SendPktOnAtmEntry: linking VC x%x and FlowInfo x%x\n",
							pVc, pFlowInfo));
					pVc->FlowHandle = (PVOID)pFlowInfo;
					AtmArpReferenceVc(pVc);	// GPC FlowInfo ref
				}
				else
				{
					//
					// We couldn't associate the vc with the flow, so we need
					// to enable the ageing timer for this vc, because we'll
					// never get notified when the flow is removed/modified.
					//
					if (!AA_IS_TIMER_ACTIVE(&(pVc->Timer)))
					{
						AADEBUGP( AAD_INFO,
						 ("SendPktOnAtmEntry: Enabling ageing timer on VC x%x "
						  "because we could not associate with FlowInfo x%x\n",
							pVc, pFlowInfo));
						AtmArpStartTimer(
								pVc->pInterface,
								&(pVc->Timer),
								AtmArpVcAgingTimeout,
								pInterface->DefaultFlowSpec.AgingTime,
								(PVOID)pVc
								);
		
						AtmArpReferenceVc(pVc);	// GPC Flow remove decay timer ref
					}
				}
			}
#endif // GPC

			if (AA_IS_FLAG_SET(
						pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_ACTIVE))
			{
#ifdef VC_REFS_ON_SENDS
				AtmArpReferenceVc(pVc);	// SendPacketOnAtmEntry
#endif // VC_REFS_ON_SENDS

				pVc->OutstandingSends++;	// SendPacketOnAtmEntry

				NdisVcHandle = pVc->NdisVcHandle;
				AtmArpRefreshTimer(&(pVc->Timer));
			}
			else
			{
				AtmArpQueuePacketOnVc(pVc, pNdisPacket);
				NdisVcHandle = NULL;	// to signify we are queueing this packet
			}

			AA_RELEASE_VC_LOCK_DPC(pVc);

			AA_RELEASE_AE_LOCK(pAtmEntry);

			if (NdisVcHandle != NULL)
			{
				//
				//  A call is active on this VC, so send the packet.
				//
#if DBG
				if (AaDataDebugLevel & (AAD_DATA_OUT))
				{
					AADEBUGP(AAD_FATAL,
						("Will send Pkt %x on VC %x, Handle %x, sendBW %d, sendMax %d\n",
								pNdisPacket,
								pVc,
								NdisVcHandle,
								pVc->FlowSpec.SendPeakBandwidth,
								pVc->FlowSpec.SendMaxSize));
				}
#endif

				AADEBUGP(AAD_EXTRA_LOUD+50,
					("SendPktOnAtmEntry: will send Pkt 0x%x on VC 0x%x, VcHandle 0x%x\n",
						pNdisPacket,
						pVc,
						NdisVcHandle));

#ifdef PERF
				AadLogSendUpdate(pNdisPacket);
#endif // PERF
				NDIS_CO_SEND_PACKETS(
						NdisVcHandle,
						&pNdisPacket,
						1
						);
			}
			else
			{
				//
				//  The packet would have been queued.
				//
			}

			Status = NDIS_STATUS_PENDING;
		}
		else
		{
			//
			//  No matching VC exists; create a new one.
			//
#ifdef IPMCAST
			if (AA_IS_FLAG_SET(pAtmEntry->Flags,
								AA_ATM_ENTRY_TYPE_MASK,
								AA_ATM_ENTRY_TYPE_UCAST))
			{
				Status = AtmArpMakeCall(
									pInterface,
									pAtmEntry,
									pFlowSpec,
									pNdisPacket
									);
				//
				//  AE lock is released within the above.
				//
			}
			else
			{
				//
				//  Multicast ATM Entry: we shouldn't be here, ideally..
				//
				AA_RELEASE_AE_LOCK(pAtmEntry);

				AAMCDEBUGP(AAD_WARNING,
					("SendPacket: pAtmEntry 0x%x, Flags 0x%x, dropping pkt 0x%x\n",
								pAtmEntry, pAtmEntry->Flags, pNdisPacket));

				AA_SET_NEXT_PACKET(pNdisPacket, NULL);
				AtmArpFreeSendPackets(
								pInterface,
								pNdisPacket,
								TRUE		// header present
								);
			}
#else
			Status = AtmArpMakeCall(
								pInterface,
								pAtmEntry,
								pFlowSpec,
								pNdisPacket
								);
			//
			//  The ATM Entry lock is released within the above.
			//
#endif // IPMCAST
			Status = NDIS_STATUS_PENDING;
		}
		break;
	}
	while (FALSE);

	return (Status);
}




VOID
AtmArpQueuePacketOnVc(
	IN	PATMARP_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Queue a packet on the VC's transmit queue.

Arguments:

	pVc					- Pointer to ATMARP VC
	pNdisPacket			- The packet to be queued.

Return Value:

	None

--*/
{
	PNDIS_PACKET		pPrevPacket;

	AADEBUGP(AAD_EXTRA_LOUD, ("Queueing Pkt 0x%x on VC 0x%x\n",
				pNdisPacket, pVc));

	if (pVc->PacketList == (PNDIS_PACKET)NULL)
	{
		//
		//  No packets on this VC.
		//
		pVc->PacketList = pNdisPacket;
	}
	else
	{
		//
		//  Go to the end of the packet list on this VC.
		//
		pPrevPacket = pVc->PacketList;
		while (AA_GET_NEXT_PACKET(pPrevPacket) != (PNDIS_PACKET)NULL)
		{
			pPrevPacket = AA_GET_NEXT_PACKET(pPrevPacket);
		}

		//
		//  Found the last packet in the list. Chain this packet
		//  to it.
		//
		AA_SET_NEXT_PACKET(pPrevPacket, pNdisPacket);
	}

	AA_SET_NEXT_PACKET(pNdisPacket, NULL);
}


VOID
AtmArpStartSendsOnVc(
	IN	PATMARP_VC					pVc		LOCKIN	NOLOCKOUT
)
/*++

Routine Description:

	Send all packets queued on a VC. It is assumed that there is
	a call active on the VC, and the Interface state is OK.

Arguments:

	pVc						- Pointer to ATMARP VC

Locks on entry:

	VC Lock.

Locks on exit:

	None

Return Value:

	None

--*/
{
	PNDIS_PACKET			pNdisPacket;
	PNDIS_PACKET			pNextNdisPacket;
	NDIS_HANDLE				NdisVcHandle;
	ULONG					rc;				// Ref Count to VC

	//
	//  Remove the entire list of packets queued on the VC.
	//
	pNdisPacket = pVc->PacketList;
	pVc->PacketList = (PNDIS_PACKET)NULL;


#ifdef VC_REFS_ON_SENDS
	//
	//  Reference the VC for all these packets.
	//
	{
		PNDIS_PACKET		pPacket;
		
		for (pPacket = pNdisPacket;
			 pPacket != NULL;
			 pPacket = AA_GET_NEXT_PACKET(pPacket))
		{
			AtmArpReferenceVc(pVc);	// StartSendsOnVc
			pVc->OutstandingSends++;// StartSendsOnVc
		}
	}
#else

	{
		PNDIS_PACKET		pPacket;
		
		for (pPacket = pNdisPacket;
			 pPacket != NULL;
			 pPacket = AA_GET_NEXT_PACKET(pPacket))
		{
			pVc->OutstandingSends++;// StartSendsOnVc (!VC_REFS_ON_SENDS)
		}
	}
#endif // VC_REFS_ON_SENDS

	AtmArpRefreshTimer(&(pVc->Timer));

	NdisVcHandle = pVc->NdisVcHandle;

	//
	//  We have got all that we need from the VC.
	//
	AA_RELEASE_VC_LOCK(pVc);

	while (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		pNextNdisPacket = AA_GET_NEXT_PACKET(pNdisPacket);
		AA_SET_NEXT_PACKET(pNdisPacket, NULL);

		AADEBUGP(AAD_EXTRA_LOUD+10, ("StartSendsOnVc: pVc 0x%x, Pkt 0x%x\n",
						pVc, pNdisPacket));

#ifdef PERF
		AadLogSendUpdate(pNdisPacket);
#endif // PERF
		NDIS_CO_SEND_PACKETS(
				NdisVcHandle,
				&pNdisPacket,
				1
				);
		
		pNdisPacket = pNextNdisPacket;
	}
}



VOID
AtmArpSendPacketListOnAtmEntry(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PNDIS_PACKET				pPacketList,
	IN	BOOLEAN						IsBroadcast
)
/*++

Routine Description:

	Send a list of packets towards a destination identified by an
	ATM Entry.

Arguments:

	pInterface				- Pointer to ATMARP Interface
	pAtmEntry				- ATM Entry on which the packets are to be sent
	pPacketList				- List of packets to be sent.
	IsBroadcast				- Are these directed to Class D/broadcast addresses?

Return Value:

	None

--*/
{
	PATMARP_FLOW_INFO			pFlowInfo;
	PATMARP_FLOW_SPEC			pFlowSpec;
	PATMARP_FILTER_SPEC			pFilterSpec;
	PNDIS_PACKET				pNdisPacket;
	PNDIS_PACKET				pNextNdisPacket;
	NDIS_STATUS					Status;


	for (pNdisPacket = pPacketList;
			pNdisPacket != (PNDIS_PACKET)NULL;
			pNdisPacket = pNextNdisPacket)
	{
		pNextNdisPacket = AA_GET_NEXT_PACKET(pNdisPacket);
		AA_SET_NEXT_PACKET(pNdisPacket, NULL);

		//
		//  Get the Filter and Flow specs for this packet
		//
		AA_GET_PACKET_SPECS(pInterface, pNdisPacket, &pFlowInfo, &pFlowSpec, &pFilterSpec);

		AADEBUGP(AAD_EXTRA_LOUD+10, ("PktListOnAtmEntry: AtmEntry 0x%x, Pkt 0x%x\n",
					pAtmEntry, pNdisPacket));

		//
		//  Send it off
		//
		AA_ACQUIRE_AE_LOCK(pAtmEntry);

		Status = AtmArpSendPacketOnAtmEntry(
							pInterface,
							pAtmEntry,
							pNdisPacket,
							pFlowSpec,
							pFilterSpec,
							pFlowInfo,
							IsBroadcast
							);
		//
		//  AE lock is released within the above.
		//
		if ((Status != NDIS_STATUS_PENDING) &&
			(Status != NDIS_STATUS_SUCCESS))
		{
			AADEBUGP(AAD_INFO, ("PktListOnAtmEntry: pIf %x, Pkt %x, Send failure %x\n",
						pInterface, pNdisPacket, Status));
			AtmArpFreeSendPackets(pInterface, pNdisPacket, FALSE);
		}
	}

	return;
}


PATMARP_IP_ENTRY
AtmArpLearnIPToAtm(
	IN	PATMARP_INTERFACE			pInterface,
	IN	IP_ADDRESS UNALIGNED *		pIPAddress,
	IN	UCHAR						AtmAddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmAddress,
	IN	UCHAR						AtmSubaddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmSubaddress,
	IN	BOOLEAN						IsStaticEntry
)
/*++

Routine Description:

	Learn an IP address to ATM address mapping. This is normally
	called when we receive an ARP reply from the ARP server.
	It may also be called to set up a static mapping.

	We take care of the case where either the IP address or the
	ATM address (or both) may already exist in the ARP Table: we
	only create the entries that are not present. For example, it
	is possible for multiple IP addresses to map to the same ATM
	address -- in this case, we might find an existing ATM entry
	for a new IP entry.

Arguments:

	pInterface				- Pointer to ATMARP Interface
	pIPAddress				- IP address
	AtmAddressTypeLength	- Type+Length (ARP packet format) for ATM address
	pAtmAddress				- ATM Number
	AtmSubaddressTypeLength	- Type+Length (ARP packet format) for ATM subaddress
	pAtmSubaddress			- ATM Subaddress
	IsStaticEntry			- Is this a static mapping?

Return Value:

	A pointer to the IP Entry that was learned/refreshed.

--*/
{
	PATMARP_IP_ENTRY			pIpEntry;	// Entry for this IP Address
	PATMARP_ATM_ENTRY			pAtmEntry;	// Entry for this ATM Address
	NDIS_STATUS					Status;
	BOOLEAN						TimerWasRunning;	// Was a timer running on IP Entry?
	ULONG						rc;			// Ref Count
	PNDIS_PACKET				pPacketList;// List of queued packets, if any
	BOOLEAN						IsBroadcast;// Is the IP address broadcast/multicast?

	AADEBUGP(AAD_LOUD, ("LearnIPToAtm: pIf 0x%x, IP Addr: %d:%d:%d:%d, ATM Addr:\n",
						pInterface,
						*((PUCHAR)pIPAddress),
						*((PUCHAR)pIPAddress+1),
						*((PUCHAR)pIPAddress+2),
						*((PUCHAR)pIPAddress+3)));

	AADEBUGPDUMP(AAD_LOUD, pAtmAddress, (AtmAddressTypeLength & ~AA_PKT_ATM_ADDRESS_BIT));

	//
	//  Initialize
	//
	Status = NDIS_STATUS_SUCCESS;
	pPacketList = (PNDIS_PACKET)NULL;
	IsBroadcast = FALSE;
	pIpEntry = NULL_PATMARP_IP_ENTRY;

	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

	//
	//  Get an ATM Entry. AtmArpSearchForAtmAddress addrefs
	//  the entry, so be sure to dereference it if
	//  we're not going to be using it.
	//
	pAtmEntry = AtmArpSearchForAtmAddress(
							pInterface,
							AtmAddressTypeLength,
							pAtmAddress,
							AtmSubaddressTypeLength,
							pAtmSubaddress,
							AE_REFTYPE_IE,
							TRUE		// Create new entry if not found
							);

	if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
	{
		AADEBUGPMAP(AAD_INFO, "Learnt", pIPAddress, &pAtmEntry->ATMAddress);

		//
		//  Now get an IP Address Entry. AtmArpSeachForIPAddress addrefs
		//  the entry, so be sure to deref it if we're not going to be
		// 	using it.
		//
		pIpEntry = AtmArpSearchForIPAddress(
							pInterface,
							pIPAddress,
							IE_REFTYPE_AE,
							FALSE,		// this isn't multicast/broadcast
							TRUE		// Create new entry if not found
							);

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			//
			//  Got both entries.
			//
			//  Check for conflict: if the IP Entry existed before, see if
			//  it is linked to a different ATM Entry. If so, we have a new
			//  mapping that violates an existing mapping. We discard this
			//  new information.
			//
			if (pIpEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY)
			{
				if (pIpEntry->pAtmEntry != pAtmEntry)
				{
					AADEBUGP(AAD_ERROR,
					("IP Entry 0x%x linked to ATM Entry 0x%x, new ATM Entry 0x%x\n",
							pIpEntry, pIpEntry->pAtmEntry, pAtmEntry));
	
					Status = NDIS_STATUS_FAILURE;
				}
				else
				{
					//
					//  An existing mapping has been reconfirmed.
					//
					AADEBUGP(AAD_INFO,
						("Revalidated IP Entry 0x%x, Addr: %d.%d.%d.%d, PktList 0x%x\n",
							pIpEntry,
							((PUCHAR)pIPAddress)[0],
							((PUCHAR)pIPAddress)[1],
							((PUCHAR)pIPAddress)[2],
							((PUCHAR)pIPAddress)[3],
							pIpEntry->PacketList
						));

					//
					//  Update IP Entry state.
					//
					AA_SET_FLAG(
							pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_RESOLVED);
					
					//
					//  Remove the list of packets queued on this entry.
					//
					pPacketList = pIpEntry->PacketList;
					pIpEntry->PacketList = (PNDIS_PACKET)NULL;


					if (pPacketList)
					{
						//
						// We'll be sending out these packets on the
						// atm entry, so better put a tempref on the atm
						// entry now. It is derefed when the packet
						// list is finished being sent on the atm entry.
						//
						AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);
						AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);// Temp ref: Pkt list.
						AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
					}

					//
					//  We will start the IP Entry aging timer on this
					//  entry.
					//

					//
					//  Stop the Address resolution timer running here
					//
					TimerWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);

					if (TimerWasRunning)
					{
						rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER); // timer ref.
						AA_ASSERT(rc != 0);
					}

					//
					//  Start the Aging timer.
					//
					AtmArpStartTimer(
						pInterface,
						&(pIpEntry->Timer),
						AtmArpIPEntryAgingTimeout,
						pInterface->ARPEntryAgingTimeout,
						(PVOID)pIpEntry
						);

					//
					// Altough we got the initial ref in SearchForIPAddress
					// for IE_REFTYPE_AE, we're actually using it for
					// the timer reference. So we need to switch the reftype
					// here...
					//
					// This reftype stuff is just for tracking purposes.
					//
					AA_SWITCH_IE_REFTYPE(
						pIpEntry,
						IE_REFTYPE_AE,
					 	IE_REFTYPE_TIMER
						);

				}
			}
			else
			{
				//
				//  This IP Entry wasn't mapped to an ATM Entry previously.
				//  Link entries together: first, make the IP entry point
				//  to this ATM Entry.
				//
				AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);

				//
				// Check if this is still a valid entry....
				//
				if (AA_IS_FLAG_SET(
							pAtmEntry->Flags,
							AA_ATM_ENTRY_STATE_MASK,
							AA_ATM_ENTRY_CLOSING))
				{
					AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
					Status = NDIS_STATUS_FAILURE;
				}
				else
				{

					pIpEntry->pAtmEntry = pAtmEntry;
	
					AA_SET_FLAG(
							pAtmEntry->Flags,
							AA_ATM_ENTRY_STATE_MASK,
							AA_ATM_ENTRY_ACTIVE);
	
					//
					//  Add the IP Entry to the ATM Entry's list of IP Entries
					//  (multiple IP entries could point to the same ATM Entry).
					//
					pIpEntry->pNextToAtm = pAtmEntry->pIpEntryList;
					pAtmEntry->pIpEntryList = pIpEntry;

					//
					//  Remove the list of packets queued on this IP entry.
					//
					pPacketList = pIpEntry->PacketList;
					pIpEntry->PacketList = (PNDIS_PACKET)NULL;

					if (pPacketList)
					{
						AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);// Temp ref: Pkt list.
					}
	
					AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
	
	
					//
					//  Update IP Entry state.
					//
					AA_SET_FLAG(
							pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_RESOLVED);
	
					TimerWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);
					if (TimerWasRunning)
					{
						ULONG		IeRefCount;
						IeRefCount = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer reference
						AA_ASSERT(IeRefCount > 0);
					}
	
	
					IsBroadcast = AA_IS_FLAG_SET(pIpEntry->Flags,
 												AA_IP_ENTRY_ADDR_TYPE_MASK,
 												AA_IP_ENTRY_ADDR_TYPE_NUCAST);
	
					if (IsStaticEntry)
					{
						pIpEntry->Flags |= AA_IP_ENTRY_IS_STATIC;
	
					}
					else
					{
						//
						//  Start the aging timer on this IP Entry.
						//
						AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpIPEntryAgingTimeout,
							pInterface->ARPEntryAgingTimeout,
							(PVOID)pIpEntry
							);

						AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer reference
	
					}
				}
			}

			AA_RELEASE_IE_LOCK_DPC(pIpEntry);
		}
		else
		{
			//
			//  Failed to locate/allocate IP Entry
			//
			Status = NDIS_STATUS_RESOURCES;
		}
	}
	else
	{
		//
		//  Failed to locate/allocate ATM Entry
		//
		Status = NDIS_STATUS_RESOURCES;
	}

	AA_RELEASE_IF_TABLE_LOCK(pInterface);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		//
		//  If we have any queued packets to send, send them now.
		//
		if (pPacketList != (PNDIS_PACKET)NULL)
		{
			AtmArpSendPacketListOnAtmEntry(
					pInterface,
					pAtmEntry,
					pPacketList,
					IsBroadcast
					);
			
			AA_ACQUIRE_AE_LOCK(pAtmEntry);
			rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP); // Send pkt list.
			if (rc>0)
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
			}
		}
	}
	else
	{
		if (pIpEntry)
		{
			AA_ACQUIRE_IE_LOCK(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE); // LearnIPAtm
			if (rc>0)
			{
				AA_RELEASE_IE_LOCK(pIpEntry);
			}
		}

		if (pAtmEntry)
		{
			AA_ACQUIRE_AE_LOCK(pAtmEntry);
			rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_IE); // LearnIPAtm
			if (rc>0)
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
			}
		}

		//
		//  Prepare the return value.
		//
		pIpEntry = NULL_PATMARP_IP_ENTRY;
	}

	return (pIpEntry);
}



NDIS_STATUS
AtmArpQueuePacketOnIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Queue a packet on an unresolved IP Entry, unless one of the following
	conditions holds:

	- We recently got an ARP NAK while trying to resolve this entry. In this
	  case, there is no point in queueing up this packet and sending another
	  ARP Request, because we might immediately get back another NAK.

	If we did queue this packet, we check if address resolution is in progress
	on this entry. If not, start it.

Arguments:

	pIpEntry					- Pointer to ATMARP IP Entry
	pNdisPacket					- Packet to be queued

Locks on entry:

	IP Entry

Locks on exit:

	None

Return Value:

	NDIS_STATUS_PENDING if we did queue the packet, NDIS_STATUS_FAILURE
	otherwise.

--*/
{
	PATMARP_INTERFACE		pInterface;
	PNDIS_PACKET			pPrevPacket;	// For queueing this packet
	NDIS_STATUS				Status;			// Return value
	IP_ADDRESS				SrcIPAddress;	// For ARP Request, if required
	IP_ADDRESS				DstIPAddress;	// For ARP Request, if required


	pInterface = pIpEntry->pInterface;

	//
	//  Check if this IP address has experienced an ARP NAK recently.
	//  If not, we queue this packet, else we discard it.
	//
	//  We also make sure that the ip entry is in ARP table (it had better be,
	//  but it's possible that we enter this code path just after the ip
	// entry has been).
	//
	if (!AA_IS_FLAG_SET(pIpEntry->Flags,
						AA_IP_ENTRY_STATE_MASK,
						AA_IP_ENTRY_SEEN_NAK)
		&& AA_IE_IS_ALIVE(pIpEntry))
	{
		//
		//  Queue the packet.
		//
		if (pIpEntry->PacketList == (PNDIS_PACKET)NULL)
		{
			//
			//  No packets on this IP Entry.
			//
			pIpEntry->PacketList = pNdisPacket;
		}
		else
		{
			//
			//  Go to the end of the packet list on this IP Entry.
			//
			pPrevPacket = pIpEntry->PacketList;
			while (AA_GET_NEXT_PACKET(pPrevPacket) != (PNDIS_PACKET)NULL)
			{
				pPrevPacket = AA_GET_NEXT_PACKET(pPrevPacket);
			}
	
			//
			//  Found the last packet in the list. Chain this packet
			//  to it.
			//
			AA_SET_NEXT_PACKET(pPrevPacket, pNdisPacket);
		}
		AA_SET_NEXT_PACKET(pNdisPacket, NULL);

		Status = NDIS_STATUS_PENDING;

		//
		//  If needed, start resolving this IP address.
		//
		AtmArpResolveIpEntry(pIpEntry);
		//
		//  The IE Lock is released within the above.
		//
	}
	else
	{
		//
		//  We have seen an ARP NAK for this IP address recently, or
		//  this pIpEntry is not alive.
		//  Drop this packet.
		//
		AA_RELEASE_IE_LOCK(pIpEntry);
		Status = NDIS_STATUS_FAILURE;
	}

	return (Status);
}

BOOLEAN
AtmArpAtmEntryIsReallyClosing(
	PATMARP_ATM_ENTRY			pAtmEntry
)
{
	BOOLEAN fRet = FALSE;

	if (AA_IS_FLAG_SET(
				pAtmEntry->Flags,
				AA_ATM_ENTRY_STATE_MASK,
				AA_ATM_ENTRY_CLOSING))
	{
		AADEBUGP(AAD_INFO, ("IsReallyClosing -- ENTRY (0x%08lx) is CLOSING\n",
			pAtmEntry));

		//
		// Decide whether we want to clear the CLOSING state here..
		// We clear the closing state because we saw a case where the
		// entry was permanently in the closing state (a ref count problem).
		// So we will clear this state if it is basically an idle entry,
		// so that it may be reused.
		//

		if (   pAtmEntry->pIpEntryList == NULL
			&& pAtmEntry->pVcList == NULL
			&& (   pAtmEntry->pMcAtmInfo == NULL
			    || pAtmEntry->pMcAtmInfo->pMcAtmMigrateList == NULL))
		{
			AADEBUGP(AAD_INFO,
 			("IsReallyClosing -- ENTRY (0x%08lx) CLEARING CLOSING STATE\n",
			pAtmEntry));
			AA_SET_FLAG(
					pAtmEntry->Flags,
					AA_ATM_ENTRY_STATE_MASK,
					AA_ATM_ENTRY_ACTIVE);
		}
		else
		{
			fRet = TRUE;
		}
	}

	return fRet;
}

PATMARP_ATM_ENTRY
AtmArpSearchForAtmAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	UCHAR						AtmAddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmAddress,
	IN	UCHAR						AtmSubaddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmSubaddress,
	IN	AE_REFTYPE					RefType,
	IN	BOOLEAN						CreateNew
)
/*++

Routine Description:

	Search for an ATM Entry that matches the given ATM number+subaddress.
	Optionally, create one if there is no match.

	The caller is assumed to hold a lock to the IF Table.

Arguments:

	pInterface				- Pointer to ATMARP Interface
	AtmAddressTypeLength	- Type+Length (ARP packet format) for the ATM number
	pAtmAddress				- ATM Number
	AtmSubaddressTypeLength	- Type+Length (ARP packet format) for the ATM subaddress
	pAtmSubaddress			- ATM Subaddress
	CreateNew				- Do we create a new entry if we don't find one?
	RefType					- Type of reference

Return Value:

	Pointer to a matching ATM Entry if found (or created anew).

--*/
{
	PATMARP_ATM_ENTRY			pAtmEntry;
	BOOLEAN						Found;

	ATM_ADDRESSTYPE				AddressType;
	ULONG						AddressLen;
	ATM_ADDRESSTYPE				SubaddressType;
	ULONG						SubaddressLen;


	AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(AtmAddressTypeLength, &AddressType, &AddressLen);
	AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(AtmSubaddressTypeLength, &SubaddressType, &SubaddressLen);

	AA_ACQUIRE_IF_ATM_LIST_LOCK(pInterface);


	//
	//  Go through the list of ATM Entries on this interface, provided the
	//  list is "up." The list is not up when shutting down the interface.
	//

	Found = FALSE;

	if (pInterface->AtmEntryListUp)
	{
		pAtmEntry = pInterface->pAtmEntryList;
	}
	else
	{
		pAtmEntry = NULL;
	}

	for (; pAtmEntry != NULL_PATMARP_ATM_ENTRY; pAtmEntry = pAtmEntry->pNext)
	{
		//
		//  Compare the ATM Addresses
		//
		if ((AddressType == pAtmEntry->ATMAddress.AddressType) &&
			(AddressLen == pAtmEntry->ATMAddress.NumberOfDigits) &&
			(AA_MEM_CMP(pAtmAddress, pAtmEntry->ATMAddress.Address, AddressLen) == 0))
		{
			//
			//  Compare the Subaddress parts
			//
			if ((SubaddressType == pAtmEntry->ATMSubaddress.AddressType) &&
				(SubaddressLen == pAtmEntry->ATMSubaddress.NumberOfDigits) &&
				(AA_MEM_CMP(pAtmSubaddress, pAtmEntry->ATMSubaddress.Address, SubaddressLen) == 0))
			{
				Found = TRUE;

				//
				// WARNING: AtmArpAtmEntryIsReallyClosing may clear the
				// CLOSING state (if the entry is basically idle) --
				// see comments in that function.
				//
				if (AtmArpAtmEntryIsReallyClosing(pAtmEntry))
				{
					//
					// We don't allow creating a new entry in this case...
					//
					CreateNew = FALSE;
					pAtmEntry = NULL;
					Found = FALSE;
				}


				break;
			}
		}
	}

	if (!Found && CreateNew && pInterface->AtmEntryListUp)
	{
		pAtmEntry = AtmArpAllocateAtmEntry(
							pInterface,
							FALSE		// Not multicast
							);

		if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
		{
			//
			//  Fill in this new entry.
			//
			pAtmEntry->Flags = AA_ATM_ENTRY_ACTIVE;

			//
			//  The ATM Address.
			//
			pAtmEntry->ATMAddress.AddressType = AddressType;
			pAtmEntry->ATMAddress.NumberOfDigits = AddressLen;
			AA_COPY_MEM(pAtmEntry->ATMAddress.Address,
						pAtmAddress,
						AddressLen);
			
			//
			//  The ATM Subaddress.
			//
			pAtmEntry->ATMSubaddress.AddressType = SubaddressType;
			pAtmEntry->ATMSubaddress.NumberOfDigits = SubaddressLen;
			AA_COPY_MEM(pAtmEntry->ATMSubaddress.Address,
						pAtmSubaddress,
						SubaddressLen);

			//
			//  Link in this entry to the Interface
			//
			pAtmEntry->pNext = pInterface->pAtmEntryList;
			pInterface->pAtmEntryList = pAtmEntry;
		}
	}

	if (pAtmEntry)
	{
		AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);
		AA_REF_AE(pAtmEntry,RefType);	//  AtmArpSearchForAtmAddress
		AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
	}

	AA_RELEASE_IF_ATM_LIST_LOCK(pInterface);

	AADEBUGP(AAD_VERY_LOUD, ("SearchForAtm: returning (%s) ATM Entry 0x%x for addr:\n",
				(Found? "Old": "New"), pAtmEntry));
	AADEBUGPDUMP(AAD_VERY_LOUD, pAtmAddress, AddressLen);
	return (pAtmEntry);
}



PATMARP_IP_ENTRY
AtmArpSearchForIPAddress(
	PATMARP_INTERFACE				pInterface,
	IP_ADDRESS UNALIGNED *			pIPAddress,
	IE_REFTYPE						RefType,
	BOOLEAN							IsMulticast,
	BOOLEAN							CreateNew
)
/*++

Routine Description:

	Search for an IP Address in the ARP Table. Optionally, create one
	if a match is not found.

	The caller is assumed to hold a lock to the IF Table.

Arguments:

	pInterface				- Pointer to ATMARP Interface
	pIPAddress				- what we are looking for
	IsMulticast				- Is this IP address broadcast or multicast?
	RefType					- Type of reference to use when we addref the entry.
	CreateNew				- Should a new entry be created if no match?

Return Value:

	Pointer to a matching IP Entry if found (or created anew).

--*/
{
	ULONG					HashIndex;
	PATMARP_IP_ENTRY		pIpEntry;
	BOOLEAN					Found;
#ifdef IPMCAST
	PATMARP_ATM_ENTRY		pAtmEntry;
	IP_ADDRESS				IPAddressValue;
	PATMARP_IP_ENTRY *		ppIpEntry;
#endif // IPMCAST

	HashIndex = ATMARP_HASH(*pIPAddress);
	Found = FALSE;

	pIpEntry = pInterface->pArpTable[HashIndex];

	//
	//  Go through the addresses in this hash list.
	//
	while (pIpEntry != NULL_PATMARP_IP_ENTRY)
	{
		if (IP_ADDR_EQUAL(pIpEntry->IPAddress, *pIPAddress))
		{
			Found = TRUE;
			break;
		}
		pIpEntry = pIpEntry->pNextEntry;
	}

	if (!Found && CreateNew && pInterface->ArpTableUp)
	{
		do
		{
			pIpEntry = AtmArpAllocateIPEntry(pInterface);

			if (pIpEntry == NULL_PATMARP_IP_ENTRY)
			{
				break;
			}
#ifdef IPMCAST
			if (IsMulticast)
			{
				AAMCDEBUGP(AAD_INFO,
				("SearchForIpAddr: Creating new MC IP Entry 0x%x for Addr %d.%d.%d.%d\n",
							pIpEntry,
							((PUCHAR)pIPAddress)[0],
							((PUCHAR)pIPAddress)[1],
							((PUCHAR)pIPAddress)[2],
							((PUCHAR)pIPAddress)[3]));

				pIpEntry->Flags |= AA_IP_ENTRY_ADDR_TYPE_NUCAST;


				//
				//  Also link this IP Entry into the per-Interface list
				//  of multicast addresses. This is sorted in ascending
				//  order of "IP Address value", to help processing
				//  <Min, Max> pairs of addresses in JOIN/LEAVE messages.
				//
				IPAddressValue = NET_LONG(*pIPAddress);

				//
				//  Find the place to insert this entry at.
				//
				for (ppIpEntry = &(pInterface->pMcSendList);
 					 *ppIpEntry != NULL_PATMARP_IP_ENTRY;
 					 ppIpEntry = &((*ppIpEntry)->pNextMcEntry))
				{
					if (NET_LONG((*ppIpEntry)->IPAddress) > IPAddressValue)
					{
						//
						//  Found it.
						//
						break;
					}
				}
				pIpEntry->pNextMcEntry = *ppIpEntry;
				*ppIpEntry = pIpEntry;
			}
			else
			{
				AAMCDEBUGP(AAD_INFO,
				("SearchForIpAddr: Creating new UNI IP Entry 0x%x for Addr %d.%d.%d.%d\n",
							pIpEntry,
							((PUCHAR)pIPAddress)[0],
							((PUCHAR)pIPAddress)[1],
							((PUCHAR)pIPAddress)[2],
							((PUCHAR)pIPAddress)[3]));
			}

#endif // IPMCAST
			//
			//  Fill in the rest of the IP entry.
			//
			pIpEntry->IPAddress = *pIPAddress;

			//
			// This signifies that it is in the arp table.
			//
			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_STATE_MASK,
						AA_IP_ENTRY_IDLE2);

			AA_REF_IE(pIpEntry, IE_REFTYPE_TABLE);		// ARP Table linkage

			//
			//  Link it to the hash table.
			//
			pIpEntry->pNextEntry = pInterface->pArpTable[HashIndex];
			pInterface->pArpTable[HashIndex] = pIpEntry;
			pInterface->NumOfArpEntries++;

			break;
		}
		while (FALSE);

	} // if creating new

	if (pIpEntry)
	{
		AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
		AA_REF_IE(pIpEntry, RefType);	 // AtmArpSearchForIPAddress
		AA_RELEASE_IE_LOCK_DPC(pIpEntry);
	}

	AADEBUGP(AAD_LOUD,
		 ("Search for IP Addr: %d.%d.%d.%d, hash ind %d, Found %d, IPEnt 0x%x\n",
					((PUCHAR)pIPAddress)[0],
					((PUCHAR)pIPAddress)[1],
					((PUCHAR)pIPAddress)[2],
					((PUCHAR)pIPAddress)[3],
					HashIndex, Found, pIpEntry));

	return (pIpEntry);
	
}


VOID
AtmArpAbortIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
)
/*++

Routine Description:

	Clean up and delete an IP entry. This is called when we invalidate
	an ARP mapping.

	NOTE: The caller is assumed to hold a lock to the IP Entry,
	which will be released here.

Arguments:

	pIpEntry		- Pointer to IP Entry to be deleted.

Return Value:

	None

--*/
{
	PATMARP_INTERFACE	pInterface;
	PATMARP_IP_ENTRY *	ppNextIpEntry;
	PATMARP_ATM_ENTRY	pAtmEntry;
	RouteCacheEntry *	pRCE;
	PNDIS_PACKET		PacketList;
	ULONG				rc;				// Ref Count on IP Entry.
	BOOLEAN				IsMulticastIpEntry;
	BOOLEAN				Found;
	BOOLEAN				TimerWasRunning;
	BOOLEAN				IfTableLockReleased;

	ULONG				HashIndex;		// For this IP Entry in ARP Table

	AADEBUGP(AAD_INFO,
		 ("Abort IP entry 0x%x, Flags 0x%x, ATM Entry 0x%x, IP Addr %d:%d:%d:%d\n",
						 pIpEntry,
						 pIpEntry->Flags,
						 pIpEntry->pAtmEntry,
						 ((PUCHAR)&(pIpEntry->IPAddress))[0],
						 ((PUCHAR)&(pIpEntry->IPAddress))[1],
						 ((PUCHAR)&(pIpEntry->IPAddress))[2],
						 ((PUCHAR)&(pIpEntry->IPAddress))[3]
						));

	//
	//  Initialize.
	//
	rc = pIpEntry->RefCount;
	pInterface = pIpEntry->pInterface;
#ifdef IPMCAST
	IsMulticastIpEntry = (AA_IS_FLAG_SET(pIpEntry->Flags,
							AA_IP_ENTRY_ADDR_TYPE_MASK,
							AA_IP_ENTRY_ADDR_TYPE_NUCAST));
#endif
	IfTableLockReleased = FALSE;

	//
	//  Reacquire the desired locks in the right order.
	//
	AA_RELEASE_IE_LOCK(pIpEntry);
	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

	//
	//  Remove any packets queued on this IP Entry.
	//
	PacketList = pIpEntry->PacketList;
	pIpEntry->PacketList = (PNDIS_PACKET)NULL;

	do
	{
#ifdef IPMCAST
		//
		//  If this is a Non-unicast entry, unlink it from the list
		//  of Multicast IP Entries on this Interface.
		//
		if (IsMulticastIpEntry)
		{
			for (ppNextIpEntry = &(pInterface->pMcSendList);
 				 *ppNextIpEntry != NULL_PATMARP_IP_ENTRY;
 				 ppNextIpEntry = &((*ppNextIpEntry)->pNextMcEntry))
 			{
 				if (*ppNextIpEntry == pIpEntry)
 				{
 					//
 					//  Unlink it.
 					//
 					*ppNextIpEntry = pIpEntry->pNextMcEntry;
 					break;
 				}
 			}

 			AAMCDEBUGP(AAD_VERY_LOUD,
 				("AbortIPEntry (MC): pIpEntry 0x%x: unlinked from MC list\n", pIpEntry));
		}
#endif // IPMCAST

		//
		//  Unlink this IP Entry from all Route Cache Entries
		//  that point to it.
		//
		pRCE = pIpEntry->pRCEList;
		while (pRCE != (RouteCacheEntry *)NULL)
		{
			Found = AtmArpUnlinkRCE(pRCE, pIpEntry);
			AA_ASSERT(Found);

			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_RCE);	// RCE linkage ref
			if (rc > 0)
			{
				pRCE = pIpEntry->pRCEList;
			}
			else
			{
				pRCE = (RouteCacheEntry *)NULL;
			}
		}

		if (rc == 0)
		{
			//  The IP Entry is gone.
			break;
		}

		//
		//  Stop any timer running on the IP Entry.
		//
		TimerWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);

		if (TimerWasRunning)
		{
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref
			if (rc == 0)
			{
				break;
			}
		}

		//
		//  Unlink this IP Entry from the ARP Table, if needed.
		//
		Found = FALSE;

		HashIndex = ATMARP_HASH(pIpEntry->IPAddress);
		ppNextIpEntry = &(pInterface->pArpTable[HashIndex]);
		while (*ppNextIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			if (*ppNextIpEntry == pIpEntry)
			{
				//
				//  Make the predecessor point to the next
				//  in the list.
				//
				*ppNextIpEntry = pIpEntry->pNextEntry;
				Found = TRUE;
				pInterface->NumOfArpEntries--;

				//
				// Once it's off the arp table, we set the flag to IDLE.
				//
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_IDLE);
				break;
			}
			else
			{
				ppNextIpEntry = &((*ppNextIpEntry)->pNextEntry);
			}
		}

		if (Found)
		{
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TABLE);	// ARP Table ref
			if (rc == 0)
			{
				break;
			}
		}

		//
		//  Do this last:
		//  ------------
		//  If this IP Entry is linked to an ATM Entry, unlink it.
		//  If this is a multicast ATM entry, shut down the ATM Entry, too.
		//
		pAtmEntry = pIpEntry->pAtmEntry;
		if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
		{
#ifdef IPMCAST
			BOOLEAN			IsMulticastAtmEntry;

			pIpEntry->pAtmEntry = NULL;

			AA_ACQUIRE_AE_LOCK(pAtmEntry);

			IsMulticastAtmEntry = AA_IS_FLAG_SET(pAtmEntry->Flags,
												 AA_ATM_ENTRY_TYPE_MASK,
												 AA_ATM_ENTRY_TYPE_NUCAST);
			if (IsMulticastAtmEntry)
			{
				//
				//  We do this because we'll access the ATM
				//  Entry below, but only for the PMP case.
				//
				AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);	// Temp ref: Abort IP Entry
			}
#else
			AA_ACQUIRE_AE_LOCK(pAtmEntry);
#endif // IPMCAST
		
			//
			//  Locate the position of this IP Entry in the ATM Entry's list.
			//


			ppNextIpEntry = &(pAtmEntry->pIpEntryList);
		
			while (*ppNextIpEntry != NULL && *ppNextIpEntry != pIpEntry)
			{
				ppNextIpEntry = &((*ppNextIpEntry)->pNextToAtm);
			}
		
			if (*ppNextIpEntry == pIpEntry)
			{
				//
				//  Make the predecessor point to the next entry.
				//
				*ppNextIpEntry = pIpEntry->pNextToAtm;
			
				rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_IE);	// IP Entry ref
	
				if (rc != 0)
				{
					AA_RELEASE_AE_LOCK(pAtmEntry);
				}

				rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE);	// ATM Entry linkage ref
				if (rc != 0)
				{
					AA_ASSERT (FALSE);	// we expect rc to be 0, but could be a  tmp ref.
					AA_RELEASE_IE_LOCK(pIpEntry);
				}
			}
			else
			{
				//
				// We didn't find this IP entry in the atm entry list!
				// Presumably the linkage has been broken by some other
				// path (probably AtmArpInvalidateAtmEntry) while we were
				// in this function.
				//
				// We don't deref here because these two are now not linked.
				//
				//
				AA_RELEASE_AE_LOCK(pAtmEntry);
				AA_RELEASE_IE_LOCK(pIpEntry);
			}

			//
			//  IE Lock would have been released above.
			//
			AA_RELEASE_IF_TABLE_LOCK(pInterface);
			IfTableLockReleased = TRUE;

#ifdef IPMCAST
			//
			//  If this was a multicast entry, shut down the ATM Entry
			//
			if (IsMulticastAtmEntry)
			{
				AA_ACQUIRE_AE_LOCK(pAtmEntry);
				rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);	// Temp ref: Abort IP Entry
				if (rc != 0)
				{
					AtmArpInvalidateAtmEntry(pAtmEntry, FALSE);
					//
					//  AE Lock is released within the above.
					//
				}
			}
#endif // IPMCAST

		}
		else
		{
			//
			//  No ATM entry linked to this IP entry.
			//
			AA_RELEASE_IE_LOCK(pIpEntry);
			break;
		}

		break;
	}
	while (FALSE);


	if (!IfTableLockReleased)
	{
		AA_RELEASE_IF_TABLE_LOCK(pInterface);
	}

	//
	//  Free all packets that were queued on the IP Entry.
	//
	AtmArpFreeSendPackets(
				pInterface,
				PacketList,
				FALSE			// No LLC/SNAP header on these
				);

	return;
}



VOID
AtmArpInvalidateAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	BOOLEAN						ShuttingDown
)
/*++

Routine Description:

	Invalidate an ATM Entry by unlinking it from IP entries.

	Typical situation:

	A non-normal communication problem has been detected on a Vc going to
	this ATM destination. The RFC says that we need to invalidate all IP
	entries for this destination, and let them get re-resolved before sending
	any traffic to them. We implement this by unlinking this ATM entry from
	all IP entries it is linked to. Each such IP entry will get re-resolved
	if+when we try to send a packet to it.

	The only exceptions are IP Entries that have been statically mapped
	to this ATM Entry: we don't unlink these, unless we are shutting down
	now, as indicated by "ShuttingDown".

	If we end up with no IP Entries pointing to this ATM Entry, we close all
	SVCs linked to the ATM Entry. If ShuttingDown is TRUE, we close all PVCs
	as well.

Arguments:

	pAtmEntry		- The ATM Entry needing invalidating.
	ShuttingDown	- TRUE iff the interface is being shut down.

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;
	PATMARP_IP_ENTRY		pNextIpEntry;
	ULONG					rc;			// Ref Count of ATM Entry
	INT						IPEntriesUnlinked;
	PATMARP_IP_ENTRY		pStaticIpEntryList;	// List of static IP Entries

	AA_STRUCT_ASSERT(pAtmEntry, aae);

	AADEBUGP(AAD_INFO,
		("InvalidateAtmEntry: pAtmEntry 0x%x, Flags 0x%x, ShutDown %d, pIpEntryList 0x%x\n",
				pAtmEntry,
				pAtmEntry->Flags,
				ShuttingDown,
				pAtmEntry->pIpEntryList));

#ifndef PROTECT_ATM_ENTRY_IN_CLOSE_CALL
	//
	//  Check if we are already closing this ATM Entry. If so,
	//  we don't do anything here.
	//
	if (AA_IS_FLAG_SET(
				pAtmEntry->Flags,
				AA_ATM_ENTRY_STATE_MASK,
				AA_ATM_ENTRY_CLOSING))
	{
		AA_RELEASE_AE_LOCK(pAtmEntry);
		return;
	}

	//
	//  Mark this ATM Entry so that we don't use it anymore.
	//
	AA_SET_FLAG(pAtmEntry->Flags,
				AA_ATM_ENTRY_STATE_MASK,
				AA_ATM_ENTRY_CLOSING);

#endif // PROTECT_ATM_ENTRY_IN_CLOSE_CALL

	//
	//  Initialize.
	//
	pStaticIpEntryList = NULL_PATMARP_IP_ENTRY;
	IPEntriesUnlinked = 0;

	//
	//  Take the IP Entry list out of the ATM Entry.
	//
	pIpEntry = pAtmEntry->pIpEntryList;
	pAtmEntry->pIpEntryList = NULL_PATMARP_IP_ENTRY;

#ifdef IPMCAST
	//
	//  Delete the Migrate list, if any.
	//
	if (AA_IS_FLAG_SET(pAtmEntry->Flags,
						AA_ATM_ENTRY_TYPE_MASK,
						AA_ATM_ENTRY_TYPE_NUCAST))
	{
		PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
		PATMARP_IPMC_ATM_ENTRY		pNextMcAtmEntry;

		for (pMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmMigrateList;
			 pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
			 pMcAtmEntry = pNextMcAtmEntry)
		{
			pNextMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;
			AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pMcAtmEntry->Timer));
			AA_CHECK_TIMER_IN_ACTIVE_LIST(&pMcAtmEntry->Timer, pAtmEntry->pInterface, pMcAtmEntry, "MC ATM Entry");
			AA_FREE_MEM(pMcAtmEntry);
		}

		pAtmEntry->pMcAtmInfo->pMcAtmMigrateList = NULL_PATMARP_IPMC_ATM_ENTRY;
	}
#endif // IPMCAST

	//
	//  We let go of the ATM Entry lock here because we'll need
	//  to lock each IP Entry in the above list, and we need to make
	//  sure that we don't deadlock.
	//
	//  However, we make sure that the ATM Entry doesn't go away
	//  by adding a reference to it.
	//
	AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);	// Temp ref
	AA_RELEASE_AE_LOCK(pAtmEntry);

	//
	//  Now, unlink all IP entries that are "dynamic", and filter
	//  out a list of static mappings.
	//
	while (pIpEntry != NULL_PATMARP_IP_ENTRY)
	{
		AA_ACQUIRE_IE_LOCK(pIpEntry);
		AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
		pNextIpEntry = pIpEntry->pNextToAtm;

		if (ShuttingDown || (!AA_IS_FLAG_SET(pIpEntry->Flags,
								AA_IP_ENTRY_TYPE_MASK,
								AA_IP_ENTRY_IS_STATIC)))
		{

			AADEBUGP(AAD_INFO,
		 ("InvalidateATMEntry: Unlinking IP entry 0x%x, Flags 0x%x, ATM Entry 0x%x, IP Addr %d:%d:%d:%d; rc=%lu\n",
						 pIpEntry,
						 pIpEntry->Flags,
						 pIpEntry->pAtmEntry,
						 ((PUCHAR)&(pIpEntry->IPAddress))[0],
						 ((PUCHAR)&(pIpEntry->IPAddress))[1],
						 ((PUCHAR)&(pIpEntry->IPAddress))[2],
						 ((PUCHAR)&(pIpEntry->IPAddress))[3],
						 pIpEntry->RefCount
						));

			//
			//  Remove the mapping.
			//
			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_STATE_MASK,
						AA_IP_ENTRY_IDLE2);

			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_MC_RESOLVE_MASK,
						AA_IP_ENTRY_MC_IDLE);
			pIpEntry->pAtmEntry = NULL_PATMARP_ATM_ENTRY;
			pIpEntry->pNextToAtm = NULL_PATMARP_IP_ENTRY;

			//
			//  Stop any active timer on the IP entry now that we have clobbered
			//  its state.
			//
			if (AtmArpStopTimer(&pIpEntry->Timer, pIpEntry->pInterface))
			{
				ULONG	IpEntryRc;

				IpEntryRc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);
				AA_ASSERT(IpEntryRc != 0);
			}

			//
			//  Remove the ATM Entry linkage reference.
			//
			if (AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE) != 0)
			{
				AA_RELEASE_IE_LOCK(pIpEntry);
			}
			//
			//  else the IP Entry is gone
			//

			IPEntriesUnlinked++;
		}
		else
		{
			//
			//  Static ARP entry, retain it.
			//
			pIpEntry->pNextToAtm = pStaticIpEntryList;
			pStaticIpEntryList = pIpEntry;
			AA_RELEASE_IE_LOCK(pIpEntry);
		}
		pIpEntry = pNextIpEntry;
	}

	AA_ACQUIRE_AE_LOCK(pAtmEntry);

	//
	//  Put back the static IP entries on the ATM Entry.
	//
	AA_ASSERT(pAtmEntry->pIpEntryList == NULL_PATMARP_IP_ENTRY);
	pAtmEntry->pIpEntryList = pStaticIpEntryList;

	//
	//  Now dereference the ATM Entry as many times as we unlinked
	//  IP Entries from it.
	//
	rc = pAtmEntry->RefCount;
	while (IPEntriesUnlinked-- > 0)
	{
		rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_IE);	// IP Entry ref
	}
	AA_ASSERT(rc != 0);

	//
	//  Take out the reference we added at the beginning of
	//  this routine.
	//
	rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);	// Temp ref

	//
	//  Now, the only IP Entries pointing at this ATM Entry would be
	//  static entries. If there are no such IP entries, close all SVCs
	//  attached to the ATM Entry. But do all this only if the ATM Entry
	//  hasn't been dereferenced away already.
	//
	if (rc != 0)
	{
		//
		//  The ATM Entry still exists.
		//

		AADEBUGP(AAD_LOUD,
		 ("InvalidateAtmEntry: nonzero rc on exit.\n"
		  "\t pAE=0x%x; rc=%lu; pIpList=0x%x\n",
		  pAtmEntry,
		  pAtmEntry->RefCount,
		  pAtmEntry->pIpEntryList
		  ));

		if (pAtmEntry->pIpEntryList == NULL_PATMARP_IP_ENTRY)
		{
			//
			//  No IP Entries pointing to this ATM Entry.
			//
			AtmArpCloseVCsOnAtmEntry(pAtmEntry, ShuttingDown);
			//
			//  The ATM Entry lock is released within the above.
			//
		}
		else
		{
			AADEBUGP(AAD_LOUD,
				("InvalidateAtmEnt: AtmEnt %x has nonempty IP list %x, reactivating\n",
					pAtmEntry, pAtmEntry->pIpEntryList));

			AA_SET_FLAG(
					pAtmEntry->Flags,
					AA_ATM_ENTRY_STATE_MASK,
					AA_ATM_ENTRY_ACTIVE);

			AA_RELEASE_AE_LOCK(pAtmEntry);
		}
	}
	//
	//  else the ATM Entry is gone
	//

	return;
}



VOID
AtmArpCloseVCsOnAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry		LOCKIN NOLOCKOUT,
	IN	BOOLEAN						ShuttingDown
)
/*++

Routine Description:

	Go through the list of VCs chained to an ATM Entry, and close all
	VCs that are SVCs. If the interface is being shut down, close all
	PVCs as well.

	NOTE: the caller is assumed to hold a lock to the ATM Entry,
	which will be released here.

Arguments:

	pAtmEntry			- Pointer to ATM Entry on which we want to close SVCs.
	ShuttingDown		- TRUE iff the interface is being shut down.

Return Value:

	None

--*/
{
	PATMARP_VC		pVc;		// Used to walk the list of VCs on the ATM Entry
	PATMARP_VC		pCloseVcList;	// List of VCs on the ATM Entry to be closed
	PATMARP_VC		*ppNextVc;
	PATMARP_VC		pNextVc;
	ULONG			rc;			// Ref count on ATM Entry


	do
	{
		//
		//  Reference the ATM Entry so that it cannot go away.
		//
		AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);	// Temp ref: InvalidateAtmEntry

#ifdef PROTECT_ATM_ENTRY_IN_CLOSE_CALL
		//
		//  Check if we are already closing this ATM Entry. If so,
		//  we don't do anything here.
		//
		if (AA_IS_FLAG_SET(
					pAtmEntry->Flags,
					AA_ATM_ENTRY_STATE_MASK,
					AA_ATM_ENTRY_CLOSING))
		{
			break;
		}

		//
		//  Mark this ATM Entry so that we don't use it anymore.
		//
		AA_SET_FLAG(pAtmEntry->Flags,
					AA_ATM_ENTRY_STATE_MASK,
					AA_ATM_ENTRY_CLOSING);

#endif // PROTECT_ATM_ENTRY_IN_CLOSE_CALL

		//
		//  Go through the list of VCs on this ATM Entry,
		//  close all SVCs, and if we are shutting down,
		//  all PVCs, too.
		//

		if (pAtmEntry->pVcList != NULL_PATMARP_VC)
		{
			pVc = pAtmEntry->pVcList;
			AA_ACQUIRE_VC_LOCK_DPC(pVc);
			AtmArpReferenceVc(pVc);	// temp: CloseVCsOnAtmEntry
			AA_RELEASE_VC_LOCK_DPC(pVc);
		}

		for (pVc = pAtmEntry->pVcList;
			 pVc != NULL_PATMARP_VC;
			 pVc = pNextVc)
		{
			pNextVc = pVc->pNextVc;

			//
			//  Make sure we do not follow a stale link after
			//  we are done with the current VC.
			//
			if (pNextVc != NULL_PATMARP_VC)
			{
				AA_ACQUIRE_VC_LOCK_DPC(pNextVc);
				AtmArpReferenceVc(pNextVc);     // temp: CloseVCsOnAtmEntry
				AA_RELEASE_VC_LOCK_DPC(pNextVc);
			}

			if (ShuttingDown || (AA_IS_FLAG_SET(pVc->Flags,
										AA_VC_TYPE_MASK,
										AA_VC_TYPE_SVC)))
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
	
				AA_ACQUIRE_VC_LOCK(pVc);

				if (AtmArpDereferenceVc(pVc) != 0)
				{
					AtmArpCloseCall(pVc);
					//
					//  The VC Lock is released within the above.
					//
                }

			}
			else
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);

				AA_ACQUIRE_VC_LOCK(pVc);
				if (AtmArpDereferenceVc(pVc) != 0)
				{
					AA_RELEASE_VC_LOCK(pVc);
				}
			}

			AA_ACQUIRE_AE_LOCK(pAtmEntry);

		}
		break;
	}
	while (FALSE);

	//
	//  Remove the temp reference
	//
	rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);	// Temp ref: InvalidateAtmEntry

	if (rc != 0)
	{
		AA_RELEASE_AE_LOCK(pAtmEntry);
	}
	//
	//  else the ATM Entry is gone.
	//

	return;
}


VOID
AtmArpResolveIpEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Trigger off address resolution of an IP entry, unless it's already
	going on. Based on the IP address class, we either go to the ARP
	server or to MARS.

	NOTE: The caller is assumed to hold a lock to the IP Entry, and it
	will be released here.

Arguments:

	pIpEntry		- IP Entry on which we want to start resolution.

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	IP_ADDRESS				DstIPAddress;
	IP_ADDRESS				SrcIPAddress;
	BOOLEAN					WasRunning;
	ULONG					Flags;			// From IP Entry

	Flags = pIpEntry->Flags;

	if (!AA_IS_FLAG_SET(
				Flags,
				AA_IP_ENTRY_STATE_MASK,
				AA_IP_ENTRY_ARPING)     &&
		!AA_IS_FLAG_SET(
				Flags,
				AA_IP_ENTRY_STATE_MASK,
				AA_IP_ENTRY_INARPING) &&
		AA_IE_IS_ALIVE(pIpEntry))
	{

		pInterface = pIpEntry->pInterface;

		//
		//  Get the source and destination IP addresses for
		//  the ARP Request.
		//
		DstIPAddress = pIpEntry->IPAddress;
		SrcIPAddress = pInterface->LocalIPAddress.IPAddress;

		//
		//  An aging timer might be running on this IP Entry.
		//  [We start one in the NakDelayTimeout routine].
		//  Stop it.
		//
		WasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);

		//
		//  Start an ARP Wait timer.
		//
		AtmArpStartTimer(
				pInterface,
				&(pIpEntry->Timer),
				AtmArpAddressResolutionTimeout,
				pInterface->AddressResolutionTimeout,
				(PVOID)pIpEntry
				);


		if (!WasRunning)
		{
			AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// timer ref
		}

		pIpEntry->RetriesLeft = pInterface->MaxResolutionAttempts - 1;

		//
		//  Update the state on this IP Entry.
		//
		AA_SET_FLAG(
				pIpEntry->Flags,
				AA_IP_ENTRY_STATE_MASK,
				AA_IP_ENTRY_ARPING);

		AA_RELEASE_IE_LOCK(pIpEntry);

#ifdef IPMCAST
		if (AA_IS_FLAG_SET(Flags,
							AA_IP_ENTRY_ADDR_TYPE_MASK,
							AA_IP_ENTRY_ADDR_TYPE_UCAST))
		{
			//
			//  Unicast address: send out an ARP Request
			//
			AtmArpSendARPRequest(
					pInterface,
					&SrcIPAddress,
					&DstIPAddress
					);
		}
		else
		{
			//
			//  Multicast/broadcast address: send a MARS Request
			//
			AtmArpMcSendRequest(
					pInterface,
					&DstIPAddress
					);
		}
#else
		//
		//  Now send out the ARP Request
		//
		AtmArpSendARPRequest(
				pInterface,
				&SrcIPAddress,
				&DstIPAddress
				);
#endif // IPMCAST
	}
	else
	{
		//
		//  The IP Address is either not alived or being resolved.
		//  No more action needed
		//  here.
		//
		AA_RELEASE_IE_LOCK(pIpEntry);
	}

	return;
}


EXTERN
VOID
AtmArpCleanupArpTable(
	IN PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Go through the ARP Table, deleting all multicast IP entries that
	are stale (currently defined as having no link to an AtmEntry).
	These IP entries stay around because mulicast entries don't have ageing timers.

Arguments:

	pInterface	

Return Value:

	None

--*/
{

	BOOLEAN	fTableLockWasReleased;

	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

	do
	{
		PATMARP_IP_ENTRY 			pIpEntry;

		fTableLockWasReleased = FALSE;

		for (pIpEntry =  pInterface->pMcSendList;
			 pIpEntry != NULL;
			 pIpEntry = pIpEntry->pNextMcEntry)
		{
			//
			// NOTE: by design, we don't claim the ip entry lock when checking
			// whether we should abort the entry or not.
			//
			if (	pIpEntry->pAtmEntry == NULL
				&&  !AA_IS_FLAG_SET(
						pIpEntry->Flags,
						AA_IP_ENTRY_STATE_MASK,
						AA_IP_ENTRY_ARPING))
			{
				//
				// Get locks in the right order.
				//
				AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
				AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
				AA_REF_IE(pIpEntry, IE_REFTYPE_TMP);	// TmpRef
				AA_RELEASE_IE_LOCK_DPC(pIpEntry);
				AA_RELEASE_IF_TABLE_LOCK(pInterface);
				AA_ACQUIRE_IE_LOCK(pIpEntry);
				AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

				if (AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP)) // TmpRef
				{
					AADEBUGP(AAD_WARNING,
						("CleanupArpTable: Aborting stale IP %d:%d:%d:%d\n",
						((PUCHAR)&(pIpEntry->IPAddress))[0],
						((PUCHAR)&(pIpEntry->IPAddress))[1],
						((PUCHAR)&(pIpEntry->IPAddress))[2],
						((PUCHAR)&(pIpEntry->IPAddress))[3]
						));
					AtmArpAbortIPEntry(pIpEntry);

					//
					//  IE Lock is released within the above.
					//
				}

				//
				// Since we let go of the table lock, we must re-start our search
				// through pMcSendList.
				//
				fTableLockWasReleased = TRUE;
				AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
				break;
			}
		}

	} while (fTableLockWasReleased);

	AA_RELEASE_IF_TABLE_LOCK(pInterface);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\cmddk.h ===
/*

Copyright (c) 1990-1996  Microsoft Corporation

Module Name:

    cmddk.h

Abstract:

    This module defines the structures, macros, and functions missing from 
    ndis.h when you specify BINARY_COMPATIBLE=1 but do not include ntddk.h
    

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	alid     	10-14-96    Created

--*/

#ifndef _CMDDK_INCLUDED_
#define _CMDDK_INCLUDED_

//
// needed by cxport.h taken from ntddk.h
//

typedef
VOID
(*PWORKER_THREAD_ROUTINE)(
    IN PVOID Parameter
    );
    
typedef struct _WORK_QUEUE_ITEM {
    LIST_ENTRY List;
    PWORKER_THREAD_ROUTINE WorkerRoutine;
    PVOID Parameter;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

NTKERNELAPI
BOOLEAN
KeCancelTimer (
    IN PKTIMER
    );


//
// Spin Lock
//

// typedef ULONG KSPIN_LOCK;  // winnt ntndis

// typedef KSPIN_LOCK *PKSPIN_LOCK;


#define ExInterlockedPopEntryList       ExfInterlockedPopEntryList
#define ExInterlockedPushEntryList      ExfInterlockedPushEntryList


NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPopEntryList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPushEntryList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
VOID
NTAPI
KeInitializeSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#if defined(_X86_)

NTKERNELAPI
VOID
FASTCALL
KefAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
FASTCALL
KefReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLockAtDpcLevel(a)      KefAcquireSpinLockAtDpcLevel(a)
#define KeReleaseSpinLockFromDpcLevel(a)    KefReleaseSpinLockFromDpcLevel(a)

#else

NTKERNELAPI
VOID
KeAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
KeReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#endif



#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || (defined(_X86_) && !defined(_NTHAL_))

//  begin_wdm

#if defined(_X86_)

__declspec(dllimport)
KIRQL
FASTCALL
KfAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

__declspec(dllimport)
VOID
FASTCALL
KfReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

__declspec(dllimport)
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLock(a,b)  *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b)  KfReleaseSpinLock(a,b)

#else

__declspec(dllimport)
KIRQL
KeAcquireSpinLockRaiseToDpc (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLock(SpinLock, OldIrql) \
    *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)

__declspec(dllimport)
VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#endif

//  end_wdm

#else

#if defined(_X86_)

KIRQL
FASTCALL
KfAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

VOID
FASTCALL
KfReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#define KeAcquireSpinLock(a,b)  *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b)  KfReleaseSpinLock(a,b)

KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

#else

KIRQL
KeAcquireSpinLockRaiseToDpc (
    IN PKSPIN_LOCK SpinLock
    );

KIRQL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLock(SpinLock, OldIrql) \
    *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)

VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#endif

#endif


#if defined(NT_UP) && !DBG && !defined(_NTDDK_) && !defined(_NTIFS_)

#if !defined(_NTDRIVER_)
#define ExAcquireSpinLock(Lock, OldIrql) (*OldIrql) = KeRaiseIrqlToDpcLevel();
#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))
#else
#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#endif
#define ExAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock)

#else

//  begin_wdm

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

// end_wdm

#endif


NTKERNELAPI
KIRQL
KfRaiseIrqlToDpcLevel (
    VOID
    );

#define KeRaiseIrqlToDpcLevel(OldIrql) (*(OldIrql) = KfRaiseIrqlToDpcLevel())

NTKERNELAPI
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    );

// end_nthal end_wdm

#if defined(NT_UP) && !defined(_NTDDK_) && !defined(_NTIFS_)
#define ExAcquireSpinLock(Lock, OldIrql) KeRaiseIrqlToDpcLevel((OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock)
#else

//  begin_wdm

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

//  end_wdm

#endif



//
// Event type
//

typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
    } EVENT_TYPE;



#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

//  begin_wdm

NTKERNELAPI
VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    );

NTKERNELAPI
VOID
KeClearEvent (
    IN PRKEVENT Event
    );

//  end_wdm

#else

#define KeInitializeEvent(_Event, _Type, _State)            \
    (_Event)->Header.Type = (UCHAR)_Type;                   \
    (_Event)->Header.Size =  sizeof(KEVENT) / sizeof(LONG); \
    (_Event)->Header.SignalState = _State;                  \
    InitializeListHead(&(_Event)->Header.WaitListHead)

#define KeClearEvent(Event) (Event)->Header.SignalState = 0

#endif


LONG
FASTCALL
InterlockedIncrement(
    IN PLONG Addend
    );


#ifndef ATMARP_WIN98
NTSYSAPI
ULONG
NTAPI
RtlCompareMemory (
    PVOID Source1,
    PVOID Source2,
    ULONG Length
    );
#endif

NTKERNELAPI
PVOID
ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

NTKERNELAPI
VOID
NTAPI
ExFreePool(
    IN PVOID P
    );
    

#endif // _CMDDK_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\arpwmi.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	arpwmi.c

Abstract:

	WMI Support for ATMARP Client. One Device Object is created for each
	IP Interface, and a bunch of GUIDs are supported on each. The static
	instance name for each interface is derived from the friendly name
	of the adapter below.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     12-16-97    Created

Notes:

--*/

#undef BINARY_COMPATIBLE

#define BINARY_COMPATIBLE	0

#include <precomp.h>

#define _FILENUMBER 'IMWA'

#define NEWQOS 1

#ifdef ATMARP_WMI


//
//  Private macros
//
#define	AA_WMI_BUFFER_TOO_SMALL(_BufferSize, _Wnode, _WnodeSize, _pStatus)		\
{																				\
	if ((_BufferSize) < sizeof(WNODE_TOO_SMALL))								\
	{																			\
		*(_pStatus) = STATUS_BUFFER_TOO_SMALL;									\
	}																			\
	else																		\
	{																			\
		(_Wnode)->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);				\
		(_Wnode)->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;					\
		((PWNODE_TOO_SMALL)(_Wnode))->SizeNeeded = (_WnodeSize);				\
																				\
		*(_pStatus) = STATUS_SUCCESS;											\
	}																			\
}


//
//  Provider Id in WMI structures
//
typedef ULONG_PTR					PROV_ID_TYPE;



PATMARP_WMI_GUID
AtmArpWmiFindGuid(
	IN	PATMARP_INTERFACE			pInterface,
	IN	LPGUID						pGuid,
	OUT	PULONG						pGuidDataSize
)
/*++

Routine Description:

	Locate and return a pointer to the GUID info structure
	for the specified GUID. The caller is assumed to have
	locked the IF structure. Also return the data size for
	the GUID instance.

Arguments:

	pInterface		- Pointer to our Interface structure
	pGuid			- Pointer to GUID being searched for
	pGuidDataSize	- Place to return data size for GUID instance

Return Value:

	Pointer to GUID info structure if found, else NULL.

--*/
{
	PATMARP_IF_WMI_INFO		pIfWmiInfo;
	PATMARP_WMI_GUID		pArpGuid;
	ULONG					i;
	UCHAR					OutputBuffer[1];
	ULONG					BytesReturned;
	NTSTATUS				NtStatus;

	do
	{
		pIfWmiInfo = pInterface->pIfWmiInfo;
		AA_ASSERT(pIfWmiInfo != NULL);

		for (i = 0, pArpGuid = &pIfWmiInfo->GuidInfo[0];
			 i < pIfWmiInfo->GuidCount;
			 i++, pArpGuid++)
		{
			if (AA_MEM_CMP(&pArpGuid->Guid, pGuid, sizeof(GUID)) == 0)
			{
				break;
			}
		}

		if (i == pIfWmiInfo->GuidCount)
		{
			pArpGuid = NULL;
			break;
		}

		//
		//  Found the GUID. Do a dummy query of its value to get
		//  the value size.
		//
		if (pArpGuid->QueryHandler == NULL)
		{
			//
			//  No query handler!
			//
			AA_ASSERT(!"No query handler!");
			pArpGuid = NULL;
			break;
		}

		NtStatus = (*pArpGuid->QueryHandler)(
						pInterface,
						pArpGuid->MyId,
						&OutputBuffer[0],
						0,					// output BufferLength
						&BytesReturned,
						pGuidDataSize
						);
		
		AA_ASSERT(NtStatus == STATUS_INSUFFICIENT_RESOURCES);
		break;
	}
	while (FALSE);

	return (pArpGuid);
}


NTSTATUS
AtmArpWmiRegister(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ULONG						RegistrationType,
	IN	PWMIREGINFO					pWmiRegInfo,
	IN	ULONG						WmiRegInfoSize,
	OUT	PULONG						pReturnSize
)
/*++

Routine Description:

	This is called to process an IRP_MN_REGINFO. If the registration type
	is WMIREGISTER, we return a list of GUIDs supported on this interface.

Arguments:

	pInterface		- Pointer to our Interface structure
	RegistrationType- WMIREGISTER or WMIUPDATE. We only handle WMIREGISTER.
	pWmiRegInfo		- Points to structure to be filled in with info about
					  supported GUIDs on this interface.
	WmiRegInfoSize	- Length of the above
	pReturnSize		- What we filled up.

Return Value:

	STATUS_SUCCESS if successful, STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS					Status;
	ULONG						BytesNeeded;
	PATMARP_IF_WMI_INFO			pIfWmiInfo;
	PATMARP_WMI_GUID			pArpWmiGuid;
	PWMIREGGUID					pWmiRegGuid;
	ULONG						InstanceOffset;
	PUCHAR						pDst;
	ULONG						c;

	Status = STATUS_SUCCESS;

	do
	{
		if (RegistrationType != WMIREGISTER)
		{
			Status = STATUS_INVALID_PARAMETER;
			break;
		}

		pIfWmiInfo = pInterface->pIfWmiInfo;

		if ((pIfWmiInfo == NULL) ||
			(pIfWmiInfo->GuidCount == 0))
		{
			//
			//  No GUIDs on this Interface.
			//
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		BytesNeeded = sizeof(WMIREGINFO)
					  		+
					  //
					  //  One WMIREGGUID structure for each supported GUID.
					  //
					  (pIfWmiInfo->GuidCount * sizeof(WMIREGGUID))
					  		+
					  //
					  //  Counted unicode string containing the instance name
					  //  for all GUIDs on this interface. Looks like:
					  //  <USHORT Length> <String of WCHAR>
					  //
					  (sizeof(USHORT) + pIfWmiInfo->InstanceName.Length)
#ifdef PATHS_REQD
					  		+
					  //
					  //  Counted unicode string containing the driver registry
					  //  path. Looks like: <USHORT Length> <String of WCHAR>
					  //
					  (sizeof(USHORT) + sizeof(ATMARP_REGISTRY_PATH) - sizeof(WCHAR))
					  		+
					  //
					  //  Counted unicode string containing the MOF resource
					  //  name: <USHORT length> <String of WCHAR>
					  //
					  (sizeof(USHORT) + sizeof(ATMARP_MOF_RESOURCE_NAME) - sizeof(WCHAR))
#endif // PATHS_REQD
					  		;
 
 		if (WmiRegInfoSize < BytesNeeded)
 		{
 			//
 			//  Insufficient space for GUID info.
 			//

 			*((ULONG UNALIGNED *)pWmiRegInfo) = BytesNeeded;
 			*pReturnSize = sizeof(ULONG);
 			Status = STATUS_SUCCESS;

 			AADEBUGP(AAD_INFO, ("WmiRegister: Bytes needed %d, Reginfo size %d\n",
 						BytesNeeded, WmiRegInfoSize));

 			break;
 		}

		//
		//  Done with all validations.
		//
		*pReturnSize = BytesNeeded;

		AA_SET_MEM(pWmiRegInfo, 0, BytesNeeded);

		pWmiRegInfo->BufferSize = BytesNeeded;
		pWmiRegInfo->NextWmiRegInfo = 0;
		pWmiRegInfo->GuidCount = pIfWmiInfo->GuidCount;

		//
		//  Calculate the offset at which we place the instance name.
		//
		InstanceOffset = sizeof(WMIREGINFO) + (pIfWmiInfo->GuidCount * sizeof(WMIREGGUID));

		//
		//  Fill in the GUID list. All GUIDs for this interface refer to
		//  the same Instance name.
		//
		pWmiRegGuid = &pWmiRegInfo->WmiRegGuid[0];
		pArpWmiGuid = &pIfWmiInfo->GuidInfo[0];

		for (c = 0;
			 c < pIfWmiInfo->GuidCount;
			 c++, pWmiRegGuid++, pArpWmiGuid++)
		{
			AA_COPY_MEM(&pWmiRegGuid->Guid, &pArpWmiGuid->Guid, sizeof(GUID));

			pWmiRegGuid->Flags = WMIREG_FLAG_INSTANCE_LIST;
			pWmiRegGuid->InstanceCount = 1;
			pWmiRegGuid->InstanceInfo = InstanceOffset;
		}


		//
		//  Fill in the instance name.
		//
		pDst = (PUCHAR)pWmiRegGuid;

		*((USHORT UNALIGNED *)pDst) = pIfWmiInfo->InstanceName.Length;
		pDst += sizeof(USHORT);

		AA_COPY_MEM(pDst,
					pIfWmiInfo->InstanceName.Buffer,
					pIfWmiInfo->InstanceName.Length);

		pDst += pIfWmiInfo->InstanceName.Length;

#ifdef PATHS_REQD

		//
		//  Fill in the Driver registry path.
		//
		pWmiRegInfo->RegistryPath = (ULONG)(pDst - (PUCHAR)pWmiRegInfo);

		*((USHORT UNALIGNED *)pDst) = sizeof(ATMARP_REGISTRY_PATH) - sizeof(WCHAR);
		pDst += sizeof(USHORT);

		AA_COPY_MEM(pDst,
					(PUCHAR)ATMARP_REGISTRY_PATH,
					sizeof(ATMARP_REGISTRY_PATH) - sizeof(WCHAR));

		pDst += sizeof(ATMARP_REGISTRY_PATH) - sizeof(WCHAR);


		//
		//  Fill in the MOF resource name.
		//
		pWmiRegInfo->MofResourceName = (ULONG)(pDst - (PUCHAR)pWmiRegInfo);
		*((USHORT UNALIGNED *)pDst) = sizeof(ATMARP_MOF_RESOURCE_NAME) - sizeof(WCHAR);
		pDst += sizeof(USHORT);

		AA_COPY_MEM(pDst,
					(PUCHAR)ATMARP_MOF_RESOURCE_NAME,
					sizeof(ATMARP_MOF_RESOURCE_NAME) - sizeof(WCHAR));

#endif // PATHS_REQD

		break;
	}
	while (FALSE);

	AADEBUGP(AAD_INFO,
		("WmiRegister: IF x%x, pWmiRegInfo x%x, Size %d, Ret size %d, status x%x\n",
			pInterface, pWmiRegInfo, WmiRegInfoSize, *pReturnSize, Status));

	return (Status);
}


NTSTATUS
AtmArpWmiQueryAllData(
	IN	PATMARP_INTERFACE			pInterface,
	IN	LPGUID						pGuid,
	IN	PWNODE_ALL_DATA				pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
)
/*++

Routine Description:

	This is called to process an IRP_MN_QUERY_ALL_DATA, which is used
	to query all instances of a GUID on this interface.

	For now, we only have single instances of any GUID on an interface.

Arguments:

	pInterface		- Pointer to our Interface structure
	pGuid			- GUID of data block being queried.
	pWnode			- The structure to be filled up.
	BufferSize		- Total space for the WNODE_ALL_DATA, beginning at pWnode.
	pReturnSize		- What we filled up.

Return Value:

	STATUS_SUCCESS if we know this GUID and successfully filled up the
	WNODE_ALL_DATA, STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS					Status;
	ULONG						BytesNeeded;
	ULONG						WnodeSize;
	PATMARP_IF_WMI_INFO			pIfWmiInfo;
	PATMARP_WMI_GUID			pArpGuid;
	ULONG						GuidDataSize;
	ULONG						GuidDataBytesReturned;
	ULONG						GuidDataBytesNeeded;
	PUCHAR						pDst;
	BOOLEAN						bIfLockAcquired = FALSE;

	do
	{
		pIfWmiInfo = pInterface->pIfWmiInfo;

		if ((pIfWmiInfo == NULL) ||
			(pIfWmiInfo->GuidCount == 0))
		{
			//
			//  No GUIDs on this Interface.
			//
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//
		//  Locate the GUID.
		//
		bIfLockAcquired = TRUE;
		AA_ACQUIRE_IF_WMI_LOCK(pInterface);

		pArpGuid = AtmArpWmiFindGuid(pInterface, pGuid, &GuidDataSize);

		if (pArpGuid == NULL)
		{
			Status = STATUS_WMI_GUID_NOT_FOUND;
			break;
		}

		WnodeSize = ROUND_TO_8_BYTES(sizeof(WNODE_ALL_DATA));

		//
		//  Compute the total size of the reply WNODE_ALL_DATA. Since
		//  we only have a single instance of each GUID on an interface,
		//  we use the "Fixed Instance Size" format.
		//
		BytesNeeded =  WnodeSize +
						//
						//  The data itself
						//
					   GuidDataSize +
						//
						//  A ULONG to store the instance name offset
						//
					   sizeof(ULONG) +
					    //
					    //  A USHORT to store the length of the instance name
					    //  (Counted Unicode string)
					    //
					   sizeof(USHORT) +
					   	//
					   	//  The instance name
					   	//
					   pIfWmiInfo->InstanceName.Length;

		//
		//  Is there sufficient space in the buffer handed down to us?
		//
		if (BufferSize < BytesNeeded)
		{
			AA_WMI_BUFFER_TOO_SMALL(BufferSize, pWnode, WnodeSize, &Status);
			break;
		}

		//
		//  Initialize the WNODE_ALL_DATA.
		//
		pWnode->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(pIfWmiInfo->pDeviceObject);
		pWnode->WnodeHeader.Version = ATMARP_WMI_VERSION;

		NdisGetCurrentSystemTime(&pWnode->WnodeHeader.TimeStamp);

		pWnode->WnodeHeader.Flags |= WNODE_FLAG_FIXED_INSTANCE_SIZE;
		pWnode->WnodeHeader.BufferSize = BytesNeeded;

		pWnode->InstanceCount = 1;

		//
		//  The data follows the WNODE_ALL_DATA.
		//
		pWnode->DataBlockOffset = WnodeSize;

		//
		//  The instance name ensemble follows the data.
		//
		pWnode->OffsetInstanceNameOffsets = WnodeSize + GuidDataSize;
		pWnode->FixedInstanceSize = GuidDataSize;

		//
		//  Get the data.
		//
		Status = (*pArpGuid->QueryHandler)(
					pInterface,
					pArpGuid->MyId,
					(PVOID)((PUCHAR)pWnode + pWnode->DataBlockOffset),
					GuidDataSize,
					&GuidDataBytesReturned,
					&GuidDataBytesNeeded);
		
		if (!NT_SUCCESS(Status))
		{
			break;
		}

		//
		//  Jump to the location where we must fill in the instance name
		//  ensemble, which consists of:
		//
		//  	ULONG	Offset from start of WNODE to counted Unicode string
		//				representing Instance name (below).
		//		USHORT	Number of WCHARs in instance name.
		//		WCHAR[]	Array of WCHARs making up the instance name.
		//
		pDst = (PUCHAR)((PUCHAR)pWnode + pWnode->OffsetInstanceNameOffsets);

		//
		//  Fill in the offset to the instance name at this spot, and move on.
		//
		*(ULONG UNALIGNED *)pDst = pWnode->OffsetInstanceNameOffsets + sizeof(ULONG);
		pDst += sizeof(ULONG);

		//
		//  Fill in the instance name as a counted Unicode string.
		//
		*(PUSHORT)pDst = (USHORT)pIfWmiInfo->InstanceName.Length;
		pDst += sizeof(USHORT);

		AA_COPY_MEM(pDst,
					pIfWmiInfo->InstanceName.Buffer,
					pIfWmiInfo->InstanceName.Length);

		AA_ASSERT(NT_SUCCESS(Status));
		break;
	}
	while (FALSE);

	if (bIfLockAcquired)
	{
		AA_RELEASE_IF_WMI_LOCK(pInterface);
	}

	if (NT_SUCCESS(Status))
	{
		*pReturnSize = pWnode->WnodeHeader.BufferSize;
	}

	AADEBUGP(AAD_INFO,
		("WmiQueryAllData: IF x%x, pWnode x%x, Size %d, Ret size %d, status x%x\n",
			pInterface, pWnode, BufferSize, *pReturnSize, Status));

	return (Status);
}


NTSTATUS
AtmArpWmiQuerySingleInstance(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PWNODE_SINGLE_INSTANCE		pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
)
/*++

Routine Description:

	This is called to process an IRP_MN_QUERY_SINGLE_INSTANCE, which is used
	to query a single instance of a GUID on this interface.

Arguments:

	pInterface		- Pointer to our Interface structure
	pWnode			- The structure to be filled up.
	BufferSize		- Total space for the WNODE_SINGLE_INSTANCE, beginning at pWnode.
	pReturnSize		- What we filled up.

Return Value:

	STATUS_SUCCESS if we know this GUID and successfully filled up the
	WNODE_SINGLE_INSTANCE, STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS					Status;
	ULONG						BytesNeeded;
	ULONG						WnodeSize;
	LPGUID						pGuid;
	PATMARP_IF_WMI_INFO			pIfWmiInfo;
	PATMARP_WMI_GUID			pArpGuid;
	PUCHAR						pDst;
	ULONG						GuidDataSize;
	ULONG						GuidDataBytesNeeded;
	BOOLEAN						bIfLockAcquired = FALSE;

	do
	{
		AA_ASSERT((pWnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) != 0);

		{
			NDIS_STRING				InstanceName;
	
			InstanceName.Length = *(PUSHORT)((PUCHAR)pWnode
									+ pWnode-> OffsetInstanceName);
			InstanceName.Buffer = (PWSTR)((PUCHAR)pWnode + pWnode->OffsetInstanceName
											+ sizeof(USHORT));
			AADEBUGP(AAD_INFO,
						("QuerySingleInstance: InstanceName=%Z\n", &InstanceName));
		}

		pIfWmiInfo = pInterface->pIfWmiInfo;

		if ((pIfWmiInfo == NULL) ||
			(pIfWmiInfo->GuidCount == 0))
		{
			//
			//  No GUIDs on this Interface.
			//
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//
		//  Locate the GUID.
		//
		pGuid = &pWnode->WnodeHeader.Guid;

		bIfLockAcquired = TRUE;
		AA_ACQUIRE_IF_WMI_LOCK(pInterface);

		pArpGuid = AtmArpWmiFindGuid(pInterface, pGuid, &GuidDataSize);

		if (pArpGuid == NULL)
		{
			Status = STATUS_WMI_GUID_NOT_FOUND;
			break;
		}

		WnodeSize = ROUND_TO_8_BYTES(sizeof(WNODE_SINGLE_INSTANCE));

		//
		//  Compute the total size of the reply WNODE_SINGLE_INSTANCE.
		//
		BytesNeeded =  pWnode->DataBlockOffset + GuidDataSize;

		if (BufferSize < BytesNeeded)
		{
			AA_WMI_BUFFER_TOO_SMALL(BufferSize, pWnode, WnodeSize, &Status);
			break;
		}
			
		//
		//  Fill in the WNODE_SINGLE_INSTANCE.
		//
		pWnode->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(pIfWmiInfo->pDeviceObject);
		pWnode->WnodeHeader.Version = ATMARP_WMI_VERSION;

		NdisGetCurrentSystemTime(&pWnode->WnodeHeader.TimeStamp);

		pWnode->WnodeHeader.BufferSize = BytesNeeded;
		pWnode->SizeDataBlock = GuidDataSize;

		//
		//  Get the GUID Data.
		//
		Status = (*pArpGuid->QueryHandler)(
					pInterface,
					pArpGuid->MyId,
					(PUCHAR)pWnode + pWnode->DataBlockOffset,	// start of output buf
					BufferSize - pWnode->DataBlockOffset,	// total length available
					&pWnode->SizeDataBlock,	// bytes written
					&GuidDataBytesNeeded
					);

		if (!NT_SUCCESS(Status))
		{
			break;
		}

		*pReturnSize = BytesNeeded;

		Status = STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	if (bIfLockAcquired)
	{
		AA_RELEASE_IF_WMI_LOCK(pInterface);
	}

	AADEBUGP(AAD_INFO,
		("WmiQuerySingleInst: IF x%x, pWnode x%x, Size %d, Ret size %d, status x%x\n",
			pInterface, pWnode, BufferSize, *pReturnSize, Status));

	return (Status);
}


NTSTATUS
AtmArpWmiChangeSingleInstance(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PWNODE_SINGLE_INSTANCE		pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
)
/*++

Routine Description:

	This is called to process an IRP_MN_CHANGE_SINGLE_INSTANCE, which is used
	to change the value of a single instance of a GUID on this interface.

Arguments:

	pInterface		- Pointer to our Interface structure
	pWnode			- The structure containing the new value for the GUID instance.
	BufferSize		- Total space for the WNODE_SINGLE_INSTANCE, beginning at pWnode.
	pReturnSize		- Not used.

Return Value:

	STATUS_SUCCESS if we know this GUID and successfully changed its value,
	STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS					Status;
	ULONG						BytesNeeded;
	ULONG						WnodeSize;
	LPGUID						pGuid;
	PATMARP_IF_WMI_INFO			pIfWmiInfo;
	PATMARP_WMI_GUID			pArpGuid;
	PUCHAR						pGuidData;
	ULONG						GuidDataSize;
	ULONG						GuidDataBytesWritten;
	ULONG						GuidDataBytesNeeded;
	BOOLEAN						bIfLockAcquired = FALSE;

	do
	{
		AA_ASSERT((pWnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) != 0);

		pIfWmiInfo = pInterface->pIfWmiInfo;

		if ((pIfWmiInfo == NULL) ||
			(pIfWmiInfo->GuidCount == 0))
		{
			//
			//  No GUIDs on this Interface.
			//
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//
		//  Locate the GUID.
		//
		pGuid = &pWnode->WnodeHeader.Guid;

		bIfLockAcquired = TRUE;
		AA_ACQUIRE_IF_WMI_LOCK(pInterface);

		pArpGuid = AtmArpWmiFindGuid(pInterface, pGuid, &GuidDataSize);

		if (pArpGuid == NULL)
		{
			Status = STATUS_WMI_GUID_NOT_FOUND;
			break;
		}

		//
		//  Check if the GUID can be set.
		//
		if (pArpGuid->SetHandler == NULL)
		{
			Status = STATUS_NOT_SUPPORTED;
			break;
		}

		//
		//  Get the start and size of the data block.
		//
		pGuidData = (PUCHAR)pWnode + pWnode->DataBlockOffset;
		GuidDataSize = pWnode->SizeDataBlock;

		if (GuidDataSize == 0)
		{
			Status = STATUS_INVALID_PARAMETER;
			break;
		}

		//
		//  Try to set the value of the GUID instance.
		//
		Status = (*pArpGuid->SetHandler)(
					pInterface,
					pArpGuid->MyId,
					pGuidData,
					GuidDataSize,
					&GuidDataBytesWritten,
					&GuidDataBytesNeeded
					);

		break;
	}
	while (FALSE);

	if (bIfLockAcquired)
	{
		AA_RELEASE_IF_WMI_LOCK(pInterface);
	}

	return (Status);
}


NTSTATUS
AtmArpWmiChangeSingleItem(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PWNODE_SINGLE_ITEM			pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
)
/*++

Routine Description:

	This is called to change a single item within the data block for a GUID
	instance (e.g. field in a struct). We don't need this for now.

Arguments:


Return Value:

	STATUS_NOT_SUPPORTED

--*/
{
	return (STATUS_NOT_SUPPORTED);
}



NTSTATUS
AtmArpWmiSetEventStatus(
	IN	PATMARP_INTERFACE			pInterface,
	IN	LPGUID						pGuid,
	IN	BOOLEAN						bEnabled
)
/*++

Routine Description:

	This is called to enable/disable event generation on the specified GUID.

Arguments:

	pInterface		- Pointer to our Interface structure
	pGuid			- affected GUID
	bEnabled		- TRUE iff events are to be enabled.

Return Value:

	STATUS_SUCCESS if we successfully enabled/disabled event generation,
	STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS					Status;
	PATMARP_IF_WMI_INFO			pIfWmiInfo;
	PATMARP_WMI_GUID			pArpGuid;
	ULONG						GuidDataSize;
	BOOLEAN						bIfLockAcquired = FALSE;

	do
	{
		pIfWmiInfo = pInterface->pIfWmiInfo;

		if ((pIfWmiInfo == NULL) ||
			(pIfWmiInfo->GuidCount == 0))
		{
			//
			//  No GUIDs on this Interface.
			//
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		bIfLockAcquired = TRUE;
		AA_ACQUIRE_IF_WMI_LOCK(pInterface);

		pArpGuid = AtmArpWmiFindGuid(pInterface, pGuid, &GuidDataSize);

		if (pArpGuid == NULL)
		{
			Status = STATUS_WMI_GUID_NOT_FOUND;
			break;
		}

		AADEBUGP(AAD_INFO, ("WmiSetEventStatus: IF x%x, pArpGuid x%x, MyId %d, enable: %d\n",
					pInterface, pArpGuid, pArpGuid->MyId, bEnabled));

		//
		//  Check if we generate events on this GUID.
		//
		if (pArpGuid->EnableEventHandler == NULL)
		{
			Status = STATUS_NOT_SUPPORTED;
			break;
		}

		//
		//  Go ahead and enable events.
		//
		if (bEnabled)
		{
			AA_SET_FLAG(pArpGuid->Flags, AWGF_EVENT_MASK, AWGF_EVENT_ENABLED);
		}
		else
		{
			AA_SET_FLAG(pArpGuid->Flags, AWGF_EVENT_MASK, AWGF_EVENT_DISABLED);
		}

		(*pArpGuid->EnableEventHandler)(
			pInterface,
			pArpGuid->MyId,
			bEnabled
			);
		
		Status = STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	if (bIfLockAcquired)
	{
		AA_RELEASE_IF_WMI_LOCK(pInterface);
	}

	return (Status);
}


NTSTATUS
AtmArpWmiDispatch(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
)
/*++

Routine Description:

	System dispatch function for handling IRP_MJ_SYSTEM_CONTROL IRPs from WMI.

Arguments:

	pDeviceObject	- Pointer to device object. The device extension field
					  contains a pointer to the Interface 

	pIrp			- Pointer to IRP.

Return Value:

	NT status code.

--*/
{
	PIO_STACK_LOCATION		pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    PVOID					DataPath = pIrpSp->Parameters.WMI.DataPath;
    ULONG					BufferSize = pIrpSp->Parameters.WMI.BufferSize;
    PVOID					pBuffer = pIrpSp->Parameters.WMI.Buffer;
    NTSTATUS				Status;
    ULONG					ReturnSize;
    PATMARP_INTERFACE		pInterface;

    pInterface = AA_PDO_TO_INTERFACE(pDeviceObject);

    AA_STRUCT_ASSERT(pInterface, aai);

	ReturnSize = 0;

    switch (pIrpSp->MinorFunction)
    {
    	case IRP_MN_REGINFO:

    		Status = AtmArpWmiRegister(
    					pInterface,
    					PtrToUlong(DataPath),
    					pBuffer,
    					BufferSize,
    					&ReturnSize
    					);
    		break;
    	
    	case IRP_MN_QUERY_ALL_DATA:

    		Status = AtmArpWmiQueryAllData(
    					pInterface,
    					(LPGUID)DataPath,
    					(PWNODE_ALL_DATA)pBuffer,
    					BufferSize,
    					&ReturnSize
    					);
    		break;
    	
    	case IRP_MN_QUERY_SINGLE_INSTANCE:

    		Status = AtmArpWmiQuerySingleInstance(
    					pInterface,
    					pBuffer,
    					BufferSize,
    					&ReturnSize
    					);
    		
    		break;

		case IRP_MN_CHANGE_SINGLE_INSTANCE:

			Status = AtmArpWmiChangeSingleInstance(
						pInterface,
						pBuffer,
						BufferSize,
						&ReturnSize
						);
			break;

		case IRP_MN_CHANGE_SINGLE_ITEM:

			Status = AtmArpWmiChangeSingleItem(
						pInterface,
						pBuffer,
						BufferSize,
						&ReturnSize
						);
			break;

		case IRP_MN_ENABLE_EVENTS:

			Status = AtmArpWmiSetEventStatus(
						pInterface,
						(LPGUID)DataPath,
						TRUE				// Enable
						);
			break;

		case IRP_MN_DISABLE_EVENTS:

			Status = AtmArpWmiSetEventStatus(
						pInterface,
						(LPGUID)DataPath,
						FALSE				// Disable
						);
			break;

		case IRP_MN_ENABLE_COLLECTION:
		case IRP_MN_DISABLE_COLLECTION:
		default:
		
			Status = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}

	pIrp->IoStatus.Status = Status;
	pIrp->IoStatus.Information = (NT_SUCCESS(Status) ? ReturnSize: 0);

	AADEBUGP(AAD_INFO,
		("WmiDispatch done: IF x%x, MinorFn %d, Status x%x, ReturnInfo %d\n",
				pInterface, pIrpSp->MinorFunction, Status, pIrp->IoStatus.Information));

	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	return (Status);
}



VOID
AtmArpWmiInitInterface(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_WMI_GUID			GuidList,
	IN	ULONG						NumberOfGuids
)
/*++

Routine Description:

	Set up the given IP Interface as a WMI provider.

Arguments:

	pInterface		- Pointer to our Interface structure
	GuidList		- List of GUIDs
	NumberOfGuids	- Size of above list

Return Value:

	None. If the interface is successfully set up, we reference it.

--*/
{
	PATMARP_IF_WMI_INFO		pIfWmiInfo;
	NDIS_STRING				DeviceName;

	NDIS_STRING				AdapterName;
	NDIS_STRING				HyphenString = NDIS_STRING_CONST(" - ");
#define MAX_IF_NUMBER_STRING_LEN		6	// 5 Digits plus terminator
	NDIS_STRING				IfNumberString;

	ULONG					TotalIfWmiLength;
	USHORT					NameLength;
	NDIS_STATUS				Status;
	NTSTATUS				NtStatus;

	AA_ASSERT(NumberOfGuids > 0);
	AA_ASSERT(GuidList != NULL);

	//
	//  Initialize.
	//
	AdapterName.Buffer = NULL;
	IfNumberString.Buffer = NULL;

	pIfWmiInfo = NULL;

	Status = NDIS_STATUS_SUCCESS;

	do
	{
		AA_INIT_IF_WMI_LOCK(pInterface);

		//
		//  Query the friendly name for the adapter beneath
		//  this Interface.
		//
		Status = NdisQueryAdapterInstanceName(
					&AdapterName,
					pInterface->NdisAdapterHandle
					);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AdapterName.Buffer = NULL;
			break;
		}

		AADEBUGP(AAD_INFO,
			 ("WmiInitIF: IF x%x, Adapter Name: <%Z>\n", pInterface, &AdapterName));

		//
		//  Prepare an instance name for all GUIDs on this Interface.
		//
		//  This is constructed by appending a string of the form "- <Num>"
		//  to the adapter's friendly name. <Num> is the value of the SEL
		//  byte used to identify this interface.
		//

		//
		//  Allocate space for the IF Number string - 5 digits should
		//  be more than enough.
		//
		AA_ASSERT(pInterface->SapSelector <= 99999);

		AA_ALLOC_MEM(IfNumberString.Buffer, WCHAR, MAX_IF_NUMBER_STRING_LEN * sizeof(WCHAR));

		if (IfNumberString.Buffer == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		IfNumberString.MaximumLength = MAX_IF_NUMBER_STRING_LEN;
		IfNumberString.Length = 0;

		//
		//  Prepare the IF Number string.
		//
		Status = RtlIntegerToUnicodeString(
					pInterface->SapSelector,
					10,	// Decimal
					&IfNumberString
					);
		
		AA_ASSERT(NT_SUCCESS(Status));

		//
		//  Compute the total length of the Interface instance name.
		//
		NameLength = AdapterName.Length + HyphenString.Length + IfNumberString.Length + sizeof(WCHAR);

		//
		//  Allocate space for WMI Info for this interface. We allocate one
		//  chunk of memory for all the following:
		//
		//  1. IF WMI Info structure
		//  2. IF Instance name string
		//  3. GUID list
		//
		TotalIfWmiLength = sizeof(ATMARP_IF_WMI_INFO) +
						   //
						   //  IF Instance name:
						   //
						   NameLength +
						   //
						   //  GUID list (-1 because ATMARP_IF_WMI_INFO
						   //  has space for one of these).
						   //
						   ((NumberOfGuids - 1) * sizeof(ATMARP_WMI_GUID));
		
		AA_ALLOC_MEM(pIfWmiInfo, ATMARP_IF_WMI_INFO, TotalIfWmiLength);

		if (pIfWmiInfo == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		AA_SET_MEM(pIfWmiInfo, 0, TotalIfWmiLength);

		pIfWmiInfo->GuidCount = NumberOfGuids;

		AA_COPY_MEM(&pIfWmiInfo->GuidInfo[0],
					GuidList,
					NumberOfGuids * sizeof(ATMARP_WMI_GUID));

		pIfWmiInfo->InstanceName.Buffer = (PWCHAR)
											((PUCHAR)pIfWmiInfo +
											 FIELD_OFFSET(ATMARP_IF_WMI_INFO, GuidInfo) +
											 (NumberOfGuids * sizeof(ATMARP_WMI_GUID)));

		pIfWmiInfo->InstanceName.MaximumLength = NameLength;

		//
		//  Concatenate the three parts of the IF Instance name.
		//
		RtlCopyUnicodeString(&pIfWmiInfo->InstanceName, &AdapterName);

		NtStatus = RtlAppendUnicodeStringToString(&pIfWmiInfo->InstanceName, &HyphenString);
		AA_ASSERT(NT_SUCCESS(NtStatus));

		NtStatus = RtlAppendUnicodeStringToString(&pIfWmiInfo->InstanceName, &IfNumberString);
		AA_ASSERT(NT_SUCCESS(NtStatus));


		AADEBUGP(AAD_INFO,
			("WmiInitIF: IF x%x, InstanceName: <%Z>\n", pInterface, &pIfWmiInfo->InstanceName));
		//
		//  Create a device object for this interface. A pointer's worth
		//  of space is required in the device extension.
		//
#define ATMARP_DEVICE_NAME1		L"\\Device\\ATMARPC1"
		NdisInitUnicodeString(&DeviceName, ATMARP_DEVICE_NAME1);

		NtStatus = IoCreateDevice(
					pAtmArpGlobalInfo->pDriverObject,
					sizeof(PATMARP_INTERFACE),
					NULL,	// &DeviceName
					FILE_DEVICE_NETWORK,
					0,		// Device Characteristics
					FALSE,	// Exclusive?
					&pIfWmiInfo->pDeviceObject
					);
		
		if (!NT_SUCCESS(NtStatus))
		{
			AADEBUGP(AAD_INFO,
				("WmiInitIF: IoCreateDevice (%Z) failed: x%x\n", &DeviceName, NtStatus));

			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Set up the device extension.
		//
		*((PATMARP_INTERFACE *)pIfWmiInfo->pDeviceObject->DeviceExtension) = pInterface;

		//
		//  Prepare to register with WMI.
		//
		pInterface->pIfWmiInfo = pIfWmiInfo;

		NtStatus = IoWMIRegistrationControl(
						pIfWmiInfo->pDeviceObject,
						WMIREG_ACTION_REGISTER);

		if (!NT_SUCCESS(NtStatus))
		{
			pInterface->pIfWmiInfo = NULL;

			IoDeleteDevice(pIfWmiInfo->pDeviceObject);

			Status = NDIS_STATUS_FAILURE;
			break;
		}

		AA_ASSERT(Status == NDIS_STATUS_SUCCESS);
		break;
	}
	while (FALSE);

	//
	//  Clean up.
	//
	if (IfNumberString.Buffer != NULL)
	{
		AA_FREE_MEM(IfNumberString.Buffer);
	}

	if (AdapterName.Buffer != NULL)
	{
		//
		//  This was allocated by NDIS.
		//
		NdisFreeString(AdapterName);
	}

	if (Status != NDIS_STATUS_SUCCESS)
	{
		AA_ASSERT(pInterface->pIfWmiInfo == NULL);

		if (pIfWmiInfo != NULL)
		{
			AA_FREE_MEM(pIfWmiInfo);
		}
	}

	AADEBUGP(AAD_INFO, ("WmiInitIF: IF x%x, WMI Info x%x, Status x%x\n",
				pInterface, pIfWmiInfo, Status));

	return;
}



VOID
AtmArpWmiShutdownInterface(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Shuts down the given IP Interface as a WMI provider.

Arguments:

	pInterface		- Pointer to our Interface structure

Return Value:

	None. If the interface was originally set up and we shut it down
	successfully, we dereference it.

--*/
{
	PATMARP_IF_WMI_INFO		pIfWmiInfo;

	do
	{
		//
		//  Check if we had successfully set up this interface for WMI.
		//
		pIfWmiInfo = pInterface->pIfWmiInfo;

		if (pIfWmiInfo == NULL)
		{
			break;
		}

		pInterface->pIfWmiInfo = NULL;

		//
		//  Deregister this device object with WMI.
		//
		IoWMIRegistrationControl(pIfWmiInfo->pDeviceObject, WMIREG_ACTION_DEREGISTER);

		//
		//  Delete the device object.
		//
		IoDeleteDevice(pIfWmiInfo->pDeviceObject);

		AA_FREE_IF_WMI_LOCK(pInterface);

		break;
	}
	while (FALSE);

	if (pIfWmiInfo)
	{
		AA_FREE_MEM(pIfWmiInfo);
	}

	return;
}



NTSTATUS
AtmArpWmiSetTCSupported(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Set function for the TC_SUPPORTED GUID.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	pInputBuffer	- Points to data value
	BufferLength	- Length of the above
	pBytesWritten	- Place to return how much was written
	pBytesNeeded	- If insufficient data, place to return expected data size

Return Value:

	STATUS_NOT_SUPPORTED. We don't allow setting the value of this GUID.

--*/
{
	*pBytesWritten = 0;

	return (STATUS_NOT_SUPPORTED);
}


NTSTATUS
AtmArpWmiQueryTCSupported(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Query function for the TC_SUPPORTED GUID. The value of this GUID is
	the list of IP Addresses assigned to this interface. This is returned
	using an ADDRESS_LIST_DESCRIPTOR data structure.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	pOutputBuffer	- Start of Buffer to be filled up
	BufferLength	- Length of the above
	pBytesReturned	- Place to return how much was returned
	pBytesNeeded	- If insufficient space, place to return expected data size

Return Value:

	STATUS_SUCCESS if we successfully filled in the address list,
	STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS	NtStatus;

#if NEWQOS
	PTC_SUPPORTED_INFO_BUFFER
				pInfo 		= (PTC_SUPPORTED_INFO_BUFFER)pOutputBuffer;
    UINT		HeaderSize  = FIELD_OFFSET(
								TC_SUPPORTED_INFO_BUFFER, 
								AddrListDesc
								);
	BOOLEAN 	CopiedHeader= FALSE;
#endif // NEWQOS

	do
	{

#if NEWQOS
		// address list
		if (BufferLength >= HeaderSize)
		{
			NDIS_STRING  DeviceGUID;
			//
			// Reserve space for the portion of SUPPORTED_INFO_BUFFER before
			// AddrListDesc, and fill it out
			//

			AA_ACQUIRE_IF_LOCK(pInterface);

			pOutputBuffer = &pInfo->AddrListDesc;
			BufferLength -= HeaderSize;
	
			DeviceGUID = pInterface->pAdapter->DeviceName; // struct copy.

			//
			// Need to skip past the "\\DEVICE\\" part of name.
			//
			if (DeviceGUID.Length > sizeof(L"\\DEVICE\\"))
			{
				DeviceGUID.Length -= sizeof(L"\\DEVICE\\");
				DeviceGUID.Buffer += sizeof(L"\\DEVICE\\")/sizeof(WCHAR);
			}

			if (sizeof(pInfo->InstanceID) < DeviceGUID.Length)
			{
				AA_ASSERT(FALSE);
				NtStatus =  STATUS_INVALID_PARAMETER;
				AA_RELEASE_IF_LOCK(pInterface);
				break;
			}

			pInfo->InstanceIDLength  = DeviceGUID.Length;
			AA_COPY_MEM(pInfo->InstanceID, DeviceGUID.Buffer, DeviceGUID.Length);
	
			CopiedHeader = TRUE;

			AA_RELEASE_IF_LOCK(pInterface);
		}
		else
		{
			BufferLength  = 0;
		}

#endif // NEWQOS
	
		NtStatus = AtmArpWmiGetAddressList(
					pInterface,
					pOutputBuffer,
					BufferLength,
					pBytesReturned,
					pBytesNeeded);
	
#if NEWQOS
		*pBytesNeeded	+= HeaderSize;
	
		if (CopiedHeader)
		{
			*pBytesReturned += HeaderSize;
		}
#endif // NEWQOS
	
	} while(FALSE);

	return (NtStatus);
}



NTSTATUS
AtmArpWmiGetAddressList(
	IN	PATMARP_INTERFACE			pInterface,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Prepare an address descriptor list out of the IP Addresses assigned
	to the specified interface. Use the buffer supplied for this.

Arguments:

	pInterface		- Pointer to our Interface structure
	pOutputBuffer	- Start of Buffer to be filled up
	BufferLength	- Length of the above
	pBytesReturned	- Place to return how much was returned
	pBytesNeeded	- If insufficient space, place to return expected data size

Return Value:

	STATUS_SUCCESS if we successfully filled in the address list,
	STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS							NtStatus;
	ULONG								BytesNeeded;
	ULONG								NumberOfIPAddresses;
	ADDRESS_LIST_DESCRIPTOR UNALIGNED *	pAddrListDescr;
	NETWORK_ADDRESS UNALIGNED *			pNwAddr;
	PIP_ADDRESS_ENTRY					pIPAddrEntry;

	NtStatus = STATUS_SUCCESS;

	AA_ACQUIRE_IF_LOCK(pInterface);

	do
	{
		*pBytesReturned = 0;
		NumberOfIPAddresses = pInterface->NumOfIPAddresses;

		//
		//  Compute the space needed.
		//
		BytesNeeded = (sizeof(ADDRESS_LIST_DESCRIPTOR) - sizeof(NETWORK_ADDRESS)) +

					  (NumberOfIPAddresses *
						(FIELD_OFFSET(NETWORK_ADDRESS, Address) + sizeof(NETWORK_ADDRESS_IP)));

		*pBytesNeeded = BytesNeeded;

		if (BytesNeeded > BufferLength)
		{
			NtStatus = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		pAddrListDescr = (PADDRESS_LIST_DESCRIPTOR)pOutputBuffer;

		pAddrListDescr->MediaType = NdisMediumAtm;
		pAddrListDescr->AddressList.AddressCount = NumberOfIPAddresses;
		pAddrListDescr->AddressList.AddressType = NDIS_PROTOCOL_ID_TCP_IP;

		//
		//  Copy in the IP addresses assigned to this Interface.
		//
		pIPAddrEntry = &pInterface->LocalIPAddress;
		pNwAddr = &pAddrListDescr->AddressList.Address[0];

		while (NumberOfIPAddresses--)
		{
			UNALIGNED NETWORK_ADDRESS_IP *pNetIPAddr =
				(NETWORK_ADDRESS_IP UNALIGNED *)&pNwAddr->Address[0];
			pNwAddr->AddressLength = sizeof(NETWORK_ADDRESS_IP);
			pNwAddr->AddressType = NDIS_PROTOCOL_ID_TCP_IP;

			//
			// Each *pNetIPAddr struct has the following fields, of which
			// only in_addr is used. We set the rest to zero.
			//
			// USHORT		sin_port;
			// ULONG		in_addr;
			// UCHAR		sin_zero[8];
			//
			AA_SET_MEM(pNetIPAddr, sizeof(*pNetIPAddr), 0);
			pNetIPAddr->in_addr = pIPAddrEntry->IPAddress;


			pIPAddrEntry = pIPAddrEntry->pNext;

			pNwAddr = (NETWORK_ADDRESS UNALIGNED *)
						((PUCHAR)pNwAddr + FIELD_OFFSET(NETWORK_ADDRESS, Address) + sizeof(IP_ADDRESS));
		}

		*pBytesReturned = BytesNeeded;
		AA_ASSERT(NT_SUCCESS(NtStatus));
		break;
	}
	while (FALSE);

	AA_RELEASE_IF_LOCK(pInterface);

	AADEBUGP(AAD_INFO,
		("WmiGetAddrList: IF x%x, OutBuf x%x, Len x%x, BytesRet %d, Needed %d, Sts x%x\n",
			pInterface, pOutputBuffer, BufferLength, *pBytesReturned, *pBytesNeeded, NtStatus));

	return (NtStatus);
}


VOID
AtmArpWmiEnableEventTCSupported(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	BOOLEAN						bEnable
)
/*++

Routine Description:

	Turns on/off event generation on the TC_SUPPORTED GUID. Since we don't
	generate events on this GUID, this is ignored.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	bEnable			- if true, enable events on this GUID, else disable.

Return Value:

	None

--*/
{
	return;
}



NTSTATUS
AtmArpWmiSetTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Set function for the TC_INTERFACE_INDICATION GUID.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	pInputBuffer	- Points to data value
	BufferLength	- Length of the above
	pBytesWritten	- Place to return how much was written
	pBytesNeeded	- If insufficient data, place to return expected data size

Return Value:

	STATUS_NOT_SUPPORTED. We don't allow setting the value of this GUID.

--*/
{
	*pBytesWritten = 0;

	return (STATUS_NOT_SUPPORTED);
}


NTSTATUS
AtmArpWmiQueryTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Query function for the TC_INTERFACE_INDICATION GUID. The
	value of this GUID is the list of IP Addresses assigned to
	this interface. This is returned using a TC_INDICATION_BUFFER
	data structure.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	pOutputBuffer	- Start of Buffer to be filled up
	BufferLength	- Length of the above
	pBytesReturned	- Place to return how much was returned
	pBytesNeeded	- If insufficient space, place to return expected data size

Return Value:

	STATUS_SUCCESS if we successfully filled in the address list,
	STATUS_XXX error code otherwise.

--*/
{
	PTC_INDICATION_BUFFER				pTcIndicationBuffer;
	NTSTATUS							NtStatus;
	ULONG								BytesReturned, BytesNeeded;
	PVOID								pAddrListBuffer;
	ULONG								AddrListBufferSize;
	ULONG								AddrListDescriptorOffset;

	pTcIndicationBuffer = (PTC_INDICATION_BUFFER)pOutputBuffer;

	pAddrListBuffer = (PVOID) &(pTcIndicationBuffer->InfoBuffer.AddrListDesc);
	AddrListDescriptorOffset = (ULONG)
						((PUCHAR) pAddrListBuffer - (PUCHAR) pOutputBuffer);

	AddrListBufferSize = ((BufferLength >= AddrListDescriptorOffset) ?
								 (BufferLength - AddrListDescriptorOffset): 0);

	NtStatus = AtmArpWmiGetAddressList(
				pInterface,
				pAddrListBuffer,
				AddrListBufferSize,
				&BytesReturned,
				&BytesNeeded);

	if (NT_SUCCESS(NtStatus))
	{
		pTcIndicationBuffer->SubCode = 0;
		*pBytesReturned = BytesReturned + AddrListDescriptorOffset;
	}
	else
	{
		*pBytesReturned = 0;
	}

	*pBytesNeeded = BytesNeeded + AddrListDescriptorOffset;

	return (NtStatus);
}


VOID
AtmArpWmiEnableEventTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	BOOLEAN						bEnable
)
/*++

Routine Description:

	Turns on/off event generation on the TC_INTERFACE_INDICATION GUID.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	bEnable			- if true, enable events on this GUID, else disable.

Return Value:

	None

--*/
{
	// CODE EnableEventTCIfIndication
	return;
}



VOID
AtmArpWmiSendTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ULONG						IndicationCode,
	IN	ULONG						IndicationSubCode
)
/*++

Routine Description:

	If event generation is allowed on TC_INTERFACE_INDICATION, send
	a WMI event now.

Arguments:

	pInterface		- Pointer to our Interface structure
	IndicationCode	- To be used in the event

Return Value:

	None

--*/
{
	PATMARP_IF_WMI_INFO				pIfWmiInfo;
	PATMARP_WMI_GUID				pArpGuid;
	ULONG							AddrBufferLength;
	ULONG							BytesReturned;
	UCHAR							DummyBuffer;
	PUCHAR							pOutputBuffer;
#ifndef NEWQOS
	PUCHAR							pDst;
#endif // !NEWQOS
	PWNODE_SINGLE_INSTANCE			pWnode;
	ULONG							WnodeSize;
	ULONG							TotalSize;
	NTSTATUS						NtStatus;

	pWnode = NULL;

	AA_ACQUIRE_IF_WMI_LOCK(pInterface);

	do
	{
		pIfWmiInfo = pInterface->pIfWmiInfo;

		if (pInterface->pIfWmiInfo == NULL)
		{
			//
			//  Haven't registered this interface with WMI.
			//
			break;
		}

		pArpGuid = &pIfWmiInfo->GuidInfo[IndicationCode];

		//
		//  Are we allowed to generate events on this GUID instance?
		//
		if (AA_IS_FLAG_SET(pArpGuid->Flags,
						   AWGF_EVENT_MASK,
						   AWGF_EVENT_DISABLED))
		{
			break;
		}

	#if NEWQOS
		//
		// Check if our instance name will fit into INFO_BUFFER.InstanceID
		//
		if (	pIfWmiInfo->InstanceName.Length
			 >  sizeof ((TC_SUPPORTED_INFO_BUFFER*)NULL)->InstanceID)
		{
			AA_ASSERT(FALSE);
			break;
		}
	#endif // NEWQOS

		//
		//  Find out how much space is needed for the data block.
		//
		pOutputBuffer = &DummyBuffer;
		AddrBufferLength = 0;

		NtStatus = AtmArpWmiGetAddressList(
					pInterface,
					pOutputBuffer,
					AddrBufferLength,
					&BytesReturned,
					&AddrBufferLength);

		AA_ASSERT(NtStatus == STATUS_INSUFFICIENT_RESOURCES);

		//
		//  Compute the total space for the WMI Event.
		//
		WnodeSize = ROUND_TO_8_BYTES(sizeof(WNODE_SINGLE_INSTANCE));

	#if NEWQOS
		TotalSize = WnodeSize 			+
					FIELD_OFFSET(					//  Indication upto info buf.
						TC_INDICATION_BUFFER,
						InfoBuffer)		+
					FIELD_OFFSET(					// info-buf upto AddrListDesc
						TC_SUPPORTED_INFO_BUFFER,
						AddrListDesc) 	+
					AddrBufferLength;					// AddrListDesc plus data.
	#else // !NEWQOS
		TotalSize = WnodeSize +
					//
					//  Counted Unicode string for the instance name:
					//
					sizeof(USHORT) +
					pIfWmiInfo->InstanceName.Length +
					//
					//  The actual data
					//
					AddrBufferLength;
	#endif // !NEWQOS

		//
		//  Allocate space for the entire lot. Since WMI will free
		//  it back to pool later, we don't use the usual allocation
		//  routine.
		//
		AA_ALLOC_FROM_POOL(pWnode, WNODE_SINGLE_INSTANCE, TotalSize);

		if (pWnode == NULL)
		{
			break;
		}

		AA_SET_MEM(pWnode, 0, TotalSize);

		pWnode->WnodeHeader.BufferSize = TotalSize;
		pWnode->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(pIfWmiInfo->pDeviceObject);
		pWnode->WnodeHeader.Version = ATMARP_WMI_VERSION;

		NdisGetCurrentSystemTime(&pWnode->WnodeHeader.TimeStamp);

		pWnode->WnodeHeader.Flags = WNODE_FLAG_EVENT_ITEM |
									 WNODE_FLAG_SINGLE_INSTANCE;


	#if NEWQOS

		{
			
			PTC_INDICATION_BUFFER pIndication
							= (PTC_INDICATION_BUFFER) ((PUCHAR)pWnode + WnodeSize);

			pIndication->SubCode = 0;  // Unused, must be 0.

			pIndication->InfoBuffer.InstanceIDLength
												= pIfWmiInfo->InstanceName.Length;
	
			//
			// We checked earlier if InstanceName will fit into InstanceID, so
			// the copy is safe.
			//
			AA_COPY_MEM(
				pIndication->InfoBuffer.InstanceID,
				pIfWmiInfo->InstanceName.Buffer,
				pIfWmiInfo->InstanceName.Length
				);
	
			//
			//  Get the address list.
			//
			NtStatus = AtmArpWmiGetAddressList(
						pInterface,
						&(pIndication->InfoBuffer.AddrListDesc),
						AddrBufferLength,
						&BytesReturned,
						&AddrBufferLength
						);
		}

	#else

		pDst = (PUCHAR)pWnode + WnodeSize;

		//
		//  Copy in the instance name.
		//
		*((PUSHORT)pDst) = pIfWmiInfo->InstanceName.Length;
		pDst += sizeof(USHORT);

		AA_COPY_MEM(pDst, pIfWmiInfo->InstanceName.Buffer, pIfWmiInfo->InstanceName.Length);

		pDst += pIfWmiInfo->InstanceName.Length;

		//
		//  Get the data.
		//
		NtStatus = AtmArpWmiGetAddressList(
					pInterface,
					pDst,
					AddrBufferLength,
					&BytesReturned,
					&AddrBufferLength);
	#endif // !NEWQOS


		AA_ASSERT(NtStatus == STATUS_SUCCESS);
		break;
	}
	while (FALSE);


	AA_RELEASE_IF_WMI_LOCK(pInterface);

	//
	//  Send off the event if OK. WMI will take care of freeing the
	//  entire structure back to pool.
	//
	if (pWnode)
	{
		NtStatus = IoWMIWriteEvent(pWnode);
		AADEBUGP(AAD_INFO, ("WmiSendTCIFInd: IF x%x, WMIWriteEv status x%x\n",
						pInterface, NtStatus));
		if (NtStatus!= STATUS_SUCCESS)
		{
			// Docs don't list pending as a possible return value.
			//
			ASSERT(NtStatus != STATUS_PENDING);
			AA_FREE_TO_POOL(pWnode);
		}
	}

	return;
}

NTSTATUS
AtmArpWmiQueryStatisticsBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Query function for the STATISTICS_BUFFER GUID.
	This function is unimplemented.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	pOutputBuffer	- Start of Buffer to be filled up
	BufferLength	- Length of the above
	pBytesReturned	- Place to return how much was returned
	pBytesNeeded	- If insufficient space, place to return expected data size

Return Value:

	STATUS_SUCCESS if we successfully filled in the address list,
	STATUS_XXX error code otherwise.

--*/
{
	return GPC_STATUS_RESOURCES;
}


NTSTATUS
AtmArpWmiSetStatisticsBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Set function for the  STATISTICS_BUFFER GUID.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	pInputBuffer	- Points to data value
	BufferLength	- Length of the above
	pBytesWritten	- Place to return how much was written
	pBytesNeeded	- If insufficient data, place to return expected data size

Return Value:

	STATUS_NOT_SUPPORTED. We don't allow setting the value of this GUID.

--*/
{
	*pBytesWritten = 0;

	return (STATUS_NOT_SUPPORTED);
}


PATMARP_INTERFACE
AtmArpWmiGetIfByName(
	IN	PWSTR						pIfName,
	IN	USHORT						IfNameLength
)
/*++

Routine Description:

	Given a name, locate and return the Interface whose instance name
	matches it. A temporary reference to the interface is added -- the caller
	is expected to deref the interface when done with it.

Arguments:

	pIfName			- Points to name to be searched for
	IfNameLength	- length of above

Return Value:

	Pointer to ATMARP interface if found, NULL otherwise.

--*/
{
	PATMARP_ADAPTER			pAdapter;
	PATMARP_INTERFACE		pInterface;

	pInterface = NULL_PATMARP_INTERFACE;

	//
	//  Knock off the terminating NULL WCHAR.
	//
	if (IfNameLength > sizeof(WCHAR))
	{
		IfNameLength -= sizeof(WCHAR);
	}

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	for (pAdapter = pAtmArpGlobalInfo->pAdapterList;
		 pAdapter != NULL_PATMARP_ADAPTER;
		 pAdapter = pAdapter->pNextAdapter)
	{
		for (pInterface = pAdapter->pInterfaceList;
			 pInterface != NULL_PATMARP_INTERFACE;
			 pInterface = pInterface->pNextInterface)
		{
#if DBG
			AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
			if (pInterface->pIfWmiInfo)
			{
				AADEBUGP(AAD_WARNING,
					("Given len %d, string %ws\n", IfNameLength, pIfName));

				AADEBUGP(AAD_WARNING,
					("   IF len %d, string %ws\n",
						pInterface->pIfWmiInfo->InstanceName.Length,
						pInterface->pIfWmiInfo->InstanceName.Buffer));
			}
			AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
#endif // DBG
					
			if ((pInterface->pIfWmiInfo != NULL) &&
				(pInterface->pIfWmiInfo->InstanceName.Length == IfNameLength) &&
				(AA_MEM_CMP(pInterface->pIfWmiInfo->InstanceName.Buffer,
							pIfName,
							IfNameLength) == 0))
			{
				//
				//  Found it.
				//

				AA_ACQUIRE_IF_LOCK(pInterface);
				AtmArpReferenceInterface(pInterface); // WMI: Tmp ref.
				AA_RELEASE_IF_LOCK(pInterface);

				break;
			}
		}

		if (pInterface != NULL_PATMARP_INTERFACE)
		{
			break;
		}
	}

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	return (pInterface);
}

#endif // ATMARP_WMI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\callmgr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	callmgr.c	- Call Manager Interface routines.

Abstract:

	Call Manager Interface routines for the ATMARP Client, including
	NDIS entry points for that interface.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     02-15-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'RGMC'


VOID
AtmArpCoAfRegisterNotifyHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY			pAddressFamily
)
/*++

Routine Description:

	This routine is called by NDIS when a Call manager registers its support
	for an Address Family over an adapter. If this is the Address Family we
	are interested in (UNI 3.1), then we start up all LIS' configured on
	this adapter.

Arguments:

	ProtocolBindingContext	- our context passed in NdisOpenAdapter, which is
							  a pointer to our Adapter structure.
	pAddressFamily			- points to a structure describing the Address Family
							  being registered by a Call Manager.

Return Value:

	None

--*/
{
	PATMARP_ADAPTER				pAdapter;
	PATMARP_INTERFACE			pInterface;			// Pointer to new ATMARP Interface
	ULONG						NumIFConfigured;	// # of LIS' over this adapter
	ULONG						NumIFActivated;		// # activated successfully here

	NDIS_STATUS					Status;
	NDIS_HANDLE					LISConfigHandle;	// Handle to per-LIS config

	struct LLIPBindInfo			BindInfo;
	BOOLEAN						bProcessingAf;

	//
	//  Initialize.
	//
	Status = NDIS_STATUS_SUCCESS;
	pAdapter = NULL_PATMARP_ADAPTER;
	LISConfigHandle = NULL;
	NumIFActivated = 0;
	bProcessingAf = FALSE;

	do
	{
		//
		//  Check if this AF is interesting to us.
		//
		if ((pAddressFamily->AddressFamily != CO_ADDRESS_FAMILY_Q2931) ||
			(pAddressFamily->MajorVersion != 3) ||
			(pAddressFamily->MinorVersion != 1))
		{
			AADEBUGP(AAD_LOUD, 
			("CoAfRegisterNotifyHandler: uninteresting AF %d or MajVer %d or MinVer %d\n",
				pAddressFamily->AddressFamily,
				pAddressFamily->MajorVersion,
				pAddressFamily->MinorVersion));
			Status = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}

		pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;
		AA_STRUCT_ASSERT(pAdapter, aaa);

		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		if (pAdapter->Flags & AA_ADAPTER_FLAGS_UNBINDING)
		{
			AADEBUGP(AAD_INFO,
				("CoAfRegisterNotify: Adapter %x is unbinding, bailing out\n", pAdapter));

    		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  If we have already created LIS' on this adapter, we don't want
		//  to open this Call Manager (multiple Call Managers supporting the
		//  same AF on the same adapter?)
		//
		if (pAdapter->pInterfaceList != NULL_PATMARP_INTERFACE)
		{
			AADEBUGP(AAD_WARNING,
				("CoAfRegisterNotifyHandler: pAdapter 0x%x, IFs (%x) already created!\n",
				pAdapter, pAdapter->pInterfaceList));
    		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		if (pAdapter->Flags & AA_ADAPTER_FLAGS_PROCESSING_AF)
		{
			AADEBUGP(AAD_WARNING,
				("CoAfRegisterNotifyHandler: pAdapter 0x%x, Already processing AF!\n",
				pAdapter));
    		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Make sure that we don't let an UnbindAdapter thread preempt us.
		//
		AA_INIT_BLOCK_STRUCT(&pAdapter->UnbindBlock);
		pAdapter->Flags |= AA_ADAPTER_FLAGS_PROCESSING_AF;
		bProcessingAf = TRUE;

		if (pAdapter->Flags & AA_ADAPTER_FLAGS_AF_NOTIFIED)
		{
			//
			// This can happen when resuming from suspend/hibernate, since
			// we do not get unbound from the adapter. All IFs go away,
			// but the adapter remains.
			//
			// So we skip the one-time init stuff (see below), but go ahead
			// and process the AF and create IFs now.
			//
			AADEBUGP(AAD_WARNING,
				("CoAfRegisterNotify: Adapter %x seen AF notify already, Flags %x\n",
					pAdapter, pAdapter->Flags));
    		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		}
		else
		{
			//
			// Do one-time init stuff for this adapter.
			//

			pAdapter->Flags |= AA_ADAPTER_FLAGS_AF_NOTIFIED;
			AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);


			//
			//  Query the adapter (miniport) for information about the adapter
			//  we are bound to.
			//
			Status = AtmArpGetAdapterInfo(pAdapter);
			if (Status != NDIS_STATUS_SUCCESS)
			{
				AADEBUGP(AAD_WARNING,
							("CoAfRegisterNotifyHandler: Failed to get adapter info.\n"));
				break;
			}
	
			//
			// Read the adapter's configuration information from the registry.
			//
			Status =  AtmArpCfgReadAdapterConfiguration(pAdapter);
			if (Status != NDIS_STATUS_SUCCESS)
			{
				AADEBUGP(AAD_WARNING,
							("CoAfRegisterNotifyHandler: Failed to open adapter configuration\n"));
				break;
			}
		}

		AADEBUGP(AAD_WARNING,
			("CoAfRegisterNotify: Adapter %x/%x, starting up\n", pAdapter, pAdapter->Flags));

		//
		//  Initialize some variables so that we know if we failed
		//  somewhere in the following loop.
		//
		LISConfigHandle = NULL;
		pInterface = NULL_PATMARP_INTERFACE;

		//
		//  Set up IP and NDIS interfaces for each LIS configured
		//  for this adapter. Loop while there are more LIS'.
		//
		for (NumIFConfigured = 0;
				;					// Stop only on error or no more LIS
			 NumIFConfigured++)
		{
#ifdef NEWARP
			//
			//  TCP/IP's Configuration section for this interface.
			//
			NDIS_STRING			IPConfigString;
#endif // NEWARP

			//
			//  Process LIS # NumIFConfigured.
			//

			//  Open the configuration section for this LIS. We use
			//  "NumIFConfigured" as the index of the LIS to be opened.
			//
			LISConfigHandle = AtmArpCfgOpenLISConfiguration(
										pAdapter,
										NumIFConfigured
#ifdef NEWARP
										,
										&IPConfigString
#endif // NEWARP
										);

			if (LISConfigHandle == NULL)
			{
				//
				//  This is the normal termination condition, i.e.
				//  we reached the end of the LIS list for this
				//  adapter.
				//
				AADEBUGP(AAD_INFO, ("NotifyRegAfHandler: cannot open LIS %d\n",
							NumIFConfigured));
				Status = NDIS_STATUS_SUCCESS;
				break; // out of for loop
			}


			pInterface =  AtmArpAddInterfaceToAdapter (
							pAdapter,
							LISConfigHandle,
							&IPConfigString
							);

			//
			//  Close the configuration section for this LIS.
			//
			AtmArpCfgCloseLISConfiguration(LISConfigHandle);
			LISConfigHandle = NULL;

			if (pInterface == NULL_PATMARP_INTERFACE)
			{
				Status = NDIS_STATUS_FAILURE;
				break;
			}


		}	// for

	}
	while (FALSE);


	if (NumIFActivated > 0)
	{
		//
		//  We managed to activate atleast one Logical IP Subnet
		//  on this adapter.
		//
		pAdapter->InterfaceCount = NumIFActivated;
	}

	if (bProcessingAf)
	{
		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		pAdapter->Flags &= ~AA_ADAPTER_FLAGS_PROCESSING_AF;
		AA_SIGNAL_BLOCK_STRUCT(&pAdapter->UnbindBlock, NDIS_STATUS_SUCCESS);
		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	}

	return;

}


NDIS_STATUS
AtmArpOpenCallMgr(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Start access to the Call Manager on the specified Interface,
	by doing the following:
		- Open Address Family

	For all of these, we wait for completion in case they pend.

	It is assumed that the Interface structure is locked.

Arguments:

	pInterface	- pointer to the ATMARP interface

Return Value:

	NDIS status.

--*/
{
	PCO_ADDRESS_FAMILY		pAddressFamily;
	NDIS_STATUS				Status;
	ULONG					RequestSize;

	pAddressFamily = (PCO_ADDRESS_FAMILY)NULL;
	Status = NDIS_STATUS_SUCCESS;


	do {

		//
		//  Allocate everything we need
		//
		RequestSize = sizeof(CO_ADDRESS_FAMILY)+
						sizeof(CO_SAP)+
						sizeof(ATM_SAP)+
						sizeof(ATM_ADDRESS);
		AA_ALLOC_MEM(
						pAddressFamily,
						CO_ADDRESS_FAMILY,
						RequestSize
					);

		if (pAddressFamily == (PCO_ADDRESS_FAMILY)NULL)
		{
			AADEBUGP(AAD_ERROR, ("OpenCallMgr: alloc failed!\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  DONT remove the following
		//
		AA_SET_MEM((PUCHAR)pAddressFamily, 0, RequestSize);
	
		//
		//  The Address Family we are interested in is Q.2931 (UNI 3.1)
		//
		pAddressFamily->AddressFamily = CO_ADDRESS_FAMILY_Q2931;
		pAddressFamily->MajorVersion = 3;
		pAddressFamily->MinorVersion = 1;

		AA_INIT_BLOCK_STRUCT(&(pInterface->Block));
		Status = NdisClOpenAddressFamily(
					pInterface->NdisAdapterHandle,
					pAddressFamily,
					(NDIS_HANDLE)pInterface,
					&AtmArpClientCharacteristics,
					sizeof(AtmArpClientCharacteristics),
					&(pInterface->NdisAfHandle)
				);

		if (Status == NDIS_STATUS_PENDING)
		{
			//
			//  Wait for completion
			//
			Status = AA_WAIT_ON_BLOCK_STRUCT(&(pInterface->Block));
		}

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_ERROR, ("Open Af returned error: 0x%x\n", Status));
			break;
		}

		AADEBUGP(AAD_INFO, ("Interface: 0x%x, Got NdisAfHandle: 0x%x\n",
						pInterface, pInterface->NdisAfHandle));

		break;
	}
	while (FALSE);

	if (pAddressFamily != (PCO_ADDRESS_FAMILY)NULL)
	{
		AA_FREE_MEM(pAddressFamily);
	}

	AADEBUGP(AAD_LOUD, ("Open Call Mgr returning 0x%x\n", Status));

	return (Status);

}



VOID
AtmArpCloseCallMgr(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Halt access to the Call Manager on the specified interface. It is
	assumed that all VCs and SAPs pertaining to the "Address Family Open"
	have been released.

Arguments:

	pInterface	- pointer to the ATMARP interface

Return Value:

	None

--*/
{
	NDIS_STATUS		Status;
	NDIS_HANDLE		NdisAfHandle;

	NdisAfHandle = pInterface->NdisAfHandle;
	pInterface->NdisAfHandle = NULL;

	AADEBUGP(AAD_INFO,
		 ("Closing Call Mgr on Interface: 0x%x, AfH: 0x%x\n",
			 pInterface, NdisAfHandle));

	if (NdisAfHandle != (NDIS_HANDLE)NULL)
	{
		Status = NdisClCloseAddressFamily(NdisAfHandle);

		AADEBUGP(AAD_INFO, ("NdisClCloseAF on IF 0x%x returned 0x%x\n",
			 pInterface, Status));

		if (Status != NDIS_STATUS_PENDING)
		{
			AtmArpCloseAfCompleteHandler(
					Status,
					(NDIS_HANDLE)pInterface
					);
		}
	}
}




VOID
AtmArpRegisterSaps(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Register all SAPs configured on the given ATMARP interface.
	Atleast one SAP must be present in the list of SAPs on the
	interface.

	We just issue the NdisClRegisterSap requests for all SAPs.
	We don't wait for completion.

Arguments:

	pInterface			- Pointer to ATMARP Interface

Return Value:

	None

--*/
{
	PATMARP_SAP					pAtmArpSap;
	PATMARP_SAP					pNextSap;
	PCO_SAP						pSapInfo;
	NDIS_STATUS					Status;
	NDIS_HANDLE					NdisAfHandle;
	ULONG						rc;				// Ref count on Interface

	AA_ACQUIRE_IF_LOCK(pInterface);

	AA_ASSERT(pInterface->NumberOfSaps > 0);

	//
	//  Initialize
	//
	pAtmArpSap = &(pInterface->SapList);
	NdisAfHandle = pInterface->NdisAfHandle;

	//
	//  Make sure that the Interface doesn't go away.
	//
	AtmArpReferenceInterface(pInterface);
	AA_RELEASE_IF_LOCK(pInterface);

	do
	{
		pSapInfo = pAtmArpSap->pInfo;
		pAtmArpSap->NdisSapHandle = NULL;
		AA_SET_FLAG(pAtmArpSap->Flags,
					AA_SAP_REG_STATE_MASK,
					AA_SAP_REG_STATE_REGISTERING);

		pNextSap = pAtmArpSap->pNextSap;

		//
		//  The ATMARP SAP structure itself won't go away as long as
		//  the Interface structure lives.
		//
		Status = NdisClRegisterSap(
						NdisAfHandle,
						(NDIS_HANDLE)pAtmArpSap,		// ProtocolSapContext
						pSapInfo,
						&(pAtmArpSap->NdisSapHandle)
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			AtmArpRegisterSapCompleteHandler(
						Status,
						(NDIS_HANDLE)pAtmArpSap,
						pSapInfo,
						pAtmArpSap->NdisSapHandle
						);
		}

		pAtmArpSap = pNextSap;
	}
	while (pAtmArpSap != NULL_PATMARP_SAP);

	//
	//  Remove the reference we added earlier to the Interface.
	//
	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);
	if (rc > 0)
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}
	//
	//  else the Interface is gone!

}


VOID
AtmArpDeregisterSaps(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Deregister all SAPs on an ATMARP Interface. We issue NdisClDeregisterSap
	calls on all SAPs we have currently registered.

Arguments:

	pInterface			- Pointer to ATMARP Interface

Return Value:

	None

--*/
{
	NDIS_HANDLE					NdisSapHandle;
	ULONG						rc;				// Reference count on Interface
	PATMARP_SAP					pAtmArpSap;
	PATMARP_SAP					pNextSap;
	NDIS_STATUS					Status;

	AA_ACQUIRE_IF_LOCK(pInterface);

	//
	//  Initialize
	//
	pAtmArpSap = &(pInterface->SapList);

	//
	//  Make sure the Interface structure doesn't go away.
	//
	AtmArpReferenceInterface(pInterface);

	AA_RELEASE_IF_LOCK(pInterface);

	do
	{
		NdisSapHandle = pAtmArpSap->NdisSapHandle;
		pNextSap = pAtmArpSap->pNextSap;

		if (NdisSapHandle != NULL)
		{
			Status = NdisClDeregisterSap(NdisSapHandle);
			if (Status != NDIS_STATUS_PENDING)
			{
				AtmArpDeregisterSapCompleteHandler(
						Status,
						(NDIS_HANDLE)pAtmArpSap
						);
			}
		}

		pAtmArpSap = pNextSap;
	}
	while (pAtmArpSap != NULL_PATMARP_SAP);

	//
	//  Remove the reference we added earlier to the Interface.
	//
	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);
	if (rc > 0)
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}
	//
	//  else the interface is gone
	//
}



NDIS_STATUS
AtmArpMakeCall(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_ATM_ENTRY			pAtmEntry	LOCKIN NOLOCKOUT,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PNDIS_PACKET				pPacketToBeQueued	OPTIONAL
)
/*++

Routine Description:

	Place a call to the given destination. Map the specified flow
	specs to ATM QoS/Traffic parameters.

	NOTE: The caller is assumed to hold a lock for the ATM Entry,
	which will be released here. The reason we do it this way is so that
	nobody else can come in and try to make another call (of the same kind)
	to this ATM Entry -- once we get a new VC into the ATM Entry's list,
	we can release its lock.

	SIDE EFFECT: If the NDIS call doesn't pend, then we call our
	MakeCall completion handler from here, and return NDIS_STATUS_PENDING
	to the caller.


Arguments:

	pInterface			- the ARP Interface originating this call
	pAtmEntry			- Pointer to ATM Address Entry corresponding to the
						  called address.
	pFlowSpec			- pointer to a Flow Spec structure containing parameters
						  for the call
	pPacketToBeQueued	- Optionally, a packet to be queued for transmission when
						  the call is established.

Return Value:

	If there is an immediate failure (e.g. allocation failure), we return
	NDIS_STATUS_XXX denoting that failure.

	If we made it to the call to NdisClMakeCall(), we return NDIS_STATUS_PENDING.
	However, if NDIS returns other than NDIS_STATUS_PENDING, we'd also
	call our MakeCall completion handler.

--*/
{

	//
	//  New VC structure to be allocated for this call
	//
	PATMARP_VC								pVc;

	NDIS_HANDLE								NdisVcHandle;
	NDIS_HANDLE								ProtocolVcContext;
	NDIS_HANDLE								ProtocolPartyContext;
	PNDIS_HANDLE							pNdisPartyHandle;
	NDIS_STATUS								Status;
	BOOLEAN									IsPMP;
	PATM_ADDRESS							pCalledAddress;

	//
	//  Set of parameters for a MakeCall
	//
	PCO_CALL_PARAMETERS						pCallParameters;
	PCO_CALL_MANAGER_PARAMETERS				pCallMgrParameters;

	PQ2931_CALLMGR_PARAMETERS				pAtmCallMgrParameters;

	//
	//  All Info Elements that we need to fill:
	//
	Q2931_IE UNALIGNED *								pIe;
	AAL_PARAMETERS_IE UNALIGNED *						pAalIe;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *				pTrafficDescriptor;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *		pBbc;
	ATM_BLLI_IE UNALIGNED *								pBlli;
	ATM_QOS_CLASS_IE UNALIGNED *						pQos;

	//
	//  Total space requirements for the MakeCall
	//
	ULONG									RequestSize;

	//
	//  Did we queue the given packet?
	//
	BOOLEAN									PacketWasQueued = FALSE;


	AA_STRUCT_ASSERT(pInterface, aai);
	AA_STRUCT_ASSERT(pAtmEntry, aae);

	AA_ASSERT(pInterface->AdminState == IF_STATUS_UP);


	do
	{
		if (pPacketToBeQueued != (PNDIS_PACKET)NULL)
		{
			//
			// Make this a list of exactly one packet.
			//
			AA_SET_NEXT_PACKET(pPacketToBeQueued, NULL);
		}

		//
		// Fail makecall if atmentry state is really closing.
		//

		if (AA_IS_FLAG_SET(
								pAtmEntry->Flags,
								AA_ATM_ENTRY_STATE_MASK,
								AA_ATM_ENTRY_CLOSING))
		{
			BOOLEAN ReallyClosing = TRUE;

			//
			// This may be a harmless close -- if the interface is not shutting
			// down we check if it's a harmless close, else (if the interface
			// is shutting down) we fail the call anyway. Note that we don't
			// claim the interface list lock (which is used to guard access
			// to AtmEntryListUp) -- we don't do this because we currently
			// hold the lock to pAtmEntry (and don't want to release it), so if
			// AtmEntryListUp is in the
			// process of being set to FALSE, when we read it's value here,
			// in the worst case we'll read it's value as TRUE and conclude that
			// the atm entry is not really closing and go ahead and make the call.
			// However in this case, the shutdown routine will invalidate the call.
			//
			if (pInterface->AtmEntryListUp)
			{
				//
				// WARNING: AtmArpAtmEntryIsReallyClosing may clear the
				// CLOSING state (if the entry is basically idle) --
				// see comments in that function.
				//
				ReallyClosing =  AtmArpAtmEntryIsReallyClosing(pAtmEntry);
			}

			if (ReallyClosing)
			{
				AADEBUGP(AAD_FATAL,
			 ("AtmArpMakeCall -- failing because AE 0x%lx is really closing.\n",
			 	pAtmEntry));
				Status = NDIS_STATUS_FAILURE;
				break;
			}
		}

		//
		//  Some initialization.
		//


		if (AA_IS_FLAG_SET(pAtmEntry->Flags,
							AA_ATM_ENTRY_TYPE_MASK,
							AA_ATM_ENTRY_TYPE_UCAST))
		{
			IsPMP = FALSE;
			ProtocolPartyContext = NULL;
			pNdisPartyHandle = NULL;
			pCalledAddress = &(pAtmEntry->ATMAddress);
		}
#ifdef IPMCAST
		else
		{
			IsPMP = TRUE;
			ProtocolPartyContext = (NDIS_HANDLE)(pAtmEntry->pMcAtmInfo->pMcAtmEntryList);
			pNdisPartyHandle = &(pAtmEntry->pMcAtmInfo->pMcAtmEntryList->NdisPartyHandle);
			pCalledAddress = &(pAtmEntry->pMcAtmInfo->pMcAtmEntryList->ATMAddress);
		}
#else
		else
		{
			AA_ASSERT(FALSE);
		}
#endif // IPMCAST

		//
		//  Compute all the space needed for the MakeCall, and allocate it
		//  in one big block.
		//
		RequestSize = 	sizeof(CO_CALL_PARAMETERS) +
						sizeof(CO_CALL_MANAGER_PARAMETERS) +
						sizeof(Q2931_CALLMGR_PARAMETERS) +
						ATMARP_MAKE_CALL_IE_SPACE +
						0;

		AA_ALLOC_MEM(pCallParameters, CO_CALL_PARAMETERS, RequestSize);

		if (pCallParameters == (PCO_CALL_PARAMETERS)NULL)
		{
			AADEBUGP(AAD_WARNING, ("Make Call: alloc (%d) failed\n", RequestSize));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Allocate a VC structure for the call
		//
		pVc = AtmArpAllocateVc(pInterface);

		if (pVc == NULL_PATMARP_VC)
		{
			AADEBUGP(AAD_WARNING, ("Make Call: failed to allocate VC\n"));
			AA_FREE_MEM(pCallParameters);
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  For a later call to MakeCallComplete
		//
		ProtocolVcContext = (NDIS_HANDLE)pVc;

		//
		//  Get an NDIS handle for this VC
		//
		NdisVcHandle = (NDIS_HANDLE)NULL;
		Status = NdisCoCreateVc(
						pInterface->NdisAdapterHandle,
						pInterface->NdisAfHandle,
						ProtocolVcContext,
						&NdisVcHandle
						);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AA_ASSERT(Status != NDIS_STATUS_PENDING);

			AADEBUGP(AAD_WARNING, ("Make Call: NdisCoCreateVc failed: 0x%x\n", Status));
			AA_FREE_MEM(pCallParameters);
			AtmArpDeallocateVc(pVc);
			break;
		}

		AADEBUGP(AAD_VERY_LOUD,
			("Make Call: pAtmEntry 0x%x, pVc 0x%x, got NdisVcHandle 0x%x\n",
				pAtmEntry,
				pVc,
				NdisVcHandle));

		AtmArpReferenceVc(pVc);	// CreateVC reference

		//
		//  At this point, we are sure that we will call NdisClMakeCall.
		//

		//
		//  Now fill in the rest of the VC structure. We don't need a lock
		//  for the VC until it gets linked to the ATM Entry structure.
		//
		pVc->NdisVcHandle = NdisVcHandle;
		pVc->Flags = 	AA_VC_TYPE_SVC |
						AA_VC_OWNER_IS_ATMARP |
						AA_VC_CALL_STATE_OUTGOING_IN_PROGRESS;
		if (IsPMP)
		{
			pVc->Flags |= AA_VC_CONN_TYPE_PMP;
		}
		else
		{
			pVc->Flags |= AA_VC_CONN_TYPE_P2P;
		}
		pVc->FlowSpec = *pFlowSpec;

		//
		//  Make sure that the packet sizes are within the miniport's range.
		//
		if (pVc->FlowSpec.SendMaxSize > pInterface->pAdapter->MaxPacketSize)
		{
			pVc->FlowSpec.SendMaxSize = pInterface->pAdapter->MaxPacketSize;
		}
		if (pVc->FlowSpec.ReceiveMaxSize > pInterface->pAdapter->MaxPacketSize)
		{
			pVc->FlowSpec.ReceiveMaxSize = pInterface->pAdapter->MaxPacketSize;
		}

		if (pPacketToBeQueued != (PNDIS_PACKET)NULL)
		{
			pVc->PacketList = pPacketToBeQueued;
			PacketWasQueued = TRUE;
		}

#ifdef IPMCAST
		AtmArpFillCallParameters(
				pCallParameters,
				RequestSize,
				pCalledAddress,
				&(pInterface->LocalAtmAddress),	// Calling address
				&(pVc->FlowSpec),
				IsPMP,
				TRUE	// IsMakeCall?
				);
#else
		//
		//  Zero out everything
		//
		AA_SET_MEM((PUCHAR)pCallParameters, 0, RequestSize);

		//
		//  Distribute space amongst the various structures
		//
		pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
								((PUCHAR)pCallParameters +
									 sizeof(CO_CALL_PARAMETERS));


		//
		//  Set pointers to link the above structures together
		//
		pCallParameters->CallMgrParameters = pCallMgrParameters;
		pCallParameters->MediaParameters = (PCO_MEDIA_PARAMETERS)NULL;

		pCallMgrParameters->CallMgrSpecific.ParamType = 0;
		pCallMgrParameters->CallMgrSpecific.Length = 
							sizeof(Q2931_CALLMGR_PARAMETERS) +
							ATMARP_CALL_IE_SPACE;

		pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
									pCallMgrParameters->CallMgrSpecific.Parameters;


		//
		//  Call Manager generic flow parameters:
		//
		pCallMgrParameters->Transmit.TokenRate = (pFlowSpec->SendAvgBandwidth);
		pCallMgrParameters->Transmit.TokenBucketSize = (pFlowSpec->SendMaxSize);
		pCallMgrParameters->Transmit.MaxSduSize = pFlowSpec->SendMaxSize;
		pCallMgrParameters->Transmit.PeakBandwidth = (pFlowSpec->SendPeakBandwidth);
		pCallMgrParameters->Transmit.ServiceType = pFlowSpec->SendServiceType;

		pCallMgrParameters->Receive.TokenRate = (pFlowSpec->ReceiveAvgBandwidth);
		pCallMgrParameters->Receive.TokenBucketSize = pFlowSpec->ReceiveMaxSize;
		pCallMgrParameters->Receive.MaxSduSize = pFlowSpec->ReceiveMaxSize;
		pCallMgrParameters->Receive.PeakBandwidth = (pFlowSpec->ReceivePeakBandwidth);
		pCallMgrParameters->Receive.ServiceType = pFlowSpec->ReceiveServiceType;

		//
		//  Q2931 Call Manager Parameters:
		//

		//
		//  Called address:
		//
		//  TBD: Add Called Subaddress IE in outgoing call.
		//
		AA_COPY_MEM((PUCHAR)&(pAtmCallMgrParameters->CalledParty),
					  (PUCHAR)&(pAtmEntry->ATMAddress),
					  sizeof(ATM_ADDRESS));

		//
		//  Calling address:
		//
		AA_COPY_MEM((PUCHAR)&(pAtmCallMgrParameters->CallingParty),
					  (PUCHAR)&(pInterface->LocalAtmAddress),
					  sizeof(ATM_ADDRESS));


		//
		//  RFC 1755 (Sec 5) says that the following IEs MUST be present in the
		//  SETUP message, so fill them all.
		//
		//      AAL Parameters
		//      Traffic Descriptor
		//      Broadband Bearer Capability
		//      Broadband Low Layer Info
		//      QoS
		//

		//
		//  Initialize the Info Element list
		//
		pAtmCallMgrParameters->InfoElementCount = 0;
		pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);


		//
		//  AAL Parameters:
		//

		{
			UNALIGNED AAL5_PARAMETERS	*pAal5;

			pIe->IEType = IE_AALParameters;
			pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE;
			pAalIe = (PAAL_PARAMETERS_IE)pIe->IE;
			pAalIe->AALType = AAL_TYPE_AAL5;
			pAal5 = &(pAalIe->AALSpecificParameters.AAL5Parameters);
			pAal5->ForwardMaxCPCSSDUSize = pFlowSpec->SendMaxSize;
			pAal5->BackwardMaxCPCSSDUSize = pFlowSpec->ReceiveMaxSize;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


		//
		//  Traffic Descriptor:
		//

		pIe->IEType = IE_TrafficDescriptor;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE;
		pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)pIe->IE;

		if (pFlowSpec->SendServiceType == SERVICETYPE_BESTEFFORT)
		{
			pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->SendPeakBandwidth);
			pTrafficDescriptor->BackwardTD.PeakCellRateCLP01 = 
									BYTES_TO_CELLS(pFlowSpec->ReceivePeakBandwidth);
			pTrafficDescriptor->BestEffort = TRUE;
		}
		else
		{
			//  Predictive/Guaranteed service (we map this to CBR, see BBC below)
				pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->SendPeakBandwidth);
				pTrafficDescriptor->BackwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->ReceivePeakBandwidth);
			pTrafficDescriptor->BestEffort = FALSE;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


		//
		//  Broadband Bearer Capability
		//

		pIe->IEType = IE_BroadbandBearerCapability;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE;
		pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)pIe->IE;

		pBbc->BearerClass = BCOB_X;
		pBbc->UserPlaneConnectionConfig = UP_P2P;
		if (pFlowSpec->SendServiceType == SERVICETYPE_BESTEFFORT)
		{
			pBbc->TrafficType = TT_NOIND;
			pBbc->TimingRequirements = TR_NOIND;
			pBbc->ClippingSusceptability = CLIP_NOT;
		}
		else
		{
			pBbc->TrafficType = TT_CBR;
			pBbc->TimingRequirements = TR_END_TO_END;
			pBbc->ClippingSusceptability = CLIP_SUS;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


		//
		//  Broadband Lower Layer Information
		//

		pIe->IEType = IE_BLLI;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE;
		pBlli = (PATM_BLLI_IE)pIe->IE;
		AA_COPY_MEM((PUCHAR)pBlli,
					  (PUCHAR)&AtmArpDefaultBlli,
					  sizeof(ATM_BLLI_IE));

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


		//
		//  QoS
		//

		pIe->IEType = IE_QOSClass;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE;
		pQos = (PATM_QOS_CLASS_IE)pIe->IE;
		if (pFlowSpec->SendServiceType == SERVICETYPE_BESTEFFORT)
		{
			pQos->QOSClassForward = pQos->QOSClassBackward = 0;
		}
		else
		{
			pQos->QOSClassForward = pQos->QOSClassBackward = 1;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
#endif // IPMCAST

		//
		//  We add the Call reference and ATM Entry Link reference
		//  right here
		//
		AtmArpReferenceVc(pVc);	// Call reference (MakeCall coming up)
		AtmArpReferenceVc(pVc);	// ATM Entry link reference (coming up below)

#ifdef IPMCAST
		if (IsPMP)
		{
			pAtmEntry->pMcAtmInfo->TransientLeaves++;
		}
#endif // IPMCAST

		//
		//  We are ready to make the call. Before we do so, we need to
		//  link the VC structure to the ATM Entry, and release the
		//  ATM Entry lock
		//
		AtmArpLinkVcToAtmEntry(pVc, pAtmEntry);
		AA_RELEASE_AE_LOCK(pAtmEntry);	// acquired by caller

		//
		//  Make the Call now
		//
		Status = NdisClMakeCall(
						NdisVcHandle,
						pCallParameters,
						ProtocolPartyContext,
						pNdisPartyHandle
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			NDIS_HANDLE			NdisPartyHandle;

			NdisPartyHandle = ((pNdisPartyHandle != NULL)?
								*pNdisPartyHandle : NULL);

			AtmArpMakeCallCompleteHandler(
						Status,
						ProtocolVcContext,
						NdisPartyHandle,
						pCallParameters
						);
			Status = NDIS_STATUS_PENDING;
		}
		//
		//  else the MakeCall complete handler will be called
		//  later
		//

	} while (FALSE);

	if (Status != NDIS_STATUS_PENDING)
	{
		ULONG		Flags;
		//
		//  Something failed within this routine.
		//  Recovery:
		//  - Release the ATM Entry lock
		//  - If we were given a packet for queueing, and we didn't do so,
		//    then free it
		//
		Flags = pAtmEntry->Flags;
		AA_RELEASE_AE_LOCK(pAtmEntry);	// acquired by caller
		if ((pPacketToBeQueued != (PNDIS_PACKET)NULL) && (!PacketWasQueued))
		{
			AA_HEADER_TYPE		HdrType;
			BOOLEAN				HdrPresent;

			if (pFlowSpec->Encapsulation == ENCAPSULATION_TYPE_LLCSNAP)
			{
				HdrPresent = TRUE;
				if (AA_IS_FLAG_SET(Flags,
									AA_ATM_ENTRY_TYPE_MASK,
									AA_ATM_ENTRY_TYPE_UCAST))
				{
					HdrType = AA_HEADER_TYPE_UNICAST;
				}
				else
				{
					HdrType = AA_HEADER_TYPE_NUNICAST;
				}
			}
			else
			{
				HdrPresent = FALSE;
				HdrType = AA_HEADER_TYPE_NONE;
			}

			AtmArpFreeSendPackets(
					pInterface,
					pPacketToBeQueued,
					HdrPresent
					);
		}
	}

	AADEBUGP(AAD_VERY_LOUD, ("Make Call: VC: 0x%x, returning status 0x%x\n",
						pVc, Status));

	return Status;
}




VOID
AtmArpFillCallParameters(
	IN	PCO_CALL_PARAMETERS			pCallParameters,
	IN	ULONG						ParametersSize,
	IN	PATM_ADDRESS				pCalledAddress,
	IN	PATM_ADDRESS				pCallingAddress,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	BOOLEAN						IsPMP,
	IN	BOOLEAN						IsMakeCall
)
/*++

Routine Description:

	Fill in a Call Parameters structure with the given information,
	thus making it ready for use in an NdisClMakeCall/NdisClAddParty
	call.

Arguments:

	pCallParameters			- points to structure to be filled in.
	ParametersSize			- size of the above
	pCalledAddress			- points to called ATM address
	pCallingAddress			- points to calling ATM address
	pFlowSpec				- points to Flow spec for this connection
	IsPMP					- Is this a point to multipoint connection?
	IsMakeCall				- Is this for MakeCall (FALSE => AddParty)

Return Value:

	None

--*/
{
	PCO_CALL_MANAGER_PARAMETERS				pCallMgrParameters;

	PQ2931_CALLMGR_PARAMETERS				pAtmCallMgrParameters;

	//
	//  All Info Elements that we need to fill:
	//
	Q2931_IE UNALIGNED *								pIe;
	AAL_PARAMETERS_IE UNALIGNED *						pAalIe;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *				pTrafficDescriptor;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *		pBbc;
	ATM_BLLI_IE UNALIGNED *								pBlli;
	ATM_QOS_CLASS_IE UNALIGNED *						pQos;

	//
	//  Zero out everything. Don't remove this!
	//
	AA_SET_MEM((PUCHAR)pCallParameters, 0, ParametersSize);

	//
	//  Distribute space amongst the various structures
	//
	pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
							((PUCHAR)pCallParameters +
 								sizeof(CO_CALL_PARAMETERS));


	//
	//  Set pointers to link the above structures together
	//
	pCallParameters->CallMgrParameters = pCallMgrParameters;
	pCallParameters->MediaParameters = (PCO_MEDIA_PARAMETERS)NULL;


	pCallMgrParameters->CallMgrSpecific.ParamType = 0;
	pCallMgrParameters->CallMgrSpecific.Length = 
						sizeof(Q2931_CALLMGR_PARAMETERS) +
						(IsMakeCall? ATMARP_MAKE_CALL_IE_SPACE: ATMARP_ADD_PARTY_IE_SPACE);

	pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
								pCallMgrParameters->CallMgrSpecific.Parameters;

	if (IsPMP)
	{
		pCallParameters->Flags |= MULTIPOINT_VC;
	}

	//
	//  Call Manager generic flow parameters:
	//
	pCallMgrParameters->Transmit.TokenRate = (pFlowSpec->SendAvgBandwidth);
	pCallMgrParameters->Transmit.TokenBucketSize = (pFlowSpec->SendMaxSize);
	pCallMgrParameters->Transmit.MaxSduSize = pFlowSpec->SendMaxSize;
	pCallMgrParameters->Transmit.PeakBandwidth = (pFlowSpec->SendPeakBandwidth);
	pCallMgrParameters->Transmit.ServiceType = pFlowSpec->SendServiceType;

	if ((!IsPMP) && (IsMakeCall))
	{
		pCallMgrParameters->Receive.TokenRate = (pFlowSpec->ReceiveAvgBandwidth);
		pCallMgrParameters->Receive.TokenBucketSize = pFlowSpec->ReceiveMaxSize;
		pCallMgrParameters->Receive.MaxSduSize = pFlowSpec->ReceiveMaxSize;
		pCallMgrParameters->Receive.PeakBandwidth = (pFlowSpec->ReceivePeakBandwidth);
		pCallMgrParameters->Receive.ServiceType = pFlowSpec->ReceiveServiceType;
	}
	else
	{
		//
		//  else receive side values are 0's.
		//
		pCallMgrParameters->Receive.ServiceType = SERVICETYPE_NOTRAFFIC;
	}
	
	//
	//  Q2931 Call Manager Parameters:
	//

	//
	//  Called address:
	//
	//  TBD: Add Called Subaddress IE in outgoing call.
	//
	AA_COPY_MEM((PUCHAR)&(pAtmCallMgrParameters->CalledParty),
  				(PUCHAR)pCalledAddress,
  				sizeof(ATM_ADDRESS));

	//
	//  Calling address:
	//
	AA_COPY_MEM((PUCHAR)&(pAtmCallMgrParameters->CallingParty),
  				(PUCHAR)pCallingAddress,
  				sizeof(ATM_ADDRESS));


	//
	//  RFC 1755 (Sec 5) says that the following IEs MUST be present in the
	//  SETUP message, so fill them all.
	//
	//      AAL Parameters
	//      Traffic Descriptor (only for MakeCall)
	//      Broadband Bearer Capability (only for MakeCall)
	//      Broadband Low Layer Info
	//      QoS (only for MakeCall)
	//

	//
	//  Initialize the Info Element list
	//
	pAtmCallMgrParameters->InfoElementCount = 0;
	pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);


	//
	//  AAL Parameters:
	//

	{
		UNALIGNED AAL5_PARAMETERS	*pAal5;

		pIe->IEType = IE_AALParameters;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE;
		pAalIe = (PAAL_PARAMETERS_IE)pIe->IE;
		pAalIe->AALType = AAL_TYPE_AAL5;
		pAal5 = &(pAalIe->AALSpecificParameters.AAL5Parameters);
		pAal5->ForwardMaxCPCSSDUSize = pFlowSpec->SendMaxSize;
		pAal5->BackwardMaxCPCSSDUSize = pFlowSpec->ReceiveMaxSize;
	}

	pAtmCallMgrParameters->InfoElementCount++;
	pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


#ifdef PREPARE_IES_OURSELVES
	//
	//  Let the Call Manager convert from generic flow spec to Traffic Descr,
	//  Broadband Bearer Cap, and QoS.
	//

	//
	//  Traffic Descriptor:
	//

	if (IsMakeCall)
	{
		pIe->IEType = IE_TrafficDescriptor;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE;
		pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)pIe->IE;

		if (pFlowSpec->SendServiceType == SERVICETYPE_BESTEFFORT)
		{
			pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->SendPeakBandwidth);
			if (!IsPMP)
			{
				pTrafficDescriptor->BackwardTD.PeakCellRateCLP01 = 
									BYTES_TO_CELLS(pFlowSpec->ReceivePeakBandwidth);
			}
			//
			//  else we have zero'ed out everything, which is what we want.
			//
			pTrafficDescriptor->BestEffort = TRUE;
		}
		else
		{
			//  Predictive/Guaranteed service (we map this to CBR, see BBC below)
			pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->SendPeakBandwidth);
			if (!IsPMP)
			{
				pTrafficDescriptor->BackwardTD.PeakCellRateCLP01 =
										BYTES_TO_CELLS(pFlowSpec->ReceivePeakBandwidth);
			}
			//
			//  else we have zero'ed out everything, which is what we want.
			//
			pTrafficDescriptor->BestEffort = FALSE;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}


	//
	//  Broadband Bearer Capability
	//

	if (IsMakeCall)
	{
		pIe->IEType = IE_BroadbandBearerCapability;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE;
		pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)pIe->IE;

		pBbc->BearerClass = BCOB_X;
		pBbc->UserPlaneConnectionConfig = (IsPMP ? UP_P2MP: UP_P2P);
		if (pFlowSpec->SendServiceType == SERVICETYPE_BESTEFFORT)
		{
			pBbc->TrafficType = TT_NOIND;
			pBbc->TimingRequirements = TR_NOIND;
			pBbc->ClippingSusceptability = CLIP_NOT;
		}
		else
		{
			pBbc->TrafficType = TT_CBR;
			pBbc->TimingRequirements = TR_END_TO_END;
			pBbc->ClippingSusceptability = CLIP_SUS;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}

#endif // PREPARE_IES_OURSELVES

	//
	//  Broadband Lower Layer Information
	//

	pIe->IEType = IE_BLLI;
	pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE;
	pBlli = (PATM_BLLI_IE)pIe->IE;
	AA_COPY_MEM((PUCHAR)pBlli,
  				(PUCHAR)&AtmArpDefaultBlli,
  				sizeof(ATM_BLLI_IE));

	pAtmCallMgrParameters->InfoElementCount++;
	pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


#ifdef PREPARE_IES_OURSELVES
	//
	//  QoS
	//

	if (IsMakeCall)
	{
		pIe->IEType = IE_QOSClass;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE;
		pQos = (PATM_QOS_CLASS_IE)pIe->IE;
		if (pFlowSpec->SendServiceType == SERVICETYPE_BESTEFFORT)
		{
			pQos->QOSClassForward = pQos->QOSClassBackward = 0;
		}
		else
		{
			pQos->QOSClassForward = pQos->QOSClassBackward = 1;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}

#endif // PREPARE_IES_OURSELVES

}



#ifdef IPMCAST

BOOLEAN
AtmArpMcPrepareAtmEntryForClose(
	IN	PATMARP_ATM_ENTRY			pAtmEntry		LOCKIN	LOCKOUT
)
/*++

Routine Description:

	Prepare an ATM Entry that has an outgoing PMP call on it, for Close Call.
	This means that we drop all but the last leaf on this PMP call.

	NOTE: The caller is assumed to hold the ATM Entry lock

Arguments:

	pAtmEntry	- Points to ATM Entry representing a PMP call

Return Value:

	TRUE iff the connection on this ATM Entry is ready for CloseCall.

--*/
{
	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
	PATMARP_IPMC_ATM_ENTRY		pNextMcAtmEntry;
	PATMARP_INTERFACE			pInterface;
	NDIS_HANDLE					NdisPartyHandle;
	NDIS_STATUS					Status;

	AA_ASSERT(pAtmEntry->pMcAtmInfo->TransientLeaves == 0);
	AA_ASSERT(pAtmEntry->pVcList != NULL_PATMARP_VC);

	pInterface = pAtmEntry->pInterface;

	AAMCDEBUGP(AAD_EXTRA_LOUD,
		("McPrepareAtmEntryForClose: pAtmEntry 0x%x, McList 0x%x, ActiveLeaves %d\n",
			pAtmEntry,
			pAtmEntry->pMcAtmInfo->pMcAtmEntryList,
			pAtmEntry->pMcAtmInfo->ActiveLeaves));


	//
	//  First, prune all members that aren't connected.
	//
	for (pMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
		 pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
		 pMcAtmEntry = pNextMcAtmEntry)
	{
		pNextMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;

		//
		//  Stop any timer running here.
		//
		(VOID)AtmArpStopTimer(&(pMcAtmEntry->Timer), pInterface);

		if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
							AA_IPMC_AE_CONN_STATE_MASK,
							AA_IPMC_AE_CONN_DISCONNECTED))
		{
			AtmArpMcUnlinkAtmMember(
					pAtmEntry,
					pMcAtmEntry
					);
		}
	}


	//
	//  Next, send drop party requests for all but one member.
	//
	while (pAtmEntry->pMcAtmInfo->ActiveLeaves > 1)
	{
		for (pMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
			 /* NONE */;
			 pMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry)
		{
			AA_ASSERT(pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY);
			if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
								AA_IPMC_AE_CONN_STATE_MASK,
								AA_IPMC_AE_CONN_ACTIVE))
			{
				break;
			}
		}

		NdisPartyHandle = pMcAtmEntry->NdisPartyHandle;

		AAMCDEBUGP(AAD_INFO,
		 ("PrepareAtmEntry: pAtmEntry 0x%x, will DropPty, McAtmEnt 0x%x, PtyHnd 0x%x\n",
		 		pAtmEntry, pMcAtmEntry, NdisPartyHandle));

		AA_SET_FLAG(pMcAtmEntry->Flags,
					AA_IPMC_AE_CONN_STATE_MASK,
					AA_IPMC_AE_CONN_WACK_DROP_PARTY);

		pAtmEntry->pMcAtmInfo->ActiveLeaves--;

		AA_RELEASE_AE_LOCK(pAtmEntry);

		Status = NdisClDropParty(
					NdisPartyHandle,
					NULL,		// Buffer
					(UINT)0		// Size
					);

		if (Status != NDIS_STATUS_PENDING)
		{
			AtmArpDropPartyCompleteHandler(
					Status,
					(NDIS_HANDLE)pMcAtmEntry
					);
		}

		AA_ACQUIRE_AE_LOCK(pAtmEntry);
	}

	//
	//  Now, if we have exactly one ATM member in the list of
	//  leaves for this PMP, we can CloseCall.
	//
	if (pAtmEntry->pMcAtmInfo->pMcAtmEntryList->pNextMcAtmEntry ==
			NULL_PATMARP_IPMC_ATM_ENTRY)
	{
		return (TRUE);
	}
	else
	{
		return (FALSE);
	}
}

#endif // IPMCAST
	



VOID
AtmArpCloseCall(
	IN	PATMARP_VC					pVc		LOCKIN	NOLOCKOUT
)
/*++

Routine Description:

	Closes an existing call on a VC. It is assumed that a call exists
	on the VC.

	NOTE: The caller is assumed to hold a lock to the VC structure,
	and it will be released here.

	SIDE EFFECT: If the NDIS call returns other than NDIS_STATUS_PENDING,
	we call our CloseCall Complete handler from here.

Arguments:

	pVc			- Pointer to ATMARP VC structure.

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PATMARP_ATM_ENTRY		pAtmEntry;

	NDIS_HANDLE				NdisVcHandle;
	NDIS_HANDLE				ProtocolVcContext;
#ifdef IPMCAST
	NDIS_HANDLE				NdisPartyHandle;
#endif
	NDIS_STATUS				Status;
	PNDIS_PACKET			PacketList;		// Packets queued on this VC
	AA_HEADER_TYPE			HdrType;		// for queued packets
	BOOLEAN					HdrPresent;		// for queued packets
	BOOLEAN					WasRunning;		// Was a timer running on this VC?
	BOOLEAN					IsPMP;			// Is this a PMP call?
	ULONG					rc;				// Ref Count on this VC.

	AA_STRUCT_ASSERT(pVc, avc);

	NdisVcHandle = pVc->NdisVcHandle;
	ProtocolVcContext = (NDIS_HANDLE)pVc;
	pInterface = pVc->pInterface;
	IsPMP = AA_IS_FLAG_SET(pVc->Flags,
							AA_VC_CONN_TYPE_MASK,
							AA_VC_CONN_TYPE_PMP);

	AADEBUGP(AAD_INFO,
		("Closing call on VC 0x%x, VC Flags 0x%x, Ref %d, NdisVcHandle 0x%x\n",
					pVc, pVc->Flags, pVc->RefCount, NdisVcHandle));

	//
	//  Remove the list of packets queued on this VC.
	//
	PacketList = pVc->PacketList;
	pVc->PacketList = (PNDIS_PACKET)NULL;
	if (pVc->FlowSpec.Encapsulation == ENCAPSULATION_TYPE_LLCSNAP)
	{
		HdrType = (IsPMP ? AA_HEADER_TYPE_NUNICAST: AA_HEADER_TYPE_UNICAST);
		HdrPresent = TRUE;
	}
	else
	{
		HdrType = AA_HEADER_TYPE_NONE;
		HdrPresent = FALSE;
	}


	//
	//  Stop any timer running on this VC.
	//
	WasRunning = AtmArpStopTimer(&(pVc->Timer), pInterface);

	if (WasRunning)
	{
		//
		//  Remove the timer reference on this VC.
		//
		rc = AtmArpDereferenceVc(pVc);
	}
	else
	{
		rc = pVc->RefCount;
	}

#ifdef GPC
	//
	//  If this VC is associated with a Flow, unlink them.
	//
	if (rc != 0)
	{
		if (pVc->FlowHandle != NULL)
		{
			PATMARP_FLOW_INFO		pFlowInfo = (PATMARP_FLOW_INFO)pVc->FlowHandle;

			if ((PVOID)pVc == InterlockedCompareExchangePointer(
									&(pFlowInfo->VcContext),
									NULL,
									pVc
							  		))
			{
				pVc->FlowHandle = NULL;
				rc = AtmArpDereferenceVc(pVc);	// Unlink from GPC Flow
			}
		}
	}
#endif // GPC


	if (rc != 0)
	{
		//
		//  Check the call state on this VC. If the call is active and
		//  we have no sends going on, then we close the call.
		//  Otherwise, simply mark the VC as closing. We will continue
		//  this process when the current operation on the VC completes.
		//

		if (AA_IS_FLAG_SET(pVc->Flags,
							AA_VC_CALL_STATE_MASK,
							AA_VC_CALL_STATE_ACTIVE) &&
			(pVc->OutstandingSends == 0))
		{
			//
			//  Set VC call state to "Close Call in progress" so that we don't
			//  reenter here.
			//
			AA_SET_FLAG(
					pVc->Flags,
					AA_VC_CALL_STATE_MASK,
					AA_VC_CALL_STATE_CLOSE_IN_PROGRESS);

#ifdef IPMCAST
			if (IsPMP)
			{
				PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;	// last leaf

				pAtmEntry = pVc->pAtmEntry;

				AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);
				AA_ASSERT(pAtmEntry->pMcAtmInfo != NULL_PATMARP_IPMC_ATM_INFO);

				if (pAtmEntry->pMcAtmInfo->TransientLeaves == 0)
				{
					//
					//  No AddParty in progress.
					//
					AA_RELEASE_VC_LOCK(pVc);

					AA_ACQUIRE_AE_LOCK(pAtmEntry);
					if (AtmArpMcPrepareAtmEntryForClose(pAtmEntry))
					{
						//
						//  The entry is ready for CloseCall.
						//
						AAMCDEBUGP(AAD_LOUD,
						("CloseCall (MC): pAtmEntry 0x%x, ready for close\n", pAtmEntry));

						//
						//  Get the party handle of the last leaf, and unlink
						//  it from the PMP structure.
						//
						AA_ASSERT(pAtmEntry->pMcAtmInfo->pMcAtmEntryList != 
								NULL_PATMARP_IPMC_ATM_ENTRY);

						pMcAtmEntry = pVc->pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
						NdisPartyHandle = pMcAtmEntry->NdisPartyHandle;

						AA_SET_FLAG(pMcAtmEntry->Flags,
									AA_IPMC_AE_CONN_STATE_MASK,
									AA_IPMC_AE_CONN_WACK_DROP_PARTY);

						pAtmEntry->pMcAtmInfo->ActiveLeaves--;
						AA_ASSERT(pAtmEntry->pMcAtmInfo->ActiveLeaves == 0);

						AA_RELEASE_AE_LOCK(pAtmEntry);
						AA_ACQUIRE_VC_LOCK(pVc);
					}
					else
					{
						AA_RELEASE_AE_LOCK(pAtmEntry);
						AA_ACQUIRE_VC_LOCK(pVc);
						//

						//  There are pending DropParty calls. Mark this VC
						//  so that we trigger a CloseCall when all DropParty
						//  calls complete.
						//
						AA_SET_FLAG(pVc->Flags,
									AA_VC_CLOSE_STATE_MASK,
									AA_VC_CLOSE_STATE_CLOSING);

						NdisVcHandle = NULL;	// Don't close call now
					}

				}
				else
				{
					//
					//  There are pending AddParty calls. Mark this VC
					//  so that we trigger a CloseCall when all AddParty
					//  calls complete.
					//
					AA_SET_FLAG(pVc->Flags,
								AA_VC_CLOSE_STATE_MASK,
								AA_VC_CLOSE_STATE_CLOSING);

					NdisVcHandle = NULL;	// Don't close call now
				}
			}
			else
			{
				NdisPartyHandle = NULL;
			}

			if (NdisVcHandle != NULL)
			{
				AA_RELEASE_VC_LOCK(pVc);

				Status = NdisClCloseCall(
							NdisVcHandle,
							NdisPartyHandle,
							(PVOID)NULL,		// No Buffer
							(UINT)0				// Size of above
						);

				if (Status != NDIS_STATUS_PENDING)
				{
					AtmArpCloseCallCompleteHandler(
							Status,
							ProtocolVcContext,
							(NDIS_HANDLE)NULL
							);
				}
			}
			else
			{
				//
				//  Set the call state back to what it was.
				//
				AA_SET_FLAG(
						pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_ACTIVE);

				AA_RELEASE_VC_LOCK(pVc);
			}
#else
			AA_RELEASE_VC_LOCK(pVc);
			Status = NdisClCloseCall(
						NdisVcHandle,
						NULL,				// NdisPartyHandle
						(PVOID)NULL,		// No Buffer
						(UINT)0				// Size of above
						);
			if (Status != NDIS_STATUS_PENDING)
			{
				AtmArpCloseCallCompleteHandler(
						Status,
						ProtocolVcContext,
						(NDIS_HANDLE)NULL
						);
			}
#endif // IPMCAST

		}
		else
		{
			//
			//  Some operation is going on here (call setup/close/send). Mark this
			//  VC so that we know what to do when this operation completes.
			//
			AA_SET_FLAG(
					pVc->Flags,
					AA_VC_CLOSE_STATE_MASK,
					AA_VC_CLOSE_STATE_CLOSING);

			AA_RELEASE_VC_LOCK(pVc);
		}
	}
	//
	//  else the VC is gone.
	//

	//
	//  Free any packets queued on this VC
	//
	if (PacketList != (PNDIS_PACKET)NULL)
	{
		AtmArpFreeSendPackets(
					pInterface,
					PacketList,
					HdrPresent
					);
	}

}




NDIS_STATUS
AtmArpCreateVcHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisVcHandle,
	OUT	PNDIS_HANDLE				pProtocolVcContext
)
/*++

Routine Description:

	Entry point called by NDIS when the Call Manager wants to create
	a new endpoint (VC). We allocate a new ATMARP VC structure, and
	return a pointer to it as our VC context.

Arguments:

	ProtocolAfContext	- Actually a pointer to the ATMARP Interface structure
	NdisVcHandle		- Handle for this VC for all future references
	pProtocolVcContext	- Place where we (protocol) return our context for the VC

Return Value:

	NDIS_STATUS_SUCCESS if we could create a VC
	NDIS_STATUS_RESOURCES otherwise

--*/
{
	PATMARP_INTERFACE	pInterface;
	PATMARP_VC			pVc;
	NDIS_STATUS			Status;

	pInterface = (PATMARP_INTERFACE)ProtocolAfContext;

	pVc = AtmArpAllocateVc(pInterface);
	if (pVc != NULL_PATMARP_VC)
	{
		*pProtocolVcContext = (NDIS_HANDLE)pVc;
		pVc->NdisVcHandle = NdisVcHandle;
		pVc->Flags = AA_VC_OWNER_IS_CALLMGR;
		AtmArpReferenceVc(pVc);	// Create VC ref

		Status = NDIS_STATUS_SUCCESS;
	}
	else
	{
		Status = NDIS_STATUS_RESOURCES;
	}

	AADEBUGP(AAD_INFO, ("Create Vc Handler: pVc 0x%x, Status 0x%x\n", pVc, Status));

	return (Status);

}



NDIS_STATUS
AtmArpDeleteVcHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
)
/*++

Routine Description:

	Our Delete VC handler. This VC would have been allocated as a result
	of a previous entry into our CreateVcHandler, and possibly used for
	an incoming call.

	At this time, this VC structure should be free of any calls, and we
	simply free this.

Arguments:

	ProtocolVcContext	- pointer to our VC structure

Return Value:

	NDIS_STATUS_SUCCESS always

--*/
{
	PATMARP_VC			pVc;
	ULONG				rc;		// Ref count on the VC

	pVc = (PATMARP_VC)ProtocolVcContext;

	AA_STRUCT_ASSERT(pVc, avc);
	AA_ASSERT((pVc->Flags & AA_VC_OWNER_MASK) == AA_VC_OWNER_IS_CALLMGR);

	AA_ACQUIRE_VC_LOCK(pVc);
	rc = AtmArpDereferenceVc(pVc);
	if (rc > 0)
	{
		//
		//  This can happen if there is a timer still running
		//  on this VC. When the timer elapses, the VC will be
		//  freed.
		//
		AADEBUGP(AAD_WARNING, ("Delete VC handler: pVc 0x%x, Flags 0x%x, refcount %d, pAtmEntry %x\n",
					pVc, pVc->Flags, rc, pVc->pAtmEntry));
		AA_RELEASE_VC_LOCK(pVc);
	}
	//
	//  else the VC is gone.
	//

	AADEBUGP(AAD_LOUD, ("Delete Vc Handler: 0x%x: done\n", pVc));

	return (NDIS_STATUS_SUCCESS);
}




NDIS_STATUS
AtmArpIncomingCallHandler(
	IN		NDIS_HANDLE				ProtocolSapContext,
	IN		NDIS_HANDLE				ProtocolVcContext,
	IN OUT	PCO_CALL_PARAMETERS 	pCallParameters
)
/*++

Routine Description:

	This handler is called when there is an incoming call matching our
	SAP. This could be either an SVC or a PVC. In either case, we store
	FlowSpec information from the incoming call in the VC structure, making
	sure that the MTU for the interface is not violated.

	For an SVC, we expect a Calling Address to be present in the call,
	otherwise we reject the call. If an ATM Entry with this address exists,
	this VC is linked to that entry, otherwise a new entry with this address
	is created.

	In the case of a PVC, we ignore any Calling Address information, and
	depend on InATMARP to resolve the ATM Address as well as the IP address
	of the other end.

Arguments:

	ProtocolSapContext		- Pointer to ATMARP Interface structure
	ProtocolVcContext		- Pointer to ATMARP VC structure
	pCallParameters			- Call parameters

Return Value:

	NDIS_STATUS_SUCCESS if we accept this call
	NDIS_STATUS_FAILURE if we reject it.

--*/
{
	PATMARP_VC										pVc;
	PATMARP_ATM_ENTRY								pAtmEntry;
	PATMARP_INTERFACE								pInterface;

	CO_CALL_MANAGER_PARAMETERS UNALIGNED *			pCallMgrParameters;
	Q2931_CALLMGR_PARAMETERS UNALIGNED *			pAtmCallMgrParameters;

	//
	//  To traverse the list of Info Elements
	//
	Q2931_IE UNALIGNED *							pIe;
	ULONG											InfoElementCount;

	//
	//  Info Elements in the incoming call, that are of interest to us.
	//  Initialize these to <not present>.
	//
	ATM_ADDRESS UNALIGNED *							pCallingAddress = NULL;
	ATM_CALLING_PARTY_SUBADDRESS_IE UNALIGNED *		pCallingSubaddressIe = NULL;
	ATM_ADDRESS UNALIGNED *							pCallingSubaddress = NULL;
	AAL_PARAMETERS_IE UNALIGNED *					pAal = NULL;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *			pTrafficDescriptor = NULL;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *	pBbc = NULL;
	ATM_BLLI_IE UNALIGNED *							pBlli = NULL;
	ATM_QOS_CLASS_IE UNALIGNED *					pQos = NULL;

	AAL5_PARAMETERS UNALIGNED *						pAal5;
	UCHAR											AddrTypeLen;
	UCHAR											SubaddrTypeLen;
	PUCHAR											pAtmSubaddress;
	NDIS_STATUS										Status;
	
	pVc = (PATMARP_VC)ProtocolVcContext;

	AA_STRUCT_ASSERT(pVc, avc);

	AA_ASSERT((pVc->Flags & AA_VC_TYPE_MASK) == AA_VC_TYPE_UNUSED);
	AA_ASSERT((pVc->Flags & AA_VC_OWNER_MASK) == AA_VC_OWNER_IS_CALLMGR);
	AA_ASSERT((pVc->Flags & AA_VC_CALL_STATE_MASK) == AA_VC_CALL_STATE_IDLE);

	pInterface = pVc->pInterface;
	AADEBUGP(AAD_LOUD, ("Incoming Call: IF 0x%x, VC 0x%x, pCallParams 0x%x\n",
				pInterface, pVc, pCallParameters));

	do
	{
		if (pInterface->AdminState != IF_STATUS_UP)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Get the following info from the Incoming call:
		//		Calling Address
		//		AAL Parameters
		//		Traffic Descriptor
		//		Broadband Bearer Capability
		//		QoS
		//
		pCallMgrParameters = pCallParameters->CallMgrParameters;
		pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
					pCallParameters->CallMgrParameters->CallMgrSpecific.Parameters;

		pCallingAddress = &(pAtmCallMgrParameters->CallingParty);
		InfoElementCount = pAtmCallMgrParameters->InfoElementCount;
		pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);

		while (InfoElementCount--)
		{
			switch (pIe->IEType)
			{
				case IE_AALParameters:
					pAal = (PAAL_PARAMETERS_IE)(pIe->IE);
					break;
				case IE_TrafficDescriptor:
					pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)(pIe->IE);
					break;
				case IE_BroadbandBearerCapability:
					pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)(pIe->IE);
					break;
				case IE_QOSClass:
					pQos = (PATM_QOS_CLASS_IE)(pIe->IE);
					break;
				case IE_CallingPartySubaddress:
					pCallingSubaddressIe = (ATM_CALLING_PARTY_SUBADDRESS_IE *)(pIe->IE);
					pCallingSubaddress = pCallingSubaddressIe; 
					break;
				default:
					break;
			}
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
		}

		if ((pCallParameters->Flags & PERMANENT_VC) == 0)
		{
			//
			//  This is an SVC.
			//

			//
			//  Make sure all mandatory IEs are present. If not, reject the call
			//
			if ((pAal == (PAAL_PARAMETERS_IE)NULL) ||
				(pTrafficDescriptor == (PATM_TRAFFIC_DESCRIPTOR_IE)NULL) ||
				(pBbc == (PATM_BROADBAND_BEARER_CAPABILITY_IE)NULL) ||
				(pQos == (PATM_QOS_CLASS_IE)NULL))
			{
				AADEBUGP(AAD_WARNING,
					("In call: IE missing: AAL 0x%x, TRAF 0x%x, BBC 0x%x, QOS 0x%x",
						pAal,
						pTrafficDescriptor,
						pBbc,
						pQos));
				Status = NDIS_STATUS_AAL_PARAMS_UNSUPPORTED;
				break;
			}

			//
			//  We insist on the Calling Address
			//  being present, as well
			//
			if (pCallingAddress->NumberOfDigits == 0)
			{
				AADEBUGP(AAD_WARNING, ("In call: calling address missing for SVC\n"));
				Status = NDIS_STATUS_INVALID_ADDRESS;
				break;
			}
		}

		if (pAal != NULL)
		{
			//
			//  Make sure that the requested MTU values aren't beyond our
			//  capabilities:
			//
			pAal5 = &(pAal->AALSpecificParameters.AAL5Parameters);
			if (pAal5->ForwardMaxCPCSSDUSize > pInterface->pAdapter->MaxPacketSize)
			{
				pAal5->ForwardMaxCPCSSDUSize = pInterface->pAdapter->MaxPacketSize;
			}

			if (pAal5->BackwardMaxCPCSSDUSize > pInterface->pAdapter->MaxPacketSize)
			{
				pAal5->BackwardMaxCPCSSDUSize = pInterface->pAdapter->MaxPacketSize;
			}
		}

#ifdef PREPARE_IES_OURSELVES
		//
		//  Get the Flow Specs for this VC from the ATM Info Elements
		//
		pVc->FlowSpec.SendPeakBandwidth =
					CELLS_TO_BYTES(pTrafficDescriptor->ForwardTD.PeakCellRateCLP01);
		pVc->FlowSpec.SendMaxSize = pAal5->ForwardMaxCPCSSDUSize;
		pVc->FlowSpec.ReceivePeakBandwidth =
					CELLS_TO_BYTES(pTrafficDescriptor->BackwardTD.PeakCellRateCLP01);
		pVc->FlowSpec.ReceiveMaxSize = pAal5->BackwardMaxCPCSSDUSize;
		if ((pQos->QOSClassForward == 0) || (pQos->QOSClassBackward == 0))
		{
			pVc->FlowSpec.SendServiceType = SERVICETYPE_BESTEFFORT;
		}
		else
		{
			pVc->FlowSpec.SendServiceType = SERVICETYPE_GUARANTEED;
		}
#else
		//
		//  Get the Flow Specs for this VC
		//
		pVc->FlowSpec.SendPeakBandwidth = pCallMgrParameters->Transmit.PeakBandwidth;
		pVc->FlowSpec.SendAvgBandwidth = pCallMgrParameters->Transmit.TokenRate;
		pVc->FlowSpec.SendMaxSize = pCallMgrParameters->Transmit.MaxSduSize;
		pVc->FlowSpec.SendServiceType = pCallMgrParameters->Transmit.ServiceType;

		pVc->FlowSpec.ReceivePeakBandwidth = pCallMgrParameters->Receive.PeakBandwidth;
		pVc->FlowSpec.ReceiveAvgBandwidth = pCallMgrParameters->Receive.TokenRate;
		pVc->FlowSpec.ReceiveMaxSize = pCallMgrParameters->Receive.MaxSduSize;
		pVc->FlowSpec.ReceiveServiceType = pCallMgrParameters->Receive.ServiceType;

#endif // PREPARE_IES_OURSELVES

		AADEBUGP(AAD_LOUD, ("InCall: VC 0x%x: Type %s, Calling Addr:\n",
					pVc,
					(((pCallParameters->Flags & PERMANENT_VC) == 0)? "SVC": "PVC")
				));
		AADEBUGPDUMP(AAD_LOUD, pCallingAddress->Address, pCallingAddress->NumberOfDigits);
		AADEBUGP(AAD_LOUD,
				("InCall: VC 0x%x: SendBW: %d, RcvBW: %d, SendSz %d, RcvSz %d\n",
					pVc,
					pVc->FlowSpec.SendPeakBandwidth,
					pVc->FlowSpec.ReceivePeakBandwidth,
					pVc->FlowSpec.SendMaxSize,
					pVc->FlowSpec.ReceiveMaxSize));

#if DBG
		if (pCallParameters->Flags & MULTIPOINT_VC)
		{
			AAMCDEBUGPATMADDR(AAD_EXTRA_LOUD, "Incoming PMP call from :", pCallingAddress);
		}
#endif // DBG

		//
		//  If this is a PVC, we are done. Accept the call.
		//
		if ((pCallParameters->Flags & PERMANENT_VC) != 0)
		{
			pVc->Flags |= (AA_VC_TYPE_PVC|AA_VC_CALL_STATE_INCOMING_IN_PROGRESS);
			Status = NDIS_STATUS_SUCCESS;
			break;
		}

		//
		//  Here if SVC. Check if an ATM Entry for this Calling address exists.
		//  If an entry exists, link this VC to the entry; otherwise, create a new
		//  ATM entry and link this VC to it.
		//
		AddrTypeLen = AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(pCallingAddress);
		if (pCallingSubaddress != (PATM_ADDRESS)NULL)
		{
			SubaddrTypeLen = AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(pCallingSubaddress);
			pAtmSubaddress = pCallingSubaddress->Address;
		}
		else
		{
			SubaddrTypeLen = 0;
			pAtmSubaddress = (PUCHAR)NULL;
		}

		pAtmEntry = AtmArpSearchForAtmAddress(
							pInterface,
							AddrTypeLen,
							pCallingAddress->Address,
							SubaddrTypeLen,
							pAtmSubaddress,
							AE_REFTYPE_TMP,
							TRUE		// Create one if no match found
							);

		if (pAtmEntry == NULL_PATMARP_ATM_ENTRY)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Link this VC to the ATM Entry, and accept this call.
		//
		AA_ACQUIRE_AE_LOCK(pAtmEntry);
		{
			ULONG rc;
			AtmArpLinkVcToAtmEntry(pVc, pAtmEntry);

			//
			// AtmArpSearchForAtmAddress addrefd pAtmEntry for us -- we deref it
			// here (AFTER calling AtmArpLinkVcToAtmEntry).
			//
			rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);
			if (rc == 0)
			{
				//
				// We shouldn't get here because AtmArpLinkVcToAtmEntry
				// should have added a reference tp pAtmEntry.
				//
				AA_ASSERT(FALSE);
				Status = NDIS_STATUS_FAILURE;
				break;
			}
		}
		AA_RELEASE_AE_LOCK(pAtmEntry);
		//

		//  All checks for an incoming SVC are complete.
		//
		pVc->Flags |= (AA_VC_TYPE_SVC|AA_VC_CALL_STATE_INCOMING_IN_PROGRESS);


		AtmArpReferenceVc(pVc);	// ATM Entry reference

		Status = NDIS_STATUS_SUCCESS;
		break;

	}
	while (FALSE);

	AADEBUGP(AAD_VERY_LOUD, ("Incoming call: VC 0x%x, Status 0x%x\n", pVc, Status));
	return Status;
}




VOID
AtmArpCallConnectedHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
)
/*++

Routine Description:

	This handler is called as the final step in an incoming call, to inform
	us that the call is fully setup.

	For a PVC, we link the ATMARP VC structure in the list of unresolved PVCs,
	and use InATMARP to resolve both the IP and ATM addresses of the other
	end.

	For an SVC, we send off any packets queued on the VC while we were waiting
	for the Call Connected.

Arguments:

	ProtocolVcContext		- Pointer to ATMARP VC structure

Return Value:

	None

--*/
{
	PATMARP_VC				pVc;
	PATMARP_INTERFACE		pInterface;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);


	pVc = (PATMARP_VC)ProtocolVcContext;
	
	AA_STRUCT_ASSERT(pVc, avc);
	AA_ASSERT((pVc->Flags & AA_VC_CALL_STATE_MASK)
						 == AA_VC_CALL_STATE_INCOMING_IN_PROGRESS);

	AA_ACQUIRE_VC_LOCK(pVc);

	//
	//  Note down that a call is active on this VC.
	//
	AA_SET_FLAG(
			pVc->Flags,
			AA_VC_CALL_STATE_MASK,
			AA_VC_CALL_STATE_ACTIVE
			);

	AtmArpReferenceVc(pVc);		// Incoming call reference

	AADEBUGP(AAD_INFO, ("Call Connected: VC: 0x%x, Flags: 0x%x, ATM Entry: 0x%x\n",
					pVc, pVc->Flags, pVc->pAtmEntry));

	pInterface = pVc->pInterface;
	AA_STRUCT_ASSERT(pInterface, aai);

	if (pInterface->AdminState == IF_STATUS_UP)
	{
		if ((pVc->Flags & AA_VC_TYPE_PVC) != 0)
		{
			//
			//  This is a PVC, link it to the list of unresolved PVCs, and
			//  send an InATMARP request on it.
			//
			pVc->pNextVc = pInterface->pUnresolvedVcs;
			pInterface->pUnresolvedVcs = pVc;

			AA_SET_FLAG(pVc->Flags,
						AA_VC_ARP_STATE_MASK,
						AA_VC_INARP_IN_PROGRESS);
			//
			//  Start an InARP wait timer while we hold a lock for
			//  the Interface
			//
			AtmArpStartTimer(
						pInterface,
						&(pVc->Timer),
						AtmArpPVCInARPWaitTimeout,
						pInterface->InARPWaitTimeout,
						(PVOID)pVc
						);


			AtmArpReferenceVc(pVc);		// Timer ref

			AtmArpReferenceVc(pVc);		// Unresolved VCs Link reference


			AADEBUGP(AAD_LOUD, ("PVC Call Connected: VC 0x%x\n", pVc));

#ifndef VC_REFS_ON_SENDS
			AA_RELEASE_VC_LOCK(pVc);
#endif // VC_REFS_ON_SENDS
			AtmArpSendInARPRequest(pVc);

			AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
		}
		else
		{
			AADEBUGP(AAD_LOUD, ("SVC Call Connected: VC 0x%x\n", pVc));

			AtmArpStartSendsOnVc(pVc);
	
			//
			//  The VC lock is released within StartSendsOnVc()
			//
			AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
		}
	}
	else
	{
		//
		//  The interface is marked as down. Close this call.
		//

		AtmArpCloseCall(pVc);

		//
		//  The VC lock is released within the above
		//
	}

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return;
}




VOID
AtmArpIncomingCloseHandler(
	IN	NDIS_STATUS					CloseStatus,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
)
/*++

Routine Description:

	This handler is called when a call is closed, either by the network
	or by the remote peer.

Arguments:

	CloseStatus			- Reason for the call clearing
	ProtocolVcContext	- Actually a pointer to the ATMARP VC structure
	pCloseData			- Additional info about the close
	Size				- Length of above

Return Value:

	None

--*/
{
	PATMARP_VC			pVc;
	PATMARP_ATM_ENTRY	pAtmEntry;
	PATMARP_INTERFACE	pInterface;
	ULONG				rc;				// Ref Count
	BOOLEAN				VcAbnormalTermination;
	BOOLEAN				IsPVC;
	BOOLEAN				Found;
	PATM_CAUSE_IE		pCauseIe;

	pVc = (PATMARP_VC)ProtocolVcContext;
	AA_STRUCT_ASSERT(pVc, avc);

	AADEBUGP(AAD_INFO, ("Incoming Close: pVc 0x%x, Status 0x%x\n", pVc, CloseStatus));
	pCauseIe = (PATM_CAUSE_IE)pCloseData;

#if DBG
	if (pCauseIe != (PATM_CAUSE_IE)NULL)
	{
		AADEBUGP(AAD_INFO, ("Incoming Close: pVc 0x%x, Locn 0x%x, Cause 0x%x\n",
					pVc, pCauseIe->Location, pCauseIe->Cause));
	}
#endif // DBG

	AA_ACQUIRE_VC_LOCK(pVc);
	IsPVC = AA_IS_FLAG_SET(pVc->Flags, AA_VC_TYPE_MASK, AA_VC_TYPE_PVC);
	pInterface = pVc->pInterface;

	//
	//  Stop any timer (e.g. VC aging) running on this VC
	//
	if (AtmArpStopTimer(&(pVc->Timer), pVc->pInterface))
	{
		//
		//  A timer WAS running
		//
		rc = AtmArpDereferenceVc(pVc);	// Timer reference
		AA_ASSERT(rc > 0);
	}

	if ((CloseStatus == NDIS_STATUS_DEST_OUT_OF_ORDER) || IsPVC)
	{
		//
		//  This is an abnormal close, note down the fact
		//
		VcAbnormalTermination = TRUE;
	}
	else
	{
		VcAbnormalTermination = FALSE;
	}

	if (AA_IS_FLAG_SET(pVc->Flags,
					AA_VC_CALL_STATE_MASK,
					AA_VC_CALL_STATE_INCOMING_IN_PROGRESS))
	{
			AADEBUGP(AAD_WARNING,
	("Incoming close: VC 0x%x state is INCOMING_IN_PROGRESS; changing to ACTIVE\n",
						pVc));
			//
			// We're getting a close call for an incoming call that is  not yet
			// in the connected state. Since we won't get any further notifications
			// for this call, this call is effectively in the active state.
			// So we set the state to active, and then close the VC.
			// Note: we will not go down the InvalidateAtmEntryPath even
			// if CloseStatus == NDIS_STATUS_DEST_OUT_OF_ORDER;
			// we instead simply close the vc. (If the client is truly out of order,
			// and we want to send to it, well separately try to make an OUTGOING
			// call to the destination, which should fail with "DEST_OUT_OF_ORDER",
			// and we'll end up eventually invalidating the atm entry.
			//
			AA_SET_FLAG(pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_ACTIVE);
			AtmArpReferenceVc(pVc);		// Incoming call reference

			VcAbnormalTermination = FALSE;
	}

	if (VcAbnormalTermination && 
		(pVc->pAtmEntry != NULL_PATMARP_ATM_ENTRY))
	{
		pAtmEntry = pVc->pAtmEntry;

		AADEBUGP(AAD_INFO,
			("IncomingClose: will invalidate ATM entry %x/%x - IP Entry %x, VC %x/%x\n",
				pAtmEntry, pAtmEntry->Flags,
				pAtmEntry->pIpEntryList,
				pVc, pVc->Flags));

		AA_RELEASE_VC_LOCK(pVc);
		AA_ACQUIRE_AE_LOCK(pAtmEntry);
		AtmArpInvalidateAtmEntry(
					pAtmEntry,
					FALSE	// Not shutting down
					);
		//
		//  AE Lock is released within the above.
		//

		if (IsPVC)
		{
			//
			//  Start a CloseCall right here because InvalidateAtmEntry doesn't.
			//
			AA_ACQUIRE_VC_LOCK(pVc);

			AtmArpCloseCall(pVc);
			//
			//  VC lock is released above
		}
	}
	else
	{
		AtmArpCloseCall(pVc);
	}

	AADEBUGP(AAD_LOUD, ("Leaving Incoming Close handler, VC: 0x%x\n", pVc));
	return;
}


#ifdef IPMCAST

VOID
AtmArpAddParty(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry
)
/*++

Routine Description:

	Add a party to an existing PMP connection. The ATM Entry contains
	all address information for the connection, and the Multicast ATM
	Entry represents one of the leaves, the one to be added.

	NOTE: The caller is assumed to hold a lock for the ATM Entry,
	which is released here.

Arguments:

	pAtmEntry				- Pointer to ATM Entry on which to add the leaf (party).
	pMcAtmEntry				- Points to ATM Multicast Entry representing the leaf.

Return Value:

	None

--*/
{
	PATMARP_VC			pVc;				// The VC structure for the connection
	NDIS_HANDLE			NdisVcHandle;
	PCO_CALL_PARAMETERS	pCallParameters;
	ULONG				RequestSize;
	NDIS_STATUS			Status;

	AA_ASSERT(pAtmEntry->pVcList != NULL_PATMARP_VC);
	pVc = pAtmEntry->pVcList;

	NdisVcHandle = pVc->NdisVcHandle;

	//
	//  Allocate all the space we need.
	//
	RequestSize = 	sizeof(CO_CALL_PARAMETERS) +
					sizeof(CO_CALL_MANAGER_PARAMETERS) +
					sizeof(Q2931_CALLMGR_PARAMETERS) +
					ATMARP_ADD_PARTY_IE_SPACE +
					0;

	AA_ALLOC_MEM(pCallParameters, CO_CALL_PARAMETERS, RequestSize);

	if (pCallParameters != (PCO_CALL_PARAMETERS)NULL)
	{
		//
		//  Fill in Call Parameters.
		//
		AtmArpFillCallParameters(
				pCallParameters,
				RequestSize,
				&(pMcAtmEntry->ATMAddress),		// Called address
				&(pAtmEntry->pInterface->LocalAtmAddress),	// Calling address
				&(pVc->FlowSpec),
				TRUE,	// IsPMP
				FALSE	// IsMakeCall?
				);
	}

	AA_SET_FLAG(pMcAtmEntry->Flags,
				AA_IPMC_AE_CONN_STATE_MASK,
				AA_IPMC_AE_CONN_WACK_ADD_PARTY);

	pAtmEntry->pMcAtmInfo->TransientLeaves++;
	AA_RELEASE_AE_LOCK(pAtmEntry);

	if (pCallParameters != (PCO_CALL_PARAMETERS)NULL)
	{
		Status = NdisClAddParty(
						NdisVcHandle,
						(NDIS_HANDLE)pMcAtmEntry,
						pCallParameters,
						&(pMcAtmEntry->NdisPartyHandle)
						);
	}
	else
	{
		Status = NDIS_STATUS_RESOURCES;
	}

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmArpAddPartyCompleteHandler(
			Status,
			(NDIS_HANDLE)pMcAtmEntry,
			pMcAtmEntry->NdisPartyHandle,
			pCallParameters
			);
	}

}




VOID
AtmArpMcTerminateMember(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry
)
/*++

Routine Description:

	Terminate the specified member of a multicast group. If it is
	currently a leaf in the point-to-multipoint connection to the
	group, then we drop it. If it is the LAST leaf, then we close
	the entire connection.

	NOTE: the caller is assumed to hold the ATM Entry lock, which
	will be released here.

Arguments:

	pAtmEntry				- Pointer to ATM Entry
	pMcAtmEntry				- Points to ATM Multicast Entry representing the leaf to
							  be terminated.

Return Value:

	None

--*/
{
	PATMARP_IPMC_ATM_INFO		pMcAtmInfo;
	PATMARP_VC					pVc;
	NDIS_HANDLE					NdisPartyHandle;
	NDIS_STATUS					Status;

	pMcAtmInfo = pAtmEntry->pMcAtmInfo;
	pVc = pAtmEntry->pVcList;
	NdisPartyHandle = pMcAtmEntry->NdisPartyHandle;

	AAMCDEBUGP(AAD_VERY_LOUD,
	  ("TerminateMember: pAtmEntry 0x%x, pMcAtmEntry 0x%x, pVc 0x%x, NdisPtyHnd 0x%x\n",
		pAtmEntry, pMcAtmEntry, pVc, NdisPartyHandle));

#if DBG
	{
		PATMARP_IP_ENTRY		pIpEntry = pAtmEntry->pIpEntryList;

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			AAMCDEBUGPMAP(AAD_INFO, "Terminating ",
						&pIpEntry->IPAddress,
						&pMcAtmEntry->ATMAddress);
		}
	}
#endif // DBG

	if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
						AA_IPMC_AE_GEN_STATE_MASK,
						AA_IPMC_AE_TERMINATING))
	{
		AA_RELEASE_AE_LOCK(pAtmEntry);
		return;
	}

	AA_SET_FLAG(pMcAtmEntry->Flags,
				AA_IPMC_AE_GEN_STATE_MASK,
				AA_IPMC_AE_TERMINATING);

	if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
   					AA_IPMC_AE_CONN_STATE_MASK,
   					AA_IPMC_AE_CONN_ACTIVE))
	{
		if (pMcAtmInfo->ActiveLeaves == 1)
		{
			//
			//  This is the last active leaf in this connection. Close the call.
			//
			AA_RELEASE_AE_LOCK(pAtmEntry);

			AA_ASSERT(pVc != NULL_PATMARP_VC);
			AA_ACQUIRE_VC_LOCK(pVc);
			AtmArpCloseCall(pVc);
			//
			//  VC lock is released within the above.
			//
		}
		else
		{
			//
			//  This isn't the only leaf in this connection. Drop this party.
			//
			pAtmEntry->pMcAtmInfo->ActiveLeaves--;

			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_CONN_STATE_MASK,
						AA_IPMC_AE_CONN_WACK_DROP_PARTY);
			AA_RELEASE_AE_LOCK(pAtmEntry);

			Status = NdisClDropParty(
						NdisPartyHandle,
						NULL,		// Buffer
						(UINT)0		// Size
						);

			if (Status != NDIS_STATUS_PENDING)
			{
				AtmArpDropPartyCompleteHandler(
						Status,
						(NDIS_HANDLE)pMcAtmEntry
						);
			}
		}
	}
	else if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
   					AA_IPMC_AE_CONN_STATE_MASK,
   					AA_IPMC_AE_CONN_DISCONNECTED))
	{
		//
		//  Simply unlink this entry.
		//
		UINT rc;
		AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);					// temp ref
		AtmArpMcUnlinkAtmMember(pAtmEntry, pMcAtmEntry);
		rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);			// temp ref
		if (rc!=0)
		{
			AA_RELEASE_AE_LOCK(pAtmEntry);
		}
	}
	else
	{
		//
		//  This party is in a transient state. Let it finish its current
		//  operation.
		//
		AA_RELEASE_AE_LOCK(pAtmEntry);
	}

}

#endif // IPMCAST


VOID
AtmArpIncomingDropPartyHandler(
	IN	NDIS_STATUS					DropStatus,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
)
/*++

Routine Description:

	This handler is called if the network (or remote peer) drops
	a leaf node from a point-to-multipoint call rooted at us.

	See Section 5.1.5.1 in RFC 2022: we delete the member from
	the multicast group it belongs to. And we start a timer at
	the end of which we mark the multicast group as needing
	revalidation.

Arguments:

	DropStatus				- Leaf drop status
	ProtocolPartyContext	- Pointer to our Multicast ATM Entry structure
	pCloseData				- Optional additional info (ignored)
	Size					- of the above (ignored)

Return Value:

	None

--*/
{
#ifdef IPMCAST
	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
	PATMARP_ATM_ENTRY			pAtmEntry;
	PATMARP_IP_ENTRY			pIpEntry;
	PATMARP_INTERFACE			pInterface;
	NDIS_HANDLE					NdisPartyHandle;
	NDIS_STATUS					Status;
	ULONG						rc;

	pMcAtmEntry = (PATMARP_IPMC_ATM_ENTRY)ProtocolPartyContext;
	AA_STRUCT_ASSERT(pMcAtmEntry, ame);

	AA_ASSERT(pMcAtmEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY);
	AA_ASSERT(pMcAtmEntry->pAtmEntry->pIpEntryList != NULL_PATMARP_IP_ENTRY);

	pAtmEntry = pMcAtmEntry->pAtmEntry;

	NdisPartyHandle = pMcAtmEntry->NdisPartyHandle;
	pInterface = pAtmEntry->pInterface;

	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

	pIpEntry = pAtmEntry->pIpEntryList;
	if (pIpEntry != NULL_PATMARP_IP_ENTRY)
	{
		AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
		AA_REF_IE(pIpEntry, IE_REFTYPE_TMP);	// TmpRef
		AA_RELEASE_IE_LOCK_DPC(pIpEntry);
	}

	AA_RELEASE_IF_TABLE_LOCK(pInterface);
		
	AA_ACQUIRE_AE_LOCK(pAtmEntry);

	AADEBUGP(AAD_INFO,
		("Incoming Drop: pMcAtmEntry 0x%x, PtyHnd 0x%x, pAtmEntry 0x%x, IP Addr: %d.%d.%d.%d\n",
			pMcAtmEntry,
			NdisPartyHandle,
			pAtmEntry,
			((PUCHAR)&(pIpEntry->IPAddress))[0],
			((PUCHAR)&(pIpEntry->IPAddress))[1],
			((PUCHAR)&(pIpEntry->IPAddress))[2],
			((PUCHAR)&(pIpEntry->IPAddress))[3]));

	pAtmEntry->pMcAtmInfo->ActiveLeaves--;

	AA_SET_FLAG(pMcAtmEntry->Flags,
				AA_IPMC_AE_CONN_STATE_MASK,
				AA_IPMC_AE_CONN_RCV_DROP_PARTY);

	AA_RELEASE_AE_LOCK(pAtmEntry);

	if (pIpEntry != NULL_PATMARP_IP_ENTRY)
	{
		//
		//  We need to revalidate this multicast group after a random
		//  delay. Start a random delay timer.
		//
		AA_ACQUIRE_IE_LOCK(pIpEntry);
		AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

		if (!AA_IS_TIMER_ACTIVE(&(pIpEntry->Timer)) &&
			AA_IS_FLAG_SET(pIpEntry->Flags,
							AA_IP_ENTRY_MC_RESOLVE_MASK,
							AA_IP_ENTRY_MC_RESOLVED))
		{
			ULONG	RandomDelay;

			RandomDelay =  AA_GET_RANDOM(
								pInterface->MinRevalidationDelay,
								pInterface->MaxRevalidationDelay);
			AtmArpStartTimer(
				pInterface,
				&(pIpEntry->Timer),
				AtmArpMcRevalidationDelayTimeout,
				RandomDelay,
				(PVOID)pIpEntry
				);

			AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref
		}

		rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP);
		if (rc != 0)
		{
			AA_RELEASE_IE_LOCK(pIpEntry);
		}
	}

	//
	//  Complete the DropParty handshake.
	//
	Status = NdisClDropParty(
				NdisPartyHandle,
				NULL,
				0
				);

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmArpDropPartyCompleteHandler(
				Status,
				(NDIS_HANDLE)pMcAtmEntry
				);
	}
#endif // IPMCAST
	return;
}



VOID
AtmArpQosChangeHandler(
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This handler is called if the remote peer modifies call parameters
	"on the fly", i.e. after the call is established and running.

	This isn't supported by existing ATM signalling, and shouldn't happen,
	but we'll allow this.

	FUTURE: The FlowSpecs associated with the call are affected by this.

Arguments:

	ProtocolVcContext		- Pointer to our ATMARP VC structure
	pCallParameters			- updated call parameters.

Return Value:

	None

--*/
{
	PATMARP_VC		pVc;

	pVc = (PATMARP_VC)ProtocolVcContext;

	AADEBUGP(AAD_WARNING, ("Ignoring Qos Change, VC: 0x%x\n", pVc));

	return;
}




VOID
AtmArpOpenAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisAfHandle
)
/*++

Routine Description:

	This handler is called to indicate completion of a previous call
	to NdisClOpenAddressFamily. We would have blocked the thread that
	called this. Wake it up now.

	By the way, if the call was successful, store the NDIS AF handle
	in our Interface structure.

	We don't need to acquire locks here because the thread that called
	OpenAddressFamily would have blocked with a lock acquired.

Arguments:

	Status					- Status of the Open AF
	ProtocolAfContext		- Pointer to our ATMARP Interface structure
	NdisAfHandle			- NDIS handle to the AF association

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;

	pInterface = (PATMARP_INTERFACE)ProtocolAfContext;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("Open AF Complete: IF 0x%x, Status 0x%x, AF Handle 0x%x\n",
				pInterface, Status, NdisAfHandle));


	if (Status == NDIS_STATUS_SUCCESS)
	{
		pInterface->NdisAfHandle = NdisAfHandle;
	}

	//
	//  Wake up the blocked thread
	//
	AA_SIGNAL_BLOCK_STRUCT(&(pInterface->Block), Status);
}




VOID
AtmArpSendIPDelInterface(
	IN	PNDIS_WORK_ITEM				pWorkItem,
	IN	PVOID						IfContext
)
{
	PATMARP_INTERFACE		pInterface;
	PVOID					IPContext;
	ULONG					rc;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);
#if !BINARY_COMPATIBLE
	AA_ASSERT(EntryIrq == PASSIVE_LEVEL);
#endif

	pInterface = (PATMARP_INTERFACE)IfContext;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_FREE_MEM(pWorkItem);

	AA_ACQUIRE_IF_LOCK(pInterface);

	IPContext = pInterface->IPContext;
	pInterface->IPContext = NULL;

	AA_RELEASE_IF_LOCK(pInterface);

	AADEBUGP(AAD_INFO, ("SendIPDelInterface: IF 0x%x, IPContext 0x%x\n",
				pInterface, IPContext));

	if (IPContext != NULL)
	{
		(*(pAtmArpGlobalInfo->pIPDelInterfaceRtn))(
					IPContext
#if IFCHANGE1
#ifndef  ATMARP_WIN98
					,0	// DeleteIndex (unused) --  See 10/14/1998 entry
						// in notes.txt
#endif
#endif // IFCHANGE1
					);
	}
	else
	{
		AADEBUGP(AAD_INFO, ("SendIPDelInterface: NO IPContext"));
	}

	AA_ACQUIRE_IF_LOCK(pInterface);

	rc = AtmArpDereferenceInterface(pInterface);	// Work Item: Del Interface

	if (rc != 0)
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}
	//
	//  else the Interface is gone.
	//

}


VOID
AtmArpCloseAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext
)
/*++

Routine Description:

	This routine is called to indicate completion of a call to
	NdisClCloseAddressFamily. Tell IP to Delete this Interface now.

Arguments:

	Status					- Status of the Close AF (ignored here)
	ProtocolAfContext		- Pointer to ATMARP Interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PNDIS_WORK_ITEM			pWorkItem;
	NDIS_STATUS				NdisStatus;
	BOOLEAN					bUnloading;
#if 0
	PVOID					IPContext;
#endif
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);
#if !BINARY_COMPATIBLE
	AA_ASSERT(EntryIrq == PASSIVE_LEVEL);
#endif

	AA_ASSERT(Status == NDIS_STATUS_SUCCESS);

	pInterface = (PATMARP_INTERFACE)ProtocolAfContext;

	AADEBUGP(AAD_INFO, ("CloseAfComplete: If 0x%x, Status 0x%x\n",
			pInterface, Status));

	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IF_LOCK(pInterface);

	pInterface->NdisAfHandle = NULL;
	bUnloading = pAtmArpGlobalInfo->bUnloading;

	if (pInterface->IPContext != NULL)
	{
		//
		//  We haven't seen an IfClose yet.
		//
		AA_ALLOC_MEM(pWorkItem, NDIS_WORK_ITEM, sizeof(NDIS_WORK_ITEM));
		if (pWorkItem == NULL)
		{
			AA_ASSERT(FALSE);
			AA_RELEASE_IF_LOCK(pInterface);
			return;
		}

#if 0
		IPContext = (PVOID)pInterface->IPContext;
		pInterface->IPContext = NULL;
#endif
		AtmArpReferenceInterface(pInterface);	// Work Item

		AA_RELEASE_IF_LOCK(pInterface);

		if (bUnloading)
		{
			AtmArpSendIPDelInterface(pWorkItem, (PVOID)pInterface);
		}
		else
		{
			//
			//  Queue a work item so that (a) things unravel easier,
			//  (b) we are at passive level when we call IPDelInterface.
			//
			NdisInitializeWorkItem(
				pWorkItem,
				AtmArpSendIPDelInterface,
				(PVOID)pInterface
				);
	
			NdisStatus = NdisScheduleWorkItem(pWorkItem);

			AA_ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);
		}
	}
	else
	{
		AADEBUGP(AAD_WARNING, ("CloseAfComplete: NO IPContext"));
		AA_RELEASE_IF_LOCK(pInterface);
	}

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

}




VOID
AtmArpRegisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext,
	IN	PCO_SAP						pSap,
	IN	NDIS_HANDLE					NdisSapHandle
)
/*++

Routine Description:

	This routine is called to indicate completion of a call to
	NdisClRegisterSap. If the call was successful, save the
	allocated NdisSapHandle in our SAP structure.

Arguments:

	Status						- Status of Register SAP
	ProtocolSapContext			- Pointer to our ATMARP Interface structure
	pSap						- SAP information we'd passed in the call
	NdisSapHandle				- SAP Handle

Return Value:

	None

--*/
{
	PATMARP_SAP					pAtmArpSap;

	pAtmArpSap = (PATMARP_SAP)ProtocolSapContext;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pAtmArpSap->NdisSapHandle = NdisSapHandle;
		AA_SET_FLAG(pAtmArpSap->Flags,
					AA_SAP_REG_STATE_MASK,
					AA_SAP_REG_STATE_REGISTERED);
	}
	else
	{
		AA_SET_FLAG(pAtmArpSap->Flags,
					AA_SAP_REG_STATE_MASK,
					AA_SAP_REG_STATE_IDLE);
	}
}




VOID
AtmArpDeregisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext
)
/*++

Routine Description:

	This routine is called when a previous call to NdisClDeregisterSap
	has completed. If it was successful, we update the state of the ATMARP
	SAP structure representing the Sap.

Arguments:

	Status						- Status of the Deregister SAP request
	ProtocolSapContext			- Pointer to our ATMARP SAP structure

Return Value:

	None

--*/
{

	PATMARP_INTERFACE			pInterface;
	PATMARP_SAP					pAtmArpSap;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pAtmArpSap = (PATMARP_SAP)ProtocolSapContext;

		AA_STRUCT_ASSERT(pAtmArpSap, aas);
		pInterface = pAtmArpSap->pInterface;

		AA_ACQUIRE_IF_LOCK(pInterface);

		pAtmArpSap->NdisSapHandle = NULL;

		AA_SET_FLAG(pAtmArpSap->Flags,
					AA_SAP_REG_STATE_MASK,
					AA_SAP_REG_STATE_IDLE);
		
		AA_RELEASE_IF_LOCK(pInterface);
	}

	return;
}




VOID
AtmArpMakeCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called when an outgoing call request (NdisClMakeCall)
	has completed. The "Status" parameter indicates whether the call was
	successful or not.

	If the call was successful, we send any packets queued for transmission
	on this VC.

	If the call failed, we free any packets queued on this VC and unlink it
	from the ATM Address Entry it was linked to. If this was an attempt to
	connect to the ATMARP server, delay for a while before attempting to
	connect again.

Arguments:

	Status						- Result of the NdisClMakeCall
	ProtocolVcContext			- Pointer to ATMARP VC structure
	NdisPartyHandle				- Not used (no point-to-multipoint calls)
	pCallParameters				- Pointer to call parameters

Return Value:

	None

--*/
{
	PATMARP_VC					pVc;
	PATMARP_INTERFACE			pInterface;
	ULONG						rc;				// ref count
	BOOLEAN						IsServerVc;		// Is this the VC to the ATMARP server?
	BOOLEAN						IsPMP;
	PNDIS_PACKET				PacketList;		// List of packets waiting to be sent
	AA_HEADER_TYPE				HdrType;		// header types for the above
	BOOLEAN						HdrPresent;
	NDIS_HANDLE					NdisVcHandle;

	PATMARP_ATM_ENTRY			pAtmEntry;		// ATM Entry to which this VC is linked

	Q2931_CALLMGR_PARAMETERS UNALIGNED *	pCallMgrSpecific;
	Q2931_IE UNALIGNED *					pIe;
	ULONG									InfoElementCount;

	//
	//  Initialize
	//
	PacketList = (PNDIS_PACKET)NULL;

	pVc = (PATMARP_VC)ProtocolVcContext;
	AA_STRUCT_ASSERT(pVc, avc);

	AADEBUGP(AAD_INFO, ("MakeCall Complete: Status 0x%x, VC 0x%x, pAtmEntry 0x%x\n",
				Status, pVc, pVc->pAtmEntry));

	AA_ACQUIRE_VC_LOCK(pVc);

	IsPMP = AA_IS_FLAG_SET(pVc->Flags,
							AA_VC_CONN_TYPE_MASK,
							AA_VC_CONN_TYPE_PMP);

	pAtmEntry = pVc->pAtmEntry;
	AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);

	if (pVc->FlowSpec.Encapsulation == ENCAPSULATION_TYPE_LLCSNAP)
	{
		HdrType = (IsPMP? AA_HEADER_TYPE_NUNICAST: AA_HEADER_TYPE_UNICAST);
		HdrPresent = TRUE;
	}
	else
	{
		HdrType = AA_HEADER_TYPE_NONE;
		HdrPresent = FALSE;
	}

	pInterface = pVc->pInterface;

	if (pInterface->AdminState == IF_STATUS_UP)
	{
		if (Status == NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_LOUD, ("Make Call Successful on VC 0x%x\n", pVc));
			//
			//  Update the call state on this VC, and send queued packets.
			//  If this happens to be the VC to the ATMARP Server, we expect
			//  to see our initial ARP Request (to register with the server)
			//  in this queue.
			//
			AA_SET_FLAG(pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_ACTIVE);

			//
			//  Locate the AAL parameters Info Element, and get the updated
			//  packet sizes.
			//
			pCallMgrSpecific = (PQ2931_CALLMGR_PARAMETERS)&pCallParameters->CallMgrParameters->CallMgrSpecific.Parameters[0];
			pIe = (PQ2931_IE)&pCallMgrSpecific->InfoElements[0];

			for (InfoElementCount = 0;
				 InfoElementCount < pCallMgrSpecific->InfoElementCount;
				 InfoElementCount++)
			{
				if (pIe->IEType == IE_AALParameters)
				{
					AAL_PARAMETERS_IE UNALIGNED *	pAalIe;
					UNALIGNED AAL5_PARAMETERS *		pAal5;

					pAalIe = (PAAL_PARAMETERS_IE)&pIe->IE[0];
					AA_ASSERT(pAalIe->AALType == AAL_TYPE_AAL5);
					pAal5 = &pAalIe->AALSpecificParameters.AAL5Parameters;

#if DBG
					if (pVc->FlowSpec.SendMaxSize != pAal5->ForwardMaxCPCSSDUSize)
					{
						AADEBUGP(AAD_INFO,
							("CallComplete: Send size changed (%d->%d)\n",
								pVc->FlowSpec.SendMaxSize,
								pAal5->ForwardMaxCPCSSDUSize));
					}
					if (pVc->FlowSpec.ReceiveMaxSize != pAal5->BackwardMaxCPCSSDUSize)
					{
						AADEBUGP(AAD_INFO,
							("CallComplete: Receive size changed (%d->%d)\n",
								pVc->FlowSpec.ReceiveMaxSize,
								pAal5->BackwardMaxCPCSSDUSize));
					}
#endif // DBG
					pVc->FlowSpec.SendMaxSize = pAal5->ForwardMaxCPCSSDUSize;
					pVc->FlowSpec.ReceiveMaxSize = pAal5->BackwardMaxCPCSSDUSize;
					break;
				}
				pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
			}

			AA_ASSERT(InfoElementCount != pCallMgrSpecific->InfoElementCount);
				

			//
			//  Update the call type on this VC. If this is an SVC, start
			//  the VC aging timer.
			//
			if (pCallParameters->Flags & PERMANENT_VC)
			{
				AA_SET_FLAG(pVc->Flags,
							AA_VC_TYPE_MASK,
							AA_VC_TYPE_PVC);
			}
			else
			{
				ULONG		AgingTime;

				AA_SET_FLAG(pVc->Flags,
							AA_VC_TYPE_MASK,
							AA_VC_TYPE_SVC);

#ifdef IPMCAST
				if (IsPMP)
				{
					AgingTime = pInterface->MulticastEntryAgingTimeout;
				}
				else
				{
					AgingTime = pVc->FlowSpec.AgingTime;
				}
#else
				AgingTime = pVc->FlowSpec.AgingTime;
#endif // IPMCAST

				//
				//  Start VC aging timer on this SVC.
				//
				if (AgingTime != 0)
				{
					AtmArpStartTimer(
						pInterface,
						&(pVc->Timer),
						AtmArpVcAgingTimeout,
						AgingTime,
						(PVOID)pVc
						);

					AtmArpReferenceVc(pVc);	// Timer ref
				}
			}

			AtmArpStartSendsOnVc(pVc);
	
			//
			//  The VC lock is released within StartSendsOnVc()
			//

#ifdef IPMCAST
			if (IsPMP)
			{
				AtmArpMcMakeCallComplete(
						pAtmEntry,
						NdisPartyHandle,
						Status
						);
			}
#endif // IPMCAST

		}
		else
		{
			//
			//  The call failed.
			//

			AA_SET_FLAG(pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_IDLE);

			//
			//  Delete the Call reference
			//
			rc = AtmArpDereferenceVc(pVc);
			AA_ASSERT(rc > 0);

			//
			//  Remove all packets queued on this VC
			//
			PacketList = pVc->PacketList;
			pVc->PacketList = (PNDIS_PACKET)NULL;

			//
			//  Was this a call to the ATMARP server?
			//
			if (pInterface->pCurrentServer != NULL)
			{
				IsServerVc = (pVc->pAtmEntry == pInterface->pCurrentServer->pAtmEntry);
			}
			else
			{
				IsServerVc = FALSE;
			}

			AADEBUGP(AAD_INFO,
				 ("Make Call FAILED on VC 0x%x IsPMP=%lu IsServer=%lu\n",
				  pVc,
				  IsPMP,
				  IsServerVc
				  ));

	#ifdef GPC
			//
			// Unlink this VC from the flow, if linked...
			//
			if (pVc->FlowHandle != NULL)
			{
				PATMARP_FLOW_INFO	pFlowInfo = (PATMARP_FLOW_INFO)pVc->FlowHandle;
				if ((PVOID)pVc == InterlockedCompareExchangePointer(
										&(pFlowInfo->VcContext),
										NULL,
										pVc
										))
				{
					pVc->FlowHandle = NULL;
					rc = AtmArpDereferenceVc(pVc);	// Unlink from GPC Flow
					AA_ASSERT(rc > 0);
				}
			}
	#endif // GPC


			//
			//  Unlink this VC from the ATM Entry it belonged to, if any
			//
			AA_ASSERT(pVc->pAtmEntry != NULL_PATMARP_ATM_ENTRY);
			AtmArpUnlinkVcFromAtmEntry(pVc, FALSE);

			//
			//  Delete the ATM Entry reference
			//
			rc = AtmArpDereferenceVc(pVc); // ATM Entry ref
			AA_ASSERT(rc > 0);

			//
			//  Delete the CreateVc reference
			//
			NdisVcHandle = pVc->NdisVcHandle;
			rc =  AtmArpDereferenceVc(pVc);	// Create Vc ref

			if (rc != 0)
			{
				AA_RELEASE_VC_LOCK(pVc);
			}

#ifndef VC_REFS_ON_SENDS
			//
			//  Delete the NDIS association
			//
			(VOID)NdisCoDeleteVc(NdisVcHandle);
#endif // VC_REFS_ON_SENDS
			AADEBUGP(AAD_LOUD, ("Deleted NDIS VC on pVc 0x%x: NdisVcHandle 0x%x\n",
						pVc, NdisVcHandle));

			AA_ACQUIRE_AE_LOCK(pAtmEntry);
			rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_VC);	// Unlink Vc - make call

			if (rc != 0)
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
#ifdef IPMCAST
				if (IsPMP)
				{
					AtmArpMcMakeCallComplete(
						pAtmEntry,
						NdisPartyHandle,
						Status
						);
				}
				else
				{
#endif // IPMCAST
					if (!AA_IS_TRANSIENT_FAILURE(Status))
					{
						AA_ACQUIRE_AE_LOCK(pAtmEntry);
						AtmArpInvalidateAtmEntry(pAtmEntry, FALSE);	// MakeCall failure
						//
						//  AE Lock is released within the above.
						//
					}
#ifdef IPMCAST
				}
#endif // IPMCAST
			}
			//
			//  else the ATM Entry is gone
			//

			if (IsServerVc)
			{
				BOOLEAN		WasRunning;

				AA_ACQUIRE_IF_LOCK(pInterface);

				//
				//  If we were in the process of registering (or refreshing)
				//  ourselves with the server, then retry after a while.
				//
				if (AA_IS_FLAG_SET(
						pInterface->Flags,
						AA_IF_SERVER_STATE_MASK,
						AA_IF_SERVER_REGISTERING))
				{
					AA_SET_FLAG(pInterface->Flags,
							AA_IF_SERVER_STATE_MASK,
							AA_IF_SERVER_NO_CONTACT);

					//
					//  The server registration timer would have been
					//  started -- stop it first.
					//
					WasRunning = AtmArpStopTimer(&(pInterface->Timer), pInterface);
					if (WasRunning)
					{
						rc = AtmArpDereferenceInterface(pInterface);
					}
					else
					{
						rc = pInterface->RefCount;
					}
	
					if (rc > 0)
					{
						AtmArpRetryServerRegistration(pInterface);
						//
						//  The IF lock is released within the above.
						//
					}
					//
					//  else the IF is gone!
					//
				}
				else
				{
					//
					//  We might have been trying to set up the server VC
					//  because of other reasons:
					//  - to resolve an unknown IP address
					//  - the server ATM address might be shared with other
					//    services (e.g. DHCP server)
					//
					//  We don't have to retry registration in these cases.
					//
					AA_RELEASE_IF_LOCK(pInterface);
				}
			}
		}
	}
	else
	{
		//
		//  The Interface is going down: clean up everything first.
		//

		if (Status == NDIS_STATUS_SUCCESS)
		{
			AA_SET_FLAG(pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_ACTIVE);

			//
			//  The call had been set up successfully, so close it.
			//  AtmArpCloseCall also frees any queued packets on the VC.
			//
			AtmArpCloseCall(pVc);
			//
			//  The VC lock is released by CloseCall
			//
		}
		else
		{
			//  MakeCall had failed. (And the IF is going down)

			AA_SET_FLAG(pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_IDLE);

			//
			//  Remove all packets queued on this VC
			//
			PacketList = pVc->PacketList;
			pVc->PacketList = (PNDIS_PACKET)NULL;
	
			NdisVcHandle = pVc->NdisVcHandle;

			AtmArpUnlinkVcFromAtmEntry(pVc, TRUE);

			//
			//  Delete the ATM Entry reference
			//
			rc = AtmArpDereferenceVc(pVc);  // ATM Entry ref

			//
			//  Delete the Call reference
			//
			rc = AtmArpDereferenceVc(pVc);
			AA_ASSERT(rc > 0);

			//
			//  Delete the CreateVc reference
			//
			rc =  AtmArpDereferenceVc(pVc);	// Create Vc ref

			if (rc != 0)
			{
				AA_RELEASE_VC_LOCK(pVc);
			}

#ifndef VC_REFS_ON_SENDS
			//
			//  Delete the NDIS association
			//
			(VOID)NdisCoDeleteVc(NdisVcHandle);
			AADEBUGP(AAD_LOUD,
				("MakeCall Fail: Deleted NDIS VC on pVc 0x%x: NdisVcHandle 0x%x\n",
						pVc, NdisVcHandle));
#endif // !VC_REFS_ON_SENDS
		}
	}

	//
	//  If there was a failure in making the call, or we aborted
	//  it for some reason, free all packets that were queued
	//  on the VC.
	//
	if (PacketList != (PNDIS_PACKET)NULL)
	{
		AtmArpFreeSendPackets(
					pInterface,
					PacketList,
					HdrPresent
					);
	}

	//
	//  We would have allocated the Call Parameters in MakeCall().
	//  We don't need it anymore.
	//
	AA_FREE_MEM(pCallParameters);
	return;

}



#ifdef IPMCAST

VOID
AtmArpMcMakeCallComplete(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	Post-processing of a PMP MakeCall completion.

Arguments:

	pAtmEntry					- Represents the multicast group to which
								  the call was made.
	NdisPartyHandle				- Returned from the MakeCall.
	Status						- Result of the MakeCall

Return Value:

	None

--*/
{

	PATMARP_IPMC_ATM_ENTRY			pMcAtmEntry;
	PATMARP_IPMC_ATM_ENTRY *		ppMcAtmEntry;
	PATMARP_IPMC_ATM_INFO			pMcAtmInfo;
	PATMARP_IP_ENTRY				pIpEntry;
	PATMARP_INTERFACE				pInterface;
	//
	//  Do we need to update the PMP connection as a result
	//  of this event?
	//
	BOOLEAN							bWantConnUpdate;
	ULONG							DelayBeforeRetry;
	BOOLEAN							bAtmEntryLockAcquired;

	bAtmEntryLockAcquired = TRUE;
	AA_ACQUIRE_AE_LOCK(pAtmEntry);

	AA_ASSERT(pAtmEntry->pMcAtmInfo != NULL_PATMARP_IPMC_ATM_INFO);
	AA_ASSERT(pAtmEntry->pIpEntryList != NULL_PATMARP_IP_ENTRY);

	pIpEntry = pAtmEntry->pIpEntryList;
	pMcAtmInfo = pAtmEntry->pMcAtmInfo;
	pInterface = pAtmEntry->pInterface;

	bWantConnUpdate = FALSE;

	pMcAtmInfo->TransientLeaves--;

	//
	//  Locate the MC ATM Entry representing the first party.
	//
	for (pMcAtmEntry = pMcAtmInfo->pMcAtmEntryList;
		 /* NONE */;
		 pMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry)
	{
		AA_ASSERT(pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY);
		if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
							AA_IPMC_AE_CONN_STATE_MASK,
							AA_IPMC_AE_CONN_WACK_ADD_PARTY))
		{
			break;
		}
	}

	AAMCDEBUGP(AAD_INFO,
			("McMakeCallComplete: pAtmEntry 0x%x, pMcAtmEntry 0x%x, Status 0x%x\n",
					pAtmEntry, pMcAtmEntry, Status));

	AAMCDEBUGPATMADDR(AAD_EXTRA_LOUD, "McMakeCall Addr: ", &pMcAtmEntry->ATMAddress);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pMcAtmInfo->ActiveLeaves++;

		//
		//  Update Multicast state
		//
		AA_SET_FLAG(pMcAtmInfo->Flags,
					AA_IPMC_AI_CONN_STATE_MASK,
					AA_IPMC_AI_CONN_ACTIVE);

		//
		//  Update state of "first party"
		//
		pMcAtmEntry->NdisPartyHandle = NdisPartyHandle;
		AA_SET_FLAG(pMcAtmEntry->Flags,
					AA_IPMC_AE_CONN_STATE_MASK,
					AA_IPMC_AE_CONN_ACTIVE);

		bWantConnUpdate = TRUE;

		//
		//  If we had decided to terminate this member when the
		//  MakeCall was going on, then we now mark this as Invalid.
		//  When we next update this PMP connection, this member will
		//  be removed.
		//
		if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_TERMINATING))
		{
			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_GEN_STATE_MASK,
						AA_IPMC_AE_INVALID);
		}
	}
	else
	{
		//
		//  A PMP call failed. If the failure is not "transient",
		//  we remove the member we were trying to connect to
		//  from the list. If there is atleast one more member
		//  that hasn't been attempted yet, try to connect to that.
		//

		AAMCDEBUGP(AAD_INFO, ("McMakeCall failed: pAtmEntry 0x%x, pMcAtmEntry 0x%x, Status 0x%x ",
					pAtmEntry, pMcAtmEntry, Status));
		AAMCDEBUGPATMADDR(AAD_INFO, " Addr: ", &pMcAtmEntry->ATMAddress);

		//
		//  Update PMP connection state
		//
		AA_SET_FLAG(pAtmEntry->pMcAtmInfo->Flags,
					AA_IPMC_AI_CONN_STATE_MASK,
					AA_IPMC_AI_CONN_NONE);


		if (AA_IS_TRANSIENT_FAILURE(Status))
		{
			//
			//  Update first party state.
			//
			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_CONN_STATE_MASK,
						AA_IPMC_AE_CONN_TEMP_FAILURE);

			DelayBeforeRetry = AA_GET_TIMER_DURATION(&(pMcAtmEntry->Timer));
			if (DelayBeforeRetry == 0)
			{
				//
				//  First time we're doing this.
				//
				DelayBeforeRetry = AA_GET_RANDOM(
										pInterface->MinPartyRetryDelay,
										pInterface->MaxPartyRetryDelay);
			}
			else
			{
				DelayBeforeRetry = 2*DelayBeforeRetry;
			}

			AtmArpStartTimer(
				pInterface,
				&(pMcAtmEntry->Timer),
				AtmArpMcPartyRetryDelayTimeout,
				DelayBeforeRetry,
				(PVOID)pMcAtmEntry
				);
		}
		else
		{
			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_CONN_STATE_MASK,
						AA_IPMC_AE_CONN_DISCONNECTED);

			AtmArpMcUnlinkAtmMember(
					pAtmEntry,
					pMcAtmEntry
					);

		}

		//
		//  Look for a member that we haven't tried to connect to.
		//
		for (ppMcAtmEntry = &(pMcAtmInfo->pMcAtmEntryList);
			 *ppMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
			 ppMcAtmEntry = &((*ppMcAtmEntry)->pNextMcAtmEntry))
		{
			if (AA_IS_FLAG_SET((*ppMcAtmEntry)->Flags,
								AA_IPMC_AE_CONN_STATE_MASK,
								AA_IPMC_AE_CONN_DISCONNECTED))
			{
				//
				//  Found one.
				//
				break;
			}
		}

		if (*ppMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY)
		{
			pMcAtmEntry = *ppMcAtmEntry;

			//
			//  Move this member to the top of the list.
			//  First, unlink from current position.
			//
			*ppMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;

			//
			//  Now insert this at top of list.
			//
			pMcAtmEntry->pNextMcAtmEntry = pMcAtmInfo->pMcAtmEntryList;
			pMcAtmInfo->pMcAtmEntryList = pMcAtmEntry;

			bWantConnUpdate = TRUE;
		}
		else
		{
			//
			//  There is no ATM member that we haven't tried to connect to.
			//
			if (pMcAtmInfo->pMcAtmEntryList == NULL_PATMARP_IPMC_ATM_ENTRY)
			{
				//
				//  The list of ATM Members is empty.
				//
				AA_RELEASE_AE_LOCK(pAtmEntry);

				AA_ACQUIRE_IE_LOCK(pIpEntry);
				AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
				AtmArpAbortIPEntry(pIpEntry);
				//
				//  IE Lock is released within the above.
				//

				bAtmEntryLockAcquired = FALSE;
			}
		}
	}


	if (bWantConnUpdate)
	{
		AA_ASSERT(bAtmEntryLockAcquired == TRUE);
		AtmArpMcUpdateConnection(pAtmEntry);
		//
		//  AE Lock is released within the above.
		//
	}
	else
	{
		if (bAtmEntryLockAcquired)
		{
			AA_RELEASE_AE_LOCK(pAtmEntry);
		}
	}
}

#endif // IPMCAST


VOID
AtmArpCloseCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					ProtocolPartyContext OPTIONAL
)
/*++

Routine Description:

	This routine handles completion of a previous NdisClCloseCall.
	It is assumed that Status is always NDIS_STATUS_SUCCESS.

	We delete the VC on which the call was just closed.

	Special case: if we just finished closing a PMP call for a multicast
	group that has been told to migrate to a (possibly) new set of
	addresses, start off a new connection now.

Arguments:

	Status					- Status of the Close Call.
	ProtocolVcContext		- Pointer to ATMARP VC structure.
	ProtocolPartyContext	- Not used.

Return Value:

	None

--*/
{
	PATMARP_VC				pVc;
	PATMARP_VC *			ppVc;
	PATMARP_ATM_ENTRY		pAtmEntry;
	PATMARP_INTERFACE		pInterface;
#ifdef IPMCAST
	PATMARP_IPMC_ATM_ENTRY	pMcAtmEntry;	// represents the last leaf
	PATMARP_IPMC_ATM_INFO	pMcAtmInfo;
#endif // IPMCAST
	ULONG					rc;			// Ref Count
	NDIS_HANDLE				NdisVcHandle;
	BOOLEAN					UpdatePMPConnection;
	BOOLEAN					AtmEntryIsClosing;
	BOOLEAN					IsMarsProblem;
	BOOLEAN					IsPVC;
	BOOLEAN					Found;

	pVc = (PATMARP_VC)ProtocolVcContext;
	AA_STRUCT_ASSERT(pVc, avc);

	AADEBUGP(AAD_VERY_LOUD, ("CloseCallComplete: pVc 0x%x, Flags 0x%x, RefCount %d\n",
					pVc, pVc->Flags, pVc->RefCount));

	IsPVC = AA_IS_FLAG_SET(pVc->Flags, AA_VC_TYPE_MASK, AA_VC_TYPE_PVC);

	//
	//  This VC may not be linked to an ATM Entry, e.g. for an unresolved
	//  Incoming PVC.
	//
	pAtmEntry = pVc->pAtmEntry;

	if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
	{
		AtmEntryIsClosing = AA_IS_FLAG_SET(pAtmEntry->Flags,
											AA_ATM_ENTRY_STATE_MASK,
											AA_ATM_ENTRY_CLOSING);
	}
	else
	{
		AtmEntryIsClosing = FALSE;
	}

	pInterface = pVc->pInterface;

	if (IsPVC)
	{
		//
		//  Take the PVC out of the unresolved VC list, if it
		//  exists there.
		//
		Found = FALSE;

		AA_ACQUIRE_IF_LOCK(pInterface);

		ppVc = &(pInterface->pUnresolvedVcs);
		while (*ppVc != NULL_PATMARP_VC)
		{
			if (*ppVc == pVc)
			{
				*ppVc = pVc->pNextVc;
				Found = TRUE;
				break;
			}
			ppVc = &((*ppVc)->pNextVc);
		}

		AA_RELEASE_IF_LOCK(pInterface);

		AA_ACQUIRE_VC_LOCK(pVc);

		if (Found)
		{
			AADEBUGP(AAD_FATAL,
				("CloseCallComplete: took VC (PVC) %x out of IF %x\n",
						pVc, pInterface));

			rc = AtmArpDereferenceVc(pVc);	// Unresolved VC list
		}
		else
		{
			rc = pVc->RefCount;
		}

		if (rc == 0)
		{
			//
			//  The VC is gone!
			//
			AADEBUGP(AAD_WARNING,
				("CloseCallComplete: VC (PVC) %x derefed away, IF %x\n",
						pVc, pInterface));
			return;
		}
		else
		{
			AA_RELEASE_VC_LOCK(pVc);
		}
	}

#ifdef IPMCAST

	//
	//  We have lost our connection to the MARS if this was the last
	//  VC going to that address. We should atleast be a party on
	//  ClusterControlVc.
	//
	IsMarsProblem = FALSE;

	if (pInterface->AdminState == IF_STATUS_UP)
	{
		if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
		{
			if (pAtmEntry->pVcList->pNextVc == NULL_PATMARP_VC)
			{
				if (pInterface->pCurrentMARS &&
					(pInterface->pCurrentMARS->pAtmEntry == pAtmEntry))
				{
					IsMarsProblem = TRUE;
					AA_ACQUIRE_IF_LOCK(pInterface);
					AtmArpReferenceInterface(pInterface);
					AA_RELEASE_IF_LOCK(pInterface);
				}
			}
		}
	}
	
	UpdatePMPConnection = FALSE;

	pMcAtmEntry = (PATMARP_IPMC_ATM_ENTRY)ProtocolPartyContext;

	//
	//  If this is a point-to-multipoint connection that was closed,
	//  handle unlinking the last leaf.
	//
	if (pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY)
	{
		//
		//  This is a PMP connection.
		//
		AAMCDEBUGP(AAD_LOUD, ("CloseCallComplete (MC): pAtmEntry 0x%x/0x%x\n",
			pAtmEntry, pAtmEntry->Flags));

		AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);

		AA_ACQUIRE_AE_LOCK(pAtmEntry);

		AA_SET_FLAG(pMcAtmEntry->Flags,
					AA_IPMC_AE_CONN_STATE_MASK,
					AA_IPMC_AE_CONN_DISCONNECTED);

		AtmArpMcUnlinkAtmMember(pAtmEntry, pMcAtmEntry);

		pMcAtmInfo = pAtmEntry->pMcAtmInfo;
		AA_ASSERT(pMcAtmInfo != NULL_PATMARP_IPMC_ATM_INFO);

		//
		//  Make the new list of ATM stations (the "Migrate to" list)
		//  the current list. This might be NULL.
		//
		pMcAtmInfo->pMcAtmEntryList = pMcAtmInfo->pMcAtmMigrateList;
		pMcAtmInfo->pMcAtmMigrateList = NULL_PATMARP_IPMC_ATM_ENTRY;

		//
		//  If there is a non-empty migrate list, then we have
		//  to make a fresh PMP connection.
		//
		UpdatePMPConnection =
			(pMcAtmInfo->pMcAtmEntryList != NULL_PATMARP_IPMC_ATM_ENTRY);

		AA_SET_FLAG(pMcAtmInfo->Flags,
					AA_IPMC_AI_CONN_STATE_MASK,
					AA_IPMC_AI_CONN_NONE);

		AA_RELEASE_AE_LOCK(pAtmEntry);
	}
#endif // IPMCAST

	AA_ACQUIRE_VC_LOCK(pVc);

	if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
	{
		AtmArpUnlinkVcFromAtmEntry(pVc, TRUE);
		rc = AtmArpDereferenceVc(pVc);  // ATM Entry ref
		AA_ASSERT(rc != 0);
	}

	rc = AtmArpDereferenceVc(pVc);	// Call reference
	AA_ASSERT(rc != 0);	// CreateVc reference remains
	AA_SET_FLAG(pVc->Flags,
				AA_VC_CALL_STATE_MASK,
				AA_VC_CALL_STATE_IDLE);

	AA_ASSERT(pVc->PacketList == NULL);

	//
	//  If this VC belongs to us, delete it.
	//
	if (AA_IS_FLAG_SET(pVc->Flags,
						AA_VC_OWNER_MASK,
						AA_VC_OWNER_IS_ATMARP))
	{
		NdisVcHandle = pVc->NdisVcHandle;
		rc =  AtmArpDereferenceVc(pVc);	// Create Vc ref
		if (rc != 0)
		{
			// Could still be temp refs...
			AA_RELEASE_VC_LOCK(pVc);
		}
		else
		{
			// The VC has been deallocated, and lock released
		}

#ifndef VC_REFS_ON_SENDS
		//
		//  Delete the NDIS association
		//
		(VOID)NdisCoDeleteVc(NdisVcHandle);
#endif // VC_REFS_ON_SENDS
		AADEBUGP(AAD_LOUD, 
			("CloseCallComplete: deleted NDIS VC on pVc 0x%x: NdisVcHandle 0x%x\n",
				pVc, NdisVcHandle));
	}
	else
	{
		//
		//  VC belongs to the Call Manager -- take it back to the
		//  state it was when it was just created (via our CreateVcHandler).
		//  The Call Manager can either re-use it or delete it.
		//
		pVc->Flags = AA_VC_OWNER_IS_CALLMGR;
		AA_RELEASE_VC_LOCK(pVc);
	}

#ifdef IPMCAST
	if (UpdatePMPConnection)
	{
		AAMCDEBUGP(AAD_INFO,
			("CloseCallComplete: pVc 0x%x, starting update on pAtmEntry 0x%x\n",
					pVc, pAtmEntry));

		AA_ACQUIRE_AE_LOCK(pAtmEntry);
		AtmArpMcUpdateConnection(pAtmEntry);
		//
		//  AE Lock is released within the above.
		//
	}
	else
	{
		//
		//  If this was a PMP connection, handle the case
		//  of a remote-initiated CloseCall: we need to
		//  unlink the ATM Entry from the IP Entry.
		//
		if ((pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY) &&
			!AtmEntryIsClosing)
		{
			AA_ACQUIRE_AE_LOCK(pAtmEntry);
			AtmArpInvalidateAtmEntry(pAtmEntry, FALSE);	// CloseCallComplete
		}
	}

	if (IsMarsProblem)
	{
		AA_ACQUIRE_IF_LOCK(pInterface);
		rc = AtmArpDereferenceInterface(pInterface);
		if (rc != 0)
		{
			AA_RELEASE_IF_LOCK(pInterface);
			AtmArpMcHandleMARSFailure(pInterface, FALSE);
		}
		//
		//  else the interface is gone.
		//
	}
#endif
	return;
}



#ifdef IPMCAST


VOID
AtmArpAddPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClAddParty. Since we don't use point-to-multipoint connections,
	this should never get called.

	If the AddParty was successful, we just update state and exit. If it
	failed, we check the failure code. If this indicates a transient
	failure condition, we start a timer so that we reattempt to add this
	party later. Otherwise ("hard" failure), this multicast entry is deleted.

Arguments:

	Status					- Status of the AddParty
	ProtocolPartyContext	- Pointer to an IPMC_ATM_ENTRY structure
	NdisPartyHandle			- NDIS' handle for this party
	pCallParameters			- what we had passed to NdisClAddParty

Return Value:

	None

--*/
{
	PATMARP_IPMC_ATM_ENTRY			pMcAtmEntry;
	PATMARP_ATM_ENTRY				pAtmEntry;
	PATMARP_IP_ENTRY				pIpEntry;
	PATMARP_VC						pVc;
	ULONG							VcFlags;
	PATMARP_INTERFACE				pInterface;
	ULONG							DelayBeforeRetry;
	BOOLEAN							ClearToSend;

	pMcAtmEntry = (PATMARP_IPMC_ATM_ENTRY)(ProtocolPartyContext);
	AA_STRUCT_ASSERT(pMcAtmEntry, ame);

	pAtmEntry = pMcAtmEntry->pAtmEntry;
	AA_ACQUIRE_AE_LOCK(pAtmEntry);

	pAtmEntry->pMcAtmInfo->TransientLeaves--;

	pVc = pAtmEntry->pVcList;
	VcFlags = pVc->Flags;
	pInterface = pAtmEntry->pInterface;

	AAMCDEBUGP(AAD_LOUD,
	 ("AddPartyComplete: Status 0x%x, pAtmEntry 0x%x, pMcAtmEntry 0x%x, pVc 0x%x\n",
	 	Status, pAtmEntry, pMcAtmEntry, pVc));

	AAMCDEBUGPATMADDR(AAD_EXTRA_LOUD, "AddParty Addr: ", &pMcAtmEntry->ATMAddress);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		AA_SET_FLAG(pMcAtmEntry->Flags,
					AA_IPMC_AE_CONN_STATE_MASK,
					AA_IPMC_AE_CONN_ACTIVE);

		//
		//  If we had decided to terminate this member when the
		//  AddParty was going on, then we now mark this as Invalid.
		//  When we next update this PMP connection, this member will
		//  be removed.
		//
		if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_TERMINATING))
		{
			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_GEN_STATE_MASK,
						AA_IPMC_AE_INVALID);
		}

		pMcAtmEntry->NdisPartyHandle = NdisPartyHandle;
		pAtmEntry->pMcAtmInfo->ActiveLeaves++;
	}
	else
	{
		AAMCDEBUGP(AAD_INFO,
			("AddPartyComplete: Status 0x%x, pAtmEntry 0x%x, to ", Status, pAtmEntry));
		AAMCDEBUGPATMADDR(AAD_INFO, "", &pMcAtmEntry->ATMAddress);

		//
		//  Check if the failure was due to a transient
		//  condition.
		//
		if (AA_IS_TRANSIENT_FAILURE(Status))
		{
			//
			//  We'll fire a timer, so that we reattempt to
			//  connect to this one later. If we had already
			//  done this (i.e. time out on failure), then
			//  we include a back-off time in the delay.
			//
			DelayBeforeRetry = AA_GET_TIMER_DURATION(&(pMcAtmEntry->Timer));
			if (DelayBeforeRetry == 0)
			{
				//
				//  First time we're doing this.
				//
				DelayBeforeRetry = AA_GET_RANDOM(
										pInterface->MinPartyRetryDelay,
										pInterface->MaxPartyRetryDelay);
			}
			else
			{
				DelayBeforeRetry = 2*DelayBeforeRetry;
			}

			AtmArpStartTimer(
				pInterface,
				&(pMcAtmEntry->Timer),
				AtmArpMcPartyRetryDelayTimeout,
				DelayBeforeRetry,
				(PVOID)pMcAtmEntry
				);

			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_CONN_STATE_MASK,
						AA_IPMC_AE_CONN_TEMP_FAILURE);
			
		}
		else
		{
			//
			//  Not a transient failure. Delete this member.
			//
			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_CONN_STATE_MASK,
						AA_IPMC_AE_CONN_DISCONNECTED);

			AtmArpMcUnlinkAtmMember(
					pAtmEntry,
					pMcAtmEntry
					);
		}
	}

	ClearToSend = ((pAtmEntry->pMcAtmInfo->TransientLeaves == 0) &&
				   (AA_IS_FLAG_SET(pAtmEntry->pMcAtmInfo->Flags,
					   				   AA_IPMC_AI_CONN_STATE_MASK,
					   				   AA_IPMC_AI_CONN_ACTIVE)));

	pIpEntry = pAtmEntry->pIpEntryList;


	AA_RELEASE_AE_LOCK(pAtmEntry);
			
	if (pCallParameters != (PCO_CALL_PARAMETERS)NULL)
	{
		AA_FREE_MEM(pCallParameters);
	}

	//
	//  Check if the VC is closing, and we had held back because
	//  this AddParty was in progress. If so, try to continue the
	//  CloseCall process.
	//
	AA_ACQUIRE_VC_LOCK(pVc);
	if (AA_IS_FLAG_SET(pVc->Flags,
						AA_VC_CLOSE_STATE_MASK,
						AA_VC_CLOSE_STATE_CLOSING))
	{
		AtmArpCloseCall(pVc);
		//
		//  VC Lock is released within the above.
		//
	}
	else
	{
		PNDIS_PACKET	pPacketList;

		AA_RELEASE_VC_LOCK(pVc);

		if (ClearToSend && pIpEntry)
		{
			AA_ACQUIRE_IE_LOCK(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			pPacketList = pIpEntry->PacketList;
			pIpEntry->PacketList = (PNDIS_PACKET)NULL;
			AA_RELEASE_IE_LOCK(pIpEntry);

			if (pPacketList != (PNDIS_PACKET)NULL)
			{
				AAMCDEBUGP(AAD_INFO, ("AddPtyCompl: pAtmEntry 0x%x, sending pktlist 0x%x\n",
					pAtmEntry, pPacketList));

				AtmArpSendPacketListOnAtmEntry(
						pInterface,
						pAtmEntry,
						pPacketList,
						TRUE	// IsBroadcast
						);
			}
		}
	}
}


#else

VOID
AtmArpAddPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClAddParty. Since we don't use point-to-multipoint connections,
	this should never get called.

Arguments:

	<Don't care>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_ERROR, ("Add Party Complete unexpectedly called\n"));
	AA_ASSERT(FALSE);
}

#endif // IPMCAST



VOID
AtmArpDropPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClDropParty. We unlink our party structure and free it.

Arguments:

	Status						- Final result of the Drop Party
	ProtocolPartyContext		- Pointer to the MC ATM Entry we used
								  to represent the party.

Return Value:

	None

--*/
{
#ifdef IPMCAST
	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
	PATMARP_ATM_ENTRY			pAtmEntry;
	PATMARP_IP_ENTRY			pIpEntry;
	ULONG						rc;
	BOOLEAN						LockReleased;

	AAMCDEBUGP(AAD_LOUD, ("DropPartyComplete: Status 0x%x, Context 0x%x\n",
				Status, ProtocolPartyContext));

	AA_ASSERT(Status == NDIS_STATUS_SUCCESS);


	pMcAtmEntry = (PATMARP_IPMC_ATM_ENTRY)ProtocolPartyContext;
	AA_STRUCT_ASSERT(pMcAtmEntry, ame);

	pAtmEntry = pMcAtmEntry->pAtmEntry;
	AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);
	AA_STRUCT_ASSERT(pAtmEntry, aae);

	AA_ACQUIRE_AE_LOCK(pAtmEntry);
	AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);	// temp ref

	AA_SET_FLAG(pMcAtmEntry->Flags,
				AA_IPMC_AE_CONN_STATE_MASK,
				AA_IPMC_AE_CONN_DISCONNECTED);

	AtmArpMcUnlinkAtmMember(pAtmEntry, pMcAtmEntry);

	//
	//  If we are in the processing of closing this PMP call,
	//  and this event signifies that all preliminary DropParty's
	//  are complete, then close the call itself.
	//
	LockReleased = FALSE;
	rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);	// temp ref

	if (rc != 0)
	{
		PATMARP_VC		pVc;

		pVc = pAtmEntry->pVcList;
		if (pVc != NULL_PATMARP_VC)
		{
			if (AA_IS_FLAG_SET(pVc->Flags,
							AA_VC_CLOSE_STATE_MASK,
							AA_VC_CLOSE_STATE_CLOSING) &&
				(pAtmEntry->pMcAtmInfo->NumOfEntries == 1))
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
				AA_ACQUIRE_VC_LOCK(pVc);

				AtmArpCloseCall(pVc);
				//
				//  VC lock is released within the above.
				//
				LockReleased = TRUE;
			}
		}
	}
				

	if (!LockReleased)
	{
		AA_RELEASE_AE_LOCK(pAtmEntry);
	}

#endif // IPMCAST
}



VOID
AtmArpModifyQosCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClModifyCallQoS. Since we don't call this, this should never
	get called.

Arguments:

	<Don't care>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_ERROR, ("Modify QOS Complete unexpectedly called\n"));
	AA_ASSERT(FALSE);
}


#ifndef OID_CO_AF_CLOSE
#define OID_CO_AF_CLOSE				0xFE00000A
#endif


NDIS_STATUS
AtmArpCoRequestHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST			pNdisRequest
)
/*++

Routine Description:

	This routine is called by NDIS when our Call Manager sends us an
	NDIS Request. NDIS Requests that are of significance to us are:
	- OID_CO_ADDRESS_CHANGE
		The set of addresses registered with the switch has changed,
		i.e. address registration is complete. We issue an NDIS Request
		ourselves to get the list of addresses registered.
	- OID_CO_SIGNALING_ENABLED
		We ignore this as of now.
	- OID_CO_SIGNALING_DISABLED
		We ignore this for now.
	- OID_CO_AF_CLOSE
		The Call Manager wants us to shut down this Interface.

	We ignore all other OIDs.

Arguments:

	ProtocolAfContext			- Our context for the Address Family binding,
								  which is a pointer to the ATMARP Interface.
	ProtocolVcContext			- Our context for a VC, which is a pointer to
								  an ATMARP VC structure.
	ProtocolPartyContext		- Our context for a Party. Since we don't do
								  PMP, this is ignored (must be NULL).
	pNdisRequest				- Pointer to the NDIS Request.

Return Value:

	NDIS_STATUS_SUCCESS if we recognized the OID
	NDIS_STATUS_NOT_RECOGNIZED if we didn't.

--*/
{
	PATMARP_INTERFACE			pInterface;
	NDIS_STATUS					Status;

	pInterface = (PATMARP_INTERFACE)ProtocolAfContext;
	AA_STRUCT_ASSERT(pInterface, aai);

	//
	//  Initialize
	//
	Status = NDIS_STATUS_NOT_RECOGNIZED;

	if (pNdisRequest->RequestType == NdisRequestSetInformation)
	{
		switch (pNdisRequest->DATA.SET_INFORMATION.Oid)
		{
			case OID_CO_ADDRESS_CHANGE:
				//
				//  The Call Manager says that the list of addresses
				//  registered on this interface has changed. Get the
				//  (potentially) new ATM address for this interface.
				//
				AA_ACQUIRE_IF_LOCK(pInterface);
				pInterface->AtmInterfaceUp = FALSE;
				AA_RELEASE_IF_LOCK(pInterface);

				AtmArpGetAtmAddress(pInterface);
				Status = NDIS_STATUS_SUCCESS;
				break;
			
			case OID_CO_SIGNALING_ENABLED:	// FALLTHRU
			case OID_CO_SIGNALING_DISABLED:
				// Ignored for now
				Status = NDIS_STATUS_SUCCESS;
				break;

			case OID_CO_AF_CLOSE:
				AA_ACQUIRE_IF_LOCK(pInterface);
				pInterface->AdminState = pInterface->State = IF_STATUS_DOWN;
				pInterface->LastChangeTime = GetTimeTicks();
				AA_RELEASE_IF_LOCK(pInterface);
				AtmArpShutdownInterface(pInterface);
				Status = NDIS_STATUS_SUCCESS;
				break;

			default:
				break;
		}
	}

	return (Status);
}



VOID
AtmArpCoRequestCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST				pNdisRequest
)
/*++

Routine Description:

	This routine is called by NDIS when a previous call to NdisCoRequest
	that had pended, is complete. We handle this based on the request
	we had sent, which has to be one of:
	- OID_CO_GET_ADDRESSES
		Get all addresses registered on the specified AF binding.

Arguments:

	Status						- Status of the Request.
	ProtocolAfContext			- Our context for the Address Family binding,
								  which is a pointer to the ATMARP Interface.
	ProtocolVcContext			- Our context for a VC, which is a pointer to
								  an ATMARP VC structure.
	ProtocolPartyContext		- Our context for a Party. Since we don't do
								  PMP, this is ignored (must be NULL).
	pNdisRequest				- Pointer to the NDIS Request.


Return Value:

	None

--*/
{
	PATMARP_INTERFACE			pInterface;
	ULONG						Oid;

	pInterface = (PATMARP_INTERFACE)ProtocolAfContext;
	AA_STRUCT_ASSERT(pInterface, aai);

	if (pNdisRequest->RequestType == NdisRequestQueryInformation)
	{
		switch (pNdisRequest->DATA.QUERY_INFORMATION.Oid)
		{
			case OID_CO_GET_ADDRESSES:
				AtmArpHandleGetAddressesComplete(
							Status,
							pInterface,
							pNdisRequest
							);
				break;

			default:
				AADEBUGP(AAD_ERROR,
					 ("CoRequestComplete: pNdisReq 0x%x, unknown Query Oid 0x%x\n",
					 		pNdisRequest,
					 		pNdisRequest->DATA.QUERY_INFORMATION.Oid));
				AA_ASSERT(FALSE);
				break;
		}
	}
	else
	{
		Oid = pNdisRequest->DATA.QUERY_INFORMATION.Oid;
		switch (Oid)
		{
			case OID_CO_ADD_ADDRESS:	// FALLTHRU
			case OID_CO_DELETE_ADDRESS:
				AtmArpHandleModAddressComplete(
							Status,
							pInterface,
							pNdisRequest,
							Oid
							);
				break;

			default:
				AADEBUGP(AAD_ERROR,
					 ("CoRequestComplete: pNdisReq 0x%x, unknown Set Oid 0x%x\n",
					 		pNdisRequest, Oid));
				AA_ASSERT(FALSE);
				break;
		}
	}

	AA_FREE_MEM(pNdisRequest);
}



VOID
AtmArpGetAtmAddress(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Send a request to the Call Manager to retrieve the ATM address
	registered with the switch on the given interface.

	This is called when the Call Manager tells us that there has been
	a change in its list of addresses registered with the switch.
	Normally, this happens when we start up our signalling stack (i.e.
	initial address registration), but it might happen during runtime,
	for example, if the link goes down and up, or we get physically
	connected to a different switch...

	In any case, we issue an NDIS Request to the Call Manager to retrieve
	the first address it has registered. Action then continues in
	AtmArpHandleGetAddressesComplete.

Arguments:

	pInterface				- Interface structure for which this event occurred.

Return Value:

	None

--*/
{
	PNDIS_REQUEST				pNdisRequest;
	NDIS_HANDLE					NdisAfHandle;
	NDIS_HANDLE					NdisAdapterHandle;
	NDIS_STATUS					Status;

	PCO_ADDRESS_LIST			pAddressList;
	ULONG						RequestSize;

	AADEBUGP(AAD_INFO, ("GetAtmAddress: pIf 0x%x\n", pInterface));

	AA_ACQUIRE_IF_LOCK(pInterface);

	NdisAfHandle = pInterface->NdisAfHandle;
	NdisAdapterHandle = pInterface->NdisAdapterHandle;

	AA_RELEASE_IF_LOCK(pInterface);

	RequestSize = sizeof(CO_ADDRESS_LIST) + sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS);

	//
	//  Allocate all that we need.
	//
	AA_ALLOC_MEM(pNdisRequest, NDIS_REQUEST, sizeof(NDIS_REQUEST)+RequestSize);
	if (pNdisRequest != (PNDIS_REQUEST)NULL)
	{
		pAddressList = (PCO_ADDRESS_LIST)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));

		AA_SET_MEM(pAddressList, 0, sizeof(CO_ADDRESS_LIST));

		Status = AtmArpSendNdisCoRequest(
						NdisAdapterHandle,
						NdisAfHandle,
						pNdisRequest,
						NdisRequestQueryInformation,
						OID_CO_GET_ADDRESSES,
						(PVOID)pAddressList,
						RequestSize
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			AtmArpCoRequestCompleteHandler(
						Status,
						(NDIS_HANDLE)pInterface,	// ProtocolAfContext
						NULL,			// Vc Context
						NULL,			// Party Context
						pNdisRequest
						);
		}
	}

}


VOID
AtmArpHandleGetAddressesComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_REQUEST				pNdisRequest
)
/*++

Routine Description:

	This is called when we have a reply to our previous call to
	NdisCoRequest(OID_CO_GET_ADDRESSES). Check if we got any addresses
	back: if we did, store the address as our Local ATM Address, and
	if conditions are ripe, start registering ourselves with the ARP
	server.

	Since we allocated the NDIS request, free it here.

Arguments:

	Status					- result of the request
	pInterface				- ATMARP interface on which the request was issued
	pNdisRequest			- the request itself. This will also contain the
							  returned address.

Return Value:

	None

--*/
{
	PCO_ADDRESS_LIST		pAddressList;
	ATM_ADDRESS UNALIGNED *	pAtmAddress;

	AADEBUGP(AAD_LOUD, ("GetAddr complete: pIf 0x%x, Status 0x%x\n",
				pInterface, Status));

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pAddressList = (PCO_ADDRESS_LIST)
						pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;

		AADEBUGP(AAD_LOUD, ("GetAddr complete: pIf 0x%x, Count %d\n",
					pInterface, pAddressList->NumberOfAddresses));

		if (pAddressList->NumberOfAddresses > 0)
		{
			//
			//  We have atleast one address here. Copy it in.
			//
			AA_ACQUIRE_IF_LOCK(pInterface);

			pAtmAddress = (ATM_ADDRESS UNALIGNED *)(pAddressList->AddressList.Address);
			AA_COPY_MEM((PUCHAR)&(pInterface->LocalAtmAddress),
						(PUCHAR)pAtmAddress,
						sizeof(ATM_ADDRESS));

			//
			//  Patch the selector byte with whatever is configured for
			//  this LIS.
			//
			pInterface->LocalAtmAddress.Address[ATM_ADDRESS_LENGTH-1] = 
							(UCHAR)(pInterface->SapSelector);

			pInterface->AtmInterfaceUp = TRUE;

			//
			//  To force registration:
			//
			AA_SET_FLAG(
				pInterface->Flags,
				AA_IF_SERVER_STATE_MASK,
				AA_IF_SERVER_NO_CONTACT);

			AtmArpStartRegistration(pInterface);
			//
			//  The IF lock is released within the above.
			//

#ifdef IPMCAST
			//
			//  Attempt to start our Multicast side, too.
			//
			AA_ACQUIRE_IF_LOCK(pInterface);
			AtmArpMcStartRegistration(pInterface);
			//
			//  IF Lock is released within the above.
			//
#endif // IPMCAST

			//
			//  Add any (additional) addresses we want to register with
			//  the switch now.
			//
			AtmArpUpdateAddresses(
						pInterface,
						TRUE			// Add them
						);
		}
		//
		//  else no address is registered currently.
		//
	}
	//
	//  else our request failed! Wait for another ADDRESS_CHANGE.
	//

	return;

}



VOID
AtmArpUpdateAddresses(
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN						AddThem
)
/*++

Routine Description:

	Update the list of addresses we want the Call manager to register
	with the switch: either add addresses or delete them. We do this
	only if we are running in an SVC environment.

Arguments:

	pInterface				- Pointer to ATMARP Interface
	AddThem					- TRUE if caller wants us to add addresses,
							  FALSE if caller wats us to delete them.
Return Value:

	None

--*/
{
	PATMARP_SAP			pAtmArpSap;
	PATMARP_SAP			pNextSap;
	PATM_SAP			pAtmSap;
	PATM_ADDRESS		pAtmAddress;
	PCO_ADDRESS			pCoAddress;
	PNDIS_REQUEST		pNdisRequest;
	NDIS_HANDLE			NdisAfHandle;
	NDIS_HANDLE			NdisAdapterHandle;
	NDIS_OID			Oid;
	ULONG				BufferLength;
	NDIS_STATUS			Status;
	BOOLEAN				StateIsOkay;	// Does the current state allow this request
	ULONG				rc;				// Ref count

	StateIsOkay = TRUE;

	BufferLength = sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS);

	AA_ACQUIRE_IF_LOCK(pInterface);
	NdisAfHandle = pInterface->NdisAfHandle;
	NdisAdapterHandle = pInterface->NdisAdapterHandle;

	if (AddThem)
	{
		Oid = OID_CO_ADD_ADDRESS;
		//
		//  This is allowed only if the AdminState for the interface
		//  is UP.
		//
		if (pInterface->AdminState != IF_STATUS_UP)
		{
			StateIsOkay = FALSE;
		}
	}
	else
	{
		Oid = OID_CO_DELETE_ADDRESS;
	}

	//
	//  Check all pre-conditions before progressing.
	//
	if (!(pInterface->PVCOnly) &&
		 (StateIsOkay) &&
		 (pInterface->AtmInterfaceUp) &&
		 (pInterface->NumberOfSaps > 1))
	{
		AA_ASSERT(pInterface->SapList.pNextSap != NULL_PATMARP_SAP);

		//
		//  Reference the Interface so that it doesn't go away.
		//
		AtmArpReferenceInterface(pInterface);
		pAtmArpSap = pInterface->SapList.pNextSap;

		AA_RELEASE_IF_LOCK(pInterface);

		do
		{
			if (AA_IS_FLAG_SET(
					pAtmArpSap->Flags,
					AA_SAP_ADDRTYPE_MASK,
					AA_SAP_ADDRTYPE_NEED_ADD))
			{
				//
				//  This SAP is of the type that needs to be added/deleted
				//  via ILMI
				//
				AA_ALLOC_MEM(
						pNdisRequest,
						NDIS_REQUEST,
						sizeof(NDIS_REQUEST)+
							sizeof(CO_ADDRESS)+
							sizeof(ATM_ADDRESS)
					);
		
				if (pNdisRequest != (PNDIS_REQUEST)NULL)
				{
					AA_SET_MEM(pNdisRequest, 0, sizeof(NDIS_REQUEST));
					//
					//  Stuff in our context for this request, which is a pointer
					//  to this ATMARP SAP, into the ProtocolReserved part of
					//  this request, so that we can handle completion easily.
					//
					*((PVOID *)(pNdisRequest->ProtocolReserved)) = (PVOID)pAtmArpSap;
	
					pCoAddress = (PCO_ADDRESS)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));
					pCoAddress->AddressSize = sizeof(ATM_ADDRESS);
					BufferLength = sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS);
	
					//
					//  Save a pointer to the next SAP
					//
					pNextSap = pAtmArpSap->pNextSap;
	
					//
					//  Get at the ATM address in this SAP.
					//
					pAtmSap = (PATM_SAP)(pAtmArpSap->pInfo->Sap);
					AA_ASSERT(pAtmSap->NumberOfAddresses > 0);
					pAtmAddress = (PATM_ADDRESS)(pAtmSap->Addresses);
	
					AA_COPY_MEM(pCoAddress->Address, pAtmAddress, sizeof(ATM_ADDRESS));
					Status = AtmArpSendNdisCoRequest(
									NdisAdapterHandle,
									NdisAfHandle,
									pNdisRequest,
									NdisRequestSetInformation,
									Oid,
									(PVOID)pCoAddress,
									BufferLength
									);
	
					//
					//  Go to the next SAP in the list.
					//
					pAtmArpSap = pNextSap;
				}
				else
				{
					//
					// Out of resources.
					//
					break;
				}
			}
		}
		while (pAtmArpSap != NULL_PATMARP_SAP);

		//
		//  Remove the reference we added earlier on.
		//
		AA_ACQUIRE_IF_LOCK(pInterface);
		rc = AtmArpDereferenceInterface(pInterface);
		if (rc > 0)
		{
			AA_RELEASE_IF_LOCK(pInterface);
		}
		//
		//  else the Interface is gone!
	}
	else
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}

}


VOID
AtmArpHandleModAddressComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	ULONG						Oid
)
/*++

Routine Description:

	This is called when we have a reply to our previous call to
	NdisCoRequest(OID_CO_ADD_ADDRESS or OID_CO_DELETE_ADDRESS).
	All we do now is to update the state on the ATMARP SAP.

Arguments:

	Status			- the result of our request.
	pInterface		- ATMARP interface pointer.
	pNdisRequest	- the request we had sent.
	Oid				- CO_OID_ADD_ADDRESS or CO_OID_DELETE_ADDRESS

Return Value:

	None

--*/
{
	PATMARP_SAP				pAtmArpSap;

	pAtmArpSap = (PATMARP_SAP)(*((PVOID *)(pNdisRequest->ProtocolReserved)));
	AA_STRUCT_ASSERT(pAtmArpSap, aas);

	AA_ACQUIRE_IF_LOCK(pInterface);

	//
	//  Update the state on this ATMARP SAP.
	//
	if ((Oid == OID_CO_ADD_ADDRESS) && (Status == NDIS_STATUS_SUCCESS))
	{
		AA_SET_FLAG(pAtmArpSap->Flags,
					AA_SAP_ILMI_STATE_MASK,
					AA_SAP_ILMI_STATE_ADDED);
	}
	else
	{
		AA_SET_FLAG(pAtmArpSap->Flags,
					AA_SAP_ILMI_STATE_MASK,
					AA_SAP_ILMI_STATE_IDLE);
	}

	AA_RELEASE_IF_LOCK(pInterface);
}




NDIS_STATUS
AtmArpSendNdisCoRequest(
	IN	NDIS_HANDLE					NdisAdapterHandle,
	IN	NDIS_HANDLE					NdisAfHandle,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
)
/*++

Routine Description:

	Send an NDIS Connection Oriented request to the Call Manager. We
	allocate an NDIS_REQUEST structure, link the supplied buffer to it,
	and send the request. If the request does not pend, we call our
	completion routine from here.

Arguments:

	NdisAdapterHandle		- Binding Handle to be used in the request
	NdisAfHandle			- AF Handle value to be used in the request
	pNdisRequest			- Pointer to NDIS request structure
	RequestType				- Set/Query information
	Oid						- OID to be passed in the request
	pBuffer					- place for value(s)
	BufferLength			- length of above

Return Value:

	Status of the NdisCoRequest.

--*/
{
	NDIS_STATUS			Status;

	//
	//  Fill in the NDIS Request structure
	//
	pNdisRequest->RequestType = RequestType;
	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = 0;
	}

	Status = NdisCoRequest(
				NdisAdapterHandle,
				NdisAfHandle,
				NULL,			// No VC handle
				NULL,			// No Party Handle
				pNdisRequest);
		
	return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\debug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains all debug-related code.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm		06-13-96	Created

Notes:

--*/


#include <precomp.h>
#include "ntddk.h"
#include <cxport.h>
#include "ndis.h"


#include "debug.h"

#if DBG

#ifdef ATMARP_WIN98
INT	AaDebugLevel=AAD_WARNING;
INT	AaMcDebugLevel=AAD_WARNING;
#else
INT	AaDebugLevel=AAD_WARNING;
INT	AaMcDebugLevel=AAD_WARNING;
#endif
INT	AaDataDebugLevel=0;
INT	AadBigDataLength=8000;
INT	AaSkipAll = 0;

PAAD_ALLOCATION	AadMemoryHead = (PAAD_ALLOCATION)NULL;
PAAD_ALLOCATION	AadMemoryTail = (PAAD_ALLOCATION)NULL;
ULONG				AadAllocCount = 0;	// how many allocated so far (unfreed)

NDIS_SPIN_LOCK		AadMemoryLock;
BOOLEAN				AadInitDone = FALSE;


PVOID
AaAuditAllocMem(
	PVOID	pPointer,
	ULONG	Size,
	ULONG	FileNumber,
	ULONG	LineNumber
)
{
	PVOID				pBuffer;
	PAAD_ALLOCATION	pAllocInfo;

	if (!AadInitDone)
	{
		NdisAllocateSpinLock(&(AadMemoryLock));
		AadInitDone = TRUE;
	}

	NdisAllocateMemoryWithTag(
		(PVOID *)&pAllocInfo,
		Size+FIELD_OFFSET(AAD_ALLOCATION, UserData),
		(ULONG)'CPRA'
	);

	if (pAllocInfo == (PAAD_ALLOCATION)NULL)
	{
		AADEBUGP(AAD_VERY_LOUD+50,
			("AaAuditAllocMem: file %d, line %d, Size %d failed!\n",
				FileNumber, LineNumber, Size));
		pBuffer = NULL;
	}
	else
	{
		pBuffer = (PVOID)&(pAllocInfo->UserData);
		AA_SET_MEM(pBuffer, 0xaf, Size);
		pAllocInfo->Signature = AAD_MEMORY_SIGNATURE;
		pAllocInfo->FileNumber = FileNumber;
		pAllocInfo->LineNumber = LineNumber;
		pAllocInfo->Size = Size;
		pAllocInfo->Location = pPointer;
		pAllocInfo->Next = (PAAD_ALLOCATION)NULL;

		NdisAcquireSpinLock(&(AadMemoryLock));

		pAllocInfo->Prev = AadMemoryTail;
		if (AadMemoryTail == (PAAD_ALLOCATION)NULL)
		{
			// empty list
			AadMemoryHead = AadMemoryTail = pAllocInfo;
		}
		else
		{
			AadMemoryTail->Next = pAllocInfo;
		}
		AadMemoryTail = pAllocInfo;
		
		AadAllocCount++;
		NdisReleaseSpinLock(&(AadMemoryLock));
	}

	AADEBUGP(AAD_VERY_LOUD+100,
	 ("AaAuditAllocMem: file %c%c%c%c, line %d, %d bytes, [0x%x] <- 0x%x\n",
	 			(CHAR)(FileNumber & 0xff),
	 			(CHAR)((FileNumber >> 8) & 0xff),
	 			(CHAR)((FileNumber >> 16) & 0xff),
	 			(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber, Size, pPointer, pBuffer));

	return (pBuffer);

}


VOID
AaAuditFreeMem(
	PVOID	Pointer
)
{
	PAAD_ALLOCATION	pAllocInfo;

	pAllocInfo = STRUCT_OF(AAD_ALLOCATION, Pointer, UserData);

	if (pAllocInfo->Signature != AAD_MEMORY_SIGNATURE)
	{
		AADEBUGP(AAD_ERROR,
		 ("AaAuditFreeMem: unknown buffer 0x%x!\n", Pointer));
#ifdef DBG
		DbgBreakPoint();
#endif
		return;
	}

	NdisAcquireSpinLock(&(AadMemoryLock));
	pAllocInfo->Signature = (ULONG)'DEAD';
	if (pAllocInfo->Prev != (PAAD_ALLOCATION)NULL)
	{
		pAllocInfo->Prev->Next = pAllocInfo->Next;
	}
	else
	{
		AadMemoryHead = pAllocInfo->Next;
	}
	if (pAllocInfo->Next != (PAAD_ALLOCATION)NULL)
	{
		pAllocInfo->Next->Prev = pAllocInfo->Prev;
	}
	else
	{
		AadMemoryTail = pAllocInfo->Prev;
	}
	AadAllocCount--;
	NdisReleaseSpinLock(&(AadMemoryLock));

	NdisFreeMemory(pAllocInfo, 0, 0);
}


VOID
AaAuditShutdown(
	VOID
)
{
	if (AadInitDone)
	{
		if (AadAllocCount != 0)
		{
			AADEBUGP(AAD_ERROR, ("AuditShutdown: unfreed memory, %d blocks!\n",
					AadAllocCount));
			AADEBUGP(AAD_ERROR, ("MemoryHead: 0x%x, MemoryTail: 0x%x\n",
					AadMemoryHead, AadMemoryTail));
			DbgBreakPoint();
			{
				PAAD_ALLOCATION		pAllocInfo;

				while (AadMemoryHead != (PAAD_ALLOCATION)NULL)
				{
					pAllocInfo = AadMemoryHead;
					AADEBUGP(AAD_INFO, ("AuditShutdown: will free 0x%x\n", pAllocInfo));
					AaAuditFreeMem(&(pAllocInfo->UserData));
				}
			}
		}
		AadInitDone = FALSE;
	}
}

#define MAX_HD_LENGTH		128

VOID
DbgPrintHexDump(
	IN	PUCHAR			pBuffer,
	IN	ULONG			Length
)
/*++

Routine Description:

	Print a hex dump of the given contiguous buffer. If the length
	is too long, we truncate it.

Arguments:

	pBuffer			- Points to start of data to be dumped
	Length			- Length of above.

Return Value:

	None

--*/
{
	ULONG		i;

	if (Length > MAX_HD_LENGTH)
	{
		Length = MAX_HD_LENGTH;
	}

	for (i = 0; i < Length; i++)
	{
		//
		//  Check if we are at the end of a line
		//
		if ((i > 0) && ((i & 0xf) == 0))
		{
			DbgPrint("\n");
		}

		//
		//  Print addr if we are at start of a new line
		//
		if ((i & 0xf) == 0)
		{
			DbgPrint("%08x ", pBuffer);
		}

		DbgPrint(" %02x", *pBuffer++);
	}

	//
	//  Terminate the last line.
	//
	if (Length > 0)
	{
		DbgPrint("\n");
	}
}


VOID
DbgPrintAtmAddr(
	IN	PCHAR					pString,
	IN	ATM_ADDRESS UNALIGNED *	pAddr
)
{
	ULONG			i;
	ULONG			NumOfDigits;
	PUCHAR			pSrc, pDst;
	UCHAR			AddrString[(ATM_ADDRESS_LENGTH*2) + 1];

	//
	// Prepare the Address string in ASCII
	//
	if ((NumOfDigits = pAddr->NumberOfDigits) > ATM_ADDRESS_LENGTH)
	{
		NumOfDigits = ATM_ADDRESS_LENGTH;
	}

	pSrc = pAddr->Address;
	pDst = AddrString;
	for (i = 0; i < NumOfDigits; i++, pSrc++)
	{
		*pDst = ((*pSrc) >> 4);
		*pDst += (((*pDst) > 9) ? ('A' - 10) : '0');
		pDst++;
		*pDst = ((*pSrc) & 0x0F);
		*pDst += (((*pDst) > 9) ? ('A' - 10) : '0');
		pDst++;
	}

	*pDst = '\0';

	DbgPrint("%s%s\n", pString, AddrString);
}



VOID
DbgPrintMapping(
	IN	PCHAR					pString,
	IN	UCHAR UNALIGNED *		pIpAddr,
	IN	ATM_ADDRESS UNALIGNED *	pAtmAddr
)
{
	DbgPrint("ATMARPC: %s %d.%d.%d.%d -> ",
				pString,
				((PUCHAR)pIpAddr)[0],
				((PUCHAR)pIpAddr)[1],
				((PUCHAR)pIpAddr)[2],
				((PUCHAR)pIpAddr)[3]
			);

	DbgPrintAtmAddr("", pAtmAddr);
}


ULONG	OutstandingSends = 0;


VOID
AaCoSendPackets(
	IN	NDIS_HANDLE				NdisVcHandle,
	IN	PNDIS_PACKET *			PacketArray,
	IN	UINT					PacketCount
)
{
	PNDIS_PACKET		pNdisPacket;
	UINT				c;
	NDIS_STATUS			Status;
	PNDIS_BUFFER		pNdisBuffer;
	PULONG				pContext;

	for (c = 0; c < PacketCount; c++)
	{
		pNdisPacket = PacketArray[c];

		AA_ASSERT(pNdisPacket->Private.Head != NULL);

		Status = NDIS_GET_PACKET_STATUS(pNdisPacket);
		AA_ASSERT(Status != NDIS_STATUS_FAILURE);

		pContext = (PULONG)&(pNdisPacket->WrapperReserved[0]);
		*pContext = 'AaAa';
	}

	NdisInterlockedIncrement(&OutstandingSends);
	NdisCoSendPackets(NdisVcHandle, PacketArray, PacketCount);
}

#endif // DBG


#if DBG_SPIN_LOCK
ULONG	AadSpinLockInitDone = 0;
NDIS_SPIN_LOCK	AadLockLock;

VOID
AtmArpAllocateSpinLock(
	IN	PATMARP_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	if (AadSpinLockInitDone == 0)
	{
		AadSpinLockInitDone = 1;
		NdisAllocateSpinLock(&(AadLockLock));
	}

	NdisAcquireSpinLock(&(AadLockLock));
	pLock->Signature = AAL_SIG;
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired = 0;
	pLock->OwnerThread = 0;
	NdisAllocateSpinLock(&(pLock->NdisLock));
	NdisReleaseSpinLock(&(AadLockLock));
}


VOID
AtmArpAcquireSpinLock(
	IN	PATMARP_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	PKTHREAD		pThread;

	pThread = KeGetCurrentThread();
	NdisAcquireSpinLock(&(AadLockLock));
	if (pLock->Signature != AAL_SIG)
	{
		DbgPrint("Trying to acquire uninited lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired != 0)
	{
		if (pLock->OwnerThread == pThread)
		{
			DbgPrint("Detected multiple locking!: pLock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
			DbgPrint("pLock 0x%x already acquired in File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(pLock->TouchedByFileNumber & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 8) & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 16) & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 24) & 0xff),
				pLock->TouchedInLineNumber);
			DbgBreakPoint();
		}
	}

	pLock->IsAcquired++;

	NdisReleaseSpinLock(&(AadLockLock));
	NdisAcquireSpinLock(&(pLock->NdisLock));

	//
	//  Mark this lock.
	//
	pLock->OwnerThread = pThread;
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
}


VOID
AtmArpReleaseSpinLock(
	IN	PATMARP_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	NdisDprAcquireSpinLock(&(AadLockLock));
	if (pLock->Signature != AAL_SIG)
	{
		DbgPrint("Trying to release uninited lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired == 0)
	{
		DbgPrint("Detected release of unacquired lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired--;
	pLock->OwnerThread = 0;
	NdisDprReleaseSpinLock(&(AadLockLock));

	NdisReleaseSpinLock(&(pLock->NdisLock));
}
#endif // DBG_SPIN_LOCK


#ifdef PERF


#define MAX_SEND_LOG_ENTRIES		100

LARGE_INTEGER		TimeFrequency;
BOOLEAN				SendLogInitDone = FALSE;
BOOLEAN				SendLogUpdate = TRUE;
NDIS_SPIN_LOCK		SendLogLock;

AAD_SEND_LOG_ENTRY	SendLog[MAX_SEND_LOG_ENTRIES];
ULONG				SendLogIndex = 0;
PAAD_SEND_LOG_ENTRY	pSendLog = SendLog;

ULONG				MaxSendTime;

#define TIME_TO_ULONG(_pTime)	 *((PULONG)_pTime)

VOID
AadLogSendStart(
	IN	PNDIS_PACKET	pNdisPacket,
	IN	ULONG			Destination,
	IN	PVOID			pRCE
)
{
	ULONG		Length;

	if (SendLogInitDone == FALSE)
	{
		SendLogInitDone = TRUE;
		(VOID)KeQueryPerformanceCounter(&TimeFrequency);
		MaxSendTime = (TIME_TO_ULONG(&TimeFrequency) * 2)/3;
		NdisAllocateSpinLock(&SendLogLock);
	}

	NdisQueryPacket(
			pNdisPacket,
			NULL,
			NULL,
			NULL,
			&Length
			);

	NdisAcquireSpinLock(&SendLogLock);
	pSendLog->Flags = AAD_SEND_FLAG_WAITING_COMPLETION;
	if (pRCE != NULL)
	{
		pSendLog->Flags |= AAD_SEND_FLAG_RCE_GIVEN;
	}
	pSendLog->pNdisPacket = pNdisPacket;
	pSendLog->Destination = Destination;
	pSendLog->Length = Length;
	pSendLog->SendTime = KeQueryPerformanceCounter(&TimeFrequency);

	pSendLog++;
	SendLogIndex++;
	if (SendLogIndex == MAX_SEND_LOG_ENTRIES)
	{
		SendLogIndex = 0;
		pSendLog = SendLog;
	}

	NdisReleaseSpinLock(&SendLogLock);
}



VOID
AadLogSendUpdate(
	IN	PNDIS_PACKET	pNdisPacket
)
{
	PAAD_SEND_LOG_ENTRY	pEntry;
	ULONG				Index;
	ULONG				SendTime;

	if (!SendLogUpdate)
	{
		return;
	}

	NdisAcquireSpinLock(&SendLogLock);

	pEntry = SendLog;
	for (Index = 0; Index < MAX_SEND_LOG_ENTRIES; Index++)
	{
		if (((pEntry->Flags & AAD_SEND_FLAG_WAITING_COMPLETION) != 0) &&
			(pEntry->pNdisPacket == pNdisPacket))
		{
			pEntry->SendTime = KeQueryPerformanceCounter(&TimeFrequency);
			break;
		}
		pEntry++;
	}

	NdisReleaseSpinLock(&SendLogLock);
}



VOID
AadLogSendComplete(
	IN	PNDIS_PACKET	pNdisPacket
)
{
	PAAD_SEND_LOG_ENTRY	pEntry;
	ULONG				Index;
	ULONG				SendTime;

	NdisAcquireSpinLock(&SendLogLock);

	pEntry = SendLog;
	for (Index = 0; Index < MAX_SEND_LOG_ENTRIES; Index++)
	{
		if (((pEntry->Flags & AAD_SEND_FLAG_WAITING_COMPLETION) != 0) &&
			(pEntry->pNdisPacket == pNdisPacket))
		{
			pEntry->Flags &= ~AAD_SEND_FLAG_WAITING_COMPLETION;
			pEntry->Flags |= AAD_SEND_FLAG_COMPLETED;
			pEntry->SendCompleteTime = KeQueryPerformanceCounter(&TimeFrequency);

			if (((pEntry->Flags & AAD_SEND_FLAG_RCE_GIVEN) != 0) &&
				((SendTime = TIME_TO_ULONG(&pEntry->SendCompleteTime) -
							TIME_TO_ULONG(&pEntry->SendTime)) > MaxSendTime))
			{
				DbgPrint("Dest %d.%d.%d.%d, Pkt 0x%x, Len %d, Flags 0x%x, Took Long %d (0x%x)\n",
						((PUCHAR)&pEntry->Destination)[0],
						((PUCHAR)&pEntry->Destination)[1],
						((PUCHAR)&pEntry->Destination)[2],
						((PUCHAR)&pEntry->Destination)[3],
						pNdisPacket, pEntry->Length, pEntry->Flags, SendTime, SendTime);
			}
			break;
		}
		pEntry++;
	}

	NdisReleaseSpinLock(&SendLogLock);
}


VOID
AadLogSendAbort(
	IN	PNDIS_PACKET		pNdisPacket
)
{
	PAAD_SEND_LOG_ENTRY	pEntry;
	ULONG				Index;
	ULONG				SendTime;


	NdisAcquireSpinLock(&SendLogLock);

	pEntry = SendLog;
	for (Index = 0; Index < MAX_SEND_LOG_ENTRIES; Index++)
	{
		if (((pEntry->Flags & AAD_SEND_FLAG_WAITING_COMPLETION) != 0) &&
			(pEntry->pNdisPacket == pNdisPacket))
		{
			pEntry->Flags = 0;
			break;
		}
		pEntry++;
	}

	NdisReleaseSpinLock(&SendLogLock);
}

#endif // PERF


#if DBG

extern
VOID
AtmArpReferenceAtmEntryEx(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	AE_REFTYPE 						RefType
)
{
	AA_ASSERT(RefType>=0 && RefType < AE_REFTYPE_COUNT);
	pAtmEntry->Refs[RefType]++;
	// AA_ASSERT(pAtmEntry->Refs[RefType] < 128);
	AtmArpReferenceAtmEntry(pAtmEntry);

}

extern
ULONG
AtmArpDereferenceAtmEntryEx(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	AE_REFTYPE 					RefType,
	IN	BOOLEAN						fOkToDelete
)
{
	AA_ASSERT(RefType>=0 && RefType < AE_REFTYPE_COUNT);
	// AA_ASSERT(pAtmEntry->Refs[RefType]);
	pAtmEntry->Refs[RefType]--;

	if (fOkToDelete)
	{
		return AtmArpDereferenceAtmEntry(pAtmEntry);
	}
	else
	{
		AA_ASSERT(pAtmEntry->RefCount);
		return --(pAtmEntry->RefCount);
	}
}


extern
VOID
AtmArpReferenceIPEntryEx(
	IN PATMARP_IP_ENTRY				pIpEntry,
	IN IE_REFTYPE 					RefType
)
{
	AA_ASSERT(RefType>=0 && RefType < IE_REFTYPE_COUNT);
	pIpEntry->Refs[RefType]++;
	// AA_ASSERT(pIpEntry->Refs[RefType] < 128);
	AtmArpReferenceIPEntry(pIpEntry);
}

extern
ULONG
AtmArpDereferenceIPEntryEx(
	IN	PATMARP_IP_ENTRY			pIpEntry,
	IN	IE_REFTYPE 					RefType,
	IN	BOOLEAN						fOkToDelete
)
{
	AA_ASSERT(RefType>=0 && RefType < IE_REFTYPE_COUNT);
	// AA_ASSERT(pIpEntry->Refs[RefType]);
	pIpEntry->Refs[RefType]--;
	if (fOkToDelete)
	{
		return AtmArpDereferenceIPEntry(pIpEntry);
	}
	else
	{
		AA_ASSERT(pIpEntry->RefCount);
		return --(pIpEntry->RefCount);
	}
}



VOID
AtmArpReferenceJoinEntryEx(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry,
	IN	ULONG						RefInfo
)
{
	AA_STRUCT_ASSERT(pJoinEntry, aamj);

	pJoinEntry->LastIncrRef = RefInfo;
	AtmArpReferenceJoinEntry(pJoinEntry);
}


ULONG
AtmArpDereferenceJoinEntryEx(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry,
	IN	ULONG						RefInfo
)
{
	AA_STRUCT_ASSERT(pJoinEntry, aamj);

	pJoinEntry->LastDecrRef = RefInfo;
	return (AtmArpDereferenceJoinEntry(pJoinEntry));
}


#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\atmarp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    atmarp.h

Abstract:

	Structure definitions and function templates for the ATM ARP module.

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    arvindm     05-17-96    created

Notes:


--*/
#ifndef __ATMARP_H_INCLUDED
#define __ATMARP_H_INCLUDED

#include <ipexport.h>
#include "aaqos.h"

typedef IPAddr	IP_ADDRESS, *PIP_ADDRESS;
typedef IPMask	IP_MASK, *PIP_MASK;

#define IP_LOCAL_BCST	0xFFFFFFFF		// The local broadcast IP address
#define IP_CLASSD_MIN   0xE0			// Min class D address (NETWORK byte order)
#define IP_CLASSD_MASK  0xFFFFFF0F		// Mask representing the entire class D
										// range (NETWORK byte order).
        								//  (0xE0|0xFFFFFF0F) = 0xFFFFFFEF =
										//   239.255.255.255 in network byte order.

//
//  IP address list entry. Used to prepare a list of local IP addresses.
//
typedef struct _IP_ADDRESS_ENTRY
{
	struct _IP_ADDRESS_ENTRY *		pNext;			// Next in list
	IP_ADDRESS						IPAddress;		// The Address
	IP_MASK							IPMask;			// Mask for the above.
	BOOLEAN							IsRegistered;	// Registered with ARP Server?
	BOOLEAN							IsFirstRegistration;	// Is this the first time
															// this is being regd?

} IP_ADDRESS_ENTRY, *PIP_ADDRESS_ENTRY;


//
//  Proxy IP address list entry. Used to prepare a list of IP addresses for
//  which we act as an ARP proxy.
//
typedef struct _PROXY_ARP_ENTRY
{
	struct _PROXY_ARP_ENTRY *		pNext;			// Next in list
	IP_ADDRESS						IPAddress;		// The Address
	IP_MASK							IPMask;

} PROXY_ARP_ENTRY, *PPROXY_ARP_ENTRY;


//
//  Forward references
//
struct _ATMARP_VC ;
struct _ATMARP_IP_ENTRY ;
struct _ATMARP_ATM_ENTRY ;
#ifdef IPMCAST
struct _ATMARP_IPMC_JOIN_ENTRY ;
struct _ATMARP_IPMC_ATM_ENTRY ;
struct _ATMARP_IPMC_ATM_INFO ;
#endif // IPMCAST
struct _ATMARP_INTERFACE ;
struct _ATMARP_ADAPTER ;

#ifdef ATMARP_WMI
struct _ATMARP_IF_WMI_INFO ;
#endif


//
//  Server address list entry. Used to prepare a list of ARP/MARS servers
//  that we try to connect to.
//
typedef struct _ATMARP_SERVER_ENTRY
{
	struct _ATMARP_SERVER_ENTRY *	pNext;			// Next in list
	ATM_ADDRESS						ATMAddress;		// Address of the server
	ATM_ADDRESS						ATMSubaddress;	// Used only if ATMAddress is E.164
	struct _ATMARP_ATM_ENTRY *		pAtmEntry;		// Info about this ATM destination
	ULONG							Flags;			// State information (see below)

} ATMARP_SERVER_ENTRY, *PATMARP_SERVER_ENTRY;

#define NULL_PATMARP_SERVER_ENTRY		((PATMARP_SERVER_ENTRY)NULL)


//
//  Server list.
//
typedef struct _ATMARP_SERVER_LIST
{
	PATMARP_SERVER_ENTRY			pList;			// List of servers
	ULONG							ListSize;		// Size of above list

} ATMARP_SERVER_LIST, *PATMARP_SERVER_LIST;

#define NULL_PATMARP_SERVER_LIST		((PATMARP_SERVER_LIST)NULL)



//
//  ------------------------ Timer Management ------------------------
//

struct _ATMARP_TIMER ;
struct _ATMARP_TIMER_LIST ;

//
//  Timeout Handler prototype
//
typedef
VOID
(*ATMARP_TIMEOUT_HANDLER)(
	IN	struct _ATMARP_TIMER *		pTimer,
	IN	PVOID						Context
);

//
//  An ATMARP_TIMER structure is used to keep track of each timer
//  in the ATMARP module.
//
typedef struct _ATMARP_TIMER
{
	struct _ATMARP_TIMER *			pNextTimer;
	struct _ATMARP_TIMER *			pPrevTimer;
	struct _ATMARP_TIMER *			pNextExpiredTimer;	// Used to chain expired timers
	struct _ATMARP_TIMER_LIST *		pTimerList;			// NULL iff this timer is inactive
	ULONG							Duration;			// In seconds
	ULONG							LastRefreshTime;
	ATMARP_TIMEOUT_HANDLER			TimeoutHandler;
	PVOID							Context;			// To be passed to timeout handler
	ULONG							State;

} ATMARP_TIMER, *PATMARP_TIMER;

//
//  NULL pointer to ATMARP Timer
//
#define NULL_PATMARP_TIMER	((PATMARP_TIMER)NULL)

#define ATMARP_TIMER_STATE_IDLE		'ELDI'
#define ATMARP_TIMER_STATE_RUNNING	' NUR'
#define ATMARP_TIMER_STATE_EXPIRING	'GPXE'
#define ATMARP_TIMER_STATE_EXPIRED	'DPXE'


//
//  Control structure for a timer wheel. This contains all information
//  about the class of timers that it implements.
//
typedef struct _ATMARP_TIMER_LIST
{
#if DBG
	ULONG							atl_sig;
#endif // DBG
	PATMARP_TIMER					pTimers;		// List of timers
	ULONG							TimerListSize;	// Length of above
	ULONG							CurrentTick;	// Index into above
	ULONG							TimerCount;		// Number of running timers
	ULONG							MaxTimer;		// Max timeout value for this
	NDIS_TIMER						NdisTimer;		// System support
	UINT							TimerPeriod;	// Interval between ticks
	PVOID							ListContext;	// Used as a back pointer to the
													// Interface structure

} ATMARP_TIMER_LIST, *PATMARP_TIMER_LIST;

#if DBG
#define atl_signature		'ATL '
#endif // DBG

//
//  Timer Classes
//
typedef enum
{
	AAT_CLASS_SHORT_DURATION,
	AAT_CLASS_LONG_DURATION,
	AAT_CLASS_MAX

} ATMARP_TIMER_CLASS;





//
//  ----------------------- ATM Address Entry -----------------------------
//
//  All information about an ATM destination, and VCs to it. This is used
//  for both Unicast destinations (a single ATM endstation) and for Multicast
//  destinations (multiple ATM endstations).
// 
//  Unicast:
//  -------
//  There could be more than one VC going to this ATM destination, because
//  of use of different QoS on each. In the case of unicast destinations,
//  one or more ARP Table Entries (see below) could point to this entry,
//  because more than one IP address could map to this ATM address.
//
//  Multicast:
//  ---------
//  For simplicity, we restrict the number of ARP Table Entries pointing to
//  this entry to atmost 1 in the multicast case. Also, this entry would be
//  linked to a single VC, of type SVC-PMP-Outgoing.
//
//  Reference Count: we add One to the RefCount for each of the following:
//  - Each VC on its VcList
//  - Each ARP IP Entry that points to it
//  - Each Packet queued on its packet list
//  - For the duration another structure (e.g. ARP Server Entry) points to it
//

typedef enum 
{
	AE_REFTYPE_TMP,
	AE_REFTYPE_MCAE,
	AE_REFTYPE_IE,
	AE_REFTYPE_VC,
	AE_REFTYPE_IF,
	AE_REFTYPE_COUNT	// Must be last

} AE_REFTYPE;

typedef struct _ATMARP_ATM_ENTRY
{
#if DBG
	ULONG							aae_sig;		// Signature for debugging
#endif
	struct _ATMARP_ATM_ENTRY *		pNext;			// Next Entry on this Interface
	ULONG							RefCount;		// References to this struct
	ULONG							Flags;			// State and Type information
	ATMARP_LOCK						Lock;
	struct _ATMARP_INTERFACE *		pInterface;		// Back pointer
	struct _ATMARP_VC *				pVcList;		// List of VCs to this ATM address
	struct _ATMARP_VC *				pBestEffortVc;	// One of the Best Effort VCs here
	struct _ATMARP_IP_ENTRY *		pIpEntryList;	// List of IP entries that
													// point to this entry
	//
	//  The following two are used in the case of a unicast destination
	//
	ATM_ADDRESS						ATMAddress;		// "ATM Number" in the RFC
	ATM_ADDRESS						ATMSubaddress;	// Used only if ATMAddress is E.164
#ifdef IPMCAST
	//
	//  If this is a multicast destination, the following points to additional
	//  information.
	//
	struct _ATMARP_IPMC_ATM_INFO *	pMcAtmInfo;		// Additional info for multicast
#endif // IPMCAST

#if DBG
	UCHAR Refs[AE_REFTYPE_COUNT];
#endif //DBG

} ATMARP_ATM_ENTRY, *PATMARP_ATM_ENTRY;

#if DBG
// ATM Address Entry
#define aae_signature	'AAAE'
#endif

//
//  NULL pointer to ATMARP ATM Entry
//
#define NULL_PATMARP_ATM_ENTRY		((PATMARP_ATM_ENTRY)NULL)


//
//  Definitions for Flags in ATMARP ATM ENTRY
//
#define AA_ATM_ENTRY_STATE_MASK		0x00000003
#define AA_ATM_ENTRY_IDLE			0x00000000		// Just created
#define AA_ATM_ENTRY_ACTIVE			0x00000001		// Installed into the database
#define AA_ATM_ENTRY_CLOSING		0x00000002

#define AA_ATM_ENTRY_TYPE_MASK		0x00000010
#define AA_ATM_ENTRY_TYPE_UCAST		0x00000000		// Unicast
#define AA_ATM_ENTRY_TYPE_NUCAST	0x00000010		// Non-unicast



#ifdef IPMCAST

//
//  ---------------------- ATM-PMP Info for an ATM Entry ---------------------
//
//  This contains additional information specific to a multi-point ATM destination,
//  and is attached to an ATM Entry.
//
typedef struct _ATMARP_IPMC_ATM_INFO
{
	ULONG							Flags;			// State info
	struct _ATMARP_IPMC_ATM_ENTRY *	pMcAtmEntryList;// List of ATM endstations (multicast)
	struct _ATMARP_IPMC_ATM_ENTRY *	pMcAtmMigrateList;// List being migrated to
	ULONG							NumOfEntries;	// Size of above list
	ULONG							ActiveLeaves;	// <= NumOfMcEntries
	ULONG							TransientLeaves;// < NumOfMcEntries

} ATMARP_IPMC_ATM_INFO, *PATMARP_IPMC_ATM_INFO;

#define NULL_PATMARP_IPMC_ATM_INFO	((PATMARP_IPMC_ATM_INFO)NULL)

#define AA_IPMC_AI_CONN_STATE_MASK		0x0000000f
#define AA_IPMC_AI_CONN_NONE			0x00000000	// No connection/VC exists
#define AA_IPMC_AI_CONN_WACK_MAKE_CALL	0x00000001	// Outgoing call in progress
#define AA_IPMC_AI_CONN_ACTIVE			0x00000002	// Outgoing PMP call established
#define AA_IPMC_AI_CONN_TEMP_FAILURE	0x00000004	// Transient failure seen on MakeCall

#define AA_IPMC_AI_CONN_UPDATE_MASK		0x000000f0
#define AA_IPMC_AI_NO_UPDATE			0x00000000	// No connection update pending
#define AA_IPMC_AI_WANT_UPDATE			0x00000010	// Connection needs update
#define AA_IPMC_AI_BEING_UPDATED		0x00000020	// Connection is being updated


//
//
//  ---------------------- ATM Entry for a Multicast leaf --------------------
//
//  This contains information about a single element in the list of ATM endstations
//  that a Class D IP Address resolves to. This participates as a leaf in the PMP
//  connection we set up for packets sent to this multicast group.
//
typedef struct _ATMARP_IPMC_ATM_ENTRY
{
#if DBG
	ULONG							ame_sig;		// Signature for debugging
#endif // DBG
	struct _ATMARP_IPMC_ATM_ENTRY *	pNextMcAtmEntry;// Next member of multicast group
	ULONG							Flags;			// State and other info
	NDIS_HANDLE						NdisPartyHandle;// NDIS handle for this leaf
	struct _ATMARP_ATM_ENTRY *		pAtmEntry;		// Back pointer
	ATM_ADDRESS						ATMAddress;		// "ATM Number" in the RFC
	ATM_ADDRESS						ATMSubaddress;	// Used only if ATMAddress is E.164
	ATMARP_TIMER					Timer;			// Used to retry connecting

} ATMARP_IPMC_ATM_ENTRY, *PATMARP_IPMC_ATM_ENTRY;

#if DBG
#define ame_signature	'AAME'
#endif // DBG

//
//  NULL pointer to a Multicast ATM Entry
//
#define NULL_PATMARP_IPMC_ATM_ENTRY	((PATMARP_IPMC_ATM_ENTRY)NULL)

//
//  Definitions for Flags in Multicast ATM Entry
//
#define AA_IPMC_AE_GEN_STATE_MASK		0x0000000f
#define AA_IPMC_AE_VALID				0x00000000	// This leaf is valid
#define AA_IPMC_AE_INVALID				0x00000001	// Will be trimmed unless revalidated
#define AA_IPMC_AE_TERMINATING			0x00000002	// This leaf being terminated

#define AA_IPMC_AE_CONN_STATE_MASK		0x00000ff0
#define AA_IPMC_AE_CONN_DISCONNECTED	0x00000000
#define AA_IPMC_AE_CONN_WACK_ADD_PARTY	0x00000010	// Waiting for AddParty to complete
#define AA_IPMC_AE_CONN_ACTIVE			0x00000020	// Active leaf of PMP connection
#define AA_IPMC_AE_CONN_WACK_DROP_PARTY	0x00000040	// Waiting for DropParty to complete
#define AA_IPMC_AE_CONN_TEMP_FAILURE	0x00000080	// AddParty failed, will try later
#define AA_IPMC_AE_CONN_RCV_DROP_PARTY	0x00000100	// Incoming Drop Party seen


//
//  ----------------- ATMARP IP Multicast Join Entry -----------------
//
//  One of these structures is maintained for each Class D IP address
//  that has been "AddAddress"ed by the IP layer, i.e., each multicast
//  group that we have Joined. This can be considered as the "receive
//  side" data structure for a Class D IP address. We have different
//  structures for the transmit and receive sides of a Multicast group
//  because this host can participate exclusively on one or the other,
//  and the information needed is very different. Transmit side
//  information is maintained in an ATMARP_IP_ENTRY and associated
//  structures.
//
typedef struct _ATMARP_IPMC_JOIN_ENTRY
{
#if DBG
	ULONG							aamj_sig;
#endif // DBG
	struct _ATMARP_IPMC_JOIN_ENTRY *pNextJoinEntry;	// Next IP Address Joined on this IF
	ULONG							Flags;			// State info (see below)
	ULONG							RefCount;
	ULONG							JoinRefCount;	// # of AddAddress - # of DelAddress
	struct _ATMARP_INTERFACE *		pInterface;		// Back pointer
	IP_ADDRESS						IPAddress;		// Class D IP address we've joined
	IP_MASK							Mask;			// Defines range of this join entry.
	ATMARP_TIMER					Timer;			// Waiting for Join/Leave completion
	ULONG							RetriesLeft;	// For Joining/Leaving
#if DBG
	ULONG							LastIncrRef;	// For debugging
	ULONG							LastDecrRef;
#endif

} ATMARP_IPMC_JOIN_ENTRY, *PATMARP_IPMC_JOIN_ENTRY;

#if DBG
#define aamj_signature	'AAMJ'
#endif // DBG
//
//  NULL pointer to IPMC Join Entry
//
#define NULL_PATMARP_IPMC_JOIN_ENTRY	((PATMARP_IPMC_JOIN_ENTRY)NULL)


//
//  Definitions for Flags in a Join Entry
//
#define AA_IPMC_JE_STATE_MASK		0x000000FF
#define AA_IPMC_JE_STATE_UNUSED		0x00000000
#define AA_IPMC_JE_STATE_PENDING	0x00000001	// Waiting for a CMI to be assigned to us
#define AA_IPMC_JE_STATE_JOINING	0x00000002	// Have sent MARS_JOIN
#define AA_IPMC_JE_STATE_JOINED		0x00000004	// Seen copy of MARS_JOIN (== ack)
#define AA_IPMC_JE_STATE_LEAVING	0x00000008	// Have sent MARS_LEAVE

#endif // IPMCAST



//
//  ---------------------------- ARP Table (IP) Entry ------------------------
//
//  Contains information about one remote IP address.
//
//  There is atmost one ARP Table entry for a given IP address.
//
//  The IP Entry participates in two lists:
//  (1) A list of all entries that hash to the same bucket in the ARP Table
//  (2) A list of all entries that resolve to the same ATM Address -- this
//      is only if the IP address is unicast.
//
//  A pointer to this structure is also used as our context value in the
//  Route Cache Entry prepared by the higher layer protocol(s).
//
//  Reference Count: We add one to its ref count for each of the following:
//	 - Each Route Cache entry that points to this entry
//   - For the duration an active timer exists on this Entry
//   - For the duration the entry belongs to the list of IP entries linked
//     to an ATM Entry.
//

typedef enum 
{
	IE_REFTYPE_TMP,
	IE_REFTYPE_RCE,
	IE_REFTYPE_TIMER,
	IE_REFTYPE_AE,
	IE_REFTYPE_TABLE,
	IE_REFTYPE_COUNT	// Must be last

} IE_REFTYPE;

typedef struct _ATMARP_IP_ENTRY
{
#if DBG
	ULONG							aip_sig;		// Signature for debugging
#endif
	IP_ADDRESS						IPAddress;		// IP Address
	struct _ATMARP_IP_ENTRY *		pNextEntry;		// Next in hash list
	struct _ATMARP_IP_ENTRY *		pNextToAtm;		// List of entries pointing to
													// the same ATM Entry
	ULONG							Flags;			// State and Type information
	ULONG							RefCount;		// References to this struct
	ATMARP_LOCK						Lock;
	struct _ATMARP_INTERFACE *		pInterface;		// Back pointer
	PATMARP_ATM_ENTRY				pAtmEntry;		// Pointer to all ATM info
#ifdef IPMCAST
	struct _ATMARP_IP_ENTRY *		pNextMcEntry;	// Next "higher" Multicast IP Entry
	USHORT							NextMultiSeq;	// Sequence Number expected
													// in the next MULTI
	USHORT							Filler;
#endif // IPMCAST
	ATMARP_TIMER					Timer;			// Timers are: (all exclusive)
													// - Aging timer
													// - Waiting for ARP reply
													// - Waiting for InARP reply
													// - Delay after NAK
													// - Waiting for MARS MULTI
													// - Delay before marking for reval
	ULONG							RetriesLeft;
	PNDIS_PACKET					PacketList;		// List of packets waiting to be sent

	RouteCacheEntry *				pRCEList;		// List of Route Cache Entries
													// associated with this entry.
#ifdef CUBDD
	SINGLE_LIST_ENTRY				PendingIrpList;	// List of IRP's waiting for
													// this IP address to be resolved.
#endif // CUBDD

#if DBG
	UCHAR Refs[IE_REFTYPE_COUNT];
#endif // DBG

} ATMARP_IP_ENTRY, *PATMARP_IP_ENTRY;

#if DBG
// ATM ARP IP Entry
#define aip_signature	'AAIP'
#endif

//
//  NULL pointer to ATMARP IP Entry
//
#define NULL_PATMARP_IP_ENTRY		((PATMARP_IP_ENTRY)NULL)


//
//  Definitions for Flags in ATMARP IP ENTRY
//
//  A pre-condition for sending data to a destination governed by a
//  table entry is: (Flags & AA_IP_ENTRY_STATE_MASK) == AA_IP_ENTRY_RESOLVED
//
#define AA_IP_ENTRY_STATE_MASK			0x0000000f
#define AA_IP_ENTRY_IDLE				0x00000000	// Just created/ ok to del
#define AA_IP_ENTRY_IDLE2				0x00000001	// In arp table but unused.
#define AA_IP_ENTRY_ARPING				0x00000002	// Waiting for ARP reply
#define AA_IP_ENTRY_INARPING			0x00000003	// Waiting for InARP reply
#define AA_IP_ENTRY_RESOLVED			0x00000004	// Resolved IP -> ATM Address
#define AA_IP_ENTRY_COMM_ERROR			0x00000005	// Seen abnormal close on attached VC
#define AA_IP_ENTRY_ABORTING			0x00000006	// Abort in progress
#define AA_IP_ENTRY_AGED_OUT			0x00000007	// Has aged out
#define AA_IP_ENTRY_SEEN_NAK			0x00000008	// NAK delay timer started

#ifdef IPMCAST
#define AA_IP_ENTRY_MC_VALIDATE_MASK	0x00000600
#define AA_IP_ENTRY_MC_NO_REVALIDATION	0x00000000	// No revalidation in progress/needed
#define AA_IP_ENTRY_MC_REVALIDATE		0x00000200	// Marked as needing Revalidation
#define AA_IP_ENTRY_MC_REVALIDATING		0x00000400	// Revalidation in progress

#define AA_IP_ENTRY_MC_RESOLVE_MASK		0x00003800
#define AA_IP_ENTRY_MC_IDLE				0x00000000
#define AA_IP_ENTRY_MC_AWAIT_MULTI		0x00000800	// Awaiting more MARS_MULTI replies
#define AA_IP_ENTRY_MC_DISCARDING_MULTI	0x00001000	// Discard mode because of error
#define AA_IP_ENTRY_MC_RESOLVED			0x00002000	// All MARS_MULTIs received

#define AA_IP_ENTRY_ADDR_TYPE_MASK		0x00004000
#define AA_IP_ENTRY_ADDR_TYPE_UCAST		0x00000000	// Unicast
#define AA_IP_ENTRY_ADDR_TYPE_NUCAST	0x00004000	// Non-unicast (e.g. Class D)
#endif // IPMCAST

#define AA_IP_ENTRY_TYPE_MASK			0x20000000
#define AA_IP_ENTRY_IS_STATIC			0x20000000	// Static entry (no aging on this)


#define ATMARP_TABLE_SIZE			127





//
//  --------------------- ATMARP Virtual Circuit (VC) ---------------------
//
//  One of these is used for each call terminated at the IP/ATM client.
//  Creation and deletion of this structure is linked to NdisCoCreateVc and
//  NdisCoDeleteVc.
//
//  An ATMARP_VC structure becomes linked to an ATMARP_ATM_ENTRY when (and only
//  when) we determine the ATM address(es) of the remote ATM endstation.
//  For outgoing calls, we would have determined this before making the call,
//  and for incoming calls, we learn this either through the Calling Address
//  (for SVCs) or via InATMARP (for PVCs). "Incoming" PVCs are kept in the
//  "Unresolved VC" list in the Interface structure, until the ATM address
//  of the other end is resolved.
//
//  The FilterSpec and FlowSpec hooks are for support of multiple VCs of
//  varying QoS between (possibly the same pair of) IP stations. Only IP
//  packets that match the FilterSpec will be transmitted on this VC.
//
//  Reference Count: we add One to the RefCount for each of the following:
//  - For the duration this VC is linked to an ATM entry (or Unresolved VC list)
//  - For the duration this VC is an NDIS VC (not DeleteVc'ed)
//  - For the duration a call exists (in progress/active) on this VC
//	- For the duration an active timer exists on this VC
//

typedef struct _ATMARP_VC
{
#if DBG
	ULONG							avc_sig;
#endif
	struct _ATMARP_VC *				pNextVc;		// Next VC in list
	ULONG							RefCount;		// References to this struct
	ULONG							Flags;			// State and Type information
	ULONG							OutstandingSends;// Sent packets awaiting completion
	ATMARP_LOCK						Lock;
	NDIS_HANDLE						NdisVcHandle;	// For NDIS calls
	struct _ATMARP_INTERFACE *		pInterface;		// Back pointer to ARP Interface
	PATMARP_ATM_ENTRY				pAtmEntry;		// Back pointer to ATM Entry
	PNDIS_PACKET					PacketList;		// List of packets waiting to be sent
	ATMARP_TIMER					Timer;			// VC Timers are (exclusive):
													// - Waiting for InARP reply
													// - Aging
	ULONG							RetriesLeft;	// In case the timer runs out
#ifdef GPC
	PVOID							FlowHandle;		// Points to Flow Info struct
#endif // GPC
	ATMARP_FILTER_SPEC				FilterSpec;		// Filter Spec (Protocol, port)
	ATMARP_FLOW_SPEC				FlowSpec;		// Flow Spec (QoS etc) for this conn

} ATMARP_VC, *PATMARP_VC;

#if DBG
// ATM ARP VC
#define avc_signature	'AAVC'
#endif

//
//  NULL pointer to ATMARP VC
//
#define NULL_PATMARP_VC		((PATMARP_VC)NULL)

//
//  Definitions for ATMARP VC flags. The following information is kept
//  here:
//		- Is this VC an SVC or PVC
//  	- Is this created (owned) by the ATMARP module or the Call Manager
//  	- Call State: Incoming in progress, Outgoing in progress, Active,
//    	  Close in progress, or Idle
//

//  Bits 0 and 1 for "Type"
#define AA_VC_TYPE_MASK								0x00000003
#define AA_VC_TYPE_UNUSED							0x00000000
#define AA_VC_TYPE_SVC								0x00000001
#define AA_VC_TYPE_PVC								0x00000002

//  Bits 2 and 3 for "Owner"
#define AA_VC_OWNER_MASK							0x0000000C
#define AA_VC_OWNER_IS_UNKNOWN						0x00000000
#define AA_VC_OWNER_IS_ATMARP						0x00000004	// NdisClCreateVc done
#define AA_VC_OWNER_IS_CALLMGR						0x00000008	// CreateVcHandler done

// Bits 4, 5, 6, 7 for Call State
#define AA_VC_CALL_STATE_MASK						0x000000F0
#define AA_VC_CALL_STATE_IDLE						0x00000000
#define AA_VC_CALL_STATE_INCOMING_IN_PROGRESS		0x00000010	// Wait for CallConnected
#define AA_VC_CALL_STATE_OUTGOING_IN_PROGRESS		0x00000020	// Wait for MakeCallCmpl
#define AA_VC_CALL_STATE_ACTIVE						0x00000040
#define AA_VC_CALL_STATE_CLOSE_IN_PROGRESS			0x00000080	// Wait for CloseCallCmpl

// Bit 8 for Aging
#define AA_VC_AGING_MASK							0x00000100
#define AA_VC_NOT_AGED_OUT							0x00000000
#define AA_VC_AGED_OUT								0x00000100

// Bit 9 to indicate whether an abnormal Close has happened
#define AA_VC_CLOSE_TYPE_MASK						0x00000200
#define AA_VC_CLOSE_NORMAL							0x00000000
#define AA_VC_CLOSE_ABNORMAL						0x00000200

// Bits 10 and 11 to indicate any ARP operation in progress
#define AA_VC_ARP_STATE_MASK						0x00000C00
#define AA_VC_ARP_STATE_IDLE						0x00000000
#define AA_VC_INARP_IN_PROGRESS						0x00000400

// Bits 12 and 13 to indicate whether we are closing this VC, or if we need to
#define AA_VC_CLOSE_STATE_MASK						0x00003000
#define AA_VC_CLOSE_STATE_CLOSING					0x00001000

// Bit 14 to indicate VC Connection type (point to point or point to
// multi-point)
#define AA_VC_CONN_TYPE_MASK						0x00004000
#define AA_VC_CONN_TYPE_P2P							0x00000000	// Point to Point
#define AA_VC_CONN_TYPE_PMP							0x00004000	// Point to Multipoint

// Bit 15 to indicate if this VC has been unlinked from a GPC QOS CFINFO
#define AA_VC_GPC_MASK								0x00008000
#define AA_VC_GPC_IS_UNLINKED_FROM_FLOW				0x00008000


//
//  ---- ATMARP Buffer Tracker ----
//
//  Keeps track of allocation information for a pool of buffers. A list
//  of these structures is used to maintain info about a dynamically
//  growable pool of buffers (e.g. for ARP header buffers)
//

typedef struct _ATMARP_BUFFER_TRACKER
{
	struct _ATMARP_BUFFER_TRACKER *	pNext;		// in a list of trackers
	NDIS_HANDLE						NdisHandle;	// for Buffer Pool
	PUCHAR							pPoolStart;	// start of memory chunk allocated
												// from the system
} ATMARP_BUFFER_TRACKER, *PATMARP_BUFFER_TRACKER;

//
//  NULL pointer to ATMARP Buffer tracker structure
//
#define NULL_PATMARP_BUFFER_TRACKER	((PATMARP_BUFFER_TRACKER)NULL)


//
//  ---- ATMARP Header Pool -----
//
//  Keeps track of allocation information for a pool of Header buffers.
//  Header buffers are used to tack on LLC/SNAP headers to transmitted
//  IP packets. Each Header pool contains a number of fixed-size buffers.
//  We use one header pool for IP Unicast headers, and one for IP Multicast
//  headers.
//
typedef struct _ATMARP_HEADER_POOL
{
	SLIST_HEADER				HeaderBufList;		// Free list of header buffers
	ULONG						HeaderBufSize;		// Size of each header buffer
	ULONG						MaxHeaderBufs;		// Max header buffers we can allocate
	ULONG						CurHeaderBufs;		// Current header buffers allocated
	PATMARP_BUFFER_TRACKER		pHeaderTrkList;		// Info about allocated header buffers

} ATMARP_HEADER_POOL, *PATMARP_HEADER_POOL;

#define NULL_PATMARP_HEADER_POOL	((PATMARP_HEADER_POOL)NULL)


//
//  Packet header types.
//
//  IMPORTANT: Keep _MAX and _NONE at the end of this list!
//
typedef enum
{
	AA_HEADER_TYPE_UNICAST,
	AA_HEADER_TYPE_NUNICAST,
	AA_HEADER_TYPE_MAX,
	AA_HEADER_TYPE_NONE

} AA_HEADER_TYPE;


//
//  ------------------------ ATMARP SAP --------------------------------
//
//  Each of these structures maintains information about a SAP attached
//  to an LIS. Normally the ATMARP client would register just one SAP
//  with the Call manager, with BLLI fields set so that all IP/ATM calls
//  are directed to this client. However, we may support services (e.g.
//  DHCP) over IP/ATM that are assigned well-known ATM addresses, i.e.
//  addresses other than the one registered with the switch. These form
//  additional SAPs we register with the Call Manager. In addition to
//  registering these addresses as SAPs, we also request the Call Manager
//  to register them via ILMI with the switch, so that the network
//  directs calls to these addresses to us.
//
typedef struct _ATMARP_SAP
{
#if DBG
	ULONG							aas_sig;
#endif
	struct _ATMARP_SAP *			pNextSap;	// in list of SAPs
	struct _ATMARP_INTERFACE *		pInterface;	// back pointer
	NDIS_HANDLE						NdisSapHandle;
	ULONG							Flags;		// state information
	PCO_SAP							pInfo;		// SAP characteristics.

} ATMARP_SAP, *PATMARP_SAP;

#if DBG
#define aas_signature			'AAS '
#endif // DBG

//
//  NULL pointer to ATMARP SAP
//
#define NULL_PATMARP_SAP			((PATMARP_SAP)NULL)

//
//  Definitions for Flags in ATMARP SAP
//
//
//  Bits 0 to 3 contain the SAP-registration state.
//
#define AA_SAP_REG_STATE_MASK					0x0000000f
#define AA_SAP_REG_STATE_IDLE					0x00000000
#define AA_SAP_REG_STATE_REGISTERING			0x00000001		// Sent RegisterSap
#define AA_SAP_REG_STATE_REGISTERED				0x00000002		// RegisterSap completed
#define AA_SAP_REG_STATE_DEREGISTERING			0x00000004		// Sent DeregisterSap
//
//  Bits 4 to 7 contain the ILMI-registration state.
//
#define AA_SAP_ILMI_STATE_MASK					0x000000f0
#define AA_SAP_ILMI_STATE_IDLE					0x00000000
#define AA_SAP_ILMI_STATE_ADDING				0x00000010		// Sent ADD_ADDRESS
#define AA_SAP_ILMI_STATE_ADDED					0x00000020		// ADD_ADDRESS completed
#define AA_SAP_ILMI_STATE_DELETING				0x00000040		// Sent DELETE_ADDRESS

//
//  Bit 8 tells us whether this Address should be "ADDED" to the Call Manager,
//  i.e. ILMI-registered with the switch.
//
#define AA_SAP_ADDRTYPE_MASK					0x00000100
#define AA_SAP_ADDRTYPE_BUILT_IN				0x00000000
#define AA_SAP_ADDRTYPE_NEED_ADD				0x00000100




//
//  ------------------------ ATMARP Interface ------------------------
//
//  One of these structures is maintained for each LIS that this system is
//  a member of.
//
//  The Interface structure has the following sections:
//
//		Adapter		  -	Information pertaining to the ATM miniport to which
//						this LIS is bound
//		Buffer Mgmt	  -	NDIS Packet pool, NDIS Buffer pool, and two types of
//						buffers: Header buffers (LLC/SNAP) and Protocol buffers
//						(for ARP/InARP packets)
//		IP 			  -	Information related to the IP layer (context, IP addr lists)
//		Client		  -	Information relating to IP/ATM client operation
//
//  Reference Count: we add One to the interface RefCount for each of:
//  - Adapter reference (between NdisOpenAdapter and NdisCloseAdapter-Complete)
//  - Call Manager reference (between OpenAf and CloseAf-Complete)
//  - Each new ATMARP Table entry in the ARP Table
//  - An active Interface timer
//

typedef struct _ATMARP_INTERFACE
{
#if DBG
	ULONG						aai_sig;			// Signature
#endif
	struct _ATMARP_INTERFACE *	pNextInterface;		// in list of ATMARP interfaces
	ATMARP_LOCK					InterfaceLock;		// Mutex for Interface structure
	ATMARP_BLOCK				Block;				// For blocking calling thread
	ULONG						RefCount;			// References to this interface
	ULONG						AdminState;			// Desired state of this interface
	ULONG						State;				// (Actual) State of this interface
    enum
    {
        RECONFIG_NOT_IN_PROGRESS,
        RECONFIG_SHUTDOWN_PENDING,
        RECONFIG_RESTART_QUEUED,
        RECONFIG_RESTART_PENDING

    }                           ReconfigState;
	PNET_PNP_EVENT			    pReconfigEvent;     // Our own PnP event pending
                                                    // completion.

	ULONG						Flags;				// Misc state information
	ULONG						LastChangeTime;		// Time of last state change
	ULONG						MTU;				// Max Transmision Unit (bytes)
	ULONG						Speed;				// That we report to IP


	//
	//  ----- Adapter related ----
	//  More than one ATMARP interface could be associated with
	//  a single adapter.
	//
#if DBG
	ULONG						aaim_sig;			// Signature to help debugging
#endif
	struct _ATMARP_ADAPTER *	pAdapter;			// Pointer to Adapter info
	NDIS_HANDLE					NdisAdapterHandle;	// to Adapter
	NDIS_HANDLE					NdisAfHandle;		// AF handle to Call Manager
	NDIS_HANDLE					NdisSapHandle;		// SAP handle to Call Manager
	PCO_SAP						pSap;				// SAP info for this interface
	ULONG						SapSelector;		// SEL byte for this interface's SAP

	ATMARP_SAP					SapList;			// Each SAP registered with CallMgr
	ULONG						NumberOfSaps;		// Size of above list (> 1)

	//
	//  ----- Buffer Management: Header buffers and Protocol buffers ----
	//
	NDIS_SPIN_LOCK				BufferLock;			// Mutex for buffers
#if 1
	ATMARP_HEADER_POOL			HeaderPool[AA_HEADER_TYPE_MAX];
#else
	SLIST_HEADER				HeaderBufList;		// Free list of header buffers
	ULONG						HeaderBufSize;		// Size of each header buffer
	ULONG						MaxHeaderBufs;		// Max header buffers we can allocate
	ULONG						CurHeaderBufs;		// Current header buffers allocated
	PATMARP_BUFFER_TRACKER		pHeaderTrkList;		// Info about allocated header buffers
#endif // 1 ( IPMCAST )
	NDIS_HANDLE					ProtocolPacketPool;	// Handle for Packet pool
	NDIS_HANDLE					ProtocolBufferPool;	// Handle for Buffer pool
	PUCHAR						ProtocolBufList;	// Free list of protocol buffers (for
													// ARP packets)
	PUCHAR						ProtocolBufTracker;	// Start of chunk of memory used for
													// the above.
	ULONG						ProtocolBufSize;	// Size of each protocol buffer
	ULONG						MaxProtocolBufs;	// Number of protocol buffers

	//
	//  ----- IP/ARP interface related ----
	//
#if DBG
	ULONG						aaia_sig;			// Signature to help debugging
#endif
	PVOID						IPContext;			// Use in calls to IP
	IP_ADDRESS_ENTRY			LocalIPAddress;		// List of local IP addresses. There
													// should be atleast one.
	ULONG						NumOfIPAddresses;	// Size of above list.
	PPROXY_ARP_ENTRY			pProxyList;			// List of proxy addresses
	IP_ADDRESS					BroadcastAddress;	// IP Broadcast address for this IF
	IP_ADDRESS					BroadcastMask;		// Broadcast Mask for this interface
	IPRcvRtn					IPRcvHandler;		// Indicate Receive
	IPTxCmpltRtn				IPTxCmpltHandler;	// Transmit Complete
	IPStatusRtn					IPStatusHandler;
	IPTDCmpltRtn				IPTDCmpltHandler;	// Transfer Data Complete
	IPRcvCmpltRtn				IPRcvCmpltHandler;	// Receive Complete
#ifdef _PNP_POWER_
	IPRcvPktRtn					IPRcvPktHandler;	// Indicate Receive Packet
	IP_PNP						IPPnPEventHandler;
#endif // _PNP_POWER_
	UINT						ATInstance;			// Instance # for this AT Entity
	UINT						IFInstance;			// Instance # for this IF Entity
	NDIS_STRING					IPConfigString;		// Config info for IP for this LIS
#ifdef PROMIS
	NDIS_OID					EnabledIPFilters; // Set of enabled oids -- 
													// set/cleared using 
													//  AtmArpIfSetNdisRequest.

#endif // PROMIS

	//
	//  ----- IP/ATM operation related ----
	//
#if DBG
	ULONG						aait_sig;			// Signature to help debugging
#endif
	PATMARP_IP_ENTRY *			pArpTable;			// The ARP table
	ULONG						NumOfArpEntries;	// Entries in the above
	ATMARP_LOCK					ArpTableLock;		// Mutex for ARP Table
	BOOLEAN						ArpTableUp;			// Status for arp table.

	ATMARP_SERVER_LIST			ArpServerList;		// List of ARP servers
	PATMARP_SERVER_ENTRY		pCurrentServer;		// ARP server in use
	PATMARP_VC					pUnresolvedVcs;		// VCs whose ATM addrs aren't resolved
	PATMARP_ATM_ENTRY			pAtmEntryList;		// List of all ATM Entries
	ATMARP_LOCK					AtmEntryListLock;	// Mutex for above list
	BOOLEAN						AtmEntryListUp;		// Status of atm entry list.

	ULONG						PVCOnly;			// Only PVCs on this interface
	ULONG						AtmInterfaceUp;		// The ATM interface is considered
													// "up" after ILMI addr regn is over
	ATM_ADDRESS					LocalAtmAddress;	// Our ATM (HW) Address

	ATMARP_TIMER				Timer;				// Interface timers are: (exclusive)
													// - Server Connect Interval
													// - Server Registration
													// - Server Refresh
	ULONG						RetriesLeft;		// For above timer

	//
	//  All timeout values are stored in terms of seconds.
	//
	ULONG						ServerConnectInterval;		// 3 to 60 seconds
	ULONG						ServerRegistrationTimeout;	// 1 to 60 seconds
	ULONG						AddressResolutionTimeout;	// 1 to 60 seconds
	ULONG						ARPEntryAgingTimeout;		// 1 to 15 minutes
	ULONG						VCAgingTimeout;				// 1 to 15 minutes
	ULONG						InARPWaitTimeout;			// 1 to 60 seconds
	ULONG						ServerRefreshTimeout;		// 1 to 15 minutes
	ULONG						MinWaitAfterNak;			// 1 to 60 seconds
	ULONG						MaxRegistrationAttempts;	// 0 means infinity
	ULONG						MaxResolutionAttempts;		// 0 means infinity
	ATMARP_TIMER_LIST			TimerList[AAT_CLASS_MAX];
	ATMARP_LOCK					TimerLock;			// Mutex for timer structures

#ifdef IPMCAST
	//
	//  ---- IP Multicast over ATM stuff ----
	//
#if DBG
	ULONG						aaic_sig;			// Signature for debugging
#endif // DBG
	ULONG						IpMcState;			// State of IP Multicast/ATM
	ULONG						HostSeqNumber;		// Latest # seen on ClusterControlVc
	USHORT						ClusterMemberId;	// ID Assigned to us by MARS
	PATMARP_IPMC_JOIN_ENTRY		pJoinList;			// List of MC groups we have Joined
	PATMARP_IP_ENTRY			pMcSendList;		// Sorted list of MC groups we send to
	ATMARP_SERVER_LIST			MARSList;			// List of MARS (servers)
	PATMARP_SERVER_ENTRY		pCurrentMARS;		// MARS in use

	ATMARP_TIMER				McTimer;			// Interface timers for Multicast:
													// - MARS Connect Interval
													// - MARS Registration
													// - MARS Refresh
	ULONG						McRetriesLeft;		// For above timer
	//
	//  All timeout values are stored in terms of seconds.
	//
	ULONG						MARSConnectInterval;
	ULONG						MARSRegistrationTimeout;
	ULONG						MARSKeepAliveTimeout;
	ULONG						JoinTimeout;
	ULONG						LeaveTimeout;
	ULONG						MulticastEntryAgingTimeout;
	ULONG						MaxDelayBetweenMULTIs;
	ULONG						MinRevalidationDelay;
	ULONG						MaxRevalidationDelay;
	ULONG						MinPartyRetryDelay;
	ULONG						MaxPartyRetryDelay;
	ULONG						MaxJoinOrLeaveAttempts;
	

#endif // IPMCAST

	//
	//  ---- QoS stuff ----
	//
	PAA_GET_PACKET_SPEC_FUNC	pGetPacketSpecFunc;	// Routine to extract packet specs
	PAA_FILTER_SPEC_MATCH_FUNC	pFilterMatchFunc;	// Routine to match filter specs
	PAA_FLOW_SPEC_MATCH_FUNC	pFlowMatchFunc;		// Routine to match flow specs
	ATMARP_FLOW_SPEC			DefaultFlowSpec;	// The default flow specs for all
													// (best effort) calls on this IF
	ATMARP_FILTER_SPEC			DefaultFilterSpec;	// The default filter specs for all
													// (best effort) packets
	PATMARP_FLOW_INFO			pFlowInfoList;		// List of configured flows

#ifdef DHCP_OVER_ATM
	BOOLEAN						DhcpEnabled;
	ATM_ADDRESS					DhcpServerAddress;
	PATMARP_ATM_ENTRY			pDhcpServerAtmEntry;
#endif // DHCP_OVER_ATM

	//
	//  ---- MIB objects: counters, descriptions etc ---
	//
#if DBG
	ULONG						aaio_sig;			// Signature to help debugging
#endif
	ULONG						IFIndex;			// Interface number
	ULONG						InOctets;			// Input octets
	ULONG						InUnicastPkts;		// Input Unicast packets
	ULONG						InNonUnicastPkts;	// Input Non-unicast packets
	ULONG						OutOctets;			// Output octets
	ULONG						OutUnicastPkts;		// Output Unicast packets
	ULONG						OutNonUnicastPkts;	// Output Non-unicast packets
	ULONG						InDiscards;
	ULONG						InErrors;
	ULONG						UnknownProtos;
	ULONG						OutDiscards;
	ULONG						OutErrors;

	//
	//  ---- WMI Information ---
	//
#if ATMARP_WMI
#if DBG
	ULONG						aaiw_sig;			// Signature to help debugging
#endif
	struct _ATMARP_IF_WMI_INFO *pIfWmiInfo;
	ATMARP_LOCK					WmiLock;
#endif

} ATMARP_INTERFACE, *PATMARP_INTERFACE;

#if DBG
// ATM ARP Interface:
#define aai_signature	'AAIF'

//  Sections within the ATM ARP Interface:
#define aaim_signature	'AAIM'
#define aaia_signature	'AAIA'
#define aait_signature	'AAIT'
#define aaio_signature	'AAIO'
#define aaic_signature	'AAIC'
#define aaiw_signature	'AAIW'
#endif

//
//  NULL Pointer to ATMARP Interface
//
#define NULL_PATMARP_INTERFACE	((PATMARP_INTERFACE)NULL)

//
//  Definitions for Interface Flags: the following information is kept
//  here:
//		- ARP Server registration state
//		- MARS registration state
//

#define AA_IF_SERVER_STATE_MASK				((ULONG)0x00000003)
#define AA_IF_SERVER_NO_CONTACT				((ULONG)0x00000000)
#define AA_IF_SERVER_REGISTERING			((ULONG)0x00000001)
#define AA_IF_SERVER_REGISTERED				((ULONG)0x00000002)

#ifdef IPMCAST
#define AAMC_IF_STATE_MASK					((ULONG)0x00000F00)
#define AAMC_IF_STATE_NOT_REGISTERED		((ULONG)0x00000000)
#define AAMC_IF_STATE_REGISTERING			((ULONG)0x00000100)
#define AAMC_IF_STATE_REGISTERED			((ULONG)0x00000200)
#define AAMC_IF_STATE_DELAY_B4_REGISTERING	((ULONG)0x00000400)

#define AAMC_IF_MARS_FAILURE_MASK			((ULONG)0x0000F000)
#define AAMC_IF_MARS_FAILURE_NONE			((ULONG)0x00000000)
#define AAMC_IF_MARS_FAILURE_FIRST_RESP		((ULONG)0x00001000)
#define AAMC_IF_MARS_FAILURE_SECOND_RESP	((ULONG)0x00002000)
#endif // IPMCAST



//
//  ---- ATMARP Adapter Information ----
//
//  One of these structures is used to maintain information about
//  each adapter to which the ATMARP module is bound. One or more
//  ATMARP Interface structures point to this structure, and the
//  reference count reflects that.
//
typedef struct _ATMARP_ADAPTER
{
#if DBG
	ULONG						aaa_sig;			// signature for debugging
#endif
	struct _ATMARP_ADAPTER *	pNextAdapter;		// Next adapter on this system
	PATMARP_INTERFACE			pInterfaceList;		// List of ATMARP IF's on this adapter
	ULONG						InterfaceCount;		// Size of above list
	NDIS_HANDLE					NdisAdapterHandle;	// From NdisOpenAdapter
	NDIS_HANDLE					BindContext;		// BindContext to our Bind handler
	NDIS_HANDLE					SystemSpecific1;	// SystemSpecific1 to our Bind handler
	NDIS_HANDLE					SystemSpecific2;	// SystemSpecific2 to our Bind handler
	NDIS_STRING				    IPConfigString;	    // Points to multi-sz, one string
													// per logical interface (LIS)
	NDIS_HANDLE					UnbindContext;		// Passed to our Unbind handler
	NDIS_MEDIUM					Medium;				// Should be NdisMediumAtm
	ULONG						Flags;				// State information
	NDIS_CO_LINK_SPEED			LineRate;			// Supported by adapter
	ULONG						MaxPacketSize;		// Supported by adapter
	UCHAR						MacAddress[AA_ATM_ESI_LEN];
													// Address burnt into adapter
	ULONG						DescrLength;		// Length of descriptor string, below
	PUCHAR						pDescrString;

	NDIS_STRING					DeviceName;			// Passed to BindAdapter handler
	NDIS_STRING					ConfigString;		// Used for per-adapter registry

	ATMARP_BLOCK				Block;				// For blocking calling thread
	ATMARP_BLOCK				UnbindBlock;		// For blocking UnbindAdapter

#if ATMOFFLOAD
	//
	// Task Offload Information
	//
	struct
	{
		ULONG 					Flags;				// Enabled tasks
		UINT					MaxOffLoadSize;		// Maximum send size supported
		UINT					MinSegmentCount;	// Minimum segments required 
													// to do large sends.
	} Offload;
#endif // ATMOFFLOAD

} ATMARP_ADAPTER, *PATMARP_ADAPTER;

#if DBG
#define aaa_signature	'AAAD'
#endif

//
//  NULL Pointer to ATMARP Adapter
//
#define NULL_PATMARP_ADAPTER	((PATMARP_ADAPTER)NULL)

//
//  Definitions for Adapter Flags: the following information is kept
//  here:
//		- Are we unbinding now?
//		- Are we processing an AF register notify?
//		- Have we initiated NdisCloseAdapter?
//
#define AA_ADAPTER_FLAGS_UNBINDING		0x00000001
#define AA_ADAPTER_FLAGS_PROCESSING_AF	0x00000002
#define AA_ADAPTER_FLAGS_AF_NOTIFIED	0x00000004
#define AA_ADAPTER_FLAGS_CLOSING		0x00000008


	
//
//  ---- ATMARP Global Information ----
//
//  One of these structures is maintained for the entire system.
//

typedef struct _ATMARP_GLOBALS
{
#if DBG
	ULONG						aag_sig;			// signature
#endif
	ATMARP_LOCK					Lock;				// mutex
	NDIS_HANDLE					ProtocolHandle;		// returned by NdisRegisterProtocol
	PVOID						pDriverObject;		// handle to Driver Object for ATMARP
	PVOID						pDeviceObject;		// handle to Device Object for ATMARP

	PATMARP_ADAPTER				pAdapterList;		// list of all adapters bound to us
	ULONG						AdapterCount;		// size of above list
	BOOLEAN						bUnloading;

#ifdef NEWARP
	HANDLE						ARPRegisterHandle;	// From IPRegisterARP
	IP_ADD_INTERFACE			pIPAddInterfaceRtn;	// call into IP to add an interface
	IP_DEL_INTERFACE			pIPDelInterfaceRtn;	// call into IP to delete an interface
	IP_BIND_COMPLETE			pIPBindCompleteRtn;	// call into IP to inform of bind cmpl
#if P2MP
	IP_ADD_LINK 				pIPAddLinkRtn;
	IP_DELETE_LINK 				pIpDeleteLinkRtn;
#endif // P2MP
#else
	IPAddInterfacePtr			pIPAddInterfaceRtn;	// call into IP to add an interface
	IPDelInterfacePtr			pIPDelInterfaceRtn;	// call into IP to delete an interface
#endif // NEWARP

	ATMARP_BLOCK				Block;				// For blocking calling thread

#ifdef GPC
#if DBG
	ULONG						aaq_sig;			// additional signature
#endif
	PATMARP_FLOW_INFO			pFlowInfoList;		// List of configured flows
	GPC_HANDLE					GpcClientHandle;	// From GpcRegisterClient()
	BOOLEAN						bGpcInitialized;	// Did we register successfully?
	GPC_EXPORTED_CALLS			GpcCalls;			// All GPC API entry points
#endif // GPC

} ATMARP_GLOBALS, *PATMARP_GLOBALS;

#if DBG
// ATM ARP Global info
#define aag_signature	'AAGL'
#define aaq_signature	'AAGQ'
#endif

//
//  NULL pointer to ATMARP Globals structure
//
#define NULL_PATMARP_GLOBALS		((PATMARP_GLOBALS)NULL)



//
//  ATMARP module's context info in IP's Route Cache Entry
//
typedef struct _ATMARP_RCE_CONTEXT
{
	RouteCacheEntry *				pNextRCE;		// Next to same IP destination
	ATMARP_IP_ENTRY *				pIpEntry;		// Info about this IP destination

} ATMARP_RCE_CONTEXT, *PATMARP_RCE_CONTEXT;
 
//
//  A NULL pointer to RCE context info
//
#define NULL_PATMARP_RCE_CONTEXT		((PATMARP_RCE_CONTEXT)NULL)


#ifndef AA_MAX
// Private macro
#define AA_MAX(_a, _b)	((_a) > (_b) ? (_a) : (_b))
#endif


//
//  Physical address as reported to IP is the ESI part plus SEL byte.
//
#define AA_ATM_PHYSADDR_LEN				(AA_ATM_ESI_LEN+1)

//
//  Defaults for ATM adapter parameters
//
#define AA_DEF_ATM_LINE_RATE			  (ATM_USER_DATA_RATE_SONET_155*100/8)
#define AA_DEF_ATM_MAX_PACKET_SIZE				 (9188+8)		// Bytes

// Max and min (for ip/atm) permissible max-packet size.
//
#define AA_MAX_ATM_MAX_PACKET_SIZE				    65535		// With AAL5
#define AA_MIN_ATM_MAX_PACKET_SIZE				 AA_DEF_ATM_MAX_PACKET_SIZE

//
//  Defaults for configurable parameters
//
#define AA_DEF_MAX_HEADER_BUFFERS					3000
#define AA_DEF_HDRBUF_GROW_SIZE						  50
#define AA_DEF_MAX_PROTOCOL_BUFFERS					 100
#define AA_MAX_1577_CONTROL_PACKET_SIZE					\
					(AA_ARP_PKT_HEADER_LENGTH +			\
					 (4 * ATM_ADDRESS_LENGTH) +			\
					 (2 * sizeof(IP_ADDRESS)))

#ifdef IPMCAST
#define AA_MAX_2022_CONTROL_PACKET_SIZE					\
			AA_MAX(sizeof(AA_MARS_JOIN_LEAVE_HEADER), sizeof(AA_MARS_REQ_NAK_HEADER)) + \
					(2 * ATM_ADDRESS_LENGTH) +			\
					(2 * sizeof(IP_ADDRESS))

#else
#define AA_MAX_2022_CONTROL_PACKET_SIZE					0
#endif


#define AA_DEF_PROTOCOL_BUFFER_SIZE						\
			AA_MAX(AA_MAX_1577_CONTROL_PACKET_SIZE, AA_MAX_2022_CONTROL_PACKET_SIZE)

#define AA_DEF_PVC_ONLY_VALUE					((ULONG)FALSE)
#define AA_DEF_SELECTOR_VALUE						0x00

#define AA_DEF_SERVER_CONNECT_INTERVAL				   5		// Seconds
#define AA_DEF_SERVER_REGISTRATION_TIMEOUT			   3		// Seconds
#define AA_DEF_ADDRESS_RESOLUTION_TIMEOUT			   3		// Seconds
#define AA_DEF_ARP_ENTRY_AGING_TIMEOUT				 900		// Seconds (15 mins)
#define AA_DEF_VC_AGING_TIMEOUT						  60		// Seconds (1 min)
#define AA_DEF_INARP_WAIT_TIMEOUT					   5		// Seconds
#define AA_DEF_SERVER_REFRESH_INTERVAL				 900		// Seconds (15 mins)
#define AA_DEF_MIN_WAIT_AFTER_NAK				      10		// Seconds
#define AA_DEF_MAX_REGISTRATION_ATTEMPTS			   5
#define AA_DEF_MAX_RESOLUTION_ATTEMPTS				   4

#define AA_DEF_FLOWSPEC_SERVICETYPE		SERVICETYPE_BESTEFFORT
#define AA_DEF_FLOWSPEC_ENCAPSULATION	ENCAPSULATION_TYPE_LLCSNAP

#ifdef IPMCAST
#define AA_DEF_MARS_KEEPALIVE_TIMEOUT			     240		// Seconds (4 mins)
#define AA_DEF_MARS_JOIN_TIMEOUT					  10		// Seconds
#define AA_DEF_MARS_LEAVE_TIMEOUT					  10		// Seconds
#define AA_DEF_MULTI_TIMEOUT						  10		// Seconds
#define AA_DEF_MCAST_IP_ENTRY_AGING_TIMEOUT			1200		// Seconds (20 mins)
#define AA_DEF_MIN_MCAST_REVALIDATION_DELAY			   1		// Seconds
#define AA_DEF_MAX_MCAST_REVALIDATION_DELAY			  10		// Seconds
#define AA_DEF_MIN_MCAST_PARTY_RETRY_DELAY			   5		// Seconds
#define AA_DEF_MAX_MCAST_PARTY_RETRY_DELAY			  10		// Seconds
#define AA_DEF_MAX_JOIN_LEAVE_ATTEMPTS				   5
#endif // IPMCAST

//
//  Structure passed in as context in a QueryInfo for the ARP Table
//
typedef struct IPNMEContext {
	UINT				inc_index;
	PATMARP_IP_ENTRY	inc_entry;
} IPNMEContext;

#endif // __ATMARP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\cubdd.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	cubdd.h

Abstract:

	All CUB-DD related defines are here.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     09-16-96    Created

Notes:

--*/

#ifndef _ATMARPC__CUBDD_H
#define _ATMARPC__CUBDD_H


#ifdef CUBDD

//
//  Request to resolve an IP address to an ATM address.
//
typedef struct _ATMARP_REQUEST
{
	ULONG			IpAddress;
	ULONG			HwAddressLength;
	UCHAR			HwAddress[20];
}
ATMARP_REQUEST, *PATMARP_REQUEST;

//
//  The Address resolution IOCTL command code.
//
#define IOCTL_ATMARP_REQUEST   0x00000001


#endif // CUBDD

#endif // _ATMARPC__CUBDD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\arp\atmarpc\externs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	externs.h -- Extern declarations.

Abstract:

	All external declarations for ATMARP client modules (functions,
	variables) are here.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-09-96    Created

Notes:

--*/

#ifndef _ATMARP_EXTERNS__H
#define _ATMARP_EXTERNS__H

#ifndef EXTERN
#define EXTERN extern
#endif // EXTERN

//
//  --------------- From adapter.c ----------------------------
//



EXTERN
INT
AtmArpBindAdapterHandler(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					BindContext,
	IN	PNDIS_STRING				pDeviceName,
	IN	PVOID						SystemSpecific1,
	IN	PVOID						SystemSpecific2
);

EXTERN
VOID
AtmArpUnbindAdapterHandler(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					UnbindContext
);

EXTERN
VOID
AtmArpCompleteUnbindAdapter(
	IN	PATMARP_ADAPTER				pAdapter
);

EXTERN
VOID
AtmArpOpenAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status,
	IN	NDIS_STATUS					OpenErrorStatus
);

EXTERN
VOID
AtmArpCloseAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmArpSendCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmArpTransferDataCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status,
	IN	UINT						BytesTransferred
);

EXTERN
VOID
AtmArpResetCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmArpRequestCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_STATUS					Status
);

EXTERN
NDIS_STATUS
AtmArpReceiveHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN  NDIS_HANDLE             	MacReceiveContext,
	IN  PVOID                   	pHeaderBuffer,
	IN  UINT                    	HeaderBufferSize,
	IN  PVOID                   	pLookAheadBuffer,
	IN  UINT                    	LookaheadBufferSize,
	IN  UINT                    	PacketSize
);

EXTERN
VOID
AtmArpReceiveCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
);

EXTERN
INT
AtmArpReceivePacketHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmArpStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
);

EXTERN
VOID
AtmArpStatusCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
);

EXTERN
VOID
AtmArpCoSendCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
);


EXTERN
VOID
AtmArpCoStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
);

#ifdef _PNP_POWER_
EXTERN
NDIS_STATUS
AtmArpPnPReconfigHandler(
	IN	PATMARP_ADAPTER				pAdapter OPTIONAL,
	IN	PNET_PNP_EVENT				pNetPnPEvent
);

EXTERN
NDIS_STATUS
AtmArpPnPEventHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNET_PNP_EVENT				pNetPnPEvent
);
#endif // _PNP_POWER_

EXTERN
NDIS_STATUS
AtmArpSendAdapterNdisRequest(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
);

EXTERN
NDIS_STATUS
AtmArpGetAdapterInfo(
	IN	PATMARP_ADAPTER			pAdapter
);


EXTERN
NDIS_STATUS
AtmArpSendNdisRequest(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
);

EXTERN
VOID
AtmArpShutdownInterface(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
BOOLEAN
AtmArpIsDeviceAlreadyBound(
	IN	PNDIS_STRING				pDeviceName
);

#if ATMOFFLOAD

NDIS_STATUS
AtmArpQueryAndEnableOffload(
	IN	PATMARP_ADAPTER				pAdapter
);

VOID
AtmArpDisableOffload(
	IN	PATMARP_ADAPTER				pAdapter
);

#endif // ATMOFFLOAD

//
//  --------------- From arpcfg.c ----------------------------
//


EXTERN
NDIS_STATUS
AtmArpCfgReadAdapterConfiguration(
	IN	PATMARP_ADAPTER				pAdapter
);

EXTERN
NDIS_HANDLE
AtmArpCfgOpenLISConfiguration(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	UINT						LISNumber,
	OUT	PNDIS_STRING				pIPConfigString
);

EXTERN
NDIS_HANDLE
AtmArpCfgOpenLISConfigurationByName(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	PNDIS_STRING				pIPConfigString
);


EXTERN
VOID
AtmArpCfgCloseLISConfiguration(
	NDIS_HANDLE						LISConfigHandle
);

EXTERN
NDIS_STATUS
AtmArpCfgReadLISConfiguration(
	IN	NDIS_HANDLE					LISConfigHandle,
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpCfgReadAtmAddressList(
	IN OUT	PATMARP_SERVER_LIST		pServerList,
	IN		PWCHAR					pListKeyName,
	IN		NDIS_HANDLE				LISConfigHandle
);

EXTERN
NDIS_STATUS
AtmArpCfgReadSAPList(
	IN	PATMARP_INTERFACE			pInterface,
	IN	NDIS_HANDLE					LISConfigHandle
);

EXTERN
NDIS_STATUS
AtmArpCfgReadAtmAddress(
	IN	NDIS_HANDLE					ConfigHandle,
	IN	PATM_ADDRESS				pAtmAddress,
	IN	PWCHAR						pValueName
);

EXTERN
NDIS_STATUS
AtmArpCfgReadQosHeuristics(
	IN	NDIS_HANDLE					LISConfigHandle,
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpCfgReadStaticArpEntries(
	IN		NDIS_HANDLE				LISConfigHandle,
	IN		PATMARP_INTERFACE		pInterface
);

EXTERN
BOOLEAN
AtmArpConvertStringToIPAddress(
    IN		PWCHAR				AddressString,
	OUT		PULONG				IpAddress
);

//
//  --------------- From arpif.c ----------------------------
//

EXTERN IP_MASK  AtmArpIPMaskTable[];


INT
AtmArpIfDynRegister(
	IN	PNDIS_STRING				pAdapterString,
	IN	PVOID						IPContext,
	IN	struct _IP_HANDLERS *		pIpHandlers,
	IN	struct LLIPBindInfo *		pBindInfo,
	IN	UINT						InterfaceNumber
);


EXTERN
VOID
AtmArpIfOpen(
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpIfClose(
	IN	PVOID						Context
);


EXTERN
UINT
AtmArpIfAddAddress(
	IN	PVOID						Context,
	IN	UINT						AddressType,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
#ifndef BUILD_FOR_1381
	,
	IN	PVOID						Context2
#endif // BUILD_FOR_1381
);


EXTERN
UINT
AtmArpIfDelAddress(
	IN	PVOID						Context,
	IN	UINT						AddressType,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
);


NDIS_STATUS
AtmArpIfMultiTransmit(
	IN	PVOID						Context,
	IN	PNDIS_PACKET *				pNdisPacketArray,
	IN	UINT						NumberOfPackets,
	IN	IP_ADDRESS					Destination,
	IN	RouteCacheEntry *			pRCE		OPTIONAL
#if P2MP
	,
	IN  void *                  ArpCtxt
#endif
);


EXTERN
NDIS_STATUS
AtmArpIfTransmit(
	IN	PVOID						Context,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	IP_ADDRESS					Destination,
	IN	RouteCacheEntry *			pRCE		OPTIONAL
#if P2MP
	,
	IN  void *                  ArpCtxt
#endif
);

EXTERN
NDIS_STATUS
AtmArpIfTransfer(
	IN	PVOID						Context,
	IN	NDIS_HANDLE					Context1,
	IN	UINT						ArpHdrOffset,
	IN	UINT						ProtoOffset,
	IN	UINT						BytesWanted,
	IN	PNDIS_PACKET				pNdisPacket,
	OUT	PUINT						pTransferCount
);

EXTERN
VOID
AtmArpIfInvalidate(
	IN	PVOID						Context,
	IN	RouteCacheEntry *			pRCE
);


EXTERN
BOOLEAN
AtmArpUnlinkRCE(
	IN	RouteCacheEntry *			pRCE,
	IN	PATMARP_IP_ENTRY			pIpEntry
);

EXTERN
VOID
AtmArpLinkRCE(
	IN	RouteCacheEntry *			pRCE,
	IN	PATMARP_IP_ENTRY			pIpEntry	LOCKIN LOCKOUT
);

EXTERN
INT
AtmArpIfQueryInfo(
	IN		PVOID					Context,
	IN		TDIObjectID *			pID,
	IN		PNDIS_BUFFER			pNdisBuffer,
	IN OUT	PUINT					pBufferSize,
	IN		PVOID					QueryContext
);


EXTERN
INT
AtmArpIfSetInfo(
	IN		PVOID					Context,
	IN		TDIObjectID *			pID,
	IN		PVOID					pBuffer,
	IN		UINT					BufferSize
);


EXTERN
INT
AtmArpIfGetEList(
	IN		PVOID					Context,
	IN		TDIEntityID *			pEntityList,
	IN OUT	PUINT					pEntityListSize
);

#ifdef _PNP_POWER_
EXTERN
VOID
AtmArpIfPnPComplete(
	IN	PVOID						Context,
	IN	NDIS_STATUS					Status,
	IN	PNET_PNP_EVENT				pNetPnPEvent
);
#endif // _PNP_POWER_


#ifdef PROMIS
EXTERN
NDIS_STATUS
AtmArpIfSetNdisRequest(
	IN	PVOID						Context,
	IN	NDIS_OID					Oid,
	IN	UINT						On
);
#endif // PROMIS

EXTERN
VOID
AtmArpFreeSendPackets(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				PacketList,
	IN	BOOLEAN						HdrPresent
);

EXTERN
NDIS_STATUS
AtmArpSendBroadcast(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FILTER_SPEC			pFilterSpec
);

EXTERN
BOOLEAN
AtmArpIsBroadcastIPAddress(
	IN	IP_ADDRESS					Address,
	IN	PATMARP_INTERFACE			pInterface		LOCKIN LOCKOUT
);

EXTERN
BOOLEAN
AtmArpValidateTableContext(
	IN	PVOID						QueryContext,
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN *					pIsValid
);

EXTERN
BOOLEAN
AtmArpReadNextTableEntry(
	IN	PVOID						QueryContext,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PUCHAR						pSpace
);

//
//  --------------- From arppkt.c ----------------------------
//

EXTERN
VOID
AtmArpSendPacketOnVc(
	IN	PATMARP_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
PNDIS_PACKET
AtmArpBuildARPPacket(
	IN	USHORT						OperationType,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PUCHAR *					ppArpPacket,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
);

EXTERN
VOID
AtmArpSendARPRequest(
	PATMARP_INTERFACE				pInterface,
	IP_ADDRESS UNALIGNED *			pSrcIPAddress,
	IP_ADDRESS UNALIGNED *			pDstIPAddress
);

EXTERN
VOID
AtmArpSendInARPRequest(
	IN	PATMARP_VC					pVc
);

EXTERN
UINT
AtmArpCoReceivePacketHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmArpHandleARPPacket(
	IN	PATMARP_VC					pVc,
	IN	PAA_PKT_LLC_SNAP_HEADER		pPktHeader,
	IN	ULONG						PacketLength
);

EXTERN
VOID
AtmArpHandleARPRequest(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
);

EXTERN
VOID
AtmArpHandleARPReply(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents,
	IN	BOOLEAN						SrcIPAddressIsOurs,
	IN	BOOLEAN						SrcAtmAddressIsOurs
);

EXTERN
VOID
AtmArpHandleARPNAK(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
);

EXTERN
VOID
AtmArpHandleInARPRequest(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
);

EXTERN
VOID
AtmArpHandleInARPReply(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
);


//
//  --------------- From arpproc.c ----------------------------
//
EXTERN
VOID
AtmArpStartRegistration(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
void
AtmArpRegisterOtherIPAddresses(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpRetryServerRegistration(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpHandleServerRegistrationFailure(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_VC					pVc			OPTIONAL
);

EXTERN
BOOLEAN
AtmArpIsZeroIPAddress(
	IN	UCHAR UNALIGNED *			pIPAddress
);

EXTERN
BOOLEAN
AtmArpIsLocalIPAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	UCHAR UNALIGNED *			pIPAddress
);

EXTERN
BOOLEAN
AtmArpIsLocalAtmAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PUCHAR						pAtmAdd