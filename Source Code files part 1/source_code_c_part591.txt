APS2_OPAQUE;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_WRITEONLY)
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_WRITEONLY;
        }

        // Specify new usages for DX8+ drivers
        if (!(pCreateSurface->dwUsage & D3DUSAGE_LOCK) &&
            !(pCreateSurface->dwUsage & D3DUSAGE_LOADONCE))
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_NOTUSERLOCKABLE;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_DISCARD)
        {
            DDASSERT(pCreateSurface->Type != D3DRTYPE_TEXTURE);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_CUBETEXTURE);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_VOLUMETEXTURE);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_VOLUME);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_VERTEXBUFFER);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_INDEXBUFFER);

            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_DISCARDBACKBUFFER;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_POINTS)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_POINTS;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_RTPATCHES)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_RTPATCHES;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_NPATCHES)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_NPATCHES;
        }
    }
    else // Pre-DX8 driver
    {
        // We allow LOADONCE through only for textures
        if ((pCreateSurface->Type == D3DRTYPE_TEXTURE) || 
            (pCreateSurface->Type == D3DRTYPE_CUBETEXTURE) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUME))
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_LOADONCE)
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_OPAQUE;
            }
        }
        // We allow WRITEONLY through only for VBs
        if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_WRITEONLY)
            {
                pddsd2->ddsCaps.dwCaps |= DDSCAPS_WRITEONLY;
            }
        }
    }

    switch (pCreateSurface->Pool)
    {
    case D3DPOOL_LOCALVIDMEM:
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
        break;
    case D3DPOOL_NONLOCALVIDMEM:
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
        break;
    case D3DPOOL_SYSTEMMEM:
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        break;
    case D3DPOOL_MANAGED:
        // We should only see this for DX8+ drivers <kd>
        DDASSERT(pDevice->DriverLevel >= 8);            
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_TEXTUREMANAGE;
        break;
    case D3DPOOL_DEFAULT:
        pCreateSurface->Pool = D3DPOOL_LOCALVIDMEM;
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        break;
    default:
        /* Unknown Pool?? */
        DDASSERT(FALSE);
        break;
    }
    pddsd2->dwFlags |= DDSD_CAPS;

    // Convert the pixel format:
    if ((pCreateSurface->Format != D3DFMT_UNKNOWN) &&
        (pCreateSurface->Format != D3DFMT_VERTEXDATA) &&
        (pCreateSurface->Format != D3DFMT_INDEX16) &&
        (pCreateSurface->Format != D3DFMT_INDEX32) &&
        !(pddsd2->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
    {
        pddsd2->dwFlags |= DDSD_PIXELFORMAT;

        // For non-textures, we want to promote X8R8G8B8 to A8R8G8B8 in some cases;
        // this allows things like RTs and Backbuffers to get created matching the
        // primary which is more consistent with typical DX7 usage.
        if (FormatCompatibleWithDisplayFormat(pDevice, (D3DFORMAT)pCreateSurface->Format) &&
            (pCreateSurface->Type == D3DRTYPE_SURFACE))
        {
            //Surface looks like primary:
            ConvertToOldFormat(&pddsd2->ddpfPixelFormat, pDevice->DisplayFormatWithAlpha);
        }
        else
        {
            ConvertToOldFormat(&pddsd2->ddpfPixelFormat, (D3DFORMAT)pCreateSurface->Format);
        }
    }

    if (!(pddsd2->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
    {
        pddsd2->dwHeight = pCreateSurface->pSList[0].cpHeight;
        pddsd2->dwWidth = pCreateSurface->pSList[0].cpWidth;
        pddsd2->dwFlags |= DDSD_HEIGHT | DDSD_WIDTH;

        if (pddsd2->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
        {
            pddsd2->dwHeight = 0;
            pddsd2->dwFlags &= ~DDSD_HEIGHT;
        }
    }
    if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
    {
        pddsd2->dwFVF = pCreateSurface->dwFVF;
        pddsd2->dwFlags |= DDSD_FVF;
    }
    if (pddsd2->ddsCaps.dwCaps2 & DDSCAPS2_VOLUME)
    {
        pddsd2->dwDepth = pCreateSurface->pSList[0].cpDepth;
        pddsd2->dwFlags |= DDSD_DEPTH;
    }
}


DWORD InitSoftwareSurface(PD3D8_CREATESURFACEDATA pCreateSurface,
                          DWORD                   SurfIndex,
                          DDSURFACEDESC2*         pddsd2,
                          DDSURFACE*              pSurf,
                          DDSURFACE*              pPrevious)
{
    LPDDRAWI_DDRAWSURFACE_INT   pInt;
    LPDDRAWI_DDRAWSURFACE_LCL   pLcl;
    BYTE *                      pTemp;
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;

    pInt = MemAlloc( sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                     sizeof(DDRAWI_DDRAWSURFACE_GBL) +
                     sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                     sizeof(DDRAWI_DDRAWSURFACE_INT));
    if (pInt == NULL)
    {
        return DDERR_OUTOFMEMORY;
    }
    pTemp = (BYTE*) pInt;
    pTemp += sizeof(DDRAWI_DDRAWSURFACE_INT);
    pInt->lpLcl = (LPDDRAWI_DDRAWSURFACE_LCL) pTemp;
    pLcl = pInt->lpLcl;
    pTemp += sizeof(DDRAWI_DDRAWSURFACE_LCL);
    pLcl->lpGbl = (LPDDRAWI_DDRAWSURFACE_GBL) pTemp;
    pTemp += sizeof(DDRAWI_DDRAWSURFACE_GBL);
    pLcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE) pTemp;

    memcpy(&pInt->lpLcl->lpGbl->ddpfSurface, &pddsd2->ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    if (pddsd2->dwFlags & DDSD_PIXELFORMAT)
    {
        pLcl->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
    }
    pLcl->lpGbl->wWidth                 = (WORD) pCreateSurface->pSList[SurfIndex].cpWidth;
    pLcl->lpGbl->wHeight                = (WORD) pCreateSurface->pSList[SurfIndex].cpHeight;

    pLcl->ddsCaps.dwCaps                = pddsd2->ddsCaps.dwCaps;
    pLcl->lpSurfMore->ddsCapsEx.dwCaps2 = pddsd2->ddsCaps.dwCaps2;
    pLcl->lpSurfMore->ddsCapsEx.dwCaps3 = DDSCAPS3_MULTISAMPLE_MASK & (DWORD) pCreateSurface->MultiSampleType;
    pLcl->lpSurfMore->ddsCapsEx.dwCaps4 = pddsd2->ddsCaps.dwCaps4;
    pLcl->lpSurfMore->dwSurfaceHandle   = pSurf->dwCookie;

    pLcl->lpSurfMore->lpDD_lcl      = pDevice->pSwDD->lpLcl;

    if (pSurf->Pool == D3DPOOL_SYSTEMMEM)
    {
        pLcl->lpGbl->fpVidMem           = (FLATPTR) pCreateSurface->pSList[SurfIndex].pbPixels;
        pLcl->lpGbl->lPitch             = pCreateSurface->pSList[SurfIndex].iPitch;
    }

    if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
        (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        pLcl->lpGbl->lSlicePitch = pCreateSurface->pSList[SurfIndex].iSlicePitch;
        pLcl->lpSurfMore->ddsCapsEx.dwCaps4 =
            MAKELONG((WORD)(pCreateSurface->pSList[SurfIndex].cpDepth),0);
    }

    // If it is a cube-map face, fix up the face flags in caps2.
    if (pCreateSurface->Type == D3DRTYPE_CUBETEXTURE) 
    {
        int MipLevels;

        if (pCreateSurface->dwSCnt>6)
            pLcl->ddsCaps.dwCaps |= DDSCAPS_MIPMAP;

        MipLevels = pCreateSurface->dwSCnt/6; //since all faces are always present in DX8
        
        DDASSERT(MipLevels>=1);
        
        //the first n (where n is mip depth) faces are +x, etc.
        pLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_CUBEMAP;
        pLcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~(DDSCAPS2_CUBEMAP_ALLFACES);
        pLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= 
            dwOrderedFaces[SurfIndex/MipLevels];
        
        //every MipLevels'th surface is a top-level face,
        if (SurfIndex % MipLevels)
        {
            // Mark non-top levels as being a sub-level
            pLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
        }
    }
    // If it is a texture, fix up the flags in caps2.
    else if ((pCreateSurface->Type == D3DRTYPE_TEXTURE) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUME))
    {
        if( SurfIndex > 0 )
        {
            pLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
        }
    }
    
    pSurf->pTempHeavy = pInt;

    return DD_OK;
}


/*****************************Private*Routine******************************\
* SelectAttachmentSurface
*
* Returns an index into the surface creation list that indicates which
* surface this surface should be attached to. For mipmap sublevels this is
* always the preceding surface. For cubemaps, each face attaches to the
* root face (element 0).
*
* History:
*  21-Mar-2000 -by- Jeff Noyle [jeffno]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "SelectAttachmentSurface"

UINT SelectAttachmentSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    UINT                    iThis)
{

    //We should never be called to find the attachment from the root face.
    DDASSERT( iThis > 0);

    if ((pCreateSurface->Type == D3DRTYPE_CUBETEXTURE) &&
        ((iThis % (pCreateSurface->dwSCnt/6)) == 0) //which means we're looking at a top-level face
        )
    {
        //... so we attach this face to the root
        return 0;
    }
    else
    {
        // nope its just a mip sublevel, so we attach to the previous
        return iThis-1;
    }
}

void ExtractLightweightInfo (DDSURFACE *pSurf, LPDDRAWI_DDRAWSURFACE_INT pInt)
{
    LIGHTWEIGHTSURFACE* pLight = pSurf->Surface.pLight;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

    pLight->LclFlags                = pInt->lpLcl->dwFlags;
    pLight->LclCaps1                = pInt->lpLcl->ddsCaps.dwCaps;
    pLight->LclReserved1            = pInt->lpLcl->dwReserved1;
    pLight->LclModeCreatedIn        = pInt->lpLcl->dwModeCreatedIn;
    pLight->LclBackBufferCount      = pInt->lpLcl->dwBackBufferCount;

    pLight->GblFlags                = pInt->lpLcl->lpGbl->dwGlobalFlags;
    pLight->GblPitch                = pInt->lpLcl->lpGbl->lPitch;
    if (pSurf->Pitch == 0)
    {
        pSurf->Pitch = pLight->GblPitch;
    }
    pLight->GblWidth                = pInt->lpLcl->lpGbl->wWidth;
    pLight->GblReserved1            = pInt->lpLcl->lpGbl->dwReserved1;
    if (pLight->LclFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        ConvertFromOldFormat(&pInt->lpLcl->lpGbl->ddpfSurface, 
            &pLight->GblFormat);
    }
    else
    {
        pLight->GblFormat = D3DFMT_UNKNOWN;
    }
    pLight->pGblVidMemHeap          = pInt->lpLcl->lpGbl->lpVidMemHeap;
    pLight->fpGblVidMem             = pInt->lpLcl->lpGbl->fpVidMem;

    pLight->MoreCaps2               = pInt->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2;
    pLight->MoreCaps3               = pInt->lpLcl->lpSurfMore->ddsCapsEx.dwCaps3;
    pLight->MoreCaps4               = pInt->lpLcl->lpSurfMore->ddsCapsEx.dwCaps4;
    pLight->MoreRgjunc              = pInt->lpLcl->lpSurfMore->rgjunc;
    if ((pLight->LclCaps1 & DDSCAPS_MIPMAP) ||
        (pLight->MoreCaps2 & DDSCAPS2_VOLUME))
    {
        pLight->MoreMipMapCount     = pInt->lpLcl->lpSurfMore->dwMipMapCount;
    }
    else
    {
        pLight->MoreFVF             = pInt->lpLcl->lpSurfMore->dwFVF;
    }

    lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE (pInt->lpLcl->lpGbl);
    if (lpGblMore != NULL)
    {
        pLight->GblMoreDriverReserved   = lpGblMore->dwDriverReserved;
        pLight->GblMoreContentsStamp    = lpGblMore->dwContentsStamp;
        pLight->pGblMoreUnswappedDriverReserved = lpGblMore->lpvUnswappedDriverReserved;
        pLight->fpGblMoreAliasOfVidMem  = lpGblMore->fpAliasOfVidMem;
        pLight->cGblMorePageUnlocks     = lpGblMore->cPageUnlocks;
    }

    if (pLight->LclCaps1 & DDSCAPS_NONLOCALVIDMEM)
    {
        if (lpGblMore != NULL)
        {
            pLight->fpGblMorePhysicalVidMem = lpGblMore->fpPhysicalVidMem;
        }
    }
    else if (pLight->LclCaps1 & DDSCAPS_LOCALVIDMEM)
    {
        if (lpGblMore != NULL)
        {
            pLight->fpGblMoreAliasedVidMem  = lpGblMore->fpAliasedVidMem;
        }
    }
    else
    {
        pLight->MoreBytesAllocated      = pInt->lpLcl->lpSurfMore->dwBytesAllocated;
    }

    pSurf->Height   = pInt->lpLcl->lpGbl->wHeight;
    pSurf->dwCookie = pInt->lpLcl->lpSurfMore->dwSurfaceHandle;
}


void DiscardHeavyweightMemory( LPDDRAWI_DDRAWSURFACE_INT pInt)
{
    if (pInt->lpLcl->lpSurfMore->slist != NULL)
    {
        MemFree (pInt->lpLcl->lpSurfMore->slist);
    }
    MemFree (pInt->lpLcl);
    MemFree (pInt);
}


DWORD APIENTRY DdCreateSurface( PD3D8_CREATESURFACEDATA pCreateSurface )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int = pDevice->pDD;
    HRESULT                     hr;
    DWORD                       i;
    PDDSURFACE                  pSurf;
    LPDIRECTDRAWSURFACE         lpDDSurface;
    DWORD                       dwNumToCreate;
    DDSURFACEDESC2              ddsd2;
    DWORD                       NextWidth;
    DWORD                       NextHeight;
    DEFERREDCREATE*             pDefCreate;

    ENTER_DDRAW();
    BuildSurfaceDesc (pCreateSurface, &ddsd2);

	dwNumToCreate = pCreateSurface->dwSCnt;

    // Allocate the internal surface structures for each surface in the chain
    // and initialize it if we are not reusing the surface

    if (!pCreateSurface->bReUse)
    {
        NextWidth = ddsd2.dwWidth;
        NextHeight = ddsd2.dwHeight;        
        for (i = 0; i < dwNumToCreate; i++)
        {
            pSurf = (PDDSURFACE) MemAlloc(sizeof(DDSURFACE));
            if (pSurf == NULL)
            {
                hr = DDERR_OUTOFMEMORY;
                goto CreateErrorCleanup;
            }
            pSurf->Pool = pCreateSurface->Pool;
            pSurf->Format = pCreateSurface->Format;
            pSurf->Type = pCreateSurface->Type;

            // For volume textures, we need to know the depth to handle lost
            // devices (for everything else we need to height).  To save space,
            // we will re-use the same variable.

            if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pSurf->Height = pCreateSurface->pSList[i].cpDepth;
            }
            else
            {
                pSurf->Height = pCreateSurface->pSList[i].cpHeight;
            }
            pCreateSurface->pSList[i].hKernelHandle = (HANDLE) pSurf;
            pSurf->pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;

            // DX6 drivers cannot handle deep mipmaps, but we want to hide this from 
            // the runtime, so we need to determine if the current level is a dummy
            // level

            if ((pDevice->DriverLevel == 6) && 
                (ddsd2.ddsCaps.dwCaps & DDSCAPS_MIPMAP))
            {
                if ((pCreateSurface->pSList[i].cpWidth == NextWidth) &&
                    (pCreateSurface->pSList[i].cpHeight == NextHeight))
                {
                    // This level is OK, so mark it as such
                    ddsd2.dwMipMapCount = i + 1;
                }
                else
                {
                    pSurf->dwFlags |= DDSURFACE_DUMMY;
                    if (i == 1)
                    {
                        // If there's only one valid level, then don't call it
                        // a mipmap
                        ddsd2.ddsCaps.dwCaps &= ~DDSCAPS_COMPLEX | DDSCAPS_MIPMAP;
                        ddsd2.dwFlags &= ~DDSD_MIPMAPCOUNT;
                    }
                }
                NextWidth /= 2;
                NextHeight /= 2;
            }

            // Now figure out if this is a software driver
            // surface, or a HAL surface.

            if (IS_SOFTWARE_DRIVER(pCreateSurface->hDD) &&
                !(pCreateSurface->dwUsage & D3DUSAGE_PRIMARYSURFACE) &&
                !(pCreateSurface->dwUsage & D3DUSAGE_OFFSCREENPLAIN))
            {
                // If they are running w/ a software driver (refrast, RGB HEL, etc.),
                // we will not allow any surfaces to be created in video memory except
                // for the primary flipping chain. And also for surfaces marked
                // D3DUSAGE_OFFSCREENPLAIN (which are used for the cursors)

                pSurf->dwFlags |= DDSURFACE_SOFTWARE;
            }
            else
            {
                pSurf->dwFlags |= DDSURFACE_HAL;
            }

            if (pCreateSurface->bTreatAsVidMem == TRUE)
            {
                // For objects that should be treated as non-persistent
                // i.e. Reset fails unless these are all freed; we
                // set a flag here and check it in DoVidMemSurfacesExist()
                pSurf->dwFlags |= DDSURFACE_TREATASVIDMEM;
            }

            if (pDevice->bLightweight && IsLightweightSurface(pDevice, &ddsd2, pCreateSurface->Format))
            {
                pSurf->dwFlags |= DDSURFACE_LIGHTWEIGHT;
                pSurf->Surface.pLight = (LIGHTWEIGHTSURFACE*) MemAlloc(sizeof(LIGHTWEIGHTSURFACE));
                if (pSurf->Surface.pLight == NULL)
                {
                    hr = DDERR_OUTOFMEMORY;
                    goto CreateErrorCleanup;
                }
            }
            else
            {

                pSurf->dwFlags |= DDSURFACE_HEAVYWEIGHT;
            }

            // Software surfaces are special cased because we want to call the software
            // driver for Create and CreateEx rather than the real driver.

            if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
            {
                if ((ddsd2.ddsCaps.dwCaps & (DDSCAPS_TEXTURE       |
                                            DDSCAPS_EXECUTEBUFFER |
                                            DDSCAPS_3DDEVICE      |
                                            DDSCAPS_ZBUFFER)) &&
                    (pCreateSurface->Type != D3DRTYPE_IMAGESURFACE))
                {
                    pSurf->dwCookie = GetDX7SurfaceHandle(pCreateSurface->hDD);
                }

                hr = InitSoftwareSurface(pCreateSurface,
                                         i,
                                         &ddsd2,
                                         pSurf,
                                         i > 0 ? pCreateSurface->pSList[i].hKernelHandle : NULL);
                if (hr != DD_OK)
                {
                    goto CreateErrorCleanup;
                }
            }
        }
    }
    else
    {
        DDASSERT(pCreateSurface->Pool == D3DPOOL_MANAGED);
    }

    pSurf = (DDSURFACE*) pCreateSurface->pSList[0].hKernelHandle;
    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        if (pCreateSurface->Pool != D3DPOOL_SYSTEMMEM)
        {
            // There is a descrepancy in the surface desc that CreateSurface
            // expects and the driver expects, so we will adjust it here for
            // the driver.

            if ((ddsd2.dwFlags & DDSD_WIDTH) &&
                !(ddsd2.dwFlags & DDSD_HEIGHT))
            {
                ddsd2.dwFlags |= DDSD_HEIGHT;
                ddsd2.dwHeight = 1;
            }

            hr = SwDDICreateSurface(pCreateSurface, &ddsd2);
            if (hr != DD_OK)
            {
                goto CreateErrorCleanup;
            }
            for (i = 0; i < pCreateSurface->dwSCnt; i++)
            {
                ((DDSURFACE*)pCreateSurface->pSList[i].hKernelHandle)->dwFlags |= 
                    DDSURFACE_CREATECOMPLETE;
            }
        }

        // We've already created the object so all
        // we have to do is call CreateSurfaceEx
        if (pSurf->dwCookie != 0)
        {
            // If it's a software driver, we may need to attach surfaces

            for (i = 1; i < pCreateSurface->dwSCnt; i++)
            {
                SwDDIAttachSurfaces (
                    ((DDSURFACE*)pCreateSurface->pSList[
                        SelectAttachmentSurface(pCreateSurface,i)
                        ].hKernelHandle)->pTempHeavy->lpLcl,
                    ((DDSURFACE*)pCreateSurface->pSList[i].hKernelHandle)->pTempHeavy->lpLcl);
            }
            SwDDICreateSurfaceEx (pDevice->pSwDD->lpLcl,
                pSurf->pTempHeavy->lpLcl);
            pSurf->dwFlags |= DDSURFACE_CREATEEX;
        }

        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            LPATTACHLIST    pAttach;
            LPATTACHLIST    pAttachTemp;

            pSurf = (DDSURFACE*)pCreateSurface->pSList[i].hKernelHandle;

            // For a sw driver, always destroy the attached list now.  
            // It serves no purpose after CreateSurfaceEx is called.

            if (pSurf->pTempHeavy->lpLcl->lpAttachList != NULL)
            {
                pAttach = pSurf->pTempHeavy->lpLcl->lpAttachList->lpLink;
                while (pAttach != NULL)
                {
                    pAttachTemp = pAttach;
                    pAttach = pAttach->lpLink;
                    MemFree(pAttachTemp);
                }
                MemFree(pSurf->pTempHeavy->lpLcl->lpAttachList);
                pSurf->pTempHeavy->lpLcl->lpAttachList = NULL;
            }
            if (pSurf->pTempHeavy->lpLcl->lpAttachListFrom != NULL)
            {
                pAttach = pSurf->pTempHeavy->lpLcl->lpAttachListFrom->lpLink;
                while (pAttach != NULL)
                {
                    pAttachTemp = pAttach;
                    pAttach = pAttach->lpLink;
                    MemFree(pAttachTemp);
                }
                MemFree(pSurf->pTempHeavy->lpLcl->lpAttachListFrom);
                pSurf->pTempHeavy->lpLcl->lpAttachListFrom = NULL;
            }

            pSurf->iSlicePitch = pSurf->pTempHeavy->lpLcl->lpGbl->lSlicePitch;
            pSurf->pTempHeavy->lpLcl->lpGbl->lSlicePitch = 0;   
            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
            {
                ExtractLightweightInfo (pSurf, pSurf->pTempHeavy);
                MemFree (pSurf->pTempHeavy);
            }
            else
            {
                pSurf->Surface.pHeavy = pSurf->pTempHeavy;
            }
            pSurf->pTempHeavy = NULL;
        }
    }
    else
    {
        LPDDSURFACEINFO pSysMem = NULL;
        BOOL            bLost;

        // If it's a sysmem surface, we want them to use the memory that we
        // have already allocated, so we need to setup an array of pointers.

        if ((pCreateSurface->Pool == D3DPOOL_SYSTEMMEM) ||
            (ddsd2.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME))
        {
            pSysMem = pCreateSurface->pSList;
        }

        // If we are creating a vidmem surface, we need to check for device lost
        // and if it's lost, we don't want to create the surface, but to instead
        // allocate a private buffer that we can return when lock is called.  We
        // do not want to fail the call just because the device is lost.

        ENTER_WIN16LOCK();
        bLost = CheckForDeviceLost(pDevice);

        // Special early out. If reuse is true, we haven't done anything yet (to
        // verify this, trace code above) so all we need to do is to return SURFACELOST
        // and not worry about jumping to CreateErrorCleanup below.
        if (bLost && pCreateSurface->bReUse)
        {
            DDASSERT(!IS_SOFTWARE_DRIVER_SURFACE(pSurf));
            DDASSERT(pCreateSurface->Pool == D3DPOOL_MANAGED);
            LEAVE_WIN16LOCK();
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        if ((pCreateSurface->Pool != D3DPOOL_SYSTEMMEM) &&
            bLost)
        {
            DWORD                       j;
            DDASSERT(pCreateSurface->bReUse == FALSE);
            for (i = 0; i < pCreateSurface->dwSCnt; i++)
            {
                pSurf = (PDDSURFACE) pCreateSurface->pSList[i].hKernelHandle;

                pSurf->Pitch = pCreateSurface->pSList[i].cpWidth * 8;
                pSurf->iSlicePitch = pSurf->Pitch * pCreateSurface->pSList[i].cpHeight;
                if (!(pSurf->dwFlags & DDSURFACE_DUMMY))
                {
                    if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                        (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
                    {
                        pSurf->fpVidMem = (char*)
                            MemAlloc(pSurf->iSlicePitch * pSurf->Height);
                    }
                    else
                    {
                        pSurf->fpVidMem = (char*)
                            MemAlloc(pSurf->Pitch * pSurf->Height);
                    }


                    if (pSurf->fpVidMem == (char*) NULL)
                    {
                        DWORD j;

                        for (j = 0; j < i; j++)
                        {
                            pSurf = (PDDSURFACE) pCreateSurface->pSList[i].hKernelHandle;
                            MemFree (pSurf->fpVidMem);
                        }
                        hr = DDERR_OUTOFMEMORY;
                        LEAVE_WIN16LOCK();
                        goto CreateErrorCleanup;
                    }
                    else
                    {
                        pSurf->dwFlags |= DDSURFACE_SYSMEMALLOCATED;
                    }
                }
            }

            // If the surface is driver managed, we save the creation info so that 
            // we can retry the creation at reset time
            if (ddsd2.ddsCaps.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
            {
                DDASSERT(pCreateSurface->Pool == D3DPOOL_MANAGED);
                pDefCreate = (PDEFERREDCREATE)MemAlloc(sizeof(DEFERREDCREATE));
                if (pDefCreate == NULL)
                {
                    // Cleanup stuff that we allocated above
                    for (i = 0; i < pCreateSurface->dwSCnt; ++i)
                    {
                        pSurf = (PDDSURFACE) pCreateSurface->pSList[i].hKernelHandle;
                        MemFree(pSurf->fpVidMem);
                        pSurf->dwFlags &= ~DDSURFACE_SYSMEMALLOCATED;
                    }
                    hr = DDERR_OUTOFMEMORY;
                    LEAVE_WIN16LOCK();
                    goto CreateErrorCleanup;
                }
                
                // Copy
                pDefCreate->CreateData = *pCreateSurface;
                
                pDefCreate->CreateData.pSList = (LPDDSURFACEINFO)MemAlloc(sizeof(DDSURFACEINFO) * pCreateSurface->dwSCnt);
                if (pDefCreate->CreateData.pSList == NULL)
                {
                    // Cleanup stuff that we allocated above
                    MemFree(pDefCreate);
                    for (i = 0; i < pCreateSurface->dwSCnt; ++i)
                    {
                        pSurf = (PDDSURFACE) pCreateSurface->pSList[i].hKernelHandle;
                        MemFree(pSurf->fpVidMem);
                        pSurf->dwFlags &= ~DDSURFACE_SYSMEMALLOCATED;
                    }
                    hr = DDERR_OUTOFMEMORY;
                    LEAVE_WIN16LOCK();
                    goto CreateErrorCleanup;
                }
                
                // Copy
                CopyMemory(pDefCreate->CreateData.pSList, pCreateSurface->pSList, sizeof(DDSURFACEINFO) * pCreateSurface->dwSCnt);
                
                // Linkup
                pDefCreate->pNext = ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDeferList;
                ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDeferList = pDefCreate;
                
                // *************************MEMORY LEAK WARNING*********************** //
                // The DEFERREDCREATE and DDSURFACEINFO allocations above will
                // not be cleaned up immediately if there is a failure after this
                // point. As of 5/2001, there is no case in which we will fail after
                // this point. (snene)
                // ******************************************************************* //
            }
        }
        else
        {
            DWORD   DX8Flags = DX8SFLAG_DX8;

            // If we are creating a sysmem surface while lost, we don't want
            // want to call the driver to create the SurfaceEx handle.

            if (bLost)
            {
                DX8Flags |= DX8SFLAG_ISLOST;
            }
            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
            {
                DX8Flags |= DX8SFLAG_ISLIGHTWEIGHT;
            }
            if (pCreateSurface->Type == D3DRTYPE_IMAGESURFACE)
            {
                DX8Flags |= DX8SFLAG_IMAGESURF;
            }

            hr = DD_CreateSurface4_Main( (LPDIRECTDRAW) pdrv_int,
                                         &ddsd2,
                                         &lpDDSurface,
                                         NULL,
                                         TRUE,
                                         pSysMem,
                                         DX8Flags);

            if (hr != DD_OK)
            {
                LEAVE_WIN16LOCK();
                goto CreateErrorCleanup;
            }

            // If we let DDraw decide between local vidmem / AGP, then we need 
            // to figure out which one it chose.

            if (((LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface)->lpLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
            {
                pCreateSurface->Pool = D3DPOOL_NONLOCALVIDMEM;
                for (i = 0; i < dwNumToCreate; i++)
                {
                    pSurf = (DDSURFACE*) pCreateSurface->pSList[i].hKernelHandle;
                    pSurf->Pool = D3DPOOL_NONLOCALVIDMEM;
                }
            }

            // Everything has worked

            //Find the pointer to the attached heavyweight surface for
            //each face, mip level, back buffer etc.
            switch(pCreateSurface->Type)
            {
                case D3DRTYPE_VERTEXBUFFER  :
                case D3DRTYPE_INDEXBUFFER   :
                case D3DRTYPE_COMMANDBUFFER :
                    //these types have no attachments
                    DDASSERT(0 ==  ( (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface)->lpLcl->lpAttachList );
                    //but we need to fall through and set the pHeavy for the first one.
                case D3DRTYPE_SURFACE                :
                case D3DRTYPE_IMAGESURFACE           :
                case D3DRTYPE_VOLUME                 :
                case D3DRTYPE_TEXTURE                :
                case D3DRTYPE_VOLUMETEXTURE          :
                    {
                        LPDDRAWI_DDRAWSURFACE_INT        lpTemp;
                        LPDDRAWI_DDRAWSURFACE_INT        lpTemp1;
                        lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

                        //these types are allocated in a linear list of attachments
                        for (i = 0; i < dwNumToCreate; i++)
                        {
                            pSurf = (DDSURFACE*) pCreateSurface->pSList[i].hKernelHandle;
                            DDASSERT(!(pSurf->dwFlags & DDSURFACE_DUMMY));    //cuz not DX6 driver

                            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                            {
                                ExtractLightweightInfo (pSurf, lpTemp);
                            }
                            else
                            {
                                pSurf->Surface.pHeavy = lpTemp;
                            }

                            lpTemp1 = lpTemp;
                            if (lpTemp->lpLcl->lpAttachList)
                                lpTemp = lpTemp->lpLcl->lpAttachList->lpIAttached;

                            pSurf->iSlicePitch = lpTemp1->lpLcl->lpGbl->lSlicePitch;
                            lpTemp1->lpLcl->lpGbl->lSlicePitch = 0;
                            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                            {
                                if (lpTemp1->lpLcl->lpAttachList != NULL)
                                {
                                    MemFree(lpTemp1->lpLcl->lpAttachList);
                                }
                                if (lpTemp1->lpLcl->lpAttachListFrom != NULL)
                                {
                                    MemFree(lpTemp1->lpLcl->lpAttachListFrom);
                                }
                                DiscardHeavyweightMemory(lpTemp1);
                            }
                        }
                    }
                    break;
                case D3DRTYPE_CUBETEXTURE   :
                    //cubes are the hard buggers.
                    {
                        int face;
                        DWORD cLevels = dwNumToCreate/6;
                        
                        for(face=0; face<6; face++)
                        {
                            LPDDRAWI_DDRAWSURFACE_INT        lpTemp;
                            lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

                            //point lpTemp to the next top-level face (which will be
                            //attached to the face returned by create-surface)
                            //(we are already pointing thereat if it's face 0)
                            if (face)
                            {
                                LPATTACHLIST pal;
                                pal = lpTemp->lpLcl->lpAttachList;
                                do
                                {
                                    lpTemp = pal->lpIAttached;
                                    pal = pal->lpLink;
                                }
                                while(0 ==  (lpTemp->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & dwOrderedFaces[face]));
                            }

                            //for each face, we run down the attachment list
                            //which are allocated in a linear list of attachments
                            for (i = 0; i < cLevels; i++)
                            {
                                pSurf = (DDSURFACE*) pCreateSurface->pSList[face*cLevels+i].hKernelHandle;
                                DDASSERT(!(pSurf->dwFlags & DDSURFACE_DUMMY));    //cuz not DX6 driver

                                pSurf->iSlicePitch = lpTemp->lpLcl->lpGbl->lSlicePitch;
                                lpTemp->lpLcl->lpGbl->lSlicePitch = 0;
                                if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                                {
                                    ExtractLightweightInfo (pSurf, lpTemp);
                                }
                                else
                                {
                                    pSurf->Surface.pHeavy = lpTemp;
                                }

                                if ((face == 0) && (i == 0) && (cLevels > 1))
                                {
                                    // Special hack for finding mip-levels
                                    // of first face; the mip-levels for the pos-x
                                    // face are actually near the the end of the
                                    // list (interposed by the top-levels of the 
                                    // other 5 faces)
                                    int j;
                                    LPATTACHLIST pal = lpTemp->lpLcl->lpAttachList;

                                    for (j = 0; j < 5; j++)
                                    {
                                        pal = pal->lpLink;
                                    }

                                    lpTemp = pal->lpIAttached;

                                    // Check we found what we were looking for
                                    DDASSERT(lpTemp->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & dwOrderedFaces[face]);
                                }
                                else if (lpTemp->lpLcl->lpAttachList)
                                {
                                    // Normal case; i.e. just go to the surface we
                                    // are directly attached to
                                    lpTemp = lpTemp->lpLcl->lpAttachList->lpIAttached;
                                }
                            }
                        }

                        // If it's a lightweight surface, now we need to free
                        // all of the heavyweight memory

                        if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                        {
                            LPDDRAWI_DDRAWSURFACE_INT   lpTemp;
                            LPATTACHLIST                pal;
                            LPATTACHLIST                pNextPal;
                            LPATTACHLIST                pFaceList;
                            LPATTACHLIST                pTemp;

                            lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

                            pal = lpTemp->lpLcl->lpAttachList;
                            DiscardHeavyweightMemory(lpTemp);

                            while (pal != NULL)
                            {
                                pNextPal = pal->lpLink;

                                pFaceList = pal;
                                while (pFaceList != NULL)
                                {
                                    if (pFaceList->lpAttached->lpAttachListFrom)
                                    {
                                        MemFree (pFaceList->lpAttached->lpAttachListFrom);
                                    }
                                    pTemp = pFaceList->lpAttached->lpAttachList;
                                    DiscardHeavyweightMemory(pFaceList->lpIAttached);
                                    MemFree(pFaceList);
                                    pFaceList = pTemp;
                                }
                                pal = pNextPal;
                            }
                        }
                    }
                    break;

                default:
                    DDASSERT(0);    //unexpected type
                    break;
            }
        
            for (i = 0; i < dwNumToCreate; i++)
            {
                DWORD                       j;

                pSurf = (DDSURFACE*) pCreateSurface->pSList[i].hKernelHandle;
                if (i == 0)
                {
                    pSurf->dwFlags |= DDSURFACE_ROOT;
                }

                if (pSurf->dwFlags & DDSURFACE_HEAVYWEIGHT)
                {
                    pSurf->Pitch = pSurf->Surface.pHeavy->lpLcl->lpGbl->lPitch;
                    if (!(pSurf->dwFlags & DDSURFACE_DUMMY))
                    {
                        if (i == 0)
                        {
                            if (DDSCAPS_PRIMARYSURFACE &
                                pSurf->Surface.pHeavy->lpLcl->ddsCaps.dwCaps)
                            {
                                if (!(DDRAWILCL_HASEXCLUSIVEMODE & pdrv_int->lpLcl->dwLocalFlags))
                                {
                                    LPDIRECTDRAWCLIPPER pcClipper;
                                    if (SUCCEEDED(DD_CreateClipper((LPDIRECTDRAW) pdrv_int,
                                            0, &pcClipper, NULL)))
                                    {
                                        if (pdrv_int->lpLcl->hWnd)
                                            DD_Clipper_SetHWnd(pcClipper, 0, (HWND) pdrv_int->lpLcl->hWnd);
                                        DD_Surface_SetClipper(lpDDSurface, pcClipper);
                                        DPF(10,"Setting Clipper=%08lx with hWnd=%08lx to Primary"
                                            " Surface", pcClipper, pdrv_int->lpLcl->hWnd);
                                        DD_Clipper_Release(pcClipper);
                                    }
                                }
                            }
                        }
                    }
                    pCreateSurface->pSList[i].hKernelHandle = (HANDLE) pSurf;
                }

                // If this is a DX6+ driver, the above CreateSurface call would
                // have created the ExSurface and assigned a driver handle value.
                // If it's a DX6 driver, however, we need to create the texture
                // handle ourselves.

                if (pDevice->DriverLevel > 6)
                {
                    if (pSurf->dwFlags & DDSURFACE_HEAVYWEIGHT)
                    {
                        pSurf->dwCookie = pSurf->Surface.pHeavy->lpLcl->lpSurfMore->dwSurfaceHandle;
                    }
                    if (pSurf->dwCookie &&
                        bLost &&
                        (pSurf->dwFlags & DDSURFACE_ROOT))
                    {
                        // We've created the surface, but we can't create the
                        // surface Ex handle yet, so we will defer that creation until later.

                        pSurf->dwFlags |= DDSURFACE_DEFERCREATEEX;
                    }
                }
                else if ((pSurf->dwFlags & DDSURFACE_ROOT) &&
                    (pSurf->Type == D3DRTYPE_TEXTURE))
                {
                    // Don't create a texture handle if the surface is in sysmem
                    // and the device doesn't texture from sysmem

                    if ((pCreateSurface->Pool != D3DPOOL_SYSTEMMEM) ||
                        pDevice->bCanTextureSysmem)
                    {
                        D3DHAL_TEXTURECREATEDATA    data;
                        DWORD                       ret;

                        if (pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureCreate == NULL)
                        {
                            hr = DDERR_UNSUPPORTED;
                            LEAVE_WIN16LOCK();
                            goto CreateErrorCleanup;
                        }

                        if (bLost)
                        {
                            // We cannot create the texture handle at this time,
                            // so we will do it later.

                            pSurf->dwFlags |= DDSURFACE_DEFERCREATETEXHANDLE;
                            pDevice->pContext->dwFlags |= DDCONTEXT_DEFEREDTEXTUREHANDLES;
                        }
                        else
                        {
                            // If it's a palettized texture, we need to associate a
                            // palette before calling TextureCreate or else some
                            // drivers (Rage128) will fault.

                            if ((pCreateSurface->Format == D3DFMT_P8) ||
                                (pCreateSurface->Format == D3DFMT_A8P8))
                            {
                                if (pDevice->pDefaultPalette == NULL)
                                {
                                    {
                                        PALETTEENTRY    ColorTable[256];
                                        int             i;

                                        for (i = 0; i < 256; i++)
                                        {
                                            ColorTable[i].peRed   = (UCHAR) i;
                                            ColorTable[i].peGreen = (UCHAR) i;
                                            ColorTable[i].peBlue  = (UCHAR) i;
                                        }
                                        DD_CreatePalette ((LPDIRECTDRAW) pDevice->pDD,
                                                        DDPCAPS_8BIT,
                                                        ColorTable,
                                                        &pDevice->pDefaultPalette,
                                                        NULL);
                                    }

                                    if (pDevice->pDefaultPalette == NULL)
                                    {
                                        DPF_ERR("Unable to create default palette");
                                        LEAVE_WIN16LOCK();
                                        hr = DDERR_OUTOFMEMORY;
                                        goto CreateErrorCleanup;
                                    }
                                }
                                hr = DD_Surface_SetPalette(lpDDSurface,
                                                           pDevice->pDefaultPalette);
                                if (hr != DD_OK)
                                {
                                    DPF_ERR("Unable to set default palette");
                                    LEAVE_WIN16LOCK();
                                    goto CreateErrorCleanup;
                                }
                            }

                            memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
                            data.dwhContext = pDevice->pContext->Context;
                            data.lpDDS = lpDDSurface;

                            CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                                pDevice,
                                                pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureCreate,
                                                &data);

                            if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK)
                            {
                                DPF_ERR("HAL failed to handle TextureCreate");
                                LEAVE_WIN16LOCK();
                                hr = data.ddrval;
                                goto CreateErrorCleanup;
                            }

                            pSurf->dwCookie = data.dwHandle;
                            pSurf->dwFlags |= DDSURFACE_DX6HANDLE;
                        }
                    }
                }
            }
        }
        LEAVE_WIN16LOCK();
    }

    // Now insert this into our linked list
    // If re-using, then we are already on the list so don't do anything
    if (!pCreateSurface->bReUse)
    {
        for (i = 0; i < dwNumToCreate; i++)
        {
            ((PDDSURFACE)(pCreateSurface->pSList[i].hKernelHandle))->pNext =
                pDevice->pSurfList;
            ((PDDSURFACE)(pCreateSurface->pSList[i].hKernelHandle))->pPrevious =
                NULL;
            if (pDevice->pSurfList != NULL)
            {
                pDevice->pSurfList->pPrevious = (PDDSURFACE)(pCreateSurface->pSList[i].hKernelHandle);
            }
            pDevice->pSurfList = (PDDSURFACE)(pCreateSurface->pSList[i].hKernelHandle);
        }
    }
    LEAVE_DDRAW();

    return DD_OK;

    CreateErrorCleanup:
    for (i = 0; i < pCreateSurface->dwSCnt; i++)
    {
        pSurf = (PDDSURFACE)pCreateSurface->pSList[i].hKernelHandle;
        if (pSurf != NULL)
        {
            FreeSurfaceObject(pSurf, TRUE);
            // If we are reusing, then we need to keep the pSurf around
            // for a retry
            if (!pCreateSurface->bReUse)
            {
                MemFree(pSurf);
            }
        }
        pCreateSurface->pSList[i].hKernelHandle = NULL;
    }
    LEAVE_DDRAW();

    return MapLegacyResult(hr);
}


DWORD APIENTRY DdDestroySurface( PD3D8_DESTROYSURFACEDATA pDestroySurface )
{
    DWORD i;
    PDDSURFACE pSurf = (PDDSURFACE) pDestroySurface->hSurface;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pDestroySurface->hDD;
    PDEFERREDCREATE pDefCreate = pDevice->pDeferList;

    ENTER_DDRAW();
    FreeSurfaceObject(pSurf, TRUE);

    if (pSurf != NULL)
    {
        // Free fpVidMem if we allocated it

        if (pSurf->dwFlags & DDSURFACE_SYSMEMALLOCATED)
        {
            MemFree (pSurf->fpVidMem);
        }

        // Remove the surface from the linked list

        if (pDevice->pSurfList == pSurf)
        {
            pDevice->pSurfList = pSurf->pNext;
            if (pSurf->pNext != NULL)
            {
                pSurf->pNext->pPrevious = NULL;
            }
        }
        else
        {
            if (pSurf->pNext != NULL)
            {
                pSurf->pNext->pPrevious = pSurf->pPrevious;
            }
            pSurf->pPrevious->pNext = pSurf->pNext;
        }

        MemFree(pSurf);
    }

    // We look in the defer list to see if any referenced surface
    // is being destroyed. If this is the case, then we need to
    // update the defer list and mark the surfaces as freed so
    // that we don't try and resurrect destroyed surfaces. Although
    // this appears slow, it is not too bad because a deferred list
    // will be present only if a mode switch happened. In this case,
    // it doesn't hurt if things are a little slow.

    while (pDefCreate != NULL)
    {
        for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
        {
            if (pSurf == (PDDSURFACE) pDefCreate->CreateData.pSList[i].hKernelHandle)
            {
                pDefCreate->CreateData.pSList[i].hKernelHandle = 0;
                break;
            }
        }
        pDefCreate = pDefCreate->pNext;
    }

    LEAVE_DDRAW();

    return DD_OK;
}

DWORD APIENTRY DdGetScanLine( PD3D8_GETSCANLINEDATA pGetScanLine )
{  
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pGetScanLine->hDD;
    DWORD           dwRet = DDHAL_DRIVER_HANDLED;

    ENTER_BOTH();
    if (CheckForDeviceLost(pDevice))
    {
        static int LostScanLine;

        // When lost, we want to mix up the return values in case somebody
        // calling us is waiting for these values to change

        pGetScanLine->ddRVal = DD_OK;
        if (LostScanLine == 0)
        {
            pGetScanLine->dwScanLine = 0;
            pGetScanLine->bInVerticalBlank = TRUE;
        }
        else 
        {
            pGetScanLine->dwScanLine = LostScanLine;
            pGetScanLine->bInVerticalBlank = FALSE;
        }
        if ((LostScanLine += 10) > 100)
        {
            LostScanLine = 0;
        }
    }
    else
    {
        LPDDHAL_GETSCANLINE gslhalfn;
        LPDDHAL_GETSCANLINE gslfn;

        gslfn = pDevice->pDD->lpLcl->lpDDCB->HALDD.GetScanLine;
        gslhalfn = pDevice->pDD->lpLcl->lpDDCB->cbDDCallbacks.GetScanLine;
        if( gslhalfn != NULL )
        {
            DDHAL_GETSCANLINEDATA   gsld;

            gsld.GetScanLine = gslhalfn;
            gsld.lpDD = pDevice->pDD->lpLcl->lpGbl;
            DOHALCALL( GetScanLine, gslfn, gsld, dwRet, FALSE );
            if( dwRet == DDHAL_DRIVER_HANDLED )
            {
                pGetScanLine->dwScanLine = gsld.dwScanLine;
                if (gsld.ddRVal == DDERR_VERTICALBLANKINPROGRESS)
                {
                    gsld.ddRVal = DD_OK;
                    pGetScanLine->bInVerticalBlank = TRUE;
                }
                else
                {
                    pGetScanLine->bInVerticalBlank = FALSE;
                }
                pGetScanLine->ddRVal = MapLegacyResult(gsld.ddRVal);
            }
	}
        else
        {
            dwRet = DDHAL_DRIVER_NOTHANDLED;
        }
    }

    LEAVE_BOTH();
    return dwRet;
}

DWORD APIENTRY DdSetExclusiveMode( PD3D8_SETEXCLUSIVEMODEDATA pSetExclusiveMode )
{
    DPF_ERR("DdSetExclusiveMode");
#if 0
    LPDDRAWI_DIRECTDRAW_LCL lpDX7;

    // Tell DDraw that we've grabbed exclusive mode

    ENTER_DDRAW();
    lpDX7 = ((LPDDRAWI_DIRECTDRAW_INT)(pSetExclusiveMode->lpDD->hDD))->lpLcl;

    if( pSetExclusiveMode->dwEnterExcl )
    {
        lpDX7->dwLocalFlags |= DDRAWILCL_SETCOOPCALLED | DDRAWILCL_ISFULLSCREEN;
        lpDX7->lpGbl->lpExclusiveOwner = lpDX7;
        lpDX7->lpGbl->dwFlags |= DDRAWI_FULLSCREEN;
    }
    else
    {
        lpDX7->dwLocalFlags &= ~(DDRAWILCL_SETCOOPCALLED | DDRAWILCL_ISFULLSCREEN);
        lpDX7->lpGbl->lpExclusiveOwner = NULL;
        lpDX7->lpGbl->dwFlags &= ~DDRAWI_FULLSCREEN;
    }
    LEAVE_DDRAW();
#endif
    pSetExclusiveMode->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdFlipToGDISurface( PD3D8_FLIPTOGDISURFACEDATA pFlipToGDISurface )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pFlipToGDISurface->hDD;
    LPDDRAWI_DIRECTDRAW_INT     lpDD = pDevice->pDD;

    pFlipToGDISurface->ddRVal = MapLegacyResult(DD_FlipToGDISurface((LPDIRECTDRAW)lpDD));
    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdSetColorkey( PD3D8_SETCOLORKEYDATA pSetColorkey)
{
    PDDDEVICEHANDLE     pDevice = (PDDDEVICEHANDLE) pSetColorkey->hDD;
    PDDSURFACE          pSurf = (PDDSURFACE) pSetColorkey->hSurface;

    ENTER_BOTH();
    pSetColorkey->ddRVal = DD_OK;
    if (CheckForDeviceLost(pSetColorkey->hDD))
    {
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    if (pSurf->Surface.pHeavy != NULL)
    {
        DDCOLORKEY DDColorKey;

        // Since this will only be called with DX6 drivers, we know that
        // it will only be heavyweight surfaces and we can use the legacy
        // entry point.

        DDColorKey.dwColorSpaceLowValue = pSetColorkey->ColorValue;
        pSetColorkey->ddRVal = MapLegacyResult(DD_Surface_SetColorKey((LPDIRECTDRAWSURFACE)pSurf->Surface.pHeavy,
                                                       DDCKEY_SRCBLT,
                                                       &DDColorKey));
    }
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdGetAvailDriverMemory( PD3D8_GETAVAILDRIVERMEMORYDATA pGetAvailDriverMemory )
{
    DWORD                       dwTotal;
    DWORD                       dwFree;
    DDSCAPS                     ddscaps;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int = ((PDDDEVICEHANDLE)pGetAvailDriverMemory->hDD)->pDD;

    ddscaps.dwCaps = DDSCAPS_TEXTURE;

    pGetAvailDriverMemory->ddRVal = MapLegacyResult(DD_GetAvailableVidMem( (LPDIRECTDRAW)pdrv_int, &ddscaps, &dwTotal, &dwFree ));

    pGetAvailDriverMemory->dwFree = dwFree;

    return DDHAL_DRIVER_HANDLED;
}

HRESULT CalcDDSurfInfo( PDDCONTEXT pCtx, LPDDRAWI_DDRAWSURFACE_LCL pSLcl,
                        LPDDRAWI_DDRAWSURFACE_LCL pZLcl )
{
    HRESULT ddrval;
    DWORD dwWidth, dwHeight;
    unsigned long m;
    int s;
    LPDDPIXELFORMAT pSPixFmt = NULL;
    LPDDPIXELFORMAT pZPixFmt = NULL;

    if( pSLcl == NULL ) return S_OK;

    // Get info from the surface
    dwWidth = pSLcl->lpGbl->wWidth;
    dwHeight = pSLcl->lpGbl->wHeight;
    GET_PIXEL_FORMAT( pSLcl, pSLcl->lpGbl, pSPixFmt );

    if( ( pSPixFmt->dwFlags & ( DDPF_PALETTEINDEXED4 |
                                DDPF_PALETTEINDEXED8 ) ) == 0 )
    {
        // palettized pixfmts will not have valid RGB Bitmasks, so avoid
        // computing this for them

        pCtx->red_mask = pSPixFmt->dwRBitMask;
        pCtx->green_mask = pSPixFmt->dwGBitMask;
        pCtx->blue_mask = pSPixFmt->dwBBitMask;

        if( (pCtx->red_mask == 0x0) || (pCtx->green_mask == 0x0) ||
            (pCtx->blue_mask == 0x0) )
        {
            D3D_ERR("All the color masks in the Render target's pixel-format "
                    "must be non-zero");
            return DDERR_INVALIDPIXELFORMAT;
        }

        // these are used by Clear
        for( s = 0, m = pCtx->red_mask; !(m & 1); s++, m >>= 1 );
        pCtx->red_shift = s;
        pCtx->red_scale = 255 / (pCtx->red_mask >> s);
        for( s = 0, m = pCtx->green_mask; !(m & 1); s++, m >>= 1 );
        pCtx->green_shift = s;
        pCtx->green_scale = 255 / (pCtx->green_mask >> s);
        for( s = 0, m = pCtx->blue_mask; !(m & 1); s++, m >>= 1 );
        pCtx->blue_shift = s;
        pCtx->blue_scale = 255 / (pCtx->blue_mask >> s);

        if( (pCtx->red_scale==0) || (pCtx->green_scale==0) ||
            (pCtx->blue_scale==0) )
            return DDERR_INVALIDPIXELFORMAT;

        pCtx->bDDSTargetIsPalettized=FALSE;
    }
    else
    {
        pCtx->bDDSTargetIsPalettized=TRUE;
    }

    if( pZLcl )
    {
        // Get info from the surface
        GET_PIXEL_FORMAT( pZLcl, pZLcl->lpGbl, pZPixFmt );
        if( pZPixFmt->dwZBitMask!=0x0)
        {
            for(s = 0, m = pZPixFmt->dwZBitMask; !(m & 0x1); s++, m >>= 1);
            pCtx->zmask_shift = s;
        }
        else
        {
            // if ZBitMask isn't being set, then Clear2 will never be used,
            // so zbuf_shift/stencil_shift wont be needed anyway
            pCtx->zmask_shift=0;
        }

        if( pZPixFmt->dwStencilBitMask != 0x0 )
        {
            for(s = 0, m = pZPixFmt->dwStencilBitMask; !(m & 0x1);
                s++, m >>= 1) ;
            pCtx->stencilmask_shift = s;
        }
        else
        {
            pCtx->stencilmask_shift=0;
        }
    }

    return S_OK;
}

DWORD WINAPI D3dContextCreate(PD3D8_CONTEXTCREATEDATA pCreateContext)
{
    D3DHAL_CONTEXTCREATEDATA    data;
    DWORD                       ret;
    HRESULT                     hr = S_OK;
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateContext->hDD;
    LPDDRAWI_DIRECTDRAW_INT     lpDD = pDevice->pDD;
    PDDSURFACE                  lpDDSTarget = (PDDSURFACE)pCreateContext->hSurface;
    PDDSURFACE                  lpDDSZBuffer = (PDDSURFACE)pCreateContext->hDDSZ;
    PDDCONTEXT                  pContext;
    ULONG                       cjBuffer = 0;

    // Do the allocation first, since if it fails we don't have to do any real cleanup

    ENTER_BOTH();
    pDevice->pContext = NULL;
    pContext = (PDDCONTEXT) MemAlloc(sizeof(DDCONTEXT));
    if (pContext == NULL)
    {
        pCreateContext->ddrval = DDERR_OUTOFMEMORY;
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    // Now allocate the memory for the DPBuffer.
    pContext->pDPBuffer = NULL;

    cjBuffer = pCreateContext->cjBuffer;
    if( cjBuffer == 0)
    {
        cjBuffer = DEF_PRIM_BUFFER_SIZE;
    }
    else if (cjBuffer < MIN_PRIM_BUFFER_SIZE ||
             cjBuffer > MAX_PRIM_BUFFER_SIZE)
    {
        D3D_ERR("Illegal buffer size");
        pCreateContext->ddrval = D3DERR_DRIVERINTERNALERROR;
        MemFree( pContext );
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    pContext->pDPBuffer = (LPVOID)MemAlloc( cjBuffer );
    if( pContext->pDPBuffer == NULL )
    {
        pCreateContext->ddrval = DDERR_OUTOFMEMORY;
        MemFree( pContext );
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    pCreateContext->pvBuffer = (LPVOID)(((DWORD)pContext->pDPBuffer+31)&(~31));
    pCreateContext->cjBuffer = cjBuffer;

    // We need to check for a lost device before mucking around with the surfaces

    if (CheckForDeviceLost(pDevice))
    {
        pContext->Context = 0;
        pContext->pDevice = pDevice;
        pDevice->pContext = pContext;
        pCreateContext->dwhContext = (ULONG_PTR) pContext;

       // Remember data required to create the context later

        pContext->dwFlags = DDCONTEXT_DEFER;
        pContext->dwTempContext = pCreateContext->dwhContext;
        pContext->dwPID = pCreateContext->dwPID;
        pContext->ddrval = pCreateContext->ddrval;

        pCreateContext->ddrval = DD_OK;

        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    // Calculate the surface info for Clear emulation if needed
    hr = CalcDDSurfInfo( pContext,
                         (lpDDSTarget) ? lpDDSTarget->Surface.pHeavy->lpLcl
                         : NULL,
                         (lpDDSZBuffer) ? lpDDSZBuffer->Surface.pHeavy->lpLcl
                         : NULL );
    if( FAILED( hr ) )
    {
        pCreateContext->ddrval = MapLegacyResult(hr);
        MemFree(pContext->pDPBuffer);
        pCreateContext->pvBuffer = NULL;
        pCreateContext->cjBuffer = 0;
        MemFree(pContext);
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    memset(&data, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));

    pDevice->pContext = NULL;
    if (pDevice->DriverLevel >= 7)
    {
        if (lpDD)
            data.lpDDLcl = lpDD->lpLcl;
        else
            data.lpDDLcl = NULL;

        if (lpDDSTarget)
            data.lpDDSLcl = lpDDSTarget->Surface.pHeavy->lpLcl;
        else
            data.lpDDSLcl = NULL;

        if (lpDDSZBuffer)
            data.lpDDSZLcl = lpDDSZBuffer->Surface.pHeavy->lpLcl;
        else
            data.lpDDSZLcl = NULL;

    }
    else
    {
        if (lpDD)
            data.lpDDGbl = lpDD->lpLcl->lpGbl;
        else
            data.lpDDLcl = NULL;

        if (lpDDSTarget)
            data.lpDDS = (LPDIRECTDRAWSURFACE)lpDDSTarget->Surface.pHeavy;
        else
            data.lpDDS = NULL;

        if (lpDDSZBuffer)
            data.lpDDSZ = (LPDIRECTDRAWSURFACE)lpDDSZBuffer->Surface.pHeavy;
        else
            data.lpDDSZ = NULL;
    }

    // Hack Alert!! dwhContext is used to inform the driver which version
    // of the D3D interface is calling it.
    data.dwhContext = pCreateContext->dwhContext;
    data.dwPID  = pCreateContext->dwPID;
    data.ddrval = pCreateContext->ddrval;

    /* 0 for pre-DX5 devices.
     * 1 for DX5 devices.
     * 2 for DX6 devices.
     * 3 for DX7 devices.
     */

    CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                        pDevice,
                        lpDD->lpLcl->lpGbl->lpD3DHALCallbacks->ContextCreate,
                        &data);

    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK)
    {
        D3D_ERR( "Driver did not handle ContextCreate" );
        MemFree(pContext->pDPBuffer);
        pCreateContext->pvBuffer = NULL;
        pCreateContext->cjBuffer = 0;
        MemFree(pContext);
        pCreateContext->dwhContext = 0;
        pCreateContext->ddrval = D3DERR_DRIVERINTERNALERROR;
    }
    else
    {
        pContext->Context = data.dwhContext;
        pContext->pDevice = pDevice;
        pDevice->pContext = pContext;

        pCreateContext->dwhContext = (ULONG_PTR) pContext;
        pCreateContext->ddrval = data.ddrval;
    }
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

HRESULT WINAPI D3dContextDestroy(PD3D8_CONTEXTDESTROYDATA pDestroyContext)
{
    PDDCONTEXT pContext = (PDDCONTEXT) pDestroyContext->dwhContext;

    ENTER_BOTH();
    CheckForDeviceLost(pContext->pDevice);

    pDestroyContext->ddrval = DD_OK;
    if (pContext->Context)
    {
        D3DHAL_CONTEXTDESTROYDATA   data;
        DWORD                       ret;
        DDSURFACE*                  pSurf;

        // If there are any DX6 texture handles created w/ this context,
        // we should destroy them now.

        pSurf = pContext->pDevice->pSurfList;
        while (pSurf != NULL)
        {
            if ((pSurf->dwFlags & DDSURFACE_DX6HANDLE) &&
                (pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy != NULL))
            {
                D3DHAL_TEXTUREDESTROYDATA   data;
                DWORD                       ret;

                data.dwhContext = (ULONG_PTR) pContext->Context;
                data.dwHandle = pSurf->dwCookie;

                CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                    pSurf->pDevice,
                                    pSurf->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy,
                                    &data);
                pSurf->dwFlags &= ~DDSURFACE_DX6HANDLE;
                pSurf->dwCookie = 0;
            }
            pSurf = pSurf->pNext;
        }

        data.dwhContext = (ULONG_PTR) pContext->Context;
        CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                            pContext->pDevice,
                            pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->ContextDestroy,
                            &data);

        pDestroyContext->ddrval = MapLegacyResult(data.ddrval);
    }

    if( pContext->pDPBuffer ) MemFree( pContext->pDPBuffer );
    pContext->pDevice->pContext = NULL;
    MemFree(pContext);
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

void BltFillRects( PDDCONTEXT pCtx, PDDSURFACE pDDS, DWORD count,
                   LPD3DRECT rect, D3DCOLOR dwFillColor)
{
    HRESULT ddrval;
    DDBLTFX bltfx;
    RECT tr;
    DWORD i;
    DWORD r, g, b;

    // Fill with background color

    memset(&bltfx, 0, sizeof(bltfx));
    bltfx.dwSize = sizeof(bltfx);

// unlike clear callback, which just takes pure 32-bit ARGB word and forces the driver to scale it for
// the pixelformat, here we need to compute the exact fill word, depending on surface's R,G,B bitmasks

    if( pCtx->bDDSTargetIsPalettized )
    {
         // Palettized render targets are not supported
         DDASSERT( TRUE );
    }
    else
    {
        DDASSERT((pCtx->red_scale!=0)&&(pCtx->green_scale!=0)&&(pCtx->blue_scale!=0));
        r = RGB_GETRED(dwFillColor) / pCtx->red_scale;
        g = RGB_GETGREEN(dwFillColor) / pCtx->green_scale;
        b = RGB_GETBLUE(dwFillColor) / pCtx->blue_scale;
        bltfx.dwFillColor = (r << pCtx->red_shift) | (g << pCtx->green_shift) |
            (b << pCtx->blue_shift);
    }

    for (i = 0; i < count; i++,rect++)
    {
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do
        {
            ddrval = DD_Surface_Blt( (LPDIRECTDRAWSURFACE)pDDS->Surface.pHeavy,
                                     &tr, NULL, NULL, DDBLT_COLORFILL, &bltfx);
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

void BltFillZRects( PDDCONTEXT pCtx, PDDSURFACE pDDSZ, unsigned long Zpixel,
                    DWORD count, LPD3DRECT rect, DWORD dwWriteMask)
{
    HRESULT ddrval;
    DDBLTFX bltfx;
    DWORD i;
    RECT tr;
    DWORD dwExtraFlags=0;

    memset(&bltfx, 0, sizeof(DDBLTFX));
    bltfx.dwSize = sizeof(DDBLTFX);
    bltfx.dwFillDepth = Zpixel;

    // hack to pass DepthBlt WriteMask through ddraw/ddhel to blitlib
    if( dwWriteMask != 0 )
    {
        bltfx.dwZDestConstBitDepth = dwWriteMask;
        dwExtraFlags = DDBLT_DEPTHFILLWRITEMASK;
    }

    for(i=0; i<count ; i++, rect++)
    {
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do
        {
            ddrval = DD_Surface_Blt( 
                (LPDIRECTDRAWSURFACE)pDDSZ->Surface.pHeavy,
                &tr, NULL, NULL,
                DDBLT_DEPTHFILL |
                dwExtraFlags, &bltfx );
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

DWORD WINAPI D3dClear( PD3D8_CLEAR2DATA pData )
{
    PDDCONTEXT pContext = (PDDCONTEXT) pData->dwhContext;
    LPDDRAWI_DIRECTDRAW_GBL pGbl = NULL;
    DWORD  ret = DDHAL_DRIVER_HANDLED;
    DWORD dwFlags = pData->dwFlags;
    BOOL bDoRGBClear     = ((dwFlags & D3DCLEAR_TARGET)!=0);
    BOOL bDoZClear       = ((dwFlags & D3DCLEAR_ZBUFFER)!=0);
    BOOL bDoStencilClear = ((dwFlags & D3DCLEAR_STENCIL)!=0);
    D3DVALUE dvZ = pData->dvFillDepth;
    PDDSURFACE pZBuffer = NULL;
    LPDDRAWI_DDRAWSURFACE_GBL pZGbl = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL pZLcl = NULL;
    LPDDPIXELFORMAT pZPixFmt = NULL;

    pData->ddrval = S_OK;

    ENTER_BOTH();
    if (CheckForDeviceLost(pContext->pDevice))
    {
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }


    pGbl = pContext->pDevice->pDD->lpLcl->lpGbl;
    if( pGbl->lpD3DHALCallbacks3->Clear2 )
    {
        D3DHAL_CLEAR2DATA Clear2Data;
        memcpy( &Clear2Data, pData, sizeof( Clear2Data ) );
        Clear2Data.dwhContext   = pContext->Context;
        Clear2Data.ddrval       = S_OK;
        CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                             pContext->pDevice,
                             pGbl->lpD3DHALCallbacks3->Clear2,
                             (D3DHAL_CLEAR2DATA *)&Clear2Data);

        LEAVE_BOTH();
        pData->ddrval = MapLegacyResult(Clear2Data.ddrval);
        return ret;
    }

    if( pGbl->lpD3DGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps &
        D3DPRASTERCAPS_ZBUFFERLESSHSR )
    {
        if( bDoStencilClear )
        {
            D3D_ERR( "Invalid flag D3DCLEAR_STENCIL: this ZBUFFERLESSHSR "
                     "device doesn't support Stencil Clears");
            pData->ddrval = D3DERR_DRIVERINTERNALERROR;
            LEAVE_BOTH();
            return DDHAL_DRIVER_NOTHANDLED;
        }

        if( bDoZClear )
        {
            if( !(pGbl->lpD3DHALCallbacks2->Clear) || (dvZ != 1.0f) )
            {
                D3D_WARN(3,"Ignoring D3DCLEAR_ZBUFFER since this "
                         "ZBUFFERLESSHSR device doesn't even support Clear "
                         "or Z!=1");
                dwFlags &= ~(D3DCLEAR_ZBUFFER);
            }
        }
    }

    if( pData->hDDSZ )
    {
        pZBuffer = (PDDSURFACE)pData->hDDSZ;
        pZLcl = pZBuffer->Surface.pHeavy->lpLcl;
        pZGbl = pZLcl->lpGbl;
        pZPixFmt = &pZGbl->ddpfSurface;
    }

    if( pGbl->lpD3DHALCallbacks2->Clear )
    {
        D3DHAL_CLEARDATA ClearData;

        if( bDoZClear || bDoStencilClear )
        {
            if( (pZPixFmt != NULL) && //PowerVR need no Zbuffer
                (DDPF_STENCILBUFFER & pZPixFmt->dwFlags))
            {
                // if surface has stencil bits, must verify either Clear2
                // callback exists or we're using SW rasterizers
                // (which require the special WriteMask DDHEL blt)
                // This case should not be hit since we check right at the
                // driver initialization time if the driver doesnt report
                // Clear2 yet it supports stencils
                if( pZLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
                {
                    goto Emulateclear;
                }
                else
                {
                    LEAVE_BOTH();
                    D3D_ERR( "Driver doesn't support StencilBuffer Clears");
                    pData->ddrval = D3DERR_DRIVERINTERNALERROR;
                    return DDHAL_DRIVER_NOTHANDLED;
                }
            }
            // if Clear2 callback doesnt exist and it's a z-only surface and
            // not doing zclear to non-max value then Clear2 is attempting to
            // do no more than Clear could do, so it's safe to call Clear()
            // instead of Clear2(), which will take advantage of older
            // drivers that implement Clear but not Clear2

            dwFlags &= ~D3DCLEAR_STENCIL;   // Device cannot do stencil
        }

        if( bDoZClear && (dvZ != 1.0) )
        {
            ClearData.dwFlags   = dwFlags & ~D3DCLEAR_ZBUFFER;
            dwFlags = D3DCLEAR_ZBUFFER;
        }
        else
        {
            ClearData.dwFlags = dwFlags;
            dwFlags = 0;
        }

        if (ClearData.dwFlags)
        {
            ClearData.dwhContext   = pContext->Context;
            // Here I will follow the ClearData.dwFillColor convention that
            // color word is raw 32bit ARGB, unadjusted for surface bit depth
            ClearData.dwFillColor  = pData->dwFillColor;
            // must clear to 0xffffffff because legacy drivers expect this
            ClearData.dwFillDepth  = 0xffffffff;
            ClearData.lpRects      = pData->lpRects;
            ClearData.dwNumRects   = pData->dwNumRects;
            ClearData.ddrval       = S_OK;

            // if((err = CheckContextSurface(this)) != D3D_OK)
            // {
            //     throw err;
            // }

            CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                                 pContext->pDevice,
                                 pGbl->lpD3DHALCallbacks2->Clear,
                                 (D3DHAL_CLEARDATA *)&ClearData);

            pData->ddrval = MapLegacyResult(ClearData.ddrval);
            LEAVE_BOTH();

            return ret;
        }
    }

Emulateclear:   // Fall back to Emulation using Blt
    {
        PDDSURFACE pTarget = (PDDSURFACE)pData->hDDS;
        LPDDRAWI_DDRAWSURFACE_GBL pTargetGbl =
            pTarget->Surface.pHeavy->lpLcl->lpGbl;
        DWORD dwStencil = pData->dwFillStencil;

        if(bDoRGBClear)
        {
            BltFillRects( pContext, (PDDSURFACE)pData->hDDS, pData->dwNumRects,
                          pData->lpRects, pData->dwFillColor );
            //ok to not return possible errors from Blt?
        }
        if( (bDoZClear || bDoStencilClear) && NULL != pZPixFmt)
        {
            DWORD   dwZbufferClearValue=0;
            DWORD   dwZbufferClearMask=0;
            DDASSERT(pZPixFmt->dwZBufferBitDepth<=32);
            DDASSERT(pZPixFmt->dwStencilBitDepth<32);
            DDASSERT(pZPixFmt->dwZBitMask!=0x0);
            DDASSERT((0xFFFFFFFF == (pZPixFmt->dwZBitMask |
                                     pZPixFmt->dwStencilBitMask)) |
                     ((DWORD)((1<<pZPixFmt->dwZBufferBitDepth)-1) ==
                      (pZPixFmt->dwZBitMask | pZPixFmt->dwStencilBitMask)));
            DDASSERT(0==(pZPixFmt->dwZBitMask & pZPixFmt->dwStencilBitMask));
            if(bDoZClear)
            {
                dwZbufferClearMask = pZPixFmt->dwZBitMask;
                // special case the common cases
                if( dvZ==1.0f )
                {
                    dwZbufferClearValue = pZPixFmt->dwZBitMask;
                }
                else if( dvZ > 0.0f )
                {
                    dwZbufferClearValue =
                        ((DWORD)((dvZ*(pZPixFmt->dwZBitMask >>
                                       pContext->zmask_shift)) + 0.5)) <<
                        pContext->zmask_shift;
                }
            }

            if( bDoStencilClear )
            {
                DDASSERT(pZPixFmt->dwStencilBitMask!=0x0);
                DDASSERT(pZPixFmt->dwFlags & DDPF_STENCILBUFFER);
                dwZbufferClearMask |= pZPixFmt->dwStencilBitMask;
                // special case the common case
                if( dwStencil != 0 )
                {
                    dwZbufferClearValue |= (dwStencil <<
                                            pContext->stencilmask_shift) &
                        pZPixFmt->dwStencilBitMask;
                }
            }
            if( dwZbufferClearMask == (pZPixFmt->dwStencilBitMask |
                                       pZPixFmt->dwZBitMask) )
            {
                // do Stencil & Z Blt together, using regular DepthFill blt
                // which will be faster than the writemask blt because its
                // write-only, instead of read-modify-write
                dwZbufferClearMask = 0;
            }
            BltFillZRects( pContext, (PDDSURFACE)pData->hDDSZ,
                           dwZbufferClearValue, pData->dwNumRects,
                           pData->lpRects, dwZbufferClearMask );
        }
    }
    LEAVE_BOTH();

    return ret;
}

DWORD WINAPI D3dSetRenderTarget( PD3D8_SETRENDERTARGETDATA pData )
{
    PDDCONTEXT pContext = (PDDCONTEXT) pData->dwhContext;
    LPDDRAWI_DIRECTDRAW_GBL pGbl = NULL;
    DWORD  ret = DDHAL_DRIVER_HANDLED;

    ENTER_BOTH();
    if (CheckForDeviceLost(pContext->pDevice))
    {
        LEAVE_BOTH();
        pData->ddrval = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    pGbl = pContext->pDevice->pDD->lpLcl->lpGbl;
    if( pGbl->lpD3DHALCallbacks2->SetRenderTarget )
    {
        D3DHAL_SETRENDERTARGETDATA srtData;

        // If creation of the render target was defered, create it now

        if (pContext->dwFlags & DDCONTEXT_DEFER)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pTarget = NULL;
            LPDDRAWI_DDRAWSURFACE_INT   pZ = NULL;
            HRESULT                     hr;
            D3DHAL_CONTEXTCREATEDATA    data;
            DWORD                       ret;

            if (pData->hDDS)
            {
                pTarget = ((PDDSURFACE)pData->hDDS)->Surface.pHeavy;
            }
            if (pData->hDDSZ)
            {
                pZ = ((PDDSURFACE)pData->hDDSZ)->Surface.pHeavy;
            }

            // Calculate the surface info for Clear emulation if needed
            CalcDDSurfInfo(pContext,
                           (pTarget) ? pTarget->lpLcl : NULL,
                           (pZ) ? pZ->lpLcl : NULL);

            memset(&data, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));
            if (pContext->pDevice->DriverLevel >= 7)
            {
                if (pContext->pDevice->pDD != NULL)
                {
                    data.lpDDLcl = pContext->pDevice->pDD->lpLcl;
                }

                if (pTarget != NULL)
                {
                    data.lpDDSLcl = pTarget->lpLcl;
                }
                else
                {
                    data.lpDDSLcl = NULL;
                }
                if (pZ != NULL)
                {
                    data.lpDDSZLcl = pZ->lpLcl;
                }
                else
                {
                    data.lpDDSZLcl = NULL;
                }
            }
            else
            {
                if (pContext->pDevice->pDD != NULL)
                {
                    data.lpDDGbl = pContext->pDevice->pDD->lpLcl->lpGbl;
                }

                data.lpDDS = (LPDIRECTDRAWSURFACE)pTarget;
                data.lpDDSZ = (LPDIRECTDRAWSURFACE) pZ;
            }

            // Hack Alert!! dwhContext is used to inform the driver which version
            // of the D3D interface is calling it.
            data.dwhContext = pContext->dwTempContext;
            data.dwPID  = pContext->dwPID;
            data.ddrval = pContext->ddrval;

            /* 0 for pre-DX5 devices.
             * 1 for DX5 devices.
             * 2 for DX6 devices.
             * 3 for DX7 devices.
             */

            CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                        pContext->pDevice,
                        pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->ContextCreate,
                        &data);

            if (ret == DDHAL_DRIVER_HANDLED && data.ddrval == DD_OK)
            {
                pContext->Context = data.dwhContext;
            }
            pContext->dwFlags &= ~DDCONTEXT_DEFER;
        }

        pData->bNeedUpdate = FALSE;
        memset( &srtData, 0, sizeof( srtData ) );
        srtData.dwhContext = pContext->Context;
        if( pData->hDDS )
            srtData.lpDDS =
                (LPDIRECTDRAWSURFACE)((PDDSURFACE)pData->hDDS)->Surface.pHeavy;
        if( pData->hDDSZ )
            srtData.lpDDSZ =
                (LPDIRECTDRAWSURFACE)((PDDSURFACE)pData->hDDSZ)->Surface.pHeavy;
        CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                             pContext->pDevice,
                             pGbl->lpD3DHALCallbacks2->SetRenderTarget,
                             (D3DHAL_SETRENDERTARGETDATA *)&srtData );
        pData->ddrval = MapLegacyResult(srtData.ddrval);

        // If we need to create any defered texture handles, we will do so now

        if (pContext->dwFlags & DDCONTEXT_DEFEREDTEXTUREHANDLES)
        {
            DDSURFACE* pSurf;

            pContext->dwFlags &= ~ DDCONTEXT_DEFEREDTEXTUREHANDLES;
            pSurf = pContext->pDevice->pSurfList;
            while (pSurf != NULL)
            {
                if (pSurf->dwFlags & DDSURFACE_DEFERCREATETEXHANDLE)
                {
                    D3DHAL_TEXTURECREATEDATA    data;
                    DWORD                       ret;

                    memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
                    data.dwhContext = pContext->Context;
                    data.lpDDS = (LPDIRECTDRAWSURFACE) pSurf->Surface.pHeavy;

                    CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                pContext->pDevice,
                                pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureCreate,
                                &data);

                    pSurf->dwCookie = data.dwHandle;
                    pSurf->dwFlags |= DDSURFACE_DX6HANDLE;
                    pSurf->dwFlags &= ~DDSURFACE_DEFERCREATETEXHANDLE;
                }
                pSurf = pSurf->pNext;
            }
        }

        LEAVE_BOTH();
        return ret;
    }
    else
    {
        D3DHAL_CONTEXTCREATEDATA cdata;
        D3DHAL_CONTEXTDESTROYDATA ddata;
        DDSURFACE* pTemp;

        // If we have allocated any texture handles, we need to free them now

        pTemp = pContext->pDevice->pSurfList;
        while (pTemp != NULL)
        {
            if ((pTemp->dwFlags & DDSURFACE_DX6HANDLE) &&
                (pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy != NULL))
            {
                D3DHAL_TEXTUREDESTROYDATA   data;
                DWORD                       ret;

                data.dwhContext = (ULONG_PTR) pContext->Context;
                data.dwHandle = pTemp->dwCookie;

                CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                    pTemp->pDevice,
                                    pTemp->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy,
                                    &data);
            }
            pTemp = pTemp->pNext;
        }

        pData->bNeedUpdate = TRUE;
        memset( &ddata, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA) );

        // Destroy Old Context
        ddata.dwhContext = pContext->Context;
        if (pContext->Context != 0)
        {
            CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                                 pContext->pDevice,
                                 pGbl->lpD3DHALCallbacks->ContextDestroy,
                                 &ddata );

            if (ret != DDHAL_DRIVER_HANDLED || ddata.ddrval != DD_OK)
            {
                D3D_ERR( "SRT emulation, ContextDestroy failed." );
                LEAVE_BOTH();
                pData->ddrval = MapLegacyResult(ddata.ddrval);
                return ret;
            }
        }
        pContext->dwFlags &= ~(DDCONTEXT_DEFER | DDCONTEXT_DEFEREDTEXTUREHANDLES);

        // Create a new Context
        memset( &cdata, 0, sizeof(D3DHAL_CONTEXTCREATEDATA) );
        cdata.lpDDGbl = pGbl;
        if( pData->hDDS )
            cdata.lpDDS =
                (LPDIRECTDRAWSURFACE)((PDDSURFACE)pData->hDDS)->Surface.pHeavy;;
        if( pData->hDDSZ )
            cdata.lpDDSZ =
                (LPDIRECTDRAWSURFACE)((PDDSURFACE)pData->hDDSZ)->Surface.pHeavy;
        // Hack Alert!! dwhContext is used to inform the driver which version
        // of the D3D interface is calling it.
        // We don't want DX6 drivers to know that we are DX8 because
        // we found at least one driver that starts behaving differently when
        // it sees anything other than 3. (the driver was TNT2 and it turned
        // off multitexturing thinking that anything other than 3 means DX5 
        // or below)
        cdata.dwhContext = 3;
        DDASSERT(pContext->pDevice->DriverLevel < 7); // should never get here for DX7 or above drivers
        cdata.dwPID  = GetCurrentProcessId();
        CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                             pContext->pDevice,
                             pGbl->lpD3DHALCallbacks->ContextCreate,
                             &cdata );
        if (ret != DDHAL_DRIVER_HANDLED || cdata.ddrval != DD_OK)
        {
            D3D_ERR( "SRT emulation, ContextCreate failed" );
            LEAVE_BOTH();
            pData->dwhContext = 0;
            pData->ddrval = MapLegacyResult(cdata.ddrval);
            return ret;
        }
        pContext->Context = cdata.dwhContext;
        pData->ddrval = MapLegacyResult(cdata.ddrval);

        // Now we need to re-create any texture handles that we destroyed

        if (pData->ddrval == DD_OK)
        {
            pTemp = pContext->pDevice->pSurfList;
            while (pTemp != NULL)
            {
                if ((pTemp->dwFlags & DDSURFACE_DX6HANDLE) ||
                    (pTemp->dwFlags & DDSURFACE_DEFERCREATETEXHANDLE))
                {
                    D3DHAL_TEXTURECREATEDATA    data;
                    DWORD                       ret;

                    memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
                    data.dwhContext = pContext->Context;
                    data.lpDDS = (LPDIRECTDRAWSURFACE) pTemp->Surface.pHeavy;

                    CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                        pTemp->pDevice,
                                        pTemp->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureCreate,
                                        &data);
                    pTemp->dwCookie = data.dwHandle;
                    pTemp->dwFlags |= DDSURFACE_DX6HANDLE;
                    pTemp->dwFlags &= ~DDSURFACE_DEFERCREATETEXHANDLE;
                }
                pTemp = pTemp->pNext;
            }
        }
    }
    LEAVE_BOTH();
    return ret;
}


HRESULT WINAPI D3dContextDestroyAll(PD3D8_CONTEXTDESTROYALLDATA pDestroyAllContext)
{
    return DDHAL_DRIVER_HANDLED;
}


HRESULT WINAPI D3dGetDriverState(PD3D8_GETDRIVERSTATEDATA pGetDriverState)
{
    PDDCONTEXT  pContext = (PDDCONTEXT) pGetDriverState->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    pGetDriverState->ddRVal = D3DERR_DRIVERINTERNALERROR;
    ENTER_BOTH();
    if (!CheckForDeviceLost(pContext->pDevice))
    {
        pTemp = pGetDriverState->dwhContext;
        pGetDriverState->dwhContext = (ULONG_PTR) pContext->Context;

        CALL_D3DHAL_TAKEBUSY_NOWIN16(dwRet,
                    pContext->pDevice,
                    pContext->pDevice->pDD->lpLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState,
                    (LPDDHAL_GETDRIVERSTATEDATA)pGetDriverState);
        pGetDriverState->dwhContext = pTemp;

        pGetDriverState->ddRVal = MapLegacyResult(pGetDriverState->ddRVal);
    }
    LEAVE_BOTH();

    return dwRet;
}


HRESULT WINAPI D3dValidateTextureStageState(PD3D8_VALIDATETEXTURESTAGESTATEDATA pValidate)
{
    PDDCONTEXT  pContext = (PDDCONTEXT) pValidate->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    pValidate->ddrval = D3DERR_DEVICELOST;
    pValidate->dwNumPasses = 0;
    ENTER_BOTH();
    if (!CheckForDeviceLost(pContext->pDevice))
    {
        pTemp = pValidate->dwhContext;
        pValidate->dwhContext = (ULONG_PTR) pContext->Context;
        CALL_D3DHAL_TAKEBUSY_NOWIN16(dwRet,
                    pContext->pDevice,
                    pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks3->ValidateTextureStageState,
                    (D3DHAL_VALIDATETEXTURESTAGESTATEDATA*) pValidate);
        pValidate->dwhContext = pTemp;
    }
    LEAVE_BOTH();

    return dwRet;
}


DWORD WINAPI D3dDrawPrimitives2(PD3D8_DRAWPRIMITIVES2DATA pdp2data)
{
    D3DHAL_DRAWPRIMITIVES2DATA  dp2data;
    DWORD                       ret = 0;
    PDDCONTEXT                  pContext = (PDDCONTEXT) pdp2data->dwhContext;
    DDSURFACE*                  pSurfCommand;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyCommand;
    DDSURFACE*                  pSurfVertex = NULL;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyVertex = NULL;

    // Copy the data into our structure for easy access
    memcpy (&dp2data, pdp2data, sizeof(dp2data));

    // Start processing
    ENTER_BOTH();

    // Handle loss 
    if (CheckForDeviceLost(((PDDSURFACE)pdp2data->hDDCommands)->pDevice))
    {
        pdp2data->ddrval = DD_OK;
        pdp2data->dwErrorOffset = 0;

        // Need to set these values to their original
        // state so that the FE doesn't get confused.
        pdp2data->fpVidMem_CB     = 0;
        pdp2data->dwLinearSize_CB = 0;
        pdp2data->fpVidMem_VB       = 0;
        pdp2data->dwLinearSize_VB   = 0;

        // May need to return a pointer here
        if ((dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) && 
            !(dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES))
        {
            DDSURFACE*  pVertex = (PDDSURFACE)pdp2data->hDDVertex;

            if (pVertex->Pool == D3DPOOL_SYSTEMMEM)
            {                           
                if (pVertex->dwFlags & DDSURFACE_LIGHTWEIGHT)
                {
                    pdp2data->fpVidMem_VB = pVertex->Surface.pLight->fpGblVidMem;
                    pdp2data->dwLinearSize_VB = pVertex->Surface.pLight->GblPitch;
                }
                else
                {
                    pdp2data->fpVidMem_VB = pVertex->Surface.pHeavy->lpLcl->lpGbl->fpVidMem;
                    pdp2data->dwLinearSize_VB = pVertex->Surface.pHeavy->lpLcl->lpGbl->dwLinearSize;
                }
            }
            else if (pVertex->dwFlags & DDSURFACE_HEAVYWEIGHT)
            {
                if ((pVertex->fpVidMem == NULL) ||
                    !(pVertex->dwFlags & DDSURFACE_SYSMEMALLOCATED))
                {
                    pVertex->fpVidMem = (char*) MemAlloc(pVertex->Pitch);
                    if (pVertex->fpVidMem != NULL)
                    {
                        pVertex->dwFlags |= DDSURFACE_SYSMEMALLOCATED;
                    }
                }
                if (pVertex->dwFlags & DDSURFACE_SYSMEMALLOCATED)
                {
                    pdp2data->fpVidMem_VB = (ULONG_PTR) pVertex->fpVidMem;
                    pdp2data->dwLinearSize_VB = pVertex->Pitch;
                }
                else
                {
                    pdp2data->ddrval = DDERR_GENERIC;
                }
            }
        }
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    pSurfCommand = (PDDSURFACE)pdp2data->hDDCommands;
    pHeavyCommand = GetHeavyweightSurf(pSurfCommand);
    if (pHeavyCommand != NULL)
    {
        dp2data.lpDDCommands = pHeavyCommand->lpLcl;
    }
    else
    {
        pdp2data->ddrval = DDERR_OUTOFMEMORY;
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    if (!(pdp2data->dwFlags & D3DHALDP2_USERMEMVERTICES))
    {
        pSurfVertex = (PDDSURFACE)pdp2data->hDDVertex;
        pHeavyVertex = GetHeavyweightSurf(pSurfVertex);
        dp2data.lpDDVertex = pHeavyVertex->lpLcl;
    }
    dp2data.dwhContext = ((PDDCONTEXT)dp2data.dwhContext)->Context;

    if (((PDDSURFACE)pdp2data->hDDCommands)->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks3->DrawPrimitives2)
    {
        CALL_D3DHAL_TAKEBUSY_NOWIN16(
            ret,
            ((PDDSURFACE)pdp2data->hDDCommands)->pDevice,
            ((PDDSURFACE)pdp2data->hDDCommands)->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks3->DrawPrimitives2,
            &dp2data);
        if ((ret == DDHAL_DRIVER_HANDLED) && (dp2data.ddrval != DD_OK)
            && (DDERR_WASSTILLDRAWING != dp2data.ddrval))
        {
            ((PDDSURFACE)pdp2data->hDDCommands)->pDevice->bDP2Error = TRUE;
        }
    }

    // If the call to the driver succeded, swap the buffers if needed and
    // perform GetAliasVidmem
    if (ret == DDHAL_DRIVER_HANDLED && (dp2data.ddrval == DD_OK))
    {
        pdp2data->fpVidMem_CB = 0;
        pdp2data->dwLinearSize_CB = 0;
        pdp2data->fpVidMem_VB = 0;
        pdp2data->dwLinearSize_VB = 0;

        if (dp2data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER)
        {
            // CONSIDER: Implement VidMem command buffer
        }

        if ((dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) && !(dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES))
        {
            FLATPTR paliasbits;
            DWORD   dwLinearSize = dp2data.lpDDVertex->lpGbl->dwLinearSize;
            if (dp2data.dwFlags & D3DHALDP2_VIDMEMVERTEXBUF)
            {
                paliasbits = GetAliasedVidMem( dp2data.lpDDVertex->lpSurfMore->lpDD_lcl,
                                               dp2data.lpDDVertex,
                                               (FLATPTR) dp2data.lpDDVertex->lpGbl->fpVidMem );
                if (paliasbits == 0)
                {
                    D3D_ERR( "Could not get Aliased pointer for vid mem vertex buffer" );
                    // Since we can't use this pointer, set it's size to 0
                    // That way next time around we will try and allocate a new one
                    dwLinearSize = 0;
                }
            }
            else
            {
                paliasbits = dp2data.lpDDVertex->lpGbl->fpVidMem;
            }

            pdp2data->fpVidMem_VB = paliasbits;
            pdp2data->dwLinearSize_VB = dwLinearSize;
        }
    }
    if ((pSurfCommand->dwFlags & DDSURFACE_LIGHTWEIGHT) &&
        (pHeavyCommand != NULL))
    {
        UnmapLightweightSurface (pSurfCommand);
    }
    if ((pSurfVertex != NULL ) &&
        (pSurfVertex->dwFlags & DDSURFACE_LIGHTWEIGHT) &&
        (pHeavyVertex != NULL))
    {
        UnmapLightweightSurface (pSurfVertex);
   }

    pdp2data->ddrval = dp2data.ddrval;
    pdp2data->dwErrorOffset = dp2data.dwErrorOffset;
    LEAVE_BOTH();

    // We don't map the errors to the new ones because the runtime still needs
    // to deal with WASSTILLDRAWING, so it does the mapping instead of us.

    return ret;
}


PALETTEINFO* GetPaletteInfo (PDDDEVICEHANDLE pDevice, DWORD PaletteID)
{
    PALETTEINFO*    pPaletteInfo;
    HRESULT         hr;
    DWORD           i;

    // The palette IDs are app defined and can range from 0 - 65500.  We don't
    // want to always allocate a table with 65500 entries, and we don't want
    // to walk a list on every palette call, so we will grow the table to the
    // desired whenever we need to.  This works well if we assume that most
    // apps will start with low numbers and then work up.

    if (PaletteID >= pDevice->NumPaletteHandleEntries)
    {
        // We need to grow the table

        DWORD           NewTableSize;
        PALETTEINFO**   pNewTable;

        if (((DWORD)-1) - PaletteID <= EXTRA_PALETTE_PADDING)
        {
            NewTableSize = PaletteID + 1;
        }
        else
        {
            NewTableSize = PaletteID + EXTRA_PALETTE_PADDING + 1;
        }
        pNewTable = MemAlloc(NewTableSize * sizeof(PALETTEINFO*));
        if (pNewTable == NULL)
        {
            return NULL;
        }
        if ((pDevice->pPaletteHandleTable) &&
            (pDevice->NumPaletteHandleEntries > 0))
        {
            memcpy(pNewTable,
                   pDevice->pPaletteHandleTable,
                   pDevice->NumPaletteHandleEntries * sizeof(PALETTEINFO*));
            MemFree(pDevice->pPaletteHandleTable);
        }
        pDevice->pPaletteHandleTable = pNewTable;
        pDevice->NumPaletteHandleEntries = NewTableSize;
    }

    // If we already have info for this palette, we just return it now

    if (pDevice->pPaletteHandleTable[PaletteID] != NULL)
    {
        return pDevice->pPaletteHandleTable[PaletteID];
    }

    // Otherwise, we allocate a structure and initialize it

    pPaletteInfo = MemAlloc(sizeof(PALETTEINFO));
    if (pPaletteInfo == NULL)
    {
        return NULL;
    }
    for (i = 0; i < 256; i++)
    {
        pPaletteInfo->ColorTable[i].peRed   = (UCHAR) i;
        pPaletteInfo->ColorTable[i].peGreen = (UCHAR) i;
        pPaletteInfo->ColorTable[i].peBlue  = (UCHAR) i;
        pPaletteInfo->ColorTable[i].peFlags = (UCHAR) 0;
    }
    hr = DD_CreatePalette ((LPDIRECTDRAW) pDevice->pDD,
                            DDPCAPS_8BIT,
                            pPaletteInfo->ColorTable,
                            &pPaletteInfo->pDDPalette,
                            NULL);
    if (hr != DD_OK)
    {
        MemFree(pPaletteInfo);
        return NULL;
    }

    pDevice->pPaletteHandleTable[PaletteID] = pPaletteInfo;
    return pPaletteInfo;
}


DWORD WINAPI DdSetPalette (PD3D8_SETPALETTEDATA pSetPalette)
{
    PALETTEINFO*    pPalette;

    DDASSERT (((PDDDEVICEHANDLE)pSetPalette->hDD)->DriverLevel == 6);

    ENTER_BOTH();
    CheckForDeviceLost(pSetPalette->hDD);

    pSetPalette->ddRVal = D3DERR_DRIVERINTERNALERROR;
    pPalette = GetPaletteInfo (pSetPalette->hDD,
                               pSetPalette->Palette);
    if (pPalette != NULL)
    {
        pSetPalette->ddRVal = DD_OK;
        if ((((DDSURFACE*)pSetPalette->hSurface)->Surface.pHeavy != NULL) &&
            (((DDSURFACE*)pSetPalette->hSurface)->Surface.pHeavy->lpLcl->lpDDPalette !=
                (LPDDRAWI_DDRAWPALETTE_INT)pPalette->pDDPalette))
        {
            pSetPalette->ddRVal = MapLegacyResult(DD_Surface_SetPalette(
                (LPDIRECTDRAWSURFACE)((DDSURFACE*)pSetPalette->hSurface)->Surface.pHeavy,
                pPalette->pDDPalette));
        }
    }
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

DWORD WINAPI DdUpdatePalette (PD3D8_UPDATEPALETTEDATA pUpdatePalette)
{
    PALETTEINFO*    pPalette;

    DDASSERT (((PDDDEVICEHANDLE)pUpdatePalette->hDD)->DriverLevel == 6);

    ENTER_BOTH();
    CheckForDeviceLost(pUpdatePalette->hDD);

    pUpdatePalette->ddRVal = D3DERR_DRIVERINTERNALERROR;
    pPalette = GetPaletteInfo (pUpdatePalette->hDD,
                               pUpdatePalette->Palette);
    if (pPalette != NULL)
    {
        pUpdatePalette->ddRVal = MapLegacyResult(DD_Palette_SetEntries(
                                            pPalette->pDDPalette,
                                            0,
                                            0,
                                            256,
                                            pUpdatePalette->ColorTable));
    }
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

DWORD WINAPI D3dSceneCapture (PD3D8_SCENECAPTUREDATA pData)
{
    PDDCONTEXT pContext = (PDDCONTEXT) pData->dwhContext;
    LPDDRAWI_DIRECTDRAW_GBL pGbl = NULL;
    DWORD  ret = DDHAL_DRIVER_HANDLED;

    pData->ddrval = S_OK;

    ENTER_BOTH();
    if (CheckForDeviceLost(pContext->pDevice))
    {
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    pGbl = pContext->pDevice->pDD->lpLcl->lpGbl;
    if( pGbl->lpD3DHALCallbacks->SceneCapture )
    {
        D3DHAL_SCENECAPTUREDATA SceneCaptureData;
        memcpy( &SceneCaptureData, pData, sizeof( SceneCaptureData ) );
        SceneCaptureData.dwhContext   = pContext->Context;
        SceneCaptureData.ddrval       = S_OK;
        CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                             pContext->pDevice,
                             pGbl->lpD3DHALCallbacks->SceneCapture,
                             (D3DHAL_SCENECAPTUREDATA *)&SceneCaptureData);

        LEAVE_BOTH();
        pData->ddrval = MapLegacyResult(SceneCaptureData.ddrval);
        return ret;
    }

    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

//
// D3D8CreateDirectDrawObject
//
// Creates a DirectDraw object in DDRAW.DLL.  By mainting a full representation of
// this object in DDRAW.DLL, it will automatically update the HAL info after mode
// changes, etc.

VOID APIENTRY D3D8CreateDirectDrawObject( LPGUID        lpGuid,
                                          char          *szDeviceName,
                                          HANDLE*       phDD,
                                          D3DDEVTYPE    Type,
                                          HINSTANCE*    phLibrary,
                                          VOID*         pInitFunction)
{
    HRESULT         hr;
    LPDIRECTDRAW    lpDD1;
    PD3D8GetSWInfo  pfnHookCreate;
    DDDEVICEHANDLE* pDeviceHandle;
    HKEY            hKey = (HKEY) NULL;

    ENTER_DDRAW();
    *phDD = NULL;
    *phLibrary = NULL;
    pDeviceHandle = (PDDDEVICEHANDLE) MemAlloc(sizeof(DDDEVICEHANDLE));
    if (pDeviceHandle == NULL)
    {
        LEAVE_DDRAW();
        return;
    }
    lstrcpy(pDeviceHandle->szDeviceName, szDeviceName);
    pDeviceHandle->PID = GetCurrentProcessId();

    hr = InternalDirectDrawCreate (NULL, &lpDD1, NULL, 
        DDRAWILCL_DIRECTDRAW7 | DDRAWILCL_DIRECTDRAW8, szDeviceName);
    if( DD_OK == hr )
    {
        // Make it point to the DX7 vtbl.  Do this rather than a QI since
        // a QI for a DX7 object has some extra overhead.

        lpDD1->lpVtbl = (LPVOID) &dd7Callbacks;
        pDeviceHandle->pDD = (HANDLE) (LPDDRAWI_DIRECTDRAW_INT)lpDD1;
        pDeviceHandle->DeviceType = Type;

        if (Type == D3DDEVTYPE_REF)
        {
            // Load the refrast and let them take things over
            *phLibrary = LoadLibrary (D3D8_REFRASTNAME);
            pDeviceHandle->pSwDD = SwDDICreateDirectDraw();
            if (pDeviceHandle->pSwDD != NULL)
            {
                *phDD = (HANDLE*) pDeviceHandle;
            }
            else
            {
                lpDD1->lpVtbl->Release(lpDD1);
            }
        }
        else if (Type == D3DDEVTYPE_SW)
        {
            pDeviceHandle->pSwDD = SwDDICreateDirectDraw();
            if (pDeviceHandle->pSwDD != NULL)
            {
                *phDD = (HANDLE*) pDeviceHandle;
                pDeviceHandle->pSwInitFunction = pInitFunction;
            }
        }
        else
        {
            *phDD = (HANDLE*) pDeviceHandle;
        }
    }

    if (*phDD == NULL)
    {
        MemFree(pDeviceHandle);
    }
    else
    {
        pDeviceHandle->pLink = pDeviceList;
        pDeviceList = pDeviceHandle;
    }
    LEAVE_DDRAW();

    // See if they want to explicitly enable/disable lightweight surfaces

    if ((*phDD != NULL) && (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey)))
    {
        DWORD   type;
        DWORD   value;
        DWORD   cb = sizeof(value);

        pDeviceHandle->ForceFlagsOn = 0;
        pDeviceHandle->ForceFlagsOff = 0;
#ifdef DEBUG
        if (!RegQueryValueEx(hKey, "ForceDriverFlagsOn", NULL, &type, (CONST LPBYTE)&value, &cb))
        {
            pDeviceHandle->ForceFlagsOn = value;
        }
        cb = sizeof(value);
#endif
        if (!RegQueryValueEx(hKey, "ForceDriverFlagsOff", NULL, &type, (CONST LPBYTE)&value, &cb))
        {
            pDeviceHandle->ForceFlagsOff = value;
        }
        RegCloseKey(hKey);
    }
}

//
// D3D8ReenableDirectDrawObject
//
// On Win9X, this function doesn't do anything, but we have it since Win2K
// requires it and keeping it keeps the code bases more similar between the
// two platforms.

BOOL WINAPI D3D8ReenableDirectDrawObject( HANDLE hDD, LPBOOL pbNewMode )
{
    *pbNewMode = TRUE;
    return TRUE;
}

BOOL
SWCursorForced()
{
    if (0 != GetPrivateProfileInt("Display", "SwCursor", 0, "SYSTEM.INI"))
    {
        // ini setting always takes precedence
        DPF(2,"System.ini says SwCursor is ON");
        return TRUE;
    }
    else 
    {
        HKEY key;

        if (RegOpenKey(HKEY_CURRENT_CONFIG, "Display\\Settings", &key) == ERROR_SUCCESS)
        {
            char temp[10];
            DWORD len = sizeof(temp);
            DWORD type;
            DWORD i;
            if ((RegQueryValueEx(key, "SwCursor", NULL, (LPDWORD)&type,
                (LPBYTE)(LPSTR)temp, (LPDWORD)&len) == ERROR_SUCCESS) &&
                (type == REG_SZ))
            {
                for (i = 0; i < len; i++)
                {
                    if ( 0 == temp[i] )
                        break;                   
                    if ( '0' != temp[i] )
                    {
                        RegCloseKey(key);
                        DPF(2,"Regkey SwCursor is ON");
                        return TRUE;
                    }
                }
            }
            RegCloseKey(key);
        }
    }
    return FALSE;
}

//
// D3D8QueryDirectDrawObject
//
// This gets all of the actual HAL info.  It will typically be called twice,
// the first time to get the basic info (some of the input pointers will be
// NULL), and again to get all of the info.

BOOL WINAPI D3D8QueryDirectDrawObject (HANDLE           hDD,
                                       PD3D8_DRIVERCAPS pDriverCaps,
                                       PD3D8_CALLBACKS  pCallbacks,
                                       char             *pDeviceName,
                                       HINSTANCE        hLibrary,
                                       D3D8_GLOBALDRIVERDATA*  pGblDriverData,
                                       D3DHAL_D3DEXTENDEDCAPS* pExtendedCaps,
                                       LPDDSURFACEDESC  pTextureFormats,
                                       LPDDPIXELFORMAT  pZStencilFormats,
                                       UINT*            pcTextureFormats,
                                       UINT*            pcZStencilFormats
                                       )
{
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    DDSCAPSEX                   SurfCapsEx;
    DWORD                       dwRet;
    DWORD                       i;
    HDC                         hdc;
    D3DFORMAT*                  pTempZStencil;
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) hDD;
    DDHAL_GETDRIVERINFODATA     GetDriverInfoData;
    BOOL                        GotDX8Formats;

    ENTER_DDRAW();

    pdrv_lcl = pDevice->pDD->lpLcl;
    pdrv = pdrv_lcl->lpGbl;

    // Get all of the neccesary caps

    memset(pDriverCaps, 0, sizeof(D3D8_DRIVERCAPS));

    pDriverCaps->D3DCaps.Caps         = pdrv->ddCaps.dwCaps;
    pDriverCaps->D3DCaps.Caps2        = pdrv->ddCaps.dwCaps2;
    pDriverCaps->D3DCaps.Caps3        = pdrv->ddCaps.dwSVCaps;
    pDriverCaps->SVBCaps              = pdrv->ddCaps.dwSVBCaps;
    pDriverCaps->VSBCaps              = pdrv->ddCaps.dwVSBCaps;
    pDriverCaps->SVBCaps2             = pdrv->ddCaps.dwSVBCaps2;

    SurfCapsEx.dwCaps2                = pdrv->ddsCapsMore.dwCaps2;
    SurfCapsEx.dwCaps3                = pdrv->ddsCapsMore.dwCaps3;
    SurfCapsEx.dwCaps4                = pdrv->ddsCapsMore.dwCaps4;

    if (!IS_SOFTWARE_DRIVER(pDevice))
    {
        GotDX8Formats = FALSE;

        // See if we can get the DX8 caps directly
        if ((pdrv->dwFlags & DDRAWI_DRIVERINFO2) &&
            (pdrv->pGetDriverInfo != NULL))
        {
            D3DCAPS8                caps8;
            DD_GETDRIVERINFO2DATA*  pgdi2;
            
            memset(&caps8, 0, sizeof(caps8));

            pgdi2 = (DD_GETDRIVERINFO2DATA*)&caps8;

            // sizeof(DD_STEREOMODE)? The GUID for GetDriverInfo2 is shared with
            // the stereo mode querying stuff. Therefore we need to pass down
            // the structure size (and the expected data size) as
            // sizeof(DD_STEREOMODE) even though we actually have a buffer (and
            // expect a size of sizeof(D3DCAPS8).
            pgdi2->dwReserved     = sizeof(D3DCAPS8);
            pgdi2->dwMagic        = D3DGDI2_MAGIC;
            pgdi2->dwType         = D3DGDI2_TYPE_GETD3DCAPS8;
            pgdi2->dwExpectedSize = sizeof(D3DCAPS8);

            memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
            GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
            GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
            GetDriverInfoData.lpvData        = &caps8;
            GetDriverInfoData.dwExpectedSize = sizeof(D3DCAPS8);

            // Pass a context variable so that the driver
            // knows which instance of itself to use
            // w.r.t. this function. These are different
            // values on Win95 and NT.
            GetDriverInfoData.dwContext = pdrv->dwReserved3;

            if ((pdrv->pGetDriverInfo(&GetDriverInfoData) == DDHAL_DRIVER_HANDLED) && 
                (GetDriverInfoData.ddRVal == DD_OK ))
            {
                // Looks like we got D3DCAPS8 back from the driver. Verify by means
                // of the dwActualSize field in GetDriverInfoData.
                if (sizeof(D3DCAPS8) != GetDriverInfoData.dwActualSize)
                {
                    DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(D3DCAPS8))");
                    LEAVE_DDRAW();
                    return(FALSE);
                }

                // All went well. Copy the caps data across
                memcpy(&pDriverCaps->D3DCaps, &caps8, sizeof(caps8));

                // Display drivers can all render windowed
                if (pdrv->ddCaps.dwCaps2 & DDCAPS2_CANRENDERWINDOWED)
                {
                    pDriverCaps->D3DCaps.Caps2 |= DDCAPS2_CANRENDERWINDOWED;
                }

                // Set the flag indicating that the DDI successfully reported DX8
                // style caps
                pDriverCaps->dwFlags |= DDIFLAG_D3DCAPS8;
            }
        }

        // If this driver supports the DX8 DDI then use the new surface format reporting
        // mechanism rather than the texture formats reported in the global driver data
        if (pDriverCaps->dwFlags & DDIFLAG_D3DCAPS8)
        {
            DD_GETDRIVERINFO2DATA* pgdi2;
            DD_GETFORMATCOUNTDATA  gfcd;
            DD_GETFORMATDATA       gfd;

            // If DDIFLAG_D3DCAPS8 got set we have a driver info 2 support
            DDASSERT(pdrv->dwFlags & DDRAWI_DRIVERINFO2);
            DDASSERT(pdrv->pGetDriverInfo != NULL);

            // Step 1: Get the number of supported formats
            // Please see the description comments above for a description of why the
            // reserved field is set to sizeof(DD_STEREOMODE)
            memset(&gfcd, 0, sizeof(gfcd));

            gfcd.gdi2.dwReserved     = sizeof(DD_GETFORMATCOUNTDATA);
            gfcd.gdi2.dwMagic        = D3DGDI2_MAGIC;
            gfcd.gdi2.dwType         = D3DGDI2_TYPE_GETFORMATCOUNT;
            gfcd.gdi2.dwExpectedSize = sizeof(DD_GETFORMATCOUNTDATA);

            #if DBG
                // Ensure the driver actually sets the format count if it succeeds this call
                gfcd.dwFormatCount    = BOGUS_FIELD_VALUE;
            #endif // DBG

            memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
            GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
            GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
            GetDriverInfoData.lpvData        = &gfcd;
            GetDriverInfoData.dwExpectedSize = sizeof(DD_GETFORMATCOUNTDATA);
            GetDriverInfoData.dwContext      = pdrv->dwReserved3;

            if ((pdrv->pGetDriverInfo(&GetDriverInfoData) == DDHAL_DRIVER_HANDLED) && 
                (GetDriverInfoData.ddRVal == DD_OK ))
            {
                // Looks like we got a DD_GETFORMATCOUNTDATA back from the driver. Verify by means
                // of the dwActualSize field in GetDriverInfoData.
                if (sizeof(DD_GETFORMATCOUNTDATA) != GetDriverInfoData.dwActualSize)
                {
                    DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(DD_GETFORMATCOUNTDATA))");
                    LEAVE_DDRAW();
                    return(FALSE);
                }

                #ifdef DBG
                    if (BOGUS_FIELD_VALUE == gfcd.dwFormatCount)
                    {
                        DPF_ERR( "Driver succeeded GETFORMATCOUNT request but didn't set dwFormatCount" );
                        LEAVE_DDRAW();
                        return(FALSE);
                    }
                #endif // DBG

                // All went well. Replace the number of supported texture formats the driver
                // reported to us with this new number. We don't use the legacy texture format
                // list if this new mechanism is supported
            
                *pcTextureFormats = gfcd.dwFormatCount;

                // Flag the fact that we got DX8 style formats from the driver.
                GotDX8Formats = TRUE;

                // Step2: Query for each of the surface formats in turn.
                // We only do this if the caller requested that we do by means of a non-NULL
                // texture format buffer
                if (NULL != pTextureFormats)
                {
                    DWORD          c;
                    DDSURFACEDESC* pOutFormat;

                    // For simplicities sake we ask for a single format at a time. Not exactly
                    // high-performance but this should not matter at this stage of the code.
                    pOutFormat = pTextureFormats;
                    for (c = 0; c < (*pcTextureFormats); ++c)
                    {
                        // We reinitialize the entire request each time. We could probably
                        // optimize this but it doesn't seem worth it.
                        memset(&gfd, 0, sizeof(DD_GETFORMATDATA));

                        gfd.gdi2.dwReserved     = sizeof(DD_GETFORMATDATA);
                        gfd.gdi2.dwMagic        = D3DGDI2_MAGIC;
                        gfd.gdi2.dwType         = D3DGDI2_TYPE_GETFORMAT;
                        gfd.gdi2.dwExpectedSize = sizeof(DD_GETFORMATDATA);
                        gfd.dwFormatIndex        = c;
                        #if DBG
                            // Ensure the driver actually sets the format count if it succeeds this call
                            gfd.format.dwSize    = BOGUS_FIELD_VALUE;
                        #endif // DBG
 
                        memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
                        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
                        GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
                        GetDriverInfoData.lpvData        = &gfd;
                        GetDriverInfoData.dwExpectedSize = sizeof(DD_GETFORMATDATA);
                        GetDriverInfoData.dwContext      = pdrv->dwReserved3;

                        if ((pdrv->pGetDriverInfo(&GetDriverInfoData) == DDHAL_DRIVER_HANDLED) && 
                            (GetDriverInfoData.ddRVal == DD_OK ))
                        {
                            // Looks like we got a DD_GETFORMATDATA back from the driver. Verify by means
                            // of the dwActualSize field in GetDriverInfoData.
                            if (sizeof(DD_GETFORMATDATA) != GetDriverInfoData.dwActualSize)
                            {
                                DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(DD_GETFORMATDATA))");
                                LEAVE_DDRAW();
                                return(FALSE);
                            }

                            DDASSERT(c == gfd.dwFormatIndex);

                            #ifdef DBG
                                if (BOGUS_FIELD_VALUE == gfd.format.dwSize)
                                {
                                    DPF_ERR( "Driver succeeded GETFORMAT request but didn't set format" );
                                    LEAVE_DDRAW();
                                    return(FALSE);
                                }
                            #endif // DBG

                            // Looks like all went well so initialize the surface description
                            // part of the output format and copy the pixel format we got from
                            // the driver across
                            memset(pOutFormat, 0, sizeof(DDSURFACEDESC));
                            pOutFormat->dwSize  = sizeof(DDSURFACEDESC);
                            pOutFormat->dwFlags = DDSD_PIXELFORMAT;
                            memcpy(&pOutFormat->ddpfPixelFormat, &(gfd.format), sizeof(DDPIXELFORMAT));

                            ++pOutFormat;
                        }
                    }
                }
            }
            else
            {
                DPF(0, "Driver claims DX8 but fails call to GETFORMATCOUNT"             );
                DPF(0, "DX7 texture format list will be used but this will change soon" );
                DPF(0, "Fix driver to support DX8 style surface format reporting now"   );
            }
        }

        // The driver does not support the DX8 DDI so simply use the existing DX7
        // style texture format list.
        if (pdrv->lpD3DGlobalDriverData != NULL)
        {
            // Wackiness to get around type checking
            *pGblDriverData   = *(D3D8_GLOBALDRIVERDATA*) pdrv_lcl->lpGbl->lpD3DGlobalDriverData;

            // If we alreay have DX8 style formats from the driver don't bother using the DX7
            // style texture format list
            if (!GotDX8Formats)
            {
                *pcTextureFormats = pdrv_lcl->lpGbl->lpD3DGlobalDriverData->dwNumTextureFormats;

                if (pTextureFormats != NULL)
                {
                    memcpy(
                        pTextureFormats,
                        pdrv_lcl->lpGbl->lpD3DGlobalDriverData->lpTextureFormats,
                        pdrv_lcl->lpGbl->lpD3DGlobalDriverData->dwNumTextureFormats*sizeof(*pTextureFormats));
                }
            }

            // Get the D3D extended caps

            if (pdrv->lpD3DExtendedCaps)
            {
                *pExtendedCaps = *(pdrv->lpD3DExtendedCaps);
            }
        }
        else
        {
            // If we alreay have DX8 style formats from the driver don't bother using the DX7
            // style texture format list
            if (!GotDX8Formats)
            {
                *pcTextureFormats = 0;
            }
        }


        // Get the supported Z formats.  We only do this if we are not using a
        // software driver

        *pcZStencilFormats = pdrv->dwNumZPixelFormats;
        if (pdrv->dwNumZPixelFormats > 0)
        {
            if (pZStencilFormats)
            {
                memcpy(pZStencilFormats,
                    pdrv->lpZPixelFormats,
                    pdrv->dwNumZPixelFormats * sizeof( *pZStencilFormats ));
            }
        }
        else
        {
            if (pGblDriverData->hwCaps.dwDeviceZBufferBitDepth & DDBD_16)
            {
                (*pcZStencilFormats)++;
                if (pZStencilFormats)
                {
                    pZStencilFormats->dwSize = sizeof(DDPIXELFORMAT);
                    pZStencilFormats->dwFlags = DDPF_ZBUFFER;
                    pZStencilFormats->dwZBufferBitDepth = 16;
                    pZStencilFormats->dwStencilBitDepth = 0;
                    pZStencilFormats->dwZBitMask = 0xffff;
                    pZStencilFormats->dwStencilBitMask = 0x0000;
                    pZStencilFormats++;
                }
            }
            if (pGblDriverData->hwCaps.dwDeviceZBufferBitDepth & DDBD_32)
            {
                (*pcZStencilFormats)++;
                if (pZStencilFormats)
                {
                    pZStencilFormats->dwSize = sizeof(DDPIXELFORMAT);
                    pZStencilFormats->dwFlags = DDPF_ZBUFFER;
                    pZStencilFormats->dwZBufferBitDepth = 32;
                    pZStencilFormats->dwStencilBitDepth = 0;
                    pZStencilFormats->dwZBitMask = 0xffffffff;
                    pZStencilFormats->dwStencilBitMask = 0x00000000;
                    pZStencilFormats++;
                }
            }
        }
    }
   
    // Get info about the current mode

    pDriverCaps->DisplayWidth     = pdrv->vmiData.dwDisplayWidth;
    pDriverCaps->DisplayHeight    = pdrv->vmiData.dwDisplayHeight;
    pDriverCaps->DisplayFrequency = pdrv->dwMonitorFrequency;
    switch (pdrv->vmiData.ddpfDisplay.dwRGBBitCount)
    {
    case 8:
        pDriverCaps->DisplayFormatWithAlpha = D3DFMT_P8;
        pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_P8;
        break;

    case 15:
    case 16:
        if (pdrv->vmiData.ddpfDisplay.dwGBitMask == 0x7e0)
        {
            pDriverCaps->DisplayFormatWithAlpha = D3DFMT_R5G6B5;
            pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_R5G6B5;
        }
        else
        {
            pDriverCaps->DisplayFormatWithAlpha = D3DFMT_X1R5G5B5;
            pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_X1R5G5B5;
            if (pdrv->vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS)
            {
                pDriverCaps->DisplayFormatWithAlpha  = D3DFMT_A1R5G5B5;
            }
            //pdrv->vmiData.ddpfDisplay.dwRGBAlphaBitMask = 0;
            //pdrv->vmiData.ddpfDisplay.dwFlags &= ~DDPF_ALPHAPIXELS;
        }
        break;

    case 24:
        pDriverCaps->DisplayFormatWithAlpha = D3DFMT_R8G8B8;
        pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_R8G8B8;
        break;

    case 32:
        pDriverCaps->DisplayFormatWithAlpha = D3DFMT_X8R8G8B8;
        pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_X8R8G8B8;
        if (pdrv->vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS)
        {
            pDriverCaps->DisplayFormatWithAlpha = D3DFMT_A8R8G8B8;
        }
        //pdrv->vmiData.ddpfDisplay.dwRGBAlphaBitMask = 0;
        //pdrv->vmiData.ddpfDisplay.dwFlags &= ~DDPF_ALPHAPIXELS;
        break;

    default:
        pDriverCaps->DisplayFormatWithAlpha = D3DFMT_UNKNOWN;
        pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_UNKNOWN;
        break;
    }

    pDevice->DisplayFormatWithAlpha = pDriverCaps->DisplayFormatWithAlpha;
    pDevice->DisplayFormatWithoutAlpha = pDriverCaps->DisplayFormatWithoutAlpha;

    // Fill in the D3D8 Callback table
    RtlZeroMemory(pCallbacks, sizeof(*pCallbacks));
    pCallbacks->CreateSurface           = DdCreateSurface;
    pCallbacks->DestroySurface          = DdDestroySurface;
    pCallbacks->Lock                    = DdLock;
    pCallbacks->Unlock                  = DdUnlock;
    pCallbacks->Blt                     = DdBlt;
    pCallbacks->GetScanLine             = DdGetScanLine;
    pCallbacks->Flip                    = DdFlip;
    pCallbacks->WaitForVerticalBlank    = DdWaitForVerticalBlank;
    pCallbacks->GetBltStatus            = DdGetBltStatus;
    pCallbacks->GetFlipStatus           = DdGetFlipStatus;
    pCallbacks->SetMode                 = DdSetMode;
    pCallbacks->FlipToGDISurface        = DdFlipToGDISurface;
    pCallbacks->SetExclusiveMode        = DdSetExclusiveMode;
    pCallbacks->GetAvailDriverMemory    = DdGetAvailDriverMemory;
    pCallbacks->Clear2                  = D3dClear;
    pCallbacks->SetRenderTarget         = D3dSetRenderTarget;
    pCallbacks->SetColorkey             = DdSetColorkey;
    pCallbacks->SetPalette              = DdSetPalette;
    pCallbacks->UpdatePalette           = DdUpdatePalette;
    pCallbacks->SceneCapture            = D3dSceneCapture;

    if ((pdrv->lpD3DHALCallbacks != NULL) &&
        (pdrv->lpD3DHALCallbacks->ContextCreate != NULL))
    {
        pCallbacks->CreateContext   = D3dContextCreate;
    }
    if ((pdrv->lpD3DHALCallbacks != NULL) &&
        (pdrv->lpD3DHALCallbacks->ContextDestroy != NULL))
    {
        pCallbacks->ContextDestroy = D3dContextDestroy;
    }
    if ((pdrv->lpD3DHALCallbacks != NULL) &&
        (pdrv->lpD3DHALCallbacks->ContextDestroyAll != NULL))
    {
        pCallbacks->ContextDestroyAll = D3dContextDestroyAll;
    }
    if (pdrv->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState != NULL)
    {
        pCallbacks->GetDriverState = D3dGetDriverState;
    }
    if ((pdrv->lpD3DHALCallbacks3 != NULL) &&
        (pdrv->lpD3DHALCallbacks3->ValidateTextureStageState != NULL))
    {
        pCallbacks->ValidateTextureStageState = D3dValidateTextureStageState;
    }
    if ((pdrv->lpD3DHALCallbacks3 != NULL) &&
        (pdrv->lpD3DHALCallbacks3->DrawPrimitives2 != NULL))
    {
        pCallbacks->DrawPrimitives2 = D3dDrawPrimitives2;
    }

    // If Refrast or the HEL has a hook, call it to let it change whatever it wants

    if (IS_SOFTWARE_DRIVER(pDevice))
    {
        *pcZStencilFormats = 0;

        SwDDIMungeCaps (
            hLibrary,
            hDD,
            pDriverCaps,
            pCallbacks,
            pTextureFormats,
            pcTextureFormats,
            pDevice->pSwInitFunction
            );
    }

    // Now we need to determine what level of DX support the driver supports

    pDevice->DriverLevel = 0;
    if (pDriverCaps->D3DCaps.MaxStreams != 0)
    {
        pDevice->DriverLevel = 8;
    }
    else if (pCallbacks->GetDriverState != 0)
    {
        pDevice->DriverLevel = 7;
    }
    else if (pCallbacks->DrawPrimitives2 != 0)
    {
        pDevice->DriverLevel = 6;
        if (pDevice->pDefaultPalette == NULL)
        {
            PALETTEENTRY    ColorTable[256];
            int             i;

            for (i = 0; i < 256; i++)
            {
                ColorTable[i].peRed   = (UCHAR) i;
                ColorTable[i].peGreen = (UCHAR) i;
                ColorTable[i].peBlue  = (UCHAR) i;
            }
            DPF_MUTE();
            DD_CreatePalette ((LPDIRECTDRAW) pDevice->pDD,
                            DDPCAPS_8BIT,
                            ColorTable,
                            &pDevice->pDefaultPalette,
                            NULL);
            DPF_UNMUTE();
        }
    }

    if (pGblDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURESYSTEMMEMORY)
    {
        pDevice->bCanTextureSysmem = TRUE;
    }


    // Can this driver handle lightweight surfaces?

    pDriverCaps->KnownDriverFlags = 0;
    if (pDevice->DriverLevel < 7)
    {
        pDevice->bLightweight = FALSE;
    }
    else if (pDevice->DriverLevel == 7)
    {
        pDevice->bLightweight = CanKnownDriverDoThis(pDevice, KNOWN_LIGHTWEIGHT);
    }
    else
    {
        pDevice->bLightweight = TRUE;
    }
        
    // What about HW cursor support?
    // The check below needs to know the hardware driver level so it cannot use
    // pDevice->DriverLevel since it may be set due to ref. 

    if (SWCursorForced())
    {
        pDriverCaps->D3DCaps.CursorCaps = 0;
    }
    else if (((0 == pdrv->lpD3DExtendedCaps) || 
         (0 == pDriverCaps->D3DCaps.MaxStreams)) &&
        (NULL != pdrv->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState))
    {
        // The hardware driver is DX7
        if (CanKnownDriverDoThis(pDevice, KNOWN_HWCURSOR))
        {
            pDriverCaps->D3DCaps.CursorCaps = D3DCURSORCAPS_COLOR; 
            pDriverCaps->KnownDriverFlags |= KNOWN_HWCURSOR;
            if (CanKnownDriverDoThis(pDevice, KNOWN_HWCURSORLOWRES))
            {
                pDriverCaps->D3DCaps.CursorCaps |= D3DCURSORCAPS_LOWRES; 
                pDriverCaps->KnownDriverFlags |= KNOWN_HWCURSORLOWRES;
            }
        }
    }

    // If it's a pre-dx8 driver and they support cubemaps, we need to
    // specify whether they support mipped cubemaps or not.

    if (pDevice->DriverLevel < 8)
    {
        if (CanKnownDriverDoThis(pDevice, KNOWN_MIPPEDCUBEMAPS))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_MIPPEDCUBEMAPS;
        }

        // Does this driver have a Z/Stencil depth restriction?
    
        if (CanKnownDriverDoThis(pDevice, KNOWN_ZSTENCILDEPTH))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_ZSTENCILDEPTH;
        }

        // Does device have no driver known to over-queue windowed presentation blts?
        if (CanKnownDriverDoThis(pDevice, KNOWN_NOTAWINDOWEDBLTQUEUER))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_NOTAWINDOWEDBLTQUEUER;
        }

        // Does device support D3DFMT_D16_LOCKABLE
        if (CanKnownDriverDoThis(pDevice, KNOWN_D16_LOCKABLE))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_D16_LOCKABLE;
        }

        // Figure out what RT/Texture formats it supports
        if (CanKnownDriverDoThis(pDevice, KNOWN_CANMISMATCHRT))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_CANMISMATCHRT;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_X1R5G5B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_X1R5G5B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_R5G6B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_R5G6B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_X8R8G8B8))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_X8R8G8B8;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A8R8G8B8))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A8R8G8B8;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A1R5G5B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A1R5G5B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A4R4G4B4))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A4R4G4B4;
        }
    }

    // ATI drivers don't handle palettes correctly, so we will delete
    // all palettized textures from their list.

    if (pDevice->DriverLevel < 8)
    {
        if (((pDevice->PCIID >> 16) == 0x1002) &&
            (pTextureFormats != NULL))
        {
            i = 0;
            while (i < *pcTextureFormats)
            {
                if (pTextureFormats[i].ddpfPixelFormat.dwFlags & 
                    (DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8))
                {
                    UINT j;

                    (*pcTextureFormats)--;
                    for (j = i; j < *pcTextureFormats; j++)
                    {
                        pTextureFormats[j] = pTextureFormats[j+1];
                    }
                }
                else
                {
                    i++;
                }
            }
        }
    }

    // We assume that a software driver will always support at least DX7

    if ((pDevice->DriverLevel < 7) &&
        IS_SOFTWARE_DRIVER(pDevice))
    {
        LEAVE_DDRAW();
        DPF_ERR("A Software rasterizer must contain at least DX7 driver level support");
        return FALSE;
    }
    LEAVE_DDRAW();
    return TRUE;
}

VOID CleanupDevice (PDDDEVICEHANDLE pDevice)
{
    DWORD       i;
    DDSURFACE*  pSurf;
    DDSURFACE*  pSurfTemp;

    // Cleanup the palette allocations

    if (pDevice->pDefaultPalette != NULL)
    {
        InternalPaletteRelease((LPDDRAWI_DDRAWPALETTE_INT)
            pDevice->pDefaultPalette);
            pDevice->pDefaultPalette = NULL;
    }
    if (pDevice->NumPaletteHandleEntries > 0)
    {
        for (i = 0; i < pDevice->NumPaletteHandleEntries; i++)
        {
            if (pDevice->pPaletteHandleTable[i] != NULL)
            {
                InternalPaletteRelease((LPDDRAWI_DDRAWPALETTE_INT)
                    pDevice->pPaletteHandleTable[i]->pDDPalette);
                MemFree(pDevice->pPaletteHandleTable[i]);
                pDevice->pPaletteHandleTable[i] = NULL;
            }
        }
        MemFree(pDevice->pPaletteHandleTable);
        pDevice->pPaletteHandleTable = NULL;
        pDevice->NumPaletteHandleEntries = 0;
    }

    if (pDevice->pContext)
    {
        D3D8_CONTEXTDESTROYDATA data;

        data.dwhContext = (ULONG_PTR) pDevice->pContext;
        D3dContextDestroy(&data);
        pDevice->pContext = NULL;
    }

    pSurf = pDevice->pSurfList;
    while (pSurf != NULL)
    {
        if (!IS_SOFTWARE_DRIVER_SURFACE(pSurf))
        {
            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
            {   
                LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

                pHeavy = MapLightweightSurface(pSurf);
                if (pHeavy != NULL)
                {
                    pHeavy->dwIntRefCnt = 1;
                    pHeavy->lpLcl->dwLocalRefCnt = 1;
                    pHeavy->lpLcl->lpGbl->dwRefCnt = 1;

                    if (pSurf->dwFlags & DDSURFACE_ROOT)
                    {
                        pHeavy->lpLcl->lpSurfMore->pAddrefedThisOwner = (IUnknown*) pSurf->pDevice->pDD;
                    }

                    InternalSurfaceRelease(pHeavy, TRUE, TRUE);

                    pHeavy->dwReserved1 = (ULONG_PTR) NULL;
                    pHeavy->dwReserved2 = 0;
                }
                MemFree (pSurf->Surface.pLight);
                pSurf->Surface.pLight = NULL;
            }
            else if (pSurf->dwFlags & DDSURFACE_HEAVYWEIGHT)
            {
                if ((pSurf->dwFlags & DDSURFACE_ROOT) &&
                    (pSurf->Surface.pHeavy != NULL))
                {
                    InternalSurfaceRelease(pSurf->Surface.pHeavy, FALSE, TRUE);
                }
            }
        }
        else
        {
            MemFree(pSurf->Surface.pHeavy);
        }
        pSurfTemp = pSurf;
        pSurf = pSurf->pNext;
        MemFree(pSurfTemp);
    }

    if (pDevice->pSwDD)
    {
        if (pDevice->pSwDD->lpLcl->lpGbl->lpDDCBtmp)
        {
            MemFree(pDevice->pSwDD->lpLcl->lpGbl->lpDDCBtmp);
        }
        MemFree(pDevice->pSwDD);
    }

    if (pDevice->NumCachedSurfaces > 0)
    {
        for (i = 0; i < (DWORD) pDevice->NumCachedSurfaces; i++)
        {
            MemFree(pDevice->pCachedSurfaceTable[i].pSurface);
        }
        MemFree(pDevice->pCachedSurfaceTable);
        pDevice->pCachedSurfaceTable = NULL;
        pDevice->NumCachedSurfaces = 0;
    }

    if (pDevice->SurfaceHandleList.dwList != NULL)
    {
        MemFree(pDevice->SurfaceHandleList.dwList);
    }
}


VOID APIENTRY D3D8DeleteDirectDrawObject( HANDLE hDD )
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) hDD;
    LPDIRECTDRAW    lpDD;

    // hDD can be NULL in some error paths
    
    if (pDevice == NULL)
        return;

    ENTER_DDRAW();
    CleanupDevice(pDevice);

    lpDD = (LPDIRECTDRAW) pDevice->pDD;
    if (lpDD != NULL)
    {
        lpDD->lpVtbl->Release(lpDD);
    }

    if (pDeviceList == pDevice)
    {
        // If we're first, then update global list
        // pointer
        pDeviceList = pDevice->pLink;
    }
    else
    {
        // Find ourselves in the list
        PDDDEVICEHANDLE pDevicePrev = pDeviceList;
        while (pDevicePrev->pLink != pDevice)
        {
            pDevicePrev = pDevicePrev->pLink;
        }

        // Skip past our current node
        pDevicePrev->pLink = pDevice->pLink;
    }
    MemFree(pDevice);

    LEAVE_DDRAW();
}

HDC APIENTRY D3D8GetDC( HANDLE hSurface, LPPALETTEENTRY pPalette )
{
    HDC                         hdc   = NULL;
    PDDSURFACE                  pSurf = (PDDSURFACE) hSurface;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        DDSURFACEDESC               ddsd;

        ddsd.dwSize = sizeof(ddsd);

        pHeavy = GetHeavyweightSurf(pSurf);
        if (pHeavy == NULL)
        {
            hdc = NULL;
            DPF_ERR("Out of memory error mapping lightweight surface");
        }
        else
        {
            FillDDSurfaceDesc(pHeavy->lpLcl, &ddsd);
            ddsd.lpSurface = (void*)pHeavy->lpLcl->lpGbl->fpVidMem;

            hdc = DD16_GetDC((HDC)(pSurf->pDevice->pDD->lpLcl->hDC),
                             &ddsd,
                             NULL);

            if (hdc == NULL)
            {
                DPF_ERR("Failure to GetDC for non-heavyweight surface?");
            }
            DONE_HEAVYWEIGHT_SURF (pSurf);
        }
    }
    else 
    {
        pHeavy = GetHeavyweightSurf(pSurf);
        if (pHeavy == NULL)
        {
            DPF_ERR("Unable to map lightweight surface - out of memory");
            hdc = NULL;
        }
        else
        {
            HRESULT hr = InternalGetDC(pHeavy, &hdc, FALSE);
            if (FAILED(hr))
            {
                DPF_ERR("Could not get DC for surface");
                hdc = NULL;
            }
        }
    }
    return hdc;
}

BOOL APIENTRY D3D8ReleaseDC(HANDLE hSurface, HDC hdc)
{
    PDDSURFACE pSurf = (PDDSURFACE) hSurface;
    DDASSERT(hdc != NULL);

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        DD16_ReleaseDC(hdc);
    }

    else
    {   
        HRESULT                     hr;
        LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

        if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
        {
            pHeavy = GET_CACHED_LIGHTWEIGHT_INT(pSurf);
            DDASSERT(pHeavy != NULL);
        }
        else
        {
            pHeavy = pSurf->Surface.pHeavy;
        }

        hr = InternalReleaseDC(pHeavy->lpLcl, hdc, FALSE);
        if (FAILED(hr))
        {
            DPF_ERR("Could not release DC?");
        }
        DONE_HEAVYWEIGHT_SURF(pSurf);
    }
    return TRUE;
}

BOOL APIENTRY D3D8SetGammaRamp( HANDLE hDD, HDC hdc, LPVOID lpGammaRamp )
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) hDD;
    HRESULT         hr = E_FAIL;

    ENTER_BOTH();
    if (CheckForDeviceLost(hDD))
    {
        LEAVE_BOTH();
        return TRUE;
    }

    if (pDevice->pDD->lpLcl->lpPrimary != NULL)
    {
        hr = DD_Gamma_SetGammaRamp((LPDIRECTDRAWGAMMACONTROL) pDevice->pDD->lpLcl->lpPrimary,
                                    0, lpGammaRamp);
    }
    LEAVE_BOTH();
    if (SUCCEEDED(hr))
    {
        return TRUE;
    }
    return FALSE;
}

// D3D8BuildModeTable
//

VOID APIENTRY D3D8BuildModeTable( char*           pDeviceName,
                                  D3DDISPLAYMODE* pTable,
                                  DWORD*          pNumEntries,
                                  D3DFORMAT       Unknown16,
                                  HANDLE          hProfile,
                                  BOOL            b16bppSupported,
                                  BOOL            b32bppSupported                                 
                                  )
{
    PDDDEVICEHANDLE         pDeviceHandle = (PDDDEVICEHANDLE) hProfile;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    DWORD                   NumModes = 0;

    DWORD           i;
    DWORD           j;
    D3DFORMAT       format;

    if ((pDeviceHandle == NULL) ||
        (pDeviceHandle->pDD == NULL))
    {
        *pNumEntries = NumModes;
        return;
    }

    ENTER_DDRAW();
    pdrv = pDeviceHandle->pDD->lpLcl->lpGbl;

    NumModes = 0;
    for (i = 0; i < pdrv->dwNumModes; i++)
    {
        // Filter out all modes other than 15, 16 and 32bpp
        if ((pdrv->lpModeInfo[i].dwBPP != 15) &&
            (pdrv->lpModeInfo[i].dwBPP != 16) &&
            (pdrv->lpModeInfo[i].dwBPP != 32))
        {
            continue;
        }

        if (((pdrv->lpModeInfo[i].dwBPP == 15) ||
             (pdrv->lpModeInfo[i].dwBPP == 16)) &&
            !b16bppSupported)
        {
            continue;
        }
        else if ((pdrv->lpModeInfo[i].dwBPP == 32) &&
            !b32bppSupported)
        {
            continue;
        }

        // Can GDI and the monitor handle this mode/refresh rate?
        if(pdrv->dwFlags & DDRAWI_DISPLAYDRV)
        {
            DWORD   cds_flags;
            DEVMODE dm;
            int     cds_rc;
            BOOL    bUseRefresh;

            bUseRefresh = (pdrv->lpModeInfo[i].wRefreshRate > 0);
            makeDEVMODE( pdrv, &pdrv->lpModeInfo[i], FALSE, bUseRefresh, &cds_flags, &dm );

            cds_flags |= CDS_TEST;
            cds_rc = xxxChangeDisplaySettingsExA(pdrv->cDriverName, &dm, NULL, cds_flags, 0);
            if( cds_rc != 0 )
            {
                continue;
            }
            if (!MonitorCanHandleMode (pdrv, 
                                       pdrv->lpModeInfo[i].dwWidth, 
                                       pdrv->lpModeInfo[i].dwHeight, 
                                       pdrv->lpModeInfo[i].wRefreshRate))
            {
                continue;
            }
        }

        // Make sure that we understand the format.

        if ((pdrv->lpModeInfo[i].dwBPP == 16) ||
            (pdrv->lpModeInfo[i].dwBPP == 15))
        {
            format = Unknown16;
        }
        else
        {
            DDASSERT(pdrv->lpModeInfo[i].dwBPP == 32);
            format = D3DFMT_X8R8G8B8;
        }

        // Add the new mode.
        if (pTable != NULL)
        {
            ///The caller must pass us a number
            DDASSERT( (*pNumEntries) );
            if ( NumModes >= *pNumEntries )
            {
                //we exceeded the number of entries allocated for us.
                //tell the caller to re-query and try again.
                NumModes = 0;
                break;
            }

            pTable[NumModes].Width       = pdrv->lpModeInfo[i].dwWidth;
            pTable[NumModes].Height      = pdrv->lpModeInfo[i].dwHeight;
            pTable[NumModes].RefreshRate = pdrv->lpModeInfo[i].wRefreshRate;
            pTable[NumModes].Format      = format;
        }
        NumModes++;
    }
    LEAVE_DDRAW();

    *pNumEntries = NumModes;
}


BOOL APIENTRY D3D8IsDeviceLost( HANDLE hDD)
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) hDD;

    return pDevice->bDeviceLost;
}

BOOL APIENTRY D3D8CanRestoreNow( HANDLE hDD)
{
    PDDDEVICEHANDLE         pDevice = (PDDDEVICEHANDLE) hDD;
    LPDDRAWI_DIRECTDRAW_GBL pGbl;
    BOOL                    bSupported = FALSE;
    HRESULT hr;

    // If we aren't lost, then it's an easy call
    ENTER_DDRAW();

    if (!(pDevice->bDeviceLost))
    {
        LEAVE_DDRAW();
        return TRUE;
    }
    hr = DD_TestCooperativeLevel((LPDIRECTDRAW)pDevice->pDD);
    if ( DD_OK == hr || DDERR_WRONGMODE == hr)
    {
        // Are we in a mode in which D3D is supported?

        pGbl = pDevice->pDD->lpLcl->lpGbl;
        if (IS_SOFTWARE_DRIVER(hDD))
        {
            // Assume that any software driver can render in modes > 8bpp

            if (pGbl->vmiData.ddpfDisplay.dwRGBBitCount > 8)
            {
                bSupported = TRUE;
            }
        }


        if (pGbl->lpD3DGlobalDriverData != NULL)
        {
            switch (pGbl->vmiData.ddpfDisplay.dwRGBBitCount)
            {
            case 15:
            case 16:
                if (pGbl->lpD3DGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & DDBD_16)
                {
                    bSupported = TRUE;
                }
                break;

            case 24:
                if (pGbl->lpD3DGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & DDBD_24)
                {
                    bSupported = TRUE;
                }
                break;

            case 32:
                if (pGbl->lpD3DGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & DDBD_32)
                {
                    bSupported = TRUE;
                }
                break;
            }
        }
    }
    LEAVE_DDRAW();

    return bSupported;
}

VOID APIENTRY D3D8RestoreDevice( HANDLE hDD)
{
    HRESULT hr;
    DWORD i, j, k;
    DWORD Width, Height, Depth;
    BYTE *SliceSrc, *SliceDst, *RowSrc, *RowDst;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) hDD;
    PDDSURFACE      pSurf;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavy;
    PDEFERREDCREATE pDefCreate = pDevice->pDeferList;
    PDEFERREDCREATE *ppNext = &pDevice->pDeferList;
    PDEFERREDCREATE pTemp;
    D3D8_LOCKDATA LockData;
    D3D8_UNLOCKDATA UnlockData;

    ENTER_BOTH();
    if (!D3D8CanRestoreNow(hDD))
    {
        LEAVE_BOTH();
        return;
    }

    pDevice->bDeviceLost = FALSE;
    pDevice->bDP2Error = FALSE;

    // If a context was created while lost, we will not re-create it now since
    // we don't have a render target or Z Buffer (the vidmem surfaces would have
    // already been destroyed.  Therefore, we won't attempt to create the context
    // until they create the new surfaces and call SetRenderTarget.  We also
    // won't try to create any defered texture handles at this time since we may
    // not have a valid context.  We will also do that in the SetRenderTarget call.

    // Walk the list of surfaces and create any SurfaceEx surfaces that we may
    // have pending.

    pSurf = pDevice->pSurfList;
    while (pSurf != NULL)
    {
        if ((pSurf->dwFlags & DDSURFACE_DEFERCREATEEX) && 
            !(pSurf->dwFlags & DDSURFACE_DUMMY))
        {
            pHeavy = GetHeavyweightSurf(pSurf);
            if (pHeavy != NULL)
            {
                createsurfaceEx(pHeavy->lpLcl);
                DONE_HEAVYWEIGHT_SURF(pSurf);
            }

            pSurf->dwFlags &= ~DDSURFACE_DEFERCREATEEX;
        }
        pSurf = pSurf->pNext;
    }

    // Finally resurrect our deferred driver managed surfaces (Gulp!)

    while (pDefCreate != NULL)
    {
        // First check if the deferred surface exists at all. The problem
        // is that DdDestroySurface could have been called. We could have
        // removed the surface from the deferred list in DdDestroySurface
        // but since DdDestroySurface is called piecemeal, it gets
        // very annoying. The removal is best done here.
        // ASSUMPTION: if pSList[0].hKernelHandle is NULL then
        // pSList[1,2,etc].hKernelHandle are also NULL. There is no
        // reason for this to be not the case as of 3/2001.

        if (pDefCreate->CreateData.pSList[0].hKernelHandle == NULL)
        {
            pTemp = pDefCreate->pNext;
            *ppNext = pTemp;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
            continue;
        }

        // Attempt to resurrect

        pDefCreate->CreateData.bReUse = TRUE;
        hr = DdCreateSurface(&pDefCreate->CreateData);
        if (SUCCEEDED(hr))
        {
            for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
            {
                pSurf = (PDDSURFACE) pDefCreate->CreateData.pSList[i].hKernelHandle;

                // Reset DDSURF_SYSMEMALLOCATED to keep DdLock below happy

                pSurf->dwFlags &= ~DDSURFACE_SYSMEMALLOCATED;

                // Lock and copy

                ZeroMemory(&LockData, sizeof(LockData));
                LockData.hDD = hDD;
                LockData.hSurface = pSurf;
                hr = DdLock(&LockData);
                if (SUCCEEDED(hr))
                {
                    SliceSrc = (BYTE*)pSurf->fpVidMem;
                    SliceDst = (BYTE*)LockData.lpSurfData;
                    Width = pDefCreate->CreateData.pSList[i].cpWidth;
                    Height = pDefCreate->CreateData.pSList[i].cpHeight;
                    Depth = pDefCreate->CreateData.pSList[i].cpDepth;
                    if (!(pDefCreate->CreateData.Type == D3DRTYPE_VOLUME ||
                        pDefCreate->CreateData.Type == D3DRTYPE_VOLUMETEXTURE))
                    {
                        Depth = 1;
                    }
                    for (j = 0; j < Depth; ++j)
                    {
                        RowSrc = SliceSrc;
                        RowDst = SliceDst;
                        for (k = 0; k < Height; ++k)
                        {
                            CopyMemory(RowDst, RowSrc, min(LockData.lPitch, (LONG)Width * 8));
                            RowSrc += Width * 8;
                            RowDst += LockData.lPitch;
                        }
                        SliceSrc += Width * Height * 8;
                        SliceDst += LockData.lSlicePitch;
                    }

                    ZeroMemory(&UnlockData, sizeof(UnlockData));
                    UnlockData.hDD = hDD;
                    UnlockData.hSurface = pSurf;
                    hr = DdUnlock(&UnlockData);
                    if (FAILED(hr))
                    {
                        // TODO: Handle/(ignore?) failure 
                        DPF(0,"Unlock failed when resurrecting driver managed surface.");
                    }
                }
                else
                {
                    // TODO: Handle/(ignore?) failure 
                    DPF(0,"Lock failed when resurrecting driver managed surface. Texture may go missing.");
                }

                // Free the temporary fpVidmem that we allocated in CreateVidmemSurface
            
                MemFree(pSurf->fpVidMem);
                pSurf->fpVidMem = 0;
            }

            // Remove from list and freeup all memory
     
            pTemp = pDefCreate->pNext;
            *ppNext = pTemp;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
        }
        else
        {
            // We set ReUse to FALSE to indicate that we were not able to resurrect
            pDefCreate->CreateData.bReUse = FALSE;

            ppNext = &(pDefCreate->pNext);
            pDefCreate = pDefCreate->pNext;
        }
    }

    if (pDevice->pDeferList != NULL)
    {
        // TODO:
        // Ummm, we were not able to resurrect. This may be due to out of memory
        // which probably needs to be reported to the app.
        DPF(0,"Unable to resurrect all driver managed surfaces.");
    }

    LEAVE_BOTH();
}


BOOL APIENTRY D3D8DoVidmemSurfacesExist( HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFACE pSurf;

    // Walk the list and return TRUE is we find any surfaces that are either
    // local or nonlocal vidmem.

    ENTER_DDRAW();
    pSurf = pDeviceHandle->pSurfList;
    while (pSurf != NULL)
    {
        if ((pSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
            (pSurf->Pool == D3DPOOL_NONLOCALVIDMEM) ||
            (pSurf->dwFlags & DDSURFACE_TREATASVIDMEM))
        {
#if DBG
            DPF(0,"The following D3DPOOL_DEFAULT surfaces/buffers/textures still exist");
            pSurf = pDeviceHandle->pSurfList;
            while (pSurf != NULL)
            {
                if ((pSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
                    (pSurf->Pool == D3DPOOL_NONLOCALVIDMEM) ||
                    (pSurf->dwFlags & DDSURFACE_TREATASVIDMEM))
                {
                    switch (pSurf->Type)
                    {
                    case D3DRTYPE_SURFACE:
                        DPF(0,"  D3DRTYPE_SURFACE");
                        break;
                    case D3DRTYPE_VOLUME:
                        DPF(0,"  D3DRTYPE_VOLUME");
                        break;
                    case D3DRTYPE_TEXTURE:
                        DPF(0,"  D3DRTYPE_TEXTURE");
                        break;
                    case D3DRTYPE_VOLUMETEXTURE:
                        DPF(0,"  D3DRTYPE_VOLUMETEXTURE");
                        break;
                    case D3DRTYPE_CUBETEXTURE:
                        DPF(0,"  D3DRTYPE_CUBETEXTURE");
                        break;
                    case D3DRTYPE_VERTEXBUFFER:
                        DPF(0,"  D3DRTYPE_VERTEXBUFFER");
                        break;
                    case D3DRTYPE_INDEXBUFFER:
                        DPF(0,"  D3DRTYPE_INDEXBUFFER");
                        break;
                    case D3DRTYPE_COMMANDBUFFER:
                        DPF(0,"  D3DRTYPE_COMMANDBUFFER");
                        break;
                    default:
                        DPF(0,"  UNKNOWN SURFACE TYPE");
                        break;
                    }
                }
                pSurf = pSurf->pNext;
            }
#endif
            LEAVE_DDRAW();

            return TRUE;
        }
        pSurf = pSurf->pNext;
    }
    LEAVE_DDRAW();

    return FALSE;
}

DWORD APIENTRY D3D8GetMode( HANDLE          Handle,
                            char*           pDeviceName,
                            D3DDISPLAYMODE* pMode,
                            D3DFORMAT       Unknown16)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) Handle;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;

    ENTER_DDRAW();
    memset(pMode, 0, sizeof(D3DDISPLAYMODE));

    if (pDeviceHandle != NULL)
    {
        pdrv = pDeviceHandle->pDD->lpLcl->lpGbl;

        pMode->Width        = pdrv->vmiData.dwDisplayWidth;
        pMode->Height       = pdrv->vmiData.dwDisplayHeight;
        pMode->RefreshRate  = pdrv->dwMonitorFrequency;
        switch (pdrv->vmiData.ddpfDisplay.dwRGBBitCount)
        {
        case 8:
            pMode->Format = D3DFMT_P8;
            break;

        case 15:
        case 16:
            if (pdrv->vmiData.ddpfDisplay.dwGBitMask == 0x7e0)
            {
                pMode->Format = D3DFMT_R5G6B5;
            }
            else
            {
                pMode->Format = D3DFMT_X1R5G5B5;
            }
            break;

        case 24:
            pMode->Format = D3DFMT_R8G8B8;
            break;

        case 32:
            pMode->Format = D3DFMT_X8R8G8B8;
            break;

        default:
            pMode->Format = D3DFMT_UNKNOWN;
            break;
        }
        LEAVE_DDRAW();
        return DD_OK;
    }
    else
    {
        DEVMODE dm;
        HDC     hdc;

        memset (&dm, 0, sizeof(dm));
        dm.dmSize = sizeof(dm);

        // For pre-Win98 systems, we use GetDeviceCaps
        // because ENUM_CURRENT_SETTINGS is not
        // supported on these legacy systems.
        if (!IsWindows98())
        {
            DWORD bpp;

            hdc = GetDC(NULL);

            pMode->Width        = GetDeviceCaps(hdc, HORZRES);
            pMode->Height       = GetDeviceCaps(hdc, VERTRES);
            pMode->RefreshRate  = 0;

            bpp = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
            ReleaseDC(NULL, hdc);

            switch (bpp)
            {
            case 8:
                pMode->Format = D3DFMT_P8;
                break;

            case 24:
                pMode->Format = D3DFMT_R8G8B8;
                break;

            case 32:
                pMode->Format = D3DFMT_X8R8G8B8;
                break;

            case 15:
            case 16:
                pMode->Format = Unknown16;
                break;

            default:
                DPF(0, "Unknown desktop format");
                pMode->Format = D3DFMT_UNKNOWN;
                break;
            }
        }
        else if (EnumDisplaySettings(pDeviceName, ENUM_CURRENT_SETTINGS, &dm))
        {
            pMode->Width        = dm.dmPelsWidth;
            pMode->Height       = dm.dmPelsHeight;
            pMode->RefreshRate  = dm.dmDisplayFrequency;

            switch (dm.dmBitsPerPel)
            {
            case 8:
                pMode->Format = D3DFMT_P8;
                break;

            case 24:
                pMode->Format = D3DFMT_R8G8B8;
                break;

            case 32:
                pMode->Format = D3DFMT_X8R8G8B8;
                break;

            case 15:
            case 16:
                pMode->Format = Unknown16;
                break;

            default:
                pMode->Format = D3DFMT_UNKNOWN;
                break;
            }
        }
        else
        {
            LEAVE_DDRAW();
            DPF_ERR("EnumDisplaySettings failed?");
            DPF(0, "display is %s", pDeviceName);
            return D3DERR_DRIVERINTERNALERROR;
        }
        LEAVE_DDRAW();
        return DD_OK;
    }

    LEAVE_DDRAW();
    return D3DERR_DRIVERINTERNALERROR;
}


DWORD APIENTRY D3D8SetMode( HANDLE  Handle,
                            char*   pDeviceName,
                            UINT    Width,
                            UINT    Height,
                            UINT    BPP,
                            UINT    RefreshRate,
                            BOOL    bRestore)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) Handle;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    HRESULT                 hr = DDERR_GENERIC;
    DWORD                   i;

    ENTER_DDRAW();
    if ((pDeviceHandle != NULL) &&
        (pDeviceHandle->pDD != NULL))
    {
        // We will call DDraw to do the mode change because it is able to
        // cleanup the mode change when the app exits and because we don't
        // want to treat external mode changes and DDraw mode changes the
        // same way.

        pdrv = pDeviceHandle->pDD->lpLcl->lpGbl;
        for (i = 0; i < pdrv->dwNumModes; i++)
        {
            if ((pdrv->lpModeInfo[i].dwWidth == Width) &&
                (pdrv->lpModeInfo[i].dwHeight == Height) &&
                (pdrv->lpModeInfo[i].dwBPP == BPP))
            {
                if ((RefreshRate == 0) ||
                    (RefreshRate == pdrv->lpModeInfo[i].wRefreshRate))
                {
                    break;
                }
            }
        }
        if (i < pdrv->dwNumModes)
        {
            BOOL                    bExists;
            BOOL                    bOwn;
            LPDDRAWI_DIRECTDRAW_LCL lcl = pDeviceHandle->pDD->lpLcl;

            // When profiling, we will be doing mode changes w/o holding 
            // exlusive mode, but we need ddraw to think that we have it in
            // order to change bit depth.

            CheckExclusiveMode(lcl, &bExists, &bOwn, FALSE, NULL, FALSE);
            if (!bOwn)
            {
                if (bExists)
                {
                    LEAVE_DDRAW();
                    return D3DERR_DRIVERINTERNALERROR;
                }
                lcl->lpGbl->lpExclusiveOwner = lcl;
            }

            if (bRestore)
            {
                hr = MapLegacyResult(RestoreDisplayMode (lcl, TRUE));
            }
            else
            {
                hr = MapLegacyResult(SetDisplayMode (lcl,
                                     i,
                                     TRUE,
                                     RefreshRate != 0));
            }
            if (!bOwn)
            {
                // This check shouldn't be needed, but it's safe since just
                // about anything can happen during a mode change.

                if (lcl->lpGbl->lpExclusiveOwner == lcl)
                {
                    lcl->lpGbl->lpExclusiveOwner = NULL;
                }
            }
        }
    }
    LEAVE_DDRAW();

    return hr;
}


DWORD APIENTRY D3D8SetCooperativeLevel(
    HANDLE hDD,
    HWND hWnd,
    DWORD dwFlags )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) hDD;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int = pDevice->pDD;
    return MapLegacyResult(DD_SetCooperativeLevel((LPDIRECTDRAW)pdrv_int, hWnd, dwFlags|DDSCL_DX8APP));
}

BOOL APIENTRY D3D8IsDummySurface(
    HANDLE hSurface )
{
    PDDSURFACE  pSurf = (PDDSURFACE) hSurface;

    return ((pSurf->dwFlags & DDSURFACE_DUMMY) != 0);
}

void CleanupD3D8( LPDDRAWI_DIRECTDRAW_GBL pdrv,
                  BOOL bDestroyAll,
                  DWORD PID)
{
    DDDEVICEHANDLE* pDevice;
    DDDEVICEHANDLE* pTemp;

    ENTER_DDRAW();
    pDevice = pDeviceList;

    if (bDestroyAll)
    {
        // The process has died, so clean everything up.  We don't need to call
        // the software driver for anything since it's already unloaded.

        while (pDevice != NULL)
        {
            if (pDevice->PID == PID)
            {
                CleanupDevice(pDevice);

                // Remove this device from the list

                if (pDeviceList == pDevice)
                {
                    pDeviceList = pDevice->pLink;
                }
                else
                {
                    pTemp = pDeviceList;
                    while (pTemp->pLink != pDevice)
                    {
                        pTemp = pTemp->pLink;
                    }
                    pTemp->pLink = pDevice->pLink;
                }

                // Now free the device

                pTemp = pDevice;
                pDevice = pDevice->pLink;
                MemFree(pTemp);
            }
            else
            {
                pDevice = pDevice->pLink;
            }
        }
    }
    else
    {
        // The device is getting lost, so we will mark it as lost and free up
        // any resources that will get lost.

        while (pDevice != NULL)
        {
            if (pDevice->pDD->lpLcl->lpGbl == pdrv)
            {
                LoseDevice (pDevice);
            }
            pDevice = pDevice->pLink;
        }
    }
    LEAVE_DDRAW();
}


VOID APIENTRY D3D8LoseDevice(
    HANDLE hDD )
{
    ENTER_DDRAW();
    LoseDevice (hDD);
    LEAVE_DDRAW();
}



VOID APIENTRY D3D8GetHALName(
    char*   pDisplayName,
    char*   pHALName)
{
    LPDDRAWI_DIRECTDRAW_INT lpDD_int = NULL;
       
    ENTER_DDRAW();
    InternalDirectDrawCreate( NULL,
                              (LPDIRECTDRAW*) &lpDD_int,
                              NULL,
                              DDRAWILCL_DIRECTDRAW7 | DDRAWILCL_DIRECTDRAW8,
                              pDisplayName);
    if (lpDD_int != NULL)
    {
        lstrcpy(pHALName, lpDD_int->lpLcl->lpGbl->dd32BitDriverData.szName);
        DD_Release((LPDIRECTDRAW)lpDD_int);
    }
    LEAVE_DDRAW();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddheapr.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddheapr.c
 *  Content:	Rectangular heap manager
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   30-mar-95	kylej	initial implementation
 *   07-apr-95	kylej	Added rectVidMemAmountFree
 *   15-may-95	craige	made separate VMEM struct for rect & linear
 *   18-jun-95	craige	specific pitch
 *   02-jul-95	craige	have rectVidMemInit return a BOOL
 *   28-nov-95  colinmc new function to return amount of allocated memory
 *                      in a heap
 *   05-jul-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   18-jan-97  colinmc Work Item: AGP support
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   03-Feb-98  DrewB   Made portable between user and kernel.
 *
 ***************************************************************************/

#include "ddrawpr.h"

/****************************************************************************

 This memory manager manages allocation of rectangular blocks of 
 video memory.	It has essentially the same interface as the linear
 video memory manager implemented in vmemmgr.c.	 Memory allocations
 are tracked by nodes on two circular, doubly-linked lists; the free
 list and the alloc list.  Each list has a special node called the 
 sentinel which contains a special memory size.	 The head of each
 list always points to the sentinel node and the first member of the
 list (if there is one) is pointed to by the sentinel node.  Block
 adjacency information is kept in each node so that several free nodes 
 can be coalesced into larger free nodes.  This takes place every 
 time a block of memory is freed.
 
 This memory manager is designed to have no impact on video memory usage.
 Global memory is used to maintain the allocation and free lists.  Because
 of this choice, merging of free blocks is a more expensive operation.
 The assumption is that in general, the speed of creating/destroying these
 memory blocks is not a high usage item and so it is OK to be slower.

 ****************************************************************************/

/*
 * IS_FREE and NOT_FREE are used to set the free flag in the flags
 * field of each VMEM node.  The free flag is the lsb of this field.
 */
  
#define IS_FREE  0x00000001
#define NOT_FREE 0xfffffffe
 
/*
 * SENTINEL is the value stuffed into the size field of a VMEM
 * node to identify it as the sentinel node.  This value makes
 * the assumption that no rectangle sized 0x7fff by 0xffff will
 * ever be requested.
 */
  
#define SENTINEL 0x7fffffff

/*
 * MIN_DIMENSION_SIZE determines the smallest valid dimension for a 
 * free memory block.  If dividing a rectangle will result in a 
 * rectangle with a dimension less then MIN_DIMENSION_SIZE, the 
 * rectangle is not divided.
 */

#define MIN_DIMENSION_SIZE 4

/*
 * BLOCK_BOUNDARY must be a power of 2, and at least 4.	 This gives
 * us the alignment of memory blocks.	
 */
#define BLOCK_BOUNDARY	4

// This macro results in the free list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

/*
 * Debugging helpers
 */
#define DPFVMEMR(str,p) VDPF((0,V,"%s: %d,%d (%dx%d) ptr:%08x, block:%08x",str,p->x,p->y,p->cx,p->cy,p->ptr,p))
#define CHECK_HEAP(a,b) ;

/*
 * insertIntoDoubleList - add an item to the a list. The list is
 *	    kept in order of increasing size and is doubly linked.  The
 *	    list is circular with a sentinel node indicating the end
 *	    of the list.  The sentinel node has its size field set 
 *	    to SENTINEL.
 */
void insertIntoDoubleList( LPVMEMR pnew, LPVMEMR listhead )
{
    LPVMEMR	pvmem = listhead;

    #ifdef DEBUG
	if( pnew->size == 0 )
	{
	    VDPF(( 0, V, "block size = 0!!!\n" ));
	}
    #endif

    /*
     * run through the list (sorted from smallest to largest) looking
     * for the first item bigger than the new item.  If the sentinel
     * is encountered, insert the new item just before the sentinel.
     */

    while( pvmem->size != SENTINEL ) 
    {
	if( pnew->size < pvmem->size )
	{
	    break;
	}
	pvmem = pvmem->next;
    }

    // insert the new item before the found one.
    pnew->prev = pvmem->prev;
    pnew->next = pvmem;
    pvmem->prev->next = pnew;
    pvmem->prev = pnew;

} /* insertIntoDoubleList */

/*
 * rectVidMemInit - initialize rectangular video memory manager
 */
BOOL rectVidMemInit(
		LPVMEMHEAP pvmh,
		FLATPTR start,
		DWORD width,
		DWORD height,
		DWORD pitch )
{
    LPVMEMR newNode;

    VDPF(( 4, V, "rectVidMemInit(start=%08lx,width=%ld,height=%ld,pitch=%ld)", start, width, height, pitch));

    pvmh->dwTotalSize = pitch * height;

    // Store the pitch for future address calculations.
    pvmh->stride = pitch;

    // Set up the Free list and the Alloc list by inserting the sentinel.
    pvmh->freeList = MemAlloc( sizeof(VMEMR) );
    if( pvmh->freeList == NULL )
    {
	return FALSE;
    }
    ((LPVMEMR)pvmh->freeList)->size = SENTINEL;
    ((LPVMEMR)pvmh->freeList)->cx = SENTINEL;
    ((LPVMEMR)pvmh->freeList)->cy = SENTINEL;
    ((LPVMEMR)pvmh->freeList)->next = (LPVMEMR)pvmh->freeList;
    ((LPVMEMR)pvmh->freeList)->prev = (LPVMEMR)pvmh->freeList;
    ((LPVMEMR)pvmh->freeList)->pLeft = NULL;
    ((LPVMEMR)pvmh->freeList)->pUp = NULL;
    ((LPVMEMR)pvmh->freeList)->pRight = NULL;
    ((LPVMEMR)pvmh->freeList)->pDown = NULL;

    pvmh->allocList = MemAlloc( sizeof(VMEMR) );
    if( pvmh->allocList == NULL )
    {
	MemFree(pvmh->freeList);
	return FALSE;
    }
    ((LPVMEMR)pvmh->allocList)->size = SENTINEL;
    ((LPVMEMR)pvmh->allocList)->next = (LPVMEMR)pvmh->allocList;
    ((LPVMEMR)pvmh->allocList)->prev = (LPVMEMR)pvmh->allocList;

    // Initialize the free list with the whole chunk of memory
    newNode = (LPVMEMR)MemAlloc( sizeof( VMEMR ) );
    if( newNode == NULL )
    {
	MemFree(pvmh->freeList);
       	MemFree(pvmh->allocList);
	return FALSE;
    }
    newNode->ptr = start;
    newNode->size = CXCY(width, height);
    newNode->x = 0;
    newNode->y = 0;
    newNode->cx = width;
    newNode->cy = height;
    newNode->flags |= IS_FREE;
    newNode->pLeft = (LPVMEMR)pvmh->freeList;
    newNode->pUp = (LPVMEMR)pvmh->freeList;
    newNode->pRight = (LPVMEMR)pvmh->freeList;
    newNode->pDown = (LPVMEMR)pvmh->freeList;
    insertIntoDoubleList( newNode, ((LPVMEMR) pvmh->freeList)->next );

    return TRUE;

} /* rectVidMemInit */

/*
 * rectVidMemFini - done with rectangular video memory manager
 */
void rectVidMemFini( LPVMEMHEAP pvmh )
{
    LPVMEMR	curr;
    LPVMEMR	next;

    if( pvmh != NULL )
    {
	// free all memory allocated for the free list
	curr = ((LPVMEMR)pvmh->freeList)->next;
	while( curr->size != SENTINEL )
	{
	    next = curr->next;
	    MemFree( curr );
	    curr = next;
	}
	MemFree( curr );
	pvmh->freeList = NULL;

	// free all memory allocated for the allocation list
	curr = ((LPVMEMR)pvmh->allocList)->next;
	while( curr->size != SENTINEL )
	{
	    next = curr->next;
	    MemFree( curr );
	    curr = next;
	}
	MemFree( curr );
	pvmh->allocList = NULL;

	// free the heap data
	MemFree( pvmh );
    }
}   /* rectVidMemFini */

/*
 * GetBeforeWastage.
 * Align the surface in the given block. Return the size of the holes
 * on the left side of the surface.
 * Fail if alignment would cause surface to spill out of block.
 * Works for horizontal and vertical alignment.
 * IN:  dwBlockSize , dwBlockStart: Parameters of the block in which
 *                                  the surface hopes to fit
 *      dwSurfaceSize               Width or height of the surface
 *      dwAlignment                 Expected alignment. 0 means don't care
 * OUT: pdwBeforeWastage
 */
BOOL GetBeforeWastage(
    DWORD dwBlockSize,
    DWORD dwBlockStart,
    DWORD dwSurfaceSize, 
    LPDWORD pdwBeforeWastage, 
    DWORD dwAlignment )
{

    if (!dwAlignment)
    {
        *pdwBeforeWastage=0;
        /*
         * If no alignment requirement, then check if the surface fits
         */
        if (dwBlockSize >= dwSurfaceSize)
        {
            return TRUE;
        }
        return FALSE;
    }
    /*
     * There's an alignment.
     */
    *pdwBeforeWastage = (dwAlignment - (dwBlockStart % dwAlignment)) % dwAlignment;

    if ( *pdwBeforeWastage + dwSurfaceSize > dwBlockSize )
    {
            return FALSE;
    }

    DDASSERT( (dwBlockStart + *pdwBeforeWastage) % dwAlignment == 0 );
    return TRUE;
}

/*
 * rectVidMemAlloc - alloc some rectangular flat video memory
 */
FLATPTR rectVidMemAlloc( LPVMEMHEAP pvmh, DWORD cxThis, DWORD cyThis,
                         LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment )
{
    LPVMEMR	pvmem;
    DWORD	cyRem;
    DWORD	cxRem;
    DWORD	cxBelow;
    DWORD	cyBelow;
    DWORD	cxBeside;
    DWORD	cyBeside;
    LPVMEMR	pnewBeside;
    LPVMEMR	pnewBelow;
    DWORD       dwXAlignment=0;
    DWORD       dwYAlignment=0;
    DWORD       dwLeftWastage=0;
    DWORD       dwTopWastage=0;


    if((cxThis == 0) || (cyThis == 0) || (pvmh == NULL))
	return (FLATPTR) NULL;

    // Make sure the size of the block is a multiple of BLOCK_BOUNDARY
    // If every block allocated has a width which is a multiple of
    // BLOCK_BOUNDARY, it guarantees that all blocks will be allocated
    // on block boundaries.

    /*
     * Bump to new alignment
     */
    if( (cxThis >= (SENTINEL>>16) ) || (cyThis >= (SENTINEL&0xffff) ) )
	return (FLATPTR) NULL;


    if (lpAlignment)
    {
        dwXAlignment = lpAlignment->Rectangular.dwXAlignment;
        dwYAlignment = lpAlignment->Rectangular.dwYAlignment;
    }
    if (dwXAlignment < 4)
    {
        dwXAlignment = 4;
    }


    
    cxThis = (cxThis+(BLOCK_BOUNDARY-1)) & ~(BLOCK_BOUNDARY-1);

    /*
     * run through free list, looking for the closest matching block
     */

    pvmem = ((LPVMEMR)pvmh->freeList)->next;
    while (pvmem->size != SENTINEL)
    {
        if (!GetBeforeWastage( pvmem->cx, pvmem->x, cxThis, &dwLeftWastage, dwXAlignment ))
        {
	    pvmem = pvmem->next;
            continue; //X size or alignment makes surface spill out of block
        }
        // Now see if size/alignment works for Y
        if (!GetBeforeWastage( pvmem->cy, pvmem->y, cyThis, &dwTopWastage, dwYAlignment ))
        {
	    pvmem = pvmem->next;
            continue; //Y size alignment makes surface spill out of block
        }
        //success:
        break;
    }

    if(pvmem->size == SENTINEL)
    {
	// There was no rectangle large enough
	return (FLATPTR) NULL;
    }

    // pvmem now points to a rectangle that is the same size or larger
    // than the requested rectangle.  We're going to use the upper-left
    // corner of the found rectangle and divide the unused remainder into
    // two rectangles which will go on the available list.

    // grow allocation by the wastage which makes the top-left aligned
    cxThis += dwLeftWastage;
    cyThis += dwTopWastage;

    // Compute the width of the unused rectangle to the right and the 
    // height of the unused rectangle below:

    cyRem = pvmem->cy - cyThis;
    cxRem = pvmem->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are 
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow = cyRem;
    cxBeside = cxRem;

    if (cxRem <= cyRem)
    {
	cxBelow = cxThis + cxRem;
	cyBeside = cyThis;
    }
    else
    {
	cxBelow = cxThis;
	cyBeside = cyThis + cyRem;
    }

    // We only make new available rectangles of the unused right and 
    // bottom portions if they're greater in dimension than MIN_DIMENSION_SIZE.
    // It hardly makes sense to do the book-work to keep around a 
    // two pixel wide available space, for example.

    pnewBeside = NULL;
    if (cxBeside >= MIN_DIMENSION_SIZE)
    {
	pnewBeside = (LPVMEMR)MemAlloc( sizeof(VMEMR) );
	if( pnewBeside == NULL)
	    return (FLATPTR) NULL;

	// Update the adjacency information along with the other required
	// information in this new node and then insert it into the free
	// list which is sorted in ascending cxcy.

	// size information
	pnewBeside->size = CXCY(cxBeside, cyBeside);
	pnewBeside->x = pvmem->x + cxThis;
	pnewBeside->y = pvmem->y;
	pnewBeside->ptr = pvmem->ptr + cxThis;
	pnewBeside->cx = cxBeside;
	pnewBeside->cy = cyBeside;
	pnewBeside->flags |= IS_FREE;

	// adjacency information
	pnewBeside->pLeft = pvmem;
	pnewBeside->pUp = pvmem->pUp;
	pnewBeside->pRight = pvmem->pRight;
	pnewBeside->pDown = pvmem->pDown;
	insertIntoDoubleList( pnewBeside, ((LPVMEMR) pvmh->freeList)->next);

	// Modify the current node to reflect the changes we've made:

	pvmem->cx = cxThis;
    }

    pnewBelow = NULL;
    if (cyBelow >= MIN_DIMENSION_SIZE)
    {
	pnewBelow = (LPVMEMR) MemAlloc( sizeof(VMEMR) );
	if (pnewBelow == NULL)
	    return (FLATPTR) NULL;

	// Update the adjacency information along with the other required
	// information in this new node and then insert it into the free
	// list which is sorted in ascending cxcy.

	// size information
	pnewBelow->size = CXCY(cxBelow, cyBelow);
	pnewBelow->x = pvmem->x;
	pnewBelow->y = pvmem->y + cyThis;
	pnewBelow->ptr = pvmem->ptr + cyThis*pvmh->stride;
	pnewBelow->cx = cxBelow;
	pnewBelow->cy = cyBelow;
	pnewBelow->flags |= IS_FREE;

	// adjacency information
	pnewBelow->pLeft = pvmem->pLeft;
	pnewBelow->pUp = pvmem;
	pnewBelow->pRight = pvmem->pRight;
	pnewBelow->pDown = pvmem->pDown;
	insertIntoDoubleList( pnewBelow, ((LPVMEMR) pvmh->freeList)->next );

	// Modify the current node to reflect the changes we've made:

	pvmem->cy = cyThis;
    }

    // Update adjacency information for the current node

    if(pnewBelow != NULL)
    {
	pvmem->pDown = pnewBelow;
	if((pnewBeside != NULL) && (cyBeside == pvmem->cy))
	    pnewBeside->pDown = pnewBelow;
    }

    if(pnewBeside != NULL)
    {
	pvmem->pRight = pnewBeside;
	if ((pnewBelow != NULL) && (cxBelow == pvmem->cx))
	    pnewBelow->pRight = pnewBeside;
    }

    // Remove this node from the available list
    pvmem->next->prev = pvmem->prev;
    pvmem->prev->next = pvmem->next;

    // set up new pointers (pBits is the value returned to the client, pvmem
    // points to the actual top-left of the block).
    pvmem->pBits = pvmem->ptr + dwLeftWastage + dwTopWastage*pvmh->stride;
    pvmem->flags &= NOT_FREE;
    pvmem->size = CXCY(pvmem->cx, pvmem->cy);

    // Now insert it into the alloc list.
    insertIntoDoubleList( pvmem, ((LPVMEMR) pvmh->allocList)->next );

    if( NULL != lpdwSize )
    {
	/*
	 * Note this is the total number of bytes needed for this surface
	 * including the stuff off the left and right hand sides due to
	 * pitch not being equal to width. This is different from the
	 * size computed above which is simply the number of bytes within
	 * the boundary of the surface itself.
	 *
	 * The formula below calculates the number of bytes from the first
	 * byte in the rectangular surface to the first byte after it
	 * taking the pitch into account. Complex I know but it works.
	 */
	DDASSERT( 0UL != pvmem->cy );
	*lpdwSize = (pvmh->stride * (pvmem->cy - 1)) + pvmem->cx;
    }

    CHECK_HEAP("After rectVidMemAlloc",pvmh);
    return pvmem->pBits;

} /* rectVidMemAlloc */

/*
 * rectVidMemFree = free some rectangular flat video memory
 */
void rectVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    LPVMEMR	pvmem;
    LPVMEMR	pBeside;

    // Find the node in the allocated list which matches ptr
    for(pvmem=((LPVMEMR)pvmh->allocList)->next; pvmem->size != SENTINEL;
	pvmem = pvmem->next)
	if(pvmem->pBits == ptr)
	    break;

    if(pvmem->size == SENTINEL)	  // couldn't find allocated rectangle?
    {
	VDPF(( 0, V, "Couldn't find node requested freed!\n"));
	return;
    }

    // pvmem now points to the node which must be freed.  Attempt to 
    // coalesce rectangles around this node until no more action
    // is possible.

    while(1)
    {
	// Try merging with the right sibling:

	pBeside = pvmem->pRight;
	if ((pBeside->flags & IS_FREE)	     &&
	    (pBeside->cy    == pvmem->cy)    &&
	    (pBeside->pUp   == pvmem->pUp)   &&
	    (pBeside->pDown == pvmem->pDown) &&
	    (pBeside->pRight->pLeft != pBeside))
	{
	    // Add the right rectangle to ours:

	    pvmem->cx	 += pBeside->cx;
	    pvmem->pRight = pBeside->pRight;

	    // Remove pBeside from the list and free it.
	    pBeside->next->prev = pBeside->prev;
	    pBeside->prev->next = pBeside->next;
	    MemFree(pBeside);
	    continue;	    // go back and try again
	}

	// Try merging with the lower sibling:

	pBeside = pvmem->pDown;
	if ((pBeside->flags & IS_FREE)	       &&
	    (pBeside->cx     == pvmem->cx)     &&
	    (pBeside->pLeft  == pvmem->pLeft)  &&
	    (pBeside->pRight == pvmem->pRight) &&
	    (pBeside->pDown->pUp != pBeside))
	{
	    pvmem->cy	+= pBeside->cy;
	    pvmem->pDown = pBeside->pDown;

	    // Remove pBeside from the list and free it.
	    pBeside->next->prev = pBeside->prev;
	    pBeside->prev->next = pBeside->next;
	    MemFree(pBeside);
	    continue;	    // go back and try again
	}

	// Try merging with the left sibling:

	pBeside = pvmem->pLeft;
	if ((pBeside->flags & IS_FREE)	      &&
	    (pBeside->cy     == pvmem->cy)    &&
	    (pBeside->pUp    == pvmem->pUp)   &&
	    (pBeside->pDown  == pvmem->pDown) &&
	    (pBeside->pRight == pvmem)	      &&
	    (pvmem->pRight->pLeft != pvmem))
	{
	    // We add our rectangle to the one to the left:

	    pBeside->cx	   += pvmem->cx;
	    pBeside->pRight = pvmem->pRight;

	    // Remove 'pvmem' from the list and free it:
	    pvmem->next->prev = pvmem->prev;
	    pvmem->prev->next = pvmem->next;
	    MemFree(pvmem);
	    pvmem = pBeside;
	    continue;
	}

	// Try merging with the upper sibling:

	pBeside = pvmem->pUp;
	if ((pBeside->flags & IS_FREE)	       &&
	    (pBeside->cx       == pvmem->cx)   &&
	    (pBeside->pLeft  == pvmem->pLeft)  &&
	    (pBeside->pRight == pvmem->pRight) &&
	    (pBeside->pDown  == pvmem)	       &&
	    (pvmem->pDown->pUp != pvmem))
	{
	    pBeside->cy	     += pvmem->cy;
	    pBeside->pDown  = pvmem->pDown;

	    // Remove 'pvmem' from the list and free it:
	    pvmem->next->prev = pvmem->prev;
	    pvmem->prev->next = pvmem->next;
	    MemFree(pvmem);
	    pvmem = pBeside;
	    continue;
	}

	// Remove the node from its current list.

	pvmem->next->prev = pvmem->prev;
	pvmem->prev->next = pvmem->next;

	pvmem->size = CXCY(pvmem->cx, pvmem->cy);
	pvmem->flags |= IS_FREE;

	// Insert the node into the free list:
	insertIntoDoubleList( pvmem, ((LPVMEMR) pvmh->freeList)->next );

	// No more area coalescing can be done, return.

        CHECK_HEAP("After rectVidMemFree",pvmh);
	return;
    }
}

/*
 * rectVidMemAmountAllocated
 */
DWORD rectVidMemAmountAllocated( LPVMEMHEAP pvmh )
{
    LPVMEMR	pvmem;
    DWORD	size;

    size = 0;
    // Traverse the alloc list and add up all the used space.
    for(pvmem=((LPVMEMR)pvmh->allocList)->next; pvmem->size != SENTINEL;
	pvmem = pvmem->next)
    {
	size += pvmem->cx * pvmem->cy;
    }

    return size;

} /* rectVidMemAmountAllocated */

/*
 * rectVidMemAmountFree
 */
DWORD rectVidMemAmountFree( LPVMEMHEAP pvmh )
{
    LPVMEMR	pvmem;
    DWORD	size;

    size = 0;
    // Traverse the free list and add up all the empty space.
    for(pvmem=((LPVMEMR)pvmh->freeList)->next; pvmem->size != SENTINEL;
	pvmem = pvmem->next)
    {
	size += pvmem->cx * pvmem->cy;
    }

    return size;

} /* rectVidMemAmountFree */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddkernel.c ===
/*==========================================================================
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddkernel.c
 *  Content: 	APIs for getting the kernel mode handles for
 *              DirectDraw and the surfaces
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   09-jan-97	smac	created
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
    #include "ddkmmini.h"
    #include "ddkmapi.h"
#else
    #include "minivdd.h"
    #include "ddkmmini.h"
    #include "ddkmapip.h"
#endif
#define DPF_MODNAME "DirectDrawVideoPort"

#define DISPLAY_STR     "display"

extern char g_szPrimaryDisplay[]; // usually \\.\Display1 on Win98

#if WIN95
/*
 * IsWindows98
 */
BOOL IsWindows98( VOID )
{
    OSVERSIONINFO osVer;

    osVer.dwOSVersionInfoSize = sizeof( osVer );
    osVer.dwMinorVersion = 0;
    GetVersionEx( &osVer );

    return( ( osVer.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ) &&
        ( osVer.dwMinorVersion > 0 ) );
}


/*
 * SyncKernelSurface
 *
 * Initializes the buffer with the kernel surface info and then gives
 * it to the HAL so they can make whatever modifications are neccesary
 * and to fill in the dwDriverReserved fields with their internal state
 * data.
 */
HRESULT SyncKernelSurface( LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
			   LPDDKMSURFACEINFO lpddkmSurfaceInfo )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    DDHAL_SYNCSURFACEDATA HALSurfaceData;
    LPDDHALKERNELCB_SYNCSURFACE pfn;
    LPDDPIXELFORMAT lpddpfFormat;
    DWORD rc;

    /*
     * Determine the default data the best that we can
     */
    memset( &HALSurfaceData, 0, sizeof( HALSurfaceData ) );
    HALSurfaceData.dwSize = sizeof( HALSurfaceData );
    HALSurfaceData.lpDD = lpSurface->lpSurfMore->lpDD_lcl;
    HALSurfaceData.lpDDSurface = lpSurface;
    HALSurfaceData.dwSurfaceOffset = 0;
    HALSurfaceData.fpLockPtr = lpSurface->lpGbl->fpVidMem;
    HALSurfaceData.lPitch = (DWORD) lpSurface->lpGbl->lPitch;
    HALSurfaceData.dwOverlayOffset = 0;
    if( lpSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
    {
    	HALSurfaceData.dwOverlaySrcWidth =
	    lpSurface->rcOverlaySrc.right -
	    lpSurface->rcOverlaySrc.left;
    	HALSurfaceData.dwOverlaySrcHeight =
	    lpSurface->rcOverlaySrc.bottom -
	    lpSurface->rcOverlaySrc.top;
    	HALSurfaceData.dwOverlayDestWidth =
	    lpSurface->rcOverlayDest.right -
	    lpSurface->rcOverlayDest.left;
    	HALSurfaceData.dwOverlayDestHeight =
	    lpSurface->rcOverlayDest.bottom -
	    lpSurface->rcOverlayDest.top;
    }
    else
    {
    	HALSurfaceData.dwOverlaySrcWidth = 0;
    	HALSurfaceData.dwOverlaySrcHeight = 0;
    	HALSurfaceData.dwOverlayDestWidth = 0;
    	HALSurfaceData.dwOverlayDestHeight = 0;
    }

    /*
     * Now call the HAL and have it fill in the rest of the values
     */
    pfn = lpSurface->lpSurfMore->lpDD_lcl->lpDDCB->HALDDKernel.SyncSurfaceData;
    if( pfn != NULL )
    {
	DOHALCALL( SyncSurfaceData, pfn, HALSurfaceData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != HALSurfaceData.ddRVal )
	{
	    return (HRESULT)rc;
	}
    }
    else
    {
    	return DDERR_UNSUPPORTED;
    }

    /*
     * Now put all of the data into a structure that the VDD can understand
     */
    lpddkmSurfaceInfo->ddsCaps = lpSurface->ddsCaps.dwCaps;
    lpddkmSurfaceInfo->dwSurfaceOffset = HALSurfaceData.dwSurfaceOffset;
    lpddkmSurfaceInfo->fpLockPtr = HALSurfaceData.fpLockPtr;
    lpddkmSurfaceInfo->dwWidth = (DWORD) lpSurface->lpGbl->wWidth;
    lpddkmSurfaceInfo->dwHeight = (DWORD) lpSurface->lpGbl->wHeight;
    lpddkmSurfaceInfo->lPitch = HALSurfaceData.lPitch;
    lpddkmSurfaceInfo->dwOverlayFlags = lpSurface->lpSurfMore->dwOverlayFlags;
    lpddkmSurfaceInfo->dwOverlayOffset = HALSurfaceData.dwOverlayOffset;
    lpddkmSurfaceInfo->dwOverlaySrcWidth = HALSurfaceData.dwOverlaySrcWidth;
    lpddkmSurfaceInfo->dwOverlaySrcHeight = HALSurfaceData.dwOverlaySrcHeight;
    lpddkmSurfaceInfo->dwOverlayDestWidth = HALSurfaceData.dwOverlayDestWidth;
    lpddkmSurfaceInfo->dwOverlayDestHeight = HALSurfaceData.dwOverlayDestHeight;
    lpddkmSurfaceInfo->dwDriverReserved1 = HALSurfaceData.dwDriverReserved1;
    lpddkmSurfaceInfo->dwDriverReserved2 = HALSurfaceData.dwDriverReserved2;
    lpddkmSurfaceInfo->dwDriverReserved3 = HALSurfaceData.dwDriverReserved3;
    if( lpSurface->lpSurfMore->lpVideoPort == NULL )
    {
    	lpddkmSurfaceInfo->dwVideoPortId = (DWORD)-1;
    }
    else
    {
    	lpddkmSurfaceInfo->dwVideoPortId =
	    lpSurface->lpSurfMore->lpVideoPort->ddvpDesc.dwVideoPortID;
    }
    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurface->lpGbl );
    lpddkmSurfaceInfo->dwPhysicalPageTable = lpSurfGblMore->dwPhysicalPageTable;
    lpddkmSurfaceInfo->pPageTable = (DWORD)lpSurfGblMore->pPageTable;
    lpddkmSurfaceInfo->cPages = lpSurfGblMore->cPages;
    GET_PIXEL_FORMAT( lpSurface, lpSurface->lpGbl, lpddpfFormat );
    if( lpddpfFormat != NULL )
    {
	lpddkmSurfaceInfo->dwFormatFlags    = lpddpfFormat->dwFlags;
	lpddkmSurfaceInfo->dwFormatFourCC   = lpddpfFormat->dwFourCC;
	lpddkmSurfaceInfo->dwFormatBitCount = lpddpfFormat->dwRGBBitCount;
	lpddkmSurfaceInfo->dwRBitMask       = lpddpfFormat->dwRBitMask;
	lpddkmSurfaceInfo->dwGBitMask       = lpddpfFormat->dwGBitMask;
	lpddkmSurfaceInfo->dwBBitMask       = lpddpfFormat->dwBBitMask;
    }

    return DD_OK;
}


/*
 * SyncKernelVideoPort
 *
 * Initializes the buffer with the kernel video port info and then gives
 * it to the HAL so they can make whatever modifications are neccesary
 * and to fill in the dwDriverReserved fields with their internal state
 * data.
 */
HRESULT SyncKernelVideoPort( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort,
			     LPDDKMVIDEOPORTINFO lpddkmVideoPortInfo )
{
    LPDDHALKERNELCB_SYNCVIDEOPORT pfn;
    DDHAL_SYNCVIDEOPORTDATA HALVideoPortData;
    DWORD rc;

    /*
     * Determine the default data the best that we can
     */
    memset( &HALVideoPortData, 0, sizeof( HALVideoPortData ) );
    HALVideoPortData.dwSize = sizeof( HALVideoPortData );
    HALVideoPortData.lpDD = lpVideoPort->lpDD;
    HALVideoPortData.lpVideoPort = lpVideoPort;
    HALVideoPortData.dwOriginOffset = 0;
    if( lpVideoPort->ddvpInfo.dwVPFlags & DDVP_PRESCALE )
    {
    	HALVideoPortData.dwHeight = lpVideoPort->ddvpInfo.dwPrescaleHeight;
    }
    else if( lpVideoPort->ddvpInfo.dwVPFlags & DDVP_CROP )
    {
    	HALVideoPortData.dwHeight = lpVideoPort->ddvpInfo.rCrop.bottom -
    	    lpVideoPort->ddvpInfo.rCrop.top;
    }
    else
    {
    	HALVideoPortData.dwHeight = lpVideoPort->ddvpDesc.dwFieldHeight;
    }
    if( lpVideoPort->ddvpInfo.dwVPFlags & DDVP_INTERLEAVE )
    {
    	HALVideoPortData.dwHeight *= 2;
    }
    HALVideoPortData.dwVBIHeight = lpVideoPort->ddvpInfo.dwVBIHeight;

    /*
     * Now call the HAL and have it fill in the rest of the values
     */
    pfn = lpVideoPort->lpDD->lpDDCB->HALDDKernel.SyncVideoPortData;
    if( pfn != NULL )
    {
	DOHALCALL( SyncVideoPortData, pfn, HALVideoPortData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != HALVideoPortData.ddRVal )
	{
	    return (HRESULT)rc;
	}
    }
    else
    {
    	return DDERR_UNSUPPORTED;
    }

    /*
     * Now put all of the data into a structure that the VDD can understand
     */
    lpddkmVideoPortInfo->dwOriginOffset = HALVideoPortData.dwOriginOffset;
    lpddkmVideoPortInfo->dwHeight = HALVideoPortData.dwHeight;
    lpddkmVideoPortInfo->dwVBIHeight = HALVideoPortData.dwVBIHeight;
    lpddkmVideoPortInfo->dwDriverReserved1 = HALVideoPortData.dwDriverReserved1;
    lpddkmVideoPortInfo->dwDriverReserved2 = HALVideoPortData.dwDriverReserved2;
    lpddkmVideoPortInfo->dwDriverReserved3 = HALVideoPortData.dwDriverReserved3;

    return DD_OK;
}


/*
 * UpdateKernelSurface
 */
HRESULT UpdateKernelSurface( LPDDRAWI_DDRAWSURFACE_LCL lpSurface )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    HANDLE hDeviceHandle;
    DWORD ddRVal;

    if( !IsKernelInterfaceSupported( lpSurface->lpSurfMore->lpDD_lcl ) )
    {
	return DDERR_UNSUPPORTED;
    }

    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurface->lpGbl );
    if( lpSurfGblMore->hKernelSurface == 0 )
    {
	return DDERR_GENERIC;
    }
    else
    {
	DDKMSURFACEUPDATE ddkmSurfaceInfo;
	DWORD dwReturned;

        hDeviceHandle = GETDDVXDHANDLE( lpSurface->lpSurfMore->lpDD_lcl );
	if( INVALID_HANDLE_VALUE == hDeviceHandle )
	{
	    return DDERR_UNSUPPORTED;
	}

	/*
	 * Get/sync the surface info
	 */
	ddRVal = SyncKernelSurface( lpSurface, &(ddkmSurfaceInfo.si) );
	if( ddRVal != DD_OK )
	{
    	    DPF( 0, "Unable to sync surface data with HAL" );
	    return ddRVal;
	}

	/*
	 * Get the handle from the VDD
	 */
	ddkmSurfaceInfo.dwDirectDrawHandle =
	    lpSurface->lpSurfMore->lpDD_lcl->lpGbl->hKernelHandle;
	ddkmSurfaceInfo.dwSurfaceHandle =
	    lpSurfGblMore->hKernelSurface;
	ddRVal = (DWORD) DDERR_GENERIC;
    	DeviceIoControl( hDeviceHandle,
    	    DD_DXAPI_UPDATE_SURFACE_INFO,
	    &ddkmSurfaceInfo,
	    sizeof( ddkmSurfaceInfo ),
	    &ddRVal,
	    sizeof( ddRVal ),
	    &dwReturned,
	    NULL);
	if( ddRVal != DD_OK )
	{
    	    DPF( 0, "Unable to update the surface info" );
	    return DDERR_UNSUPPORTED;
	}
    }

    return DD_OK;
}


/*
 * GetKernelSurfaceState
 */
HRESULT GetKernelSurfaceState( LPDDRAWI_DDRAWSURFACE_LCL lpSurf, LPDWORD lpdwStateFlags )
{
    DDGETSURFACESTATEIN ddStateInput;
    DDGETSURFACESTATEOUT ddStateOutput;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    HANDLE hDeviceHandle;
    DWORD dwReturned;

    *lpdwStateFlags = 0;
    if( !IsKernelInterfaceSupported( lpSurf->lpSurfMore->lpDD_lcl ) )
    {
	return DDERR_UNSUPPORTED;
    }

    hDeviceHandle = GETDDVXDHANDLE( lpSurf->lpSurfMore->lpDD_lcl );
    if( INVALID_HANDLE_VALUE == hDeviceHandle )
    {
	return DDERR_UNSUPPORTED;
    }

    /*
     * Send the new info down to the VDD
     */
    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurf->lpGbl );
    ddStateInput.hDirectDraw = (HANDLE)
	(lpSurf->lpSurfMore->lpDD_lcl->lpGbl->hKernelHandle);
    ddStateInput.hSurface = (HANDLE)
	(lpSurfGblMore->hKernelSurface);
    ddStateOutput.ddRVal = (DWORD) DDERR_GENERIC;
    DeviceIoControl( hDeviceHandle,
    	DD_DXAPI_PRIVATE_GET_SURFACE_STATE,
	&ddStateInput,
	sizeof( ddStateInput ),
	&ddStateOutput,
	sizeof( ddStateOutput ),
	&dwReturned,
	NULL);
    if( ddStateOutput.ddRVal != DD_OK )
    {
	DPF( 0, "Unable to get the surface state" );
	return DDERR_UNSUPPORTED;
    }
    *lpdwStateFlags = ddStateOutput.dwStateStatus;

    return DD_OK;
}

/*
 * SetKernelDOSBoxEvent
 */
HRESULT SetKernelDOSBoxEvent( LPDDRAWI_DIRECTDRAW_LCL lpDD )
{
    DDSETDOSBOXEVENT ddDOSBox;
    DWORD dwReturned;
    DWORD ddRVal;

    ddDOSBox.dwDirectDrawHandle = lpDD->lpGbl->hKernelHandle;
    ddDOSBox.dwDOSBoxEvent = lpDD->lpGbl->dwDOSBoxEvent;
    ddRVal = (DWORD) DDERR_GENERIC;
    DeviceIoControl( (HANDLE)lpDD->hDDVxd,
	DD_DXAPI_SET_DOS_BOX_EVENT,
	&ddDOSBox,
	sizeof( ddDOSBox ),
	&ddRVal,
	sizeof( ddRVal ),
	&dwReturned,
	NULL);

    return DD_OK;
}


/*
 * UpdateKernelVideoPort
 *
 * On NT, this same stuff is done in kernel mode as part of the
 * UpdateVideo call, so it doesn't have to do it again here.
 */
HRESULT UpdateKernelVideoPort( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    LPDDRAWI_DDRAWSURFACE_LCL lpSurf;
    DDKMVIDEOPORTINFO ddkmVideoPortInfo;
    HANDLE hDeviceHandle;
    DWORD dwReturned;
    DWORD ddRVal;
    DWORD dwIRQ;
    DWORD i;

    if( ( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps == NULL ) ||
    	( lpVideoPort->lpDD->lpGbl->hKernelHandle == (DWORD)NULL ) )
    {
	return DDERR_UNSUPPORTED;
    }

    hDeviceHandle = GETDDVXDHANDLE( lpVideoPort->lpDD );
    if( INVALID_HANDLE_VALUE == hDeviceHandle )
    {
	return DDERR_UNSUPPORTED;
    }

    /*
     * Start filling in the info
     */
    memset( &ddkmVideoPortInfo, 0, sizeof( DDKMVIDEOPORTINFO ) );
    ddkmVideoPortInfo.dwDirectDrawHandle =
	lpVideoPort->lpDD->lpGbl->hKernelHandle;
    ddkmVideoPortInfo.dwVideoPortId = lpVideoPort->ddvpDesc.dwVideoPortID;
    ddkmVideoPortInfo.dwVPFlags = lpVideoPort->ddvpInfo.dwVPFlags;
    ddkmVideoPortInfo.dwFlags = dwFlags;
    if( lpVideoPort->dwFlags & DDRAWIVPORT_ON )
    {
	ddkmVideoPortInfo.dwFlags |= DDKMVP_ON;
    }
    if( dwFlags != DDKMVP_RELEASE )
    {
	if( ( lpVideoPort->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP ) &&
	    ( lpVideoPort->ddvpInfo.dwVPFlags & DDVP_AUTOFLIP ) )
	{
	    if( lpVideoPort->dwNumAutoflip > 0 )
	    {
		ddkmVideoPortInfo.dwFlags |= DDKMVP_AUTOFLIP;
	    }
	    if( lpVideoPort->dwNumVBIAutoflip > 0 )
	    {
		ddkmVideoPortInfo.dwFlags |= DDKMVP_AUTOFLIP_VBI;
	    }
	}
	ddkmVideoPortInfo.dwNumAutoflipping = lpVideoPort->dwNumAutoflip;
	ddkmVideoPortInfo.dwNumVBIAutoflipping = lpVideoPort->dwNumVBIAutoflip;

	/*
	 * Fill in surface handles for the regular video
	 */
	if( lpVideoPort->lpSurface != NULL )
	{
	    if( lpVideoPort->dwNumAutoflip > 0 )
	    {
		for( i = 0; i < lpVideoPort->dwNumAutoflip; i++ )
		{
		    lpSurf = lpVideoPort->lpFlipInts[i]->lpLcl;
		    DDASSERT( lpSurf != NULL );
		    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurf->lpGbl );
		    ddkmVideoPortInfo.dwSurfaceHandle[i] =
			lpSurfGblMore->hKernelSurface;
		}
	    }
	    else
	    {
	    	lpSurf = lpVideoPort->lpSurface->lpLcl;
	    	lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurf->lpGbl );
	    	ddkmVideoPortInfo.dwSurfaceHandle[0] =
		    lpSurfGblMore->hKernelSurface;
	    }
	}

	/*
	 * Fill in surface handles for the VBI data
	 */
	if( lpVideoPort->lpVBISurface != NULL )
	{
	    if( lpVideoPort->dwNumVBIAutoflip > 0 )
	    {
		DWORD dwCnt = 0;

		for( i = lpVideoPort->dwNumAutoflip;
		    i < (lpVideoPort->dwNumVBIAutoflip + lpVideoPort->dwNumAutoflip);
		    i++ )
		{
		    lpSurf = lpVideoPort->lpFlipInts[i]->lpLcl;
		    DDASSERT( lpSurf != NULL );
		    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurf->lpGbl );
		    ddkmVideoPortInfo.dwVBISurfaceHandle[dwCnt++] =
		        lpSurfGblMore->hKernelSurface;
		}
	    }
	    else
	    {
	    	lpSurf = lpVideoPort->lpVBISurface->lpLcl;
	    	lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurf->lpGbl );
	    	ddkmVideoPortInfo.dwVBISurfaceHandle[0] =
		    lpSurfGblMore->hKernelSurface;
	    }
	}

	/*
	 * Sync with the HAL
	 */
	if( dwFlags == DDKMVP_UPDATE )
	{
	    /*
	     * Get/sync the surface info
	     */
	    ddRVal = SyncKernelVideoPort( lpVideoPort, &ddkmVideoPortInfo );
	    if( ddRVal != DD_OK )
	    {
	    	DPF( 0, "Unable to sync video port data with HAL" );
	    	return ddRVal;
	    }
	}

	/*
	 * Does this support an IRQ?
	 */
	dwIRQ = DDIRQ_VPORT0_VSYNC;
	dwIRQ <<= ( lpVideoPort->ddvpDesc.dwVideoPortID * 2 );
    	if( !( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps->dwIRQCaps &
	    dwIRQ ) )
	{
	    ddkmVideoPortInfo.dwFlags |= DDKMVP_NOIRQ;
	}
    	if( !( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps->dwCaps &
	    DDKERNELCAPS_SKIPFIELDS ) )
	{
	    ddkmVideoPortInfo.dwFlags |= DDKMVP_NOSKIP;
	}
    }

    /*
     * Notify DDVXD if the even field is shifted down by one line
     * due to half lines.  This is really only an issue when capturing.
     */
    if( lpVideoPort->ddvpDesc.VideoPortType.dwFlags & DDVPCONNECT_HALFLINE )
    {
	ddkmVideoPortInfo.dwFlags |= DDKMVP_HALFLINES;
    }

    /*
     * Send the new info down to the VDD
     */
    ddRVal = (DWORD) DDERR_GENERIC;
    DeviceIoControl( hDeviceHandle,
    	DD_DXAPI_UPDATE_VP_INFO,
	&ddkmVideoPortInfo,
	sizeof( ddkmVideoPortInfo ),
	&ddRVal,
	sizeof( ddRVal ),
	&dwReturned,
	NULL);
    if( ddRVal != DD_OK )
    {
	DPF( 0, "Unable to update the video port info" );
	return DDERR_UNSUPPORTED;
    }

    return DD_OK;
}

/*
 * EnableAutoflip
 */
VOID EnableAutoflip( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, BOOL bEnable )
{
    DDENABLEAUTOFLIP ddkmEnableAutoflip;
    HANDLE hDeviceHandle;
    DWORD dwReturned;
    DWORD ddRVal;

    if( lpVideoPort == NULL )
    {
	return;
    }

    #ifdef WIN95
        if( !IsWindows98() )
        {
            return;
        }
    #endif

    hDeviceHandle = GETDDVXDHANDLE( lpVideoPort->lpDD );
    if( INVALID_HANDLE_VALUE == hDeviceHandle )
    {
	return;
    }

    /*
     * Start filling in the info
     */
    memset( &ddkmEnableAutoflip, 0, sizeof( DDENABLEAUTOFLIP ) );
    ddkmEnableAutoflip.dwDirectDrawHandle =
	lpVideoPort->lpDD->lpGbl->hKernelHandle;
    ddkmEnableAutoflip.dwVideoPortId = lpVideoPort->ddvpDesc.dwVideoPortID;
    ddkmEnableAutoflip.bEnableAutoflip = bEnable;
    ddRVal = (DWORD) DDERR_GENERIC;
    DeviceIoControl( hDeviceHandle,
    	DD_DXAPI_ENABLE_AUTOFLIP,
	&ddkmEnableAutoflip,
	sizeof( ddkmEnableAutoflip ),
	&ddRVal,
	sizeof( ddRVal ),
	&dwReturned,
	NULL);
}


/*
 * MungeAutoflipCaps
 */
void MungeAutoflipCaps( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    LPDDVIDEOPORTCAPS lpVideoPortCaps;
    DWORD i;

    if( ( pdrv->hKernelHandle != (DWORD) NULL ) &&
	( pdrv->lpDDVideoPortCaps != NULL ) &&
	( pdrv->lpDDKernelCaps != NULL ) &&
    	( pdrv->lpDDKernelCaps->dwCaps & DDKERNELCAPS_AUTOFLIP ) )
    {
	/*
	 * Software autoflipping is supported, so set the autoflip
	 * capabilities to the max.
	 */
	for( i = 0; i < pdrv->ddCaps.dwMaxVideoPorts; i++ )
	{
    	    lpVideoPortCaps = &(pdrv->lpDDVideoPortCaps[i]);
    	    if( ( lpVideoPortCaps != NULL ) &&
    	    	VALID_DDVIDEOPORTCAPS_PTR( lpVideoPortCaps ) )
    	    {
    	    	lpVideoPortCaps->dwCaps |= DDVPCAPS_AUTOFLIP;
    	    	lpVideoPortCaps->dwNumAutoFlipSurfaces = MAX_AUTOFLIP;
		if( lpVideoPortCaps->dwCaps & DDVPCAPS_VBISURFACE )
		{
    	    	    lpVideoPortCaps->dwNumVBIAutoFlipSurfaces = MAX_AUTOFLIP;
    	    	}
	    }
	}
    }
}
#endif


/*
 * InternalReleaseKernelHandle
 */
HRESULT InternalReleaseKernelSurfaceHandle( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, BOOL bLosingSurface )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    HANDLE hDeviceHandle;
    DWORD dwReturned;
    DWORD ddRVal;
    #ifdef WIN95
    DDRELEASEHANDLE ddRelease;
    #endif

    #ifdef WIN95
        if( lpSurface->lpSurfMore->lpDD_lcl->lpGbl->hKernelHandle == (DWORD) NULL )
        {
	    return DD_OK;
        }

        hDeviceHandle = GETDDVXDHANDLE( lpSurface->lpSurfMore->lpDD_lcl );
        if( INVALID_HANDLE_VALUE == hDeviceHandle )
        {
	    return DDERR_UNSUPPORTED;
        }
    #endif

    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurface->lpGbl );
    if( lpSurfGblMore->hKernelSurface == 0 )
    {
	return DD_OK;
    }

    /*
     * Check the ref count to make sure it's time to release this surface
     */
    if( bLosingSurface )
    {
	lpSurfGblMore->dwKernelRefCnt = 0;
    }
    else if( lpSurfGblMore->dwKernelRefCnt > 0 )
    {
	if( --(lpSurfGblMore->dwKernelRefCnt) > 0 )
	{
	    return DD_OK;
	}
    }

    #if WIN95

	/*
	 * Tell the VDD to release the surface
	 */
	ddRelease.dwDirectDrawHandle =
	    lpSurface->lpSurfMore->lpDD_lcl->lpGbl->hKernelHandle;
	ddRelease.hSurface = lpSurfGblMore->hKernelSurface;
	ddRVal = (DWORD) DDERR_GENERIC;

    	DeviceIoControl( hDeviceHandle,
    	    DD_DXAPI_RELEASE_SURFACE_HANDLE,
	    &ddRelease,
	    sizeof( ddRelease ),
	    &ddRVal,
	    sizeof( ddRVal ),
	    &dwReturned,
	    NULL);
	if( ddRVal != DD_OK )
	{
	    DPF_ERR( "Unable to release the surface handle in the VDD" );
	    return (HRESULT)ddRVal;
	}

    #else
	{
    	    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl = lpSurface->lpSurfMore->lpDD_lcl;
    	    LPDDRAWI_DIRECTDRAW_GBL pdrv = pdrv_lcl->lpGbl;

	    // Update DDraw handle in driver GBL object before calling DdGetDxHandle.
	    pdrv->hDD = pdrv_lcl->hDD;
	    DdGetDxHandle( NULL, lpSurface, TRUE );
	}

    #endif

    lpSurfGblMore->hKernelSurface = 0;

    return DD_OK;
}


/*
 * InternalCreateKernelSurfaceHandle
 */
HRESULT InternalCreateKernelSurfaceHandle( LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
					   PULONG_PTR lpHandle )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    HANDLE hDeviceHandle;
    DWORD ddRVal;

    *lpHandle = 0;
    if( !IsKernelInterfaceSupported( lpSurface->lpSurfMore->lpDD_lcl ) )
    {
	return DDERR_UNSUPPORTED;
    }

    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurface->lpGbl );
    if( lpSurfGblMore->hKernelSurface != 0 )
    {
	*lpHandle = lpSurfGblMore->hKernelSurface;
	lpSurfGblMore->dwKernelRefCnt++;
    }
    else
    {
	#if WIN95
	    DDKMSURFACEINFO ddkmSurfaceInfo;
	    DDGETSURFACEHANDLE ddkmGetSurfaceHandle;
	    DWORD dwReturned;

            hDeviceHandle = GETDDVXDHANDLE( lpSurface->lpSurfMore->lpDD_lcl );
	    if( INVALID_HANDLE_VALUE == hDeviceHandle )
	    {
	    	return DDERR_UNSUPPORTED;
	    }

	    /*
	     * Get/sync the surface info
	     */
	    ddRVal = SyncKernelSurface( lpSurface, &ddkmSurfaceInfo );
	    if( ddRVal != DD_OK )
	    {
    		DPF( 0, "Unable to sync surface data with HAL" );
		return ddRVal;
	    }

	    /*
             * Get the handle from DDRAW.VXD
	     */
	    ddkmSurfaceInfo.dwDirectDrawHandle =
	    	lpSurface->lpSurfMore->lpDD_lcl->lpGbl->hKernelHandle;
	    ddkmGetSurfaceHandle.ddRVal = (DWORD) DDERR_GENERIC;
	    ddkmGetSurfaceHandle.hSurface = 0;
    	    DeviceIoControl( hDeviceHandle,
    		DD_DXAPI_GET_SURFACE_HANDLE,
	    	&ddkmSurfaceInfo,
	    	sizeof( ddkmSurfaceInfo ),
	    	&ddkmGetSurfaceHandle,
	    	sizeof( ddkmGetSurfaceHandle ),
	    	&dwReturned,
		NULL);
	    if( ( ddkmGetSurfaceHandle.ddRVal != DD_OK ) ||
	    	( ddkmGetSurfaceHandle.hSurface == 0 ) )
	    {
    		DPF( 0, "Unable to get surface handle from the VDD" );
		return DDERR_UNSUPPORTED;
	    }
	    *lpHandle = lpSurfGblMore->hKernelSurface =
	   	ddkmGetSurfaceHandle.hSurface;

        #else

	    *lpHandle = (ULONG_PTR) DdGetDxHandle( NULL, lpSurface, 0 );
	    if( *lpHandle == 0 )
	    {
	        return DDERR_GENERIC;
	    }
	    lpSurfGblMore->hKernelSurface = *lpHandle;

        #endif

	lpSurfGblMore->dwKernelRefCnt = 1;
    }

    return DD_OK;
}


/*
 * InitKernelInterface
 */

#ifdef WINNT
#ifndef MAX_AUTOFLIP
#define MAX_AUTOFLIP 10
#endif
#endif

HRESULT InitKernelInterface( LPDDRAWI_DIRECTDRAW_LCL lpDD )
{
#ifdef WIN95
    VDD_IOCTL_SET_NOTIFY_INPUT vddNotify;
    DDINITDEVICEIN ddInput;
    DDINITDEVICEOUT ddOutput;
    DDSETKERNELCAPS ddSetCaps;
#endif
    LPDDKERNELCAPS lpKernelCaps;
    HANDLE hDeviceHandle;
    DWORD dwReturned;
    DWORD ddRVal;
    DWORD dwTemp;
    BYTE szDisplayName[MAX_DRIVER_NAME];

    #ifdef WIN95

        /*
         * Don't do anything unles we're Windows98 or later
         */
        if( !IsWindows98() )
        {
	    return DDERR_UNSUPPORTED;
        }

	/*
	 * Get the name of the VDD device to open
	 * This is a hack to do some temporary work on Win95
	 */
	lstrcpy( szDisplayName, lpDD->lpGbl->cDriverName );
	if( _stricmp( szDisplayName, DISPLAY_STR ) == 0 )
	{
	    lstrcpy( szDisplayName, g_szPrimaryDisplay );
	}

	/*
	 * Open the VDD for communication
	 */
	lpDD->lpGbl->hKernelHandle = 0;
	hDeviceHandle = CreateFile( szDisplayName,
	    GENERIC_WRITE,
	    FILE_SHARE_WRITE,
	    NULL,
	    OPEN_EXISTING,
	    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
	    NULL);
	if( INVALID_HANDLE_VALUE == hDeviceHandle )
	{
	    DPF( 0, "Unable to open the VDD" );
	    return DDERR_UNSUPPORTED;
	}

	/*
	 * Get the function table from the mini VDD
	 */
	memset( &ddInput, 0, sizeof( ddInput ) );
    	DeviceIoControl( hDeviceHandle,
	    VDD_IOCTL_GET_DDHAL,
	    &dwTemp,
	    sizeof( DWORD ),
	    &(ddInput.MiniVDDTable),
	    sizeof( DDMINIVDDTABLE ),
	    &dwReturned,
	    NULL);

	/*
         * Send the new info down to DDRAW.VXD
	 */
	lpKernelCaps = lpDD->lpGbl->lpDDKernelCaps;
	if( lpKernelCaps != NULL )
	{
	    ddInput.dwMaxVideoPorts = lpDD->lpGbl->ddCaps.dwMaxVideoPorts;
	    if( lpDD->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANBOBINTERLEAVED )
	    {
    	        ddInput.dwDeviceFlags |= DDKMDF_CAN_BOB_INTERLEAVED;
	    }
	    if( lpDD->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED )
	    {
    	        ddInput.dwDeviceFlags |= DDKMDF_CAN_BOB_NONINTERLEAVED;
	    }
	    if( !( lpKernelCaps->dwCaps & DDKERNELCAPS_SETSTATE ) )
	    {
    	        ddInput.dwDeviceFlags |= DDKMDF_NOSTATE;
	    }
	}
	ddOutput.ddRVal = (DWORD) DDERR_GENERIC;
        DeviceIoControl( (HANDLE)lpDD->hDDVxd,
	    DD_DXAPI_INIT_DEVICE,
	    &ddInput,
	    sizeof( ddInput ),
	    &ddOutput,
	    sizeof( ddOutput ),
	    &dwReturned,
	    NULL);
	if( ddOutput.ddRVal != DD_OK )
	{
	    DPF( 0, "Unable to initialize the kernel data" );
	    CloseHandle( hDeviceHandle );
	    return DDERR_UNSUPPORTED;
	}

	/*
	 * If unable to allocate the IRQ, disable functionality that depends
	 * on it.
	 */
	if( lpKernelCaps != NULL )
	{
	    if( !ddOutput.bHaveIRQ )
	    {
	        DPF( 1, "Unable to allocate IRQ - disabling some kernel mode functionality" );
	        lpKernelCaps->dwIRQCaps = 0;
	    }

	    /*
	     * Disable kernel mode caps for which functions are not available
	     */
	    if( ( ddInput.MiniVDDTable.vddGetIRQInfo == NULL ) ||
	        ( ddInput.MiniVDDTable.vddEnableIRQ == NULL ) )
	    {
	        // Can't to any IRQ stuff w/o these functions
	        DPF( 1, "vddGet/EnableIRQ not supported - overriding dwIRQCaps" );
	        lpKernelCaps->dwIRQCaps = 0;
	    }
	    if( ddInput.MiniVDDTable.vddSetState == NULL )
	    {
	        DPF( 1, "vddSetState not supported - overriding DDKERNELCAPS_SETSTATE" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_SETSTATE;
	    }
	    if( ddInput.MiniVDDTable.vddLock == NULL )
	    {
	        DPF( 1, "vddLock not supported - overriding DDKERNELCAPS_LOCK" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_LOCK;
	    }
	    if( ddInput.MiniVDDTable.vddSkipNextField == NULL )
	    {
	        DPF( 1, "vddSkipNextField not supported - overriding DDKERNELCAPS_SKIPFIELDS" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_SKIPFIELDS;
	    }
	    if( ddInput.MiniVDDTable.vddFlipOverlay == NULL )
	    {
	        DPF( 1, "vddFlipOverlay not supported - overriding DDKERNELCAPS_FLIPOVERLAY" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_FLIPOVERLAY;
	    }
	    if( ddInput.MiniVDDTable.vddFlipVideoPort == NULL )
	    {
	        DPF( 1, "vddFlipVideoPort not supported - overriding DDKERNELCAPS_FLIPVIDEOPORT" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_FLIPVIDEOPORT;
	    }
	    if( ddInput.MiniVDDTable.vddGetPolarity == NULL )
	    {
	        DPF( 1, "vddGetFieldPolarity not supported - overriding DDKERNELCAPS_FIELDPOLARITY" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_FIELDPOLARITY;
	    }
	    if( ( ddInput.MiniVDDTable.vddTransfer == NULL ) ||
	        ( ddInput.MiniVDDTable.vddGetTransferStatus == NULL ) )
	    {
	        DPF( 1, "vddTransfer/GetTransferStatus not supported - overriding DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM/SYSMEM" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM;
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_CAPTURE_SYSMEM;
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_CAPTURE_INVERTED;
	    }
	    if( ( ddInput.MiniVDDTable.vddBobNextField == NULL ) &&
	        ( lpDD->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANBOBINTERLEAVED ) )
	    {
	        DPF( 1, "vddBobNextField not supported - overriding DDKERNELCAPS_AUTOFLIP" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_AUTOFLIP;
	    }
	    if( ( ddInput.MiniVDDTable.vddFlipOverlay == NULL ) ||
	        ( ddInput.MiniVDDTable.vddFlipVideoPort == NULL ) )
	    {
	        DPF( 1, "vddFlipOverlay/VideoPort not supported - overriding DDKERNELCAPS_AUTOFLIP" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_AUTOFLIP;
	    }
	    if( !( lpKernelCaps->dwIRQCaps & DDIRQ_VPORT0_VSYNC ) )
	    {
	        DPF( 1, "DDIRQ_VPORT0_VSYNC not set - overriding DDKERNELCAPS_AUTOFLIP" );
	        lpKernelCaps->dwCaps &= ~( DDKERNELCAPS_AUTOFLIP | DDKERNELCAPS_SETSTATE );
	    }
	    if( !( lpKernelCaps->dwCaps & DDKERNELCAPS_AUTOFLIP ) )
	    {
	        DPF( 1, "DDKERNELCAPS_AUTOFLIP not set - overriding DDKERNELCAPS_SKIPFIELDS" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_SKIPFIELDS;
	    }

	    /*
             * Notify DDVXD of the updated caps
	     */
    	    ddSetCaps.dwDirectDrawHandle = ddOutput.dwDirectDrawHandle;
    	    ddSetCaps.dwCaps = lpKernelCaps->dwCaps;
    	    ddSetCaps.dwIRQCaps = lpKernelCaps->dwIRQCaps;
	    ddRVal = (DWORD) DDERR_GENERIC;
            DeviceIoControl( (HANDLE)lpDD->hDDVxd,
	        DD_DXAPI_SET_KERNEL_CAPS,
	        &ddSetCaps,
	        sizeof( ddSetCaps ),
	        &ddRVal,
	        sizeof( ddRVal ),
	        &dwReturned,
	        NULL);
	    if( ddRVal != DD_OK )
	    {
	        DPF( 0, "Unable to initialize the kernel data" );
	        CloseHandle( hDeviceHandle );
	        return DDERR_UNSUPPORTED;
	    }
	}


	/*
	 * Tell the VDD to notify us of dos box and res change events.
	 */
	vddNotify.NotifyMask = VDD_NOTIFY_START_MODE_CHANGE |
	    VDD_NOTIFY_END_MODE_CHANGE | VDD_NOTIFY_ENABLE | VDD_NOTIFY_DISABLE;
	vddNotify.NotifyType = VDD_NOTIFY_TYPE_CALLBACK;
	vddNotify.NotifyProc = ddOutput.pfnNotifyProc;
	vddNotify.NotifyData = ddOutput.dwDirectDrawHandle;
    	DeviceIoControl( hDeviceHandle,
	    VDD_IOCTL_SET_NOTIFY,
	    &vddNotify,
	    sizeof( vddNotify ),
	    &dwTemp,
	    sizeof( dwTemp ),
	    &dwReturned,
	    NULL);
	CloseHandle( hDeviceHandle );

	lpDD->lpGbl->hKernelHandle = ddOutput.dwDirectDrawHandle;
	lpDD->lpGbl->pfnNotifyProc = ddOutput.pfnNotifyProc;

	/*
	 * Everything worked.  If they can support software autoflipping,
	 * we'll update the video port caps structure accordingly.
	 */
    MungeAutoflipCaps( lpDD->lpGbl );

    #else

	/*
	 * Can we software autoflip?  If so, we'll update the video
	 * port caps structure accordingly.
	 */
	lpKernelCaps = lpDD->lpGbl->lpDDKernelCaps;
	if( ( lpKernelCaps != NULL ) &&
	    ( lpKernelCaps->dwCaps & DDKERNELCAPS_AUTOFLIP ) &&
	    ( lpDD->lpGbl->lpDDVideoPortCaps != NULL ) )
	{
    	    LPDDVIDEOPORTCAPS lpVideoPortCaps;
	    DWORD i;

	    for( i = 0; i < lpDD->lpGbl->ddCaps.dwMaxVideoPorts; i++ )
	    {
    	    	lpVideoPortCaps = &(lpDD->lpGbl->lpDDVideoPortCaps[i]);
    	    	if( ( lpVideoPortCaps != NULL ) &&
    	    	    VALID_DDVIDEOPORTCAPS_PTR( lpVideoPortCaps ) )
    	    	{
    	    	    lpVideoPortCaps->dwCaps |= DDVPCAPS_AUTOFLIP;
    	    	    lpVideoPortCaps->dwNumAutoFlipSurfaces = MAX_AUTOFLIP;
		    if( lpVideoPortCaps->dwCaps & DDVPCAPS_VBISURFACE )
		    {
    	    	        lpVideoPortCaps->dwNumVBIAutoFlipSurfaces = MAX_AUTOFLIP;
		    }
    	    	}
	    }
	}

    #endif

    return DD_OK;
}


/*
 * ReleaseKernelInterface
 */
HRESULT ReleaseKernelInterface( LPDDRAWI_DIRECTDRAW_LCL lpDD )
{
    HANDLE hDDVxd;
    HANDLE hVDD;
    DWORD dwTemp;
    DWORD dwReturned;
    BYTE szDisplayName[MAX_DRIVER_NAME];

    /*
     * Do nothing if no interface has been created.
     */
    if( lpDD->lpGbl->hKernelHandle == 0 )
    {
	return DD_OK;
    }

    #if WIN95

	/*
	 * Tell the VDD to stop notifying us of DOS box and res change events.
	 */
	if( lpDD->lpGbl->pfnNotifyProc != 0 )
	{
	    /*
	     * Get the name of the VDD device to open
	     */
	    lstrcpy( szDisplayName, lpDD->lpGbl->cDriverName );
	    if( _stricmp( szDisplayName, DISPLAY_STR ) == 0 )
	    {
	        lstrcpy( szDisplayName, g_szPrimaryDisplay );
	    }

	    hVDD = CreateFile( szDisplayName,
	    	GENERIC_WRITE,
	    	FILE_SHARE_WRITE,
	    	NULL,
	    	OPEN_EXISTING,
	    	FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
	    	NULL);
	    if( hVDD != INVALID_HANDLE_VALUE )
	    {
    	    	VDD_IOCTL_SET_NOTIFY_INPUT vddNotify;

	    	vddNotify.NotifyMask = 0;
	    	vddNotify.NotifyType = VDD_NOTIFY_TYPE_CALLBACK;
	    	vddNotify.NotifyProc = lpDD->lpGbl->pfnNotifyProc;
	    	vddNotify.NotifyData = lpDD->lpGbl->hKernelHandle;
    	    	DeviceIoControl( hVDD,
	    	    VDD_IOCTL_SET_NOTIFY,
	    	    &vddNotify,
	    	    sizeof( vddNotify ),
	    	    &dwTemp,
	    	    sizeof( dwTemp ),
	    	    &dwReturned,
	    	    NULL);
	    	CloseHandle( hVDD );
	    }
	}

	/*
	 * Need to decide which VXD handle to use. If we are executing
	 * on a DDHELP thread use the helper's VXD handle.
	 */
        hDDVxd = ( ( GetCurrentProcessId() != GETCURRPID() ) ? hHelperDDVxd : (HANDLE)lpDD->hDDVxd );
	dwTemp = lpDD->lpGbl->hKernelHandle;
        if( ( hDDVxd != NULL ) && ( dwTemp != 0 ) )
	{
            DeviceIoControl( hDDVxd,
	    	DD_DXAPI_RELEASE_DEVICE,
	    	&dwTemp,
	    	sizeof( DWORD ),
	    	&dwTemp,
	    	sizeof( DWORD ),
	    	&dwReturned,
	    	NULL);
	}

    #else

	DdGetDxHandle( lpDD, NULL, TRUE );

    #endif

    return DD_OK;
}


/*
 * Determines if software autoflipping is an option.
 */
BOOL CanSoftwareAutoflip( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort )
{
    DWORD dwIRQ;

    #if WIN95

        /*
         * Fail if the ring 0 interface is not present
         */
        if( ( lpVideoPort == NULL ) ||
            ( !IsKernelInterfaceSupported( lpVideoPort->lpDD ) ) ||
    	    ( lpVideoPort->lpDD->lpGbl->hKernelHandle == (DWORD) 0 ) ||
    	    ( lpVideoPort->dwFlags & DDRAWIVPORT_NOKERNELHANDLES ) )
        {
	    return FALSE;
        }

        /*
         * Check the ring 0 caps to see if autoflipping is available
         */
        if( ( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps == NULL ) ||
    	    !( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps->dwCaps &
    	    DDKERNELCAPS_AUTOFLIP ) )
        {
	    return FALSE;
        }

        /*
         * Check to make sure an IRQ is available for this video port
         */
        dwIRQ = DDIRQ_VPORT0_VSYNC;
        dwIRQ <<= ( lpVideoPort->ddvpDesc.dwVideoPortID * 2 );
        if( !( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps->dwIRQCaps & dwIRQ ) )
        {
	    return FALSE;
        }

    #else

        /*
         * Check the ring 0 caps to see if autoflipping is available
         */
        if( (lpVideoPort == NULL ) ||
	    ( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps == NULL ) ||
    	    !( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps->dwCaps &
    	    DDKERNELCAPS_AUTOFLIP ) )
        {
	    return FALSE;
        }

        /*
         * Check to make sure an IRQ is available for this video port
         */
        dwIRQ = DDIRQ_VPORT0_VSYNC;
        dwIRQ <<= ( lpVideoPort->ddvpDesc.dwVideoPortID * 2 );
        if( !( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps->dwIRQCaps & dwIRQ ) )
        {
	    return FALSE;
        }

    #endif

    return TRUE;
}


/*
 * DD_Kernel_GetCaps
 */
HRESULT DDAPI DD_Kernel_GetCaps(LPDIRECTDRAWKERNEL lpDDK, LPDDKERNELCAPS lpCaps )
{
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Kernel_GetCaps");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDK;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this = this_int->lpLcl->lpGbl;
	if( !VALID_DDKERNELCAPS_PTR( lpCaps ) )
	{
	    DPF( 0, "Invalid DDKERNELCAPS ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        if( !IsKernelInterfaceSupported( this_int->lpLcl ) )
	{
	    DPF( 0, "Device does not support kernel interface" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    memcpy( lpCaps, this->lpDDKernelCaps, sizeof( DDKERNELCAPS ));
    lpCaps->dwSize = sizeof( DDKERNELCAPS );

    LEAVE_DDRAW();
    return DD_OK;
}


/*
 * DD_Kernel_GetKernelHandle
 */
HRESULT DDAPI DD_Kernel_GetKernelHandle(LPDIRECTDRAWKERNEL lpDDK, PULONG_PTR lpHandle )
{
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Kernel_GetKernelHandle");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDK;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this = this_int->lpLcl->lpGbl;
	if( !VALID_DWORD_PTR( lpHandle ) )
	{
	    DPF( 0, "Invalid handle ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        if( !IsKernelInterfaceSupported( this_int->lpLcl ) )
	{
	    DPF( 0, "Device does not support kernel interface" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    #ifdef WINNT
	this->hKernelHandle = (ULONG_PTR) DdGetDxHandle( this_int->lpLcl, NULL, FALSE );
	if( this->hKernelHandle == 0 )
	{
	    DPF( 0, "Kernel failed GetDxHandle" );
	    LEAVE_DDRAW();
	    return DDERR_GENERIC;
	}
    #endif
    *lpHandle = this->hKernelHandle;

    LEAVE_DDRAW();
    return DD_OK;
}


/*
 * DD_Kernel_ReleaseKernelHandle
 *
 * Does nothing - should it?
 */
HRESULT DDAPI DD_Kernel_ReleaseKernelHandle(LPDIRECTDRAWKERNEL lpDDK )
{
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Kernel_ReleaseKernelHandle");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDK;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this = this_int->lpLcl->lpGbl;
        if( !IsKernelInterfaceSupported( this_int->lpLcl ) )
	{
	    DPF( 0, "Device does not support kernel interface" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    #ifdef WINNT
	ReleaseKernelInterface( this_int->lpLcl );
    #endif

    LEAVE_DDRAW();
    return DD_OK;
}


/*
 * DD_SurfaceKernel_GetKernelHandle
 */
HRESULT DDAPI DD_SurfaceKernel_GetKernelHandle(LPDIRECTDRAWSURFACEKERNEL lpDDK,
					PULONG_PTR lpHandle )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    DWORD ddRVal;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_SurfaceKernel_GetKernelHandle");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDK;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	if( !VALID_DWORD_PTR( lpHandle ) )
	{
	    DPF( 0, "Invalid handle ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        if( !IsKernelInterfaceSupported( this_int->lpLcl->lpSurfMore->lpDD_lcl ) )
	{
	    DPF( 0, "Device does not support kernel interface" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    ddRVal = InternalCreateKernelSurfaceHandle( this_int->lpLcl, lpHandle );

    LEAVE_DDRAW();
    return ddRVal;
}


/*
 * DD_SurfaceKernel_ReleaseKernelHandle
 */
HRESULT DDAPI DD_SurfaceKernel_ReleaseKernelHandle(LPDIRECTDRAWSURFACEKERNEL lpDDK )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE 	lpSurfGblMore;
    DWORD	ddRVal;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_SurfaceKernel_ReleaseKernelHandle");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDK;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this = this_int->lpLcl->lpGbl;
    	lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( this );
    	if( lpSurfGblMore->hKernelSurface == 0 )
	{
	    DPF_ERR( "Kernel handle has already been released" );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
	if( this_int->lpLcl->lpSurfMore->lpDD_lcl->lpGbl->hKernelHandle == (DWORD) 0 )
	{
	    DPF( 0, "Device does not support kernel interface" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    ddRVal = InternalReleaseKernelSurfaceHandle( this_int->lpLcl, FALSE );

    LEAVE_DDRAW();
    return ddRVal;
}


/*
 * IsKernelInterfaceSupported
 */
BOOL IsKernelInterfaceSupported( LPDDRAWI_DIRECTDRAW_LCL lpDD )
{
    #ifdef WIN95
        if( ( lpDD->lpGbl->hKernelHandle == (DWORD) NULL ) ||
	    ( lpDD->lpGbl->lpDDKernelCaps == NULL ) ||
            ( lpDD->lpDDCB->HALDDKernel.SyncSurfaceData == NULL ) )
        {
	    return FALSE;
        }
    #else
        if( ( lpDD->lpGbl->lpDDKernelCaps == NULL ) ||
    	    ( lpDD->lpGbl->lpDDKernelCaps->dwCaps == 0 ) )
        {
	    return FALSE;
        }
    #endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddiunk.c ===
/*==========================================================================
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddiunk.c
 *  Content:    DirectDraw IUnknown interface
 *              Implements QueryInterface, AddRef, and Release
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   14-mar-95  craige  split out of ddraw.c
 *   19-mar-95  craige  process termination cleanup fixes
 *   29-mar-95  craige  DC per process to clean up; use GETCURRPID
 *   31-mar-95  craige  cleanup palettes
 *   01-apr-95  craige  happy fun joy updated header file
 *   07-apr-95  craige  bug 14 - check GUID ptr in QI
 *                      don't release NULL hdc
 *   12-may-95  craige  check for guids
 *   15-may-95  craige  restore mode, free surfaces & palettes on a
 *                      per-process basis
 *   24-may-95  craige  release allocated tables
 *   02-jun-95  craige  extra parm in AddToActiveProcessList
 *   06-jun-95  craige  call RestoreDisplayMode
 *   07-jun-95  craige  removed DCLIST
 *   12-jun-95  craige  new process list stuff
 *   21-jun-95  craige  clipper stuff
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns
 *   03-jul-95  craige  YEEHAW: new driver struct; SEH
 *   13-jul-95  craige  removed spurious frees of ddhel dll (obsolete);
 *                      don't restore the mode if not excl mode owner on death
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset
 *   21-nov-95  colinmc made Direct3D a queryable interface off DirectDraw
 *   27-nov-95  jeffno  ifdef'd out VxD stuff (in DD_Release) for winnt
 *   01-dec-95  colinmc new IID for DirectDraw V2
 *   22-dec-95  colinmc Direct3D support no longer conditional
 *   25-dec-95	craige	allow a NULL lpGbl ptr for QI, AddRef, Release
 *   31-dec-95	craige	validate riid
 *   01-jan-96  colinmc Fixed D3D integration bug which lead to
 *                      the Direct3D DLL being released too early.
 *   13-jan-96  colinmc Temporary workaround for Direct3D cleanup problem
 *   04-jan-96  kylej   add interface structures
 *   26-jan-96  jeffno  Destroy NT kernel-mode objects
 *   07-feb-96  jeffno  Rearrange DD_Release so that freed objects aren't referenced
 *   08-feb-96  colinmc New D3D interface
 *   17-feb-96  colinmc Removed final D3D references
 *   28-feb-96  colinmc Fixed thread-unsafe problem in DD_Release
 *   22-mar-96  colinmc Bug 13316: uninitialized interfaces
 *   23-mar-96  colinmc Bug 12252: Direct3D not properly cleaned up on GPF
 *   27-mar-96  colinmc Bug 14779: Bad cleanup on Direct3DCreate failure
 *   18-apr-96  colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *   29-apr-96  colinmc Bug 19954: Must query for Direct3D before texture
 *                      or device
 *   03-may-96  kylej   Bug 19125: Preserve V1 SetCooperativeLevel behaviour
 *   15-sep-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   29-jan-97  smac    Fixed video port container bug
 *   03-mar-97  smac    Added kernel mode interface
 *   08-mar-97  colinmc Added support for DMA style AGP parts
 *   30-sep-97  jeffno  IDirectDraw4
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
#endif
#define DPF_MODNAME "DirectDraw::QueryInterface"

/*
 * Create the Direct3D interface aggregated by DirectDraw. This involves
 * loading the Direct3D DLL, getting the Direct3DCreate entry point and
 * invoking it.
 *
 * NOTE: This function does not call QueryInterface() on the returned
 * interface to bump the reference count as this function may be invoked
 * by one of the surface QueryInterface() calls to initialized Direct3D
 * before the user makes a request for external interface.
 *
 * Returns:
 * DD_OK         - success
 * E_NOINTERFACE - we could not find valid Direct3D DLLs (we assumed its not
 *                 installed and so the Direct3D interfaces are not understood)
 * D3DERR_       - We found a valid Direct3D installation but the object
 *                 creation failed for some reason.
 */
HRESULT InitD3DRevision(
    LPDDRAWI_DIRECTDRAW_INT this_int,
    HINSTANCE * pDLLHinstance,
    IUnknown ** ppOwnedIUnknown,
    DWORD dwRevisionLevel )
{
    D3DCreateProc lpfnD3DCreateProc;
    HRESULT rval;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;

    this_lcl = this_int->lpLcl;

    /*
     * This function does no checking to ensure that it
     * has not already been invoked for this driver object
     * so this must be NULL on entry.
     */
    DDASSERT( NULL == this_lcl->pD3DIUnknown );

    DPF( 4, "Initializing Direct3D" );

    /*
     * Load the Direct3D DLL.
     */

    if(*pDLLHinstance == NULL)
    {
        char* pDLLName;

        if (dwRevisionLevel < 0x700)
        {
            pDLLName = D3D_DLLNAME;
        }
        else
        {
            pDLLName = D3DDX7_DLLNAME;
        }

        *pDLLHinstance = LoadLibrary( pDLLName );

        if( *pDLLHinstance == NULL )
        {
            DPF( 0, "Could not locate the Direct3D DLL (%s)", pDLLName);
            return E_NOINTERFACE;
        }
    }

    lpfnD3DCreateProc = (D3DCreateProc)GetProcAddress( *pDLLHinstance, D3DCREATE_PROCNAME );
    this_lcl->pPaletteUpdateNotify = (LPPALETTEUPDATENOTIFY)GetProcAddress( *pDLLHinstance, PALETTEUPDATENOTIFY_NAME );
    this_lcl->pPaletteAssociateNotify = (LPPALETTEASSOCIATENOTIFY)GetProcAddress( *pDLLHinstance, PALETTEASSOCIATENOTIFY_NAME );
    this_lcl->pSurfaceFlipNotify = (LPSURFACEFLIPNOTIFY)GetProcAddress( *pDLLHinstance, SURFACEFLIPNOTIFY_NAME );
    this_lcl->pFlushD3DDevices = (FLUSHD3DDEVICES)GetProcAddress( *pDLLHinstance, FLUSHD3DDEVICES_NAME );
    this_lcl->pD3DTextureUpdate = (D3DTEXTUREUPDATE)GetProcAddress( *pDLLHinstance, D3DTEXTUREUPDATE_NAME );
    if (dwRevisionLevel >= 0x700)
    {
        this_lcl->pFlushD3DDevices2 = this_lcl->pFlushD3DDevices;
        this_lcl->pD3DCreateTexture = (D3DCREATETEXTURE)GetProcAddress( *pDLLHinstance, D3DCREATETEXTURE_NAME );
        this_lcl->pD3DDestroyTexture = (D3DDESTROYTEXTURE)GetProcAddress( *pDLLHinstance, D3DDESTROYTEXTURE_NAME );
        this_lcl->pD3DSetPriority = (D3DSETPRIORITY)GetProcAddress( *pDLLHinstance, D3DSETPRIORITY_NAME );
        this_lcl->pD3DGetPriority = (D3DGETPRIORITY)GetProcAddress( *pDLLHinstance, D3DGETPRIORITY_NAME );
        this_lcl->pD3DSetLOD = (D3DSETLOD)GetProcAddress( *pDLLHinstance, D3DSETLOD_NAME );
        this_lcl->pD3DGetLOD = (D3DGETLOD)GetProcAddress( *pDLLHinstance, D3DGETLOD_NAME );
        this_lcl->pBreakVBLock = (LPBREAKVBLOCK)GetProcAddress( *pDLLHinstance, BREAKVBLOCK_NAME );
        this_lcl->pddSurfaceCallbacks = &ddSurfaceCallbacks;
    }
    else
    {
        this_lcl->pFlushD3DDevices2 = (FLUSHD3DDEVICES)GetProcAddress( *pDLLHinstance, FLUSHD3DDEVICES2_NAME );
        this_lcl->pD3DCreateTexture = NULL;
        this_lcl->pD3DDestroyTexture = NULL;
        this_lcl->pD3DSetPriority = NULL;
        this_lcl->pD3DGetPriority = NULL;
        this_lcl->pD3DSetLOD = NULL;
        this_lcl->pD3DGetLOD = NULL;
        this_lcl->pBreakVBLock = NULL;
        this_lcl->pddSurfaceCallbacks = NULL;
    }

    if( lpfnD3DCreateProc == NULL )
    {
        DPF( 0, "Could not locate the Direct3DCreate entry point" );
        FreeLibrary( *pDLLHinstance );
        *pDLLHinstance = NULL;
        return E_NOINTERFACE;
    }

    /*
     * ### Tada - an aggregated object creation ###
     */
    #ifdef USE_D3D_CSECT
        rval = (*lpfnD3DCreateProc)( ppOwnedIUnknown, (LPUNKNOWN)this_int );
    #else /* USE_D3D_CSECT */
        #ifdef WINNT
           rval = (*lpfnD3DCreateProc)( 0, ppOwnedIUnknown, (LPUNKNOWN)this_int );
        #else
           rval = (*lpfnD3DCreateProc)( lpDDCS, ppOwnedIUnknown, (LPUNKNOWN)this_int );
        #endif
    #endif /* USE_D3D_CSECT */
    if( rval == DD_OK )
    {
        DPF( 4, "Created aggregated Direct3D interface" );
        return DD_OK;
    }
    else
    {
        /*
         * Direct3D did understand the IID but failed to initialize for
         * some other reason.
         */
        DPF( 0, "Could not create aggregated Direct3D interface" );
        *ppOwnedIUnknown = NULL;
        FreeLibrary( *pDLLHinstance );
        *pDLLHinstance = NULL;
        return rval;
    }
}

HRESULT InitD3D( LPDDRAWI_DIRECTDRAW_INT this_int )
{
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;

    this_lcl = this_int->lpLcl;
    if( DDRAWILCL_DIRECTDRAW7 & this_lcl->dwLocalFlags)
    {
        return InitD3DRevision( this_int, &this_lcl->hD3DInstance, &this_lcl->pD3DIUnknown, 0x700);
    }
    else
    {
        return InitD3DRevision( this_int, &this_lcl->hD3DInstance, &this_lcl->pD3DIUnknown, 0x600);
    }
}

#if 0
/*
 * This function builds a d3d device context for use by ddraw. DDraw will use this context
 * initially to send palette update messages.
 */
HRESULT InitDDrawPrivateD3DContext( LPDDRAWI_DIRECTDRAW_INT this_int )
{
    IUnknown *              pD3DUnknown;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    HRESULT                 hr=DD_OK;
    HINSTANCE               hInstance;

    this_lcl = this_int->lpLcl;

    DDASSERT( 0 == (this_lcl->dwLocalFlags & DDRAWILCL_ATTEMPTEDD3DCONTEXT) );

    /*
     * If this is a dx7 ddraw object, then we will piggy back off of the d3d object
     * that's created when IDirect3Dx is QIed. This saves creating another d3d object
     * since they are quite piggy.
     * If this is not a dx7 object, then we have to get our own dx7 d3d, since the dx6
     * d3d can't understand our extra calls.
     */
    if( DDRAWILCL_DIRECTDRAW7 & this_lcl->dwLocalFlags)
    {
        if( !D3D_INITIALIZED( this_lcl ) )
            hr = InitD3D( this_int );

        this_lcl->hinstDDrawPrivateD3D = 0;

        pD3DUnknown = this_lcl->pD3DIUnknown;
        hInstance = this_lcl->hD3DInstance;
        //We set this up so d3d doesn't have to struggle trying to figure out which iunknown to use
        this_lcl->pPrivateD3DInterface = this_lcl->pD3DIUnknown;
    }
    else
    {
        /*
         * Have to create a new one and keep it around
         */
        hr = InitD3DRevision( this_int, &this_lcl->hinstDDrawPrivateD3D, &this_lcl->pPrivateD3DInterface, 0x700 );
        pD3DUnknown = this_lcl->pPrivateD3DInterface;
        hInstance = this_lcl->hinstDDrawPrivateD3D;
    }

    if (SUCCEEDED(hr))
    {
        GETDDRAWCONTEXT pGetContext;

        DDASSERT(hInstance);
        DDASSERT(pD3DUnknown);
        /*
         * Go create the d3d device
         */
        pGetContext = (GETDDRAWCONTEXT)GetProcAddress( hInstance, GETDDRAWCONTEXT_NAME );

        if (pGetContext)
        {
            this_lcl->pDeviceContext = pGetContext(this_lcl);
            /*
             * Go get the notification entry points.
             * If either of these fail, we carry on regardless.
             */
            this_lcl->pPaletteUpdateNotify = (LPPALETTEUPDATENOTIFY)GetProcAddress( hInstance, PALETTEUPDATENOTIFY_NAME );
            this_lcl->pPaletteAssociateNotify = (LPPALETTEASSOCIATENOTIFY)GetProcAddress( hInstance, PALETTEASSOCIATENOTIFY_NAME );
        }
    }
    this_lcl->dwLocalFlags |= DDRAWILCL_ATTEMPTEDD3DCONTEXT;
    return hr;
}
#endif

/*
 * getDDInterface
 */
LPDDRAWI_DIRECTDRAW_INT getDDInterface( LPDDRAWI_DIRECTDRAW_LCL this_lcl, LPVOID lpddcb )
{
    LPDDRAWI_DIRECTDRAW_INT curr_int;

    ENTER_DRIVERLISTCSECT();
    for( curr_int = lpDriverObjectList; curr_int != NULL; curr_int = curr_int->lpLink )
    {
        if( (curr_int->lpLcl == this_lcl) &&
            (curr_int->lpVtbl == lpddcb) )
        {
            break;
        }
    }
    if( NULL == curr_int )
    {
        // Couldn't find an existing interface, create one.
        curr_int = MemAlloc( sizeof( DDRAWI_DIRECTDRAW_INT ) );
        if( NULL == curr_int )
        {
            LEAVE_DRIVERLISTCSECT();
            return NULL;
        }

        /*
         * set up data
         */
        curr_int->lpVtbl = lpddcb;
        curr_int->lpLcl = this_lcl;
        curr_int->dwIntRefCnt = 0;
        curr_int->lpLink = lpDriverObjectList;
        lpDriverObjectList = curr_int;
    }
    LEAVE_DRIVERLISTCSECT();
    DPF( 5, "New driver interface created, %08lx", curr_int );
    return curr_int;
}
#ifdef POSTPONED
/*
 * Delegating IUnknown for DDraw
 */
HRESULT DDAPI DD_DelegatingQueryInterface(
                LPDIRECTDRAW lpDD,
                REFIID riid,
                LPVOID FAR * ppvObj )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    HRESULT                     hr;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_DelegatingQueryInterface");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * We have to check if the owning IUnknown is actually one of our own
     * interfaces
     */
    if ( IS_NATIVE_DDRAW_INTERFACE(this_int->lpLcl->pUnkOuter) )
    {
        /*
         * So we can trust that the int pointer really is a pointer to DDRAW_DIRECTDRAW_INT
         */
        hr = this_int->lpLcl->pUnkOuter->lpVtbl->QueryInterface((IUnknown*)lpDD, riid, ppvObj);
    }
    else
    {
        /*
         * So we have no idea whose pointer it is, better pass its this pointer.
         */
        hr = this_int->lpLcl->pUnkOuter->lpVtbl->QueryInterface(this_int->lpLcl->pUnkOuter, riid, ppvObj);
    }

    LEAVE_DDRAW();
    return hr;
}

DWORD DDAPI DD_DelegatingAddRef( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    DWORD                       dw;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_DelegatingAddRef");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
            // what error code can you return from AddRef??
	    return 0;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
        // what error code can you return from AddRef??
	return 0;
    }

    /*
     * We have to check if the owning IUnknown is actually one of our own
     * interfaces
     */
    if ( IS_NATIVE_DDRAW_INTERFACE(this_int->lpLcl->pUnkOuter) )
    {
        /*
         * So we can trust that the int pointer really is a pointer to DDRAW_DIRECTDRAW_INT
         */
        dw = this_int->lpLcl->pUnkOuter->lpVtbl->AddRef((IUnknown*)lpDD);
    }
    else
    {
        /*
         * So we have no idea whose pointer it is, better pass its this pointer.
         */
        dw = this_int->lpLcl->pUnkOuter->lpVtbl->AddRef(this_int->lpLcl->pUnkOuter);
    }

    LEAVE_DDRAW();
    return dw;
}

DWORD DDAPI DD_DelegatingRelease( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    DWORD                       dw;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_DeletegatingRelease");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
            // what error code can you return from AddRef??
	    return 0;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
        // what error code can you return from Release??
	return 0;
    }

    /*
     * We have to check if the owning IUnknown is actually one of our own
     * interfaces
     */
    if ( IS_NATIVE_DDRAW_INTERFACE(this_int->lpLcl->pUnkOuter) )
    {
        /*
         * So we can trust that the int pointer really is a pointer to DDRAW_DIRECTDRAW_INT
         */
        dw = this_int->lpLcl->pUnkOuter->lpVtbl->Release((IUnknown*)lpDD);
    }
    else
    {
        /*
         * So we have no idea whose pointer it is, better pass its this pointer.
         */
        dw = this_int->lpLcl->pUnkOuter->lpVtbl->Release(this_int->lpLcl->pUnkOuter);
    }

    LEAVE_DDRAW();
    return dw;
}

#endif //postponed

/*
 * DD_QueryInterface
 */
HRESULT DDAPI DD_QueryInterface(
                LPDIRECTDRAW lpDD,
                REFIID riid,
                LPVOID FAR * ppvObj )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    HRESULT                     rval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_QueryInterface");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        if( !VALID_PTR_PTR( ppvObj ) )
        {
            DPF( 1, "Invalid object ptr" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( !VALIDEX_IID_PTR( riid ) )
        {
            DPF( 1, "Invalid iid ptr" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *ppvObj = NULL;
        this_lcl = this_int->lpLcl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * Is the IID one of DirectDraw's?
     */
#ifdef POSTPONED
    if( IsEqualIID(riid, &IID_IUnknown) )
    {
        /*
         * If we are being aggregated and the QI is for IUnknown,
         * then we must return a non delegating interface. The only way this can
         * happen is if the incoming vtable points to our non delegating vtables.
         * In this case we can simply addref and return.
         * If we are not aggregated, then the QI must have the same pointer value
         * as any other QI for IUnknown, so we make that the ddCallbacks.
         */
        if( ( this_int->lpVtbl == &ddNonDelegatingUnknownCallbacks ) ||
            ( this_int->lpVtbl == &ddUninitNonDelegatingUnknownCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &ddCallbacks );
    }
    else
#endif
    if (IsEqualIID(riid, &IID_IDirectDraw) || IsEqualIID(riid, &IID_IUnknown) )
    {
        if( ( this_int->lpVtbl == &ddCallbacks ) ||
            ( this_int->lpVtbl == &ddUninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &ddCallbacks );
    }
    else if( IsEqualIID(riid, &IID_IDirectDraw2 ) )
    {
        if( (this_int->lpVtbl == &dd2Callbacks )||
            ( this_int->lpVtbl == &dd2UninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &dd2Callbacks );
    }
    else if( IsEqualIID(riid, &IID_IDirectDraw4 ) )
    {
        if( (this_int->lpVtbl == &dd4Callbacks ) ||
            ( this_int->lpVtbl == &dd4UninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &dd4Callbacks );
    }
    else if( IsEqualIID(riid, &IID_IDirectDraw7 ) )
    {
        if( (this_int->lpVtbl == &dd7Callbacks ) ||
            ( this_int->lpVtbl == &dd7UninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
        {
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &dd7Callbacks );
            #ifdef WIN95
                if ( *ppvObj )
                {
                    DDGetMonitorInfo( (LPDDRAWI_DIRECTDRAW_INT) *ppvObj );
                }
            #endif
        }
    }
    else if( IsEqualIID(riid, &IID_IDDVideoPortContainer ) )
    {
        if( this_int->lpVtbl == &ddVideoPortContainerCallbacks )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = getDDInterface (this_int->lpLcl, &ddVideoPortContainerCallbacks);
    }
    else if( IsEqualIID(riid, &IID_IDirectDrawKernel ) )
    {
        /*
         * Don't create the interface if the VDD didn't have a handle
         * the kernel mode interface.
         */
        if( !IsKernelInterfaceSupported( this_lcl ) )
        {
            DPF( 0, "Kernel Mode interface not supported" );
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }

        if( this_int->lpVtbl == &ddKernelCallbacks )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = getDDInterface (this_int->lpLcl, &ddKernelCallbacks);
    }
    else if( IsEqualIID(riid, &IID_IDDVideoAcceleratorContainer ) )
    {
        /*
         * Don't create the interface if the hardware doesn't support it
         */
        if( !IsMotionCompSupported( this_lcl ) )
        {
            DPF( 0, "Motion comp interface not supported" );
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }

        if( this_int->lpVtbl == &ddMotionCompContainerCallbacks )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = getDDInterface (this_int->lpLcl, &ddMotionCompContainerCallbacks);
        if( NULL == *ppvObj )
        {
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        else
        {
            DD_AddRef( *ppvObj );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }
    else
    {
#ifndef _IA64_
#if _WIN32_WINNT >= 0x0501
        typedef BOOL (WINAPI *PFN_ISWOW64PROC)( HANDLE hProcess,
                                                PBOOL Wow64Process );
        HINSTANCE hInst = NULL;
        hInst = LoadLibrary( "kernel32.dll" );
        if( hInst )
        {
            PFN_ISWOW64PROC pfnIsWow64 = NULL;
            pfnIsWow64 = (PFN_ISWOW64PROC)GetProcAddress( (HMODULE)hInst, "IsWow64Process" );
            // We assume that if this function is not available, then it is some OS where
            // WOW64 does not exist (this means that pre-Release versions of XP are busted)
            if( pfnIsWow64 )
            {
                BOOL wow64Process;
                if (pfnIsWow64(GetCurrentProcess(), &wow64Process) && wow64Process)
                {
                    DPF_ERR("Pre-DX8 D3D interfaces are not supported on WOW64");
                    LEAVE_DDRAW();
                    return E_NOINTERFACE;
                }
            }
            FreeLibrary( hInst );
        }
        else
        {
            DPF_ERR("LoadLibrary failed. Quitting.");
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
#endif // _WIN32_WINNT >= 0x0501
#else  // _IA64_
        DPF_ERR("Pre-DX8 D3D interfaces are not supported on IA64");
        LEAVE_DDRAW();
        return E_NOINTERFACE;
#endif // _IA64_

        DPF( 4, "IID not understood by DirectDraw QueryInterface - trying Direct3D" );

        /*
         * It's not one of DirectDraw's so it might be the Direct3D
         * interface. So try Direct3D.
         */
        if( !D3D_INITIALIZED( this_lcl ) )
        {
            /*
             * No Direct3D interface yet so try and create one.
             */
            rval = InitD3D( this_int );
            if( FAILED( rval ) )
            {
                /*
                 * Direct3D could not be initialized. No point trying to
                 * query for the Direct3D interface if we could not
                 * initialize Direct3D.
                 *
                 * NOTE: This assumes that DirectDraw does not aggregate
                 * any other object type. If it does this code will need
                 * to be revised.
                 */
                LEAVE_DDRAW();
                return rval;
            }
        }

        DDASSERT( D3D_INITIALIZED( this_lcl ) );

        /*
         * We have a Direct3D interface so try the IID out on it.
         */
        DPF( 4, "Passing query off to Direct3D interface" );
        rval = this_lcl->pD3DIUnknown->lpVtbl->QueryInterface( this_lcl->pD3DIUnknown, riid, ppvObj );
        if( rval == DD_OK )
        {
            DPF( 4, "Sucessfully queried for the Direct3D interface" );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }

    if( NULL == *ppvObj )
    {
        DPF_ERR( "IID not understood by DirectDraw" );
        LEAVE_DDRAW();
        return E_NOINTERFACE;
    }
    else
    {
        /*
         * Note that this casts the ppvObj to an IUnknown and then calls it.
         * This is better than hard-coding to call the DD_AddRef, since we
         * may be aggregated and so need to punt addref calls to the owning
         * iunknown. This will happen automatically if it's any recognized non-IUnknown
         * interface because they all have a delegating unknown
         */
        ((IUnknown*)( *ppvObj ))->lpVtbl->AddRef(*ppvObj);
        LEAVE_DDRAW();
        return DD_OK;
    }
} /* DD_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDraw::UnInitedQueryInterface"
/*
 * DD_UnInitedQueryInterface
 */
HRESULT DDAPI DD_UnInitedQueryInterface(
                LPDIRECTDRAW lpDD,
                REFIID riid,
                LPVOID FAR * ppvObj )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_UnInitedQueryInterface");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        if( !VALID_PTR_PTR( ppvObj ) )
        {
            DPF( 1, "Invalid object ptr" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( !VALIDEX_IID_PTR( riid ) )
        {
            DPF( 1, "Invalid iid ptr" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * Is the IID one of DirectDraw's?
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
        IsEqualIID(riid, &IID_IDirectDraw) )
    {
        /*
         * Our IUnknown interface is the same as our V1
         * interface.  We must always return the V1 interface
         * if IUnknown is requested.
         */
        if( ( this_int->lpVtbl == &ddCallbacks ) ||
            ( this_int->lpVtbl == &ddUninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &ddUninitCallbacks );

        if( NULL == *ppvObj )
        {
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        else
        {
            DD_AddRef( *ppvObj );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }
    else if( IsEqualIID(riid, &IID_IDirectDraw2 ) )
    {
        if( (this_int->lpVtbl == &dd2Callbacks ) ||
            ( this_int->lpVtbl == &dd2UninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &dd2UninitCallbacks );

        if( NULL == *ppvObj )
        {
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        else
        {
            DD_AddRef( *ppvObj );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }
    else if( IsEqualIID(riid, &IID_IDirectDraw4 ) )
    {
        if( (this_int->lpVtbl == &dd4Callbacks ) ||
            ( this_int->lpVtbl == &dd4UninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &dd4UninitCallbacks );

        if( NULL == *ppvObj )
        {
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        else
        {
            DD_AddRef( *ppvObj );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }
    else if( IsEqualIID(riid, &IID_IDirectDraw7 ) )
    {
        if( (this_int->lpVtbl == &dd7Callbacks ) ||
            ( this_int->lpVtbl == &dd7UninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &dd7UninitCallbacks );

        if( NULL == *ppvObj )
        {
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        else
        {
            DD_AddRef( *ppvObj );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }


    DPF( 2, "IID not understood by uninitialized DirectDraw QueryInterface" );

    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DD_UnInitedQueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDraw::AddRef"

/*
 * DD_AddRef
 */
DWORD DDAPI DD_AddRef( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_AddRef");
    /* DPF( 2, "DD_AddRef, pid=%08lx, obj=%08lx", GETCURRPID(), lpDD ); */

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return 0;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return 0;
    }

    /*
     * bump refcnt
     */
    if( this != NULL )
    {
        this->dwRefCnt++;
    }
    this_lcl->dwLocalRefCnt++;
    this_int->dwIntRefCnt++;

    #ifdef DEBUG
        if( this == NULL )
        {
            DPF( 5, "DD_AddRef, Reference Count: Global Undefined Local = %ld Int = %ld",
                this_lcl->dwLocalRefCnt, this_int->dwIntRefCnt );
        }
        else
        {
            DPF( 5, "DD_AddRef, Reference Count: Global = %ld Local = %ld Int = %ld",
                this->dwRefCnt, this_lcl->dwLocalRefCnt, this_int->dwIntRefCnt );
        }
    #endif

    LEAVE_DDRAW();

    return this_int->dwIntRefCnt;

} /* DD_AddRef */

#ifdef WIN95
#define MMDEVLDR_IOCTL_CLOSEVXDHANDLE       6
/*
 * closeVxDHandle
 */
static void closeVxDHandle( DWORD dwHandle )
{

    HANDLE hFile;

    hFile = CreateFile(
        "\\\\.\\MMDEVLDR.VXD",
        GENERIC_WRITE,
        FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
        NULL);

    if( hFile == INVALID_HANDLE_VALUE )
    {
        return;
    }

    DeviceIoControl( hFile,
                     MMDEVLDR_IOCTL_CLOSEVXDHANDLE,
                     NULL,
                     0,
                     &dwHandle,
                     sizeof(dwHandle),
                     NULL,
                     NULL);

    CloseHandle( hFile );
    DPF( 5, "closeVxdHandle( %08lx ) done", dwHandle );

} /* closeVxDHandle */
#endif

#if 0
/*
 * This function calls d3dim700.dll to clean up any driver state that may be stored per-ddrawlocal
 */
void CleanUpD3DPerLocal(LPDDRAWI_DIRECTDRAW_LCL this_lcl)
{
    HINSTANCE                   hInstance=0;
    /*
     * Call d3d for per-local cleanup. We only call d3dim7.
     * For safety, we'll just load a new copy of the DLL whether or not we're on ddhelp's PID
     */
    hInstance = LoadLibrary( D3DDX7_DLLNAME );

    if (hInstance)
    {
        FreeLibrary(hInstance);
    }
}
#endif


/*
 * DD_Release
 *
 * Once the globalreference count reaches 0, all surfaces are freed and all
 * video memory heaps are destroyed.
 */
DWORD DDAPI DD_Release( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWPALETTE_INT   ppal_int;
    LPDDRAWI_DDVIDEOPORT_INT    pvport_int;
    DWORD                       rc;
    DWORD                       refcnt;
    DWORD                       intrefcnt;
    DWORD                       lclrefcnt;
    DWORD                       gblrefcnt;
    int                         i;
    DDHAL_DESTROYDRIVERDATA     dddd;
    DWORD                       pid;
    HANDLE                      hinst;
    HANDLE                      hvxd;
    #ifdef WIN95
        DWORD                   event16;
        DWORD                   eventDOSBox;
        HANDLE                  hthisvxd;
    #endif
    #ifdef WINNT
        LPATTACHED_PROCESSES    lpap;
    #endif

    ENTER_DDRAW();

        pid = GETCURRPID();

    DPF(2,A,"ENTERAPI: DD_Release");
    /* DPF( 2, "DD_Release, pid=%08lx, obj=%08lx", pid, lpDD ); */

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return 0;
        }
        if ( this_int->dwIntRefCnt == 0 )
        {
            DPF_ERR( "DDraw Interface pointer has 0 ref count! Interface has been over-released.");
            LEAVE_DDRAW();
            return 0;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return 0;
    }

    /*
     * decrement process reference count
     */
    this_int->dwIntRefCnt--;
    intrefcnt = this_int->dwIntRefCnt;
    this_lcl->dwLocalRefCnt--;
    lclrefcnt = this_lcl->dwLocalRefCnt;
    if( this != NULL )
    {
        this->dwRefCnt--;
        gblrefcnt = this->dwRefCnt;
    }
    else
    {
        gblrefcnt = (DWORD) -1;
    }

    DPF( 5, "DD_Release, Ref Count: Global = %ld Local = %ld Interface = %ld",
        gblrefcnt, lclrefcnt, intrefcnt );


    /*
     * if the global refcnt is zero, free the driver object
     * note that the local object must not be freed yet because
     * we need to use the HAL callback tables
     */

    hinst = NULL;
    #ifdef WIN95
        event16 = 0;
        eventDOSBox = 0;
        hthisvxd = INVALID_HANDLE_VALUE;
    #endif
    /*
     * if local object is freed, for the owning process we:
     * - cleanup palettes, clippers & surfaces
     * - restore display mode
     * - release exclusive mode
     * - find the DC used by the process
     */
    if( lclrefcnt == 0 )
    {
        #ifdef TIMING
            // Printing timing information
            TimerDump();
        #endif

        /*
         * see if the hwnd was hooked, if so, undo it!
         */
        if( this_lcl->dwLocalFlags & DDRAWILCL_HOOKEDHWND )
        {
            SetAppHWnd( this_lcl, NULL, 0 );
            this_lcl->dwLocalFlags &= ~DDRAWILCL_HOOKEDHWND;
        }

        //
        // Do not call CleanUpD3DPerLocal because it does a LoadLibrary on
        // d3dim700.dll and is currently unnecessary. The LoadLibrary can
        // cause problems when opengl32.dll is detaching from a process
        // because they call DD_Release. Since ddraw.dll is statically linked
        // to opengl32.dll, it may be marked to be unloaded when opengl32.dll
        // is, and the load of d3dim700.dll here can cause ddraw.dll to be
        // reloaded at a different address, in this case, before the first
        // instance of ddraw.dll has been freed.
        //

        //CleanUpD3DPerLocal(this_lcl);

        if( GetCurrentProcessId() == GETCURRPID() )
        {
            /*
             * If we have created the Direct3D IUnknown release it now.
             * NOTE: The life of an aggregated object is the same as that
             * of its owning interface so we can also free the DLL at
             * this point.
             * NOTE: We must free the library AFTER ProcessSurfaceCleanup
             * as it can invoke D3D members to clean up device and texture
             * surfaces.
             */
            if( this_lcl->pD3DIUnknown != NULL )
            {
                DPF(4, "Releasing Direct3D IUnknown");
                this_lcl->pD3DIUnknown->lpVtbl->Release( this_lcl->pD3DIUnknown );
                /*
                 * Actually, this FreeLibrary will kill the process if the app
                 * did the final release of d3d after the final release of ddraw.
                 * The d3d release will punt to the owning IUnknown (us) and we
                 * will decrement ref count to zero and free the d3d DLL then
                 * return to the caller. The caller was IDirect3D::Release within
                 * the d3d DLL, so we would free the code that called us.
                 * For DX5 we will take out this FreeLibrary to fix the shutdown
                 * problem, but we should probably find something better for DX6 etc.
                 */
                //FreeLibrary( this_lcl->hD3DInstance );
                this_lcl->pD3DIUnknown = NULL;
                this_lcl->hD3DInstance = NULL;
            }
        }

        if( this != NULL )
        {
            BOOL excl_exists,has_excl;
            /*
             * punt process from any surfaces and palettes
             */
            FreeD3DSurfaceIUnknowns( this, pid, this_lcl );
            ProcessSurfaceCleanup( this, pid, this_lcl );
            ProcessPaletteCleanup( this, pid, this_lcl );
            ProcessClipperCleanup( this, pid, this_lcl );
            ProcessVideoPortCleanup( this, pid, this_lcl );
            ProcessMotionCompCleanup( this, pid, this_lcl );
#ifdef WIN95
            if (this_lcl->lpDDCB && this_lcl->lpDDCB->HALDDMiscellaneous2.DestroyDDLocal)
            {
                DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;
                DDHAL_DESTROYDDLOCALDATA destDDLcl;
                destDDLcl.dwFlags = 0;
                destDDLcl.pDDLcl  = this_lcl;
                ENTER_WIN16LOCK();
                dwRet = this_lcl->lpDDCB->HALDDMiscellaneous2.DestroyDDLocal(&destDDLcl);
                LEAVE_WIN16LOCK();
                if (dwRet == DDHAL_DRIVER_NOTHANDLED)
                {
                    DPF(0, "DD_Release: failed DestroyDDLocal");
                }
            }
#endif
            /*
             * reset the display mode if needed
             * and only if we are doing the v1 SetCooperativeLevel behaviour
             */

            CheckExclusiveMode(this_lcl, &excl_exists, &has_excl, FALSE, NULL, FALSE);

            if( this_lcl->dwLocalFlags & DDRAWILCL_V1SCLBEHAVIOUR)
            {
                if( (gblrefcnt == 0) ||
                    (!excl_exists) ||
                    (has_excl ) )
                {
                    RestoreDisplayMode( this_lcl, TRUE );
                }
            }
            else
            {
                /*
                 * Even in V2 or later, we want to restore the display
                 * mode for a non exclusive app.  Exclusive mode apps
                 * will restore their mode in DoneExclusiveMode
                 */
                if(!excl_exists)
                {
                    RestoreDisplayMode( this_lcl, TRUE );
                }
            }

            /*
             * exclusive mode held by this process? if so, release it
             */
            if( has_excl )
            {
                DoneExclusiveMode( this_lcl );
            }

            #ifdef WIN95
                /*
                 * We don't close the VXD handle just yet as we may need it
                 * to release virtual memory aliases if the global object
                 * is dying. Just remember that we need to free it for now.
                 */
                hthisvxd = (HANDLE) this_lcl->hDDVxd;

                /*
                 * Get a VXD handle we can use to communicate with the DirectX vxd.
                 * Please note that this code can be executed in the context of
                 * the processes which created the local object or DDHELP's if an
                 * application is shutting down without cleaning up. Therefore we
                 * can't just use the VXD handle stored in the local object as that
                 * my belong to a dead process (and hence be an invalid handle in
                 * the current process). Therefore, we need to detect whether we
                 * are being executed by DDHELP or an application process and
                 * choose a vxad handle appropriately. This is the destinction
                 * between hthisvxd which is the VXD handle stored in the local
                 * object and hvxd which is the VXD handle we can actually use
                 * to talk to the VXD.
                 */
                hvxd = ( ( GetCurrentProcessId() != GETCURRPID() ) ? hHelperDDVxd : hthisvxd );
                DDASSERT( INVALID_HANDLE_VALUE != hvxd );
            #else /* WIN95 */
                /*
                 * Handle is not used on NT. Just pass NULL.
                 */
                hvxd = INVALID_HANDLE_VALUE;
            #endif /* WIN95 */

            /*
             * If we created a device window ourselves, destroy it now
             */
            if( ( this_lcl->dwLocalFlags & DDRAWILCL_CREATEDWINDOW ) &&
                IsWindow( (HWND) this_lcl->hWnd ) )
            {
                DestroyWindow( (HWND) this_lcl->hWnd );
                this_lcl->hWnd = 0;
                this_lcl->dwLocalFlags &= ~DDRAWILCL_CREATEDWINDOW;
            }

            /*
             * If we previously loaded a gamma calibrator, unload it now.
             */
            if( this_lcl->hGammaCalibrator != (ULONG_PTR)INVALID_HANDLE_VALUE )
            {
                /*
                 * If we are on the helper thread, we don't need to unload the
                 * calibrator because it's already gone.
                 */
                if( GetCurrentProcessId() == GETCURRPID() )
                {
                    FreeLibrary( (HMODULE)this_lcl->hGammaCalibrator );
                }
                this_lcl->hGammaCalibrator = (ULONG_PTR) INVALID_HANDLE_VALUE;
            }

            /*
             * If a mode test was started, but not finished, release the
             * memory now.
             */
            if( this_lcl->lpModeTestContext )
            {
                MemFree( this_lcl->lpModeTestContext->lpModeList );
                MemFree( this_lcl->lpModeTestContext );
                this_lcl->lpModeTestContext = NULL;
            }

            /*
             * The palette handle bitfield
             */
            MemFree(this_lcl->pPaletteHandleUsedBitfield);
            this_lcl->pPaletteHandleUsedBitfield = 0;
        }
    }

    /*
     * Note the local object is freed after the global...
     */

    if( gblrefcnt == 0 )
    {
        DPF( 4, "FREEING DRIVER OBJECT" );

        /*
         * Notify driver.
         */
        dddd.lpDD = this;
        if((this->dwFlags & DDRAWI_EMULATIONINITIALIZED) &&
           (this_lcl->lpDDCB->HELDD.DestroyDriver != NULL))
        {
            /*
             * if the HEL was initialized, make sure we call the HEL
             * DestroyDriver function so it can clean up.
             */
            DPF( 4, "Calling HEL DestroyDriver" );
            dddd.DestroyDriver = NULL;

            /*
             * we don't really care about the return value of this call
             */
            rc = this_lcl->lpDDCB->HELDD.DestroyDriver( &dddd );
        }

        // Note that in a multimon system, a driver that is not attached to the
        // desktop is destroyed by GDI at termination of the process that uses
        // the driver.  In this case, Ddhelp cleanup must not try to destroy the
        // driver again or it will cause a GP fault.
        if( (this_lcl->lpDDCB->cbDDCallbacks.DestroyDriver != NULL) &&
            ((this->dwFlags & DDRAWI_ATTACHEDTODESKTOP) ||
             (dwGrimReaperPid != GetCurrentProcessId())))
        {
            dddd.DestroyDriver = this_lcl->lpDDCB->cbDDCallbacks.DestroyDriver;
            DPF( 4, "Calling DestroyDriver" );
            rc = this_lcl->lpDDCB->HALDD.DestroyDriver( &dddd );
            if( rc == DDHAL_DRIVER_HANDLED )
            {
                // Ignore any failure since there's no way to report a failure to
                // the app and exiting now would leave a half initialized interface
                // in the DriverObjectList
                DPF( 5, "DDHAL_DestroyDriver: ddrval = %ld", dddd.ddRVal );
            }
        }

        /*
         * release all surfaces
         */
        psurf_int = this->dsList;
        while( psurf_int != NULL )
        {
            LPDDRAWI_DDRAWSURFACE_INT   next_int;

            refcnt = psurf_int->dwIntRefCnt;
            next_int = psurf_int->lpLink;
            while( refcnt > 0 )
            {
                DD_Surface_Release( (LPDIRECTDRAWSURFACE) psurf_int );
                refcnt--;
            }
            psurf_int = next_int;
        }

        /*
         * release all palettes
         */
        ppal_int = this->palList;
        while( ppal_int != NULL )
        {
            LPDDRAWI_DDRAWPALETTE_INT   next_int;

            refcnt = ppal_int->dwIntRefCnt;
            next_int = ppal_int->lpLink;
            while( refcnt > 0 )
            {
                DD_Palette_Release( (LPDIRECTDRAWPALETTE) ppal_int );
                refcnt--;
            }
            ppal_int = next_int;
        }

        /*
         * release all videoports
         */
        pvport_int = this->dvpList;
        while( pvport_int != NULL )
        {
            LPDDRAWI_DDVIDEOPORT_INT    next_int;

            refcnt = pvport_int->dwIntRefCnt;
            next_int = pvport_int->lpLink;
            while( refcnt > 0 )
            {
                DD_VP_Release( (LPDIRECTDRAWVIDEOPORT) pvport_int );
                refcnt--;
            }
            pvport_int = next_int;
        }

        #ifdef WINNT
            /*
             * The driver needs to know to free its internal state
             */

            // Update DDraw handle in driver GBL object.
            this->hDD = this_lcl->hDD;

            DdDeleteDirectDrawObject(this);
            lpap = lpAttachedProcesses;
            while( lpap != NULL )
            {
                if( lpap->dwPid == pid )
                    lpap->dwNTToldYet = 0;

                lpap = lpap->lpLink;
            }
        #endif

        #ifdef USE_ALIAS
            /*
             * If this local object has heap aliases release them now.
             * NOTE: This really should release the heap aliases as by
             * this point all the surfaces should have gone.
             */
            if( NULL != this->phaiHeapAliases )
            {
                DDASSERT( 1UL == this->phaiHeapAliases->dwRefCnt );

                /*
                 * Need to decide which VXD handle to use. If we are executing
                 * on a DDHELP thread use the helper's VXD handle.
                 */
                ReleaseHeapAliases( hvxd, this->phaiHeapAliases );
            }
        #endif /* USE_ALIAS */

        /*
         * Notify the kernel mode interface that we are done using it
         */
        ReleaseKernelInterface( this_lcl );

#ifndef WINNT
        /*
         * free all video memory heaps
         */
        for( i=0;i<(int)this->vmiData.dwNumHeaps;i++ )
        {
            LPVIDMEM    pvm;
            pvm = &this->vmiData.pvmList[i];
            HeapVidMemFini( pvm, hvxd );
        }
#endif //not WINNT

        /*
         * free extra tables
         */
        MemFree( this->lpdwFourCC );
        MemFree( this->vmiData.pvmList );
#ifndef WINNT
        //On NT, lpModeInfo points to a contained member of "this"
        MemFree( this->lpModeInfo );
#endif
        MemFree( this->lpDDVideoPortCaps );
        MemFree( this->lpDDKernelCaps );
        MemFree( (LPVOID) this->lpD3DHALCallbacks2 );
        MemFree( (LPVOID) this->lpD3DHALCallbacks3);
        MemFree( (LPVOID) this->lpD3DExtendedCaps );
        MemFree( this->lpddNLVCaps );
        MemFree( this->lpddNLVHELCaps );
        MemFree( this->lpddNLVBothCaps );
#ifdef WINNT
        if ( this->lpD3DGlobalDriverData )
            MemFree( this->lpD3DGlobalDriverData->lpTextureFormats );
        // The lpD3DGlobalDriverData, lpD3DHALCallbacks and EXEBUF structs
        // are allocated in one chunk in ddcreate.c
        MemFree( (void *)this->lpD3DHALCallbacks );
        if (NULL != this->SurfaceHandleList.dwList)
        {
            MemFree(this->SurfaceHandleList.dwList);
        }
#endif

        MemFree(this->lpZPixelFormats);
        MemFree(this->lpddMoreCaps);
        MemFree(this->lpddHELMoreCaps);
        MemFree(this->lpddBothMoreCaps);
        MemFree( this->lpMonitorInfo );
#ifdef POSTPONED
        MemFree((LPVOID) this->lpDDUmodeDrvInfo);
        MemFree((LPVOID) this->lpDDOptSurfaceInfo);
#endif

        #ifdef WIN95
            DD16_DoneDriver( this->hInstance );
            event16 = this->dwEvent16;
            eventDOSBox = this->dwDOSBoxEvent;
        #endif
        hinst = (HANDLE) ULongToPtr(this->hInstance);
        /*
         * The DDHAL_CALLBACKS structure tacked onto the end of the
         * global object is also automatically freed here because it
         * was allocated with the global object in a single malloc
         */
        MemFree( this );

        DPF( 4, "Driver is now FREE" );
    }

    if( lclrefcnt == 0 )
    {
        #ifdef WIN95
            /*
             * We are now finished with the local object's VXD handle. However
             * we don't discard it if we are running in DDHELP's context as, in
             * that case, the handle has been freed by the operating system
             * and closing it would be possitively dangerous.
             */
            if( ( GetCurrentProcessId() == GETCURRPID() ) && this )
            {
                DDASSERT( INVALID_HANDLE_VALUE != hthisvxd );
                CloseHandle( hthisvxd );
            }
        #endif /* WIN95 */

        /*
         * only free DC's if we aren't running on DDHELP's context
         */
        if( (GetCurrentProcessId() == GETCURRPID()) && ((HDC)this_lcl->hDC != NULL) )
        {
            LPDDRAWI_DIRECTDRAW_LCL ddlcl;


            // If there are other local objects in this process,
            // wait to delete the hdc until the last object is
            // deleted.

            for( ddlcl=lpDriverLocalList; ddlcl != NULL; ddlcl = ddlcl->lpLink)
            {
                if( (ddlcl != this_lcl) && (ddlcl->hDC == this_lcl->hDC) )
                    break;
            }
            if( ddlcl == NULL )
            {
                WORD fPriv;
                #ifdef WIN95
                    // We need to unmark it as private now so
                    // that the delete will succeed
                    fPriv = DD16_MakeObjectPrivate((HDC)this_lcl->hDC, FALSE);
                    DDASSERT(fPriv == TRUE);
                    /*
                     * The following assert will fail occasionally inside
                     * GetObjectType. I mean crash. Don't understand. We
                     * should put the assert back in for 5a and see if it blows
                     * on our machines.
                     */

                    //DDASSERT(GetObjectType((HDC)this_lcl->hDC) == OBJ_DC);
                #endif

                DeleteDC( (HDC)this_lcl->hDC );
            }
        }
#ifdef  WIN95
        if (NULL != this_lcl->SurfaceHandleList.dwList)
        {
            MemFree(this_lcl->SurfaceHandleList.dwList);
        }
#endif  //WIN95
        /*
         * delete this local object from the master list
         */
        RemoveLocalFromList( this_lcl );

        // Free the local object (finally)!
        MemFree( this_lcl );
    }

    #ifdef WIN95
        if( event16 != 0 )
        {
            closeVxDHandle( event16 );
        }
        if( eventDOSBox != 0 )
        {
            closeVxDHandle( eventDOSBox );
        }
    #endif

    /*
     * if interface is freed, we reset the vtbl and remove it
     * from the list of drivers.
     */
    if( intrefcnt == 0 )
    {
        /*
         * delete this driver object from the master list
         */
        RemoveDriverFromList( this_int, gblrefcnt == 0 );

        /*
         * just in case someone comes back in with this pointer, set
         * an invalid vtbl.
         */
        this_int->lpVtbl = NULL;
        MemFree( this_int );
    }

    LEAVE_DDRAW();

#ifndef WINNT
    if( hinst != NULL )
    {
        HelperKillModeSetThread( (DWORD) hinst );
        HelperKillDOSBoxThread( (DWORD) hinst );
    }
#endif //!WINNT

    HIDESHOW_IME();     //Show/hide the IME OUTSIDE of the ddraw critsect.

    return intrefcnt;

} /* DD_Release */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddheapl.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheapl.c
 *  Content:    Linear heap manager
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   03-Feb-98  DrewB   Split from old vmemmgr.c for user/kernel code.
 *
 ***************************************************************************/

#include "ddrawpr.h"

/****************************************************************************

 This memory manager is designed to have no impact on video memory usage.
 Global memory is used to maintain the allocation and free lists.  Because
 of this choice, merging of free blocks is a more expensive operation.
 The assumption is that in general, the speed of creating/destroying these
 memory blocks is not a high usage item and so it is OK to be slower.

 ****************************************************************************/

/*
 * MIN_SPLIT_SIZE determines the minimum size of a free block - if splitting
 * a block will result in less than MIN_SPLIT_SIZE bytes left, then
 * those bytes are just left as part of the new block.
 */
#define MIN_SPLIT_SIZE  15

/*
 * BLOCK_BOUNDARY must be a power of 2, and at least 4.  This gives
 * us the alignment of memory blocks.   
 */
#define BLOCK_BOUNDARY  4

/*
 * linVidMemInit - initialize video memory manager
 */
BOOL linVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, FLATPTR end )
{
    DWORD       size;

    VDPF((4,V, "linVidMemInit(%08lx,%08lx)", start, end ));

    /*
     * get the size of the heap (and verify its alignment for debug builds)
     */
    size = (DWORD)(end - start) + 1;
    #ifdef DEBUG
	if( (size & (BLOCK_BOUNDARY-1)) != 0 )
	{
	    VDPF(( 0, V, "Invalid size: %08lx (%ld)\n", size, size ));
	}
    #endif

    pvmh->dwTotalSize = size;

    /*
     * set up a free list with the whole chunk of memory on the block
     */
    pvmh->freeList = MemAlloc( sizeof( VMEML ) );
    if( pvmh->freeList == NULL )
    {
	return FALSE;
    }
    ((LPVMEML)pvmh->freeList)->next = NULL;
    ((LPVMEML)pvmh->freeList)->ptr = start;
    ((LPVMEML)pvmh->freeList)->size = size;

    pvmh->allocList = NULL;

    return TRUE;

} /* linVidMemInit */

/*
 * linVidMemFini - done with video memory manager
 */
void linVidMemFini( LPVMEMHEAP pvmh )
{
    LPVMEML     curr;
    LPVMEML     next;

    if( pvmh != NULL )
    {
	/*
	 * free all memory allocated for the free list
	 */
	curr = (LPVMEML)pvmh->freeList;
	while( curr != NULL )
	{
	    next = curr->next;
	    MemFree( curr );
	    curr = next;
	}
	pvmh->freeList = NULL;

	/*
	 * free all memory allocated for the allocation list
	 */
	curr = (LPVMEML)pvmh->allocList;
	while( curr != NULL )
	{
	    next = curr->next;
	    MemFree( curr );
	    curr = next;
	}
	pvmh->allocList = NULL;

	/*
	 * free the heap data
	 */
	MemFree( pvmh );
    }

} /* linVidMemFini */

/*
 * insertIntoList - add an item to the allocation list. list is kept in
 *                  order of increasing size
 */
void insertIntoList( LPVMEML pnew, LPLPVMEML listhead )
{
    LPVMEML     pvmem;
    LPVMEML     prev;

    #ifdef DEBUG
	if( pnew->size == 0 )
	{
	    VDPF(( 0, V, "block size = 0!!!\n" ));
	}
    #endif

    /*
     * run through the list (sorted from smallest to largest) looking
     * for the first item bigger than the new item
     */
    pvmem = *listhead;
    prev = NULL;
    while( pvmem != NULL )
    {
	if( pnew->size < pvmem->size )
	{
	    break;
	}
	prev = pvmem;
	pvmem = pvmem->next;
    }

    /*
     * insert the new item item (before the found one)
     */
    if( prev != NULL )
    {
	pnew->next = pvmem;
	prev->next = pnew;
    }
    else
    {
	pnew->next = *listhead;
	*listhead = pnew;
    }

} /* insertIntoList */

/*
 * coalesceFreeBlocks - add a new item to the free list and coalesce
 */
LPVMEML coalesceFreeBlocks( LPVMEMHEAP pvmh, LPVMEML pnew )
{
    LPVMEML     pvmem;
    LPVMEML     prev;
    FLATPTR     end;
    BOOL        done;

    pvmem = (LPVMEML)pvmh->freeList;
    pnew->next = NULL;
    end = pnew->ptr + pnew->size;
    prev = NULL;
    done = FALSE;

    /*
     * try to merge the new block "pnew"
     */
    while( pvmem != NULL )
    {
	if( pnew->ptr == (pvmem->ptr + pvmem->size) )
	{
	    /*
	     * new block starts where another ended
	     */
	    pvmem->size += pnew->size;
	    done = TRUE;
	}
	else if( end == pvmem->ptr )
	{
	    /*
	     * new block ends where another starts
	     */
	    pvmem->ptr = pnew->ptr;
	    pvmem->size += pnew->size;
	    done = TRUE;
	}
	/*
	 * if we are joining 2 blocks, remove the merged on from the
	 * list and return so that it can be re-tried (we don't recurse
	 * since we could get very deep)
	 */
	if( done )
	{
	    if( prev != NULL )
	    {
		prev->next = pvmem->next;
	    }
	    else
	    {
		pvmh->freeList = pvmem->next;
	    }
	    MemFree( pnew );
	    return pvmem;
	}
	prev = pvmem;
	pvmem = pvmem->next;
    }

    /*
     * couldn't merge, so just add to the free list
     */
    insertIntoList( pnew, (LPLPVMEML) &pvmh->freeList );
    return NULL;

} /* coalesceFreeBlocks */

/*
 * linVidMemFree = free some flat video memory
 */
void linVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    LPVMEML     pvmem;
    LPVMEML     prev;

    if( ptr == (FLATPTR) NULL )
    {
	return;
    }

    #ifdef DEBUG
	if( pvmh == NULL )
	{
	    VDPF(( 0, V, "VidMemAlloc: NULL heap handle!\n" ));
	    return;
	}
    #endif

    pvmem = (LPVMEML)pvmh->allocList;
    prev = NULL;

    /*
     * run through the allocation list and look for this ptr
     * (O(N), bummer; that's what we get for not using video memory...)
     */
    while( pvmem != NULL )
    {
	if( pvmem->ptr == ptr )
	{
	    /*
	     * remove from allocation list
	     */
	    if( prev != NULL )
	    {
		prev->next = pvmem->next;
	    }
	    else
	    {
		pvmh->allocList = pvmem->next;
	    }
	    /*
	     * keep coalescing until we can't coalesce anymore
	     */
	    while( pvmem != NULL )
	    {
		pvmem = coalesceFreeBlocks( pvmh, pvmem );
	    }
	    return;
	}
	prev = pvmem;
	pvmem = pvmem->next;
    }

} /* linVidMemFree */

/*
 * linVidMemAlloc - alloc some flat video memory
 */
FLATPTR linVidMemAlloc( LPVMEMHEAP pvmh, DWORD xsize, DWORD ysize,
                        LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment,
                        LPLONG lpNewPitch )
{
    LPVMEML     pvmem;
    LPVMEML     prev;
    LPVMEML     pnew_free;

    DWORD       dwBeforeWastage;
    DWORD       dwAfterWastage;
    FLATPTR     pAligned;

    LONG        lNewPitch;

    DWORD       size;

    if( xsize == 0 || ysize == 0 || pvmh == NULL )
    {
	return (FLATPTR) NULL;
    }

    lNewPitch = (LONG) xsize;
    if (lpAlignment && lpAlignment->Linear.dwPitchAlignment )
    {
        if (lNewPitch % lpAlignment->Linear.dwPitchAlignment)
        {
            lNewPitch += lpAlignment->Linear.dwPitchAlignment - lNewPitch % lpAlignment->Linear.dwPitchAlignment;
        }
    }
    /*
     * This weird size calculation doesn't include the little bit on the 'bottom right' of the surface
     */
    size = (DWORD) lNewPitch * (ysize-1) + xsize;
    size = (size+(BLOCK_BOUNDARY-1)) & ~(BLOCK_BOUNDARY-1);

    /*
     * run through free list, looking for the closest matching block
     */
    prev = NULL;
    pvmem = (LPVMEML)pvmh->freeList;
    while( pvmem != NULL )
    {
	while( pvmem->size >= size ) //Using while as a try block
	{
            /*
             * Setup for no alignment changes..
             */
            pAligned = pvmem->ptr;
            dwBeforeWastage = 0;
            dwAfterWastage = pvmem->size - size;
            if( lpAlignment )
            {
                //get wastage if we put the new block at the beginning or at the end of the free block
                if( lpAlignment->Linear.dwStartAlignment )
                {
                    /*
                     * The before wastage is how much we'd have to skip at the beginning to align the surface
                     */

                    dwBeforeWastage = (lpAlignment->Linear.dwStartAlignment - ((DWORD)pvmem->ptr % lpAlignment->Linear.dwStartAlignment)) % lpAlignment->Linear.dwStartAlignment;
                    //if ( dwBeforeWastage+size > pvmem->size )
                    //    break;
                    /*
                     * The after wastage is the bit between the end of the used surface and the end of the block
                     * if we snuggle this surface as close to the end of the block as possible.
                     */
                    dwAfterWastage = ( (DWORD)pvmem->ptr + pvmem->size - size ) % lpAlignment->Linear.dwStartAlignment;
                    //if ( dwAfterWastage + size > pvmem->size )
                    //    break;
                }
                /*
                 * Reassign before/after wastage to meaningful values based on where the block will actually go.
                 * Also check that aligning won't spill the surface off either end of the block.
                 */
                if ( dwBeforeWastage <= dwAfterWastage )
                {
                    if (pvmem->size < size + dwBeforeWastage)
                    {
                        /*
                         * Alignment pushes end of surface off end of block
                         */
                        break;
                    }
                    dwAfterWastage = pvmem->size - (size + dwBeforeWastage);
                    pAligned = pvmem->ptr + dwBeforeWastage;
                }
                else
                {
                    if (pvmem->size < size + dwAfterWastage)
                    {
                        /*
                         * Alignment pushes end of surface off beginning of block
                         */
                        break;
                    }
                    dwBeforeWastage = pvmem->size - (size + dwAfterWastage);
                    pAligned = pvmem->ptr + dwBeforeWastage;
                }
            }
            DDASSERT(size + dwBeforeWastage + dwAfterWastage == pvmem->size );
            DDASSERT(pAligned >= pvmem->ptr );
            DDASSERT(pAligned + size <= pvmem->ptr + pvmem->size );
            /*
             * Remove the old free block from the free list.
             */
	    if( prev != NULL )
	    {
		prev->next = pvmem->next;
	    }
	    else
	    {
		pvmh->freeList = pvmem->next;
	    }

            /*
             * If the after wastage is less than a small amount, smush it into
             * this block.
             */
            if (dwAfterWastage <= MIN_SPLIT_SIZE)
            {
                size += dwAfterWastage;
                dwAfterWastage=0;
            }
            /*
             * Add the new block to the used list, using the old free block
             */
	    pvmem->size = size;
	    pvmem->ptr = pAligned;
	    if( NULL != lpdwSize )
		*lpdwSize = size;
            if (NULL != lpNewPitch)
                *lpNewPitch = lNewPitch;
	    insertIntoList( pvmem, (LPLPVMEML) &pvmh->allocList );

            /*
             * Add a new free block for before wastage
             */
            if (dwBeforeWastage)
            {
		pnew_free = (LPVMEML)MemAlloc( sizeof( VMEML ) );
		if( pnew_free == NULL )
		{
		    return (FLATPTR) NULL;
		}
		pnew_free->size = dwBeforeWastage;
		pnew_free->ptr = pAligned-dwBeforeWastage;
		insertIntoList( pnew_free, (LPLPVMEML) &pvmh->freeList );
            }
            /*
             * Add a new free block for after wastage
             */
            if (dwAfterWastage)
            {
		pnew_free = (LPVMEML)MemAlloc( sizeof( VMEML ) );
		if( pnew_free == NULL )
		{
		    return (FLATPTR) NULL;
		}
		pnew_free->size = dwAfterWastage;
		pnew_free->ptr = pAligned+size;
		insertIntoList( pnew_free, (LPLPVMEML) &pvmh->freeList );
            }
#ifdef DEBUG
            if( lpAlignment )
            {
                if (lpAlignment->Linear.dwStartAlignment)
                {
                    VDPF((5,V,"Alignment for start is %d",lpAlignment->Linear.dwStartAlignment));
                    DDASSERT(pvmem->ptr % lpAlignment->Linear.dwStartAlignment == 0);
                }
                if (lpAlignment->Linear.dwPitchAlignment)
                {
                    VDPF((5,V,"Alignment for pitch is %d",lpAlignment->Linear.dwPitchAlignment));
                    DDASSERT(lNewPitch % lpAlignment->Linear.dwPitchAlignment == 0);
                }
            }
#endif
	    return pvmem->ptr;
	}
	prev = pvmem;
	pvmem = pvmem->next;
    }
    return (FLATPTR) NULL;

} /* linVidMemAlloc */

/*
 * linVidMemAmountAllocated
 */
DWORD linVidMemAmountAllocated( LPVMEMHEAP pvmh )
{
    LPVMEML     pvmem;
    DWORD       size;

    pvmem = (LPVMEML)pvmh->allocList;
    size = 0;
    while( pvmem != NULL )
    {
	size += pvmem->size;
	pvmem = pvmem->next;
    }
    return size;

} /* linVidMemAmountAllocated */

/*
 * linVidMemAmountFree
 */
DWORD linVidMemAmountFree( LPVMEMHEAP pvmh )
{
    LPVMEML     pvmem;
    DWORD       size;

    pvmem = (LPVMEML)pvmh->freeList;
    size = 0;
    while( pvmem != NULL )
    {
	size += pvmem->size;
	pvmem = pvmem->next;
    }
    return size;

} /* linVidMemAmountFree */

/*
 * linVidMemLargestFree - alloc some flat video memory
 */
DWORD linVidMemLargestFree( LPVMEMHEAP pvmh )
{
    LPVMEML     pvmem;

    if( pvmh == NULL )
    {
	return 0;
    }

    pvmem = (LPVMEML)pvmh->freeList;

    if( pvmem == NULL )
    {
	return 0;
    }
    
    while( 1 )
    {
	if( pvmem->next == NULL )
	{
	    return pvmem->size;
	}
	pvmem = pvmem->next;
    }
    
} /* linVidMemLargestFree */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddheap.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheap.c
 *  Content:    Top-level heap routines.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-dec-94  craige  initial implementation
 *   06-jan-95  craige  integrated into DDRAW
 *   20-mar-95  craige  prepare for rectangular memory manager
 *   27-mar-95  craige  linear or rectangular vidmem
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  fill in free video memory
 *   15-may-95  craige  made separate VMEM struct for rect & linear
 *   10-jun-95  craige  exported fns
 *   02-jul-95  craige  fail if VidMemInit if linear or rect. fail;
 *                      removed linFindMemBlock
 *   17-jul-95  craige  added VidMemLargestFree
 *   01-dec-95  colinmc added VidMemAmountAllocated
 *   11-dec-95  kylej   added VidMemGetRectStride
 *   05-jul-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   03-Feb-98  DrewB   Made portable between user and kernel.
 *
 ***************************************************************************/

#include "ddrawpr.h"

/*
 * IsDifferentPixelFormat
 *
 * determine if two pixel formats are the same or not
 *
 * (CMcC) 12/14/95 Really useful - so no longer static
 *
 * This function really shouldn't be in a heap file but it's
 * needed by both the user and kernel code so this is a convenient
 * place to put it to have it shared.
 */
BOOL IsDifferentPixelFormat( LPDDPIXELFORMAT pdpf1, LPDDPIXELFORMAT pdpf2 )
{
    /*
     * same flags?
     */
    if( pdpf1->dwFlags != pdpf2->dwFlags )
    {
	VDPF(( 4, S, "Flags differ!" ));
	return TRUE;
    }

    /*
     * same bitcount for non-YUV surfaces?
     */
    if( !(pdpf1->dwFlags & (DDPF_YUV | DDPF_FOURCC)) )
    {
	if( pdpf1->dwRGBBitCount != pdpf2->dwRGBBitCount )
	{
	    VDPF(( 4, S, "RGB Bitcount differs!" ));
	    return TRUE;
	}
    }

    /*
     * same RGB properties?
     */
    if( pdpf1->dwFlags & DDPF_RGB )
    {
	if( pdpf1->dwRBitMask != pdpf2->dwRBitMask )
	{
	    VDPF(( 4, S, "RBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwGBitMask != pdpf2->dwGBitMask )
	{
	    VDPF(( 4, S, "GBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwBBitMask != pdpf2->dwBBitMask )
	{
	    VDPF(( 4, S, "BBitMask differs!" ));
	    return TRUE;
	}
        if( ( pdpf1->dwFlags & DDPF_ALPHAPIXELS ) &&
	    ( pdpf1->dwRGBAlphaBitMask != pdpf2->dwRGBAlphaBitMask )
          )
        {
            VDPF(( 4, S, "RGBAlphaBitMask differs!" ));
            return TRUE;
        }
    }

    /*
     * same YUV properties?
     */
    if( pdpf1->dwFlags & DDPF_YUV )
    {
	VDPF(( 5, S, "YUV???" ));
	if( pdpf1->dwFourCC != pdpf2->dwFourCC )
	{
	    return TRUE;
	}
	if( pdpf1->dwYUVBitCount != pdpf2->dwYUVBitCount )
	{
	    return TRUE;
	}
	if( pdpf1->dwYBitMask != pdpf2->dwYBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwUBitMask != pdpf2->dwUBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwVBitMask != pdpf2->dwVBitMask )
	{
	    return TRUE;
	}
        if( ( pdpf1->dwFlags & DDPF_ALPHAPIXELS ) &&
	    (pdpf1->dwYUVAlphaBitMask != pdpf2->dwYUVAlphaBitMask )
          )
	{
	    return TRUE;
	}
    }

    /*
     * Possible to use FOURCCs w/o setting the DDPF_YUV flag
     * ScottM 7/11/96
     */
    else if( pdpf1->dwFlags & DDPF_FOURCC )
    {
	VDPF(( 5, S, "FOURCC???" ));
	if( pdpf1->dwFourCC != pdpf2->dwFourCC )
	{
	    return TRUE;
	}
    }

    /*
     *	If Interleaved Z then check Z bit masks are the same
     */
    if( pdpf1->dwFlags & DDPF_ZPIXELS )
    {
	VDPF(( 5, S, "ZPIXELS???" ));
	if( pdpf1->dwRGBZBitMask != pdpf2->dwRGBZBitMask )
	    return TRUE;
    }

    return FALSE;

} /* IsDifferentPixelFormat */

/*
 * VidMemInit - initialize video memory manager heap
 */
LPVMEMHEAP WINAPI VidMemInit(
		DWORD   flags,
		FLATPTR start,
		FLATPTR width_or_end,
		DWORD   height,
		DWORD   pitch )
{
    LPVMEMHEAP  pvmh;

    pvmh = (LPVMEMHEAP)MemAlloc( sizeof( VMEMHEAP ) );
    if( pvmh == NULL )
    {
	return NULL;
    }
    pvmh->dwFlags = flags;
    ZeroMemory( & pvmh->Alignment.ddsCaps, sizeof(pvmh->Alignment.ddsCaps) );

    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	if( !linVidMemInit( pvmh, start, width_or_end ) )
	{
	    MemFree( pvmh );
	    return NULL;
	}
    }
    else
    {
	if( !rectVidMemInit( pvmh, start, (DWORD) width_or_end, height,
                             pitch ) )
	{
	    MemFree( pvmh );
	    return NULL;
	}
    }
    return pvmh;

} /* VidMemInit */

/*
 * VidMemFini - done with video memory manager
 */
void WINAPI VidMemFini( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	linVidMemFini( pvmh );
    }
    else
    {
	rectVidMemFini( pvmh );
    }

} /* VidMemFini */

/*
 * InternalVidMemAlloc - alloc some flat video memory and give us back the size
 * we allocated
 */
FLATPTR WINAPI InternalVidMemAlloc( LPVMEMHEAP pvmh, DWORD x, DWORD y,
                                    LPDWORD lpdwSize,
                                    LPSURFACEALIGNMENT lpAlignment,
                                    LPLONG lpNewPitch )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemAlloc( pvmh, x, y, lpdwSize, lpAlignment, lpNewPitch );
    }
    else
    {
	FLATPTR lp = rectVidMemAlloc( pvmh, x, y, lpdwSize, lpAlignment );
        if (lp && lpNewPitch )
        {
            *lpNewPitch = (LONG) pvmh->stride;
        }
        return lp;
    }
    return (FLATPTR) NULL;

} /* InternalVidMemAlloc */

/*
 * VidMemAlloc - alloc some flat video memory
 */
FLATPTR WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD x, DWORD y )
{
    DWORD dwSize;

    /*
     * We are not interested in the size here.
     */
    return InternalVidMemAlloc( pvmh, x, y, &dwSize , NULL , NULL );
} /* VidMemAlloc */

/*
 * VidMemFree = free some flat video memory
 */
void WINAPI VidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	linVidMemFree( pvmh, ptr );
    }
    else
    {
	rectVidMemFree( pvmh, ptr );
    }

} /* VidMemFree */

/*
 * VidMemAmountAllocated
 */
DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemAmountAllocated( pvmh );
    }
    else
    {
	return rectVidMemAmountAllocated( pvmh );
    }
 
} /* VidMemAmountAllocated */

/*
 * VidMemAmountFree
 */
DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemAmountFree( pvmh );
    }
    else
    {
	return rectVidMemAmountFree( pvmh );
    }
 
} /* VidMemAmountFree */

/*
 * VidMemLargestFree
 */
DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemLargestFree( pvmh );
    }
    else
    {
	return 0;
    }

} /* VidMemLargestFree */

/*
 * HeapVidMemInit
 *
 * Top level heap initialization code which handles AGP stuff.
 */
LPVMEMHEAP WINAPI HeapVidMemInit( LPVIDMEM lpVidMem,
		                  DWORD    pitch,
		                  HANDLE   hdev,
                                  LPHEAPALIGNMENT pgad)
{
    DWORD         dwSize;
    FLATPTR       fpLinStart;
    LARGE_INTEGER liDevStart;
    PVOID         pvReservation;

    DDASSERT( NULL != lpVidMem );

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        BOOL    fIsUC;
        BOOL    fIsWC;
        DWORD   dwSizeReserved = 0;

        /*
         * Its a non-local heap so the first thing we need to do
         * is to reserved the heap address range.
         */

        /*
         * Compute the size of the heap.
         */
        if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
        {
            dwSize = (DWORD)(lpVidMem->fpEnd - lpVidMem->fpStart) + 1UL;
            if (dwSize & 1)
            {
                DPF_ERR("Driver error: fpEnd of non-local heap should be inclusive");
            }
        }
        else
        {
            DDASSERT( lpVidMem->dwFlags & VIDMEM_ISRECTANGULAR );
            dwSize = (pitch * lpVidMem->dwHeight);
        }
        DDASSERT( 0UL != dwSize );

        if( lpVidMem->dwFlags & VIDMEM_ISWC )
        {
            fIsUC = FALSE;
            fIsWC = TRUE;
        }
        else
        {
            fIsUC = TRUE;
            fIsWC = FALSE;
        }

        if( !(dwSizeReserved = AGPReserve( hdev, dwSize, fIsUC, fIsWC,
                                           &fpLinStart, &liDevStart,
                                           &pvReservation )) )
        {
            VDPF(( 0, V, "Could not reserve a GART address range for a "
                   "linear heap of size 0x%08x", dwSize ));
            return 0UL;
        }
        else
        {
            VDPF((4,V, "Allocated a GART address range starting at "
                  "0x%08x (linear) 0x%08x:0x%08x (physical) of size %d",
                  fpLinStart, liDevStart.HighPart, liDevStart.LowPart,
                  dwSizeReserved ));
        }

        if (dwSizeReserved != dwSize)
        {
            VDPF((1,V,"WARNING! This system required that the full "
                  "nonlocal aperture could not be reserved!"));
            VDPF((1,V,"         Requested aperture:%08x, "
                  "Reserved aperture:%08x", dwSize, dwSizeReserved));
        }

        /*
         * Update the heap for the new start address
         * (and end address for a linear heap).
         */
        lpVidMem->fpStart = fpLinStart;
        if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
        {
            lpVidMem->fpEnd = ( fpLinStart + dwSizeReserved ) - 1UL;
        }
        else
        {
            DDASSERT( lpVidMem->dwFlags & VIDMEM_ISRECTANGULAR );
            DDASSERT( pitch );
            lpVidMem->dwHeight = dwSizeReserved / pitch;
        }
    }

    if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
    {
	VDPF(( 4,V, "VidMemInit: Linear:      fpStart = 0x%08x fpEnd = 0x%08x",
	     lpVidMem->fpStart, lpVidMem->fpEnd ));
	lpVidMem->lpHeap = VidMemInit( VMEMHEAP_LINEAR, lpVidMem->fpStart,
                                       lpVidMem->fpEnd, 0, 0 );
    }
    else
    {
	VDPF(( 4,V, "VidMemInit: Rectangular: fpStart = 0x%08x "
               "dwWidth = %ld dwHeight = %ld, pitch = %ld",
	     lpVidMem->fpStart, lpVidMem->dwWidth, lpVidMem->dwHeight,
               pitch  ));
	lpVidMem->lpHeap = VidMemInit( VMEMHEAP_RECTANGULAR, lpVidMem->fpStart,
				       lpVidMem->dwWidth, lpVidMem->dwHeight,
                                       pitch );
    }

    /*
     * Modify the caps and alt-caps so that you don't allocate local
     * video memory surfaces out of AGP memory and vice-verse.
     */
    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
	/*
	 * Its an AGP heap. So don't let explict LOCAL video memory
	 * be allocated out of this heap.
	 */
	lpVidMem->ddsCaps.dwCaps    |= DDSCAPS_LOCALVIDMEM;
	lpVidMem->ddsCapsAlt.dwCaps |= DDSCAPS_LOCALVIDMEM;
    }
    else
    {
	/*
	 * Its a local video memory heap. So don't let explicity NON-LOCAL
	 * video memory be allocated out of this heap.
	 */
	lpVidMem->ddsCaps.dwCaps    |= DDSCAPS_NONLOCALVIDMEM;
	lpVidMem->ddsCapsAlt.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
    }

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        if (lpVidMem->lpHeap != NULL)
        {
            /*
             * We start out with no committed memory.
             */
            lpVidMem->lpHeap->fpGARTLin      = fpLinStart;
            // Fill in partial physical address for Win9x.
            lpVidMem->lpHeap->fpGARTDev      = liDevStart.LowPart;
            // Fill in complete physical address for NT.
            lpVidMem->lpHeap->liPhysAGPBase  = liDevStart;
            lpVidMem->lpHeap->pvPhysRsrv     = pvReservation;
            lpVidMem->lpHeap->dwCommitedSize = 0UL;
        }
        else if (pvReservation != NULL)
        {
            AGPFree( hdev, pvReservation );
        }
    }

    /*
     * Copy any extended alignment data into the private heap structure
     */
    if ( lpVidMem->lpHeap )
    {
        if ( pgad )
        {
            lpVidMem->lpHeap->dwFlags |= VMEMHEAP_ALIGNMENT;
            lpVidMem->lpHeap->Alignment = *pgad;
            VDPF((4,V,"Extended alignment turned on for this heap."));
            VDPF((4,V,"Alignments are turned on for:"));
            VDPF((4,V,"  %08X",pgad->ddsCaps));
        }
        else
        {
            /*
             * This means the allocation routines will do no alignment modifications
             */
            VDPF((4,V,"Extended alignment turned OFF for this heap."));
            lpVidMem->lpHeap->dwFlags &= ~VMEMHEAP_ALIGNMENT;
        }
    }

    return lpVidMem->lpHeap;
} /* HeapVidMemInit */

/*
 * HeapVidMemFini
 *
 * Top level heap release code. Handle AGP stuff
 */
void WINAPI HeapVidMemFini( LPVIDMEM lpVidMem, HANDLE hdev )
{
    DWORD dwCommittedSize = 0UL;
    PVOID pvReservation;

    /*
     * Remember how much memory we committed to the AGP heap.
     */
    DDASSERT( NULL != lpVidMem->lpHeap );
    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        dwCommittedSize = lpVidMem->lpHeap->dwCommitedSize;
        pvReservation = lpVidMem->lpHeap->pvPhysRsrv;
    }

    /*
     * Free the memory manager
     */
    VidMemFini( lpVidMem->lpHeap );
    lpVidMem->lpHeap = NULL;

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        BOOL fSuccess;
        
        /*
         * If this is a non-local (AGP) heap then decommit and
         * free the GART memory now.
         */
        if( 0UL != dwCommittedSize )
        {
            /*
             * Only decommit if we actually bothered to commit something
             * in the first place.
             */
            fSuccess = AGPDecommitAll( hdev, pvReservation, dwCommittedSize );
            /*
             * Should never fail and not much we can do if it does apart
             * from assert that something bad is happening.
             */
            DDASSERT( fSuccess );
        }

        fSuccess = AGPFree( hdev, pvReservation );
        /*
         * Again this should only fail if the OS is in an unstable state
         * or if I have messed up (sadly the later is all too likely)
         * so assert.
         */
        DDASSERT( fSuccess );
    }   
} /* HeapVidMemFini */

/*
 * This is an external entry point which can be used by drivers to allocate 
 * aligned surfaces.
 */
FLATPTR WINAPI HeapVidMemAllocAligned( 
                LPVIDMEM lpVidMem,
                DWORD dwWidth, 
                DWORD dwHeight, 
                LPSURFACEALIGNMENT lpAlignment , 
                LPLONG lpNewPitch )
{
    HANDLE  hdev;
    FLATPTR ptr;
    DWORD   dwSize;

    if ( lpVidMem == NULL ||
         lpVidMem->lpHeap == NULL ||
         (lpVidMem->dwFlags & VIDMEM_HEAPDISABLED) )
    {
	return (FLATPTR) NULL;
    }

    /*
     * As we may need to commit AGP memory we need a device handle
     * to communicate with the AGP controller. Rather than hunting
     * through the driver object list hoping we will find a
     * local object for this process we just create a handle
     * and discard it after the allocation. This should not be
     * performance critical code to start with.
     */
    hdev = OsGetAGPDeviceHandle(lpVidMem->lpHeap);
    if (hdev == NULL)
    {
        return 0;
    }

    /* Pass NULL Alignment and new pitch pointer */
    ptr = HeapVidMemAlloc( lpVidMem, dwWidth, dwHeight,
                           hdev, lpAlignment, lpNewPitch, &dwSize );

    OsCloseAGPDeviceHandle( hdev );

    return ptr; 
}

/*
 * HeapVidMemAlloc
 *
 * Top level video memory allocation function. Handles AGP stuff
 */
FLATPTR WINAPI HeapVidMemAlloc( LPVIDMEM lpVidMem, DWORD x, DWORD y,
                                HANDLE hdev, LPSURFACEALIGNMENT lpAlignment,
                                LPLONG lpNewPitch, LPDWORD pdwSize )
{
    FLATPTR fpMem;
    DWORD   dwSize;

    DDASSERT( NULL != lpVidMem );
    DDASSERT( NULL != lpVidMem->lpHeap );

    fpMem = InternalVidMemAlloc( lpVidMem->lpHeap, x, y, &dwSize,
                                 lpAlignment, lpNewPitch );
    if( 0UL == fpMem )
    {
	return fpMem;
    }

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        DWORD dwCommittedSize;
        /*
         * If this is a non-local heap then we may not have actually
         * committed the memory that has just been allocated. We can
         * determine this by seeing if the highest address so far
         * committed is less than the last address in the surface.
         */
        dwCommittedSize = lpVidMem->lpHeap->dwCommitedSize;
        if( (fpMem + dwSize) > (lpVidMem->fpStart + dwCommittedSize) )
        {
            DWORD dwSizeToCommit;
            BOOL  fSuccess;

            /*
             * We have not yet committed sufficient memory from this heap for
             * this surface so commit now. We don't want to recommit for every
             * surface creation so we have a minimum commit size
             * (dwAGPPolicyCommitDelta). We also need to ensure that by forcing
             * the granularity we don't go over the total size of the heap. So
             * clamp to that also.
             */
            dwSizeToCommit = (DWORD)((fpMem + dwSize) -
                                     (lpVidMem->fpStart + dwCommittedSize));
            if( dwSizeToCommit < dwAGPPolicyCommitDelta )
                dwSizeToCommit = min(dwAGPPolicyCommitDelta,
                                     lpVidMem->lpHeap->dwTotalSize -
                                     dwCommittedSize);

            /*
             * Okay, we have the offset and the size we need to commit. So ask
             * the OS to commit memory to that portion of this previously
             * reserved GART range.
             *
             * NOTE: We start commiting from the start of the currently
             * uncommitted area.
             */
            fSuccess = AGPCommit( hdev, lpVidMem->lpHeap->pvPhysRsrv,
                                  dwCommittedSize, dwSizeToCommit );
            if( !fSuccess )
            {
                /*
                 * Couldn't commit. Must be out of memory.
                 * Put the allocated memory back and fail.
                 */
                VidMemFree( lpVidMem->lpHeap, fpMem );
                return (FLATPTR) NULL;
            }
            lpVidMem->lpHeap->dwCommitedSize += dwSizeToCommit;
        }
    }

    if (pdwSize != NULL)
    {
        *pdwSize = dwSize;
    }
    
    return fpMem;
} /* HeapVidMemAlloc */

/*
 * SurfaceCapsToAlignment
 *
 * Return a pointer to the appropriate alignment element in a VMEMHEAP
 * structure given surface caps.
 *
 */
LPSURFACEALIGNMENT SurfaceCapsToAlignment(
    LPVIDMEM			lpVidmem ,
    LPDDRAWI_DDRAWSURFACE_LCL	lpSurfaceLcl,
    LPVIDMEMINFO                lpVidMemInfo)
{
    LPVMEMHEAP			lpHeap;
    LPDDSCAPS			lpCaps;
    LPDDRAWI_DDRAWSURFACE_GBL	lpSurfaceGbl;

    DDASSERT( lpVidmem );
    DDASSERT( lpSurfaceLcl );
    DDASSERT( lpVidMemInfo );
    DDASSERT( lpVidmem->lpHeap );

    if ( !lpVidmem->lpHeap )
        return NULL;

    lpCaps = &lpSurfaceLcl->ddsCaps;
    lpHeap = lpVidmem->lpHeap;
    lpSurfaceGbl = lpSurfaceLcl->lpGbl;

    if ( (lpHeap->dwFlags & VMEMHEAP_ALIGNMENT) == 0 )
        return NULL;

    if ( lpCaps->dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            VDPF((4,V,"Aligning surface as execute buffer"));
            return & lpHeap->Alignment.ExecuteBuffer;
        }
        /*
         * If the surface is an execute buffer, then no other
         * alignment can apply
         */
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_OVERLAY )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_OVERLAY )
        {
            VDPF((4,V,"Aligning surface as overlay"));
            return & lpHeap->Alignment.Overlay;
        }
        /*
         * If the surface is an overlay, then no other alignment can apply
         */
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_TEXTURE )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_TEXTURE )
        {
            VDPF((4,V,"Aligning surface as texture"));
            return & lpHeap->Alignment.Texture;
        }
        /*
         * If it's a texture, it can't be an offscreen or any of the others
         */
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_ZBUFFER )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
        {
            VDPF((4,V,"Aligning surface as Z buffer"));
            return & lpHeap->Alignment.ZBuffer;
        }
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_ALPHA )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_ALPHA )
        {
            VDPF((4,V,"Aligning surface as alpha buffer"));
            return & lpHeap->Alignment.AlphaBuffer;
        }
        return NULL;
    }

    /*
     * We need to give a surface which may potentially become a back buffer
     * the alignment which is reserved for potentially visible back buffers.
     * This includes any surface which has made it through the above checks
     * and has the same dimensions as the primary.
     * Note we check only the dimensions of the primary. There's an outside
     * chance that an app could create its back buffer before it creates
     * the primary
     */
    do
    {
	if ( lpSurfaceLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	{
	    if (IsDifferentPixelFormat( &lpVidMemInfo->ddpfDisplay,
                                        &lpSurfaceGbl->ddpfSurface ))
	    {
		/*
		 * Different pixel format from primary means this surface
                 * cannot be part of primary chain
		 */
		break;
	    }

	}

	if ( (DWORD)lpSurfaceGbl->wWidth != lpVidMemInfo->dwDisplayWidth )
	    break;

	if ( (DWORD)lpSurfaceGbl->wHeight != lpVidMemInfo->dwDisplayHeight )
	    break;


	/*
	 * This surface could potentially be part of primary chain.
         * It has the same
	 * pixel format as the primary and the same dimensions.
	 */
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_FLIP )
        {
            VDPF((4,V,"Aligning surface as potential primary surface"));
            return & lpHeap->Alignment.FlipTarget;
        }

	/*
	 * Drop through and check for offscreen if driver specified no
         * part-of-primary-chain alignment
	 */
	break;
    } while (0);

    if ( lpCaps->dwCaps & DDSCAPS_OFFSCREENPLAIN )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN )
        {
            VDPF((4,V,"Aligning surface as offscreen plain"));
            return & lpHeap->Alignment.Offscreen;
        }
    }

    VDPF((4,V,"No extended alignment for surface"));
    return NULL;
}

/*
 * DdHeapAlloc
 *
 * Search all heaps for one that has space and the appropriate
 * caps for the requested surface type and size.
 *
 * We AND the caps bits required and the caps bits not allowed
 * by the video memory.   If the result is zero, it is OK.
 *
 * This is called in 2 passes.   Pass1 is the preferred memory state,
 * pass2 is the "oh no no memory" state.
 *
 * On pass1, we use ddsCaps in the VIDMEM struct.
 * On pass2, we use ddsCapsAlt in the VIDMEM struct.
 *
 */
FLATPTR DdHeapAlloc( DWORD dwNumHeaps,
                     LPVIDMEM pvmHeaps,
                     HANDLE hdev,
                     LPVIDMEMINFO lpVidMemInfo,
                     DWORD dwWidth,
                     DWORD dwHeight,
                     LPDDRAWI_DDRAWSURFACE_LCL lpSurfaceLcl,
                     DWORD dwFlags,
                     LPVIDMEM *ppvmHeap,
                     LPLONG plNewPitch,
                     LPDWORD pdwNewCaps,
                     LPDWORD pdwSize)
{
    LPVIDMEM	pvm;
    DWORD	vm_caps;
    int		i;
    FLATPTR	pvidmem;
    HANDLE      hvxd;
    LPDDSCAPS	lpCaps;

    LPDDSCAPSEX lpExtendedRestrictions;
    LPDDSCAPSEX lpExtendedCaps;

    DDASSERT( NULL != pdwNewCaps );
    DDASSERT( NULL != lpSurfaceLcl );

    lpCaps = &lpSurfaceLcl->ddsCaps;
    lpExtendedCaps = &lpSurfaceLcl->lpSurfMore->ddsCapsEx;

    for( i = 0 ; i < (int)dwNumHeaps ; i++ )
    {
	pvm = &pvmHeaps[i];

        // Skip disabled heaps.
        if (pvm->dwFlags & VIDMEM_HEAPDISABLED)
        {
            continue;
        }
        
        /*
         * Skip rectangular heaps if we were told to.
         */
        if (dwFlags & DDHA_SKIPRECTANGULARHEAPS)
        {
            if (pvm->dwFlags & VIDMEM_ISRECTANGULAR)
            {
                continue;
            }
        }

	/*
	 * If local or non-local video memory has been explicity
	 * specified then ignore heaps which don't match the required
	 * memory type.
	 */
	if( ( lpCaps->dwCaps & DDSCAPS_LOCALVIDMEM ) &&
            ( pvm->dwFlags & VIDMEM_ISNONLOCAL ) )
	{
	    VDPF(( 4, V, "Local video memory was requested but heap is "
                   "non local. Ignoring heap %d", i ));
	    continue;
	}

	if( ( lpCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM ) &&
            !( pvm->dwFlags & VIDMEM_ISNONLOCAL ) )
	{
	    VDPF(( 4, V, "Non-local video memory was requested but "
                   "heap is local. Ignoring heap %d", i ));
	    continue;
	}

	if( !( lpCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM ) &&
	     ( pvm->dwFlags & VIDMEM_ISNONLOCAL ) &&
             ( dwFlags & DDHA_ALLOWNONLOCALMEMORY ) )
	{
            /*
             * We can allow textures to fail over to DMA model cards
             * if the card exposes an appropriate heap. This won't
             * affect cards which can't texture from nonlocal, because
             * they won't expose such a heap. This mod doesn't affect
             * execute model because all surfaces fail over to nonlocal
             * for them.
             * Note that we should only fail over to nonlocal if the
             * surface wasn't explicitly requested in local. There is a
             * clause a few lines up which guarantees this.
             */
            if ( !(lpCaps->dwCaps & DDSCAPS_TEXTURE) )
            {
	        VDPF(( 4, V, "Non-local memory not explicitly requested "
                       "for non-texture surface. Ignoring non-local heap %d",
                       i ));
	        continue;
            }

            /*
             * If the device can't texture out of AGP, we need to fail this
             * heap, since the app is probably expecting to texture out of
             * this surface.
             */
            if ( !(dwFlags & DDHA_ALLOWNONLOCALTEXTURES) )
            {
                continue;
            }
	}

	if( dwFlags & DDHA_USEALTCAPS )
	{
	    vm_caps = pvm->ddsCapsAlt.dwCaps;
            lpExtendedRestrictions = &(pvm->lpHeap->ddsCapsExAlt);
	}
	else
	{
	    vm_caps = pvm->ddsCaps.dwCaps;
            lpExtendedRestrictions = &(pvm->lpHeap->ddsCapsEx);
	}
        
	if( ((lpCaps->dwCaps & vm_caps) == 0) &&
            ((lpExtendedRestrictions->dwCaps2 & lpExtendedCaps->dwCaps2) == 0) &&
            ((lpExtendedRestrictions->dwCaps3 & lpExtendedCaps->dwCaps3) == 0) &&
            ((lpExtendedRestrictions->dwCaps4 & lpExtendedCaps->dwCaps4) == 0))
	{
	    pvidmem = HeapVidMemAlloc(
		pvm,
                dwWidth,
		dwHeight,
		hdev,
		SurfaceCapsToAlignment(pvm, lpSurfaceLcl, lpVidMemInfo),
		plNewPitch,
                pdwSize);

	    if( pvidmem != (FLATPTR) NULL )
	    {
		*ppvmHeap = pvm;

		if( pvm->dwFlags & VIDMEM_ISNONLOCAL )
		    *pdwNewCaps |= DDSCAPS_NONLOCALVIDMEM;
		else
		    *pdwNewCaps |= DDSCAPS_LOCALVIDMEM;
		return pvidmem;
	    }
	}
    }
    return (FLATPTR) NULL;

} /* DdHeapAlloc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddithunk.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddithunk.h
 *  Content:	header file used by the NT DDI thunk layer
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Dec-99  smac    Created it
 *
 ***************************************************************************/

#ifndef __DDITHUNK_INCLUDED__
#define __DDITHUNK_INCLUDED__

typedef struct _CACHEENTRY
{
    LPDDRAWI_DDRAWSURFACE_INT   pSurface;
    DWORD                       UsageStamp;
} CACHEENTRY;

typedef struct _DEFERREDCREATE
{
    D3D8_CREATESURFACEDATA      CreateData;
    struct _DEFERREDCREATE     *pNext;
} DEFERREDCREATE, *PDEFERREDCREATE;

typedef struct _DDDEVICEHANDLE
{
    LPDDRAWI_DIRECTDRAW_INT     pDD;
    LPDDRAWI_DIRECTDRAW_INT     pSwDD;
    DWLIST                      SurfaceHandleList;
    char                        szDeviceName[MAX_DRIVER_NAME];
    BOOL                        bDeviceLost;
    D3DFORMAT                   DisplayFormatWithAlpha;
    D3DFORMAT                   DisplayFormatWithoutAlpha;
    UINT                        DriverLevel;
    struct _DDCONTEXT*          pContext;
    struct _DDSURFACE*          pSurfList;
    struct _DDDEVICEHANDLE*     pLink;
    struct _PALETTEINFO**       pPaletteHandleTable;
    DWORD                       NumPaletteHandleEntries;
    LPDIRECTDRAWPALETTE         pDefaultPalette;
    BOOL                        bCanTextureSysmem;
    DWORD                       PID;
    DWORD                       PCIID;
    DWORD                       DriverVersionHigh;
    DWORD                       DriverVersionLow;
    CACHEENTRY*                 pCachedSurfaceTable;
    int                         NumCachedSurfaces;
    DWORD                       CacheUsageStamp;
    DWORD                       ForceFlagsOn;
    DWORD                       ForceFlagsOff;
    BOOL                        bLightweight;
    VOID*                       pSwInitFunction;
    BOOL                        bDP2Error;
    PDEFERREDCREATE             pDeferList;
    D3DDEVTYPE                  DeviceType;
} DDDEVICEHANDLE, * PDDDEVICEHANDLE;

typedef struct _DDSURFACE
{
    // NOTE: dwCookie must be the first element
    // since we need easy access to it from the 
    // client and the thunk layer itself.
    DWORD                           dwCookie;

    DWORD                           dwFlags;
    union
    {
        LPDDRAWI_DDRAWSURFACE_INT   pHeavy;
        struct _LIGHTWEIGHTSURFACE* pLight;
    } Surface;
    union
    {
        BYTE*                       fpVidMem;
        LPDDRAWI_DDRAWSURFACE_INT   pTempHeavy;
    };
    int                             Pitch;
    D3DPOOL                         Pool;
    D3DFORMAT                       Format;   
    D3DRESOURCETYPE                 Type;
    DWORD                           Height;
    LPVOID                          pBits;
    DWORD                           LockFlags;
    RECT                            LockRect;
    PDDDEVICEHANDLE                 pDevice;
    struct _DDSURFACE*              pNext;
    struct _DDSURFACE*              pPrevious;
    int                             iSlicePitch;
} DDSURFACE, * PDDSURFACE;

#define DDSURFACE_LIGHTWEIGHT               0x00000001
#define DDSURFACE_HEAVYWEIGHT               0x00000002
#define DDSURFACE_ROOT                      0x00000004
#define DDSURFACE_LOCKRECT                  0x00000008
#define DDSURFACE_SOFTWARE                  0x00000010
#define DDSURFACE_HAL                       0x00000020
#define DDSURFACE_DX6HANDLE                 0x00000040
#define DDSURFACE_CREATECOMPLETE            0x00000080
#define DDSURFACE_CREATEEX                  0x00000100
#define DDSURFACE_SYSMEMALLOCATED           0x00000200
#define DDSURFACE_SYSMEMLOCK                0x00000400
#define DDSURFACE_DEFERCREATEEX             0x00000800
#define DDSURFACE_DEFERCREATETEXHANDLE      0x00001000
#define DDSURFACE_DUMMY                     0x00002000
#define DDSURFACE_TREATASVIDMEM             0x00004000      // Flag to indicate that surf should
                                                            // be treated as vid-mem for the
                                                            // "do vid-mem surfaces exist" case


typedef struct _DDCONTEXT
{
    DWORD       Context;

    void*       pDPBuffer; // This is used to cache the pointer allocated at 
                           // context-create time
    // Clear emulation cache
    DWORD       red_mask;
    DWORD       red_scale;
    DWORD       red_shift;
    DWORD       green_mask;
    DWORD       green_scale;
    DWORD       green_shift;
    DWORD       blue_mask;
    DWORD       blue_scale;
    DWORD       blue_shift;
    DWORD       zmask_shift, stencilmask_shift;
    BOOL        bDDSTargetIsPalettized;  // true if 4 or 8 bit rendertarget
    
    DDDEVICEHANDLE*                 pDevice;

    // Used for defered creates
    DWORD       dwFlags;
    DWORD       dwTempContext;
    DWORD       dwPID;
    DWORD       ddrval;
} DDCONTEXT, * PDDCONTEXT;

#define DDCONTEXT_DEFER                     0x00000001
#define DDCONTEXT_DEFEREDTEXTUREHANDLES     0x00000002


typedef struct _LIGHTWEIGHTSURFACE
{
    // Members that go to the Lcl
    DWORD       LclFlags;
    DWORD       LclCaps1;
    ULONG_PTR   LclReserved1;
    DWORD       LclModeCreatedIn;
    DWORD       LclBackBufferCount;

    // Members that go to the Gbl
    DWORD       GblFlags;  
    LONG        GblPitch;    
    DWORD       GblWidth;    
    ULONG_PTR   GblReserved1; 
    D3DFORMAT   GblFormat;
    LPVMEMHEAP  pGblVidMemHeap;
    FLATPTR     fpGblVidMem; 

    // Members that go to the More
    DWORD       MoreCaps2;
    DWORD       MoreCaps3;
    DWORD       MoreCaps4;
    VOID*       MoreRgjunc;

    // Members that go to the GblMore
    ULONG_PTR   GblMoreDriverReserved;               
    DWORD       GblMoreContentsStamp;                
    LPVOID      pGblMoreUnswappedDriverReserved;
    FLATPTR     fpGblMoreAliasOfVidMem;
    DWORD       cGblMorePageUnlocks;

    // Unions to save memory
    union
    {
        FLATPTR         fpGblMorePhysicalVidMem;        // non-local vidmem
        FLATPTR         fpGblMoreAliasedVidMem;         // local vidmem
        DWORD           MoreBytesAllocated;             // sys mem
    };
    union
    {
        DWORD           MoreMipMapCount;                // Mipmaps
        DWORD           MoreFVF;                        // Exe buffers
    };
    UINT                CachedIndex;                    // ORed with INDEX_IN_USE if in use
} LIGHTWEIGHTSURFACE, * PLIGHTWEIGHTSURFACE;

#define INDEX_IN_USE    0x80000000


typedef struct _PALETTEINFO
{
    DDSURFACE*          pSurface;
    LPDIRECTDRAWPALETTE pDDPalette;
    PALETTEENTRY        ColorTable[256];
} PALETTEINFO, * PPALETTEINFO;

#define EXTRA_PALETTE_PADDING               25


#define IS_SOFTWARE_DRIVER(x)                                       \
    (((PDDDEVICEHANDLE)(x))->pSwDD != NULL)

#define IS_SOFTWARE_DRIVER_SURFACE(x)                               \
    (((PDDSURFACE)(x))->dwFlags & DDSURFACE_SOFTWARE)

#define IS_SURFACE_LOOSABLE(x)                                      \
    (!IS_SOFTWARE_DRIVER_SURFACE(x) &&                              \
    ((((PDDSURFACE)(x))->Pool == D3DPOOL_LOCALVIDMEM) ||        \
    (((PDDSURFACE)(x))->Pool == D3DPOOL_NONLOCALVIDMEM) ||      \
    (((PDDSURFACE)(x))->Pool == D3DPOOL_MANAGED)))

#define INDEX_ENTRY(x)                                          \
    ((x) & ~INDEX_IN_USE)

#define GET_CACHED_ENTRY(x)                                     \
    (&((x)->pDevice->pCachedSurfaceTable[INDEX_ENTRY((x)->Surface.pLight->CachedIndex)]))

#define GET_CACHED_LIGHTWEIGHT_INT(x)                           \
    ((x)->pDevice->pCachedSurfaceTable[INDEX_ENTRY((x)->Surface.pLight->CachedIndex)].pSurface)


// Function protoptypes

extern void ConvertToOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT NewFormat);
extern void ConvertFromOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT *pNewFormat);
extern LPDDRAWI_DIRECTDRAW_INT SwDDICreateDirectDraw(void);
extern void SwDDIMungeCaps (HINSTANCE hLibrary, HANDLE hDD, PD3D8_DRIVERCAPS pDriverCaps, PD3D8_CALLBACKS pCallbacks, LPDDSURFACEDESC, UINT*, VOID*);
extern HRESULT SwDDICreateSurface(PD3D8_CREATESURFACEDATA pCreateSurface, DDSURFACEDESC2* pSurfDesc);
extern void SwDDIAttachSurfaces (LPDDRAWI_DDRAWSURFACE_LCL pFrom, LPDDRAWI_DDRAWSURFACE_LCL pTo);
extern void SwDDICreateSurfaceEx (LPDDRAWI_DIRECTDRAW_LCL pDrv, LPDDRAWI_DDRAWSURFACE_LCL pLcl);
extern DWORD SwDDIDestroySurface (HANDLE hDD, PDDSURFACE pSurf, LPDDRAWI_DDRAWSURFACE_LCL pLcl);
extern HRESULT SwDDILock (HANDLE hDD, PDDSURFACE pSurf, PD3D8_LOCKDATA pLockData, LPDDRAWI_DDRAWSURFACE_LCL pLcl);
extern HRESULT SwDDIUnlock( HANDLE hDD, PDDSURFACE pSurf, D3D8_UNLOCKDATA* pUnlockData, LPDDRAWI_DDRAWSURFACE_LCL pLcl );
extern LPDDRAWI_DDRAWSURFACE_INT MapLightweightSurface(DDSURFACE* pSurf);
extern void UnmapLightweightSurface(DDSURFACE* pSurf);
extern HRESULT MapLegacyResult(HRESULT hr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddkmapip.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkmapi.h
 *  Content:	Kernel mode APIs for accessing DirectDraw support.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   31-jan-97	scottm	initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDKMAPI_INCLUDED__
#define __DDKMAPI_INCLUDED__


/*
 * API entry point
 */
DWORD
FAR PASCAL
DxApi(
    DWORD  dwFunctionNum,
    LPVOID lpvInBuffer,
    DWORD  cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD  cbOutBuffer
);

typedef
DWORD
(FAR PASCAL *LPDXAPI)(
    DWORD   dwFunctionNum,
    LPVOID  lpvInBuffer,
    DWORD   cbInBuffer,
    LPVOID  lpvOutBuffer,
    DWORD   cbOutBuffer
);

#define DXAPI_MAJORVERSION		1
#define DXAPI_MINORVERSION              0

#define DD_FIRST_DXAPI					0x500

typedef ULONG (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);

/*
 * Queries the DXAPI version number.
 *
 * Input:  Null
 * Output: LPDDGETVERSIONNUMBER
 */
#define DD_DXAPI_GETVERSIONNUMBER                       (DD_FIRST_DXAPI)

    typedef struct _DDGETVERSIONNUMBER
    {
        DWORD   ddRVal;
        DWORD   dwMajorVersion;
        DWORD   dwMinorVersion;
    } DDGETVERSIONNUMBER, FAR *LPDDGETVERSIONNUMBER;

/*
 * Closes the kernel mode handle.
 *
 * Input:  LPDDCLOSEHANDLE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_CLOSEHANDLE                            (DD_FIRST_DXAPI+1)

    typedef struct _DDCLOSEHANDLE
    {
        HANDLE  hHandle;
    } DDCLOSEHANDLE, FAR *LPDDCLOSEHANDLE;

/*
 * Opens the DirectDraw object and returns a kernel mode handle.
 *
 * Input:  LPDDOPENDIRECTDRAWIN
 * Output: LPDDOPENDIRECTDRAWOUT
 */
#define DD_DXAPI_OPENDIRECTDRAW                         (DD_FIRST_DXAPI+2)

    typedef struct _DDOPENDIRECTDRAWIN
    {
        ULONG_PTR            dwDirectDrawHandle;
        LPDD_NOTIFYCALLBACK pfnDirectDrawClose;
        PVOID               pContext;
    } DDOPENDIRECTDRAWIN, FAR *LPDDOPENDIRECTDRAWIN;

    typedef struct _DDOPENDIRECTDRAWOUT
    {
        DWORD   ddRVal;
        HANDLE  hDirectDraw;
    } DDOPENDIRECTDRAWOUT, FAR *LPDDOPENDIRECTDRAWOUT;

/*
 * Opens the surface and returns a kernel mode handle.
 *
 * Input:  LPDDOPENSURFACEIN
 * Output: LPDDOPENSURFACEOUT
 */
#define DD_DXAPI_OPENSURFACE                            (DD_FIRST_DXAPI+3)

    typedef struct _DDOPENSURFACEIN
    {
	HANDLE	            hDirectDraw;
        ULONG_PTR            dwSurfaceHandle;
        LPDD_NOTIFYCALLBACK pfnSurfaceClose;
        PVOID               pContext;
    } DDOPENSURFACEIN, FAR *LPDDOPENSURFACEIN;

    typedef struct _DDOPENSURFACEOUT
    {
        DWORD   ddRVal;
        HANDLE  hSurface;
    } DDOPENSURFACEOUT, FAR *LPDDOPENSURFACEOUT;

/*
 * Opens the VideoPort and returns a kernel mode handle.
 *
 * Input:  LPDDOPENVIDEOPORTIN
 * Output: LPDDOPENVIDEOPORTOUT
 */
#define DD_DXAPI_OPENVIDEOPORT                          (DD_FIRST_DXAPI+4)

    typedef struct _DDOPENVIDEOPORTIN
    {
	HANDLE		    hDirectDraw;
        ULONG               dwVideoPortHandle;
        LPDD_NOTIFYCALLBACK pfnVideoPortClose;
        PVOID               pContext;
    } DDOPENVIDEOPORTIN, FAR *LPDDOPENVIDEOPORTIN;

    typedef struct _DDOPENVIDEOPORTOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoPort;
    } DDOPENVIDEOPORTOUT, FAR *LPDDOPENVIDEOPORTOUT;

/*
 * Returns the kernel mode capabilities supported by the device
 *
 * Input:  HANDLE hDirectDraw
 * Output: LPDDGETKERNELCAPSOUT
 */
#define DD_DXAPI_GETKERNELCAPS                          (DD_FIRST_DXAPI+5)

    typedef struct _DDGETKERNELCAPSOUT
    {
	DWORD	ddRVal;
        DWORD	dwCaps;
	DWORD	dwIRQCaps;
    } DDGETKERNELCAPSOUT, FAR *LPDDGETKERNELCAPSOUT;

/*
 * Gets the current field number
 *
 * Input:  LPDDGETFIELDNUMIN
 * Output: LPDDGETFIELDNUMOUT
 */
#define DD_DXAPI_GET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+6)

    typedef struct _DDGETFIELDNUMIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETFIELDNUMIN, FAR *LPDDGETFIELDNUMIN;

    typedef struct _DDGETFIELDNUMOUT
    {
	DWORD	ddRVal;
	DWORD	dwFieldNum;
    } DDGETFIELDNUMOUT, FAR *LPDDGETFIELDNUMOUT;

/*
 * Sets the current field number
 *
 * Input:  LPDDSETFIELDNUM
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+7)

    typedef struct _DDSETFIELDNUM
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwFieldNum;
    } DDSETFIELDNUM, FAR *LPDDSETFIELDNUM;

/*
 * Indicates which fields should be skipped to undo the 3:2 pulldown.
 *
 * Input:  LPDDSETSKIPFIELD
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_SKIP_FIELD			(DD_FIRST_DXAPI+8)

    typedef struct _DDSETSKIPFIELD
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwStartField;
    } DDSETSKIPFIELD, FAR *LPDDSETSKIPFIELD;

/*
 * Notifies whether the surface is in bob or weave mode.
 *
 * Input:  LPDDGETSURFACESTATEIN
 * Output: LPDDGETSURFACESTATEOUT
 */
#define DD_DXAPI_GET_SURFACE_STATE			(DD_FIRST_DXAPI+9)

    typedef struct _DDGETSURFACESTATEIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDGETSURFACESTATEIN, FAR *LPDDGETSURFACESTATEIN;

    typedef struct _DDGETSURFACESTATEOUT
    {
	DWORD	ddRVal;
	DWORD	dwStateCaps;
	DWORD	dwStateStatus;
    } DDGETSURFACESTATEOUT, FAR *LPDDGETSURFACESTATEOUT;

/*
 * Changes the surface between bob and weave mode.
 *
 * Input:  LPDDSETSURFACESTATE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_SURFACE_STATE			(DD_FIRST_DXAPI+10)

    typedef struct _DDSETSURFACETATE
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
	DWORD	dwState;
	DWORD	dwStartField;
    } DDSETSURFACESTATE, FAR *LPDDSETSURFACESTATE;

/*
 * Allows direct access to the surface memory
 *
 * Input:  LPDDLOCKIN
 * Output: LPDDLOCKOUT
 */
#define DD_DXAPI_LOCK					(DD_FIRST_DXAPI+11)

    typedef struct _DDLOCKIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDLOCKIN, FAR *LPDDLOCKIN;

    typedef struct _DDLOCKOUT
    {
	DWORD	ddRVal;
	DWORD	dwSurfHeight;
	DWORD	dwSurfWidth;
	LONG	lSurfPitch;
	PVOID	lpSurface;
	DWORD	SurfaceCaps;
	DWORD	dwFormatFlags;
	DWORD	dwFormatFourCC;
	DWORD	dwFormatBitCount;
	union
	{
	    DWORD	dwRBitMask;
	    DWORD	dwYBitMask;
    	};
    	union
    	{
	    DWORD	dwGBitMask;
	    DWORD	dwUBitMask;
	};
	union
	{
	    DWORD	dwBBitMask;
	    DWORD	dwVBitMask;
	};
    } DDLOCKOUT, FAR *LPDDLOCKOUT;

/*
 * Flips the overlay surface
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_OVERLAY				(DD_FIRST_DXAPI+12)

    typedef struct _DDFLIPOVERLAY
    {
	HANDLE	hDirectDraw;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPOVERLAY, FAR *LPDDFLIPOVERLAY;

/*
 * Flips the video port
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_VP				(DD_FIRST_DXAPI+13)

    typedef struct _DDFLIPVIDEOPORT
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPVIDEOPORT, FAR *LPDDFLIPVIDEOPORT;

/*
 * Returns the current surface receiving the data while autoflipping
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_CURRENT_VP_AUTOFLIP_SURFACE	(DD_FIRST_DXAPI+14)

    typedef struct _DDGETAUTOFLIPIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETAUTOFLIPIN, FAR *LPDDGETAUTOFLIPIN;

    typedef struct _DDGETAUTOFLIPOUT
    {
	DWORD	ddRVal;
	HANDLE	hVideoSurface;
	HANDLE	hVBISurface;
	BOOL	bPolarity;
    } DDGETAUTOFLIPOUT, FAR *LPDDGETAUTOFLIPOUT;

/*
 * Returns the surface that received the previous field of data (could
 * be the same as current if video is interleaved)
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_LAST_VP_AUTOFLIP_SURFACE		(DD_FIRST_DXAPI+15)

/*
 * Registers a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_REGISTER_CALLBACK			(DD_FIRST_DXAPI+16)

    typedef struct _DDREGISTERCALLBACK
    {
	HANDLE 	            hDirectDraw;
	ULONG	            dwEvents;
	LPDD_NOTIFYCALLBACK pfnCallback;
	ULONG_PTR            dwParam1;
	ULONG_PTR            dwParam2;
	PVOID	            pContext;
    } DDREGISTERCALLBACK, FAR *LPDDREGISTERCALLBACK;

/*
 * Unregisters a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_UNREGISTER_CALLBACK			(DD_FIRST_DXAPI+17)

/*
 * Returns the polarity (odd/even) of the current field
 *
 * Input:  LPDDGETPOLARITYIN
 * Output: LPDDGETPOLARITYOUT
 */
#define DD_DXAPI_GET_POLARITY				(DD_FIRST_DXAPI+18)

    typedef struct _DDGETPOLARITYIN
    {
	HANDLE 	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETPOLARITYIN, FAR *LPDDGETPOLARITYIN;

    typedef struct _DDGETPOLARITYOUT
    {
	DWORD 	ddRVal;
	BOOL	bPolarity;
    } DDGETPOLARITYOUT, FAR *LPDDGETPOLARITYOUT;

/*
 * Opens the device for capture
 *
 * Input:  LPDDOPENCAPTUREDEVICEIN
 * Output: LPDDOPENCAPTUREDEVICEOUT
 */
#define DD_DXAPI_OPENVPCAPTUREDEVICE			(DD_FIRST_DXAPI+19)

    typedef struct _DDOPENVPCAPTUREDEVICEIN
    {
	HANDLE  hDirectDraw;
	HANDLE  hVideoPort;
	DWORD   dwStartLine;
	DWORD   dwEndLine;
	DWORD   dwCaptureEveryNFields;
	LPDD_NOTIFYCALLBACK pfnCaptureClose;
	PVOID   pContext;
	DWORD	dwFlags;
    } DDOPENVPCAPTUREDEVICEIN, FAR * LPDDOPENVPCAPTUREDEVICEIN;

    typedef struct _DDOPENVPCAPTUREDEVICEOUT
    {
	DWORD	ddRVal;
	HANDLE	hCapture;
    } DDOPENVPCAPTUREDEVICEOUT, FAR * LPDDOPENVPCAPTUREDEVICEOUT;

    #define DDOPENCAPTURE_VIDEO	0x0001	// Capture from the video stream
    #define DDOPENCAPTURE_VBI	0x0002	// Capture from the VBI stream

/*
 * Adds a capture buffer to the internal video port capture queue
 *
 * Input:  LPDDADDVPCAPTUREBUFF
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_ADDVPCAPTUREBUFFER			(DD_FIRST_DXAPI+20)

    typedef struct _DDCAPBUFFINFO
    {
	DWORD   	dwFieldNumber;
	DWORD   	bPolarity;
	LARGE_INTEGER	liTimeStamp;
	DWORD   	ddRVal;
    } DDCAPBUFFINFO, FAR * LPDDCAPBUFFINFO;

    typedef struct _DDADDVPCAPTUREBUFF
    {
	HANDLE  hCapture;
	DWORD   dwFlags;
	PMDL    pMDL;
	PKEVENT pKEvent;
	LPDDCAPBUFFINFO lpBuffInfo;
    } DDADDVPCAPTUREBUFF, FAR * LPDDADDVPCAPTUREBUFF;

    #define DDADDBUFF_SYSTEMMEMORY	0x0001	// lpBuffer points to sys mem
    #define DDADDBUFF_NONLOCALVIDMEM	0x0002	// lpBuffer points to AGP mem
    #define DDADDBUFF_INVERT		0x0004	// invert the buffer during capture

/*
 * Flushes the internal video port capture queue
 *
 * Input:  HANDLE to capture device
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLUSHVPCAPTUREBUFFERS			(DD_FIRST_DXAPI+21)


//@@BEGIN_MSINTERNAL
//#ifdef WIN95

    /*
     * These IOCTLS are private and should not be used by clients.
     * They are to allow DirectDraw to sync the state/data between
     * the two drivers
     */
    #define DDHANDLEADJUST	8

    /*
     * Input:  LPDDINITDEVICEIN
     * Output: LPDDINITDEVICEOUT
     */
    #define DD_DXAPI_INIT_DEVICE			(DD_FIRST_DXAPI+22)

    	typedef struct _DDINITDEVICEIN
    	{
	    DWORD		dwDeviceFlags;
	    DWORD		dwMaxVideoPorts;
	    DDMINIVDDTABLE	MiniVDDTable;
    	} DDINITDEVICEIN, FAR *LPDDINITDEVICEIN;

    	typedef struct _DDINITDEVICEOUT
    	{
	    DWORD		ddRVal;
	    DWORD		dwDirectDrawHandle;
	    ULONG_PTR		pfnNotifyProc;
	    DWORD		bHaveIRQ;
    	} DDINITDEVICEOUT, FAR *LPDDINITDEVICEOUT;

    /*
     * Input:  DWORD dwDirectDrawHandle
     * Output: none
     */
    #define DD_DXAPI_RELEASE_DEVICE			(DD_FIRST_DXAPI+23)

    /*
     * Input:  LPDDKMSURFACEINFO
     * Output: LPDDGETSURFACEHANDLE
     */
    #define DD_DXAPI_GET_SURFACE_HANDLE			(DD_FIRST_DXAPI+24)

    	typedef struct _DDKMSURFACEINFO
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	ddsCaps;		// Ring 3 creation caps
	    DWORD	dwSurfaceOffset;	// Offset in frame buffer of surface
	    ULONG_PTR	fpLockPtr;		// Surface lock ptr
	    DWORD	dwWidth;		// Surface width
	    DWORD	dwHeight;		// Surface height
	    LONG	lPitch;			// Surface pitch
	    DWORD	dwOverlayFlags;		// DDOVER_XX flags
	    DWORD	dwOverlayOffset;	// Offset in frame buffer of overlay
	    DWORD	dwOverlaySrcWidth;	// Src width of overlay
	    DWORD	dwOverlaySrcHeight;	// Src height of overlay
	    DWORD	dwOverlayDestWidth;	// Dest width of overlay
	    DWORD	dwOverlayDestHeight;	// Dest height of overlay
	    DWORD	dwVideoPortId; 		// ID of video port (-1 if not connected to a video port)
	    DWORD	dwPhysicalPageTable;
	    ULONG_PTR	pPageTable;
	    DWORD	cPages;
	    DWORD	dwFormatFlags;
	    DWORD	dwFormatFourCC;
	    DWORD	dwFormatBitCount;
	    DWORD	dwRBitMask;
	    DWORD	dwGBitMask;
	    DWORD	dwBBitMask;
	    ULONG_PTR	dwDriverReserved1;	// Reserved for the HAL/Mini VDD
	    ULONG_PTR	dwDriverReserved2;	// Reserved for the HAL/Mini VDD
	    ULONG_PTR	dwDriverReserved3;	// Reserved for the HAL/Mini VDD
    	} DDKMSURFACEINFO, FAR *LPDDKMSURFACEINFO;

    	typedef struct _DDGETSURFACEHANDLE
    	{
	    DWORD	ddRVal;			// Return code
	    DWORD	hSurface;		// New surface handle
    	} DDGETSURFACEHANDLE, FAR *LPDDGETSURFACEHANDLE;

    /*
     * Input:  LPDDRELEASEHANDLE
     * Output: DWORD DirectDraw return value
     */
    #define DD_DXAPI_RELEASE_SURFACE_HANDLE		(DD_FIRST_DXAPI+25)

    	typedef struct _DDRELEASEHANDLE
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	hSurface;		// Surface handle to release
    	} DDRELEASEHANDLE, FAR *LPDDRELEASEHANDLE;

    /*
     * Input:  LPDDKMSURFACEUPDATE
     * Output: DWORD DirectDraw return value
     */
    #define DD_DXAPI_UPDATE_SURFACE_INFO		(DD_FIRST_DXAPI+26)

    	typedef struct _DDKMSURFACEUPDATE
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	dwSurfaceHandle;	// Handle of surface to update
	    DDKMSURFACEINFO	si;	// New surface info
    	} DDKMSURFACEUPDATE, FAR *LPDDKMSURFACEUPDATE;

    /*
     * Input:  LPDDKMVIDEOPORTINFO
     * Output: DWORD DirectDraw return value
     */
    #define DD_DXAPI_UPDATE_VP_INFO			(DD_FIRST_DXAPI+27)

    	#define MAX_AUTOFLIP	10

    	typedef struct _DDKMVIDEOPORTINFO
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	dwVideoPortId;		// ID of video port (0 - MaxVideoPorts-1)
	    DWORD	dwVPFlags;		// Offset in frame buffer of surface
	    DWORD	dwFlags;		// Flags used internally
	    DWORD	dwOriginOffset;		// Start address relative to surface
	    DWORD	dwHeight;		// Height of total video region (per field)
	    DWORD	dwVBIHeight;		// Height of VBI region (per field)
	    DWORD	dwNumAutoflipping;	// Number of surfaces being autoflipped
	    DWORD	dwNumVBIAutoflipping;	// Number of VBI surfaces being autoflipped
	    DWORD	dwSurfaceHandle[MAX_AUTOFLIP];	// Surface receiving the data (up to 10 autoflipping)
	    DWORD	dwVBISurfaceHandle[MAX_AUTOFLIP]; // Surface receiving VBI data (up to 10 autoflipping)
	    ULONG_PTR	dwDriverReserved1;	// Reserved for the HAL/Mini VDD
	    ULONG_PTR	dwDriverReserved2;	// Reserved for the HAL/Mini VDD
	    ULONG_PTR	dwDriverReserved3;	// Reserved for the HAL/Mini VDD
    	} DDKMVIDEOPORTINFO, FAR *LPDDKMVIDEOPORTINFO;

    /*
     * Same as DD_DXAPI_GET_SURFACE_STATE, but it doesn't require that
     * you open the surace first.
     *
     * Input:  LPDDGETSURFACESTATEIN
     * Output: LPDDGETSURFACESTATEOUT
     */
    #define DD_DXAPI_PRIVATE_GET_SURFACE_STATE	       (DD_FIRST_DXAPI+28)

    /*
     * Input:  LPDDSETDOSBOXEVENT
     * Output: DWORD DirectDraw return value
     */
    #define DD_DXAPI_SET_DOS_BOX_EVENT		       (DD_FIRST_DXAPI+29)

    	typedef struct _DDSETDOSBOXEVENT
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	dwDOSBoxEvent;
    	} DDSETDOSBOXEVENT, FAR *LPDDSETDOSBOXEVENT;

    /*
     * Input:  LPDDSETKERNELCAPS
     * Output: DWORD DirectDraw return value
     */
    #define DD_DXAPI_SET_KERNEL_CAPS		       (DD_FIRST_DXAPI+30)

    	typedef struct _DDSETKERNELCAPS
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	dwCaps;
	    DWORD	dwIRQCaps;
    	} DDSETKERNELCAPS, FAR *LPDDSETKERNELCAPS;

    /*
     * Input:  LPDDSETKERNELCAPS
     * Output: DWORD DirectDraw return value
     */
    #define DD_DXAPI_ENABLE_AUTOFLIP		       (DD_FIRST_DXAPI+31)

    	typedef struct _DDENABLEAUTOLFIP
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	dwVideoPortId;		// ID of video port (0 - MaxVideoPorts-1)
	    BOOL	bEnableAutoflip;
    	} DDENABLEAUTOFLIP, FAR *LPDDENABLEAUTOFLIP;

    #define DD_LAST_DXAPI	DD_DXAPI_ENABLE_AUTOFLIP

//#endif

//@@END_MSINTERNAL
/*
 * State flags returned by DSVXD_DXAPI_DD_GET_SURFACE_STATE
 */
#define DDSTATE_BOB				0x0001
#define DDSTATE_WEAVE				0x0002
#define DDSTATE_EXPLICITLY_SET			0x0004
#define DDSTATE_SOFTWARE_AUTOFLIP		0x0008
#define DDSTATE_SKIPEVENFIELDS			0x0010

/*
 * Event flags - passed into RegisterCallback
 */
#define DDEVENT_DISPLAY_VSYNC			0x0001
#define DDEVENT_VP_VSYNC			0x0002
#define DDEVENT_VP_LINE				0x0004
#define DDEVENT_PRERESCHANGE			0x0008
#define DDEVENT_POSTRESCHANGE			0x0010
#define DDEVENT_PREDOSBOX			0x0020
#define DDEVENT_POSTDOSBOX			0x0040

/*
 * Notification flags - passed to the notification proc
 */
#define DDNOTIFY_DISPLAY_VSYNC			0x0001	// dwParam1 = hDirectDraw
#define DDNOTIFY_VP_VSYNC			0x0002	// dwParam1 = hVideoPort
#define DDNOTIFY_VP_LINE	  		0x0004	// dwParam1 = hVideoPort
#define DDNOTIFY_PRERESCHANGE			0x0008	// dwParam1 = hDirectDraw
#define DDNOTIFY_POSTRESCHANGE			0x0010	// dwParam1 = hDirectDraw
#define DDNOTIFY_PREDOSBOX			0x0020  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTDOSBOX			0x0040  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSEDIRECTDRAW		0x0080  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSESURFACE			0x0100  // dwParam1 = hSurface
#define DDNOTIFY_CLOSEVIDEOPORT			0x0200  // dwParam1 = hVideoPort
#define DDNOTIFY_CLOSECAPTURE			0x0400  // dwParam1 = hCapture

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddkernel.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkernel.h
 *  Content:	APIs for accessing kernel mode support.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   09-jan-97	scottm	initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDKM_INCLUDED__
#define __DDKM_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by to get kernel interfaces
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDirectDrawKernel,             0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawSurfaceKernel,      0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );

#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke the kernel API functions.
 *
 *==========================================================================*/

typedef struct IDirectDrawKernel		FAR *LPDIRECTDRAWKERNEL;
typedef struct IDirectDrawSurfaceKernel		FAR *LPDIRECTDRAWSURFACEKERNEL;
typedef struct _DDKERNELCAPS			FAR *LPDDKERNELCAPS;


/*
 * INTERACES FOLLOW:
 *	IDirectDrawKernel
 *	IVideoPort
 */

/*
 * IDirectDrawKernel
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawKernel
DECLARE_INTERFACE_( IDirectDrawKernel, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDDKERNELCAPS) PURE;
    STDMETHOD(GetKernelHandle)(THIS_ PULONG_PTR) PURE;
    STDMETHOD(ReleaseKernelHandle)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawKernel_GetCaps(p, a)             (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawKernel_GetKernelHandle(p, a)     (p)->lpVtbl->GetKernelHandle(p, a)
#define IDirectDrawKernel_ReleaseKernelHandle(p)    (p)->lpVtbl->ReleaseKernelHandle(p)
#endif

#endif

/*
 * IDirectDrawSurfaceKernel
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawSurfaceKernel
DECLARE_INTERFACE_( IDirectDrawSurfaceKernel, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(GetKernelHandle)(THIS_ PULONG_PTR) PURE;
    STDMETHOD(ReleaseKernelHandle)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurfaceKernel_GetKernelHandle(p, a)     (p)->lpVtbl->GetKernelHandle(p, a)
#define IDirectDrawSurfaceKernel_ReleaseKernelHandle(p)    (p)->lpVtbl->ReleaseKernelHandle(p)
#endif

#endif


/*
 * DDKERNELCAPS
 */
typedef struct _DDKERNELCAPS
{
    DWORD dwSize;			// size of the DDKERNELCAPS structure
    DWORD dwCaps;                       // Contains the DDKERNELCAPS_XXX flags
    DWORD dwIRQCaps;                    // Contains the DDIRQ_XXX flags
} DDKERNELCAPS, FAR *LPDDKERNELCAPS;



/****************************************************************************
 *
 * DDKERNELCAPS CAPS
 *
 ****************************************************************************/

/*
 * Indicates that the device supports field skipping.
 */
#define DDKERNELCAPS_SKIPFIELDS			0x00000001l

/*
 * Indicates that the device can support software autoflipping.
 */
#define DDKERNELCAPS_AUTOFLIP			0x00000002l

/*
 * Indicates that the device can switch between bob and weave.
 */
#define DDKERNELCAPS_SETSTATE			0x00000004l

/*
 * Indicates that a client can gain direct access to the frame buffer.
 */
#define DDKERNELCAPS_LOCK			0x00000008l

/*
 * Indicates that a client can manually flip the video port.
 */
#define DDKERNELCAPS_FLIPVIDEOPORT		0x00000010l

/*
 * Indicates that a client can manually flip the overlay.
 */
#define DDKERNELCAPS_FLIPOVERLAY		0x00000020l

/*
 * Indicates that the device supports a video port capture interface
 * capable of transfering data to system memory.
 */
#define DDKERNELCAPS_CAPTURE_SYSMEM		0x00000040l

/*
 * Indicates that the device supports a video port capture interface
 * capable of transfering data to non-local video memory.
 */
#define DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM	0x00000080l

/*
 * Indicates that the device can report the polarity (even/odd) of
 * the curent video field.
 */
#define DDKERNELCAPS_FIELDPOLARITY		0x00000100l

/*
 * Indicates that the device supports inverting the DIBs while capturing
 * the data.
 */
#define DDKERNELCAPS_CAPTURE_INVERTED		0x00000200l

/****************************************************************************
 *
 * DDKERNELCAPS IRQ CAPS
 *
 ****************************************************************************/

/*
 * The device can generate display VSYNC IRQs
 */
#define DDIRQ_DISPLAY_VSYNC			0x00000001l

/*
 * Reserved
 */
#define DDIRQ_RESERVED1				0x00000002l

/*
 * The device can generate video ports VSYNC IRQs using video port 0
 */
#define DDIRQ_VPORT0_VSYNC			0x00000004l

/*
 * The device can generate video ports line IRQs using video port 0
 */
#define DDIRQ_VPORT0_LINE			0x00000008l

/*
 * The device can generate video ports VSYNC IRQs using video port 1
 */
#define DDIRQ_VPORT1_VSYNC			0x00000010l

/*
 * The device can generate video ports line IRQs using video port 1
 */
#define DDIRQ_VPORT1_LINE			0x00000020l

/*
 * The device can generate video ports VSYNC IRQs using video port 2
 */
#define DDIRQ_VPORT2_VSYNC			0x00000040l

/*
 * The device can generate video ports line IRQs using video port 2
 */
#define DDIRQ_VPORT2_LINE			0x00000080l

/*
 * The device can generate video ports VSYNC IRQs using video port 3
 */
#define DDIRQ_VPORT3_VSYNC			0x00000100l

/*
 * The device can generate video ports line IRQs using video port 3
 */
#define DDIRQ_VPORT3_LINE			0x00000200l

/*
 * The device can generate video ports VSYNC IRQs using video port 4
 */
#define DDIRQ_VPORT4_VSYNC			0x00000400l

/*
 * The device can generate video ports line IRQs using video port 4
 */
#define DDIRQ_VPORT4_LINE			0x00000800l

/*
 * The device can generate video ports VSYNC IRQs using video port 5
 */
#define DDIRQ_VPORT5_VSYNC			0x00001000l

/*
 * The device can generate video ports line IRQs using video port 5
 */
#define DDIRQ_VPORT5_LINE			0x00002000l

/*
 * The device can generate video ports VSYNC IRQs using video port 6
 */
#define DDIRQ_VPORT6_VSYNC			0x00004000l

/*
 * The device can generate video ports line IRQs using video port 6
 */
#define DDIRQ_VPORT6_LINE			0x00008000l

/*
 * The device can generate video ports VSYNC IRQs using video port 7
 */
#define DDIRQ_VPORT7_VSYNC			0x00010000l

/*
 * The device can generate video ports line IRQs using video port 7
 */
#define DDIRQ_VPORT7_LINE			0x00020000l

/*
 * The device can generate video ports VSYNC IRQs using video port 8
 */
#define DDIRQ_VPORT8_VSYNC			0x00040000l

/*
 * The device can generate video ports line IRQs using video port 8
 */
#define DDIRQ_VPORT8_LINE			0x00080000l

/*
 * The device can generate video ports VSYNC IRQs using video port 9
 */
#define DDIRQ_VPORT9_VSYNC			0x00010000l

/*
 * The device can generate video ports line IRQs using video port 9
 */
#define DDIRQ_VPORT9_LINE			0x00020000l



#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddmcp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddmc.h
 *  Content:	DirectDrawMotionComp include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-sep-97	smac
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDVA_INCLUDED__
#define __DDVA_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoAccelerator objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDDVideoAcceleratorContainer,	0xACA12120,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
DEFINE_GUID( IID_IDirectDrawVideoAccelerator,   0xC9B2D740,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoAcceleratorContainer		FAR *LPDDVIDEOACCELERATORCONTAINER;
typedef struct IDirectDrawVideoAccelerator		FAR *LPDIRECTDRAWVIDEOACCELERATOR;

typedef struct IDDVideoAcceleratorContainerVtbl DDVIDEOACCELERATORCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoAcceleratorVtbl  DIRECTDRAWVIDEOACCELERATORCALLBACKS;


typedef struct _tag_DDVAUncompDataInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwUncompWidth;              // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;             // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;        // [in]     pixel-format of uncompressed data
} DDVAUncompDataInfo, *LPDDVAUncompDataInfo;

typedef struct _tag_DDVAInternalMemInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwScratchMemAlloc;          // [out]    amount of scratch memory will the hal allocate for its private use
} DDVAInternalMemInfo, *LPDDVAInternalMemInfo;


typedef struct _tag_DDVACompBufferInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwNumCompBuffers;           // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;            // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;           // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;          // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;                 // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;              // [out]    fourcc to create surfaces to store compressed data
} DDVACompBufferInfo, *LPDDVACompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVABeginFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    LPDIRECTDRAWSURFACE7    pddDestSurface;             // [in]     destination buffer in which to decoding this frame
    DWORD                   dwSizeInputData;            // [in]     size of other misc data to begin frame
    LPVOID                  pInputData;                 // [in]     pointer to misc data
    DWORD                   dwSizeOutputData;           // [in/out] size of other misc data to begin frame
    LPVOID                  pOutputData;                // [out]    pointer to misc data
} DDVABeginFrameInfo, *LPDDVABeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVAEndFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwSizeMiscData;             // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;                  // [in]     pointer to misc data
} DDVAEndFrameInfo, *LPDDVAEndFrameInfo;

typedef struct _tag_DDVABUFFERINFO
{
    DWORD                   dwSize;                     // [in]    size of the struct
    LPDIRECTDRAWSURFACE7    pddCompSurface;             // [in]    pointer to buffer containing compressed data
    DWORD                   dwDataOffset;               // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;                 // [in]    size of relevant data
} DDVABUFFERINFO, *LPDDVABUFFERINFO;


/*
 * INTERACES FOLLOW:
 *	IDDVideoAcceleratorContainer
 *	IDirectDrawVideoAccelerator
 */

/*
 * IDDVideoAcceleratorContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoAcceleratorContainer
DECLARE_INTERFACE_( IDDVideoAcceleratorContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDDVideoAcceleratorContainer methods ***/
    STDMETHOD(CreateVideoAccelerator)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPVOID, DWORD, LPDIRECTDRAWVIDEOACCELERATOR FAR *, IUnknown FAR *) PURE;
    STDMETHOD(GetCompBufferInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDWORD, LPDDVACompBufferInfo ) PURE;
    STDMETHOD(GetInternalMemInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDDVAInternalMemInfo ) PURE;
    STDMETHOD(GetVideoAcceleratorGUIDs)(THIS_ LPDWORD, LPGUID ) PURE;
    STDMETHOD(GetUncompFormatsSupported)(THIS_ LPGUID, LPDWORD, LPDDPIXELFORMAT ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IVideoAcceleratorContainer_Release(p)                         (p)->lpVtbl->Release(p)
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p,a,b,c,d,e,f)    (p)->lpVtbl->CreateVideoAccelerator(p, a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(p, a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(p, a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->lpVtbl->GetVideoAcceleratorGUIDs(p, a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->lpVtbl->GetUncompFormatsSupported(p, a, b, c)
#else
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->QueryInterface(a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->AddRef()
#define IVideoAcceleratorContainer_Release(p)                         (p)->Release()
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p, a, b, c,d,e,f) (p)->CreateVideoAccelerator(a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->GetCompBufferInfo(a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->GetInternalMemInfo(a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->GetVideoAcceleratorGUIDs(a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(a, b, c)
#endif

#endif


/*
 * IDirectDrawVideoAccelerator
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoAccelerator
DECLARE_INTERFACE_( IDirectDrawVideoAccelerator, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirecytDrawVideoAccelerator methods ***/
    STDMETHOD(BeginFrame)(THIS_ LPDDVABeginFrameInfo) PURE;
    STDMETHOD(EndFrame)(THIS_ LPDDVAEndFrameInfo) PURE;
    STDMETHOD(QueryRenderStatus)(THIS_ LPDIRECTDRAWSURFACE7, DWORD)PURE;
    STDMETHOD(Execute)(THIS_ 
                       DWORD,            // Function
                       LPVOID,           // Input data
                       DWORD,            // Input data length
                       LPVOID,           // Output data
                       DWORD,            // Output data length
                       DWORD,            // Number of buffers
                       LPDDVABUFFERINFO  // Buffer info array
                       ) PURE;
};

//  Flags for QueryRenderStatus
#define DDVA_QUERYRENDERSTATUSF_READ     0x00000001  // Query for read
                                                     // set this bit to 0 
                                                     // if query for update

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoAccelerator_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoAccelerator_BeginFrame(p,a)            (p)->lpVtbl->BeginFrame(p,a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->lpVtbl->EndFrame(p,a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->lpVtbl->QueryRenderStatus(p,a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->lpVtbl->RenderMacroBlocks(p,a,b)
#else
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->AddRef()
#define IVideoAccelerator_Release(p)                 (p)->Release()
#define IVideoAccelerator_BeginFrame(p,a)            (p)->BeginFrame(a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->EndFrame(a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->QueryRenderStatus(a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->RenderMacroBlocks(a,b)
#endif

#endif


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddkmmini.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkmmini.h
 *  Content:	Mini VDD support for DirectDraw
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   31-jan-97	scottm	initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDKMMINI_INCLUDED__
#define __DDKMMINI_INCLUDED__


/*============================================================================
 *
 * DDHAL table filled in by the Mini VDD and called by DirectDraw
 *
 *==========================================================================*/

typedef DWORD (* MINIPROC)(VOID);

typedef struct _DDMINIVDDTABLE {
    DWORD	dwMiniVDDContext;
    MINIPROC	vddGetIRQInfo;
    MINIPROC	vddIsOurIRQ;
    MINIPROC	vddEnableIRQ;
    MINIPROC	vddSkipNextField;
    MINIPROC	vddBobNextField;
    MINIPROC	vddSetState;
    MINIPROC	vddLock;
    MINIPROC	vddFlipOverlay;
    MINIPROC	vddFlipVideoPort;
    MINIPROC	vddGetPolarity;
    MINIPROC	vddReserved1;
    MINIPROC	vddGetCurrentAutoflip;
    MINIPROC	vddGetPreviousAutoflip;
    MINIPROC	vddTransfer;
    MINIPROC	vddGetTransferStatus;
} DDMINIVDDTABLE;
typedef DDMINIVDDTABLE *LPDDMINIVDDTABLE;


/*============================================================================
 *
 * MDL structure for handling pagelocked memory.  This is copied from WDM.H
 *
 *==========================================================================*/

typedef struct _MDL {
    struct _MDL *MdlNext;
    short MdlSize;
    short MdlFlags;
    struct _EPROCESS *Process;
    ULONG *lpMappedSystemVa;
    ULONG *lpStartVa;
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL;
typedef MDL *PMDL;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_LOCK_HELD               0x0200
#define MDL_SCATTER_GATHER_VA       0x0400
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000
#define MDL_64_BIT_VA               0x8000

#define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_LOCK_HELD               | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )

typedef DWORD *PKEVENT;

/*============================================================================
 *
 * Structures maintained by DirectDraw
 *
 *==========================================================================*/

//
// Data for every kernel mode surface
//
typedef struct _DDSURFACEDATA {
    DWORD	dwSize;			// Structure size
    DWORD	ddsCaps;		// Ring 3 creation caps
    DWORD	dwSurfaceOffset;	// Offset in frame buffer of surface
    DWORD	fpLockPtr;		// Surface lock ptr
    DWORD	dwWidth;		// Surface width
    DWORD	dwHeight;		// Surface height
    LONG	lPitch;			// Surface pitch
    DWORD	dwOverlayFlags;		// DDOVER_XX flags
    DWORD	dwOverlayOffset;	// Offset in frame buffer of overlay
    DWORD	dwOverlaySrcWidth;	// Src width of overlay
    DWORD	dwOverlaySrcHeight;	// Src height of overlay
    DWORD	dwOverlayDestWidth;	// Dest width of overlay
    DWORD	dwOverlayDestHeight;	// Dest height of overlay
    DWORD	dwVideoPortId; 		// ID of video port (-1 if not connected to a video port)
    ULONG	pInternal1;		// Private
    ULONG	pInternal2;		// Private
    ULONG	pInternal3;		// Private
    DWORD	dwFormatFlags;
    DWORD	dwFormatFourCC;
    DWORD	dwFormatBitCount;
    DWORD	dwRBitMask;
    DWORD	dwGBitMask;
    DWORD	dwBBitMask;
    DWORD	dwSurfInternalFlags;	// Private internal flags
    DWORD	dwIndex;		// Private
    DWORD	dwRefCnt;		// Private
    DWORD	dwDriverReserved1;	// Reserved for the HAL/Mini VDD
    DWORD	dwDriverReserved2;	// Reserved for the HAL/Mini VDD
    DWORD	dwDriverReserved3;	// Reserved for the HAL/Mini VDD
} DDSURFACEDATA;
typedef DDSURFACEDATA * LPDDSURFACEDATA;

//
// Data for every kernel mode video port
//
typedef struct DDVIDEOPORTDATA {
    DWORD	dwSize;			// Structure size
    DWORD	dwVideoPortId;		// ID of video port (0 - MaxVideoPorts-1)
    DWORD	dwVPFlags;		// Offset in frame buffer of surface
    DWORD	dwOriginOffset;		// Start address relative to surface
    DWORD	dwHeight;		// Height of total video region (per field)
    DWORD	dwVBIHeight;		// Height of VBI region (per field)
    DWORD	dwDriverReserved1;	// Reserved for the HAL/Mini VDD
    DWORD	dwDriverReserved2;	// Reserved for the HAL/Mini VDD
    DWORD	dwDriverReserved3;	// Reserved for the HAL/Mini VDD
} DDVIDEOPORTDATA;
typedef DDVIDEOPORTDATA *LPDDVIDEOPORTDATA;


/*============================================================================
 *
 * Structures used to communicate with the Mini VDD
 *
 *==========================================================================*/

// Output from vddGetIRQInfo
typedef struct _DDGETIRQINFO {
    DWORD	dwSize;
    DWORD	dwFlags;
    DWORD	dwIRQNum;
} DDGETIRQINFO;
#define IRQINFO_HANDLED                 0x01    // Mini VDD is managing IRQ
#define IRQINFO_NOTHANDLED              0x02    // Mini VDD wants VDD to manage the IRQ
#define IRQINFO_NODISABLEFORDOSBOX      0x04    // DDraw should  not tell mini VDD to disable IRQs when DOS boxes
                                                //  occur because they might still be able to operate in this mode

// Input to vddEnableIRQ
typedef struct _DDENABLEIRQINFO {
    DWORD dwSize;
    DWORD dwIRQSources;
    DWORD dwLine;
    DWORD IRQCallback;	// Mini VDD calls this when IRQ happens if they are managing the IRQ
    DWORD dwContext;	// Context to be specified in EBX when IRQCallback is called
} DDENABLEIRQINFO;

// Input to vddFlipVideoPort
typedef struct _DDFLIPVIDEOPORTINFO {
    DWORD dwSize;
    DWORD lpVideoPortData;
    DWORD lpCurrentSurface;
    DWORD lpTargetSurface;
    DWORD dwFlipVPFlags;
} DDFLIPVIDEOPORTINFO;

// Input to vddFlipOverlay
typedef struct _DDFLIPOVERLAYINFO {
    DWORD dwSize;
    DWORD lpCurrentSurface;
    DWORD lpTargetSurface;
    DWORD dwFlags;
} DDFLIPOVERLAYINFO;

// Input to vddSetState
typedef struct _DDSTATEININFO {
    DWORD dwSize;
    DWORD lpSurfaceData;
    DWORD lpVideoPortData;
} DDSTATEININFO;

// Output from vddSetState
typedef struct _DDSTATEOUTINFO {
    DWORD dwSize;
    DWORD dwSoftwareAutoflip;
    DWORD dwSurfaceIndex;
    DWORD dwVBISurfaceIndex;
} DDSTATEOUTINFO;

// Input to vddGetPolarity
typedef struct _DDPOLARITYININFO {
    DWORD dwSize;
    DWORD lpVideoPortData;
} DDPOLARITYININFO;

// Output from vddGetPolarity
typedef struct _DDPOLARITYOUTINFO {
    DWORD dwSize;
    DWORD bPolarity;
} DDPOLARITYOUTINFO;

// Input to vddLock
typedef struct _DDLOCKININFO {
    DWORD dwSize;
    DWORD lpSurfaceData;
} DDLOCKININFO;

// Output from vddLock
typedef struct _DDLOCKOUTINFO {
    DWORD dwSize;
    DWORD dwSurfacePtr;
} DDLOCKOUTINFO;

// Input to vddBobNextField
typedef struct _DDBOBINFO {
    DWORD dwSize;
    DWORD lpSurface;
} DDBOBINFO;

// Input to vddSkipNextField
typedef struct _DDSKIPINFO {
    DWORD dwSize;
    DWORD lpVideoPortData;
    DWORD dwSkipFlags;
} DDSKIPINFO;

// Input to vddSetSkipPattern
typedef struct _DDSETSKIPINFO {
    DWORD dwSize;
    DWORD lpVideoPortData;
    DWORD dwPattern;
    DWORD dwPatternSize;
} DDSETSKIPINFO;

// Input to vddGetCurrent/PreviousAutoflip
typedef struct _DDGETAUTOFLIPININFO {
    DWORD dwSize;
    DWORD lpVideoPortData;
} DDGETAUTOFLIPININFO;

// Output from vddGetCurrent/PreviousAutoflip
typedef struct _DDGETAUTOFLIPOUTINFO {
    DWORD dwSize;
    DWORD dwSurfaceIndex;
    DWORD dwVBISurfaceIndex;
} DDGETAUTOFLIPOUTINFO;

// Input to vddTransfer
typedef struct _DDTRANSFERININFO {
    DWORD dwSize;
    DWORD lpSurfaceData;
    DWORD dwStartLine;
    DWORD dwEndLine;
    DWORD dwTransferID;
    DWORD dwTransferFlags;
    PMDL  lpDestMDL;
} DDTRANSFERININFO;

// Input to vddTransfer
typedef struct _DDTRANSFEROUTINFO {
    DWORD dwSize;
    DWORD dwBufferPolarity;
} DDTRANSFEROUTINFO;

// Input to vddGetTransferStatus
typedef struct _DDGETTRANSFERSTATUSOUTINFO {
    DWORD dwSize;
    DWORD dwTransferID;
} DDGETTRANSFERSTATUSOUTINFO;


//@@BEGIN_MSINTERNAL
  /*
   * The following IRQ flags are duplicated in DDKERNEL.H.  Any changes must
   * be made in both places!!!
   */
//@@END_MSINTERNAL
// IRQ source flags
#define DDIRQ_DISPLAY_VSYNC			0x00000001l
#define DDIRQ_BUSMASTER				0x00000002l
#define DDIRQ_VPORT0_VSYNC			0x00000004l
#define DDIRQ_VPORT0_LINE			0x00000008l
#define DDIRQ_VPORT1_VSYNC			0x00000010l
#define DDIRQ_VPORT1_LINE			0x00000020l
#define DDIRQ_VPORT2_VSYNC			0x00000040l
#define DDIRQ_VPORT2_LINE			0x00000080l
#define DDIRQ_VPORT3_VSYNC			0x00000100l
#define DDIRQ_VPORT3_LINE			0x00000200l
#define DDIRQ_VPORT4_VSYNC			0x00000400l
#define DDIRQ_VPORT4_LINE			0x00000800l
#define DDIRQ_VPORT5_VSYNC			0x00001000l
#define DDIRQ_VPORT5_LINE			0x00002000l
#define DDIRQ_VPORT6_VSYNC			0x00004000l
#define DDIRQ_VPORT6_LINE			0x00008000l
#define DDIRQ_VPORT7_VSYNC			0x00010000l
#define DDIRQ_VPORT7_LINE			0x00020000l
#define DDIRQ_VPORT8_VSYNC			0x00040000l
#define DDIRQ_VPORT8_LINE			0x00080000l
#define DDIRQ_VPORT9_VSYNC			0x00010000l
#define DDIRQ_VPORT9_LINE			0x00020000l
#define DDIRQ_MISCELLANOUS                      0x80000000l

// SkipNextField flags
#define DDSKIP_SKIPNEXT			1
#define DDSKIP_ENABLENEXT		2

//@@BEGIN_MSINTERNAL
  /*
   * The following flip flags are duplicated in DVP.H.  Any changes must
   * be made in both places!!!
   */
//@@END_MSINTERNAL
// Flip VP flags
#define DDVPFLIP_VIDEO			0x00000001l
#define DDVPFLIP_VBI			0x00000002l

//@@BEGIN_MSINTERNAL
   /*
    * The following flags correspond to the DDADDBUFF_XXXX flags defined
    * in DDKMAPI.H.  Please keep these in sync!
    */
//@@END_MSINTERNAL
#define DDTRANSFER_SYSTEMMEMORY		0x00000001
#define DDTRANSFER_NONLOCALVIDMEM	0x00000002
#define DDTRANSFER_INVERT		0x00000004
#define DDTRANSFER_CANCEL		0x00000080
#define DDTRANSFER_HALFLINES		0x00000100


//@@BEGIN_MSINTERNAL

    #define MAX_DDKM_DEVICES	9

    /*
     * The following flags are passed to UpdateVPInfo by ring 3 DDraw
     */
    #define DDKMVP_CREATE	0x0001	// Are creating video port
    #define DDKMVP_RELEASE	0x0002	// Are releasing video port
    #define DDKMVP_UPDATE	0x0004	// Are updating the video port
    #define DDKMVP_ON		0x0008	// Video port is on
    #define DDKMVP_AUTOFLIP  	0x0010	// Autoflipping should be performed in software
    #define DDKMVP_AUTOFLIP_VBI	0x0020	// Autoflipping VBI should be performed in software
    #define DDKMVP_NOIRQ	0x0040	// VP will not generate VSYNC IRQ
    #define DDKMVP_NOSKIP	0x0080	// VP cannot skip fields
    #define DDKMVP_HALFLINES	0x0100	// Due to half lines, even field data is shifted down one line

    /*
     * The following internal flags are stored in KMVPEDATA.dwInternalFlags
     * and maintain the internal state information.
     */
    #define DDVPIF_ON			0x0001	// The video port is on
    #define DDVPIF_AUTOFLIP		0x0002	// Video data is autoflipped using IRQ
    #define DDVPIF_AUTOFLIP_VBI		0x0004	// VBI data is autoflipped using IRQ
    #define DDVPIF_BOB			0x0008	// Video data using bob via the IRQ
    #define DDVPIF_NOIRQ		0x0010	// VP will not generate VSYNC IRQ
    #define DDVPIF_NOSKIP		0x0020	// VP cannot skip fields
    #define DDVPIF_CAPTURING		0x0040	// VP has capture buffers in queue
    #define DDVPIF_NEW_STATE		0x0080	// A new state change has been posted
    #define DDVPIF_SKIPPED_LAST		0x0100	// The previous field was skipped - VP needs restoring
    #define DDVPIF_SKIP_SET		0x0200	// dwStartSkip contains valid data needs restoring
    #define DDVPIF_NEXT_SKIP_SET	0x0400	// dwNextSkip contains valid data
    #define DDVPIF_FLIP_NEXT		0x0800	// This video field was not flipped due to interleaving
    #define DDVPIF_FLIP_NEXT_VBI	0x1000	// This VBI field was not flipped due to interleaving
    #define DDVPIF_VBI_INTERLEAVED	0x2000	// Is the VBI data interleaved?
    #define DDVPIF_HALFLINES      	0x4000	// Due to half lines, even field data is shifted down one line
    #define DDVPIF_DISABLEAUTOFLIP     	0x8000	// Overlay autolfipping is temporarily disabled

    /*
     * Device capabilities
     */
    #define DDKMDF_IN_USE			0x00000001	// Can bob while interleaved
    #define DDKMDF_CAN_BOB_INTERLEAVED		0x00000002	// Can bob while interleaved
    #define DDKMDF_CAN_BOB_NONINTERLEAVED	0x00000004	// Can bob while non-interleaved
    #define DDKMDF_NOSTATE			0x00000008	// No support for switching from bob/weave
    #define DDKMDF_TRANSITION 			0x00000010	// Currently in a full-screen DOS box or res-change
    #define DDKMDF_STARTDOSBOX                  0x00000020      // Interim flag required to make power downs behave like DOS boxes
    #define DDKMDF_NODISABLEIRQ                 0x00000040      // DDraw should  not tell mini VDD to disable IRQs when DOS boxes
                                                                //  occur because they might still be able to operate in this mode

    /*
     * Internal flags used to describe the VPE actions at IRQ time
     */
    #define ACTION_BOB		0x0001
    #define ACTION_FLIP		0x0002
    #define ACTION_FLIP_VBI	0x0004
    #define ACTION_STATE	0x0008
    #define ACTION_BUSMASTER	0x0010

    /*
     * Internal surface flags
     */
    #define DDKMSF_STATE_SET		0x00000001
    #define DDKMSF_TRANSFER		0x00000002

    typedef DWORD (* MINIPROC)(VOID);

    /*
     * Info about each registered event
     */
    #ifndef LPDD_NOTIFYCALLBACK
	typedef DWORD (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);
    #endif
    typedef struct _KMEVENTNODE {
    	DWORD		dwEvents;
	LPDD_NOTIFYCALLBACK pfnCallback;
    	DWORD		dwParam1;
    	DWORD		dwParam2;
    	ULONG		pContext;
    	struct _KMEVENTNODE *lpNext;
    } KMEVENTNODE;
    typedef KMEVENTNODE *LPKMEVENTNODE;

    /*
     * Info about each allocated handle
     */
    typedef struct _KMHANDLENODE {
    	DWORD		dwHandle;
    	LPDD_NOTIFYCALLBACK pfnCallback;
    	ULONG		pContext;
    	struct _KMHANDLENODE *lpNext;
    } KMHANDLENODE;
    typedef KMHANDLENODE *LPKMHANDLENODE;

    typedef struct KMCAPTUREBUFF {
	DWORD   dwBuffFlags;
	PMDL    pBuffMDL;
	PKEVENT pBuffKEvent;
	ULONG	*lpBuffInfo;
	DWORD	dwInternalBuffFlags;
	LPDDSURFACEDATA lpBuffSurface;
    } KMCAPTUREBUFF;
    typedef KMCAPTUREBUFF *LPKMCAPTUREBUFF;

    #define DDBUFF_INUSE		0x0001
    #define DDBUFF_READY		0x0002
    #define DDBUFF_WAITING		0x0004

    /*
     * Info about each capture stream
     */
    #define DDKM_MAX_CAP_BUFFS		10
    typedef struct _KMCAPTURENODE {
    	DWORD		dwHandle;
    	DWORD		dwStartLine;
    	DWORD		dwEndLine;
	DWORD		dwCaptureEveryNFields;
	DWORD		dwCaptureCountDown;
    	LPDD_NOTIFYCALLBACK pfnCaptureClose;
	ULONG		pContext;
	KMCAPTUREBUFF	kmcapQueue[DDKM_MAX_CAP_BUFFS];
	DWORD		bUsed;
	DWORD		dwTop;
	DWORD		dwBottom;
	DWORD		dwPrivateFlags;
	DWORD		dwTheTransferId;
    	struct _KMCAPTURENODE *lpNext;
    } KMCAPTURENODE;
    typedef KMCAPTURENODE *LPKMCAPTURENODE;

    #define DDKMCAPT_VBI	0x0001
    #define DDKMCAPT_VIDEO	0x0002

    /*
     * Info that is needed of each video port
     */
    typedef struct _KMVPEDATA {
        DDVIDEOPORTDATA	ddvpData; 		// Video port data
        DWORD		dwInternalFlags;	// DDVPIF_xxx flags
        DWORD		dwNumAutoflip;		// Number of surfaces being autoflipped
        DWORD		dwNumVBIAutoflip;	// Number of VBI surfaces being autoflipped
        DWORD		dwSurfaces[10];		// Surface receiving the data (up to 10 autoflipping)
        DWORD		dwVBISurfaces[10];	// Surface receiving VBI data (up to 10 autoflipping)
        DWORD		dwIRQCnt_VPSYNC;	// VP VSYNC IRQ usage cnt
	DWORD		dwIRQCnt_VPLine;	// VP line IRQ usage cnt
    	DWORD		dwIRQLine;		// Line # of line IRQ
    	DWORD		dwCurrentField; 	// Current field number
	DWORD		dwStartSkip;		// Next field to skip
	DWORD		dwNextSkip;		// Field to skip after dwStartSkip
    	DWORD		dwActions;		// Actions required by IRQ logic
    	DWORD		dwCurrentBuffer;        // Current buffer (for autoflipping)
    	DWORD		dwCurrentVBIBuffer;	// Current VBI buffer (for autoflipping)
    	DWORD		dwNewState;		// For handling state changes posted on a certain field
    	DWORD		dwStateStartField;	// Field on which to start a new state change
    	DWORD		dwRefCnt;		// Reference count
    	LPKMHANDLENODE	lpHandleList;
	LPKMCAPTURENODE lpCaptureList;
	DWORD		dwCaptureCnt;
    } KMVPEDATA;
    typedef KMVPEDATA *LPKMVPEDATA;

    /*
     * Info that is needed of each VGA
     */
    typedef struct _KMSTATEDATA {
    	DWORD		dwDeviceFlags;		// Device flags
    	ULONG		pContext;		// Passed to Mini VDD
    	DWORD		dwListHandle;  		// List of surface handles
    	LPKMVPEDATA	lpVideoPort;		// Array containing video port info
    	DWORD  		dwHigh;         	// For error checking
    	DWORD		dwLow;          	// For error checking
    	DWORD		dwMaxVideoPorts;	// Number of video ports supported by device
    	DWORD		dwNumVPInUse;		// Number of video ports currently in use
    	DWORD		dwIRQHandle;    	// IRQ Handle (if we are managing the IRQ)
    	DWORD		dwIRQFlags;		// Sources, etc.
    	DWORD		dwIRQCnt_VSYNC; 	// # times graphics VSYNC IRQ is requested
    	DWORD		dwEventFlags;		// Which IRQs have registered notification
    	DWORD		dwIRQEvents;		// Which IRQs occurred that require event notification
    	DWORD		dwRefCnt;
    	DWORD		dwDOSBoxEvent;
	DWORD		dwCaps;
	DWORD		dwIRQCaps;
    	LPKMEVENTNODE	lpEventList;
    	LPKMHANDLENODE	lpHandleList;
    	MINIPROC	pfnGetIRQInfo;
    	MINIPROC	pfnIsOurIRQ;
    	MINIPROC	pfnEnableIRQ;
    	MINIPROC	pfnSkipNextField;
    	MINIPROC	pfnBobNextField;
    	MINIPROC	pfnSetState;
    	MINIPROC	pfnLock;
    	MINIPROC	pfnFlipOverlay;
    	MINIPROC	pfnFlipVideoPort;
    	MINIPROC	pfnGetPolarity;
    	MINIPROC	pfnSetSkipPattern;
    	MINIPROC	pfnGetCurrentAutoflip;
    	MINIPROC	pfnGetPreviousAutoflip;
    	MINIPROC	pfnTransfer;
    	MINIPROC	pfnGetTransferStatus;
    } KMSTATEDATA;
    typedef KMSTATEDATA *LPKMSTATEDATA;


//@@END_MSINTERNAL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddmode.c ===
/*========================================================================== *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddmode.c
 *  Content:    DirectDraw mode support
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   31-jan-95  craige  split out of ddraw.c and enhanced
 *   27-feb-95  craige  new sync. macros
 *   01-mar-95  craige  Win95 mode stuff
 *   19-mar-95  craige  use HRESULTs
 *   28-mar-95  craige  made modeset work again
 *   01-apr-95  craige  happy fun joy updated header file
 *   19-apr-95  craige  check for invalid callback in EnumDisplayModes
 *   14-may-95  craige  allow BPP change; validate EnumDisplayModes modes
 *   15-may-95  craige  keep track of who changes the mode
 *   02-jun-95  craige  keep track of the mode set by a process
 *   06-jun-95  craige  added internal fn RestoreDisplayMode
 *   11-jun-95  craige  don't allow mode switch if surfaces locked
 *   12-jun-95  craige  new process list stuff
 *   25-jun-95  craige  one ddraw mutex
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns
 *   30-jun-95  craige  turned off > 16bpp
 *   01-jul-95  craige  bug 106 - always went to last mode if mode not found
 *   02-jul-95  craige  RestoreDisplayMode needs to call HEL too
 *   04-jul-95  craige  YEEHAW: new driver struct; SEH
 *   05-jul-95  craige  crank up priority during mode change
 *   13-jul-95  craige  first step in mode set fix; made it work
 *   19-jul-95  craige  bug 189 - graphics mode change being ignored sometimes
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset
 *   22-jul-95  craige  bug 216 - random hang switching bpp - fixed by
 *                      using apps hwnd to hide things.
 *                      bug 230 - unsupported starting modes
 *   29-jul-95  toddla  allways call HEL for SetMode for display driver
 *   10-aug-95  toddla  EnumDisplayModes changed to take a lp not a lplp
 *   02-sep-95  craige  bug 854: disable > 640x480 modes for rel 1
 *   04-sep-95  craige  bug 894: allow forcing of mode set
 *   08-sep-95  craige  bug 932: set preferred mode after RestoreDisplayMode
 *   05-jan-96  kylej   add interface structures
 *   09-jan-96  kylej   enable >640x480 modes for rel 2
 *   27-feb-96  colinmc ensured that bits-per-pixel is always tested for
 *                      when enumerating display modes and that enumeration
 *                      always assumes you will be in exclusive mode when
 *                      you actually do the mode switch
 *   11-mar-96  jeffno  Dynamic mode switch stuff for NT
 *   24-mar-96  kylej   Check modes with monitor profile
 *   26-mar-96  jeffno  Added ModeChangedOnENTERDDRAW
 *   15-sep-96	craige	modex only work
 *   05-oct-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   15-dec-96  jeffno  Added more modex modes
 *   29-jan-97  jeffno  Mode13 support
 *   30-jan-97  colinmc Bug 5555: Bad DPF
 *   01-feb-97  colinmc Bug 5594: New ModeX modes are dangerous
 *   02-feb-97  toddla  pass driver name to DD16_GetMonitor functions
 *   03-may-98 johnstep NT-specific mode code moved to ddmodent.c
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"


// DX7 introduced a new style of refresh rate testing (for stereo), but we
// had to back away from it in DX8, so rather then using the LOWERTHANDDRAW7
// macro, we have to create our own that takes DX8 into account.

#define NEW_STYLE_REFRESH(x)    \
    (!LOWERTHANDDRAW7(x) && !((x)->lpLcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8))


static DDHALMODEINFO    ddmiModeXModes[] =
{
    #ifdef EXTENDED_MODEX
	{
	    320,    // width (in pixels) of mode
	    175,    // height (in pixels) of mode
	    320,    // pitch (in bytes) of mode
	    8,      // bits per pixel
	    (WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	    0,      // refresh rate
	    0,      // red bit mask
	    0,      // green bit mask
	    0,      // blue bit mask
	    0       // alpha bit mask
	},
    #endif // EXTENDED_MODEX
    {
	320,    // width (in pixels) of mode
	200,    // height (in pixels) of mode
	320,    // pitch (in bytes) of mode
	8,      // bits per pixel
	(WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	0,      // refresh rate
	0,      // red bit mask
	0,      // green bit mask
	0,      // blue bit mask
	0       // alpha bit mask
    },
    {
	320,    // width (in pixels) of mode
	240,    // height (in pixels) of mode
	320,    // pitch (in bytes) of mode
	8,      // bits per pixel
	(WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	0,      // refresh rate
	0,      // red bit mask
	0,      // green bit mask
	0,      // blue bit mask
	0       // alpha bit mask
    },
    #ifdef EXTENDED_MODEX
	{
	    320,    // width (in pixels) of mode
	    350,    // height (in pixels) of mode
	    320,    // pitch (in bytes) of mode
	    8,      // bits per pixel
	    (WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	    0,      // refresh rate
	    0,      // red bit mask
	    0,      // green bit mask
	    0,      // blue bit mask
	    0       // alpha bit mask
	},
        {
	    320,    // width (in pixels) of mode
	    400,    // height (in pixels) of mode
	    320,    // pitch (in bytes) of mode
	    8,      // bits per pixel
	    (WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	    0,      // refresh rate
	    0,      // red bit mask
	    0,      // green bit mask
	    0,      // blue bit mask
	    0       // alpha bit mask
        },
        {
	    320,    // width (in pixels) of mode
	    480,    // height (in pixels) of mode
	    320,    // pitch (in bytes) of mode
	    8,      // bits per pixel
	    (WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	    0,      // refresh rate
	    0,      // red bit mask
	    0,      // green bit mask
	    0,      // blue bit mask
	    0       // alpha bit mask
        },
    #endif // EXTENDED_MODEX
    /*
     * This is the standard VGA 320x200 linear mode. This mode must stay at the
     * end of the modex mode list, or else makeModeXModeIfNeeded might trip up
     * and pick this mode first. We want makeModeXModeIfNeeded to continue to
     * force modex and only modex.
     */
    {
	320,    // width (in pixels) of mode
	200,    // height (in pixels) of mode
	320,    // pitch (in bytes) of mode
	8,      // bits per pixel
	(WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX | DDMODEINFO_STANDARDVGA), // flags
	0,      // refresh rate
	0,      // red bit mask
	0,      // green bit mask
	0,      // blue bit mask
	0       // alpha bit mask
    }
};
#define NUM_MODEX_MODES (sizeof( ddmiModeXModes ) / sizeof( ddmiModeXModes[0] ) )


/*
 * makeModeXModeIfNeeded
 */
static LPDDHALMODEINFO makeModeXModeIfNeeded(
    	LPDDHALMODEINFO pmi,
	LPDDRAWI_DIRECTDRAW_LCL this_lcl )
{
    int			j;
    LPDDHALMODEINFO     pmi_j;

    /*
     * The app compat flags which mean ModeX mode only still mean ModeX mode
     * only. This routine will not substitute a standard VGA mode for a ModeX
     * mode by virtue of the order of these modes in the modex mode table.
     */
    if( (this_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_MODEXONLY) ||
	(dwRegFlags & DDRAW_REGFLAGS_MODEXONLY) )
    {
	for( j=0;j<NUM_MODEX_MODES; j++ )
	{
	    pmi_j = &ddmiModeXModes[j];
	    if( (pmi->dwWidth == pmi_j->dwWidth) &&
		(pmi->dwHeight == pmi_j->dwHeight) &&
		(pmi->dwBPP == pmi_j->dwBPP) &&
		((pmi->wFlags & pmi_j->wFlags) & DDMODEINFO_PALETTIZED ) )
	    {
                DPF(2,"Forcing mode %dx%d into modex", pmi->dwWidth,pmi->dwHeight );
		return pmi_j;
	    }
	}
    }
    return pmi;

} /* makeModeXModeIfNeeded */


/*
 * makeDEVMODE
 *
 * create a DEVMODE struct (and flags) from mode info
 *
 * NOTE: We now always set the exclusive bit here and
 * we always set the bpp. This is because we were
 * previously not setting the bpp when not exclusive
 * so the checking code was always passing the surface
 * if it could do a mode of that size regardless of
 * color depth.
 *
 * The new semantics of EnumDisplayModes is that it
 * gives you a list of all display modes you could
 * switch into if you were exclusive.
 */
void makeDEVMODE(
		LPDDRAWI_DIRECTDRAW_GBL this,
		LPDDHALMODEINFO pmi,
		BOOL inexcl,
		BOOL useRefreshRate,
		LPDWORD pcds_flags,
		LPDEVMODE pdm )
{
    ZeroMemory( pdm, sizeof(*pdm) );
    pdm->dmSize = sizeof( *pdm );
    pdm->dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL;
    if( useRefreshRate && (pmi->wRefreshRate != 0) )
	pdm->dmFields |= DM_DISPLAYFREQUENCY;
    pdm->dmPelsWidth = pmi->dwWidth;
    pdm->dmPelsHeight = pmi->dwHeight;
    pdm->dmBitsPerPel = pmi->dwBPP;
    pdm->dmDisplayFrequency = pmi->wRefreshRate;

    *pcds_flags = CDS_EXCLUSIVE | CDS_FULLSCREEN;

} /* makeDEVMODE */

/*
 * AddModeXModes
 */
void AddModeXModes( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    DWORD               i;
    DWORD               j;
    LPDDHALMODEINFO     pmi_i;
    LPDDHALMODEINFO     pmi_j;
    BOOL                hasmode[NUM_MODEX_MODES];
    DWORD               newmodecnt;
    LPDDHALMODEINFO     pmi;

    for( j=0;j<NUM_MODEX_MODES; j++ )
    {
	hasmode[j] = FALSE;
    }

    /*
     * find out what modes are already supported
     */
    for( i=0;i<pdrv->dwNumModes;i++ )
    {
	pmi_i = &pdrv->lpModeInfo[i];
	for( j=0;j<NUM_MODEX_MODES; j++ )
	{
	    pmi_j = &ddmiModeXModes[j];
	    if( (pmi_i->dwWidth == pmi_j->dwWidth) &&
		(pmi_i->dwHeight == pmi_j->dwHeight) &&
		(pmi_i->dwBPP == pmi_j->dwBPP) &&
		((pmi_i->wFlags & pmi_j->wFlags) & DDMODEINFO_PALETTIZED ) )
	    {
		// There is a mode already in the mode table the same as the modeX mode.
		// check to make sure that the driver really supports it
		DWORD   cds_flags;
		DEVMODE dm;
		int     cds_rc;

		makeDEVMODE( pdrv, pmi_i, TRUE, FALSE, &cds_flags, &dm );

		cds_flags |= CDS_TEST;
		cds_rc = ChangeDisplaySettings( &dm, cds_flags );
		if( cds_rc != 0)
		{
		    // The driver does not support this mode even though it is in the mode table.
		    // Mark the mode as unsupported and go ahead and add the ModeX mode.
		    DPF( 2, "Mode %d not supported (%dx%dx%d), rc = %d, marking invalid", i,
				pmi_i->dwWidth, pmi_i->dwHeight, pmi_i->dwBPP,
				cds_rc );
		    pmi_i->wFlags |= DDMODEINFO_UNSUPPORTED;
		}
		else
		{
		    // Don't add the ModeX mode, the driver supports a linear mode.
		    hasmode[j] = TRUE;
		}
	    }
	}
    }

    /*
     * count how many new modes we need
     */
    newmodecnt = 0;
    for( j=0;j<NUM_MODEX_MODES; j++ )
    {
	if( !hasmode[j] )
	{
	    newmodecnt++;
	}
    }

    /*
     * create new struct
     */
    if( newmodecnt > 0 )
    {
	pmi = MemAlloc( (newmodecnt + pdrv->dwNumModes) * sizeof( DDHALMODEINFO ) );
	if( pmi != NULL )
	{
	    memcpy( pmi, pdrv->lpModeInfo, pdrv->dwNumModes * sizeof( DDHALMODEINFO ) );
	    for( j=0;j<NUM_MODEX_MODES; j++ )
	    {
		if( !hasmode[j] )
		{
		    DPF( 2, "Adding ModeX mode %ldx%ldx%ld (standard VGA flag is %d)",
			    ddmiModeXModes[j].dwWidth,
			    ddmiModeXModes[j].dwHeight,
			    ddmiModeXModes[j].dwBPP,
                            (ddmiModeXModes[j].wFlags &DDMODEINFO_STANDARDVGA) ? 1 : 0);
		    pmi[ pdrv->dwNumModes ] = ddmiModeXModes[j];
		    pdrv->dwNumModes++;
		}
	    }
	    MemFree( pdrv->lpModeInfo );
	    pdrv->lpModeInfo = pmi;
	}
    }
    //
    //  make sure the last mode we validate is the current mode
    //  this works around a Win95 VDD bug.
    //
    (void) ChangeDisplaySettings( NULL, CDS_TEST );
} /* AddModeXModes */

BOOL MonitorCanHandleMode(LPDDRAWI_DIRECTDRAW_GBL this, DWORD width, DWORD height, WORD refreshRate )
{
    DWORD   max_monitor_x;
    DWORD   min_refresh;
    DWORD   max_refresh;

    max_monitor_x = (DWORD)DD16_GetMonitorMaxSize(this->cDriverName);

    if( ( max_monitor_x != 0 ) && ( width > max_monitor_x ) )
    {
	DPF(1, "Mode's width greater than monitor maximum width (%d)", max_monitor_x);
	return FALSE;
    }

    if( refreshRate == 0 )
    {
	// default refresh rate specified, no need to verify it
	return TRUE;
    }

    // a refresh rate was specified, we'd better make sure the monitor can handle it

    if(DD16_GetMonitorRefreshRateRanges(this->cDriverName, (int)width, (int) height, &min_refresh, &max_refresh))
    {
	if( (min_refresh != -1) && (min_refresh != 0) && (refreshRate < min_refresh) )
	{
	    DPF(1, "Requested refresh rate < monitor's minimum refresh rate (%d)", min_refresh);
	    return FALSE;
	}
	if( (min_refresh != -1) && (max_refresh != 0) && (refreshRate > max_refresh) )
	{
	    DPF(1, "Requested refresh rate > monitor's maximum refresh rate (%d)", max_refresh);
	    return FALSE;
	}
    }

    // The monitor likes it.
    return TRUE;
}

/*
 * setSurfaceDescFromMode
 */
static void setSurfaceDescFromMode(
                LPDDRAWI_DIRECTDRAW_LCL this_lcl,
		LPDDHALMODEINFO pmi,
		LPDDSURFACEDESC pddsd
        )
{
    memset( pddsd, 0, sizeof( DDSURFACEDESC ) );
    pddsd->dwSize = sizeof( DDSURFACEDESC );
    pddsd->dwFlags = DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT |
		     DDSD_PITCH | DDSD_REFRESHRATE;
    pddsd->dwHeight = pmi->dwHeight;
    pddsd->dwWidth = pmi->dwWidth;
    pddsd->lPitch = pmi->lPitch;
    pddsd->dwRefreshRate = (DWORD)pmi->wRefreshRate;

    pddsd->ddpfPixelFormat.dwSize = sizeof( DDPIXELFORMAT );
    pddsd->ddpfPixelFormat.dwFlags = DDPF_RGB;
    pddsd->ddpfPixelFormat.dwRGBBitCount = (DWORD)pmi->dwBPP;
    if( pmi->wFlags & DDMODEINFO_PALETTIZED )
    {
	pddsd->ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED8;
    }
    else
    {
	pddsd->ddpfPixelFormat.dwRBitMask = pmi->dwRBitMask;
	pddsd->ddpfPixelFormat.dwGBitMask = pmi->dwGBitMask;
	pddsd->ddpfPixelFormat.dwBBitMask = pmi->dwBBitMask;
	pddsd->ddpfPixelFormat.dwRGBAlphaBitMask = pmi->dwAlphaBitMask;
    }

    if (pmi->wFlags & DDMODEINFO_MODEX)
    {
        /*
         * We only turn on these flags if the app is not hacked to turn them off and
         * the registry hasn't been set to turn them off.
         */
        if ( (!(dwRegFlags & DDRAW_REGFLAGS_NODDSCAPSINDDSD)) && (!(this_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_NODDSCAPSINDDSD)) )
        {
            pddsd->dwFlags |= DDSD_CAPS;
            /*
             * If both MODEX and STANDARDVGA are set in the mode info, then it's
             * a regular VGA mode (i.e. mode 0x13)
             */
            if (pmi->wFlags & DDMODEINFO_STANDARDVGA )
            {
	        pddsd->ddsCaps.dwCaps |= DDSCAPS_STANDARDVGAMODE;
            }
            else
            {
	        pddsd->ddsCaps.dwCaps |= DDSCAPS_MODEX;
            }
        }
    }

} /* setSurfaceDescFromMode */

#undef DPF_MODNAME
#define DPF_MODNAME     "GetDisplayMode"

HRESULT DDAPI DD_GetDisplayMode(
		LPDIRECTDRAW lpDD,
		LPDDSURFACEDESC lpSurfaceDesc )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDHALMODEINFO             pmi;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetDisplayMode");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( !VALIDEX_DDSURFACEDESC2_PTR( lpSurfaceDesc ) &&
	    !VALIDEX_DDSURFACEDESC_PTR( lpSurfaceDesc ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( this->dwModeIndex == DDUNSUPPORTEDMODE)
	{
	    DPF_ERR( "Driver is in an unsupported mode" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTEDMODE;
	}
	pmi = &this->lpModeInfo[ this->dwModeIndex ];
	pmi = makeModeXModeIfNeeded( pmi, this_lcl );

        ZeroMemory(lpSurfaceDesc,lpSurfaceDesc->dwSize);
	setSurfaceDescFromMode( this_lcl, pmi, lpSurfaceDesc );

        /*
         * Maintain old behavior..
         */
        if (LOWERTHANDDRAW4(this_int))
        {
            lpSurfaceDesc->dwSize = sizeof(DDSURFACEDESC);
        }
        else
        {
            lpSurfaceDesc->dwSize = sizeof(DDSURFACEDESC2);


        }

        /*
         * set stereo surface caps bits if driver marks mode as stereo mode
         * 
         */
        if ( pmi->wFlags & DDMODEINFO_STEREO &&
            !LOWERTHANDDRAW7(this_int) &&
            VALIDEX_DDSURFACEDESC2_PTR(lpSurfaceDesc)
            )
        {
            LPDDSURFACEDESC2 pddsd2=(LPDDSURFACEDESC2) lpSurfaceDesc;
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_STEREOSURFACELEFT;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_GetDisplayMode */

#undef DPF_MODNAME
#define DPF_MODNAME     "SetDisplayMode"

/*
 * bumpPriority
 */
static DWORD bumpPriority( void )
{
    DWORD       oldclass;
    HANDLE      hprocess;

    hprocess = GetCurrentProcess();
    oldclass = GetPriorityClass( hprocess );
    SetPriorityClass( hprocess, HIGH_PRIORITY_CLASS );
    return oldclass;

} /* bumpPriority */

/*
 * restorePriority
 */
static void restorePriority( DWORD oldclass )
{
    HANDLE      hprocess;

    hprocess = GetCurrentProcess();
    SetPriorityClass( hprocess, oldclass );

} /* restorePriority */

#if 0
static char     szClassName[] = "DirectDrawFullscreenWindow";
static HWND     hWndTmp;
static HCURSOR  hSaveClassCursor;
static HCURSOR  hSaveCursor;
static LONG     lWindowLong;
static RECT     rWnd;

#define         OCR_WAIT_DEFAULT 102

/*
 * curtainsUp
 */
void curtainsUp( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    HCURSOR hcursor= (HCURSOR)LoadImage(NULL,MAKEINTRESOURCE(OCR_WAIT_DEFAULT),IMAGE_CURSOR,0,0,0);

    if( (pdrv_lcl->hWnd != 0) && IsWindow( (HWND) pdrv_lcl->hWnd ) )
    {
	lWindowLong = GetWindowLong( (HWND) pdrv_lcl->hWnd, GWL_EXSTYLE );
	SetWindowLong( (HWND) pdrv_lcl->hWnd, GWL_EXSTYLE, lWindowLong |
				(WS_EX_TOOLWINDOW) );
	hSaveClassCursor = (HCURSOR) GetClassLong( (HWND) pdrv_lcl->hWnd, GCL_HCURSOR );
	SetClassLong( (HWND) pdrv_lcl->hWnd, GCL_HCURSOR, (LONG) hcursor );
	GetWindowRect( (HWND) pdrv_lcl->hWnd, (LPRECT) &rWnd );
	SetWindowPos( (HWND) pdrv_lcl->hWnd, NULL, 0, 0,
	    10000, 10000,
	    SWP_NOZORDER | SWP_NOACTIVATE );
	SetForegroundWindow( (HWND) pdrv_lcl->hWnd );
    }
    else
    {
	WNDCLASS        cls;
	pdrv_lcl->hWnd = 0;
	cls.lpszClassName  = szClassName;
	cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
	cls.hInstance      = hModule;
	cls.hIcon          = NULL;
	cls.hCursor        = hcursor;
	cls.lpszMenuName   = NULL;
	cls.style          = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
	cls.lpfnWndProc    = DefWindowProc;
	cls.cbWndExtra     = 0;
	cls.cbClsExtra     = 0;

	RegisterClass(&cls);

	DPF( 4, "*** CREATEWINDOW" );
	hWndTmp = CreateWindowEx(WS_EX_TOPMOST|WS_EX_TOOLWINDOW,
	    szClassName, szClassName,
	    WS_POPUP|WS_VISIBLE, 0, 0, 10000, 10000,
	    NULL, NULL, hModule, NULL);
	DPF( 5, "*** BACK FROM CREATEWINDOW, hwnd=%08lx", hWndTmp );

	if( hWndTmp != NULL)
	{
	    SetForegroundWindow( hWndTmp );
	}
    }
    hSaveCursor = SetCursor( hcursor );

} /* curtainsUp */

/*
 * curtainsDown
 */
void curtainsDown( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    if( (pdrv_lcl->hWnd != 0) && IsWindow( (HWND) pdrv_lcl->hWnd ) )
    {
	SetWindowLong( (HWND) pdrv_lcl->hWnd, GWL_EXSTYLE, lWindowLong );
	SetClassLong( (HWND) pdrv_lcl->hWnd, GCL_HCURSOR, (LONG) hSaveClassCursor );
	SetCursor( hSaveCursor );
	SetWindowPos( (HWND) pdrv_lcl->hWnd, NULL,
	    rWnd.left, rWnd.top,
	    rWnd.right-rWnd.left,
	    rWnd.bottom-rWnd.top,
	    SWP_NOZORDER | SWP_NOACTIVATE );
    }
    else
    {
	SetCursor( hSaveCursor );
	pdrv_lcl->hWnd = 0;
	if( hWndTmp != NULL )
	{
	    DestroyWindow( hWndTmp );
	    UnregisterClass( szClassName, hModule );
	}
    }
    hWndTmp = NULL;

} /* curtainsDown */
#endif

/*
 * stopModeX
 */
static void stopModeX( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    DPF( 4, "***************** Turning off ModeX or standard VGA *****************" );
    ModeX_RestoreMode();

    pdrv->dwFlags &= ~(DDRAWI_MODEX|DDRAWI_STANDARDVGA);
    DPF( 4, "**************** DONE Turning off ModeX or standard VGA *************" );

} /* stopModeX */

/*
 * SetDisplayMode
 */
HRESULT SetDisplayMode(
		LPDDRAWI_DIRECTDRAW_LCL this_lcl,
		DWORD modeidx,
		BOOL force,
		BOOL useRefreshRate)
{
    DWORD                       rc;
    DDHAL_SETMODEDATA           smd;
    LPDDHAL_SETMODE             smfn;
    LPDDHAL_SETMODE             smhalfn;
    LPDDHALMODEINFO             pmi;
    LPDDHALMODEINFO             orig_pmi;
    BOOL                        inexcl;
    BOOL                        emulation;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DWORD                       oldclass;
    BOOL                        use_modex;
    BOOL                        was_modex;
    DWORD                       real_modeidx;

    /*
     * Signify that the app at least tried to set a mode.
     * Redrawing of the desktop will only happen if this flag is set.
     */
    this_lcl->dwLocalFlags |= DDRAWILCL_MODEHASBEENCHANGED;

    this = this_lcl->lpGbl;

    /*
     * don't allow if surfaces open
     */
    if( !force )
    {
	#ifdef USE_ALIAS
	    /*
	     * See comment on alias stuff in DD_SetDisplayMode2()
	     */
	    if( this->dwWin16LockCnt > 0 )
	    {
		DPF_ERR( "Can't switch modes with locked surfaces holding Win16 lock!" );
		return DDERR_SURFACEBUSY;
	    }
	#else /* USE_ALIAS */
	    if( this->dwSurfaceLockCount > 0 )
	    {
		DPF_ERR( "Can't switch modes with locked surfaces!" );
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */
    }

    if( modeidx == DDUNSUPPORTEDMODE )
    {
	DPF_ERR( "Trying to set to an unsupported mode" );
	return DDERR_UNSUPPORTEDMODE;
    }

    /*
     * is our current mode a disp dib mode?
     */
    was_modex = FALSE;
    orig_pmi = NULL;
    if( this->dwModeIndex != DDUNSUPPORTEDMODE )
    {
	orig_pmi = &this->lpModeInfo[ this->dwModeIndex ];
	orig_pmi = makeModeXModeIfNeeded( orig_pmi, this_lcl );
	if( orig_pmi->wFlags & DDMODEINFO_MODEX )
	{
	    was_modex = TRUE;
	}
    }

    /*
     * is the new mode a mode x mode
     */
    pmi = &this->lpModeInfo[ modeidx ];
    pmi = makeModeXModeIfNeeded( pmi, this_lcl );
    if( pmi->wFlags & DDMODEINFO_MODEX )
    {
	DPF( 5, "Mode %ld is a ModeX or standard VGA mode", modeidx);
	use_modex = TRUE;
    }
    else
    {
	use_modex = FALSE;
    }

    /*
     * don't re-set the mode to the same one...
     * NOTE: we ALWAYS set the mode in emulation on Win95 since our index could be wrong
     */
    if( modeidx == this->dwModeIndex && !(this->dwFlags & DDRAWI_NOHARDWARE) )
    {
	DPF( 5, "%08lx: Current Mode match: %ldx%ld, %dbpp", GetCurrentProcessId(),
			pmi->dwWidth, pmi->dwHeight, pmi->dwBPP );
	return DD_OK;
    }

    DPF( 5, "***********************************************" );
    DPF( 5, "*** SETDISPLAYMODE: %ldx%ld, %dbpp", pmi->dwWidth, pmi->dwHeight, pmi->dwBPP );
    DPF( 5, "*** dwModeIndex (current) = %ld", this->dwModeIndex );
    DPF( 5, "*** modeidx (new) = %ld", modeidx );
    DPF( 5, "*** use_modex = %ld", use_modex );
    DPF( 5, "*** was_modex = %ld", was_modex );
    DPF( 5, "***********************************************" );

    /*
     * check if in exclusive mode
     */
    inexcl = (this->lpExclusiveOwner == this_lcl);

    /*
     * check bpp
     */
    if( (this->dwFlags & DDRAWI_DISPLAYDRV) && !force )
    {
	DWORD dwBPP;

	if( NULL == orig_pmi )
	{
	    /*
	     * This is branch is taken if we are currently running in an unsupported
	     * mode.
	     */
	    DDASSERT( 0UL != this_lcl->hDC );
	    dwBPP = ( GetDeviceCaps( (HDC)( this_lcl->hDC ), BITSPIXEL ) *
		      GetDeviceCaps( (HDC)( this_lcl->hDC ), PLANES ) );
	}
	else
	{
	    dwBPP = orig_pmi->dwBPP;
	}

	if( (dwBPP != pmi->dwBPP) || ((dwBPP == pmi->dwBPP) && use_modex ) )
	{
	    if( !inexcl || !(this->dwFlags & DDRAWI_FULLSCREEN) )
	    {
		DPF_ERR( "Can't change BPP if not in exclusive fullscreen mode" );
		return DDERR_NOEXCLUSIVEMODE;
	    }
	}
    }

    /*
     * see if we need to shutdown modex mode
     */
    if( was_modex )
    {
	stopModeX( this );
    }

    /*
     * see if we need to set a modex mode
     */
    if( use_modex )
    {
	DWORD                   i;
	LPDDHALMODEINFO         tmp_pmi;

	real_modeidx = modeidx;
	for( i=0;i<this->dwNumModes;i++ )
	{
	    tmp_pmi = &this->lpModeInfo[ i ];
	    if( (tmp_pmi->dwWidth == 640) &&
		(tmp_pmi->dwHeight == 480) &&
		(tmp_pmi->dwBPP == 8) &&
		(tmp_pmi->wFlags & DDMODEINFO_PALETTIZED) )
	    {
		DPF( 5, "MODEX or Standard VGA: Setting to 640x480x8 first (index=%ld)", i );
		modeidx = i;
		break;
	    }
	}
	if( i == this->dwNumModes )
	{
	    DPF( 0, "Mode not supported" );
	    return DDERR_INVALIDMODE;
	}
    }
    /*
     * get the driver to set the new mode...
     */
    if( ( this->dwFlags & DDRAWI_DISPLAYDRV ) ||
	( this->dwFlags & DDRAWI_NOHARDWARE ) ||
	( this_lcl->lpDDCB->cbDDCallbacks.SetMode == NULL ) )
    {
	smfn = this_lcl->lpDDCB->HELDD.SetMode;
	smhalfn = smfn;
	emulation = TRUE;

    // If this DDraw object was created for a particular device, explicitly,
    // and we're using the HEL (which we will be except on non-display
    // devices), then stuff the this_lcl pointer into ddRVal so we can
    // check the EXPLICITMONITOR flag from mySetMode.
    smd.ddRVal = (HRESULT) this_lcl;

    DPF( 4, "Calling HEL SetMode" );
    }
    else
    {
	smhalfn = this_lcl->lpDDCB->cbDDCallbacks.SetMode;
	smfn = this_lcl->lpDDCB->HALDD.SetMode;
	emulation = FALSE;
    }
    if( smhalfn != NULL )
    {
	DWORD   oldmode;
	BOOL    didsetmode;

	/*
	 * set the mode if this isn't a modex mode, or if it is a modex
	 * mode but wasn't one before
	 */
	if( !use_modex || (use_modex && !was_modex) )
	{
	    smd.SetMode = smhalfn;
	    smd.lpDD = this;
	    smd.dwModeIndex = modeidx;
	    smd.inexcl = inexcl;
	    smd.useRefreshRate = useRefreshRate;
	    this->dwFlags |= DDRAWI_CHANGINGMODE;
	    oldclass = bumpPriority();
	    DOHALCALL( SetMode, smfn, smd, rc, emulation );
	    restorePriority( oldclass );
	    this->dwFlags &= ~DDRAWI_CHANGINGMODE;
	    didsetmode = TRUE;
	}
	else
	{
	    rc = DDHAL_DRIVER_HANDLED;
	    smd.ddRVal = DD_OK;
	    didsetmode = FALSE;
	}
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( smd.ddRVal == DD_OK )
	    {
		oldmode = this->dwModeIndexOrig; // save original mode index
		if( didsetmode )
		{
                    CleanupD3D8(this, FALSE, 0);
                    FetchDirectDrawData( this, TRUE, 0, GETDDVXDHANDLE( this_lcl ), NULL, 0 , this_lcl );
                    this->dwModeIndex = modeidx;
                    this_lcl->dwPreferredMode = modeidx;
                    DPF(5,"Preferred mode index is %d, desired mode is %d",this_lcl->dwPreferredMode,modeidx);
		    this->dwModeIndexOrig = oldmode;

                    /*
                     * Some drivers will re-init the gamma ramp on a mode
                     * change, so if we previously set a new gamma ramp,
                     * we'll set it again.
                     */
                    if( ( this_lcl->lpPrimary != NULL ) &&
                        ( this_lcl->lpPrimary->lpLcl->lpSurfMore->lpGammaRamp != NULL ) &&
                        ( this_lcl->lpPrimary->lpLcl->dwFlags & DDRAWISURF_SETGAMMA ) )
                    {
                        SetGamma( this_lcl->lpPrimary->lpLcl, this_lcl );
                    }

		    /*
		     * It is possible that calling ChangeDisplaySettings could
		     * generate a WM_ACTIVATE app message to the app telling
		     * it to deactivate, which would cause RestoreDisplaymode
		     * to be called before we setup the new mode index.  In this
		     * case, it would not actually restore the mode but it would
		     * clear the MODEHASBEENCHANGEDFLAG, insuring that we could
                     * never restore the original mode.  The simple workaround
		     * it to set this flag again.
		     */
		    this_lcl->dwLocalFlags |= DDRAWILCL_MODEHASBEENCHANGED;
                    /*
                     * The driver local's DC will have been invalidated (DCX_CLIPCHILDREN set) by the
                     * mode switch, if it occurred via ChangeDisplaySettigs. Record this fact so the emulation
                     * code can decide to reinit the device DC.
                     */
		    this_lcl->dwLocalFlags |= DDRAWILCL_DIRTYDC;
		}

		/*
		 * now set modex mode
		 */
		if( use_modex )
		{
		    extern void HELStopDCI( void );
		    DPF( 4, "********************** Setting MODEX or STANDARD VGA MODE **********************" );

		    if( this->dwFlags & DDRAWI_ATTACHEDTODESKTOP )
		    {
		        HELStopDCI();
		    }

                    ModeX_SetMode( (UINT)pmi->dwWidth, (UINT)pmi->dwHeight, (UINT) (pmi->wFlags & DDMODEINFO_STANDARDVGA) );
		    /*
		     * ModeX now active, program our driver object and return
		     */
		    /*
		     * We know this code can only ever be called from an application
		     * thread so we don't have to worry about using DDHELP's VXD handle.
		     */
                    fetchModeXData( this, pmi, (HANDLE) this_lcl->hDDVxd );
		    this->dwModeIndex = real_modeidx;
		    this_lcl->dwPreferredMode = real_modeidx;
		    this->dwModeIndexOrig = oldmode;
		    DPF( 4, "********************** Done Setting MODEX MODE **********************" );

		    /*
		     * It is possible that calling ChangeDisplaySettings could
		     * generate a WM_ACTIVATE app message to the app telling
		     * it to deactivate, which would cause RestoreDisplaymode
		     * to be called before we setup the new mode index.  In this
		     * case, it would not actually restore the mode but it would
		     * clear the MODEHASBEENCHANGEDFLAG, insuring that we could
		     * never restore the origainl mode.  The simple workaround
		     * it to set this flag again.
		     */
		    this_lcl->dwLocalFlags |= DDRAWILCL_MODEHASBEENCHANGED;

		    return DD_OK;

		}
	    }
	    return smd.ddRVal;
	}
    }

    return DDERR_UNSUPPORTED;

} /* SetDisplayMode */

/*
 * DD_SetDisplayMode
 */
HRESULT DDAPI DD_SetDisplayMode(
		LPDIRECTDRAW lpDD,
		DWORD dwWidth,
		DWORD dwHeight,
		DWORD dwBPP )
{
    DPF(2,A,"ENTERAPI: DD_SetDisplayMode");

    DPF(4,"DD1 setdisplay mode called");
    return DD_SetDisplayMode2(lpDD,dwWidth,dwHeight,dwBPP,0,0);
} /* DD_SetDisplayMode */

/*
 * DD_SetDisplayMode2
 */
HRESULT DDAPI DD_SetDisplayMode2(
		LPDIRECTDRAW lpDD,
		DWORD dwWidth,
		DWORD dwHeight,
		DWORD dwBPP,
		DWORD dwRefreshRate,
                DWORD dwFlags)
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    int                         i;
    int                         j;
    LPDDHALMODEINFO             pmi;
    HRESULT                     ddrval;
    int                         iChosenMode;
    DWORD                       dwNumberOfTempModes;

    typedef struct
    {
        DDHALMODEINFO               mi;
        int                         iIndex;
    }TEMP_MODE_LIST;

    TEMP_MODE_LIST * pTempList=0;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_SetDisplayMode2");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	/*
	 * Check for invalid flags
	 */
	if( dwFlags & ~ DDSDM_VALID)
	{
	    DPF_ERR( "Invalid flags specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	#ifdef USE_ALIAS
	    /*
	     * Behaviour change. Previously we did not allow a mode switch
	     * if any video memory (or implicit system memory) surfaces
	     * were locked. However, we not allow mode switches for
	     * locked VRAM surfaces as long as they don't have the Win16
	     * lock (in which case this code is irrelevant as the DirectDraw
	     * critical section will prevent them ever hitting this code).
	     * So the behaviour is now that if vram surface are locked but
	     * are not holding the Win16 lock they can mode switch away.
	     * If however, we have Win16 locked VRAM surfaces then they can't
	     * mode switch. This should only have any effect if the application
	     * holding the locks attempts the mode switch. In which case,
	     * previously it would fail if it had any VRAM or implicit system
	     * memory surfaces locked whereas now it will only fail if it has
	     * the primary or other unaliased VRAM surface locked.
	     */
	    if( this->dwWin16LockCnt > 0 )
	    {
		DPF_ERR( "Can't switch modes with locked surfaces holding Win16 lock!" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#else /* USE_ALIAS */
	    /*
	     * don't allow change if surfaces are locked
	     */
	    if( this->dwSurfaceLockCount )
	    {
		DPF_ERR( "Surfaces are locked, can't switch the mode" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */

	/*
	 * don't allow change if some other process has exclusive mode
	 */
	if( (this->lpExclusiveOwner != NULL) &&
	    (this->lpExclusiveOwner != this_lcl ) )
	{
	    DPF_ERR( "Can't change mode; exclusive mode not owned" );
	    LEAVE_DDRAW();
	    return DDERR_NOEXCLUSIVEMODE;
	}

        /*
         * Modes are now chosen in a 3-step process:
         * -Build a temporary list of modes which match the desired spatial and color resolutions
         * -Sort this list into ascending refresh rate order.
         * -Select from this list the rate which best matches what we want.
         */

        if( (this_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_MODEXONLY) ||
	    (dwRegFlags & DDRAW_REGFLAGS_MODEXONLY) )
        {
            /*
             * Don't allow VGA mode if ModeX only.
             * Note if either of these flags are set, there won't actually be a VGA mode in the
             * table, so we wouldn't match it anyway. The problem comes in when makeModeXModeIfNeeded
             * overrides an accelerated mode. The duplication-check loop below will attempt to
             * skip the newly modex 320x200x8 since it doesn't match the VGA 320x200x8 which it is expecting later in
             * the table. That VGA mode won't be in the table, so the dupe check code skips the mode we
             * actually wanted (since we are forcing to modex). If we turn off the app's request for
             * VGA, then that dupe check won't be made, and we should pick up the modex mode.
             */
            DPF(2,"Turning off request for standard VGA due to ModeX override");
            dwFlags &= ~DDSDM_STANDARDVGAMODE;
        }

        /*
         * Step 1. Build a list of modes which match the desired spatial and color resolutions
         */
        pTempList = (TEMP_MODE_LIST*) MemAlloc(this->dwNumModes * sizeof(TEMP_MODE_LIST));
        if (0 == pTempList)
        {
            LEAVE_DDRAW();
            return DDERR_OUTOFMEMORY;
        }

        dwNumberOfTempModes=0;
	DPF( 5, "Looking for %ldx%ldx%ld", dwWidth, dwHeight, dwBPP );
        for(i = 0;i <(int) (this->dwNumModes);i++)
        {
	    pmi = &this->lpModeInfo[i];
	    pmi = makeModeXModeIfNeeded( pmi, this_lcl );

	    DPF( 5, "Found %ldx%ldx%ldx (flags = %ld)", pmi->dwWidth, pmi->dwHeight, pmi->dwBPP, pmi->wFlags );

	    if( (pmi->dwWidth == dwWidth) &&
		(pmi->dwHeight == dwHeight) &&
		((DWORD)pmi->dwBPP == dwBPP) &&
		((pmi->wFlags & DDMODEINFO_UNSUPPORTED) == 0) &&
                (!LOWERTHANDDRAW7(this_int) || !(pmi->wFlags & DDMODEINFO_DX7ONLY)) )
            {
                /*
                 * The behaviour is that linear modes override ModeX modes
                 * and standard VGA modes. If the app sets
                 * DDSDM_STANDARDVGAMODE even when a linear mode has replaced
                 * both the modex and mode13 modes, then we will IGNORE the app's
                 * request for VGA and run with the linear mode. This most closely
                 * matches the ModeX behaviour.
                 * If there's an accelerated 320x200 mode, then there will be neither
                 * the modex nor the VGA mode in the mode table. If there's no accelerated
                 * mode, then there will be both modex and vga modes in the list.
                 * Therefore, if the app specified VGA, we only pay attention to them
                 * and ignore a 320x200x8 mode if it is a modex mode.
                 */
                if ( (dwFlags & DDSDM_STANDARDVGAMODE)
                    && (pmi->wFlags & DDMODEINFO_MODEX) && ((pmi->wFlags & DDMODEINFO_STANDARDVGA)==0) )
                {
                    /*
                     * App wants a standard VGA mode, but this mode is mode X. Move on.
                     */
                    continue;

                }

                if(!(this->dwFlags & DDRAWI_DISPLAYDRV ))
                {
                    if (pmi->wFlags & DDMODEINFO_DX7ONLY)
                    {
                        //
                        // Can't pass generated modes to non-display drivers
                        // because they actually get the index, and a generated
                        // mode's index would be beyond the end of their table.
                        //
                        
                        continue;
                    }
                }

                pTempList[dwNumberOfTempModes].mi = *pmi;
                pTempList[dwNumberOfTempModes].iIndex = i;
                dwNumberOfTempModes++;
            }
        }
        if (0 == dwNumberOfTempModes)
        {
            MemFree(pTempList);
	    LEAVE_DDRAW();
	    DPF( 0,"Mode not found... No match amongst available spatial and color resolutions (wanted %dx%dx%d)",dwWidth,dwHeight,dwBPP );
	    return DDERR_INVALIDMODE;
	}

        for(i=0;i<(int)dwNumberOfTempModes;i++)
            DPF(5,"Copied mode list element %d:%dx%dx%d@%d",i,
                pTempList[i].mi.dwWidth,
                pTempList[i].mi.dwHeight,
                pTempList[i].mi.dwBPP,
                pTempList[i].mi.wRefreshRate);

        /*
         * Step 2. Sort list into ascending refresh order
         * Bubble sort
         * Note this does nothing if there's only one surviving mode.
         */
        for (i=0;i<(int)dwNumberOfTempModes;i++)
        {
            for (j=(int)dwNumberOfTempModes-1;j>i;j--)
            {
                if (pTempList[i].mi.wRefreshRate > pTempList[j].mi.wRefreshRate)
                {
                    TEMP_MODE_LIST temp = pTempList[i];
                    pTempList[i] = pTempList[j];
                    pTempList[j] = temp;
                }
            }
        }

        for(i=0;i<(int)dwNumberOfTempModes;i++)
            DPF(5,"Sorted mode list element %d:%dx%dx%d@%d",i,
                pTempList[i].mi.dwWidth,
                pTempList[i].mi.dwHeight,
                pTempList[i].mi.dwBPP,
                pTempList[i].mi.wRefreshRate);

        /*
         * Step 3. Find the rate we're looking for.
         * There are three cases.
         * 1:Looking for a specific refresh
         * 2a:Not looking for a specific refresh and stepping down in spatial resolution
         * 2a:Not looking for a specific refresh and stepping up in spatial resolution
         */
        iChosenMode = -1;

        if (dwRefreshRate)
        {
            /* case 1 */
            DPF(5,"App wants rate of %d",dwRefreshRate);
            for (i=0;i<(int)dwNumberOfTempModes;i++)
            {
                /*
                 * We'll never match a zero (hardware default) rate here,
                 * but if there's only one rate which has refresh=0
                 * the app will never ask for a non-zero rate, because it will
                 * never have seen one at enumerate time.
                 */
                if ( (DWORD) (pTempList[i].mi.wRefreshRate) == dwRefreshRate )
                {
                    iChosenMode=pTempList[i].iIndex;
                    break;
                }
            }
        }
        else
        {
            /*
             * Case 2b: Going up in spatial resolution, so just pick the
	     * lowest rate (earliest in list) which isn't a hardware
	     * default, unless no such rate exists.
             */
            iChosenMode=pTempList[0].iIndex;
        }

        if (-1 == iChosenMode)
        {
            MemFree(pTempList);
	    LEAVE_DDRAW();
	    DPF( 0,"Mode not found... No match amongst available refresh rates (wanted %dx%dx%d@%d)",dwWidth,dwHeight,dwBPP,dwRefreshRate);
	    return DDERR_INVALIDMODE;
	}

        MemFree(pTempList);

	pmi = &this->lpModeInfo[iChosenMode];

	/*
	 * only allow ModeX modes if the cooplevel is ok
	 */
	if( (pmi->wFlags & DDMODEINFO_MODEX) && !(this_lcl->dwLocalFlags & DDRAWILCL_ALLOWMODEX) )
	{
	    LEAVE_DDRAW();
	    DPF( 0,"must set DDSCL_ALLOWMODEX to use ModeX or Standard VGA modes" );
	    return DDERR_INVALIDMODE;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    // See if the monitor likes it.  If using an interface older than DX7,
    // we check using the old way; otherwise, we check using the new way
    if( !NEW_STYLE_REFRESH( this_int ) )
    {
        if( !(pmi->wFlags & DDMODEINFO_MODEX) && !MonitorCanHandleMode(this, pmi->dwWidth, pmi->dwHeight, pmi->wRefreshRate) )
        {
            // Monitor doesn't like it
            LEAVE_DDRAW();
            DPF_ERR("Mode not compatible with monitor");
            return DDERR_INVALIDMODE;
        }
    }
    else if( !(pmi->wFlags & DDMODEINFO_MODEX) )
    {
        if( !MonitorCanHandleMode(this, pmi->dwWidth, pmi->dwHeight, 0) ||
            !CanMonitorHandleRefreshRate( this, pmi->dwWidth, pmi->dwHeight, 
            //Only pass a refresh rate if the app asked for one (otherwise, asking for 0
            //will cause us to pass the first wRefreshRate in the mode table).
            dwRefreshRate ? pmi->wRefreshRate : 0 ) ) 
        {
            // Monitor doesn't like it
            LEAVE_DDRAW();
            DPF_ERR("Mode not compatible with monitor");
            return DDERR_INVALIDMODE;
        }
    }

    /*
     * set the display mode, and pay attention to refresh rate if we were asked to.
     * Always pay attention to rate on NT.
     * NOTE!!! This is a very slight change from what we did in released DX2!!!
     * - This function is now called from DD_SetDisplayMode with a refresh rate of 0,
     *   so we check for that circumstance and use it to say to the driver wether
     *   or not to pay attention to the refresh rate. Fine. However, now when
     *   someone calls DD_SetDisplayMode2 with a refresh rate of 0, we tell
     *   the driver to ignore the rate, when before we were telling the driver
     *   to force to some rate we found in the mode table (which would have been
     *   the first mode which matched resolution in the list... probably the lowest
     *   refresh rate).
     */
    #if 1 //def WIN95
        if (0 == dwRefreshRate)
            ddrval = SetDisplayMode( this_lcl, iChosenMode, FALSE, FALSE );
        else
    #endif
        ddrval = SetDisplayMode( this_lcl, iChosenMode, FALSE, TRUE );

    LEAVE_DDRAW();
    return ddrval;

} /* DD_SetDisplayMode2 */

#undef DPF_MODNAME
#define DPF_MODNAME     "RestoreDisplayMode"

/*
 * RestoreDisplayMode
 *
 * For use by DD_RestoreDisplayMode & internally.
 * Must be called with driver lock taken
 */
HRESULT RestoreDisplayMode( LPDDRAWI_DIRECTDRAW_LCL this_lcl, BOOL force )
{
    DWORD                       rc;
    DDHAL_SETMODEDATA           smd;
    BOOL                        inexcl;
    DWORD                       pid;
    LPDDHAL_SETMODE             smfn;
    LPDDHAL_SETMODE             smhalfn;
    BOOL                        emulation;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DWORD                       oldclass;
    BOOL                        was_modex;
    LPDDHALMODEINFO             pmi;

    DPF(2,A,"ENTERAPI: DD_RestoreDisplayMode");

    this = this_lcl->lpGbl;
    #ifdef DEBUG
    	if( DDUNSUPPORTEDMODE != this->dwModeIndexOrig )
	{
            DPF(5,"Restoring Display mode to index %d, %dx%dx%d@%d",this->dwModeIndexOrig,
                this->lpModeInfo[this->dwModeIndexOrig].dwWidth,
                this->lpModeInfo[this->dwModeIndexOrig].dwHeight,
                this->lpModeInfo[this->dwModeIndexOrig].dwBPP,
                this->lpModeInfo[this->dwModeIndexOrig].wRefreshRate);
	}
	else
	{
	    DPF(5,"Restoring Display mode to a non-DirectDraw mode");
	}
    #endif /* DEBUG */

    if (0 == (this_lcl->dwLocalFlags & DDRAWILCL_MODEHASBEENCHANGED) )
    {
        /*
         * This app never made a mode change, so we ignore the restore, in case someone switch desktop
         * modes while playing a movie in a window, for instance. We do it before the redraw window
         * so that we don't flash icons when a windowed app exits.
         */
	DPF( 2, "Mode was never changed by this app" );
	return DD_OK;
    }

    /*
     * we ALWAYS set the mode in emulation on Win95 since our index could be wrong
     */
    if( ( (this->dwModeIndex == this->dwModeIndexOrig) &&
	!(this->dwFlags & DDRAWI_NOHARDWARE) ) || (this->lpModeInfo==NULL) )
    {
	DPF( 2, "Mode wasn't changed" );
        RedrawWindow( NULL, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN );
        /*
         * Scenario: Start an app that can do windowed<->fullscreen transitions. Start windowed.
         * Go fullscreen (sets MODEHASBEENCHANGED). Go windowed. Use control panel to
         * change display settings. Exit app. Original mode will be restored.
         * If we reset this flag, that won't happen.
         */
        this_lcl->dwLocalFlags &= ~DDRAWILCL_MODEHASBEENCHANGED;

	return DD_OK;
    }


    DPF( 4, "In RestoreDisplayMode" );

    pid = GetCurrentProcessId();

    /*
     * don't allow mode change if surfaces are locked
     */
    if( !force )
    {
	#ifdef USE_ALIAS
	    /*
	     * See comment on aliasing in DD_ResetDisplayMode()
	     */
	    if( this->dwWin16LockCnt > 0 )
	    {
		DPF_ERR( "Can't switch modes with locked surfaces holding Win16 lock!" );
		return DDERR_SURFACEBUSY;
	    }
	#else /* USE_ALIAS */
	    if( this->dwSurfaceLockCount > 0 )
	    {
		DPF( 0, "Can't switch modes with locked surfaces!" );
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */
    }

    /*
     * see if we're in exclusive mode
     */
    if( force )
    {
	inexcl = TRUE;
    }
    else
    {
	inexcl = (this->lpExclusiveOwner == this_lcl);
    }

    /*
     * check bpp
     */
    pmi = &this->lpModeInfo[ this->dwModeIndex ];
    pmi = makeModeXModeIfNeeded( pmi, this_lcl );
    if( pmi->wFlags & DDMODEINFO_MODEX )
    {
	was_modex = TRUE;
    }
    else
    {
	was_modex = FALSE;
    }

    /*
     * turn off modex first...
     */
    if( was_modex )
    {
	stopModeX( this );
    }

    /*
     * get the driver to restore the mode...
     */
    if( ( this->dwFlags & DDRAWI_DISPLAYDRV ) ||
	( this->dwFlags & DDRAWI_NOHARDWARE ) ||
	( this_lcl->lpDDCB->cbDDCallbacks.SetMode == NULL ) )
    {
	smfn = this_lcl->lpDDCB->HELDD.SetMode;
	smhalfn = smfn;
	emulation = TRUE;

    // Store the this_lcl so we can check for multimon-aware in mySetMode
    smd.ddRVal = (HRESULT) this_lcl;
    }
    else
    {
	smhalfn = this_lcl->lpDDCB->cbDDCallbacks.SetMode;
	smfn = this_lcl->lpDDCB->HALDD.SetMode;
	emulation = FALSE;
    }
    if( smhalfn != NULL )
    {
	smd.SetMode = smhalfn;
	smd.lpDD = this;
        smd.dwModeIndex = (DWORD) -1;
	smd.inexcl = inexcl;
	smd.useRefreshRate = TRUE;
        this->dwFlags |= DDRAWI_CHANGINGMODE;
	oldclass = bumpPriority();

        // Store the this_lcl so we can check for multimon-aware in mySetMode
        smd.ddRVal = (HRESULT) this_lcl;

	DOHALCALL( SetMode, smfn, smd, rc, emulation );
	restorePriority( oldclass );
	this->dwFlags &= ~DDRAWI_CHANGINGMODE;

	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( smd.ddRVal != DD_OK )
	    {
		/*
		 * Scenario: Laptop boots w/ external monitor, switch to
		 * 10x7 mode.  Shutdown, unplug the monitor, reboot.  Mode
		 * is 640x480 but registry says it's 10x7.  Run a low-res
		 * game, we call ChangeDisplaySettings(NULL), which tries
		 * to restore things according to the registry, so it
		 * fails.  The result is we stay in low-res mode, which
		 * pretty much means we have to reboot.
		 *
		 * To work around this, we will explixitly set the mode that
		 * we started in.
		 */
		smd.dwModeIndex = this->dwModeIndexOrig;
                this->dwFlags |= DDRAWI_CHANGINGMODE;
		oldclass = bumpPriority();
	        smd.lpDD = this;
		DOHALCALL( SetMode, smfn, smd, rc, emulation );
		restorePriority( oldclass );
		this->dwFlags &= ~DDRAWI_CHANGINGMODE;
	    }
	    if( smd.ddRVal == DD_OK )
	    {
		DPF( 5, "RestoreDisplayMode: Process %08lx Mode = %ld", GETCURRPID(), this->dwModeIndex );
                CleanupD3D8(this, FALSE, 0);
                FetchDirectDrawData( this, TRUE, 0, GETDDVXDHANDLE( this_lcl ), NULL, 0 , this_lcl );

                /*
                 * Some drivers will re-init the gamma ramp on a mode
                 * change, so if we previously set a new gamma ramp,
                 * we'll set it again.
                 */
                if( ( this_lcl->lpPrimary != NULL ) &&
                    ( this_lcl->lpPrimary->lpLcl->lpSurfMore->lpGammaRamp != NULL ) &&
                    ( this_lcl->lpPrimary->lpLcl->dwFlags & DDRAWISURF_SETGAMMA ) )
                {
                    SetGamma( this_lcl->lpPrimary->lpLcl, this_lcl );
                }

                /*
                 * Scenario: Start an app that can do windowed<->fullscreen transitions. Start windowed.
                 * Go fullscreen (sets MODEHASBEENCHANGED). Go windowed. Use control panel to
                 * change display settings. Exit app. Original mode will be restored.
                 * If we reset this flag, that won't happen.
                 */
                this_lcl->dwLocalFlags &= ~DDRAWILCL_MODEHASBEENCHANGED;

                /*
                 * The driver local's DC will have been invalidated (DCX_CLIPCHILDREN set) by the
                 * mode switch, if it occurred via ChangeDisplaySettigs. Record this fact so the emulation
                 * code can decide to reinit the device DC.
                 */
		this_lcl->dwLocalFlags |= DDRAWILCL_DIRTYDC;

		if( this->dwFlags & DDRAWI_DISPLAYDRV )
		{
                    DPF(4,"Redrawing all windows");
		    RedrawWindow( NULL, NULL, NULL, RDW_INVALIDATE | RDW_ERASE |
				     RDW_ALLCHILDREN );
		}
	    }
	    return smd.ddRVal;
	}
    }

    return DDERR_UNSUPPORTED;

} /* RestoreDisplayMode */

/*
 * DD_RestoreDisplayMode
 *
 * restore mode
 */
HRESULT DDAPI DD_RestoreDisplayMode( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    HRESULT                     ddrval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_RestoreDisplayMode");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	/*
	 * switching to the same mode?
	 */
	if( this->dwModeIndex == this->dwModeIndexOrig )
	{
	    LEAVE_DDRAW();
	    return DD_OK;
	}

	/*
	 * don't allow change if some other process has exclusive mode
	 */
	if( (this->lpExclusiveOwner != NULL) &&
	    (this->lpExclusiveOwner != this_lcl ) )
	{
	    DPF_ERR( "Can't change mode; exclusive mode owned" );
	    LEAVE_DDRAW();
	    return DDERR_NOEXCLUSIVEMODE;
	}

	#ifdef USE_ALIAS
	    /*
	     * Behaviour change. Previously we did not allow a mode switch
	     * if any video memory (or implicit system memory) surfaces
	     * were locked. However, we not allow mode switches for
	     * locked VRAM surfaces as long as they don't have the Win16
	     * lock (in which case this code is irrelevant as the DirectDraw
	     * critical section will prevent them ever hitting this code).
	     * So the behaviour is now that if vram surface are locked but
	     * are not holding the Win16 lock they can mode switch away.
	     * If however, we have Win16 locked VRAM surfaces then they can't
	     * mode switch. This should only have any effect if the application
	     * holding the locks attempts the mode switch. In which case,
	     * previously it would fail if it had any VRAM or implicit system
	     * memory surfaces locked whereas now it will only fail if it has
	     * the primary or other unaliased VRAM surface locked.
	     *
	     * !!! NOTE: My gut feeling is that this should have no impact on
	     * anyone. However, we need to pull it and see.
	     */
	    if( this->dwWin16LockCnt > 0 )
	    {
		DPF_ERR( "Can't switch modes with locked surfaces holding Win16 lock!" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#else /* USE_ALIAS */
	    /*
	     * don't allow change if surfaces are locked
	     */
	    if( this->dwSurfaceLockCount )
	    {
		DPF_ERR( "Surfaces are locked, can't switch the mode" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }


    ddrval = RestoreDisplayMode( this_lcl, FALSE );
    if( ddrval == DD_OK )
    {
	this_lcl->dwPreferredMode = this->dwModeIndex;
	DPF( 5, "Preferred mode is now %ld", this_lcl->dwPreferredMode );
    }

    LEAVE_DDRAW();
    return ddrval;

} /* DD_RestoreDisplayMode */

#undef DPF_MODNAME
#define DPF_MODNAME     "EnumDisplayModes"

/*
 * DD_EnumDisplayModes
 */
HRESULT DDAPI DD_EnumDisplayModes(
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPDDSURFACEDESC lpDDSurfaceDesc,
		LPVOID lpContext,
		LPDDENUMMODESCALLBACK lpEnumCallback )
{
    DPF(2,A,"ENTERAPI: DD_EnumDisplayModes");

    if( lpDDSurfaceDesc != NULL )
    {
        DDSURFACEDESC2 ddsd2 = {sizeof(ddsd2)};

        ZeroMemory(&ddsd2,sizeof(ddsd2));

        TRY
        {
	    if( !VALID_DIRECTDRAW_PTR( ((LPDDRAWI_DIRECTDRAW_INT)lpDD) ) )
	    {
	        return DDERR_INVALIDOBJECT;
	    }
	        if( !VALID_DDSURFACEDESC_PTR( lpDDSurfaceDesc ) )
	    {
	        DPF_ERR( "Invalid surface description. Did you set the dwSize member?" );
                DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	        return DDERR_INVALIDPARAMS;
	    }

            memcpy(&ddsd2,lpDDSurfaceDesc,sizeof(*lpDDSurfaceDesc));
        }
        EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            DPF_ERR( "Exception encountered validating parameters: Bad LPDDSURFACEDESC" );
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	    return DDERR_INVALIDPARAMS;
        }

        ddsd2.dwSize = sizeof(ddsd2);
        return DD_EnumDisplayModes4(lpDD,dwFlags,&ddsd2,lpContext, (LPDDENUMMODESCALLBACK2) lpEnumCallback);
    }

    return DD_EnumDisplayModes4(lpDD,dwFlags,NULL,lpContext,(LPDDENUMMODESCALLBACK2)lpEnumCallback);
}
HRESULT DDAPI DD_EnumDisplayModes4(
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPDDSURFACEDESC2 lpDDSurfaceDesc,
		LPVOID lpContext,
		LPDDENUMMODESCALLBACK2 lpEnumCallback )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DWORD                       rc;
    DDSURFACEDESC2              ddsd;
    LPDDHALMODEINFO             pmi;
    int                         i, j;
    BOOL                        inexcl;
    BOOL                        bUseRefreshRate = FALSE;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_EnumDisplayModes4");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	if( lpDDSurfaceDesc != NULL )
	{
	    if( !VALID_DDSURFACEDESC2_PTR(lpDDSurfaceDesc) )
	    {
		DPF_ERR( "Invalid surface description" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}

	if ( dwFlags & ~DDEDM_VALID)
	{
	    DPF_ERR( "Invalid flags") ;
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
	{
	    DPF_ERR( "Invalid enum. callback routine" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * see if we're in exclusive mode
     */
    inexcl = (this->lpExclusiveOwner == this_lcl);

    if( (this_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_MODEXONLY) ||
	(dwRegFlags & DDRAW_REGFLAGS_MODEXONLY) )
    {
        /*
         * Don't allow VGA mode if ModeX only.
         * Note if either of these flags are set, there won't actually be a VGA mode in the
         * table, so we wouldn't match it anyway. The problem comes in when makeModeXModeIfNeeded
         * overrides an accelerated mode. The duplication-check loop below will attempt to
         * skip the newly modex 320x200x8 since it doesn't match the VGA 320x200x8 which it is expecting later in
         * the table. That VGA mode won't be in the table, so the dupe check code skips the mode we
         * actually wanted (since we are forcing to modex). If we turn off the app's request for
         * VGA, then that dupe check won't be made, and we should pick up the modex mode.
         */
        DPF(2,"Turning off request for standard VGA due to ModeX override");
        dwFlags &= ~DDEDM_STANDARDVGAMODES;
    }


    /*
     * go through all possible modes...
     */
    for( i=0;i<(int)this->dwNumModes;i++ )
    {
	pmi = &this->lpModeInfo[i];
	pmi = makeModeXModeIfNeeded( pmi, this_lcl );
        DPF(5,"Enumerating mode %d. %dx%d",i,pmi->dwWidth,pmi->dwHeight);

        if( ( pmi->wFlags & DDMODEINFO_DX7ONLY ) &&
            LOWERTHANDDRAW7( this_int ) )
        {
            continue;
        }

	/*
	 * check to see if this is a duplicate mode
	 */
	for (j=0; j<i; j++)
	{
	    // if we find a duplicate, break out early
	    if( (this->lpModeInfo[j].dwHeight == pmi->dwHeight) &&
		(this->lpModeInfo[j].dwWidth  == pmi->dwWidth)  &&
		(this->lpModeInfo[j].dwBPP    == pmi->dwBPP) )
	    {
		// basic mode matches, what about refresh rate?
		if( dwFlags & DDEDM_REFRESHRATES )
		{
		    // if refresh rate is not unique then the modes match
		    if( this->lpModeInfo[j].wRefreshRate == pmi->wRefreshRate )
		    {
			DPF(5, "matched: %d %d", this->lpModeInfo[j].wRefreshRate, pmi->wRefreshRate);
                        /*
                         * We have an identical mode, unless one is standard VGA and the other is not
                         */
		        if( dwFlags & DDEDM_STANDARDVGAMODES )
                        {
                            /*
                             * If the app cares about VGA modes, then a difference in the vganess
                             * of the two modes means they don't match.
                             */
                            if ( (this->lpModeInfo[j].wFlags ^ pmi->wFlags) & DDMODEINFO_STANDARDVGA )
                            {
                                /*
                                 * One mode is standard VGA and the other is not. Since
                                 * the app asked to enumerate standard VGA modes, we don't
                                 * consider this a match.
                                 */
                                continue;
                            }
                        }
                        /*
                         * Found identical refresh rate, and either app didn't care that
                         * modes are different in terms of VGAness or they are the same in
                         * terms of VGAness. Consider this a match.
                         */
			break;
		    }
		    // unique refresh rate and the app cares, the modes don't match
                    continue;
		}
		else
		{
		    // the app doesn't care about refresh rates
		    if( dwFlags & DDEDM_STANDARDVGAMODES )
                    {
                        if ( (this->lpModeInfo[j].wFlags ^ pmi->wFlags) & DDMODEINFO_STANDARDVGA )
                        {
                            /*
                             * One mode is standard VGA and the other is not. Since
                             * the app asked to enumerate standard VGA modes, we don't
                             * consider this a match.
                             */
                            continue;
                        }
                        /*
                         * Modes are the same as far as VGAness goes. drop through and break
                         * since they match
                         */
                    }
                    /*
                     * The app specified neither refresh rates nor VGA, so any mode which is
                     * duplicated at least on resolution (spatial and color) is skipped
                     */
		    break;
		}
	    }
	}

	if( j != i)
	{
	    // broke out early, mode i is not unique, move on to the next one.
	    continue;
	}

	/*
	 * check if surface description matches mode
	 */
	if ( lpDDSurfaceDesc )
	{
	    if( lpDDSurfaceDesc->dwFlags & DDSD_HEIGHT )
	    {
		if( lpDDSurfaceDesc->dwHeight != pmi->dwHeight )
		{
		    continue;
		}
	    }
	    if( lpDDSurfaceDesc->dwFlags & DDSD_WIDTH )
	    {
		if( lpDDSurfaceDesc->dwWidth != pmi->dwWidth )
		{
		    continue;
		}
	    }
	    if( lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT )
	    {
		if( lpDDSurfaceDesc->ddpfPixelFormat.dwRGBBitCount != pmi->dwBPP )
		{
		    continue;
		}
	    }
	    if( lpDDSurfaceDesc->dwFlags & DDSD_REFRESHRATE )
	    {
		bUseRefreshRate = TRUE;
		if( lpDDSurfaceDesc->dwRefreshRate != (DWORD)pmi->wRefreshRate )
		{
		    continue;
		}
	    }
	    else
	    {
		bUseRefreshRate = FALSE;
	    }
	}

	/*
	 * see if driver will allow this
	 */
        if (!(pmi->wFlags & DDMODEINFO_MODEX) )
	{
           if(this->dwFlags & DDRAWI_DISPLAYDRV)
           {

	        DWORD   cds_flags;
	        DEVMODE dm;
	        int     cds_rc;

	        makeDEVMODE( this, pmi, inexcl, bUseRefreshRate, &cds_flags, &dm );

	        cds_flags |= CDS_TEST;
	        cds_rc = xxxChangeDisplaySettingsExA(this->cDriverName, &dm, NULL, cds_flags, 0);
	        if( cds_rc != 0 )
	        {
		    if( bUseRefreshRate )
		    {
		        DPF( 1, "Mode %d not supported (%ldx%ldx%ld rr=%d), rc = %d", i,
			    pmi->dwWidth, pmi->dwHeight, pmi->dwBPP, pmi->wRefreshRate, cds_rc );
		    }
		    else
		    {
		        DPF( 1, "Mode %d not supported (%ldx%ldx%ld), rc = %d", i,
			    pmi->dwWidth, pmi->dwHeight, pmi->dwBPP, cds_rc );
		    }
		    continue;
	        }
           }
            if( !NEW_STYLE_REFRESH( this_int ) )
            {
                // We check for a display driver, merely to maintain identical behaviour to DX6-:
                // We never used to do the Monitor check on voodoos.
                if (this->dwFlags & DDRAWI_DISPLAYDRV)
                {
                    if( !MonitorCanHandleMode( this, pmi->dwWidth, pmi->dwHeight, pmi->wRefreshRate ) )
                    {
                        DPF( 1, "Monitor can't handle mode %d: (%ldx%ld rr=%d)", i,
                            pmi->dwWidth, pmi->dwHeight, pmi->wRefreshRate);
                        continue;
                    }
                }
            }
            else
            {
                // Call MonitorcanHandleMode to verify that that the size works,
                // but we'll use our own hacked mechanism to determine if the
                // refresh is supported

                if( !MonitorCanHandleMode( this, pmi->dwWidth, pmi->dwHeight, 0 ) )
                {
                    DPF( 1, "Monitor can't handle mode %d: (%ldx%ld rr=%d)", i,
                        pmi->dwWidth, pmi->dwHeight, pmi->wRefreshRate);
                    continue;
                }
                if( ( pmi->wRefreshRate > 0 ) &&
	            (dwFlags & DDEDM_REFRESHRATES) )
                {
                    if( !CanMonitorHandleRefreshRate( this, pmi->dwWidth, pmi->dwHeight, pmi->wRefreshRate ) )
                    {
                        DPF( 1, "Monitor can't handle mode %d: (%ldx%ld rr=%d)", i,
                            pmi->dwWidth, pmi->dwHeight, pmi->wRefreshRate);
                        continue;
                    }
                }
            }
        }

	if( (this->dwFlags & DDRAWI_DISPLAYDRV) &&
	    (pmi->wFlags & DDMODEINFO_MODEX) &&
	    !(this_lcl->dwLocalFlags & DDRAWILCL_ALLOWMODEX) )
	{
	    DPF( 2, "skipping ModeX or standard VGA mode" );
	    continue;
	}

	/*
	 * invoke callback with surface desc.
	 */
        ZeroMemory(&ddsd,sizeof(ddsd));
	    setSurfaceDescFromMode( this_lcl, pmi, (LPDDSURFACEDESC)&ddsd );
        if (LOWERTHANDDRAW4(this_int))
        {
            ddsd.dwSize = sizeof(DDSURFACEDESC);
        }
        else
        {
            ddsd.dwSize = sizeof(DDSURFACEDESC2);
        }

        if ((pmi->wFlags & DDMODEINFO_STEREO) &&
            !LOWERTHANDDRAW7(this_int)
            )
        {
            ddsd.ddsCaps.dwCaps2 |= DDSCAPS2_STEREOSURFACELEFT;
        }

        /*
         * Hardware default rates on NT are signified as 1Hz. We translate this to
         * 0Hz for DDraw apps. At SetDisplayMode time, 0Hz is translated back to 1Hz.
         */
	if(0==(dwFlags & DDEDM_REFRESHRATES))
        {
	    ddsd.dwRefreshRate = 0;
        }


   

	rc = lpEnumCallback( (LPDDSURFACEDESC2) &ddsd, lpContext );
	if( rc == 0 )
	{
	    break;
	}
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_EnumDisplayModes */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddmc.c ===
/*==========================================================================
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddmc.c
 *  Content: 	DirectDrawMotionComp
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-sep-97	smac	created
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
#endif
#define DPF_MODNAME "DirectDrawMotionComp"



/*
 * IsMotionCompSupported
 */
BOOL IsMotionCompSupported( LPDDRAWI_DIRECTDRAW_LCL this_lcl )
{
    if( this_lcl->lpDDCB->HALDDMotionComp.GetMoCompGuids == NULL )
    {
	return FALSE;
    }
    return TRUE;
}


/*
 * DD_MC_AddRef
 */
DWORD DDAPI DD_MC_AddRef( LPDIRECTDRAWVIDEOACCELERATOR lpDDMC )
{
    LPDDRAWI_DDMOTIONCOMP_INT        this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL        this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_AddRef");
    /* DPF( 2, "DD_MC_AddRef, pid=%08lx, obj=%08lx", GETCURRPID(), lpDDMC ); */

    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * bump refcnt
     */
    this_lcl->dwRefCnt++;
    this_int->dwIntRefCnt++;

    LEAVE_DDRAW();

    return this_int->dwIntRefCnt;

} /* DD_MC_AddRef */


/*
 * DD_MC_QueryInterface
 */
HRESULT DDAPI DD_MC_QueryInterface(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, REFIID riid, LPVOID FAR * ppvObj )
{
    LPDDRAWI_DDMOTIONCOMP_INT                this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL                this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_QueryInterface");

    /*
     * validate parms
     */
    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid motion comp pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF_ERR( "Invalid motion comp interface pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*ppvObj = NULL;
	if( !VALIDEX_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * asking for IUnknown?
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
	IsEqualIID(riid, &IID_IDirectDrawVideoAccelerator) )
    {
	/*
	 * Our IUnknown interface is the same as our V1
	 * interface.  We must always return the V1 interface
	 * if IUnknown is requested.
	 */
    	*ppvObj = (LPVOID) this_int;
	DD_MC_AddRef( *ppvObj );
	LEAVE_DDRAW();
	return DD_OK;
    }

    DPF_ERR( "IID not understood by DirectDraw" );

    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DD_MC_QueryInterface */


/*
 * DD_MC_Release
 */
DWORD DDAPI DD_MC_Release(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC )
{
    LPDDRAWI_DDMOTIONCOMP_INT   this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL   this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDHALMOCOMPCB_DESTROY     pfn;
    DWORD 			dwIntRefCnt;
    DWORD			rc;
    LPDDRAWI_DDMOTIONCOMP_INT   curr_int;
    LPDDRAWI_DDMOTIONCOMP_INT   last_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_Release");

    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid motion comp pointer" );
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
	pdrv = this_lcl->lpDD->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * decrement the reference count.  if it hits zero, free the surface
     */
    this_lcl->dwRefCnt--;
    this_int->dwIntRefCnt--;

    DPF( 5, "DD_MC_Release, Reference Count: Local = %ld Int = %ld",
         this_lcl->dwRefCnt, this_int->dwIntRefCnt );

    /*
     * interface at zero?
     */
    dwIntRefCnt = this_int->dwIntRefCnt;
    if( dwIntRefCnt == 0 )
    {
	/*
	 * Notify the HAL
	 */
        pfn = this_lcl->lpDD->lpDDCB->HALDDMotionComp.DestroyMoComp;
	if( NULL != pfn )
	{
            DDHAL_DESTROYMOCOMPDATA DestroyData;

	    DestroyData.lpDD = this_lcl->lpDD;
            DestroyData.lpMoComp = this_lcl;

            DOHALCALL( DestroyMoComp, pfn, DestroyData, rc, 0 );
	    if( ( DDHAL_DRIVER_HANDLED == rc ) && ( DD_OK != DestroyData.ddRVal ) )
	    {
	    	LEAVE_DDRAW();
	    	return DestroyData.ddRVal;
	    }
    	}

	/*
	 * Remove it from our internal list
	 */
	curr_int = pdrv->mcList;
	last_int = NULL;
	while( curr_int != this_int )
	{
	    last_int = curr_int;
	    curr_int = curr_int->lpLink;
	    if( curr_int == NULL )
	    {
		DPF_ERR( "MotionComp object not in list!" );
		LEAVE_DDRAW();
		return 0;
	    }
	}
	if( last_int == NULL )
	{
	    pdrv->mcList = pdrv->mcList->lpLink;
	}
	else
	{
	    last_int->lpLink = curr_int->lpLink;
	}

	/*
	 * just in case someone comes back in with this pointer, set
	 * an invalid vtbl & data ptr.
	 */
	this_int->lpVtbl = NULL;
	this_int->lpLcl = NULL;
	MemFree( this_int );
    }

    LEAVE_DDRAW();

    return dwIntRefCnt;
}


/*
 * IsApprovedMCGuid
 *
 * The Motion Comp API can be used as a generic escape mechanism to
 * the driver, which we don't want to happen.  One way to deter this is
 * to control which GUIDs are used.  If somebody wants to use a new GUID,
 * we should approve their need and then assign them a GUID.  Since we want
 * to reserve GUIDs that we can assign in the future, we will reserve
 * four ranges 20 GUID values and will only accept GUIDs within one of
 * these ranges.
 */
BOOL IsApprovedMCGuid( LPGUID lpGuid )
{
    return TRUE;
}


/*
 * DDMCC_CreateMotionComp
 */
HRESULT DDAPI DDMCC_CreateMotionComp(
        LPDDVIDEOACCELERATORCONTAINER lpDDMCC,
	LPGUID lpGuid,
        LPDDVAUncompDataInfo lpUncompInfo,
	LPVOID lpData,
	DWORD  dwDataSize,
	LPDIRECTDRAWVIDEOACCELERATOR FAR *lplpDDMotionComp,
	IUnknown FAR *pUnkOuter )
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    LPDDHALMOCOMPCB_CREATE cvpfn;
    LPDDRAWI_DDMOTIONCOMP_INT new_int;
    LPDDRAWI_DDMOTIONCOMP_LCL new_lcl;
    DWORD dwNumGuids;
    LPGUID lpGuidList;
    LPGUID lpTemp;
    DWORD rc;
    DWORD i;

    if( pUnkOuter != NULL )
    {
	return CLASS_E_NOAGGREGATION;
    }
    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDMCC_CreateMotionComp");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDMCC;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	this = this_lcl->lpGbl;
	#ifdef WINNT
    	    // Update DDraw handle in driver GBL object.
	    this->hDD = this_lcl->hDD;
	#endif
    	if( ( NULL == lplpDDMotionComp ) || !VALID_PTR_PTR( lplpDDMotionComp ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( lpGuid == NULL ) || !VALID_BYTE_ARRAY( lpGuid, sizeof( GUID ) ) )
    	{
            DPF_ERR ( "DDMCC_CreateMotionComp: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( ( lpUncompInfo == NULL ) ||
            !VALID_BYTE_ARRAY( lpUncompInfo, sizeof( DDVAUncompDataInfo ) ) )
    	{
            DPF_ERR ( "DDMCC_CreateMotionComp: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( !IsApprovedMCGuid( lpGuid ) )
	{
            DPF_ERR ( "DDMCC_CreateMotionComp: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwDataSize > 0 )
	{
	    if( ( lpData == NULL ) || !VALID_BYTE_ARRAY( lpData, dwDataSize ) )
    	    {
                DPF_ERR ( "DDMCC_CreateMotionComp: invalid lpData passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	}
	else
	{
	    lpData = NULL;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    if( this_lcl->dwProcessId != GetCurrentProcessId() )
    {
	DPF_ERR( "Process does not have access to object" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Verify that the GUID can be supported.
     */
    rc = DDMCC_GetMotionCompGUIDs( lpDDMCC,
	&dwNumGuids, NULL );
    if( rc != DD_OK )
    {
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    lpGuidList = (LPGUID) MemAlloc( sizeof( GUID ) * dwNumGuids );
    if( NULL == lpGuidList )
    {
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }
    rc = DDMCC_GetMotionCompGUIDs( lpDDMCC, &dwNumGuids, lpGuidList );
    if( rc != DD_OK )
    {
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    lpTemp = lpGuidList;
    for (i = 0; i < dwNumGuids; i++)
    {
    	if( ( IsEqualIID( lpGuid, lpTemp++ ) ) )
	{
	    break;
	}
    }
    MemFree( lpGuidList );
    if( i >= dwNumGuids )
    {
	DPF_ERR( "invalid GUID specified" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Allocate it
     */
    new_int = MemAlloc( sizeof( DDRAWI_DDMOTIONCOMP_INT ) +
        sizeof( DDRAWI_DDMOTIONCOMP_LCL ) );
    if( NULL == new_int )
    {
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }
    new_lcl = (LPDDRAWI_DDMOTIONCOMP_LCL) ((LPBYTE)new_int + sizeof( DDRAWI_DDMOTIONCOMP_INT ) );
    new_int->lpLcl = new_lcl;
    new_int->lpVtbl = (LPVOID)&ddMotionCompCallbacks;
    new_lcl->lpDD = this_lcl;
    new_lcl->dwProcessId = GetCurrentProcessId();
    memcpy( &(new_lcl->guid), lpGuid, sizeof( GUID ) );
    new_lcl->dwUncompWidth = lpUncompInfo->dwUncompWidth;
    new_lcl->dwUncompHeight = lpUncompInfo->dwUncompHeight;
    memcpy( &(new_lcl->ddUncompPixelFormat), &(lpUncompInfo->ddUncompPixelFormat), sizeof( DDPIXELFORMAT ) );

    /*
     * Notify the HAL that we created it
     */
    cvpfn = this_lcl->lpDDCB->HALDDMotionComp.CreateMoComp;
    if( NULL != cvpfn )
    {
        DDHAL_CREATEMOCOMPDATA CreateData;

    	CreateData.lpDD = this_lcl;
        CreateData.lpMoComp = new_lcl;
	CreateData.lpGuid = lpGuid;
        CreateData.dwUncompWidth = lpUncompInfo->dwUncompWidth;
        CreateData.dwUncompHeight = lpUncompInfo->dwUncompHeight;
        memcpy( &(CreateData.ddUncompPixelFormat), &(lpUncompInfo->ddUncompPixelFormat), sizeof( DDPIXELFORMAT ) );
	CreateData.lpData = lpData;
	CreateData.dwDataSize = dwDataSize;

        DOHALCALL( CreateMoComp, cvpfn, CreateData, rc, 0 );
	if( ( DDHAL_DRIVER_HANDLED == rc ) &&  (DD_OK != CreateData.ddRVal ) )
	{
	    LEAVE_DDRAW();
	    return CreateData.ddRVal;
	}
    }

    DD_MC_AddRef( (LPDIRECTDRAWVIDEOACCELERATOR )new_int );
    *lplpDDMotionComp = (LPDIRECTDRAWVIDEOACCELERATOR) new_int;
    new_int->lpLink = this->mcList;
    this->mcList = new_int;

    LEAVE_DDRAW();

    return DD_OK;
} /* DDMCC_CreateMotionComp */


/*
 * DDMCC_GetMotionCompFormats
 */
HRESULT DDAPI DDMCC_GetUncompressedFormats(
        LPDDVIDEOACCELERATORCONTAINER lpDDMCC,
	LPGUID lpGuid,
        LPDWORD lpdwNumFormats,
	LPDDPIXELFORMAT lpFormats )
{
    LPDDHALMOCOMPCB_GETFORMATS pfn;
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDPIXELFORMAT lpTemp;
    DDHAL_GETMOCOMPFORMATSDATA GetFormatData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDMCC_GetMotionCompFormats");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDMCC;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
            DPF_ERR ( "DDMCC_GetMotionCompFormats: Invalid DirectDraw ptr");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	#ifdef WINNT
    	    // Update DDraw handle in driver GBL object.
	    this_lcl->lpGbl->hDD = this_lcl->hDD;
	#endif
    	if( (lpdwNumFormats == NULL) || !VALID_BYTE_ARRAY( lpdwNumFormats, sizeof( LPVOID ) ) )
    	{
            DPF_ERR ( "DDMCC_GetMotionCompFormats: lpNumFormats not valid");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( NULL != lpFormats )
    	{
	    if( 0 == *lpdwNumFormats )
    	    {
                DPF_ERR ( "DDMCC_GetMotionCompFormats: lpNumFormats not valid");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	    if( !VALID_BYTE_ARRAY( lpFormats, *lpdwNumFormats * sizeof( DDPIXELFORMAT ) ) )
    	    {
                DPF_ERR ( "DDMCC_GetMotionCompFormats: invalid array passed in");
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
      	}
	if( ( lpGuid == NULL ) || !VALID_BYTE_ARRAY( lpGuid, sizeof( GUID ) ) )
    	{
            DPF_ERR ( "DDMCC_GetMotionCompFormats: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( !IsApprovedMCGuid( lpGuid ) )
	{
            DPF_ERR ( "DDMCC_GetMotionCompFormats: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_int->lpLcl->lpDDCB->HALDDMotionComp.GetMoCompFormats;
    if( pfn != NULL )
    {
	/*
	 * Get the number of formats
	 */
    	GetFormatData.lpDD = this_int->lpLcl;
    	GetFormatData.lpGuid = lpGuid;
    	GetFormatData.lpFormats = NULL;

        DOHALCALL( GetMoCompFormats, pfn, GetFormatData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return GetFormatData.ddRVal;
	}
	else if( DD_OK != GetFormatData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetFormatData.ddRVal;
	}

	if( NULL == lpFormats )
	{
    	    *lpdwNumFormats = GetFormatData.dwNumFormats;
	}

	else
	{
	    /*
	     * Make sure we have enough room for formats
	     */
	    if( GetFormatData.dwNumFormats > *lpdwNumFormats )
	    {
		lpTemp = (LPDDPIXELFORMAT) MemAlloc(
		    sizeof( DDPIXELFORMAT ) * GetFormatData.dwNumFormats );
    	        GetFormatData.lpFormats = lpTemp;
	    }
	    else
	    {
    	    	GetFormatData.lpFormats = lpFormats;
	    }

            DOHALCALL( GetMoCompFormats, pfn, GetFormatData, rc, 0 );
	    if( DDHAL_DRIVER_HANDLED != rc )
	    {
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
	    else if( DD_OK != GetFormatData.ddRVal )
	    {
	        LEAVE_DDRAW();
	        return GetFormatData.ddRVal;
	    }

	    if( GetFormatData.lpFormats != lpFormats )
	    {
		memcpy( lpFormats, lpTemp,
		    sizeof( DDPIXELFORMAT ) * *lpdwNumFormats );
		MemFree( lpTemp );
    		LEAVE_DDRAW();
		return DDERR_MOREDATA;
	    }
	    else
	    {
		*lpdwNumFormats = GetFormatData.dwNumFormats;
	    }
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DDMCC_GetMotionCompFormats */


/*
 * DDMCC_GetMotionCompGUIDs
 */
HRESULT DDAPI DDMCC_GetMotionCompGUIDs(
        LPDDVIDEOACCELERATORCONTAINER lpDDMCC,
        LPDWORD lpdwNumGuids,
	LPGUID lpGuids )
{
    LPDDHALMOCOMPCB_GETGUIDS pfn;
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPGUID lpTemp = NULL;
    LPGUID lpTempGuid;
    DDHAL_GETMOCOMPGUIDSDATA GetGuidData;
    DWORD rc;
    DWORD i;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: GetMotionCompGUIDs");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDMCC;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
            DPF_ERR ( "DDMCC_GetMotionCompGUIDs: Invalid DirectDraw ptr");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	#ifdef WINNT
    	    // Update DDraw handle in driver GBL object.
	    this_lcl->lpGbl->hDD = this_lcl->hDD;
	#endif
    	if( (lpdwNumGuids == NULL) || !VALID_BYTE_ARRAY( lpdwNumGuids, sizeof( LPVOID ) ) )
    	{
            DPF_ERR ( "DDMCC_GetMotionCompGuids: lpNumGuids not valid");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( NULL != lpGuids )
    	{
	    if( 0 == *lpdwNumGuids )
    	    {
                DPF_ERR ( "DDMCC_GetMotionCompGUIDs: lpNumGuids not valid");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	    if( !VALID_BYTE_ARRAY( lpGuids, *lpdwNumGuids * sizeof( GUID ) ) )
    	    {
                DPF_ERR ( "DDMCC_GetMotionCompGUIDs: invalid array passed in");
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
      	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_int->lpLcl->lpDDCB->HALDDMotionComp.GetMoCompGuids;
    if( pfn != NULL )
    {
	/*
	 * Get the number of GUIDs
	 */
    	GetGuidData.lpDD = this_int->lpLcl;
    	GetGuidData.lpGuids = NULL;

        DOHALCALL( GetMoCompGuids, pfn, GetGuidData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return GetGuidData.ddRVal;
	}
	else if( DD_OK != GetGuidData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetGuidData.ddRVal;
	}

	if( NULL == lpGuids )
	{
    	    *lpdwNumGuids = GetGuidData.dwNumGuids;
	}

	else
	{
	    /*
	     * Make sure we have enough room for GUIDs
	     */
	    if( GetGuidData.dwNumGuids > *lpdwNumGuids )
	    {
		lpTemp = (LPGUID) MemAlloc(
		    sizeof( GUID ) * GetGuidData.dwNumGuids );
    	        GetGuidData.lpGuids = lpTemp;
	    }
	    else
	    {
    	    	GetGuidData.lpGuids = lpGuids;
	    }

            DOHALCALL( GetMoCompGuids, pfn, GetGuidData, rc, 0 );
	    if( DDHAL_DRIVER_HANDLED != rc )
	    {
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
	    else if( DD_OK != GetGuidData.ddRVal )
	    {
	        LEAVE_DDRAW();
	        return GetGuidData.ddRVal;
	    }

	    /*
	     * If the driver returned a GUID that is not from our valid
	     * range, fail the call
	     */
	    lpTempGuid = GetGuidData.lpGuids;
	    for( i = 0; i < GetGuidData.dwNumGuids; i++ )
	    {
		if( !IsApprovedMCGuid( lpTempGuid ) )
		{
		    if( lpTemp != NULL )
		    {
			MemFree( lpTemp );
		    }
		    DPF_ERR("The driver returned a GUID that DDraw didn't assign");
		    LEAVE_DDRAW();
	            return DDERR_GENERIC;
		}
		lpTempGuid++;
	    }

	    if( GetGuidData.lpGuids != lpGuids )
	    {
		memcpy( lpGuids, lpTemp,
		    sizeof( GUID ) * *lpdwNumGuids );
		MemFree( lpTemp );
    		LEAVE_DDRAW();
		return DDERR_MOREDATA;
	    }
	    else
	    {
		*lpdwNumGuids = GetGuidData.dwNumGuids;
	    }
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DDMCC_GetMotionCompGUIDs */

/*
 * DDMCC_GetCompBuffInfo
 */
HRESULT DDAPI DDMCC_GetCompBuffInfo(
        LPDDVIDEOACCELERATORCONTAINER lpDDMCC,
	LPGUID lpGuid,
        LPDDVAUncompDataInfo lpUncompInfo,
        LPDWORD lpdwNumBuffInfo,
        LPDDVACompBufferInfo lpCompBuffInfo )
{
    LPDDHALMOCOMPCB_GETCOMPBUFFINFO pfn;
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDMCCOMPBUFFERINFO lpTemp = NULL;
    DDHAL_GETMOCOMPCOMPBUFFDATA GetCompBuffData;
    DWORD rc;

    ENTER_DDRAW();

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDMCC;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
            DPF_ERR ( "DDMCC_GetCompBuffInfo: Invalid DirectDraw ptr");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
        if( (lpdwNumBuffInfo == NULL) || !VALID_BYTE_ARRAY( lpdwNumBuffInfo, sizeof( LPVOID ) ) )
    	{
            DPF_ERR ( "DDMCC_GetCompBuffInfo: lpNumBuffInfo not valid");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( NULL != lpCompBuffInfo )
    	{
            if( 0 == *lpdwNumBuffInfo )
    	    {
                DPF_ERR ( "DDMCC_GetCompBuffInfo lpCompBuffInfo not valid");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
            if( !VALID_BYTE_ARRAY( lpCompBuffInfo, *lpdwNumBuffInfo * sizeof( DDVACompBufferInfo ) ) )
    	    {
                DPF_ERR ( "DDMCC_GetCompBuffInfo: invalid array passed in");
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
      	}
        if( ( lpUncompInfo == NULL ) ||
            !VALID_BYTE_ARRAY( lpUncompInfo, sizeof( DDVAUncompDataInfo ) ) )
    	{
            DPF_ERR ( "DDMCC_GetCompBuffInfo: invalid lpUncompInfo passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( lpGuid == NULL ) || !VALID_BYTE_ARRAY( lpGuid, sizeof( GUID ) ) )
    	{
            DPF_ERR ( "DDMCC_GetCompBuffInfo: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( !IsApprovedMCGuid( lpGuid ) )
	{
            DPF_ERR ( "DDMCC_GetCompBuffInfo: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_int->lpLcl->lpDDCB->HALDDMotionComp.GetMoCompBuffInfo;
    if( pfn != NULL )
    {
	/*
         * Get the number of buffer types
	 */
        GetCompBuffData.lpDD = this_int->lpLcl;
        GetCompBuffData.lpGuid = lpGuid;
        GetCompBuffData.dwWidth= lpUncompInfo->dwUncompWidth;
        GetCompBuffData.dwHeight= lpUncompInfo->dwUncompHeight;
        memcpy( &GetCompBuffData.ddPixelFormat,
            &(lpUncompInfo->ddUncompPixelFormat), sizeof( DDPIXELFORMAT ) );
        GetCompBuffData.lpCompBuffInfo = NULL;
        GetCompBuffData.dwNumTypesCompBuffs = 0;

        DOHALCALL( GetMoCompBuffInfo, pfn, GetCompBuffData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
            return GetCompBuffData.ddRVal;
	}
        else if( DD_OK != GetCompBuffData.ddRVal )
	{
	    LEAVE_DDRAW();
            return GetCompBuffData.ddRVal;
	}

        if( NULL == lpCompBuffInfo )
	{
            *lpdwNumBuffInfo = GetCompBuffData.dwNumTypesCompBuffs;
	}

	else
	{
	    /*
	     * Make sure we have enough room for formats
	     */
            if( GetCompBuffData.dwNumTypesCompBuffs > *lpdwNumBuffInfo )
	    {
                lpTemp = (LPDDMCCOMPBUFFERINFO) MemAlloc(
                    sizeof( DDMCCOMPBUFFERINFO ) * GetCompBuffData.dwNumTypesCompBuffs );
                GetCompBuffData.lpCompBuffInfo = lpTemp;
	    }
	    else
	    {
                GetCompBuffData.lpCompBuffInfo = (LPDDMCCOMPBUFFERINFO)lpCompBuffInfo;
	    }

            DOHALCALL( GetMoCompBuffInfo, pfn, GetCompBuffData, rc, 0 );
	    if( DDHAL_DRIVER_HANDLED != rc )
	    {
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
            else if( DD_OK != GetCompBuffData.ddRVal )
	    {
	        LEAVE_DDRAW();
                return GetCompBuffData.ddRVal;
	    }

            if( GetCompBuffData.lpCompBuffInfo != (LPDDMCCOMPBUFFERINFO)lpCompBuffInfo )
	    {
                memcpy( lpCompBuffInfo, lpTemp,
                    sizeof( DDVACompBufferInfo ) * *lpdwNumBuffInfo );
		MemFree( lpTemp );
    		LEAVE_DDRAW();
		return DDERR_MOREDATA;
	    }
	    else
	    {
                *lpdwNumBuffInfo = GetCompBuffData.dwNumTypesCompBuffs;
	    }
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DDMCC_GetCompBuffInfo */

/*
 * DDMCC_GetInternalMemInfo
 */
HRESULT DDAPI DDMCC_GetInternalMoCompInfo(
        LPDDVIDEOACCELERATORCONTAINER lpDDMCC,
	LPGUID lpGuid,
        LPDDVAUncompDataInfo lpUncompInfo,
        LPDDVAInternalMemInfo lpMemInfo )
{
    LPDDHALMOCOMPCB_GETINTERNALINFO pfn;
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    DDHAL_GETINTERNALMOCOMPDATA GetInternalData;
    DWORD rc;

    ENTER_DDRAW();

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDMCC;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
            DPF_ERR ( "DDMCC_GetInternalMemInfo: Invalid DirectDraw ptr");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
        if( ( lpUncompInfo == NULL ) ||
            !VALID_BYTE_ARRAY( lpUncompInfo, sizeof( DDVAUncompDataInfo ) ) )
    	{
            DPF_ERR ( "DDMCC_GetInternalMemInfo: invalid lpUncompInfo passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( ( lpMemInfo == NULL ) ||
            !VALID_BYTE_ARRAY( lpMemInfo, sizeof( DDVAInternalMemInfo ) ) )
    	{
            DPF_ERR ( "DDMCC_GetInternalMemInfo: invalid lpUncompInfo passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( lpGuid == NULL ) || !VALID_BYTE_ARRAY( lpGuid, sizeof( GUID ) ) )
    	{
            DPF_ERR ( "DDMCC_GetInternalMemInfo: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( !IsApprovedMCGuid( lpGuid ) )
	{
            DPF_ERR ( "DDMCC_GetInternalMemInfo: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    lpMemInfo->dwScratchMemAlloc = 0;
    pfn = this_int->lpLcl->lpDDCB->HALDDMotionComp.GetInternalMoCompInfo;
    if( pfn != NULL )
    {
	/*
         * Get the number of buffer types
	 */
        GetInternalData.lpDD = this_int->lpLcl;
        GetInternalData.lpGuid = lpGuid;
        GetInternalData.dwWidth= lpUncompInfo->dwUncompWidth;
        GetInternalData.dwHeight= lpUncompInfo->dwUncompHeight;
        memcpy( &GetInternalData.ddPixelFormat,
            &(lpUncompInfo->ddUncompPixelFormat), sizeof( DDPIXELFORMAT ) );

        DOHALCALL( GetInternalMoCompInfo, pfn, GetInternalData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
            return GetInternalData.ddRVal;
	}
        else if( DD_OK != GetInternalData.ddRVal )
	{
	    LEAVE_DDRAW();
            return GetInternalData.ddRVal;
	}
        lpMemInfo->dwScratchMemAlloc = GetInternalData.dwScratchMemAlloc;
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DDMCC_GetInternalMemInfo */

/*
 * DD_MC_BeginFrame
 */
HRESULT DDAPI DD_MC_BeginFrame(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC,
                               LPDDVABeginFrameInfo lpInfo )
{
    LPDDRAWI_DDMOTIONCOMP_INT this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL this_lcl;
    DDHAL_BEGINMOCOMPFRAMEDATA BeginFrameData;
    LPDDHALMOCOMPCB_BEGINFRAME pfn;
    DWORD i;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_BeginFrame");

    /*
     * Validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
        if( ( lpInfo == NULL ) || !VALID_BYTE_ARRAY( lpInfo, sizeof( DDVABeginFrameInfo ) ) )
    	{
            DPF_ERR ( "DD_MC_BeginFrame: invalid structure passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( ( lpInfo->pddDestSurface == NULL ) ||
            !VALID_DIRECTDRAWSURFACE_PTR( ((LPDDRAWI_DDRAWSURFACE_INT)lpInfo->pddDestSurface) ) )
        {
            DPF_ERR ( "DD_MC_BeginFrame: invalid dest surface specified");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( lpInfo->dwSizeInputData > 0 )
	{
            if( ( lpInfo->pInputData == NULL ) ||
                !VALID_BYTE_ARRAY( lpInfo->pInputData, lpInfo->dwSizeInputData ) )
    	    {
                DPF_ERR ( "DD_MC_BeginFrame: invalid lpInputData passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	}
        if( lpInfo->dwSizeOutputData > 0 )
	{
            if( ( lpInfo->pOutputData == NULL ) ||
                !VALID_BYTE_ARRAY( lpInfo->pOutputData, lpInfo->dwSizeOutputData ) )
    	    {
                DPF_ERR ( "DD_MC_BeginFrame: invalid lpOutputData passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Call the HAL
     */
    pfn = this_lcl->lpDD->lpDDCB->HALDDMotionComp.BeginMoCompFrame;
    if( pfn != NULL )
    {
    	BeginFrameData.lpDD = this_lcl->lpDD;
        BeginFrameData.lpMoComp = this_lcl;
        BeginFrameData.lpDestSurface = ((LPDDRAWI_DDRAWSURFACE_INT)lpInfo->pddDestSurface)->lpLcl;
        BeginFrameData.dwInputDataSize = lpInfo->dwSizeInputData;
        BeginFrameData.lpInputData = BeginFrameData.dwInputDataSize == 0 ? NULL : lpInfo->pInputData;
        BeginFrameData.dwOutputDataSize = lpInfo->dwSizeOutputData;
        BeginFrameData.lpOutputData = BeginFrameData.dwOutputDataSize == 0 ? NULL : lpInfo->pOutputData;

        DOHALCALL( BeginMoCompFrame, pfn, BeginFrameData, rc, 0 );

        if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
	}
        if( BeginFrameData.ddRVal == DD_OK )
        {
            if( BeginFrameData.dwOutputDataSize > 0 )
            {
                lpInfo->dwSizeOutputData = BeginFrameData.dwOutputDataSize;
            }
        }
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return BeginFrameData.ddRVal;
}


/*
 * DD_MC_EndFrame
 */
HRESULT DDAPI DD_MC_EndFrame(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC,
        LPDDVAEndFrameInfo lpInfo )
{
    LPDDRAWI_DDMOTIONCOMP_INT this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL this_lcl;
    DDHAL_ENDMOCOMPFRAMEDATA EndFrameData;
    LPDDHALMOCOMPCB_ENDFRAME pfn;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_EndFrame");

    /*
     * Validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
        if( ( lpInfo == NULL ) || !VALID_BYTE_ARRAY( lpInfo, sizeof( DDVAEndFrameInfo ) ) )
    	{
            DPF_ERR ( "DD_MC_EndFrame: invalid structure passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( lpInfo->dwSizeMiscData > 0 )
	{
            if( ( lpInfo->pMiscData == NULL ) ||
                !VALID_BYTE_ARRAY( lpInfo->pMiscData, lpInfo->dwSizeMiscData ) )
    	    {
                DPF_ERR ( "DD_MC_BeginFrame: invalid lpData passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Call the HAL
     */
    pfn = this_lcl->lpDD->lpDDCB->HALDDMotionComp.EndMoCompFrame;
    if( pfn != NULL )
    {
    	EndFrameData.lpDD = this_lcl->lpDD;
        EndFrameData.lpMoComp = this_lcl;
        EndFrameData.dwInputDataSize = lpInfo->dwSizeMiscData;
        EndFrameData.lpInputData = EndFrameData.dwInputDataSize > 0 ? lpInfo->pMiscData : NULL;

        DOHALCALL( EndMoCompFrame, pfn, EndFrameData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return EndFrameData.ddRVal;
}


/*
 * DD_MC_RenderMacroBlocks
 */
HRESULT DDAPI DD_MC_RenderMacroBlocks(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC,
        DWORD dwFunction, LPVOID lpInData, DWORD dwInSize, LPVOID lpOutData,
        DWORD dwOutSize, DWORD dwNumBuffers, LPDDVABUFFERINFO lpBuffInfo )
{
    LPDDRAWI_DDMOTIONCOMP_INT this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL this_lcl;
    DDHAL_RENDERMOCOMPDATA RenderData;
    LPDDHALMOCOMPCB_RENDER pfn;
    LPDDMCBUFFERINFO lpTempArray = NULL;
    LPDDMCBUFFERINFO lpTempDest;
    LPDDVABUFFERINFO lpTempSrc;
    DWORD rc;
    DWORD i;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_RenderMacroBlocks");

    /*
     * Validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
        if( dwNumBuffers > 0 )
	{
            if( ( lpBuffInfo== NULL ) ||
                !VALID_BYTE_ARRAY( lpBuffInfo, sizeof( DDVABUFFERINFO) * dwNumBuffers ) )
    	    {
                DPF_ERR ( "DD_MC_RenderMacroBlocks: invalid buffer pointer passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }

            if( lpInData == NULL )
            {
                dwInSize = 0;
            }
            else if( !VALID_BYTE_ARRAY( lpInData, dwInSize) )
    	    {
                DPF_ERR ( "DD_MC_RenderMacroBlocks: invalid input data pointer passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }

            if( lpOutData == NULL )
            {
                dwOutSize = 0;
            }
            else if( !VALID_BYTE_ARRAY( lpOutData, dwOutSize) )
    	    {
                DPF_ERR ( "DD_MC_RenderMacroBlocks: invalid output data pointer passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }

            lpTempArray = LocalAlloc( LPTR, sizeof( DDMCBUFFERINFO ) * dwNumBuffers );
            if( lpTempArray == NULL )
            {
                LEAVE_DDRAW();
                return DDERR_OUTOFMEMORY;
            }
            lpTempSrc = lpBuffInfo;
            lpTempDest = lpTempArray;
            for( i = 0; i < dwNumBuffers; i++)
            {
                if( ( lpTempSrc->pddCompSurface == NULL ) ||
                    !VALID_DIRECTDRAWSURFACE_PTR( ((LPDDRAWI_DDRAWSURFACE_INT)lpTempSrc->pddCompSurface) ) )
                {
                    if( lpTempArray != NULL )
                    {
                        LocalFree( lpTempArray );
                    }
                    DPF_ERR ( "DD_MC_RendermacroBlockse: invalid surface specified");
                    LEAVE_DDRAW();
                    return DDERR_INVALIDPARAMS;
                }
                lpTempDest->dwSize = lpTempSrc->dwSize;
                lpTempDest->lpCompSurface = ((LPDDRAWI_DDRAWSURFACE_INT)(lpTempSrc->pddCompSurface))->lpLcl;
                lpTempDest->dwDataOffset = lpTempSrc->dwDataOffset;
                lpTempDest++->dwDataSize = lpTempSrc++->dwDataSize;
            }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        if( lpTempArray != NULL )
        {
            LocalFree( lpTempArray );
        }
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Call the HAL
     */
    pfn = this_lcl->lpDD->lpDDCB->HALDDMotionComp.RenderMoComp;
    if( pfn != NULL )
    {
        RenderData.lpDD = this_lcl->lpDD;
        RenderData.lpMoComp = this_lcl;
        RenderData.dwNumBuffers = dwNumBuffers;
        RenderData.lpBufferInfo = lpTempArray;
        RenderData.lpInputData = lpInData;
        RenderData.dwInputDataSize = dwInSize;
        RenderData.lpOutputData = lpOutData;
        RenderData.dwOutputDataSize = dwOutSize;
        RenderData.dwFunction = dwFunction;

        DOHALCALL( RenderMoComp, pfn, RenderData, rc, 0 );

        if( lpTempArray != NULL )
        {
            LocalFree( lpTempArray );
        }
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
	}
    }
    else
    {
        if( lpTempArray != NULL )
        {
            LocalFree( lpTempArray );
        }
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return RenderData.ddRVal;
}


/*
 * DD_MC_QueryRenderStatus
 */
HRESULT DDAPI DD_MC_QueryRenderStatus(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC,
        LPDIRECTDRAWSURFACE7 lpSurface, DWORD dwFlags )
{
    LPDDRAWI_DDMOTIONCOMP_INT this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT surf_int;
    DDHAL_QUERYMOCOMPSTATUSDATA QueryData;
    LPDDHALMOCOMPCB_QUERYSTATUS pfn;
    DWORD rc;
    DWORD i;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_QueryRenderStatus");

    /*
     * Validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;

        surf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpSurface;
        if( ( surf_int == NULL ) ||
            !VALID_DIRECTDRAWSURFACE_PTR( surf_int ) )
        {
            DPF_ERR("DD_MD_QueryRenderStatus: Invalid surface passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
        }

        if( dwFlags & ~(DDMCQUERY_VALID) )
        {
            DPF_ERR("DD_MD_QueryRenderStatus: Invalid flag specified");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Call the HAL
     */
    pfn = this_lcl->lpDD->lpDDCB->HALDDMotionComp.QueryMoCompStatus;
    if( pfn != NULL )
    {
    	QueryData.lpDD = this_lcl->lpDD;
        QueryData.lpMoComp = this_lcl;
        QueryData.lpSurface = surf_int->lpLcl;
        QueryData.dwFlags = dwFlags;

        DOHALCALL( QueryMoCompStatus, pfn, QueryData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return QueryData.ddRVal;
}

/*
 * ProcessMotionCompCleanup
 *
 * A process is done, clean up any motion comp objects that it may
 * still exist.
 *
 * NOTE: we enter with a lock taken on the DIRECTDRAW object.
 */
void ProcessMotionCompCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDMOTIONCOMP_INT        pmc_int;
    LPDDRAWI_DDMOTIONCOMP_LCL        pmc_lcl;
    LPDDRAWI_DDMOTIONCOMP_INT        pmcnext_int;
    DWORD			rcnt;
    ULONG			rc;

    /*
     * run through all motion comp objects owned by the driver object, and find ones
     * that have been accessed by this process.  If the pdrv_lcl parameter
     * is non-null, only delete motion comp objects created by that local driver object.
     */
    pmc_int = pdrv->mcList;
    DPF( 4, "ProcessMotionCompCleanup" );
    while( pmc_int != NULL )
    {
	pmc_lcl = pmc_int->lpLcl;
	pmcnext_int = pmc_int->lpLink;
	rc = 1;
	if( ( pmc_lcl->dwProcessId == pid ) &&
	    ( (NULL == pdrv_lcl) || (pmc_lcl->lpDD == pdrv_lcl) ) )
	{
	    /*
	     * release the references by this process
	     */
	    rcnt = pmc_int->dwIntRefCnt;
	    DPF( 5, "Process %08lx had %ld accesses to motion comp %08lx", pid, rcnt, pmc_int );
	    while( rcnt >  0 )
	    {
		rc = DD_MC_Release( (LPDIRECTDRAWVIDEOACCELERATOR) pmc_int );
		pmcnext_int = pdrv->mcList;
		if( rc == 0 )
		{
		    break;
		}
		rcnt--;
	    }
	}
	else
	{
            DPF( 5, "Process %08lx had no accesses to motion comp object %08lx", pid, pmc_int );
	}
	pmc_int = pmcnext_int;
    }
    DPF( 4, "Leaving ProcessMotionCompCleanup");

} /* ProcessMotionCompCleanup */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddoptsur.c ===
//-------------------------------------------------------------------------------
//
//  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
//
//  File:       ddoptsur.c
//  Content:    DirectDraw Optimized Surface support
//  History:
//   Date      By       Reason
//   ====      ==       ======
//   2-nov-97  anankan  Original implementation
//
//-------------------------------------------------------------------------------

#include "ddrawpr.h"

//-------------------------------------------------------------------------------
//
// IsRecognizedOptSurfaceGUID
//
// Checks to see if the GUID passed is recognized by the driver.
// This is done by looking at the list maintained in LPDDRAWI_DIRECTDRAW_GBL
//
//-------------------------------------------------------------------------------
BOOL
IsRecognizedOptSurfaceGUID(
    LPDDRAWI_DIRECTDRAW_GBL  this,
    LPGUID                   pGuid)
{
    int i;

    LPDDOPTSURFACEINFO pOptSurfInfo;
    pOptSurfInfo = this->lpDDOptSurfaceInfo;

    for (i = 0; i < (int)pOptSurfInfo->dwNumGuids; i++)
    {
        if (IsEqualIID(pGuid, &(pOptSurfInfo->lpGuidArray[i])))
            return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------------
//
// ValidateSurfDesc
//
// Fill in correct surf desc to be passed to the driver
//
//-------------------------------------------------------------------------------
HRESULT
ValidateSurfDesc(
    LPDDSURFACEDESC2         pOrigSurfDesc
    )
{
    DWORD   caps = pOrigSurfDesc->ddsCaps.dwCaps;

    //
    // check for no caps at all!
    //
    if( caps == 0 )
    {
    	DPF_ERR( "no caps specified" );
        return DDERR_INVALIDCAPS;
    }

    //
    // check for bogus caps.
    //
    if( caps & ~DDSCAPS_VALID )
    {
        DPF_ERR( "Create surface: invalid caps specified" );
        return DDERR_INVALIDCAPS;
    }

    //
    // Anything other than a texture is not allowed
    // ATTENTION: some more flags need to be checked
    //
    if(caps & (DDSCAPS_EXECUTEBUFFER      |
               DDSCAPS_BACKBUFFER         |
               DDSCAPS_FRONTBUFFER        |
               DDSCAPS_OFFSCREENPLAIN     |
               DDSCAPS_PRIMARYSURFACE     |
               DDSCAPS_PRIMARYSURFACELEFT |
               DDSCAPS_VIDEOPORT          |
               DDSCAPS_ZBUFFER            |
               DDSCAPS_OWNDC              |
               DDSCAPS_OVERLAY            |
               DDSCAPS_3DDEVICE           |
               DDSCAPS_ALLOCONLOAD)
        )
    {
        DPF_ERR( "currently only textures can be optimized" );
        return DDERR_INVALIDCAPS;
    }

    if( !(caps & DDSCAPS_TEXTURE) )
    {
        DPF_ERR( "DDSCAPS_TEXTURE needs to be set" );
        return DDERR_INVALIDCAPS;
    }

    // Pixelformat not specified ?
    if (!(pOrigSurfDesc->dwFlags & DDSD_PIXELFORMAT))
    {
        DPF_ERR( "Pixel format needs to be set" );
        return DDERR_INVALIDCAPS;
    }

    return DD_OK;
}

//-------------------------------------------------------------------------------
//
// DD_CanOptimizeSurface
//
// Check to see if a surface given the description be optimized.
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_CanOptimizeSurface(
    LPDIRECTDRAW             pDD,
    LPDDSURFACEDESC2         pDDSurfDesc,
    LPDDOPTSURFACEDESC       pDDOptSurfDesc,
    BOOL                    *bTrue
    )
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    DDHAL_CANOPTIMIZESURFACEDATA ddhal_cosd;
    LPDDOPTSURFACEINFO    pDDOptSurfInfo = NULL;
    HRESULT ddrval = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_CanOptimizeSurface");

    //
    // Setup DPF stuff
    //
    DPF_ENTERAPI(pDD);

    //
    // Parameter validation
    //
    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) pDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            DPF_ERR( "Invalid driver object passed" );
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( this->dwModeIndex == DDUNSUPPORTEDMODE )
        {
            DPF_ERR( "Driver is in an unsupported mode" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_UNSUPPORTEDMODE);
            return DDERR_UNSUPPORTEDMODE;
        }

        if( !VALID_DDSURFACEDESC2_PTR( pDDSurfDesc ) )
        {
            DPF_ERR( "Invalid surface description. Did you set the dwSize member?" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }

        if( !VALID_DDOPTSURFACEDESC_PTR( pDDOptSurfDesc ) )
        {
            DPF_ERR( "Invalid optimized surface description. Did you set the dwSize member?" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }

        if( !VALID_PTR( bTrue,  sizeof (*bTrue)) )
        {
            DPF_ERR( "Invalid Boolean pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *bTrue  = TRUE;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_INVALIDPARAMS);
        return DDERR_INVALIDPARAMS;
    }

    //
    // Quit with error if:
    // 1) No hardware
    // 2) Hardware doesnt support optimized surfaces
    // 3) pSurfDesc does not provide useful information
    // 4) Is the guid one of the recognized ones
    // 5) The driver fails for some reason
    //

    // 1)
    if( this->dwFlags & DDRAWI_NOHARDWARE )
    {
        DPF_ERR ("No hardware present");
        LEAVE_DDRAW();
        return DDERR_NODIRECTDRAWHW;
    }

    // 2)
    if ((0 == this->lpDDOptSurfaceInfo) ||
        !(this->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        DPF_ERR ("Optimized surfaces not supported");
        LEAVE_DDRAW();
        return DDERR_NOOPTSURFACESUPPORT;
    }

    // 3)
    ddrval = ValidateSurfDesc (pDDSurfDesc);
    if (ddrval != DD_OK)
    {
        DPF_ERR ("Invalid surface description");
        LEAVE_DDRAW();
        return ddrval;
    }

    // 4)
    if (!IsRecognizedOptSurfaceGUID (this, &(pDDOptSurfDesc->guid)))
    {
        DPF_ERR( "Not a recognized GUID" );
        LEAVE_DDRAW();
        return DDERR_UNRECOGNIZEDGUID;
    }

    // Call the driver
    ZeroMemory (&ddhal_cosd, sizeof (ddhal_cosd));
    ddhal_cosd.lpDD            = this_lcl;
    ddhal_cosd.ddOptSurfDesc   = *pDDOptSurfDesc;
    ddhal_cosd.ddSurfaceDesc   = *pDDSurfDesc;

    // Make the HAL call
    pDDOptSurfInfo = this->lpDDOptSurfaceInfo;
    DOHALCALL(CanOptimizeSurface, pDDOptSurfInfo->CanOptimizeSurface, ddhal_cosd, ddrval, FALSE );

    if (ddrval != DD_OK)
    {
        DPF_ERR ("LoadUnOptSurface failed in the driver");
        LEAVE_DDRAW();
        return ddrval;
    }

    if (ddhal_cosd.bCanOptimize != 0)
    {
        *bTrue = TRUE;
    }
    else
    {
        *bTrue = FALSE;
    }

    LEAVE_DDRAW();
    return DD_OK;
}

//-------------------------------------------------------------------------------
//
// CreateAndLinkUninitializedSurface
//
// Create a surface, and link it into the chain.
// We create a single surface place-holder  here, real work is done at the
// Load/Copy time.
//
//-------------------------------------------------------------------------------
HRESULT
CreateAndLinkUnintializedSurface(
    LPDDRAWI_DIRECTDRAW_LCL this_lcl,
    LPDDRAWI_DIRECTDRAW_INT this_int,
    LPDIRECTDRAWSURFACE FAR *ppDDSurface
    )
{
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   pSurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf;
    LPVOID                     *ppSurf_gbl_more;
    DDSCAPS                     caps;
    DDPIXELFORMAT               ddpf;
    int                         surf_size;
    int                         surf_size_lcl;
    int                         surf_size_lcl_more;
#ifdef WIN95
    DWORD                       ptr16;
#endif
    HRESULT                     ddrval = DD_OK;

    // DDraw-global
    this = this_lcl->lpGbl;
    #ifdef WINNT
	// Update DDraw handle in driver GBL object.
	this->hDD = this_lcl->hDD;
    #endif //WINNT

    //
    // Zero the caps
    //
    ZeroMemory (&caps, sizeof (DDCAPS));

    //
    // PixelFormat: Mark it as an empty surface
    //
    ZeroMemory (&ddpf, sizeof (ddpf));
    ddpf.dwSize = sizeof (ddpf);
    ddpf.dwFlags = DDPF_EMPTYSURFACE;


    //
    // Allocate the internal Surface structure and initialize the fields
    //
    //
    // fail requests for non-local video memory allocations if the driver does
    // not support non-local video memory.
    //
    // NOTE: Should we really do this or just let the allocation fail from
    // naturalcauses?
    //
    // ALSO NOTE: Don't have to worry about emulation as no emulated surface
    // should
    // ever get this far with DDSCAPS_NONLOCALVIDMEM set.
    //
    // ALSO ALSO NOTE: Should we also fail DDSCAPS_LOCALVIDMEM if the driver does
    // not support DDSCAPS_NONLOCALVIDMEM. My feeling is that we should allow.
    // DDSCAPS_LOCALVIDMEM is legal with a non AGP driver - redundant but legal.
    //

    //
    // allocate the surface struct, allowing for overlay and pixel
    // format data
    //
    // NOTE: This single allocation can allocate space for local surface
    // structure (DDRAWI_DDRAWSURFACE_LCL), the additional local surface
    // structure (DDRAWI_DDRAWSURFACE_MORE) and the global surface structure
    // (DDRAWI_DDRAWSURFACE_GBL). And now the global surface more
    // structure too (DDRAWI_DDRAWSURFACE_GBL_MORE). As both the local and
    // global objects can be variable sized this can get pretty complex.
    // Additionally, we have 4 bytes just before the surface_gbl that points to
    // the surface_gbl_more.
    //
    // CAVEAT: All future surfaces that share this global all point to this
    // allocation. The last surface's release has to free it. During
    // InternalSurfaceRelease (in ddsiunk.c) a calculation is made to determine
    // the start of this memory allocation. If the surface being released is
    // the first one, then freeing "this_lcl" will free the whole thing. If
    // not, then "this_lcl->lpGbl - (Surface_lcl + surface_more + more_ptr)"
    // is computed. Keep this layout in synch with code in ddsiunk.c.
    //
    //  The layout of the various objects in the allocation is as follows:
    //
    // +-----------------+---------------+----+------------+-----------------+
    // | SURFACE_LCL     | SURFACE_MORE  |More| SURFACE_GBL| SURFACE_GBL_MORE|
    // | (variable)      |               |Ptr | (variable) |         |
    // +-----------------+---------------+----+------------+-----------------+
    // <- surf_size_lcl ->           |                   |
    // <- surf_size_lcl_more ------------>                   |
    // <- surf_size --------------------------------------------------------->
    //
    //

    // ATTENTION: Currently ignores to account for the overlays
#if 0
    surf_size_lcl = sizeof( DDRAWI_DDRAWSURFACE_LCL );
#endif
    surf_size_lcl = offsetof( DDRAWI_DDRAWSURFACE_LCL, ddckCKSrcOverlay );
    surf_size_lcl_more = surf_size_lcl + sizeof( DDRAWI_DDRAWSURFACE_MORE );

    // Assume that the pixelformat is present for allocating the GBL
    surf_size = surf_size_lcl_more + sizeof( DDRAWI_DDRAWSURFACE_GBL );
#if 0
    surf_size = surf_size_lcl_more + offsetof( DDRAWI_DDRAWSURFACE_GBL,
                                               ddpfSurface );
#endif

    // Need to allocate a pointer just before the SURFACE_GBL to
    // point to the beginning of the GBL_MORE.
    surf_size += sizeof( LPDDRAWI_DDRAWSURFACE_GBL_MORE );

    // Need to allocate a SURFACE_GBL_MORE too
    surf_size += sizeof( DDRAWI_DDRAWSURFACE_GBL_MORE );

    DPF( 8, "Allocating struct (%ld)", surf_size );

#ifdef WIN95
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) MemAlloc16 (surf_size, &ptr16);
#else
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) MemAlloc (surf_size);
#endif

    if (pSurf_lcl == NULL)
    {
        DPF_ERR ("Failed to allocate internal surface structure");
        ddrval =  DDERR_OUTOFMEMORY;
        goto error_exit_create_link;
    }

    // Initialize SURFACE_GBL pointer
    // skipping 4 bytes for a pointer to the GBL_MORE
    ZeroMemory (pSurf_lcl, surf_size);
    pSurf_lcl->lpGbl = (LPVOID) (((LPSTR) pSurf_lcl) + surf_size_lcl_more +
                                 sizeof (LPVOID));

    // Initialize GBL_MORE pointer
    ppSurf_gbl_more = (LPVOID *)((LPBYTE)pSurf_lcl->lpGbl - sizeof (LPVOID));
    *ppSurf_gbl_more = (LPVOID) ((LPBYTE)pSurf_lcl + surf_size
                                 - sizeof (DDRAWI_DDRAWSURFACE_GBL_MORE));

    // Sanity Check
    DDASSERT( *ppSurf_gbl_more ==
              (LPVOID) GET_LPDDRAWSURFACE_GBL_MORE(pSurf_lcl->lpGbl));

    //
    // 1) Initialize GBL_MORE structure
    //
    GET_LPDDRAWSURFACE_GBL_MORE(pSurf_lcl->lpGbl)->dwSize =
        sizeof( DDRAWI_DDRAWSURFACE_GBL_MORE );

    // Init the contents stamp to 0 means the surface's contents can
    // change at any time.
    GET_LPDDRAWSURFACE_GBL_MORE( pSurf_lcl->lpGbl )->dwContentsStamp = 0;

    //
    // 2) Initialize DDRAWI_DDRAWSURFACE_GBL structure
    //
    pSurf = pSurf_lcl->lpGbl;
    pSurf->ddpfSurface = ddpf;
    pSurf->lpDD = this;

    //
    // 3) Allocate and initialize DDRAWI_DDRAWSURFACE_INT structure
    //
    pSurf_int = (LPDDRAWI_DDRAWSURFACE_INT)
        MemAlloc( sizeof(DDRAWI_DDRAWSURFACE_INT));
    if( NULL == pSurf_int )
    {
        DPF_ERR ("Failed allocation of DDRAWI_DDRAWSURFACE_INT");
        ddrval = DDERR_OUTOFMEMORY;
        goto error_exit_create_link;
    }

    // fill surface specific stuff
    ZeroMemory (pSurf_int, sizeof(DDRAWI_DDRAWSURFACE_INT));
    pSurf_int->lpLcl = pSurf_lcl;
    pSurf_int->lpVtbl = NULL;

    //
    // 4) Initialize DDRAWI_DDRAWSURFACE_LCL structure
    //
    pSurf_lcl->dwLocalRefCnt = OBJECT_ISROOT;
    pSurf_lcl->dwProcessId = GetCurrentProcessId();
#ifdef WIN95
    pSurf_lcl->dwModeCreatedIn = this->dwModeIndex;
#else
    pSurf_lcl->dmiCreated = this->dmiCurrent;
#endif
    pSurf_lcl->dwBackBufferCount = 0;

    // Flag it as an:
    // 1) empty surface
    // 2) Front surface
    // 3) Has a pixelformat
    pSurf_lcl->dwFlags = (DDRAWISURF_EMPTYSURFACE |
                          DDRAWISURF_FRONTBUFFER  |
                          DDRAWISURF_HASPIXELFORMAT);
    //
    // 5) Initialize DDRAWI_DDRAWSURFACE_MORE structure
    //
    pSurf_lcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE) (((LPSTR) pSurf_lcl) +
                                                          surf_size_lcl );
    pSurf_lcl->lpSurfMore->dwSize = sizeof( DDRAWI_DDRAWSURFACE_MORE );
    pSurf_lcl->lpSurfMore->lpIUnknowns = NULL;
    pSurf_lcl->lpSurfMore->lpDD_lcl = this_lcl;
    pSurf_lcl->lpSurfMore->lpDD_int = this_int;
    pSurf_lcl->lpSurfMore->dwMipMapCount = 0UL;
    pSurf_lcl->lpSurfMore->lpddOverlayFX = NULL;
    pSurf_lcl->lpSurfMore->lpD3DDevIList = NULL;
    pSurf_lcl->lpSurfMore->dwPFIndex = PFINDEX_UNINITIALIZED;

    // fill in the current caps
    pSurf_lcl->ddsCaps = caps;

#ifdef WINNT
    //
    // NT kernel needs to know about surface
    //

    //don't let NT kernel know about exec buffers
    DPF(8,"Attempting to create NT kernel mode surface object");

    if (!DdCreateSurfaceObject(pSurf_lcl, FALSE))
    {
        DPF_ERR("NT kernel mode stuff won't create its surface object!");
        ddrval = DDERR_GENERIC;
        goto error_exit_create_link;
    }
    DPF(9,"Kernel mode handle is %08x", pSurf_lcl->hDDSurface);
#endif

    //
    // Link the newly created surface to the DDraw surface chain
    //
    pSurf_int->lpLink = this->dsList;
    this->dsList = pSurf_int;

    //
    // AddRef the newly created surface
    //
    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) pSurf_int );

    //
    // Now assign it to the ptr-to-ptr passed in
    //
	*ppDDSurface = (LPDIRECTDRAWSURFACE) pSurf_int;
    return DD_OK;

error_exit_create_link:
    //
    // Free any allocated memory
    //

    // 1) The allocated SURFACE_LCL
    if (pSurf_lcl)
    {
	    MemFree (pSurf_lcl);
    }

    // 2) The Surface_int
    if (pSurf_int)
    {
        MemFree (pSurf_int);
    }

    return ddrval;
}

//-------------------------------------------------------------------------------
//
// createAndLinkOptSurface
//
// Create a surface, and link it into the chain.
// We create a single surface place-holder  here, real work is done at the
// Load/Copy time.
//
//-------------------------------------------------------------------------------
HRESULT
createAndLinkOptSurface(
    LPDDRAWI_DIRECTDRAW_LCL this_lcl,
    LPDDRAWI_DIRECTDRAW_INT this_int,
    LPDDOPTSURFACEDESC      pDDOptSurfaceDesc,
    LPDIRECTDRAWSURFACE FAR *ppDDSurface
    )
{
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   new_surf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   new_surf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   new_surf;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE   new_surf_gbl_more;
    DDSCAPS2                    caps2;
    LPDDOPTSURFACEDESC          pOptSurfDesc;
    DDPIXELFORMAT               ddpf;
    HRESULT                     ddrval = DD_OK;

    // DDraw-global
    this = this_lcl->lpGbl;

    //
    // Fix the caps
    //
    ZeroMemory (&caps2, sizeof (DDSCAPS));
    caps2.dwCaps = DDSCAPS_OPTIMIZED;
    if (pDDOptSurfaceDesc->ddSCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        caps2.dwCaps |= DDSCAPS_SYSTEMMEMORY;
    if (pDDOptSurfaceDesc->ddSCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        caps2.dwCaps |= DDSCAPS_VIDEOMEMORY;
    if (pDDOptSurfaceDesc->ddSCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
        caps2.dwCaps |= DDSCAPS_LOCALVIDMEM;
    if (pDDOptSurfaceDesc->ddSCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        caps2.dwCaps |= DDSCAPS_NONLOCALVIDMEM;

    // Quit is the memory type is not supported
    if (caps2.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        if (!(this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM))
        {
            DPF_ERR( "Driver does not support non-local video memory" );
            ddrval = DDERR_NONONLOCALVIDMEM;
            goto error_exit_create_opt;
        }
    }

#if 0
    // Quit if textures are not supported
    if (!(this->ddCaps.dwCaps & DDSCAPS_TEXTURE))
    {
        DPF_ERR( "Driver does not support textures" );
        return DDERR_NOTEXTUREHW;
    }
#endif

    //
    // PixelFormat: Mark it as an empty surface
    //
    ZeroMemory (&ddpf, sizeof (ddpf));
    ddpf.dwSize = sizeof (ddpf);
    ddpf.dwFlags = DDPF_EMPTYSURFACE;

    //
    // OptSurfaceDesc
    //
    pOptSurfDesc = MemAlloc (sizeof (DDOPTSURFACEDESC));
    if (NULL == pOptSurfDesc)
    {
        DPF_ERR ("Memory allocation failed for opt surface descriptor");
        ddrval = DDERR_OUTOFMEMORY;
        goto error_exit_create_opt;
    }
    ZeroMemory (pOptSurfDesc, sizeof (*pOptSurfDesc));
    CopyMemory (pOptSurfDesc, pDDOptSurfaceDesc, sizeof (DDOPTSURFACEDESC));

    // Create and link an uninitialized surface
    ddrval =  CreateAndLinkUnintializedSurface (this_lcl,
                                                this_int,
                                                ppDDSurface);
    if (ddrval != DD_OK)
    {
        DPF_ERR ("createAndLinkUninitializedSurface failed");
        goto error_exit_create_opt;
    }


    //
    // 1) Update GBL_MORE structure
    //
    new_surf_int = (LPDDRAWI_DDRAWSURFACE_INT)*ppDDSurface;
    new_surf_lcl = new_surf_int->lpLcl;
    new_surf     = new_surf_lcl->lpGbl;
    new_surf_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE(new_surf);
    new_surf_gbl_more->lpDDOptSurfaceDesc = pOptSurfDesc;
    // Init the contents stamp to 0 means the surface's contents can
    // change at any time.
    new_surf_gbl_more->dwContentsStamp = 0;

    //
    // 2) Update DDRAWI_DDRAWSURFACE_GBL structure
    //
    new_surf->ddpfSurface = ddpf;

    //
    // 3) Update DDRAWI_DDRAWSURFACE_INT structure
    //
    new_surf_int->lpVtbl = &ddOptSurfaceCallbacks;

    //
    // 4) Update DDRAWI_DDRAWSURFACE_LCL structure
    //

    // Flag it as an:
    // 1) empty surface
    // 2) Front surface
    // 3) Has a pixelformat
    new_surf_lcl->dwFlags = (DDRAWISURF_EMPTYSURFACE |
                             DDRAWISURF_FRONTBUFFER  |
                             DDRAWISURF_HASPIXELFORMAT);
    // fill in the current caps
    CopyMemory (&new_surf_lcl->ddsCaps, &caps2, sizeof(new_surf_lcl->ddsCaps));


    return DD_OK;

error_exit_create_opt:
    //
    // Free any allocated memory
    //

    // 1) The allocated OPTSURFDESC
    if (pOptSurfDesc)
    {
	    MemFree (pOptSurfDesc);
    }

    return ddrval;
}

//-------------------------------------------------------------------------------
//
// InternalCreateOptSurface
//
// Create the surface.
// This is the internal way of doing this; used by EnumSurfaces.
// Assumes the directdraw lock has been taken.
//
//-------------------------------------------------------------------------------

HRESULT
InternalCreateOptSurface(
    LPDDRAWI_DIRECTDRAW_LCL  this_lcl,
    LPDDOPTSURFACEDESC       pDDOptSurfaceDesc,
    LPDIRECTDRAWSURFACE FAR *ppDDSurface,
    LPDDRAWI_DIRECTDRAW_INT  this_int )
{
    DDSCAPS2        caps2;
    DDOSCAPS        ocaps;
    HRESULT         ddrval;
    LPDDRAWI_DIRECTDRAW_GBL this;

    this = this_lcl->lpGbl;

    // Validate Caps
    caps2 = pDDOptSurfaceDesc->ddSCaps;
    if (caps2.dwCaps & ~DDOSDCAPS_VALIDSCAPS)
    {
        DPF_ERR( "Unrecognized optimized surface caps" );
        return DDERR_INVALIDCAPS;
    }

    ocaps = pDDOptSurfaceDesc->ddOSCaps;
    if (ocaps.dwCaps & ~DDOSDCAPS_VALIDOSCAPS)
    {
        DPF_ERR( "Unrecognized optimized surface caps" );
        return DDERR_INVALIDCAPS;
    }

    //
    // valid memory caps?
    //
    if ((caps2.dwCaps & DDSCAPS_SYSTEMMEMORY)
        && (caps2.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        DPF_ERR( "Can't specify SYSTEMMEMORY and VIDEOMEMORY" );
        return DDERR_INVALIDCAPS;
    }

    //
    // If DDSCAPS_LOCALVIDMEM or DDSCAPS_NONLOCALVIDMEM are specified
    // then DDSCAPS_VIDOEMEMORY must be explicity specified. Note, we
    // can't dely this check until checkCaps() as by that time the heap
    // scanning software may well have turned on DDSCAPS_VIDOEMEMORY.
    //
    if ((caps2.dwCaps & (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM)) &&
        !(caps2.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        DPF_ERR( "DDOSDCAPS_VIDEOMEMORY must be specified with DDSCAPS_LOCALVIDMEM or DDSCAPS_NONLOCALVIDMEM" );
        return DDERR_INVALIDCAPS;
    }

    //
    // have to specify if it is sys-mem or vid-mem
    //
    if ((caps2.dwCaps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_SYSTEMMEMORY)) == 0)
    {
        DPF_ERR( "Need to specify the memory type" );
        return DDERR_INVALIDCAPS;
    }

    //
    // Validate optimization type caps
    //
    if ((ocaps.dwCaps & (DDOSDCAPS_OPTCOMPRESSED | DDOSDCAPS_OPTREORDERED)) == 0)
    {
        DPF_ERR ("Not specified whether compressed or reordered, let the driver choose");
    }

    // Cannot be both compresses and reordered
    if ((ocaps.dwCaps & DDOSDCAPS_OPTCOMPRESSED)
        && (ocaps.dwCaps & DDOSDCAPS_OPTREORDERED))
    {
        DPF_ERR ("Cannot be both compresses and reordered");
        return DDERR_INVALIDCAPS;
    }

    ddrval = createAndLinkOptSurface (this_lcl, this_int, pDDOptSurfaceDesc,
                                      ppDDSurface);
    return ddrval;
}

//-------------------------------------------------------------------------------
//
// CreateOptSurface method of IDirectDrawSurface4
//
// Create an optimized surface given the Optimized surface descriptor
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_CreateOptSurface(
    LPDIRECTDRAW             pDD,
    LPDDOPTSURFACEDESC       pDDOptSurfaceDesc,
    LPDIRECTDRAWSURFACE FAR *ppDDS,
    IUnknown FAR            *pUnkOuter )
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    DDOPTSURFACEDESC ddosd;
    HRESULT         ddrval;

    ZeroMemory(&ddosd,sizeof(ddosd));
    ddosd.dwSize = sizeof (ddosd);

    //
    // Return error if aggregation expected
    //
    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_CreateOptSurface");

    //
    // Setup DPF stuff
    //
    DPF_ENTERAPI(pDD);

    //
    // Parameter validation
    //
    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) pDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            DPF_ERR( "Invalid driver object passed" );
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        // verify that cooperative level is set
        if( !(this_lcl->dwLocalFlags & DDRAWILCL_SETCOOPCALLED) )
        {
            DPF_ERR( "Must call SetCooperativeLevel before calling Create functions" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_NOCOOPERATIVELEVELSET);
            return DDERR_NOCOOPERATIVELEVELSET;
        }

        if( this->dwModeIndex == DDUNSUPPORTEDMODE )
        {
            DPF_ERR( "Driver is in an unsupported mode" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_UNSUPPORTEDMODE);
            return DDERR_UNSUPPORTEDMODE;
        }

        if( !VALID_DDOPTSURFACEDESC_PTR( pDDOptSurfaceDesc ) )
        {
            DPF_ERR( "Invalid optimized surface description. Did you set the dwSize member?" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }
        memcpy(&ddosd, pDDOptSurfaceDesc, sizeof(*pDDOptSurfaceDesc));
        *ppDDS = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_INVALIDPARAMS);
        return DDERR_INVALIDPARAMS;
    }

    // Quit if there is no hardware present
    if( this->dwFlags & DDRAWI_NOHARDWARE )
    {
        ddrval = DDERR_NODIRECTDRAWHW;
        goto exit_create;
    }

    // Assert that: (0 == this->lpDDOptSurfaceInfo) <==> (if and only if)
    // (this->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES)

    //Check to see if the driver supports OptSurface
    if ((0 == this->lpDDOptSurfaceInfo) // GetDriverInfo failed for some reason
        || !(this->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        ddrval = DDERR_NOOPTSURFACESUPPORT;
        goto exit_create;
    }

    //
    // Check if the GUID passed is a recognized optimized surface GUID
    // The compression ratio is more a hint.
    //
    if (!IsRecognizedOptSurfaceGUID (this, &(pDDOptSurfaceDesc->guid)))
    {
        DPF_ERR( "Not a recognized GUID" );
        ddrval = DDERR_UNRECOGNIZEDGUID;
        goto exit_create;
    }

    //
    // Now create the Optimized surface
    //
    ddrval = InternalCreateOptSurface(this_lcl, &ddosd, ppDDS, this_int);

exit_create:
    DPF_APIRETURNS(ddrval);
    LEAVE_DDRAW();
    return ddrval;
}

//-------------------------------------------------------------------------------
//
// CreateOptSurface method of IDirectDrawSurface4
//
// Create an optimized surface given the Optimized surface descriptor
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_ListOptSurfaceGUIDS(
    LPDIRECTDRAW    pDD,
    DWORD          *pNumGuids,
    LPGUID          pGuidArray )
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    HRESULT         ddrval = DD_OK;
    LPGUID          pRetGuids = NULL;
    LPDDOPTSURFACEINFO pOptSurfInfo;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_ListOptSurfaceGUIDS");

    //
    // Parameter validation
    //
    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) pDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            DPF_ERR( "Invalid driver object passed" );
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( !VALID_PTR( pGuidArray, sizeof (GUID) ))
        {
            DPF_ERR( "Invalid GuidArray pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        pGuidArray = NULL;

        if( !VALID_PTR( pNumGuids,  sizeof (*pNumGuids)) )
        {
            DPF_ERR( "Invalid GuidArray pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *pNumGuids  = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_INVALIDPARAMS);
        return DDERR_INVALIDPARAMS;
    }

    pOptSurfInfo = this->lpDDOptSurfaceInfo;

    // Assert that: (0 == this->lpDDOptSurfaceInfo) <==> (if and only if)
    // (this->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES)

    //Check to see if the driver supports OptSurface
    if ((0 == pOptSurfInfo) // GetDriverInfo failed for some reason
        || !(this->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        ddrval = DDERR_NOOPTSURFACESUPPORT;
        goto list_exit;
    }

    // If there are no GUIDS reported by the driver,
    // return the nulled out out-params.
    if (pOptSurfInfo->dwNumGuids == 0)
    {
        ddrval = DD_OK;
        goto list_exit;
    }

    // Allocate the array of GUIDS
    // ATTENTION: Incomplete allocation?
    pRetGuids = MemAlloc(pOptSurfInfo->dwNumGuids * sizeof(GUID));
	if( NULL == pRetGuids )
	{
	    ddrval = DDERR_OUTOFMEMORY;
        goto list_exit;
	}

    // Copy the GUID array to be returned
    CopyMemory ((PVOID)pRetGuids, (PVOID)pOptSurfInfo->lpGuidArray,
                pOptSurfInfo->dwNumGuids * sizeof(GUID));
    pGuidArray = pRetGuids;
    *pNumGuids = pOptSurfInfo->dwNumGuids;

list_exit:
    LEAVE_DDRAW();
    return ddrval;
}

//-------------------------------------------------------------------------------
//
// GetOptSurfaceDesc method of IDirectDrawOptSurface
//
// Get the Optimized surface description
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_OptSurface_GetOptSurfaceDesc(
    LPDIRECTDRAWSURFACE  pDDS,
    LPDDOPTSURFACEDESC   pDDOptSurfDesc)
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE   this_gbl_more;
    LPDDOPTSURFACEDESC   pDDRetOptSurfDesc = NULL;
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_OptSurface_GetOptSurfaceDesc");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE(this);

        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        if( !VALID_DDOPTSURFACEDESC_PTR( pDDOptSurfDesc ) )
        {
            DPF_ERR( "Invalid optimized surface description. Did you set the dwSize member?" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }
        pDDOptSurfDesc = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    //
    // Quit with error if:
    // 1) No hardware
    // 2) Hardware doesnt support optimized surfaces
    // 3) Surface is an unoptimized surface
    //

    // DDraw Gbl pointer
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

    // Assert that: (0 == this->lpDDOptSurfaceInfo) <==> (if and only if)
    // (this->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES)

    // 1)
    if( pdrv->dwFlags & DDRAWI_NOHARDWARE )
    {
        DPF_ERR ("No hardware present");
        LEAVE_DDRAW();
        return DDERR_NODIRECTDRAWHW;
    }

    // 2)
    if ((0 == pdrv->lpDDOptSurfaceInfo) ||
        !(pdrv->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        DPF_ERR ("Optimized surfaces not supported");
        LEAVE_DDRAW();
        return DDERR_NOOPTSURFACESUPPORT;
    }

    // 3)
    if (!(this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        DPF_ERR ("Current surface is not an optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANOPTIMIZEDSURFACE;
    }

    pDDRetOptSurfDesc = MemAlloc (sizeof (*pDDRetOptSurfDesc));
    if (!pDDRetOptSurfDesc)
    {
        DPF_ERR ("Memory allocation failed");
        LEAVE_DDRAW();
        return DDERR_OUTOFMEMORY;
    }
    ZeroMemory (pDDRetOptSurfDesc, sizeof (*pDDRetOptSurfDesc));
    CopyMemory (pDDRetOptSurfDesc, this_gbl_more->lpDDOptSurfaceDesc,
                sizeof (*pDDRetOptSurfDesc));
    pDDOptSurfDesc = pDDRetOptSurfDesc;

    LEAVE_DDRAW();
    return DD_OK;
}

//-------------------------------------------------------------------------------
//
// DoLoadUnOptSurf
//
// Actually make the HAL call and update data-structures if the call
// succeeds.
//
//-------------------------------------------------------------------------------
HRESULT
DoLoadUnOptSurf(
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl,
    LPDDRAWI_DDRAWSURFACE_GBL   this,
    LPDDRAWI_DDRAWSURFACE_LCL   src_lcl,
    LPDDRAWI_DDRAWSURFACE_GBL   src
    )
{
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;
    DDHAL_OPTIMIZESURFACEDATA   ddhal_osd;
    LPDDOPTSURFACEINFO    pDDOptSurfInfo = NULL;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE this_gbl_more, src_gbl_more;
    HRESULT ddrval = DD_OK;

    // Get the ddraw pointers
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;
    pDDOptSurfInfo = pdrv->lpDDOptSurfaceInfo;
    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE (this);

    // Setup data to pass to the driver
    ZeroMemory (&ddhal_osd, sizeof (DDHAL_COPYOPTSURFACEDATA));
    ddhal_osd.lpDD           = pdrv_lcl;
    ddhal_osd.ddOptSurfDesc  = *(this_gbl_more->lpDDOptSurfaceDesc);
    ddhal_osd.lpDDSSrc       = src_lcl;
    ddhal_osd.lpDDSDest      = this_lcl;

    // Make the HAL call
    DOHALCALL(OptimizeSurface, pDDOptSurfInfo->OptimizeSurface, ddhal_osd, ddrval, FALSE );

    if (ddrval != DD_OK)
    {
        DPF_ERR ("LoadUnOptSurface failed in the driver");
        return ddrval;
    }

    // ATTENTION: Should the driver do these updates ?

    // 1) Update the DDRAWI_DDRAWSURFACE_LCL structure
    //    Color key stuff is ignored for now
    this_lcl->dwFlags = src_lcl->dwFlags;
    this_lcl->dwFlags &= ~DDRAWISURF_EMPTYSURFACE;
    this_lcl->ddsCaps = src_lcl->ddsCaps;
    this_lcl->ddsCaps.dwCaps |= DDSCAPS_OPTIMIZED;
#ifdef WIN95
    this_lcl->dwModeCreatedIn = src_lcl->dwModeCreatedIn;
#else
    this_lcl->dmiCreated = src_lcl->dmiCreated;
#endif
    this_lcl->dwBackBufferCount = src_lcl->dwBackBufferCount;

    // 2) Update the DDRAWI_DDRAWSURFACE_MORE structure
    this_lcl->lpSurfMore->dwMipMapCount = src_lcl->lpSurfMore->dwMipMapCount;
    this_lcl->lpSurfMore->ddsCapsEx = src_lcl->lpSurfMore->ddsCapsEx;

    // 3) Update the DDRAWI_DDRAWSURFACE_GBL structure
    this->dwGlobalFlags = src->dwGlobalFlags;
    this->wHeight = src->wHeight;
    this->wWidth = src->wWidth;
    this->ddpfSurface = src->ddpfSurface;

    // 4) Update the DDRAWI_DDRAWSURFACE_GBL_MORE structure
    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE (this);
    src_gbl_more  = GET_LPDDRAWSURFACE_GBL_MORE (src);

    this_gbl_more->dwContentsStamp = src_gbl_more->dwContentsStamp;
    CopyMemory (this_gbl_more->lpDDOptSurfaceDesc,
                src_gbl_more->lpDDOptSurfaceDesc,
                sizeof (DDOPTSURFACEDESC));

    return ddrval;
}

//-------------------------------------------------------------------------------
//
// FilterSurfCaps
//
// Check to see if the surface is can be optimized
//
//-------------------------------------------------------------------------------
HRESULT
FilterSurfCaps(
    LPDDRAWI_DDRAWSURFACE_LCL   surf_lcl,
    LPDDRAWI_DDRAWSURFACE_GBL   surf)
{
    DWORD   caps = surf_lcl->ddsCaps.dwCaps;

    //
    // check for no caps at all!
    //
    if( caps == 0 )
    {
    	DPF_ERR( "no caps specified" );
        return DDERR_INVALIDCAPS;
    }

    //
    // check for bogus caps.
    //
    if( caps & ~DDSCAPS_VALID )
    {
        DPF_ERR( "Create surface: invalid caps specified" );
        return DDERR_INVALIDCAPS;
    }

    //
    // Anything other than a texture is not allowed
    // ATTENTION: some more flags need to be checked
    //
    if(caps & (DDSCAPS_EXECUTEBUFFER      |
               DDSCAPS_BACKBUFFER         |
               DDSCAPS_FRONTBUFFER        |
               DDSCAPS_OFFSCREENPLAIN     |
               DDSCAPS_PRIMARYSURFACE     |
               DDSCAPS_PRIMARYSURFACELEFT |
               DDSCAPS_VIDEOPORT          |
               DDSCAPS_ZBUFFER            |
               DDSCAPS_OWNDC              |
               DDSCAPS_OVERLAY            |
               DDSCAPS_3DDEVICE           |
               DDSCAPS_ALLOCONLOAD)
        )
    {
        DPF_ERR( "currently only textures can be optimized" );
        return DDERR_INVALIDCAPS;
    }

    if( !(caps & DDSCAPS_TEXTURE) )
    {
        DPF_ERR( "DDSCAPS_TEXTURE needs to be set" );
        return DDERR_INVALIDCAPS;
    }

    return DD_OK;
}

//-------------------------------------------------------------------------------
//
// LoadUnoptimizedSurf method of IDirectDrawOptSurface
//
// Load an unoptimized surface. This is a way to optimize a surface.
//
// The Surface's PIXELFORMAT will be that of the pDDSSrc in case the call
// succeeds.
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_OptSurface_LoadUnoptimizedSurf(
    LPDIRECTDRAWSURFACE pDDS,
    LPDIRECTDRAWSURFACE pDDSSrc)
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DDRAWSURFACE_INT   src_int;
    LPDDRAWI_DDRAWSURFACE_LCL   src_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   src;
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;
    HRESULT                     ddrval = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_OptSurface_LoadUnoptimizedSurf");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        src_int = (LPDDRAWI_DDRAWSURFACE_INT) pDDSSrc;
        if( !VALID_DIRECTDRAWSURFACE_PTR( src_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }

        src_lcl = src_int->lpLcl;
        if( SURFACE_LOST( src_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
        src = src_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    //ATTENTION: Should src be AddRef'd ?

    //
    // Quit with error if:
    // 1) No hardware
    // 2) Hardware doesnt support optimized surfaces
    // 3) Surface is an unoptimized surface
    // 4) Src is an optimized surface
    // 5) Current surface is not empty (should we enforce it, or let the driver
    //    deal with it ?)
    // 6) The surface is not the "right" type
    // 7) The driver fails for some reason
    //

    // DDraw Gbl pointer
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

    // 1)
    if( pdrv->dwFlags & DDRAWI_NOHARDWARE )
    {
        DPF_ERR ("No hardware present");
        LEAVE_DDRAW();
        return DDERR_NODIRECTDRAWHW;
    }

    // 2)
    if ((0 == pdrv->lpDDOptSurfaceInfo) ||
        !(pdrv->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        DPF_ERR ("Optimized surfaces not supported");
        LEAVE_DDRAW();
        return DDERR_NOOPTSURFACESUPPORT;
    }

    // 3)
    if (!(this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        DPF_ERR ("Current surface is not an optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANOPTIMIZEDSURFACE;
    }

    // 4)
    if (src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
        DPF_ERR ("Source surface is an optimized surface");
        LEAVE_DDRAW();
        return DDERR_ISOPTIMIZEDSURFACE;
    }

    // 5)
    if (!(this_lcl->dwFlags & DDRAWISURF_EMPTYSURFACE))
    {
        DPF_ERR ("Current surface is not an empty optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANEMPTYOPTIMIZEDSURFACE;
    }

    // 6)
    ddrval = FilterSurfCaps (src_lcl, src);
    if (ddrval != DD_OK)
    {
        DPF_ERR ("Source surface cannot be optimized");
        LEAVE_DDRAW();
        return DDERR_NOTANEMPTYOPTIMIZEDSURFACE;
    }

    // Now attempt the actual load
    ddrval = DoLoadUnOptSurf (this_lcl, this, src_lcl, src);

    LEAVE_DDRAW();
    return ddrval;
}

//-------------------------------------------------------------------------------
//
// DoCopyOptSurf
//
// Actually make the HAL call and update data-structures if the call
// succeeds.
//
//-------------------------------------------------------------------------------
HRESULT
DoCopyOptSurf(
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl,
    LPDDRAWI_DDRAWSURFACE_GBL   this,
    LPDDRAWI_DDRAWSURFACE_LCL   src_lcl,
    LPDDRAWI_DDRAWSURFACE_GBL   src
    )
{
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;
    DDHAL_COPYOPTSURFACEDATA    ddhal_cosd;
    LPDDOPTSURFACEINFO    pDDOptSurfInfo = NULL;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE this_gbl_more, src_gbl_more;
    HRESULT ddrval = DD_OK;

    // Get the ddraw pointers
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;
    pDDOptSurfInfo = pdrv->lpDDOptSurfaceInfo;

    // Setup data to pass to the driver
    ZeroMemory (&ddhal_cosd, sizeof (DDHAL_COPYOPTSURFACEDATA));
    ddhal_cosd.lpDD      = pdrv_lcl;
    ddhal_cosd.lpDDSSrc  = src_lcl;
    ddhal_cosd.lpDDSDest = this_lcl;

    DOHALCALL(CopyOptSurface, pDDOptSurfInfo->CopyOptSurface, ddhal_cosd, ddrval, FALSE );

    // If the driver call succeeds, then copy the surface description and
    // pixel format etc.
    if (ddrval != DD_OK)
    {
        DPF_ERR ("CopyOptSurface failed in the driver");
        return ddrval;
    }

    // ATTENTION: Should the driver do these updates ?

    // 1) Update the DDRAWI_DDRAWSURFACE_LCL structure
    //    Color key stuff is ignored for now
    this_lcl->dwFlags = src_lcl->dwFlags;
    this_lcl->ddsCaps = src_lcl->ddsCaps;
#ifdef WIN95
    this_lcl->dwModeCreatedIn = src_lcl->dwModeCreatedIn;
#else
    this_lcl->dmiCreated = src_lcl->dmiCreated;
#endif
    this_lcl->dwBackBufferCount = src_lcl->dwBackBufferCount;

    // 2) Update the DDRAWI_DDRAWSURFACE_MORE structure
    this_lcl->lpSurfMore->dwMipMapCount = src_lcl->lpSurfMore->dwMipMapCount;
    this_lcl->lpSurfMore->ddsCapsEx = src_lcl->lpSurfMore->ddsCapsEx;

    // 3) Update the DDRAWI_DDRAWSURFACE_GBL structure
    this->dwGlobalFlags = src->dwGlobalFlags;
    this->wHeight = src->wHeight;
    this->wWidth = src->wWidth;
    this->ddpfSurface = src->ddpfSurface;

    // 4) Update the DDRAWI_DDRAWSURFACE_GBL_MORE structure
    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE (this);
    src_gbl_more  = GET_LPDDRAWSURFACE_GBL_MORE (src);

    this_gbl_more->dwContentsStamp = src_gbl_more->dwContentsStamp;
    CopyMemory (this_gbl_more->lpDDOptSurfaceDesc,
                src_gbl_more->lpDDOptSurfaceDesc,
                sizeof (DDOPTSURFACEDESC));

    return ddrval;
}

//-------------------------------------------------------------------------------
//
// CopyOptimizedSurf method of IDirectDrawOptSurface
//
// Copy an optimized surface.
//
// The Surface's PIXELFORMAT will be that of the pDDSSrc in case the call
// succeeds.
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_OptSurface_CopyOptimizedSurf(
    LPDIRECTDRAWSURFACE pDDS,
    LPDIRECTDRAWSURFACE pDDSSrc)
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DDRAWSURFACE_INT   src_int;
    LPDDRAWI_DDRAWSURFACE_LCL   src_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   src;
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;
    HRESULT                     ddrval = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_OptSurface_CopyOptimizedSurf");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        src_int = (LPDDRAWI_DDRAWSURFACE_INT) pDDSSrc;
        if( !VALID_DIRECTDRAWSURFACE_PTR( src_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        src_lcl = src_int->lpLcl;
        src = src_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    //ATTENTION: Should src be AddRef'd ?

    //
    // Quit with error if:
    // 1) No hardware
    // 2) Hardware doesnt support optimized surfaces
    // 3) Surface is an unoptimized surface
    // 4) Src is an unoptimized surface
    // 5) Src is an empty optimized surface
    // 6) Current surface is not empty (should we enforce it, or let the driver
    //    deal with it ?)
    // 7) The driver fails for some reason
    //

    // DDraw Gbl pointer
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

    // 1)
    if( pdrv->dwFlags & DDRAWI_NOHARDWARE )
    {
        DPF_ERR ("No hardware present");
        LEAVE_DDRAW();
        return DDERR_NODIRECTDRAWHW;
    }

    // 2)
    if ((0 == pdrv->lpDDOptSurfaceInfo) ||
        !(pdrv->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        DPF_ERR ("Optimized surfaces not supported");
        LEAVE_DDRAW();
        return DDERR_NOOPTSURFACESUPPORT;
    }

    // 3)
    if (!(this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        DPF_ERR ("Current surface is not an optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANOPTIMIZEDSURFACE;
    }

    // 4)
    if (!(src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        DPF_ERR ("Source surface is not an optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANOPTIMIZEDSURFACE;
    }

    // 5)
    if (src_lcl->dwFlags & DDRAWISURF_EMPTYSURFACE)
    {
        DPF_ERR ("Source surface is an empty optimized surface");
        LEAVE_DDRAW();
        return DDERR_ISANEMPTYOPTIMIZEDSURFACE;
    }

    // 6)
    if (!(this_lcl->dwFlags & DDRAWISURF_EMPTYSURFACE))
    {
        DPF_ERR ("Current surface is not an empty optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANEMPTYOPTIMIZEDSURFACE;
    }

    // Now attempt the actual copy
    ddrval = DoCopyOptSurf (this_lcl, this, src_lcl, src);

    LEAVE_DDRAW();
    return ddrval;
}

//-------------------------------------------------------------------------------
//
// DoUnOptimize
//
// Actually make the HAL call and update data-structures if the call
// succeeds.
//
//-------------------------------------------------------------------------------
HRESULT
DoUnOptimize(
    LPDDSURFACEDESC2            pSurfDesc,
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl,
    LPDDRAWI_DDRAWSURFACE_GBL   this,
    LPDIRECTDRAWSURFACE FAR    *ppDDSDest
    )
{
    LPDDRAWI_DIRECTDRAW_INT	    pdrv_int;
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL	new_surf_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	new_surf_int;
    LPDDRAWI_DDRAWSURFACE_GBL	new_surf;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE new_surf_gbl_more;
    DDPIXELFORMAT               ddpf;
    DDSCAPS                     caps;
    DDHAL_UNOPTIMIZESURFACEDATA ddhal_uosd;
    LPDDOPTSURFACEINFO          pDDOptSurfInfo = NULL;
    LPDDRAWI_DDRAWSURFACE_INT	pSurf_int, prev_int;
    HRESULT ddrval = DD_OK;

    // Get the ddraw pointers
	pdrv_int = this_lcl->lpSurfMore->lpDD_int;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

    //
    // Fix the caps
    //
    ZeroMemory (&caps, sizeof (DDSCAPS));
    if (pSurfDesc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        caps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
    if (pSurfDesc->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        caps.dwCaps |= DDSCAPS_VIDEOMEMORY;
    if (pSurfDesc->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
        caps.dwCaps |= DDSCAPS_LOCALVIDMEM;
    if (pSurfDesc->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        caps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;

    // Quit if the memory type is not supported
    if (caps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        if (!(pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM))
        {
            DPF_ERR( "Driver does not support non-local video memory" );
            return DDERR_NONONLOCALVIDMEM;
        }
    }

#if 0
    // Quit if textures are not supported
    if (!(pdrv->ddCaps.dwCaps & DDCAPS_TEXTURE))
    {
        DPF_ERR( "Driver does not support textures" );
        return DDERR_NOTEXTUREHW;
    }
#endif

    //
    // PixelFormat: Mark it as an empty surface
    //
    ZeroMemory (&ddpf, sizeof (ddpf));
    ddpf.dwSize = sizeof (ddpf);
    ddpf.dwFlags = DDPF_EMPTYSURFACE;

    // Make a new uninitialized surface
    ddrval = CreateAndLinkUnintializedSurface (pdrv_lcl, pdrv_int, ppDDSDest);
    if (ddrval != DD_OK)
    {
        DPF_ERR ("createAndLinkUnintializedSurface failed");
        return ddrval;
    }

    //
    // 1) Update GBL_MORE structure
    //
    new_surf_int = (LPDDRAWI_DDRAWSURFACE_INT)*ppDDSDest;
    new_surf_lcl = new_surf_int->lpLcl;
    new_surf     = new_surf_lcl->lpGbl;
    new_surf_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE (new_surf);
    // Init the contents stamp to 0 means the surface's contents can
    // change at any time.
    new_surf_gbl_more->dwContentsStamp = 0;

    //
    // 2) Update DDRAWI_DDRAWSURFACE_GBL structure
    //
    new_surf->ddpfSurface = this->ddpfSurface;

    //
    // 3) Update DDRAWI_DDRAWSURFACE_INT structure
    //
    new_surf_int->lpVtbl = &ddSurface4Callbacks;

    //
    // 4) Update DDRAWI_DDRAWSURFACE_LCL structure
    //

    // Flag it as an:
    // 1) empty surface
    // 2) Front surface
    // 3) Has a pixelformat
    new_surf_lcl->dwFlags = (DDRAWISURF_EMPTYSURFACE |
                             DDRAWISURF_FRONTBUFFER  |
                             DDRAWISURF_HASPIXELFORMAT);
    // fill in the current caps
    new_surf_lcl->ddsCaps = caps;


    // Try the unoptimize
    pDDOptSurfInfo = pdrv->lpDDOptSurfaceInfo;

    // Setup data to pass to the driver
    ZeroMemory (&ddhal_uosd, sizeof (DDHAL_UNOPTIMIZESURFACEDATA));
    ddhal_uosd.lpDD      = pdrv_lcl;
    ddhal_uosd.lpDDSSrc  = this_lcl;
    ddhal_uosd.lpDDSDest = new_surf_lcl;

    DOHALCALL(UnOptimizeSurface, pDDOptSurfInfo->UnOptimizeSurface, ddhal_uosd, ddrval, FALSE );

    if (ddrval == DD_OK)
    {
        return DD_OK;
    }

    // If there was an error, then destroy the surface
    // Since it is an empty surface, all we need to do is:
    //   i) unlink the surface from the ddraw-chain
    //  ii) on NT, inform the kernel
    // iii) free all the allocated memory

    // i)
    prev_int = NULL;
    pSurf_int = pdrv->dsList;
    while ((pSurf_int != NULL) && (pSurf_int != new_surf_int))
    {
        prev_int = pSurf_int;
        pSurf_int = pSurf_int->lpLink;
    }
    if (pSurf_int == new_surf_int)
    {
        prev_int->lpLink = new_surf_int->lpLink;
    }

    // ii)
#ifdef WINNT
    DPF(8,"Attempting to destroy NT kernel mode surface object");

    if (!DdDeleteSurfaceObject (new_surf_lcl))
    {
        DPF_ERR("NT kernel mode stuff won't delete its surface object!");
        ddrval = DDERR_GENERIC;
    }
#endif

    // iii)
    MemFree (new_surf_lcl);

    return ddrval;
}

//-------------------------------------------------------------------------------
//
// Unoptimize method of IDirectDrawOptSurface
//
// Unoptimize an optimized surface. In doing so, it creates a new surface.
//
// The pDDSDest surface's PIXELFORMAT will be that of the pDDS in case the call
// succeeds. This means that the pixelformat of the original surface that was
// loaded is restored.
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_OptSurface_Unoptimize(
    LPDIRECTDRAWSURFACE pDDS,
    LPDDSURFACEDESC2    pSurfDesc,
    LPDIRECTDRAWSURFACE FAR *ppDDSDest,
    IUnknown FAR *pUnkOuter)
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;
    HRESULT                     ddrval = DD_OK;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_OptSurface_Unoptimize");

    TRY
    {
        if( !VALID_DDSURFACEDESC2_PTR( pSurfDesc ) )
        {
            DPF_ERR( "Invalid surface description. Did you set the dwSize member?" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }

        this_int = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        if( !VALID_PTR_PTR( ppDDSDest ) )
        {
            DPF_ERR( "Invalid dest. surface pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        *ppDDSDest = NULL;

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    //
    // Quit with error if:
    // 0) pSurfaceDesc not understood
    // 1) No hardware
    // 2) Hardware doesnt support optimized surfaces
    // 3) Surface is an unoptimized surface
    // 4) Surface is an empty optimized surface
    // 5) The driver fails for some reason
    //

    // DDraw Gbl pointer
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

    // 0)
    if (pSurfDesc->ddsCaps.dwCaps & ~(DDSCAPS_SYSTEMMEMORY |
                                      DDSCAPS_VIDEOMEMORY |
                                      DDSCAPS_NONLOCALVIDMEM |
                                      DDSCAPS_LOCALVIDMEM))
    {
        DPF_ERR ("Invalid flags");
        LEAVE_DDRAW();
        return DDERR_INVALIDCAPS;
    }

    // 1)
    if( pdrv->dwFlags & DDRAWI_NOHARDWARE )
    {
        DPF_ERR ("No hardware present");
        LEAVE_DDRAW();
        return DDERR_NODIRECTDRAWHW;
    }

    // 2)
    if ((0 == pdrv->lpDDOptSurfaceInfo) ||
        !(pdrv->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        DPF_ERR ("Optimized surfaces not supported");
        LEAVE_DDRAW();
        return DDERR_NOOPTSURFACESUPPORT;
    }

    // 3)
    if (!(this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        DPF_ERR ("Current surface is not an optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANOPTIMIZEDSURFACE;
    }

    // 4)
    if (this_lcl->dwFlags & DDRAWISURF_EMPTYSURFACE)
    {
        DPF_ERR ("Current surface is an empty optimized surface");
        LEAVE_DDRAW();
        return DDERR_ISANEMPTYOPTIMIZEDSURFACE;
    }

    // Do the actual unoptimize
    ddrval = DoUnOptimize (pSurfDesc, this_lcl, this, ppDDSDest);

    LEAVE_DDRAW();
    return ddrval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddraw.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw.c
 *  Content:    DirectDraw object support
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   25-dec-94  craige  initial implementation
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   21-jan-95  craige  made 32-bit + ongoing work
 *   31-jan-95  craige  and even more ongoing work...
 *   21-feb-95  craige  disconnect anyone who forgot to do it themselves
 *   27-feb-95  craige  new sync. macros
 *   01-mar-95  craige  flags to Get/SetExclusiveMode
 *   03-mar-95  craige  DuplicateSurface
 *   08-mar-95  craige  GetFourCCCodes, FreeAllSurfaces, GarbageCollect
 *   19-mar-95  craige  use HRESULTs
 *   20-mar-95  craige  new CSECT work
 *   26-mar-95  craige  driver wide color keys for overlays
 *   28-mar-95  craige  added FlipToGDISurface; removed Get/SetColorKey
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  fill in free video memory
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   15-apr-95  craige  implement FlipToGDISurface
 *   06-may-95  craige  use driver-level csects only
 *   14-may-95  craige  disable CTRL_ALT_DEL if exclusive fullscreen
 *   19-may-95  craige  check DDSEMO_ALLOWREBOOT before disabling CAD
 *   22-may-95  craige  use MemAlloc16 for sel. allocation
 *   23-may-95  craige  have GetCaps return HEL caps
 *   28-may-95  craige  implement FreeAllSurfaces; unicode support;
 *                      HAL cleanup: entry for GetScanLine
 *   05-jun-95  craige  removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *                      change GarbageCollect to Compact
 *   07-jun-95  craige  added StartExclusiveMode
 *   12-jun-95  craige  new process list stuff
 *   16-jun-95  craige  removed fpVidMemOrig
 *   17-jun-95  craige  new surface structure
 *   18-jun-95  craige  new DuplicateSurface code
 *   20-jun-95  craige  need to check fpVidMemOrig for deciding to flip
 *   24-jun-95  craige  don't hide/show cursor - up to app
 *   25-jun-95  craige  pay attention to DDCKEY_COLORSPACE; allow NULL ckey;
 *                      one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  return num of 4cc codes if NULL array specified.
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns
 *   30-jun-95  kylej   use GetProcessPrimary instead of lpPrimarySurface,
 *                      invalid all primaries when starting exclusive mode
 *   30-jun-95  craige  turn off all hot keys
 *   01-jul-95  craige  require fullscreen for excl. mode
 *   03-jul-95  craige  YEEHAW: new driver struct; SEH
 *   05-jul-95  craige  added internal FlipToGDISurface
 *   06-jul-95  craige  added Initialize
 *   08-jul-95  craige  added FindProcessDDObject
 *   08-jul-95  kylej   Handle exclusive mode palettes correctly
 *   09-jul-95  craige  SetExclusiveMode->SetCooperativeLevel;
 *                      flush all service when exclusive mode set;
 *                      check style for SetCooperativeLevel
 *   16-jul-95  craige  hook hwnd always
 *   17-jul-95  craige  return unsupported from GetMonitorFrequency if not avail
 *   20-jul-95  craige  don't set palette unless palettized
 *   22-jul-95  craige  bug 230 - unsupported starting modes
 *   01-aug-95  craige  bug 286 - GetCaps should fail if both parms NULL
 *   13-aug-95  craige  new parms to flip
 *   13-aug-95  toddla  added DDSCL_DONTHOOKHWND
 *   20-aug-95  toddla  added DDSCL_ALLOWMODEX
 *   21-aug-95  craige  mode X support
 *   25-aug-95  craige  bug 671
 *   26-aug-95  craige  bug 717
 *   26-aug-95  craige  bug 738
 *   04-sep-95  craige  bug 895: toggle GetVerticalBlankStatus result in emul.
 *   22-sep-95  craige  bug 1275: return # of 4cc codes copied
 *   15-nov-95  jeffno  Initial NT changes: ifdef out all but last routine
 *   27-nov-95  colinmc new member to return the available vram of a given
 *                      type (defined by DDSCAPS).
 *   10-dec-95  colinmc added execute buffer support
 *   18-dec-95  colinmc additional surface caps checking for
 *                      GetAvailableVidMem member
 *   26-dec-95  craige  implement DD_Initialize
 *   02-jan-96  kylej   handle new interface structures
 *   26-jan-96  jeffno  Teensy change in DoneExclusiveMode: bug when only 1 mode avail.
 *   14-feb-96  kylej   Allow NULL hwnd for non-exclusive SetCooperativeLevel
 *   05-mar-96  colinmc Bug 11928: Fixed DuplicateSurface problem caused by
 *                      failing to initialize the back pointer to the
 *                      DirectDraw object
 *   13-mar-96  craige  Bug 7528: hw that doesn't have modex
 *   22-mar-96  colinmc Bug 13316: uninitialized interfaces
 *   10-apr-96  colinmc Bug 16903: HEL uses obsolete FindProcessDDObject
 *   13-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *   14-apr-96  colinmc Bug 16855: Can't pass NULL to initialize
 *   03-may-96  kylej   Bug 19125: Preserve V1 SetCooperativeLevel behaviour
 *   27-may-96  colinmc Bug 24465: SetCooperativeLevel(..., DDSCL_NORMAL)
 *                      needs to ensure we are looking at the GDI surface
 *   01-oct-96  ketand  Use GetAvailDriverMemory to free/total vidmem estimates
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   21-jan-97  ketand  Deleted unused Get/SetColorKey. Put existing DDraw windowed
 *                      apps into emulation on multi-mon systems.
 *   30-jan-97  colinmc Work item 4125: Need time bomb for final
 *   29-jan-97  jeffno  Mode13 support. Just debugging changes.
 *   07-feb-97  ketand  Fix Multi-Mon when running EMULATION_ONLY and going full-screen
 *   08-mar-97  colinmc Support for DMA model AGP parts
 *   24-mar-97  jeffno  Optimized Surfaces
 *   30-sep-97  jeffno  IDirectDraw4
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"

/*
 * Caps bits that we don't allow to be specified when asking for
 * available video memory. These are bits which don't effect the
 * allocation of the surface in a vram heap.
 */
#define AVAILVIDMEM_BADSCAPS (DDSCAPS_BACKBUFFER   | \
                              DDSCAPS_FRONTBUFFER  | \
                              DDSCAPS_COMPLEX      | \
                              DDSCAPS_FLIP         | \
                              DDSCAPS_OWNDC        | \
                              DDSCAPS_PALETTE      | \
                              DDSCAPS_SYSTEMMEMORY | \
                              DDSCAPS_VISIBLE      | \
                              DDSCAPS_WRITEONLY)

extern BYTE szDeviceWndClass[];
extern LRESULT WINAPI DeviceWindowProc( HWND, UINT, WPARAM, LPARAM );

#undef DPF_MODNAME
#define DPF_MODNAME "GetVerticalBlankStatus"

#if defined(WIN95) || defined(NT_FIX)

    __inline static BOOL IN_VBLANK( void )
    {
        BOOL    rc;
        _asm
        {
            xor eax,eax
            mov dx,03dah    ;status reg. port on color card
            in  al,dx       ;read the status
            and     al,8            ;test whether beam is currently in retrace
            mov rc,eax
        }
        return rc;
    }

    #define IN_DISPLAY() (!IN_VBLANK())

#endif

/*
 * DD_GetVerticalBlankStatus
 */
HRESULT DDAPI DD_GetVerticalBlankStatus(
                LPDIRECTDRAW lpDD,
                LPBOOL lpbIsInVB )
{
    LPDDRAWI_DIRECTDRAW_INT             this_int;
    LPDDRAWI_DIRECTDRAW_LCL             this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL             this;
    LPDDHAL_WAITFORVERTICALBLANK        wfvbhalfn;
    LPDDHAL_WAITFORVERTICALBLANK        wfvbfn;

    ENTER_DDRAW();

    /* Removed because too many: DPF(2,A,"ENTERAPI: DD_GetVerticalBlankStatus"); */

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        #ifdef WINNT
            // Update DDraw handle in driver GBL object.
            this->hDD = this_lcl->hDD;
        #endif //WINNT
        if( !VALID_BOOL_PTR( lpbIsInVB ) )
        {
            DPF_ERR( "Invalid BOOL pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * ask the driver test the VB status
     */
    #pragma message( REMIND( "Need HEL WaitForVerticalBlank (for NT too!)" ))
    #if defined (WIN95) || defined ( NT_FIX )
        if( this->dwFlags & DDRAWI_MODEX )
        {
            *lpbIsInVB = FALSE;
            if( IN_VBLANK() )
            {
                *lpbIsInVB = TRUE;
            }
            LEAVE_DDRAW();
            return DD_OK;
        }
        else
    #endif
    {
        wfvbfn = this_lcl->lpDDCB->HALDD.WaitForVerticalBlank;
        wfvbhalfn = this_lcl->lpDDCB->cbDDCallbacks.WaitForVerticalBlank;
        if( wfvbhalfn != NULL )
        {
            DDHAL_WAITFORVERTICALBLANKDATA      wfvbd;
            DWORD                               rc;

            wfvbd.WaitForVerticalBlank = wfvbhalfn;
            wfvbd.lpDD = this;
            wfvbd.dwFlags = DDWAITVB_I_TESTVB;
            wfvbd.hEvent = 0;
            DOHALCALL( WaitForVerticalBlank, wfvbfn, wfvbd, rc, FALSE );
            if( rc == DDHAL_DRIVER_HANDLED )
            {
                *lpbIsInVB = wfvbd.bIsInVB;
                LEAVE_DDRAW();
                return wfvbd.ddRVal;
            }
        }
    }

    /*
     * no hardware support, so just pretend it works
     */
    {
        static BOOL     bLast=FALSE;
        *lpbIsInVB = bLast;
        bLast = !bLast;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_GetVerticalBlankStatus */

#undef DPF_MODNAME
#define DPF_MODNAME "GetScanLine"

/*
 * DD_GetScanLine
 */
HRESULT DDAPI DD_GetScanLine(
                LPDIRECTDRAW lpDD,
                LPDWORD lpdwScanLine )
{
    LPDDRAWI_DIRECTDRAW_INT             this_int;
    LPDDRAWI_DIRECTDRAW_LCL             this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL             this;
    LPDDHAL_GETSCANLINE gslhalfn;
    LPDDHAL_GETSCANLINE gslfn;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetScanLine");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        #ifdef WINNT
            // Update DDraw handle in driver GBL object.
            this->hDD = this_lcl->hDD;
        #endif //WINNT
        if( !VALID_DWORD_PTR( lpdwScanLine ) )
        {
            DPF_ERR( "Invalid scan line pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * ask the driver to get the current scanline
     */
    #pragma message( REMIND( "Need HEL GetScanLine" ))
    gslfn = this_lcl->lpDDCB->HALDD.GetScanLine;
    gslhalfn = this_lcl->lpDDCB->cbDDCallbacks.GetScanLine;
    if( gslhalfn != NULL )
    {
        DDHAL_GETSCANLINEDATA   gsld;
        DWORD                   rc;

        gsld.GetScanLine = gslhalfn;
        gsld.lpDD = this;
        DOHALCALL( GetScanLine, gslfn, gsld, rc, FALSE );
        if( rc == DDHAL_DRIVER_HANDLED )
        {
            *lpdwScanLine = gsld.dwScanLine;
            LEAVE_DDRAW();
            return gsld.ddRVal;
        }
    }

    *lpdwScanLine = 0;
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_GetScanLine */

#undef DPF_MODNAME
#define DPF_MODNAME "BuildDDCAPS"

/*
 * Build a fullsized, API visible DDCAPS structure from the multiple internal
 * caps structures in the global driver object.
 */
static void BuildDDCAPS( LPDDCAPS lpddcaps, LPDDRAWI_DIRECTDRAW_GBL pdrv, BOOL bHEL )
{
    LPDDCORECAPS           lpddcorecaps;
    LPDDNONLOCALVIDMEMCAPS lpddnlvcaps;
    LPDDMORECAPS           lpddmorecaps;
    LPDDSCAPSEX            lpddsExCaps;

    DDASSERT( NULL != lpddcaps );
    DDASSERT( NULL != pdrv );

    lpddcorecaps = ( bHEL ? &( pdrv->ddHELCaps ) : &( pdrv->ddCaps ) );
    lpddnlvcaps  = ( bHEL ? pdrv->lpddNLVHELCaps : pdrv->lpddNLVCaps );
    lpddmorecaps = ( bHEL ? pdrv->lpddHELMoreCaps : pdrv->lpddMoreCaps );
    lpddsExCaps  = ( bHEL ? &pdrv->ddsHELCapsMore : &pdrv->ddsCapsMore );

    memset( lpddcaps, 0, sizeof( DDCAPS ) );
    memcpy( lpddcaps, lpddcorecaps, sizeof( DDCORECAPS ) );
    if( NULL != lpddnlvcaps )
    {
        lpddcaps->dwNLVBCaps     = lpddnlvcaps->dwNLVBCaps;
        lpddcaps->dwNLVBCaps2    = lpddnlvcaps->dwNLVBCaps2;
        lpddcaps->dwNLVBCKeyCaps = lpddnlvcaps->dwNLVBCKeyCaps;
        lpddcaps->dwNLVBFXCaps   = lpddnlvcaps->dwNLVBFXCaps;
        memcpy( &( lpddcaps->dwNLVBRops[0] ), &( lpddnlvcaps->dwNLVBRops[0] ), DD_ROP_SPACE * sizeof( DWORD ) );
    }

    lpddcaps->ddsCaps.dwCaps = lpddcorecaps->ddsCaps.dwCaps;
    memcpy(&lpddcaps->ddsCaps.ddsCapsEx, lpddsExCaps, sizeof(lpddcaps->ddsCaps.ddsCapsEx) );

    if (lpddmorecaps != NULL)
    {
#ifdef POSTPONED2
        lpddcaps->dwAlphaCaps    = lpddmorecaps->dwAlphaCaps;
        lpddcaps->dwSVBAlphaCaps = lpddmorecaps->dwSVBAlphaCaps;
        lpddcaps->dwVSBAlphaCaps = lpddmorecaps->dwVSBAlphaCaps;
        lpddcaps->dwSSBAlphaCaps = lpddmorecaps->dwSSBAlphaCaps;

        lpddcaps->dwFilterCaps    = lpddmorecaps->dwFilterCaps;
        lpddcaps->dwSVBFilterCaps = lpddmorecaps->dwSVBFilterCaps;
        lpddcaps->dwVSBFilterCaps = lpddmorecaps->dwVSBFilterCaps;
        lpddcaps->dwSSBFilterCaps = lpddmorecaps->dwSSBFilterCaps;
        lpddcaps->dwTransformCaps    = lpddmorecaps->dwTransformCaps;
        lpddcaps->dwSVBTransformCaps = lpddmorecaps->dwSVBTransformCaps;
        lpddcaps->dwVSBTransformCaps = lpddmorecaps->dwVSBTransformCaps;
        lpddcaps->dwSSBTransformCaps = lpddmorecaps->dwSSBTransformCaps;

        lpddcaps->dwBltAffineMinifyLimit = lpddmorecaps->dwBltAffineMinifyLimit;
        lpddcaps->dwOverlayAffineMinifyLimit = lpddmorecaps->dwOverlayAffineMinifyLimit;
#endif //POSTPONED2
    }

    lpddcaps->dwSize = sizeof( DDCAPS );
} /* BuildDDCAPS */

#undef DPF_MODNAME
#define DPF_MODNAME "GetCaps"

/*
 * DD_GetCaps
 *
 * Retrieve all driver capabilites
 */
HRESULT DDAPI DD_GetCaps(
    LPDIRECTDRAW lpDD,
    LPDDCAPS lpDDDriverCaps,
    LPDDCAPS lpDDHELCaps )
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    DWORD           dwSize;
    DDCAPS                      ddcaps;
    DDSCAPS                     ddscaps;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetCaps");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        if( (lpDDDriverCaps == NULL) && (lpDDHELCaps == NULL) )
        {
            DPF_ERR( "Must specify at least one of driver or emulation caps" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( lpDDDriverCaps != NULL )
        {
            if( !VALID_DDCAPS_PTR( lpDDDriverCaps ) )
            {
                DPF_ERR( "Invalid driver caps pointer" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
        }
        if( lpDDHELCaps != NULL )
        {
            if( !VALID_DDCAPS_PTR( lpDDHELCaps ) )
            {
                DPF_ERR( "Invalid hel caps pointer" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * fill in caps fields
     */
    if( lpDDDriverCaps != NULL)
    {
        /*
         * We now have to assemble the final, API visible caps from multiple
         * sub-components scattered through the driver object. To make the size
         * computation simple we just build a full, API sized DDCAPS and then
         * just copy the appropritate portion of it. Cheesy in that involves an
         * extra copy of the data but very simple. This should not be performance
         * critical code to start with.
         */
        BuildDDCAPS( &ddcaps, this, FALSE );

        dwSize = lpDDDriverCaps->dwSize;
        ZeroMemory( lpDDDriverCaps, dwSize);
        memcpy( lpDDDriverCaps, &ddcaps, dwSize );
        lpDDDriverCaps->dwSize = dwSize;

        /*
         * Execute buffers are invisible to the user level API
         * so mask that caps bit off.
         */
        if (dwSize >= sizeof(DDCAPS))
        {
            /*
             * Only mask off the extended caps if they were queried for.
             */
            lpDDDriverCaps->ddsCaps.dwCaps &= ~DDSCAPS_EXECUTEBUFFER;
        }
        lpDDDriverCaps->ddsOldCaps.dwCaps &= ~DDSCAPS_EXECUTEBUFFER;

        /*
         * get amount of free video memory
         * Yes, I know I'm ignoring the return code. This is a conscious choice not to engender any
         * regression risks by changing return codes.
         */
        ZeroMemory(&ddscaps,sizeof(ddscaps));
        ddscaps.dwCaps = DDSCAPS_VIDEOMEMORY;
        DD_GetAvailableVidMem( lpDD, &ddscaps, &lpDDDriverCaps->dwVidMemTotal, &lpDDDriverCaps->dwVidMemFree );
    }

    /*
     * fill in hel caps
     */
    if( lpDDHELCaps != NULL )
    {
        /*
         * We now have to assemble the final, API visible caps from multiple
         * sub-components scattered through the driver object. To make the size
         * computation simple we just build a full, API sized DDCAPS and then
         * just copy the appropritate portion of it. Cheesy in that involves an
         * extra copy of the data but very simple. This should not be performance
         * critical code to start with.
         */
        BuildDDCAPS( &ddcaps, this, TRUE );

        dwSize = lpDDHELCaps->dwSize;
        ZeroMemory( lpDDHELCaps, dwSize);
        memcpy( lpDDHELCaps, &ddcaps, dwSize );
        lpDDHELCaps->dwSize = dwSize;

        /*
         * Again, execute buffers are invisible to the user level API
         * so mask that caps bit off.
         */
        if (dwSize >= sizeof(DDCAPS))
        {
            /*
             * Only mask off the extended caps if they were queried for.
             */
            lpDDHELCaps->ddsCaps.dwCaps &= ~DDSCAPS_EXECUTEBUFFER;
        }
        lpDDHELCaps->ddsOldCaps.dwCaps &= ~DDSCAPS_EXECUTEBUFFER;

        lpDDHELCaps->dwVidMemFree = 0;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_GetCaps */

#undef DPF_MODNAME
#define DPF_MODNAME "WaitForVerticalBlank"

/*
 * ModeX_WaitForVerticalBlank
 */
static void ModeX_WaitForVerticalBlank( DWORD dwFlags )
{
#if defined (WIN95) || defined ( NT_FIX )
    switch( dwFlags )
    {
    case DDWAITVB_BLOCKBEGIN:
        /*
         * if blockbegin is requested we wait until the vertical retrace
         * is over, and then wait for the display period to end.
         */
        while(IN_VBLANK());
        while(IN_DISPLAY());
        break;

    case DDWAITVB_BLOCKEND:
        /*
         * if blockend is requested we wait for the vblank interval to end.
         */
        if( IN_VBLANK() )
        {
            while( IN_VBLANK() );
        }
        else
        {
            while(IN_DISPLAY());
            while(IN_VBLANK());
        }
        break;
    }
#endif
} /* ModeX_WaitForVerticalBlank */

/*
 * DD_WaitForVerticalBlank
 */
HRESULT DDAPI DD_WaitForVerticalBlank(
                LPDIRECTDRAW lpDD,
                DWORD dwFlags,
                HANDLE hEvent )
{
    LPDDRAWI_DIRECTDRAW_INT             this_int;
    LPDDRAWI_DIRECTDRAW_LCL             this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL             this;
    LPDDHAL_WAITFORVERTICALBLANK        wfvbhalfn;
    LPDDHAL_WAITFORVERTICALBLANK        wfvbfn;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_WaitForVerticalBlank");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        #ifdef WINNT
            // Update DDraw handle in driver GBL object.
            this->hDD = this_lcl->hDD;
        #endif //WINNT

        if( (dwFlags & DDWAITVB_BLOCKBEGINEVENT) || (hEvent != NULL) )
        {
            DPF_ERR( "Event's not currently supported" );
            LEAVE_DDRAW();
            return DDERR_UNSUPPORTED;
        }

        if( (dwFlags != DDWAITVB_BLOCKBEGIN) && (dwFlags != DDWAITVB_BLOCKEND) )
        {
            DPF_ERR( "Invalid dwFlags" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * ask the driver to wait for the vertical blank
     */
    if( this->dwFlags & DDRAWI_MODEX )
    {
        ModeX_WaitForVerticalBlank( dwFlags );
    }
    else
    {
        #pragma message( REMIND( "Need HEL WaitForVerticalBlank" ))
        wfvbfn = this_lcl->lpDDCB->HALDD.WaitForVerticalBlank;
        wfvbhalfn = this_lcl->lpDDCB->cbDDCallbacks.WaitForVerticalBlank;
        if( wfvbhalfn != NULL )
        {
            DDHAL_WAITFORVERTICALBLANKDATA      wfvbd;
            DWORD                               rc;

            wfvbd.WaitForVerticalBlank = wfvbhalfn;
            wfvbd.lpDD = this;
            wfvbd.dwFlags = dwFlags;
            wfvbd.hEvent = (ULONG_PTR) hEvent;
            DOHALCALL( WaitForVerticalBlank, wfvbfn, wfvbd, rc, FALSE );
            if( rc == DDHAL_DRIVER_HANDLED )
            {
                LEAVE_DDRAW();
                return wfvbd.ddRVal;
            }
        }
    }

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_WaitForVerticalBlank */

#undef DPF_MODNAME
#define DPF_MODNAME "GetMonitorFrequency"

/*
 * DD_GetMonitorFrequency
 */
HRESULT DDAPI DD_GetMonitorFrequency(
                LPDIRECTDRAW lpDD,
                LPDWORD lpdwFrequency)
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetMonitorFrequency");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        if( !VALID_DWORD_PTR( lpdwFrequency ) )
        {
            DPF_ERR( "Invalid frequency pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( this->dwMonitorFrequency == 0 )
        {
            LEAVE_DDRAW();
            return DDERR_UNSUPPORTED;
        }
        *lpdwFrequency = this->dwMonitorFrequency;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_GetMonitorFrequency */

DWORD gdwSetIME = 0;

/*
 * DoneExclusiveMode
 */
void DoneExclusiveMode( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    DDHAL_SETEXCLUSIVEMODEDATA  semd;
    LPDDHAL_SETEXCLUSIVEMODE    semfn;
    LPDDHAL_SETEXCLUSIVEMODE    semhalfn;
    HRESULT                     rc;

    DPF( 4, "DoneExclusiveMode" );
    pdrv = pdrv_lcl->lpGbl;
    if( (pdrv->dwFlags & DDRAWI_FULLSCREEN) &&
        (pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
    {
        DPF( 4, "Enabling error mode, hotkeys" );
        SetErrorMode( pdrv_lcl->dwErrorMode );

        if( !( pdrv_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_SCREENSAVER ) )
        {
            BOOL        old;
            SystemParametersInfo( SPI_SCREENSAVERRUNNING, FALSE, &old, 0 );
        }

        #ifdef WINNT
            // Restore cursor shadow coming out of fullscreen
            SystemParametersInfo( SPI_SETCURSORSHADOW, 0, (LPVOID)ULongToPtr(pdrv_lcl->dwCursorShadow), 0 );
        #endif

        // Restore reactive menus coming out of fullscreen:
        SystemParametersInfo( SPI_SETHOTTRACKING, 0, (LPVOID)ULongToPtr(pdrv_lcl->dwHotTracking), 0 );
        InterlockedExchange(&gdwSetIME, pdrv_lcl->dwIMEState + 1);
    }
    pdrv->dwFlags &= ~(DDRAWI_FULLSCREEN);

    /*
     * Driver is no longer flipped to GDI surface.
     * NOTE: This does not mean its not showing the GDI surface just that
     * its no longer showing the GDI surface as a result of a FlipToGDISurface
     */
    pdrv->dwFlags &= ~(DDRAWI_FLIPPEDTOGDI);

    // restore the GDI palette
    // we let GDI do this by calling SetSystemPaletteUse() this will send
    // the right (ie what GDI thinks...) colors down to the device
    // this also flushes GDIs palette xlat cache.

#ifdef WIN95
    if( pdrv->dwModeIndex != DDUNSUPPORTEDMODE && NULL != pdrv->lpModeInfo)
#else
    if (NULL != pdrv->lpModeInfo)
#endif
    {
        if( pdrv->lpModeInfo[ pdrv->dwModeIndex ].wFlags & DDMODEINFO_PALETTIZED )
        {
            HDC         hdc;

            if( pdrv->cMonitors > 1 )
            {
                SetSystemPaletteUse( (HDC) (pdrv_lcl->hDC), SYSPAL_STATIC);
                DPF(4,"SetSystemPaletteUse STATICS ON (DoneExclusiveMode)");
            }
            else
            {
                hdc = GetDC(NULL);
                SetSystemPaletteUse(hdc, SYSPAL_STATIC);
                DPF(4,"SetSystemPaletteUse STATICS ON (DoneExclusiveMode)");
                ReleaseDC(NULL, hdc);
            }

            // if we have a primary
            if (pdrv_lcl->lpPrimary)
            {
                if (pdrv_lcl->lpPrimary->lpLcl->lpDDPalette) //if that primary has a palette
                {
                    pdrv_lcl->lpPrimary->lpLcl->lpDDPalette->lpLcl->lpGbl->dwFlags &= ~DDRAWIPAL_EXCLUSIVE;
                    DPF(5,"Setting non-exclusive for palette %08x",pdrv_lcl->lpPrimary->lpLcl->lpDDPalette->lpLcl);
                }
            }
        }

        #ifdef WINNT
            // this fixes DOS Box colors on NT.  We need to do this even in non-
            // palettized modes.
            PostMessage(HWND_BROADCAST, WM_PALETTECHANGED, (WPARAM)pdrv_lcl->hWnd, 0);
        #endif
    }

    /*
     * Restore the display mode in case it was changed while
     * in exclusive mode.
     * Only do this if we are not adhering to the v1 behaviour
     */
    if( !(pdrv_lcl->dwLocalFlags & DDRAWILCL_V1SCLBEHAVIOUR) )
    {
        RestoreDisplayMode( pdrv_lcl, TRUE );
    }

    /*
     * If the primary has a gamma ramp associated w/ it, set it now
     */
    if( ( pdrv_lcl->lpPrimary != NULL ) &&
        ( pdrv_lcl->lpPrimary->lpLcl->lpSurfMore->lpOriginalGammaRamp != NULL ) )
    {
        RestoreGamma( pdrv_lcl->lpPrimary->lpLcl, pdrv_lcl );
    }

    /*
     * Notify the driver that we are leaving exclusive mode.
     * NOTE: This is a HAL only call - the HEL does not get to
     * see it.
     * NOTE: We don't allow the driver to fail this call. This is
     * a notification callback only.
     */
    semfn    = pdrv_lcl->lpDDCB->HALDD.SetExclusiveMode;
    semhalfn = pdrv_lcl->lpDDCB->cbDDCallbacks.SetExclusiveMode;
    if( NULL != semhalfn )
    {
        semd.SetExclusiveMode = semhalfn;
        semd.lpDD             = pdrv;
        semd.dwEnterExcl      = FALSE;
        semd.dwReserved       = 0UL;
        DOHALCALL( SetExclusiveMode, semfn, semd, rc, FALSE );
        //
        // This assert has fired and confused many devs. Seems like the 3dfx and the pvr both
        // bounce us a failure code. It's clearly not serving its original purpose of making
        // driver devs return an ok code, so let's yank it.
        //
        //DDASSERT( ( DDHAL_DRIVER_HANDLED == rc ) && ( !FAILED( semd.ddRVal ) ) );
    }

    pdrv->lpExclusiveOwner = NULL;

    /*
     * changes to lpExclusiveOwner can only be made while the exclusive mode mutex is owned by this process
     */
    RELEASE_EXCLUSIVEMODE_MUTEX;

    ClipTheCursor(pdrv_lcl, NULL);

    // If we are going into window'ed mode and we are
    // emulated then we might need to turn on the VirtualDesktop flag.
    // We don't do this for 3Dfx, and we don't do this if the app
    // has chosen a monitor explicitly.
    if( ( pdrv->cMonitors > 1 ) &&
        (pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
    {
        pdrv->dwFlags |= DDRAWI_VIRTUALDESKTOP;

        // We need to update our device rect
        UpdateRectFromDevice( pdrv );
    }

} /* DoneExclusiveMode */

/*
 * StartExclusiveMode
 */
void StartExclusiveMode( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, DWORD dwFlags, DWORD pid )
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    DDHAL_SETEXCLUSIVEMODEDATA  semd;
    LPDDHAL_SETEXCLUSIVEMODE    semfn;
    LPDDHAL_SETEXCLUSIVEMODE    semhalfn;
    DWORD                       dwWaitResult;
    HRESULT                     rc;

    DPF( 4, "StartExclusiveMode" );
    pdrv = pdrv_lcl->lpGbl;

#if _WIN32_WINNT >= 0x0501
    {
        //Turn off ghosting for any exclusive-mode app
        //(Whistler onwards only)
        typedef void (WINAPI *PFN_NOGHOST)( void );
        HINSTANCE hInst = NULL;
        hInst = LoadLibrary( "user32.dll" );
        if( hInst )
        {
            PFN_NOGHOST pfnNoGhost = NULL;
            pfnNoGhost = (PFN_NOGHOST)GetProcAddress( (HMODULE)hInst, "DisableProcessWindowsGhosting" );
            if( pfnNoGhost )
            {
                pfnNoGhost();
            }
            FreeLibrary( hInst );
        }
    }
#endif // _WIN32_WINNT >= 0x0501


    /*
     * Preceeding code should have taken this mutex already.
     */

#if defined(WINNT) && defined(DEBUG)
    dwWaitResult = WaitForSingleObject(hExclusiveModeMutex, 0);
    DDASSERT(dwWaitResult == WAIT_OBJECT_0);
    ReleaseMutex(hExclusiveModeMutex);
#endif

    pdrv->lpExclusiveOwner = pdrv_lcl;

    if( (pdrv->dwFlags & DDRAWI_FULLSCREEN) &&
        (pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
    {
        pdrv_lcl->dwErrorMode = SetErrorMode( SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );
        {
            BOOL        old;

            /*
             * Don't send kepyboard events while the screen saver is running
             * or else USER gets confused
             */
            if( !( pdrv_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_SCREENSAVER ) )
            {
#ifdef WIN95
                // If the user has just switched to us, and then quickly
                // switched away from us, we may be in the Alt+Tab switch box.
                // If we are, then we need to get out of it or the user will
                // be forced to reboot the system. So we check to see if the
                // Alt key is down, and if so, force it up. Hacking is fun.
                if (GetAsyncKeyState(VK_MENU) & 0x80000000)
                {
                    keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0);
                }
#endif
                SystemParametersInfo( SPI_SCREENSAVERRUNNING, TRUE, &old, 0 );
            }

            #ifdef WINNT
                // Save current cursor shadow setting
                SystemParametersInfo( SPI_GETCURSORSHADOW, 0, (LPVOID) &(pdrv_lcl->dwCursorShadow), 0 );
                SystemParametersInfo( SPI_SETCURSORSHADOW, 0, 0, 0 );
            #endif

            // Save current hot-tracking setting
            SystemParametersInfo( SPI_GETHOTTRACKING, 0, (LPVOID) &(pdrv_lcl->dwHotTracking), 0 );
            SystemParametersInfo( SPI_GETSHOWIMEUI, 0, (LPVOID) &(pdrv_lcl->dwIMEState), 0 );

            //And turn it off as we go into exclusive mode
            SystemParametersInfo( SPI_SETHOTTRACKING, 0, 0, 0 );
            InterlockedExchange(&gdwSetIME, FALSE + 1);
            #ifdef WIN95
                if( dwFlags & DDSCL_ALLOWREBOOT )
                {
                    /*
                     * re-enable reboot after SPI_SCREENSAVERRUNNING, it disables it
                     */
                    DD16_EnableReboot( TRUE );
                }
            #endif
        }
    }

    /*
     * invalidate all primary surfaces.  This includes the primary surface
     * for the current process if it was created before exclusive mode was
     * entered.
     *
     * we must invalidate ALL surfaces in case the app doesn't switch the
     * mode. - craige 7/9/95
     */
    InvalidateAllSurfaces( pdrv, (HANDLE) pdrv_lcl->hDDVxd, TRUE );

    /*
     * If the primary has a gamma ramp associated w/ it, set it now
     */
    if( ( pdrv_lcl->lpPrimary != NULL ) &&
        ( pdrv_lcl->lpPrimary->lpLcl->lpSurfMore->lpGammaRamp != NULL ) )
    {
        SetGamma( pdrv_lcl->lpPrimary->lpLcl, pdrv_lcl );
    }

    /*
     * Notify the driver that we are entering exclusive mode.
     * NOTE: This is a HAL only call - the HEL does not get to
     * see it.
     * NOTE: We don't allow the driver to fail this call. This is
     * a notification callback only.
     */
    semfn    = pdrv_lcl->lpDDCB->HALDD.SetExclusiveMode;
    semhalfn = pdrv_lcl->lpDDCB->cbDDCallbacks.SetExclusiveMode;
    if( NULL != semhalfn )
    {
        semd.SetExclusiveMode = semhalfn;
        semd.lpDD             = pdrv;
        semd.dwEnterExcl      = TRUE;
        semd.dwReserved       = 0UL;
        DOHALCALL( SetExclusiveMode, semfn, semd, rc, FALSE );
        //
        // This assert has fired and confused many devs. Seems like the 3dfx and the pvr both
        // bounce us a failure code. It's clearly not serving its original purpose of making
        // driver devs return an ok code, so let's yank it.
        //
        //DDASSERT( ( DDHAL_DRIVER_HANDLED == rc ) && ( !FAILED( semd.ddRVal ) ) );
    }

    // If we are going into fullscreen mode
    // Then we might need to turn off the VirtualDesktop flag
    if( pdrv->cMonitors > 1 )
    {
        pdrv->dwFlags &= ~DDRAWI_VIRTUALDESKTOP;

        // We need to update our device rect
        UpdateRectFromDevice( pdrv );
    }

} /* StartExclusiveMode */

#undef DPF_MODNAME
#define DPF_MODNAME     "SetCooperativeLevel"

/*
 * DD_SetCooperativeLevel
 */
HRESULT DDAPI DD_SetCooperativeLevel(
                LPDIRECTDRAW lpDD,
                HWND hWnd,
                DWORD dwFlags )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DWORD                       pid;
    HRESULT                     ddrval;
    DWORD                       style;
    HWND                        old_hwnd;
    HWND                        hTemp;
    BOOL                        excl_exists;
    BOOL                        is_excl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_SetCooperativeLevel");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( dwFlags & ~DDSCL_VALID )
        {
            DPF_ERR( "Invalid flags specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if ((dwFlags & DDSCL_FPUSETUP) && (dwFlags & DDSCL_FPUPRESERVE))
        {
            DPF_ERR( "Only one DDSCL_FPU* flag can be specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }


        /*
         * If the device isn't attached to the desktop, we don't want
         * to mess w/ it's window because we'll get it wrong.
         */
        if( !( this->dwFlags & DDRAWI_ATTACHEDTODESKTOP ) )
        {
            dwFlags |= DDSCL_NOWINDOWCHANGES;
        }

        if( !(dwFlags & (DDSCL_EXCLUSIVE|DDSCL_NORMAL) ) &&
            !(dwFlags & DDSCL_SETFOCUSWINDOW ) )
        {
            DPF_ERR( "Must specify one of EXCLUSIVE or NORMAL" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( (dwFlags & DDSCL_EXCLUSIVE) && !(dwFlags & DDSCL_FULLSCREEN) )
        {
            DPF_ERR( "Must specify fullscreen for exclusive mode" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( (dwFlags & DDSCL_ALLOWMODEX) && !(dwFlags & DDSCL_FULLSCREEN) )
        {
            DPF_ERR( "Must specify fullscreen for modex" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( (hWnd != NULL) && !IsWindow( hWnd ) )
        {
            DPF_ERR( "Hwnd passed is not a valid window" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( (dwFlags & DDSCL_DONTHOOKHWND) && (dwFlags & DDSCL_EXCLUSIVE) )
        {
            DPF_ERR( "we must hook the window in exclusive mode" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( dwFlags & DDSCL_SETFOCUSWINDOW )
        {
            if( !( dwFlags & DDSCL_CREATEDEVICEWINDOW) &&
                ( dwFlags & ~(DDSCL_SETFOCUSWINDOW | DDSCL_ALLOWMODEX
                  | DDSCL_DX8APP | DDSCL_NOWINDOWCHANGES) ) )
            {
                DPF_ERR( "Flags invalid with DDSCL_SETFOCUSWINDOW" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
            if( this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE )
            {
                DPF_ERR( "Cannot reset focus window while exclusive mode is owned" );
                LEAVE_DDRAW();
                return DDERR_HWNDALREADYSET;
            }
        }

        if( dwFlags & DDSCL_SETDEVICEWINDOW )
        {
            if( dwFlags & (DDSCL_SETFOCUSWINDOW | DDSCL_CREATEDEVICEWINDOW) )
            {
                DPF_ERR( "Flags invalid with DDSCL_SETDEVICEWINDOW" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
            if( hWnd != NULL )
            {
                if( this_lcl->hFocusWnd == 0 )
                {
                    DPF_ERR( "Focus window has not been set" );
                    LEAVE_DDRAW();
                    return DDERR_NOFOCUSWINDOW;
                }
            }
        }

        if( ( dwFlags & DDSCL_CREATEDEVICEWINDOW ) &&
            ( this_lcl->hWnd != 0 ) &&
            !( this_lcl->dwLocalFlags & DDRAWILCL_CREATEDWINDOW ) )
        {
            DPF_ERR( "HWND already set - DDSCL_CREATEDEVICEWINDOW flag not valid" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( ( dwFlags & DDSCL_CREATEDEVICEWINDOW ) &&
            !( dwFlags & DDSCL_EXCLUSIVE ) )
        {
            DPF_ERR( "DDSCL_CREATEDEVICEWINDOW only valid with DDSCL_EXCLUSIVE" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( ( dwFlags & DDSCL_CREATEDEVICEWINDOW ) &&
            ( this_lcl->hWnd == 0 ) )
        {
            if( !( dwFlags & DDSCL_SETFOCUSWINDOW ) )
            {
                if( hWnd != NULL )
                {
                    DPF_ERR( "hWnd specified with DDSCL_CREATEDEVICEWINDOW" );
                    LEAVE_DDRAW();
                    return DDERR_INVALIDPARAMS;
                }
                if( this_lcl->hFocusWnd == 0 )
                {
                    DPF_ERR( "Focus window has not been set" );
                    LEAVE_DDRAW();
                    return DDERR_NOFOCUSWINDOW;
                }
            }
        }

        if( ( dwFlags & DDSCL_EXCLUSIVE ) &&
            !( dwFlags & DDSCL_CREATEDEVICEWINDOW ) )
        {
            if( NULL == hWnd )
            {
                DPF_ERR( "Hwnd must be specified for exclusive mode" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
            if( (GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD) )
            {
                DPF_ERR( "Hwnd must be a top level window" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
        }

        pid = GETCURRPID();

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * In v1, we allowed an app to set the mode while in exclusive mode but
     * we didn't restore the mode if the app lost exclusive mode.  We have
     * changed this behaviour in v2 to cause the display mode to be restored
     * when exclusive mode is lost.  If the v1 SetCooperativeLevel is ever
     * called then we revert back to the v1 behaviour to avoid breaking
     * existing apps.
     */
    if( this_int->lpVtbl == &ddCallbacks )
    {
        // This is the V1 SetCooperativeLevel
        this_lcl->dwLocalFlags |= DDRAWILCL_V1SCLBEHAVIOUR;
    }

    /*
     * don't mess with dialogs, this is a hack for DDTEST and DDCAPS.
     * Don't do this if the app specified the
     * SETDEVICEWINDOW/CREATEDEVICEWINDOW flags.
     */
    if( ( NULL != hWnd ) &&
        !( dwFlags & (DDSCL_SETDEVICEWINDOW|DDSCL_CREATEDEVICEWINDOW) ) )
    {
        style = GetWindowLong(hWnd, GWL_STYLE);
        if ((style & WS_CAPTION) == WS_DLGFRAME)
        {
            DPF( 2, "setting DDSCL_NOWINDOWCHANGES for caller" );
            dwFlags |= DDSCL_NOWINDOWCHANGES;
        }
    }

    if( dwFlags & DDSCL_EXCLUSIVE )
    {
        /*
         * This is one of exactly two cases where we keep the exclusive mode mutex (the other is
         * in dddefwp, wherein we are activated by alt-tab). We have to be careful to release the
         * mutex properly in failure modes.
         */
        if( !( dwFlags & DDSCL_SETFOCUSWINDOW ) )
        {
            hTemp = (HWND) this_lcl->hFocusWnd;
        }
        else
        {
            hTemp = hWnd;
        }
        CheckExclusiveMode(this_lcl, &excl_exists, &is_excl, TRUE, hTemp, TRUE );

        if( (excl_exists) &&
            (!is_excl) )
        {
            if( ( dwFlags & DDSCL_CREATEDEVICEWINDOW ) &&
                ( this_lcl->hWnd == 0 ) &&
                ( hWnd ) )
            {
                DestroyWindow(hWnd);
            }
            LEAVE_DDRAW();
            return DDERR_EXCLUSIVEMODEALREADYSET;
        }
    }

    /*
     * If we are only setting the focus window, save it now
     */
    if( dwFlags & DDSCL_SETFOCUSWINDOW )
    {
        this_lcl->hFocusWnd = (ULONG_PTR) hWnd;
        if( ( this_lcl->hWnd != 0 ) &&
            ( this_lcl->dwLocalFlags & DDRAWILCL_CREATEDWINDOW ) &&
            IsWindow( (HWND) this_lcl->hWnd ) )
        {
            SetWindowLongPtr( (HWND) this_lcl->hWnd, 0, (LONG_PTR) hWnd );
        }
        if( !( dwFlags & DDSCL_CREATEDEVICEWINDOW ) )
        {
            if (dwFlags & DDSCL_MULTITHREADED)
                this_lcl->dwLocalFlags |= DDRAWILCL_MULTITHREADED;
            if (dwFlags & DDSCL_FPUSETUP)
                this_lcl->dwLocalFlags |= DDRAWILCL_FPUSETUP;
            if (dwFlags & DDSCL_FPUPRESERVE)
                this_lcl->dwLocalFlags |= DDRAWILCL_FPUPRESERVE;

            /*
             * It's ok to always release the mutex here, because the only way we can get here is if we just took
             * exclusive mode, i.e. we didn't already have exclusive mode before this SetCoop call was made.
             */
            if( dwFlags & DDSCL_EXCLUSIVE )
            {
                RELEASE_EXCLUSIVEMODE_MUTEX;
            }

            LEAVE_DDRAW();
            return DD_OK;
        }
    }

    /*
     * Create the window now if we need to
     */
    if( ( dwFlags & DDSCL_CREATEDEVICEWINDOW ) &&
        ( this_lcl->hWnd == 0 ) )
    {
        WNDCLASS        cls;

        if( !GetClassInfo( hModule, szDeviceWndClass, &cls ) )
        {
            cls.lpszClassName  = szDeviceWndClass;
            cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
            cls.hInstance      = hModule;
            cls.hIcon          = NULL;
            cls.hCursor        = NULL;
            cls.lpszMenuName   = NULL;
            cls.style          = CS_DBLCLKS;
            cls.lpfnWndProc    = DeviceWindowProc;
            cls.cbWndExtra     = sizeof( INT_PTR );
            cls.cbClsExtra     = 0;
            if( RegisterClass(&cls) == 0 )
            {
                DPF_ERR( "RegisterClass failed" );
                RELEASE_EXCLUSIVEMODE_MUTEX;
                LEAVE_DDRAW();
                return DDERR_GENERIC;
            }
        }

        hWnd = CreateWindow(
            szDeviceWndClass,
            szDeviceWndClass,
            WS_OVERLAPPED|WS_POPUP|WS_VISIBLE,
            this->rectDevice.left,
            this->rectDevice.top,
            this->rectDevice.right - this->rectDevice.left,
            this->rectDevice.bottom - this->rectDevice.top,
            (HWND)this_lcl->hFocusWnd, NULL,
            hModule,
            (LPVOID) (this_lcl->hFocusWnd) );
        if( hWnd == NULL )
        {
            DPF_ERR( "Unable to create the device window" );
            RELEASE_EXCLUSIVEMODE_MUTEX;
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }

    // Destroy the old window if we created it ourselves
    if( ( hWnd != (HWND) this_lcl->hWnd ) &&
        IsWindow( (HWND) this_lcl->hWnd ) &&
        ( this_lcl->dwLocalFlags & DDRAWILCL_CREATEDWINDOW ) )
    {
        DestroyWindow( (HWND) this_lcl->hWnd );
        this_lcl->hWnd = 0;
        this_lcl->dwLocalFlags &= ~DDRAWILCL_CREATEDWINDOW;
    }

    // Save the hwnd in the local object for later reference
    old_hwnd = (HWND)this_lcl->hWnd;
    if( dwFlags & (DDSCL_SETDEVICEWINDOW | DDSCL_CREATEDEVICEWINDOW) )
    {
        (HWND) this_lcl->hWnd = hWnd;
        if( dwFlags & DDSCL_CREATEDEVICEWINDOW )
        {
            this_lcl->dwLocalFlags |= DDRAWILCL_CREATEDWINDOW;
        }
    }
    else
    {
        (HWND) this_lcl->hWnd = hWnd;
        (HWND) this_lcl->hFocusWnd = hWnd;
    }

    /*
     * allow modex modes?
     */
    if( (dwFlags & DDSCL_ALLOWMODEX) &&
        !( this->dwFlags & DDRAWI_MODEXILLEGAL ) )
    {
        DPF( 2, "*********** ALLOWING MODE X AND VGA MODES" );
        this_lcl->dwLocalFlags |= DDRAWILCL_ALLOWMODEX;
    }
    else
    {
        DPF( 2, "*********** NOT!! ALLOWING MODE X AND VGA MODES" );
        this_lcl->dwLocalFlags &= ~DDRAWILCL_ALLOWMODEX;
    }

    /*
     * exclusive mode?
     */
    if( dwFlags & DDSCL_EXCLUSIVE )
    {
        if( dwFlags & DDSCL_FULLSCREEN )
        {
            this->dwFlags |= DDRAWI_FULLSCREEN;
            this_lcl->dwLocalFlags |= DDRAWILCL_ISFULLSCREEN;
        }

        // Only hook if exclusive mode requested
        if( !(dwFlags & DDSCL_DONTHOOKHWND) )
        {
            ddrval = SetAppHWnd( this_lcl, hWnd, dwFlags );

            if( ddrval != DD_OK )
            {
                DPF( 1, "Could not hook HWND!" );
                //We don't release the exclusive mode mutex here, because we are already committed to owning
                //it by the lines just above.
                LEAVE_DDRAW();
                return ddrval;
            }
            this_lcl->dwLocalFlags |= DDRAWILCL_HOOKEDHWND;
        }

        if( !is_excl )
        {
            StartExclusiveMode( this_lcl, dwFlags, pid );
            this_lcl->dwLocalFlags |= DDRAWILCL_ACTIVEYES;
            this_lcl->dwLocalFlags &=~DDRAWILCL_ACTIVENO;
            if( hWnd != NULL )
            {
                extern void InternalSetForegroundWindow(HWND hWnd);
                InternalSetForegroundWindow(hWnd);
            }
            this_lcl->dwLocalFlags |= DDRAWILCL_HASEXCLUSIVEMODE;
            ClipTheCursor(this_lcl, &(this->rectDevice));
        }
    }
    /*
     * no, must be regular
     */
    else
    {
        if( this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE )
        {
            /*
             * If we are leaving exclusive mode ensure we are
             * looking at the GDI surface.
             */
            DD_FlipToGDISurface( lpDD );

            DoneExclusiveMode( this_lcl );
            this_lcl->dwLocalFlags &= ~(DDRAWILCL_ISFULLSCREEN |
                                        DDRAWILCL_ALLOWMODEX |
                                        DDRAWILCL_HASEXCLUSIVEMODE);

            // Lost exclusive mode, need to remove window hook?
            if( this_lcl->dwLocalFlags & DDRAWILCL_HOOKEDHWND )
            {
                ddrval = SetAppHWnd( this_lcl, NULL, dwFlags );

                if( ddrval != DD_OK )
                {
                    DPF( 1, "Could not unhook HWND!" );
                    //No need to release excl mutex here, since DoneExclusiveMode does it.
                    LEAVE_DDRAW();
                    HIDESHOW_IME();     //Show/hide the IME OUTSIDE of the ddraw critsect.
                    return ddrval;
                }
                this_lcl->dwLocalFlags &= ~DDRAWILCL_HOOKEDHWND;
            }

            /*
             * make the window non-topmost
             */
            if (!(dwFlags & DDSCL_NOWINDOWCHANGES) && (IsWindow(old_hwnd)))
            {
                SetWindowPos(old_hwnd, HWND_NOTOPMOST,
                    0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
            }
        }

        // If we are going into window'ed mode and we are
        // emulated then we might need to turn on the VirtualDesktop flag.
        // We don't do this for 3Dfx, and we don't do this if the app
        // has chosen a monitor explicitly.
        if( ( this->cMonitors > 1 ) &&
            (this->dwFlags & DDRAWI_DISPLAYDRV) )
        {
            this->dwFlags |= DDRAWI_VIRTUALDESKTOP;

            // We need to update our device rect
            UpdateRectFromDevice( this );
        }
    }

    // Allow other DD objects to be created now.
    this_lcl->dwLocalFlags |= DDRAWILCL_SETCOOPCALLED;

    if (dwFlags & DDSCL_MULTITHREADED)
        this_lcl->dwLocalFlags |= DDRAWILCL_MULTITHREADED;
    if (dwFlags & DDSCL_FPUSETUP)
        this_lcl->dwLocalFlags |= DDRAWILCL_FPUSETUP;
    if (dwFlags & DDSCL_FPUPRESERVE)
        this_lcl->dwLocalFlags |= DDRAWILCL_FPUPRESERVE;
    LEAVE_DDRAW();
    HIDESHOW_IME();     //Show/hide the IME OUTSIDE of the ddraw critsect.
    return DD_OK;

} /* DD_SetCooperativeLevel */

#undef DPF_MODNAME
#define DPF_MODNAME     "DuplicateSurface"

/*
 * DD_DuplicateSurface
 *
 * Create a duplicate surface from an existing one.
 * The surface will have the same properties and point to the same
 * video memory.
 */
HRESULT DDAPI DD_DuplicateSurface(
                LPDIRECTDRAW lpDD,
                LPDIRECTDRAWSURFACE lpDDSurface,
                LPDIRECTDRAWSURFACE FAR *lplpDupDDSurface )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_LCL   orig_surf_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL   new_surf_lcl;
    LPDDRAWI_DDRAWSURFACE_INT   orig_surf_int;
    LPDDRAWI_DDRAWSURFACE_INT   new_surf_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_DuplicateSurface");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        orig_surf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( orig_surf_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }

        orig_surf_lcl = orig_surf_int->lpLcl;
        if( SURFACE_LOST( orig_surf_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        if( !VALID_PTR_PTR( lplpDupDDSurface ) )
        {
            DPF_ERR( "Invalid dup surface pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        *lplpDupDDSurface = NULL;

        /*
         * make sure we can duplicate this baby
         */
        if( orig_surf_lcl->ddsCaps.dwCaps & (DDSCAPS_PRIMARYSURFACE) )
        {
            DPF_ERR( "Can't duplicate primary surface" );
            LEAVE_DDRAW();
            return DDERR_CANTDUPLICATE;
        }

        if( orig_surf_lcl->dwFlags & (DDRAWISURF_IMPLICITCREATE) )
        {
            DPF_ERR( "Can't duplicate implicitly created surfaces" );
            LEAVE_DDRAW();
            return DDERR_CANTDUPLICATE;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * go make ourselves a new interface for this surface...
     */
    new_surf_lcl = NewSurfaceLocal( orig_surf_lcl, orig_surf_int->lpVtbl );
    if( NULL == new_surf_lcl )
    {
        LEAVE_DDRAW();
        return DDERR_OUTOFMEMORY;
    }

    /*
     * NewSurfaceLocal does not initialize the lpDD_lcl field of the
     * local surface object's lpSurfMore data structure. Need to do
     * this here as it is needed by Release.
     */
    new_surf_lcl->lpSurfMore->lpDD_lcl = this_lcl;
    new_surf_lcl->lpSurfMore->lpDD_int = this_int;

    new_surf_int = NewSurfaceInterface( new_surf_lcl, orig_surf_int->lpVtbl );
    if( new_surf_int == NULL )
    {
        MemFree(new_surf_lcl);
        LEAVE_DDRAW();
        return DDERR_OUTOFMEMORY;
    }
    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)new_surf_int );

    if( new_surf_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
    {
        new_surf_lcl->dbnOverlayNode.object = new_surf_lcl;
        new_surf_lcl->dbnOverlayNode.object_int = new_surf_int;
    }

    LEAVE_DDRAW();

    *lplpDupDDSurface = (LPDIRECTDRAWSURFACE) new_surf_int;
    return DD_OK;

} /* DD_DuplicateSurface */

#undef DPF_MODNAME
#define DPF_MODNAME     "GetGDISurface"

/*
 * DD_GetGDISurface
 *
 * Get the current surface associated with GDI
 */
HRESULT DDAPI DD_GetGDISurface(
                LPDIRECTDRAW lpDD,
                LPDIRECTDRAWSURFACE FAR *lplpGDIDDSurface )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf;
    LPDDRAWI_DDRAWSURFACE_INT   next_int;
    LPDDRAWI_DDRAWSURFACE_LCL   next_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   next;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetGDISurface");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        if( !VALID_PTR_PTR( lplpGDIDDSurface ) )
        {
            DPF_ERR( "Invalid gdi surface pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *lplpGDIDDSurface = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * go find the surface. start at the primary, look at all attached...
     */
    psurf_int = this_lcl->lpPrimary;
    if( psurf_int != NULL )
    {
        psurf_lcl = psurf_int->lpLcl;
        psurf = psurf_lcl->lpGbl;
        if( !(psurf->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) ) //psurf->fpVidMem != this->fpPrimaryOrig )
        {
            next_int = FindAttachedFlip( psurf_int );
            if( next_int != NULL && next_int != psurf_int )
            {
                next_lcl = next_int->lpLcl;
                next = next_lcl->lpGbl;
                do
                {
                    if( next->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE ) //next->fpVidMem == this->fpPrimaryOrig )
                    {
                        /*
                         * DirectDraw's COM behavior has changed with IDD4:
                         * IDD4 returns IDDSurface4 and IDD5 returns IDDSurface7.
                         * Create the new surface interface object only if we need to.
                         */
                        if ( !LOWERTHANDDRAW4(this_int) )
                        {
                            // This is IDD4 or above. Assume IDD4 initially:
                            LPVOID pddSurfCB = &ddSurface4Callbacks;

                            if (this_int->lpVtbl == &dd7Callbacks)
                            {
                                // This is IDD7, so we must return IDDSurface7.
                                pddSurfCB = &ddSurface7Callbacks;
                            }
                            if (next_int->lpVtbl != pddSurfCB)
                            {
                                // Need to make IDDSurface? level match IDD? level.
                                next_int = NewSurfaceInterface( next_lcl, pddSurfCB );
                            }
                        }

                        DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) next_int );
                        *lplpGDIDDSurface = (LPDIRECTDRAWSURFACE) next_int;
                        LEAVE_DDRAW();
                        return DD_OK;
                    }
                    next_int = FindAttachedFlip( next_int );
                } while( next_int != psurf_int );
            }
            DPF_ERR( "Not found" );
        }
        else
        {
            /*
             * DirectDraw's COM behavior has changed with IDD4:
             * IDD4 returns IDDSurface4 and IDD7 returns IDDSurface7.
             * Create the new surface interface object only if we need to.
             */
            if ( !LOWERTHANDDRAW4(this_int) )
            {
                // This is IDD4 or above. Assume IDD4 initially:
                LPVOID pddSurfCB = &ddSurface4Callbacks;

                if (this_int->lpVtbl == &dd7Callbacks)
                {
                    // This is IDD7, so we must return IDDSurface7.
                    pddSurfCB = &ddSurface7Callbacks;
                }
                if (psurf_int->lpVtbl != pddSurfCB)
                {
                    // Need to make IDDSurface? level match IDD? level.
                    psurf_int = NewSurfaceInterface( psurf_lcl, pddSurfCB );
                }
            }

            DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) psurf_int );
            *lplpGDIDDSurface = (LPDIRECTDRAWSURFACE) psurf_int;
            LEAVE_DDRAW();
            return DD_OK;
        }
    }
    else
    {
        DPF_ERR( "No Primary Surface" );
    }
    LEAVE_DDRAW();
    return DDERR_NOTFOUND;

} /* DD_GetGDISurface */

#undef DPF_MODNAME
#define DPF_MODNAME     "FlipToGDISurface"


/*
 * FlipToGDISurface
 */
HRESULT FlipToGDISurface( LPDDRAWI_DIRECTDRAW_LCL   pdrv_lcl,
                          LPDDRAWI_DDRAWSURFACE_INT psurf_int) //, FLATPTR fpprim )
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_INT   attached_int;
    DDHAL_FLIPTOGDISURFACEDATA  ftgsd;
    LPDDHAL_FLIPTOGDISURFACE    ftgsfn;
    LPDDHAL_FLIPTOGDISURFACE    ftgshalfn;
    HRESULT                     ddrval;

    pdrv = pdrv_lcl->lpGbl;

    psurf_lcl = psurf_int->lpLcl;
    if( psurf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
        return DD_OK;

    /*
     * Notify the driver that we are about to flip to GDI
     * surface.
     * NOTE: This is a HAL only call - it means nothing to the
     * HEL.
     * NOTE: If the driver handles this call then we do not
     * attempt to do the actual flip. This is to support cards
     * which do not have GDI surfaces. If the driver does not
     * handle the call we will continue on and do the flip.
     */
    ftgsfn     = pdrv_lcl->lpDDCB->HALDD.FlipToGDISurface;
    ftgshalfn  = pdrv_lcl->lpDDCB->cbDDCallbacks.FlipToGDISurface;
    if( NULL != ftgshalfn )
    {
        ftgsd.FlipToGDISurface = ftgshalfn;
        ftgsd.lpDD             = pdrv;
        ftgsd.dwToGDI          = TRUE;
        ftgsd.dwReserved       = 0UL;
        DOHALCALL( FlipToGDISurface, ftgsfn, ftgsd, ddrval, FALSE );
        if( DDHAL_DRIVER_HANDLED == ddrval )
        {
            if( !FAILED( ftgsd.ddRVal ) )
            {
                /*
                 * The driver is not showing the GDI surface as a
                 * result of a flip to GDI operation.
                 */
                pdrv->dwFlags |= DDRAWI_FLIPPEDTOGDI;
                DPF( 4, "Driver handled FlipToGDISurface" );
                return ftgsd.ddRVal;
            }
            else
            {
                DPF_ERR( "Driver failed FlipToGDISurface" );
                return ftgsd.ddRVal;
            }
        }
    }

    /*
     * We used to only call this function if the flip was actaully needed,
     * but 3DFX requested that we always call them, so now this fucntion
     * is always called.  If we make it this far, it's not a 3DFX and we don't
     * need to do anything more if the GDI surface is already visible.
     */
    if( psurf_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE)
    {
        return DD_OK;
    }

    /*
     * No HAL entry point. If this is not a GDI driver we will
     * fail the call with NOGDI.
     */
    if( ( NULL == ftgshalfn ) && !( pdrv->dwFlags & DDRAWI_DISPLAYDRV ) )
    {
        DPF( 0, "Not a GDI driver" );
        return DDERR_NOGDI;
    }

    /*
     * Driver did not handle FlipToGDISurface so do the default action
     * (the actual flip).
     *
     * go find our partner in the attachment list
     */
    attached_int = FindAttachedFlip( psurf_int );
    if( attached_int == NULL )
    {
        return DDERR_NOTFOUND;
    }
    while( attached_int != psurf_int )
    {
        if( attached_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) //->lpGbl->fpVidMem == fpprim )
        {
            break;
        }
        attached_int = FindAttachedFlip( attached_int );
    }

    /*
     * flip between the two buddies
     */
    ddrval = DD_Surface_Flip( (LPDIRECTDRAWSURFACE) psurf_int,
            (LPDIRECTDRAWSURFACE) attached_int, DDFLIP_WAIT );
    if( ddrval != DD_OK )
    {
        DPF_ERR( "Couldn't do the flip!" );
        DPF( 5, "Error = %08lx (%ld)", ddrval, LOWORD( ddrval ) );
    }

    /*
     * The driver is now showing the GDI surface as a result of a
     * FlipToGDISurface operation.
     */
    pdrv->dwFlags |= DDRAWI_FLIPPEDTOGDI;

    return ddrval;

} /* FlipToGDISurface */

/*
 * DD_FlipToGDISurface
 *
 * Get the current surface associated with GDI
 */
HRESULT DDAPI DD_FlipToGDISurface( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf;
    HRESULT                     ddrval;
//    FLATPTR                     fpprim;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_FlipToGDISurface");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    psurf_int = this_lcl->lpPrimary;
    if( psurf_int == NULL )
    {
        DPF(2, "No Primary Surface" );
        LEAVE_DDRAW();
        return DDERR_NOTFOUND;
    }

    psurf_lcl = psurf_int->lpLcl;
    psurf = psurf_lcl->lpGbl;
    if( !(psurf_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP) )
    {
        DPF_ERR( "Primary surface isn't flippable" );
        LEAVE_DDRAW();
        return DDERR_NOTFLIPPABLE;
    }

    /*
     * Always call FlipToGDISurface because it benefits 3DFX
     */
//    fpprim = this->fpPrimaryOrig;
    ddrval = FlipToGDISurface( this_lcl, psurf_int); //, fpprim );

    LEAVE_DDRAW();
    return ddrval;

} /* DD_FlipToGDISurface */

#undef DPF_MODNAME
#define DPF_MODNAME "GetFourCCCodes"

/*
 * DD_GetFourCCCodes
 */
HRESULT DDAPI DD_GetFourCCCodes(
                LPDIRECTDRAW lpDD,
                DWORD FAR *lpNumCodes,
                DWORD FAR *lpCodes )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    int                         numcodes;
    int                         i;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetFourCCCodes");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        if( !VALID_DWORD_PTR( lpNumCodes ) )
        {
            DPF_ERR( "Invalid number of codes pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( (*lpNumCodes > 0) && (lpCodes != NULL) )
        {
            if( !VALID_DWORD_ARRAY( lpCodes, *lpNumCodes ) )
            {
                DPF_ERR( "Invalid array of codes" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
        }
        if( lpCodes == NULL )
        {
            *lpNumCodes = this->dwNumFourCC;
        }
        else
        {
            numcodes = min( *lpNumCodes, this->dwNumFourCC );
            *lpNumCodes = numcodes;
            for( i=0;i<numcodes;i++ )
            {
                lpCodes[i] = this->lpdwFourCC[i];
            }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_GetFourCCCodes */

#undef DPF_MODNAME
#define DPF_MODNAME "Compact"

/*
 * DD_Compact
 */
HRESULT DDAPI DD_Compact( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Compact");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( this->lpExclusiveOwner != this_lcl )
        {
            LEAVE_DDRAW();
            return DDERR_NOEXCLUSIVEMODE;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    #pragma message( REMIND( "Compact not implemented in Rev 1" ) )


    LEAVE_DDRAW();
    return DD_OK;

}/* DD_Compact */

#undef DPF_MODNAME
#define DPF_MODNAME "GetAvailableVidMem"

/*
 * DD_GetAvailableVidMem
 */
HRESULT DDAPI DD_GetAvailableVidMem( LPDIRECTDRAW lpDD, LPDDSCAPS lpDDSCaps, LPDWORD lpdwTotal, LPDWORD lpdwFree )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DDSCAPS2                    ddscaps2 = {0,0,0,0};
    HRESULT                     hr=DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetAvailableVidMem");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        /*
         * This call only considers vram so if running in emulation
         * only there really is no point.
         */
        if( this->dwFlags & DDRAWI_NOHARDWARE )
        {
            DPF_ERR( "No video memory - running emulation only" );
            LEAVE_DDRAW();
            return DDERR_NODIRECTDRAWHW;
        }

        ddscaps2.dwCaps = lpDDSCaps->dwCaps;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Invalid DDSCAPS pointer" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    hr = DD_GetAvailableVidMem4(lpDD, & ddscaps2, lpdwTotal, lpdwFree);
    LEAVE_DDRAW();

    return hr;
}

HRESULT DDAPI DD_GetAvailableVidMem4( LPDIRECTDRAW lpDD, LPDDSCAPS2 lpDDSCaps, LPDWORD lpdwTotal, LPDWORD lpdwFree )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DWORD                       dwLocalFree;
    DWORD                       dwNonLocalFree;
    DWORD                       dwLocalTotal;
    DWORD                       dwNonLocalTotal;
#ifndef WINNT
    LPVIDMEM                    pvm;
    int                         i;
#endif

    LPDDHAL_GETAVAILDRIVERMEMORY gadmfn;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetAvailableVidMem4");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        #ifdef WINNT
            // Update DDraw handle in driver GBL object.
            this->hDD = this_lcl->hDD;
        #endif //WINNT

        /*
         * This call only considers vram so if running in emulation
         * only there really is no point.
         */
        if( this->dwFlags & DDRAWI_NOHARDWARE )
        {
            DPF_ERR( "No video memory - running emulation only" );
            LEAVE_DDRAW();
            return DDERR_NODIRECTDRAWHW;
        }

        if( !VALID_DDSCAPS2_PTR( lpDDSCaps ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * Check for generically bogus caps.
         */
        if( lpDDSCaps->dwCaps & ~DDSCAPS_VALID )
        {
            DPF_ERR( "Invalid surface caps specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDCAPS;
        }

        if( lpDDSCaps->dwCaps2 & ~DDSCAPS2_VALID )
        {
            DPF_ERR( "Invalid surface caps2 specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDCAPS;
        }

        if( lpDDSCaps->dwCaps3 & ~DDSCAPS3_VALID )
        {
            DPF_ERR( "Invalid surface caps3 specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDCAPS;
        }

        if( lpDDSCaps->dwCaps4 & ~DDSCAPS4_VALID )
        {
            DPF_ERR( "Invalid surface caps4 specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDCAPS;
        }

        /*
         * !!! NOTE: Consider using the capability checking code
         * of CreateSurface here to ensure no strange bit combinations
         * are passed in.
         */
        if( lpDDSCaps->dwCaps & AVAILVIDMEM_BADSCAPS )
        {
            DPF_ERR( "Invalid surface capability bits specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * The caller can pass NULL for lpdwTotal or lpdwFree if
         * they are not interested in that info. However, they
         * can't pass NULL for both.
         */
        if( ( lpdwTotal == NULL ) && ( lpdwFree == NULL ) )
        {
            DPF_ERR( "Can't specify NULL for both total and free memory" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( ( lpdwTotal != NULL ) && !VALID_DWORD_PTR( lpdwTotal ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( ( lpdwFree != NULL ) && !VALID_DWORD_PTR( lpdwFree ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    // Initialize values
    dwLocalFree  = 0UL;
    dwNonLocalFree = 0UL;
    dwLocalTotal = 0UL;
    dwNonLocalTotal = 0UL;

    if( lpdwTotal != NULL )
    {
        *lpdwTotal = 0UL;
    }
    if( lpdwFree != NULL )
    {
        *lpdwFree = 0UL;
    }

    DPF(5,"GetAvailableVidmem called for:");
    DPF_STRUCT(5,V,DDSCAPS2,lpDDSCaps);

#ifndef WINNT
    for( i=0;i<(int)this->vmiData.dwNumHeaps;i++ )
    {

        pvm = &this->vmiData.pvmList[i];

        /*
         * We use ddsCapsAlt as we wish to return the total amount
         * of memory of the given type it is possible to allocate
         * regardless of whether is is desirable to allocate that
         * type of memory from a given heap or not.
         * We need to keep a separate count of what's in nonlocal,
         * since we may need to cap that amount to respect the commit policy.
         */
        if( (lpDDSCaps->dwCaps & pvm->ddsCapsAlt.dwCaps) == 0 )
        {
            if ( pvm->dwFlags & VIDMEM_ISNONLOCAL )
            {
                DPF(5,V,"Heap number %d adds %08x (%d) free bytes of nonlocal",i,VidMemAmountFree( pvm->lpHeap ),VidMemAmountFree( pvm->lpHeap ));
                DPF(5,V,"Heap number %d adds %08x (%d) allocated bytes of nonlocal",i,VidMemAmountAllocated( pvm->lpHeap ),VidMemAmountAllocated( pvm->lpHeap ));
                dwNonLocalFree += VidMemAmountFree( pvm->lpHeap );
                dwNonLocalTotal += VidMemAmountAllocated( pvm->lpHeap );
            }
            else
            {
                DPF(5,V,"Heap number %d adds %08x free bytes of local",i,VidMemAmountFree( pvm->lpHeap ));
                DPF(5,V,"Heap number %d adds %08x (%d) allocated bytes of local",i,VidMemAmountAllocated( pvm->lpHeap ),VidMemAmountAllocated( pvm->lpHeap ));
                dwLocalFree += VidMemAmountFree( pvm->lpHeap );
                dwLocalTotal += VidMemAmountAllocated( pvm->lpHeap );
            }
        }
    }
    dwLocalTotal += dwLocalFree;
    dwNonLocalTotal += dwNonLocalFree;
#endif //not WINNT

    // Try asking the driver
    gadmfn     = this_lcl->lpDDCB->HALDDMiscellaneous.GetAvailDriverMemory;
    /*
     * Only ask the driver about nonlocal vidmem if it understands the concept.
     */
    if( (gadmfn != NULL) &&
        (((lpDDSCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM) == 0) || (this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM))
        )
    {
        DDHAL_GETAVAILDRIVERMEMORYDATA  gadmd;
        DWORD                           rc;

        DDASSERT( VALIDEX_CODE_PTR( gadmfn ) );

        gadmd.lpDD = this;
        gadmd.DDSCaps.dwCaps = lpDDSCaps->dwCaps;
        gadmd.ddsCapsEx = lpDDSCaps->ddsCapsEx;

        DOHALCALL( GetAvailDriverMemory, gadmfn, gadmd, rc, FALSE );

        if( rc == DDHAL_DRIVER_HANDLED )
        {
            if( lpDDSCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM )
            {
                DPF(5,V,"Driver adds %08x private free nonlocal bytes",gadmd.dwFree);
                DPF(5,V,"Driver adds %08x private total nonlocal bytes",gadmd.dwTotal);
                dwNonLocalFree += gadmd.dwFree;
                dwNonLocalTotal += gadmd.dwTotal;
            }
            else
            {
                DPF(5,V,"Driver adds %08x (%d) private free local bytes",gadmd.dwFree,gadmd.dwFree);
                DPF(5,V,"Driver adds %08x (%d) private total local bytes",gadmd.dwTotal,gadmd.dwTotal);
                dwLocalFree += gadmd.dwFree;
                dwLocalTotal += gadmd.dwTotal;
            }
        }
        else
        {
            DPF_ERR( "GetAvailDriverMemory failed!" );
        }
    }

    if( lpdwFree != NULL )
    {
        *lpdwFree = dwLocalFree;
        if (lpDDSCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            //report nonlocal if it was asked for
            *lpdwFree += dwNonLocalFree;
        }
        else if ( ((this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS) == 0) ||
                  ((this_lcl->lpGbl->lpD3DGlobalDriverData) &&
                   (this_lcl->lpGbl->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURENONLOCALVIDMEM ) &&
                    (lpDDSCaps->dwCaps & DDSCAPS_TEXTURE) )
                )
        {
            //If nonlocal wasn't asked for, then report it only if it's either execute model, or the app is asking
            //for textures, and the part can texture nonlocal
            *lpdwFree += dwNonLocalFree;
        }
    }

    if( lpdwTotal != NULL )
    {
        *lpdwTotal = dwLocalTotal;
        if (lpDDSCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            //report nonlocal if it was asked for
            *lpdwTotal += dwNonLocalTotal;
        }
        else if ( ((this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS) == 0) ||
                  ((this_lcl->lpGbl->lpD3DGlobalDriverData) &&
                   (this_lcl->lpGbl->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURENONLOCALVIDMEM ) &&
                    (lpDDSCaps->dwCaps & DDSCAPS_TEXTURE) )
                )
        {
            //If nonlocal wasn't asked for, then report it only if it's either execute model, or the app is asking
            //for textures, and the part can texture nonlocal
            *lpdwTotal += dwNonLocalTotal;
        }
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_GetAvailableVidMem */

#undef DPF_MODNAME
#define DPF_MODNAME "DD_Initialize"

/*
 * DD_Initialize
 *
 * Initialize a DirectDraw object that was created via the class factory
 */
HRESULT DDAPI DD_Initialize( LPDIRECTDRAW lpDD, GUID FAR * lpGUID )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    HRESULT                     hr;
    LPDIRECTDRAW                tmplpdd;
    LPVOID                      lpOldCallbacks;
    IUnknown                    *lpOldIUnknown=NULL;
    BOOL                        bDX7=FALSE;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Initialize");
    /* DPF_ENTERAPI(lpDD); */

    DPF( 5, "****** DirectDraw::Initialize( 0x%08lx ) ******", lpGUID );
    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        if( this_lcl->lpGbl != NULL )
        {
            DPF_ERR( "Already initialized." );
            LEAVE_DDRAW();
            return DDERR_ALREADYINITIALIZED;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * If the object is uninitialized put the real vtable in place.
     */
    lpOldCallbacks = NULL;
    if( this_int->lpVtbl == &ddUninitCallbacks )
    {
        lpOldCallbacks = this_int->lpVtbl;
        this_int->lpVtbl = &ddCallbacks;
    }
    else if( this_int->lpVtbl == &dd2UninitCallbacks )
    {
        lpOldCallbacks = this_int->lpVtbl;
        this_int->lpVtbl = &dd2Callbacks;
    }
    else if( this_int->lpVtbl == &dd4UninitCallbacks )
    {
        lpOldCallbacks = this_int->lpVtbl;
        this_int->lpVtbl = &dd4Callbacks;
    }
    else if( this_int->lpVtbl == &dd7UninitCallbacks )
    {
        lpOldCallbacks = this_int->lpVtbl;
        this_int->lpVtbl = &dd7Callbacks;
        bDX7=TRUE;
    }
    /*
     * Note that a call to Initialize off of the uninitnondelegatingiunknown vtbl
     * is not possible, since the Initialize method doesn't exist in that interface
     */

#ifdef POSTPONED
    /*
     * Also need to fix up the owning unknown to point to the initialized non delegating unknown
     * This is the non-aggregated case. In the aggregated case, the owning IUnknown will
     * not have our vtable, and we also don't need to mess with it.
     */
    lpOldIUnknown = this_int->lpLcl->pUnkOuter;
    if (this_int->lpLcl->pUnkOuter ==  (IUnknown*) &UninitNonDelegatingIUnknownInterface )
    {
        this_int->lpLcl->pUnkOuter =  (IUnknown*) &NonDelegatingIUnknownInterface;
    }
#endif

    hr = InternalDirectDrawCreate( (GUID *)lpGUID, &tmplpdd, this_int, bDX7 ? DDRAWILCL_DIRECTDRAW7 : 0UL, NULL );
    if( FAILED( hr ) && ( lpOldCallbacks != NULL ) )
    {
        /*
         * As initialization has failed put the vtable and the owner back the way it was
         * before.
         */
        this_int->lpVtbl = lpOldCallbacks;
#ifdef POSTPONED
        this_int->lpLcl->pUnkOuter = lpOldIUnknown;
#endif
    }

    LEAVE_DDRAW();
    return hr;

} /* DD_Initialize */


#ifdef WINNT
BOOL IsWinlogonThread (void)
 
{
    BOOL    fResult = FALSE;
    DWORD   dwLengthNeeded;
    TCHAR   szThreadDesktopName[256];
 
    if (GetUserObjectInformation(GetThreadDesktop(GetCurrentThreadId()),
                                 UOI_NAME,
                                 szThreadDesktopName, 
                                 sizeof(szThreadDesktopName), 
                                 &dwLengthNeeded))
    {
        fResult = (BOOL)(lstrcmpi(szThreadDesktopName, TEXT("winlogon")) == 0);
        if (fResult)
            DPF(0,"Is winlogon thread");
    }
    return fResult;
}
#endif

BOOL DesktopIsVisible()
{
#ifdef WINNT
    BOOL retval=FALSE;

    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        HRGN hrgn = CreateRectRgn(0, 0, 0, 0);
        if (hrgn)
        {
            if (GetRandomRgn(hdc, hrgn, SYSRGN) == 1)
            {
                RECT rect;
                retval = (BOOL) (GetRgnBox(hrgn, &rect) != NULLREGION);

                if (!retval)
                {
                    if (IsWinlogonThread())
                    {
                        //We must be on winlogon's process... so desktop IS visible...
                        retval = TRUE;
                    }
                }
            }
            DeleteObject(hrgn);
        }
        ReleaseDC(NULL, hdc);
    }
    return retval;
#else
    return TRUE;
#endif
}

HRESULT DDAPI DD_TestCooperativeLevel(LPDIRECTDRAW lpDD)
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    HRESULT                     hr;
    BOOL                        has_excl;
    BOOL                        excl_exists;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_TestCooperativeLevel");


    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        /*
         * If we're in a fullscreen DOS box, we need to let them know that
         * they don't have it and that they can't get it.
         */
        if( *(this->lpwPDeviceFlags) & BUSY )
        {
            if ( this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE )
            {
                hr = DDERR_NOEXCLUSIVEMODE;
            }
            else
            {
                hr = DDERR_EXCLUSIVEMODEALREADYSET;
            }
            LEAVE_DDRAW();
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    CheckExclusiveMode(this_lcl, &excl_exists, &has_excl, FALSE, NULL, FALSE);

    if ( this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE )
    {
        /*
         * Either the app has exclusive mode or it does not
         */
        if ( has_excl && DesktopIsVisible() )
        {
            hr = DD_OK;
        }
        else
        {
            hr = DDERR_NOEXCLUSIVEMODE;
        }
    }
    else
    {
        if ( excl_exists || !DesktopIsVisible() )
        {
            hr = DDERR_EXCLUSIVEMODEALREADYSET;
        }
        else
        {
#ifdef WIN95
            if ( this->dwModeIndex == this_lcl->dwPreferredMode )
#else
            if (EQUAL_DISPLAYMODE(this->dmiCurrent, this_lcl->dmiPreferred))
#endif
            {
                hr = DD_OK;
            }
            else
            {
                hr = DDERR_WRONGMODE;
            }
        }
    }

    LEAVE_DDRAW();
    return hr;

} /* DD_TestCooperativeLevel */


#ifdef DEBUG
    /*
     * These are the DPF structure dumpers.
     * If you want to dump a structure, add a function with the prototype
     *      void DUMP_<structure-name> (DWORD level, DWORD topic, LP<structure-name> lpStruct);
     *
     */

    /*
     * Dump a DDPIXELFORMAT
     */
    void DUMP_DDPIXELFORMAT (DWORD level, DWORD topic, LPDDPIXELFORMAT lpDDPF)
    {
        if (!lpDDPF)
        {
            DPF(level,topic,"   DDPIXELFORMAT NULL");
            return;
        }

        DPF(level,topic,"Flags:");
        if (lpDDPF->dwFlags & DDPF_ALPHAPIXELS )
            DPF(level,topic,"   DDPF_ALPHAPIXELS");
        if (lpDDPF->dwFlags & DDPF_ALPHA   )
            DPF(level,topic,"   DDPF_ALPHA ");
        if (lpDDPF->dwFlags & DDPF_FOURCC   )
            DPF(level,topic,"   DDPF_FOURCC = %08x",lpDDPF->dwFourCC);
        if (lpDDPF->dwFlags & DDPF_PALETTEINDEXED4  )
            DPF(level,topic,"   DDPF_PALETTEINDEXED4  ");
        if (lpDDPF->dwFlags & DDPF_PALETTEINDEXEDTO8)
            DPF(level,topic,"   DDPF_PALETTEINDEXEDTO8");
        if (lpDDPF->dwFlags & DDPF_PALETTEINDEXED8  )
            DPF(level,topic,"   DDPF_PALETTEINDEXED8  ");
        if (lpDDPF->dwFlags & DDPF_RGB        )
            DPF(level,topic,"   DDPF_RGB              ");
        if (lpDDPF->dwFlags & DDPF_COMPRESSED         )
            DPF(level,topic,"   DDPF_COMPRESSED       ");
        if (lpDDPF->dwFlags & DDPF_RGBTOYUV           )
            DPF(level,topic,"   DDPF_RGBTOYUV         ");
        if (lpDDPF->dwFlags & DDPF_YUV        )
            DPF(level,topic,"   DDPF_YUV              ");
        if (lpDDPF->dwFlags & DDPF_ZBUFFER            )
            DPF(level,topic,"   DDPF_ZBUFFER          ");
        if (lpDDPF->dwFlags & DDPF_PALETTEINDEXED1  )
            DPF(level,topic,"   DDPF_PALETTEINDEXED1  ");
        if (lpDDPF->dwFlags & DDPF_PALETTEINDEXED2  )
            DPF(level,topic,"   DDPF_PALETTEINDEXED2  ");
        if (lpDDPF->dwFlags & DDPF_ZPIXELS            )
            DPF(level,topic,"   DDPF_ZPIXELS          ");
        if (lpDDPF->dwFlags & DDPF_STENCILBUFFER        )
            DPF(level,topic,"   DDPF_STENCILBUFFER    ");

        DPF(level,topic,"   BitCount:%d",lpDDPF->dwRGBBitCount);
        DPF(level,topic,"   Bitmasks: R/Y/StencDepth:%08x, G/U/ZMask:%08x, B/V/StencMask:%08x, Alpha/Z:%08x",
            lpDDPF->dwRBitMask,
            lpDDPF->dwGBitMask,
            lpDDPF->dwBBitMask,
            lpDDPF->dwRGBAlphaBitMask);
    }

    /*
     * Dump a ddscaps
     */
    void DUMP_DDSCAPS (DWORD level, DWORD topic, LPDDSCAPS lpDDSC)
    {
        if (!lpDDSC)
        {
            DPF(level,topic,"   DDSCAPS NULL");
            return;
        }

        if (lpDDSC->dwCaps & DDSCAPS_ALPHA)
            DPF(level,topic,"   DDSCAPS_ALPHA");
        if (lpDDSC->dwCaps & DDSCAPS_BACKBUFFER)
            DPF(level,topic,"   DDSCAPS_BACKBUFFER");
        if (lpDDSC->dwCaps & DDSCAPS_COMPLEX)
            DPF(level,topic,"   DDSCAPS_COMPLEX");
        if (lpDDSC->dwCaps & DDSCAPS_FLIP)
            DPF(level,topic,"   DDSCAPS_FLIP");
        if (lpDDSC->dwCaps & DDSCAPS_FRONTBUFFER)
            DPF(level,topic,"   DDSCAPS_FRONTBUFFER");
        if (lpDDSC->dwCaps & DDSCAPS_OFFSCREENPLAIN)
            DPF(level,topic,"   DDSCAPS_OFFSCREENPLAIN");
        if (lpDDSC->dwCaps & DDSCAPS_OVERLAY)
            DPF(level,topic,"   DDSCAPS_OVERLAY");
        if (lpDDSC->dwCaps & DDSCAPS_PALETTE)
            DPF(level,topic,"   DDSCAPS_PALETTE");
        if (lpDDSC->dwCaps & DDSCAPS_PRIMARYSURFACE)
            DPF(level,topic,"   DDSCAPS_PRIMARYSURFACE");
        if (lpDDSC->dwCaps & DDSCAPS_PRIMARYSURFACELEFT)
            DPF(level,topic,"   DDSCAPS_PRIMARYSURFACELEFT");
        if (lpDDSC->dwCaps & DDSCAPS_SYSTEMMEMORY)
            DPF(level,topic,"   DDSCAPS_SYSTEMMEMORY");
        if (lpDDSC->dwCaps & DDSCAPS_TEXTURE)
            DPF(level,topic,"   DDSCAPS_TEXTURE");
        if (lpDDSC->dwCaps & DDSCAPS_3DDEVICE)
            DPF(level,topic,"   DDSCAPS_3DDEVICE");
        if (lpDDSC->dwCaps & DDSCAPS_VIDEOMEMORY)
            DPF(level,topic,"   DDSCAPS_VIDEOMEMORY");
        if (lpDDSC->dwCaps & DDSCAPS_VISIBLE)
            DPF(level,topic,"   DDSCAPS_VISIBLE");
        if (lpDDSC->dwCaps & DDSCAPS_WRITEONLY)
            DPF(level,topic,"   DDSCAPS_WRITEONLY");
        if (lpDDSC->dwCaps & DDSCAPS_ZBUFFER)
            DPF(level,topic,"   DDSCAPS_ZBUFFER");
        if (lpDDSC->dwCaps & DDSCAPS_OWNDC)
            DPF(level,topic,"   DDSCAPS_OWNDC");
        if (lpDDSC->dwCaps & DDSCAPS_LIVEVIDEO)
            DPF(level,topic,"   DDSCAPS_LIVEVIDEO");
        if (lpDDSC->dwCaps & DDSCAPS_HWCODEC)
            DPF(level,topic,"   DDSCAPS_HWCODEC");
        if (lpDDSC->dwCaps & DDSCAPS_MODEX)
            DPF(level,topic,"   DDSCAPS_MODEX");
        if (lpDDSC->dwCaps & DDSCAPS_MIPMAP)
            DPF(level,topic,"   DDSCAPS_MIPMAP");
#ifdef SHAREDZ
        if (lpDDSC->dwCaps & DDSCAPS_SHAREDZBUFFER)
            DPF(level,topic,"   DDSCAPS_SHAREDZBUFFER");
        if (lpDDSC->dwCaps & DDSCAPS_SHAREDBACKBUFFER)
            DPF(level,topic,"   DDSCAPS_SHAREDBACKBUFFER");
#endif
        if (lpDDSC->dwCaps & DDSCAPS_ALLOCONLOAD)
            DPF(level,topic,"   DDSCAPS_ALLOCONLOAD");
        if (lpDDSC->dwCaps & DDSCAPS_VIDEOPORT)
            DPF(level,topic,"   DDSCAPS_VIDEOPORT");
        if (lpDDSC->dwCaps & DDSCAPS_LOCALVIDMEM)
            DPF(level,topic,"   DDSCAPS_LOCALVIDMEM");
        if (lpDDSC->dwCaps & DDSCAPS_NONLOCALVIDMEM)
            DPF(level,topic,"   DDSCAPS_NONLOCALVIDMEM");
        if (lpDDSC->dwCaps & DDSCAPS_STANDARDVGAMODE)
            DPF(level,topic,"   DDSCAPS_STANDARDVGAMODE");
        if (lpDDSC->dwCaps & DDSCAPS_OPTIMIZED)
            DPF(level,topic,"   DDSCAPS_OPTIMIZED");
    }

    /*
     * Dump a DDSCAPS2
     */
    void DUMP_DDSCAPS2 (DWORD level, DWORD topic, LPDDSCAPS2 lpDDSC)
    {
        DUMP_DDSCAPS(level,topic,(LPDDSCAPS)lpDDSC);
        //no more to dump yet
    }

    /*
     * Dump a DDSURFACEDESC
     */
    void DUMP_DDSURFACEDESC (DWORD level, DWORD topic, LPDDSURFACEDESC lpDDSD)
    {
        if (!lpDDSD)
        {
            DPF(level,topic,"   DDSURFACEDESC NULL");
            return;
        }

        if (lpDDSD->dwFlags & DDSD_HEIGHT)
            DPF(level,topic,"   DDSURFACEDESC->dwHeight = %d",lpDDSD->dwHeight);
        if (lpDDSD->dwFlags & DDSD_WIDTH)
            DPF(level,topic,"   DDSURFACEDESC->dwWidth  = %d",lpDDSD->dwWidth);
        if (lpDDSD->dwFlags & DDSD_PITCH)
            DPF(level,topic,"   DDSURFACEDESC->lPitch   = %d",lpDDSD->lPitch);

        if (lpDDSD->dwFlags & DDSD_BACKBUFFERCOUNT)
            DPF(level,topic,"   DDSURFACEDESC->dwBackBufferCount  = %d",lpDDSD->dwBackBufferCount);
        if (lpDDSD->dwFlags & DDSD_ZBUFFERBITDEPTH)
            DPF(level,topic,"   DDSURFACEDESC->dwZBufferBitDepth  = %d",lpDDSD->dwZBufferBitDepth);
        if (lpDDSD->dwFlags & DDSD_MIPMAPCOUNT)
            DPF(level,topic,"   DDSURFACEDESC->dwMipMapCount      = %d",lpDDSD->dwMipMapCount);
        if (lpDDSD->dwFlags & DDSD_REFRESHRATE)
            DPF(level,topic,"   DDSURFACEDESC->dwRefreshRate      = %d",lpDDSD->dwRefreshRate);

        /*if (lpDDSD->dwFlags & DDSD_LPSURFACE)*/
            DPF(level,topic,"   DDSURFACEDESC->lpSurface = %08x",lpDDSD->lpSurface);

        if (lpDDSD->dwFlags & DDSD_PIXELFORMAT)
            DUMP_DDPIXELFORMAT(level,topic, &lpDDSD->ddpfPixelFormat);

        if (lpDDSD->dwFlags & DDSD_CAPS)
            DUMP_DDSCAPS(level,topic, &lpDDSD->ddsCaps);
    }

    /*
     * Dump a DDSURFACEDESC2
     */
    void DUMP_DDSURFACEDESC2 (DWORD level, DWORD topic, LPDDSURFACEDESC2 lpDDSD)
    {
        if (!lpDDSD)
        {
            DPF(level,topic,"   DDSURFACEDESC2 NULL");
            return;
        }

        if (lpDDSD->dwFlags & DDSD_HEIGHT)
            DPF(level,topic,"   DDSURFACEDESC2->dwHeight = %d",lpDDSD->dwHeight);
        if (lpDDSD->dwFlags & DDSD_WIDTH)
            DPF(level,topic,"   DDSURFACEDESC2->dwWidth  = %d",lpDDSD->dwWidth);
        if (lpDDSD->dwFlags & DDSD_PITCH)
            DPF(level,topic,"   DDSURFACEDESC2->lPitch   = %d",lpDDSD->lPitch);

        if (lpDDSD->dwFlags & DDSD_BACKBUFFERCOUNT)
            DPF(level,topic,"   DDSURFACEDESC2->dwBackBufferCount  = %d",lpDDSD->dwBackBufferCount);

        if (lpDDSD->dwFlags & DDSD_MIPMAPCOUNT)
            DPF(level,topic,"   DDSURFACEDESC2->dwMipMapCount      = %d",lpDDSD->dwMipMapCount);
        if (lpDDSD->dwFlags & DDSD_REFRESHRATE)
            DPF(level,topic,"   DDSURFACEDESC2->dwRefreshRate      = %d",lpDDSD->dwRefreshRate);

        /*if (lpDDSD->dwFlags & DDSD_LPSURFACE)*/
            DPF(level,topic,"   DDSURFACEDESC2->lpSurface = %08x",lpDDSD->lpSurface);

        if (lpDDSD->dwFlags & DDSD_PIXELFORMAT)
            DUMP_DDPIXELFORMAT(level,topic, &lpDDSD->ddpfPixelFormat);

        if (lpDDSD->dwFlags & DDSD_CAPS)
            DUMP_DDSCAPS2(level,topic, &lpDDSD->ddsCaps);
    }

    /*
     * Dump a DDOPTSURFACEDESC
     */
    void DUMP_DDOPTSURFACEDESC (DWORD level, DWORD topic, LPDDOPTSURFACEDESC lpDDSD)
    {
        if (!lpDDSD)
        {
            DPF(level,topic,"   DDOPTSURFACEDESC NULL");
            return;
        }

#if 0
        if (lpDDSD->dwFlags & DDOSD_GUID)
            DPF(level,topic,"   DDOPTSURFACEDESC->guid = %08x, %08x, %08x, %08x",lpDDSD->dwHeight);
#endif
        if (lpDDSD->dwFlags & DDOSD_COMPRESSION_RATIO)
            DPF(level,topic,"   DDOPTSURFACEDESC->dwCompressionRatio  = %d",lpDDSD->dwCompressionRatio);
    }
#endif //def DEBUG


/*
 * GetInternalPointer
 * This function can be called with a ULONG_PTR ordinal value, and will return
 * a ULONG_PTR value.
 */

ULONG_PTR __stdcall GetOLEThunkData(ULONG_PTR dwOrdinal)
{
    extern DWORD dwLastFrameRate;
    switch(dwOrdinal)
    {
    case 0x1:
        return dwLastFrameRate;
    case 0x2:
        return (ULONG_PTR) lpDriverObjectList;
    case 0x3:
        return (ULONG_PTR) lpAttachedProcesses;
    case 0x4:
        return 0;
    case 0x5:
        return (ULONG_PTR) CheckExclusiveMode;
    case 6:
        RELEASE_EXCLUSIVEMODE_MUTEX;
        return 0;
    }

    return 0;
}


/*
 * Check if exclusive mode is owned, and if so if it is owned by this ddraw local.
 * This routine only works if the calling thread owns the ddraw critical section (which is assumed
 * to at least own ddraw for all threads in this process.)
 *
 * We are only allowed to test for this ddraw object owning exclusive mode if this process
 * owns the exclusive mode mutex. If it does, then the ddraw csect allows us to know that
 * this thread can check the lpExclusiveOwner in the ddraw gbl thread-safely.
 *
 * The routine can optionally hold the exclusive mode mutex. This is done when the caller wishes to
 * change the state of the ddraw gbl lpExclusiveOwner.
 *
 * Note that this routine will ONLY take the mutex if it's possible that this local can own exclusive mode.
 * This means that callers only need to worry about releasing the mutex if
 */
void CheckExclusiveMode(LPDDRAWI_DIRECTDRAW_LCL this_lcl, LPBOOL pbExclusiveExists, LPBOOL pbThisLclOwnsExclusive, BOOL bKeepMutex, HWND hwnd, BOOL bCanGetIt)
{
    LPDDRAWI_DIRECTDRAW_GBL this_gbl;
    DWORD dwWaitResult;

    this_gbl = this_lcl->lpGbl;

#ifdef WINNT
    WaitForSingleObject( hCheckExclusiveModeMutex, INFINITE );

    dwWaitResult = WaitForSingleObject(hExclusiveModeMutex, 0);

    if (dwWaitResult == WAIT_OBJECT_0)
    {
#endif
        /*
         * OK, so this process owns the exlusive mode object,
         * are we the process (really the ddraw lcl) with exclusive mode?
         */
        if (pbExclusiveExists)
            *pbExclusiveExists = (BOOL)( NULL != this_gbl->lpExclusiveOwner );
        if (pbThisLclOwnsExclusive)
            *pbThisLclOwnsExclusive = (BOOL) ( this_gbl->lpExclusiveOwner == this_lcl );

        /*
         * It is possible that another app has set exclusive mode
         * on another monitor, or that the same app is calling w/o first
         */
        if( pbExclusiveExists )
        {
            if( !( *pbExclusiveExists ) )
            {
                LPDDRAWI_DIRECTDRAW_INT pdrv_int;

                pdrv_int = lpDriverObjectList;
                while (pdrv_int != NULL )
                {
                    if( ( pdrv_int->lpLcl->lpGbl != this_gbl ) &&
                        ( pdrv_int->lpLcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE ) &&
                        ( pdrv_int->lpLcl->lpGbl->lpExclusiveOwner == pdrv_int->lpLcl ) )
                    {
                        if( bCanGetIt )
                        {
                            if( ( pdrv_int->lpLcl->hFocusWnd != PtrToUlong(hwnd) ) &&
                                ( pdrv_int->lpLcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV ) &&
                                ( this_gbl->dwFlags & DDRAWI_DISPLAYDRV ) )
                            {
                                *pbExclusiveExists = TRUE;
                                break;
                            }
                        }
                        else
                        {
                            *pbExclusiveExists = TRUE;
                            break;
                        }
                    }
                    pdrv_int = pdrv_int->lpLink;
                }
            }
        }

#ifdef WINNT
        /*
         * Undo the temporary ref we just took on the mutex to check its state, if we're not actually
         * taking ownership. We are not taking ownership if we already have ownership. This means this routine
         * doesn't allow more than one ref on the exclusive mode mutex.
         */
        if (!bKeepMutex || *pbThisLclOwnsExclusive)
        {
            ReleaseMutex( hExclusiveModeMutex );
        }
    }
    else if (dwWaitResult == WAIT_TIMEOUT)
    {
        /*
         * Some other thread owns the exclusive mode mutex. If that other thread took the mutex
         * on this_lcl as well, then the current thread owns excl. mode.
         *
         * We can still check if the exclusive owner is us, because all we're doing is checking
         * pointers that can only be set by whoever owns the mutex. The owner pointer will be 0
         * until it becomes (until the mutex is released) some pointer. Thus we will never get
         * a false positive when this thread asks if it owns excl. mode here.
         */
        if (this_gbl->lpExclusiveOwner == this_lcl)
        {
            if (pbExclusiveExists)
                *pbExclusiveExists = TRUE;
            if (pbThisLclOwnsExclusive)
                *pbThisLclOwnsExclusive = TRUE;
        }
        else
        {
            if (pbExclusiveExists)
                *pbExclusiveExists = TRUE;
            if (pbThisLclOwnsExclusive)
                *pbThisLclOwnsExclusive = FALSE;
        }
    }
    else if (dwWaitResult == WAIT_ABANDONED)
    {
        /*
         * Some other thread lost exclusive mode. We have now picked it up.
         */
        if (pbExclusiveExists)
            *pbExclusiveExists = FALSE;
        if (pbThisLclOwnsExclusive)
            *pbThisLclOwnsExclusive = FALSE;
        /*
         * Undo the temporary ref we just took on the mutex to check its state, if we're not actually
         * taking ownership.
         */
        if (!bKeepMutex)
        {
            ReleaseMutex( hExclusiveModeMutex );
        }
    }
    else
    {
        DPF(0, "Unexpected return from WaitForSingleObject.");
        DDASSERT(FALSE);
        if (pbExclusiveExists)
            *pbExclusiveExists = TRUE;
        if (pbThisLclOwnsExclusive)
            *pbThisLclOwnsExclusive = FALSE;
    }

    ReleaseMutex( hCheckExclusiveModeMutex );

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddpal.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddpal.c
 *  Content:	DirectDraw palette functions
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27-jan-95	craige	initial implementation
 *   11-mar-95	craige	more HAL fns, filled out CreatePalette
 *   19-mar-95	craige	use HRESULTs, process termination cleanup fixes
 *   26-mar-95	craige	filled out remaining fns
 *   28-mar-95	craige	switched to PALETTEENTRY from RGBQUAD
 *   31-mar-95	craige	use critical sections with palettes
 *   01-apr-95	craige	happy fun joy updated header file
 *   04-apr-95	craige	use driver directly in exclusive mode
 *   07-apr-95	craige	bug 14 - check GUID ptr in QI
 *   10-apr-95	craige	mods to process list stuff
 *   			bug 3,16 - palette issues: use driver in excl. mode
 *   12-apr-95	craige	don't use GETCURRPID all the time; proper csect ordering
 *   06-may-95	craige	use driver-level csects only
 *   12-may-95	craige	check for real guids in QI
 *   02-jun-95	craige	extra parm in AddToActiveProcessList
 *   12-jun-95	craige	new process list stuff
 *   20-jun-95  kylej   moved palette emulation code into ddhel
 *   21-jun-95	craige	couple of internal inteface cleanup issues
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns
 *   02-jul-95	craige	implemented GetCaps; added SEH for parm. validation
 *   04-jul-95	craige	YEEHAW: new driver struct
 *   05-jul-95	craige	added Initialize
 *   08-jul-95	kylej	Surface and DirectDraw Palette calls require 
 *			exclusive mode. Removed ResetSysPalette.  Make a
 *                      SetPalette call to the HAL/HEL to detach a palette.
 *   11-jul-95	craige	fail aggregation calls
 *   13-jul-95	craige	bug 94 - flag validation fixes
 *   20-jul-95	craige	stop palette code from running non-palettized
 *   31-jul-95  toddla  unselect palette in InternalPaletteRelease
 *   31-jul-95	craige	validate flags
 *   21-aug-95	craige	mode X support
 *   27-aug-95	craige	bug 735: added SetPaletteAlways
 *			bug 742: use ALLOW256
 *   14-oct-95  colinmc add support for attaching palettes to offscreen and
 *                      texture map surfaces
 *   07-nov-95  colinmc support for 1, 2 and 4-bit palettes and palette
 *                      sharing added
 *   09-dec-95  colinmc added execute buffer support
 *   02-jan-96	kylej	handle new interface structs
 *   09-feb-96  colinmc surface lost flag moved from global to local object
 *   03-mar-96  colinmc fixed problem with QueryInterface returning local
 *                      object rather than interface.
 *   13-mar-96  colinmc added IID validation to QueryInterface
 *   16-mar-96  colinmc fixed problem with palettes being released too many
 *                      times
 *   19-mar-96  colinmc Bug 12129: Bogus lpColorTable causes CreatePalette
 *                      to bomb
 *   19-apr-96  colinmc Bug 17473: CreatePalette faults on bogus palette
 *                      pointer
 *   02-may-96	kylej	Bug 20066: GetPalette doesn't NULL pointer on failure
 *   23-sep-96  ketand  Added TIMING routines
 *   24-mar-97  jeffno  Optimized Surfaces
 *   26-nov-97  t-craigs Added IDirectDrawPalette2 stuff
 *
 ***************************************************************************/

#include "ddrawpr.h"

#define SIZE_DDPCAPS (DDPCAPS_1BIT | DDPCAPS_2BIT | DDPCAPS_4BIT | DDPCAPS_8BIT)

#define PE_FLAGS (PC_NOCOLLAPSE |PC_RESERVED)

#define BITS_PER_BITFIELD_ENTRY (sizeof(DWORD)*8)

/*
 * Generate a palette handle. We keep a bitfiled in the ddraw local that
 * tells us if we can recycle a handle. Note that handles are 1-based,
 * and these routines deal with that
 */
DWORD GeneratePaletteHandle(LPDDRAWI_DIRECTDRAW_LCL lpDD_lcl)
{
    DWORD                       cbits,*pdw;

    /*
     * Check for an unused entry in the palette-handle-used bitfield. We check
     */
    for (cbits=0; cbits< lpDD_lcl->cbitsPaletteBitfieldBitCount; cbits++ )
    {
        if ( 0 == (lpDD_lcl->pPaletteHandleUsedBitfield[cbits/BITS_PER_BITFIELD_ENTRY] 
                    & (1<<(cbits % BITS_PER_BITFIELD_ENTRY))) )
        {
            /*
             * Found a recycled handle
             */
            lpDD_lcl->pPaletteHandleUsedBitfield[cbits/BITS_PER_BITFIELD_ENTRY] |=
                (1<<(cbits % BITS_PER_BITFIELD_ENTRY));
            return cbits+1; //plus one since 0 is error return
        }
    }

    /* 
     * Didn't find a recycled entry. Get a new handle
     */

    DDASSERT( cbits == lpDD_lcl->cbitsPaletteBitfieldBitCount );

    if ( (cbits% BITS_PER_BITFIELD_ENTRY) == 0)
    {
        /* 
         * Have to grow the table since the current table fits exactly in a number of DWORDs
         */
        pdw = MemAlloc( ((cbits / BITS_PER_BITFIELD_ENTRY) +1)*sizeof(DWORD) );

        if (pdw)
        {
            /*
             * Couldn't convince myself the MemRealloc both worked and would zero remaining space.
             */
            memcpy(pdw, lpDD_lcl->pPaletteHandleUsedBitfield, 
                (cbits / BITS_PER_BITFIELD_ENTRY) * sizeof(DWORD) );
            MemFree(lpDD_lcl->pPaletteHandleUsedBitfield);
            lpDD_lcl->pPaletteHandleUsedBitfield = pdw;
        }
        else
        {
            return 0;
        }
    }

    /*
     * Table is big enough. Grab the entry and mark it.
     */
    cbits = lpDD_lcl->cbitsPaletteBitfieldBitCount++;
    lpDD_lcl->pPaletteHandleUsedBitfield[cbits/BITS_PER_BITFIELD_ENTRY] |=
        (1<<(cbits % BITS_PER_BITFIELD_ENTRY));
    return cbits+1; //+1 since zero is an error return, and it helps out drivers to know 0 is invalid
}

void FreePaletteHandle(LPDDRAWI_DIRECTDRAW_LCL lpDD_lcl, DWORD dwHandle)
{
    DDASSERT( dwHandle <= lpDD_lcl->cbitsPaletteBitfieldBitCount );

    if (dwHandle == 0)
        return;

    dwHandle -=1; //since handles are 1-based

    lpDD_lcl->pPaletteHandleUsedBitfield[dwHandle/BITS_PER_BITFIELD_ENTRY] &=
        ~(1<<(dwHandle % BITS_PER_BITFIELD_ENTRY));

}

/*
 * newPaletteInterface
 *
 * Construct a new palette interface which points to an existing local object.
 */
static LPVOID newPaletteInterface( LPDDRAWI_DDRAWPALETTE_LCL this_lcl, LPVOID lpvtbl )
{
    LPDDRAWI_DDRAWPALETTE_INT	pnew_int;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;

    
    pnew_int = MemAlloc( sizeof( DDRAWI_DDRAWPALETTE_INT ));
    if( NULL == pnew_int )
    {
	return NULL;
    }

    /*
     * set up data
     */
    pnew_int->lpVtbl = lpvtbl;
    pnew_int->lpLcl = this_lcl;
    pnew_int->dwIntRefCnt = 0;

    /*
     * link this into the global list of palettes
     */
    pdrv = this_lcl->lpDD_lcl->lpGbl;
    pnew_int->lpLink = pdrv->palList;
    pdrv->palList = pnew_int;
    return pnew_int;

} /* newPaletteInterface */


#undef DPF_MODNAME
#define DPF_MODNAME "Palette::QueryInterface"

/*
 * DD_Palette_QueryInterface
 */
HRESULT DDAPI DD_Palette_QueryInterface(
		LPDIRECTDRAWPALETTE lpDDPalette,
		REFIID riid,
		LPVOID FAR * ppvObj )
{
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_INT	this_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_QueryInterface");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
        if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
        {
	    DPF_ERR( "Invalid palette pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        if( !VALID_PTR_PTR( ppvObj ) )
        {
	    DPF( 1, "Invalid palette pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
        }
        if( !VALIDEX_IID_PTR( riid ) )
        {
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
        }
        this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return (DWORD) DDERR_INVALIDPARAMS;
    }

    if( IsEqualIID(riid, &IID_IUnknown) ||
    	IsEqualIID(riid, &IID_IDirectDrawPalette) )
    {
	if( this_int->lpVtbl == (LPVOID) &ddPaletteCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) newPaletteInterface( this_lcl, (LPVOID)&ddPaletteCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Palette_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }
#ifdef POSTPONED
    if (IsEqualIID(riid, &IID_IPersist))
    {
	/*
	 * if this is already an IID_IPersist interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddPalettePersistCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) newPaletteInterface( this_lcl, (LPVOID)&ddPalettePersistCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Palette_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }
    if (IsEqualIID(riid, &IID_IPersistStream))
    {
	/*
	 * if this is already an IID_IPersistStream interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddPalettePersistStreamCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) newPaletteInterface( this_lcl, (LPVOID)&ddPalettePersistStreamCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Palette_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }
    if (IsEqualIID(riid, &IID_IDirectDrawPalette2))
    {
	/*
	 * if this is already an IID_IDirectDrawPalette2 interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddPalette2Callbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) newPaletteInterface( this_lcl, (LPVOID)&ddPalette2Callbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Palette_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }
#endif //POSTPONED

    LEAVE_DDRAW();
    return (DWORD) DDERR_GENERIC;

} /* DD_Palette_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "Palette::AddRef"

/*
 * DD_Palette_AddRef
 */
DWORD DDAPI DD_Palette_AddRef( LPDIRECTDRAWPALETTE lpDDPalette )
{
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    DWORD			rcnt;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_AddRef");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
    
	/*
	 * update palette reference count
	 */
	this->dwRefCnt++;
	this_lcl->dwLocalRefCnt++;
	this_int->dwIntRefCnt++;
	rcnt = this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT;
	DPF( 5, "Palette %08lx addrefed, refcnt = %ld,%ld,%ld", 
	    this_lcl, this->dwRefCnt, rcnt, 
	    this_int->dwIntRefCnt );
    
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    LEAVE_DDRAW();
    return this_int->dwIntRefCnt;

} /* DD_Palette_AddRef */

#undef DPF_MODNAME
#define DPF_MODNAME "Palette::Release"

/*
 * InternalPaletteRelease
 *
 * Done with a palette.   if no one else is using it, then we can free it.
 * Also called by ProcessPaletteCleanup
 */
ULONG DDAPI InternalPaletteRelease( LPDDRAWI_DDRAWPALETTE_INT this_int )
{
    DWORD			intrefcnt;
    DWORD			lclrefcnt;
    DWORD			gblrefcnt;
    BOOL			root_object_deleted;
    BOOL			do_free;
    ULONG			rc;
    DDHAL_DESTROYPALETTEDATA	dpd;
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_INT	curr_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_INT	last_int;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    IUnknown *                  pOwner = NULL;

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;
    pdrv_lcl = this->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;

    /*
     * decrement reference count to this palette.  If it hits zero,
     * cleanup
     */
    this->dwRefCnt--;
    this_lcl->dwLocalRefCnt--;
    this_int->dwIntRefCnt--;
    intrefcnt = this_int->dwIntRefCnt;
    lclrefcnt = this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT;
    gblrefcnt = this->dwRefCnt;
    DPF( 5, "Palette %08lx released, refcnt = %ld,%ld,%ld", this_int, gblrefcnt, lclrefcnt, intrefcnt );

    /*
     * local object gone?
     */
    root_object_deleted = FALSE;
    if( lclrefcnt == 0 )
    {
        /*
         * Remove private data
         */
        FreeAllPrivateData( &this_lcl->pPrivateDataHead );

        /*
         * If the ddraw interface which created this palette caused the surface to addref the ddraw
         * object, then we need to release that addref now.
         */
        pOwner = this_lcl->pAddrefedThisOwner;

	/*
	 * see if we are deleting the root object
	 */
	if( this_lcl->dwLocalRefCnt & OBJECT_ISROOT )
	{
	    root_object_deleted = TRUE;
	}
    }

    /*
     * did the object get globally deleted?
     */
    do_free = FALSE;
    if( gblrefcnt == 0 )
    {
	LPDDHALPALCB_DESTROYPALETTE	dphalfn;
	LPDDHALPALCB_DESTROYPALETTE	dpfn;
	BOOL                        	emulation;

        do_free = TRUE;

	/*
         * if this palette is selected into the primary, unselect it!
         */
        if (pdrv_lcl && pdrv_lcl->lpPrimary &&
            pdrv_lcl->lpPrimary->lpLcl->lpDDPalette == this_int)
        {
            SetPaletteAlways(pdrv_lcl->lpPrimary, NULL);
        }

        FreePaletteHandle( pdrv_lcl, this->dwHandle );

	/*
	 * destroy the hardware
	 */
	if( ( pdrv_lcl->lpDDCB->HALDDPalette.DestroyPalette == NULL ) ||
	    ( this->dwFlags & DDRAWIPAL_INHEL ) )
	{
	    // use HEL 
	    dpfn = pdrv_lcl->lpDDCB->HELDDPalette.DestroyPalette;
	    dphalfn = dpfn;
	    emulation = TRUE;
	}
	else
	{
	    // use HAL
            dpfn = pdrv_lcl->lpDDCB->HALDDPalette.DestroyPalette;
	    dphalfn = pdrv_lcl->lpDDCB->cbDDPaletteCallbacks.DestroyPalette;
	    emulation = FALSE;
	}
	
	if( dphalfn != NULL )
	{
	    dpd.DestroyPalette = dphalfn;
	    dpd.lpDD = pdrv_lcl->lpGbl;
	    dpd.lpDDPalette = this;
	    DOHALCALL( DestroyPalette, dpfn, dpd, rc, emulation );
	    if( rc == DDHAL_DRIVER_HANDLED )
	    {
		if( dpd.ddRVal != DD_OK )
		{
		    DPF_ERR( "HAL call failed" );
                    /*
                     * If the palette took a ref count on the ddraw object that created it,
                     * release that ref now as the very last thing
                     * We don't want to do this on ddhelp's thread cuz it really mucks up the
                     * process cleanup stuff. 
                     */
                    if (pOwner && (dwHelperPid != GetCurrentProcessId()) )
                    {
                        pOwner->lpVtbl->Release(pOwner);
                    }

		    /* GEE: What do we do here since we no longer return
		     * error codes from Release.
		     */
		    return (DWORD) dpd.ddRVal;
		}
	    }
            /*
             * Moved here from ddhel.c. Non-display drivers mean that the hel isn't called for palette
             * destroy, so we were leaking palette tables. It's called exactly here to most closely 
             * duplicate the old behaviour, but reduce any risk of drivers using the color table or whatever.
             */
            if (this->lpColorTable)
            {
                MemFree(this->lpColorTable);
                this->lpColorTable = NULL;
            }
        }
	else 
	{
	    /*
	     * We can't do this; we've already committed to releasing at
	     * this point!
	     */
	    // couldn't handle it
	    // return (ULONG)DDERR_UNSUPPORTED;
	}

	/*
	 * if this was the final delete, but this wasn't the root object,
	 * then we need to delete the dangling root object
	 */
	if( !root_object_deleted )
	{
            LPVOID root_lcl;

            root_lcl = (LPVOID) (((LPBYTE) this) - sizeof( DDRAWI_DDRAWPALETTE_LCL ) );
	    MemFree( root_lcl );
	}
    }
    else if( lclrefcnt == 0 )
    {
	/*
	 * only remove the object if it wasn't the root.   if it
	 * was the root, we must leave it dangling until the last
	 * object referencing it goes away.
	 */
	if( !root_object_deleted )
	{
	    do_free = TRUE;
	}
    }

    /*
     * free the object if needed
     */
    if( do_free )
    {
	/*
	 * just in case someone comes back in with this pointer, set
	 * an invalid vtbl & data ptr.
	 */

        this_lcl->lpGbl = NULL;
	MemFree( this_lcl );
    }

    /*
     * need to delete the interface?
     */
    if( intrefcnt == 0 )
    {
	/*
	 * remove palette from list of all palettes
	 */
	curr_int = pdrv->palList;
	last_int = NULL;
	while( curr_int != this_int )
	{
	    last_int = curr_int;
	    curr_int = curr_int->lpLink;
	    if( curr_int == NULL )
	    {
		return 0;
	    }
	}
	if( last_int == NULL )
	{
	    pdrv->palList = pdrv->palList->lpLink;
	}
	else
	{
	    last_int->lpLink = curr_int->lpLink;
	}
	/*
	 * Invalidate the interface
	 */
	this_int->lpVtbl = NULL;
	this_int->lpLcl = NULL;
	MemFree( this_int );
    }

    /*
     * If the palette took a ref count on the ddraw object that created it,
     * release that ref now as the very last thing
     * We don't want to do this on ddhelp's thread cuz it really mucks up the
     * process cleanup stuff. 
     */
    if (pOwner && (dwHelperPid != GetCurrentProcessId()) )
    {
        pOwner->lpVtbl->Release(pOwner);
    }

    return intrefcnt;

} /* InternalPaletteRelease */

/*
 * DD_Palette_Release
 *
 * Done with a palette.   if no one else is using it, then we can free it.
 */
ULONG DDAPI DD_Palette_Release( LPDIRECTDRAWPALETTE lpDDPalette )
{
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    ULONG			rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_Release");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALIDEX_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
    
	rc = InternalPaletteRelease( this_int );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    LEAVE_DDRAW();
    return rc;

} /* DD_Palette_Release */

#undef DPF_MODNAME
#define DPF_MODNAME "GetCaps"

/*
 * DD_Palette_GetCaps
 */
HRESULT DDAPI DD_Palette_GetCaps(
		LPDIRECTDRAWPALETTE lpDDPalette,
		LPDWORD lpdwCaps )
{
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    DWORD			caps;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_GetCaps");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_DWORD_PTR( lpdwCaps ) )
	{
	    DPF_ERR( "invalid caps pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*lpdwCaps = 0;
	this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * basic palette size caps.
     */
    caps = SIZE_FLAGS_TO_PCAPS( this->dwFlags );

    /*
     * is this palette attached to the primary?
     */
    pdrv_lcl = this->lpDD_lcl;
    if (pdrv_lcl && pdrv_lcl->lpPrimary && pdrv_lcl->lpPrimary->lpLcl->lpDDPalette &&
        (pdrv_lcl->lpPrimary->lpLcl->lpDDPalette == this_int))
	caps |= DDPCAPS_PRIMARYSURFACE;

    /*
     * an allow256 palette?
     */
    if( this->dwFlags & DDRAWIPAL_ALLOW256 )
    {
	caps |= DDPCAPS_ALLOW256;
    }

    /*
     * does this palette store indices into an 8-bit destination
     * palette.
     */
    if( this->dwFlags & DDRAWIPAL_STORED_8INDEX )
    {
        caps |= DDPCAPS_8BITENTRIES;
    }

    *lpdwCaps = caps;

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Palette_GetCaps */

#undef DPF_MODNAME
#define DPF_MODNAME "Initialize"

/*
 * DD_Palette_Initialize
 */
HRESULT DDAPI DD_Palette_Initialize(
		LPDIRECTDRAWPALETTE lpDDPalette,
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPPALETTEENTRY lpDDColorTable )
{
    DPF_ERR( "DirectDrawPalette: DD_Palette_Initialize");

    DPF(2,A,"ENTERAPI: ");
    return DDERR_ALREADYINITIALIZED;
} /* DD_Palette_Initialize */

#undef DPF_MODNAME
#define DPF_MODNAME "SetEntries"

/*
 * DD_Palette_SetEntries
 */

HRESULT DDAPI DD_Palette_SetEntries(
		LPDIRECTDRAWPALETTE lpDDPalette,
		DWORD dwFlags,
		DWORD dwBase,
		DWORD dwNumEntries,
		LPPALETTEENTRY lpEntries )
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    DWORD			rc;
    DDHAL_SETENTRIESDATA	sed;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDHALPALCB_SETENTRIES	sehalfn;
    LPDDHALPALCB_SETENTRIES	sefn;
    DWORD			size;
    BOOL                        emulation;
    DWORD                       entry_size;

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Palette_SetEntries");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_BOTH();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;

	/*
	 * check number of entries
	 */
	size = FLAGS_TO_SIZE( this->dwFlags );
	if( dwNumEntries < 1 || dwNumEntries > size )
	{
	    DPF_ERR( "Invalid number of entries" );
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwBase >= size )
	{
	    DPF_ERR( "Invalid base palette index" );
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwNumEntries+dwBase > size )
	{
	    DPF_ERR( "palette indices requested would go past the end of the palette" );
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}

	if( this->dwFlags & DDRAWIPAL_STORED_8INDEX )
	{
	    entry_size = sizeof( BYTE );
	    if( !VALID_BYTE_ARRAY( lpEntries, dwNumEntries ) )
	    {
	        DPF_ERR( "Invalid 8-bit palette index array" );
		LEAVE_BOTH();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    entry_size = sizeof( PALETTEENTRY );
	    if( !VALID_PALETTEENTRY_ARRAY( lpEntries, dwNumEntries ) )
	    {
	        DPF_ERR( "Invalid PALETTEENTRY array" );
		LEAVE_BOTH();
    	        return DDERR_INVALIDPARAMS;
	    }
	}
	pdrv_lcl = this->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

	/*
	 * copy the entries
	 */
	memcpy( ((LPBYTE)this->lpColorTable) + (entry_size * dwBase),
	        lpEntries, dwNumEntries * entry_size );
    
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_BOTH();
	return DDERR_INVALIDPARAMS;
    }

    if( ( pdrv_lcl->lpDDCB->HALDDPalette.SetEntries == NULL ) ||
	( this->dwFlags & DDRAWIPAL_INHEL ) )
    {
	// use HEL
	sefn = pdrv_lcl->lpDDCB->HELDDPalette.SetEntries;
	sehalfn = sefn;
	emulation = TRUE;
    }
    else
    {
	// use HAL
	sefn = pdrv_lcl->lpDDCB->HALDDPalette.SetEntries;
	sehalfn = pdrv_lcl->lpDDCB->cbDDPaletteCallbacks.SetEntries;
	emulation = FALSE;
    }

    if( sehalfn != NULL )
    {
	sed.SetEntries = sehalfn;
	sed.lpDD = pdrv;
	sed.lpDDPalette = this;
	sed.dwBase = dwBase;
	sed.dwNumEntries = dwNumEntries;
	sed.lpEntries = lpEntries;
	DOHALCALL_NOWIN16( SetEntries, sefn, sed, rc, emulation );
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( sed.ddRVal != DD_OK )
	    {
		DPF( 5, "DDHAL_SetEntries: ddrval = %ld", sed.ddRVal );
		LEAVE_BOTH();
		return (DWORD) sed.ddRVal;
	    }

	    // We have now set the palette as we have been asked; so
	    // we may need to update some outstanding DCs. 
	    UpdateDCOnPaletteChanges( this );

	}
    }
    else
    {
	LEAVE_BOTH();
	return DDERR_UNSUPPORTED;
    }

    BUMP_PALETTE_STAMP(this);

    /*
     * If the palette's handle is non-zero, that means the palette has already been exposed to the
     * driver by a palette associate notify call. If the handle is zero, then the driver has never
     * seen the palette before and doesn't care about setentries for it. The driver will get its 
     * first setentries immediately after the setpalette call (See DD_Surface_SetPalette)
     * Mustn't do this on ddhelp's context, since the DLL will be long gone. (Note this should never 
     * happen anyway).
     */
    if( dwHelperPid != GetCurrentProcessId() )
    {
        if (this->dwHandle)
        {
            if ( pdrv_lcl->pPaletteUpdateNotify && pdrv_lcl->pD3DIUnknown)
            {
                pdrv_lcl->pPaletteUpdateNotify( pdrv_lcl->pD3DIUnknown, this->dwHandle , dwBase, dwNumEntries, lpEntries );
            }
        }
    }

    LEAVE_BOTH();

    return DD_OK;

} /* DD_Palette_SetEntries */

#undef DPF_MODNAME
#define DPF_MODNAME "GetEntries"

/*
 * DD_Palette_GetEntries
 */
HRESULT DDAPI DD_Palette_GetEntries(
		LPDIRECTDRAWPALETTE lpDDPalette,
		DWORD dwFlags,
		DWORD dwBase,
		DWORD dwNumEntries,
		LPPALETTEENTRY lpEntries )
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    DWORD			size;
    DWORD                       entry_size;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_GetEntries");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	/*
	 * check number of entries
	 */
	size = FLAGS_TO_SIZE( this->dwFlags );
	if( dwNumEntries < 1 || dwNumEntries > size )
	{
	    DPF_ERR( "Invalid number of entries" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwBase >= size )
	{
	    DPF_ERR( "Invalid base palette index" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwNumEntries+dwBase > size )
	{
	    DPF_ERR( "palette indices requested would go past the end of the palette" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( this->dwFlags & DDRAWIPAL_STORED_8INDEX )
	{
	    entry_size = sizeof( BYTE );
	    if( !VALID_BYTE_ARRAY( lpEntries, dwNumEntries ) )
	    {
	        DPF_ERR( "Invalid 8-bit palette index array" );
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    entry_size = sizeof( PALETTEENTRY );
	    if( !VALID_PALETTEENTRY_ARRAY( lpEntries, dwNumEntries ) )
	    {
	        DPF_ERR( "Invalid PALETTEENTRY array" );
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
	    }
	}

	/* GetEntries function body */
	memcpy( lpEntries, ((LPBYTE)this->lpColorTable) + (dwBase * entry_size),
		dwNumEntries * entry_size );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Palette_GetEntries */

#undef DPF_MODNAME
#define DPF_MODNAME "GetPalette"

/*
 * DD_Surface_GetPalette
 *
 * Surface function: get the palette associated with surface
 */
HRESULT DDAPI DD_Surface_GetPalette(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDIRECTDRAWPALETTE FAR * lplpDDPalette)
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    HRESULT                     hr;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetPalette");

    TRY
    {
	if( !VALID_PTR_PTR( lplpDDPalette ) )
	{
	    DPF_ERR( "Invalid palette pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        *lplpDDPalette = NULL;	// in case we fail

	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
    
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
    
        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( this_lcl->lpDDPalette == NULL )
	{
	    DPF( 1, "No palette associated with surface" );
	    LEAVE_DDRAW();
	    return DDERR_NOPALETTEATTACHED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

#ifdef POSTPONED
    if (LOWERTHANSURFACE4(this_int))
    {
        hr = DD_Palette_QueryInterface(
            (LPDIRECTDRAWPALETTE) this_lcl->lpDDPalette,
            &IID_IDirectDrawPalette,
            (void**)lplpDDPalette );
    }
    else
    {
        hr = DD_Palette_QueryInterface( 
            (LPDIRECTDRAWPALETTE) this_lcl->lpDDPalette,
            &IID_IDirectDrawPalette2,
            (void**)lplpDDPalette );
    }
#else
    hr = DD_Palette_QueryInterface(
            (LPDIRECTDRAWPALETTE) this_lcl->lpDDPalette,
            &IID_IDirectDrawPalette,
            (void**)lplpDDPalette );
#endif
    LEAVE_DDRAW();
    return hr;

} /* DD_Surface_GetPalette */

#undef DPF_MODNAME
#define DPF_MODNAME	"SetPalette"

/*
 * DD_Surface_SetPalette
 *
 * Surface function: set the palette associated with surface
 *
 * NOTE: Currently the only way a windowed app. has of
 * realizing its palette on the primary is to call SetPalette
 * (full screen app. palette's are realized for them by the
 * WM_ACTIVATEAPP hook). Hence, the logic is to AddRef the
 * palette only if it is not already set as the surface's
 * palette).
 * Perhaps we need a RealizePalette() call?
 */
HRESULT DDAPI DD_Surface_SetPalette(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDIRECTDRAWPALETTE lpDDPalette )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_INT	this_pal_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_pal_lcl;
    LPDDRAWI_DDRAWPALETTE_GBL	this_pal;
    LPDDRAWI_DDRAWPALETTE_INT   prev_pal_int;
    LPDDPIXELFORMAT		pddpf;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    BOOL			attach;
    DWORD			rc;
    DDHAL_SETPALETTEDATA	spd;
    LPDDHALSURFCB_SETPALETTE	sphalfn;
    LPDDHALSURFCB_SETPALETTE	spfn;
    BOOL			emulation;
    BOOL                        isprimary;
    BOOL                        excl_exists;
    BOOL                        has_excl;

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_SetPalette");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_BOTH();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

        /*
         * Palettes don't make any sense on z-buffers or execute
         * buffers.
         */
        if( this_lcl->ddsCaps.dwCaps & ( DDSCAPS_ZBUFFER | DDSCAPS_EXECUTEBUFFER ) )
        {
            DPF_ERR( "Invalid surface type: cannot attach palette" );
	    LEAVE_BOTH();
            return DDERR_INVALIDSURFACETYPE;
        }

        // 
        // New interfaces don't let mipmap sublevels have palettes
        //
        if ((!LOWERTHANSURFACE7(this_int)) && 
            (this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL))
        {
            DPF_ERR( "Cannot attach palette to mipmap sublevels" );
            LEAVE_BOTH();
            return DDERR_NOTONMIPMAPSUBLEVEL;
        }

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_BOTH();
	    return DDERR_SURFACELOST;
	}
    
	this_pal_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( this_pal_int != NULL )
	{
	    if( !VALID_DIRECTDRAWPALETTE_PTR( this_pal_int ) )
	    {
		LEAVE_BOTH();
		return DDERR_INVALIDOBJECT;
	    }
	    this_pal_lcl = this_pal_int->lpLcl;
	    this_pal = this_pal_lcl->lpGbl;
	}
	else
	{
	    this_pal_lcl = NULL;
	    this_pal = NULL;
	}
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

        if ( this_pal_int && 
             (this_pal->dwFlags & DDRAWIPAL_ALPHA) &&
             (! (this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)) )
        {
            DPF_ERR( "Attaching palette w/alpha to non-texture surface" );
            LEAVE_BOTH();
            return DDERR_INVALIDSURFACETYPE;
        }

	/* 
	 * don't allow a palette from one global to be
	 * used with a different one (because it doesn't work)
	 */
	if( this_pal_int && pdrv != this_pal_lcl->lpDD_lcl->lpGbl )
	{
            /*
             * Don't check if either device isn't a display driver (i.e. 3dfx)
             * since that's a back-compat hole.
             */
            if ( (this->lpDD->dwFlags & DDRAWI_DISPLAYDRV) &&
                 (this_pal_lcl->lpDD_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV) )
            {
	        DPF_ERR( "Can't set a palette created from one DDraw onto a surface created by another DDraw" );
	        LEAVE_BOTH();
	        return DDERR_INVALIDPARAMS;
            }
	}
    
        CheckExclusiveMode(pdrv_lcl, &excl_exists, &has_excl, FALSE, NULL, FALSE);

	/*
	 * don't allow primary palette set if not exclusive mode owner
	 */
	isprimary = FALSE;
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
	{
	    isprimary = TRUE;
	    if( excl_exists )
	    {
		if( !has_excl )
		{
		    DPF_ERR( "Cannot set palette on primary when other process owns exclusive mode" );
		    LEAVE_BOTH();
		    return DDERR_NOEXCLUSIVEMODE;
		}
	    }
	}

	/*
	 * Was a palette previously attached to this surface?
	 * If so, we will need to release if all goes well so
	 * remember it.
	 */
	prev_pal_int = this_lcl->lpDDPalette;
    
	/*
	 * NULL palette, remove palette from this surface
	 */
	attach = TRUE;
	if( this_pal == NULL )
	{
	    attach = FALSE;
	    this_pal_int = prev_pal_int;
	    if( this_pal_int == NULL )
	    {
		DPF_ERR( "No attached palette" );
		LEAVE_BOTH();
		return DDERR_NOPALETTEATTACHED;
	    }
	    this_pal_lcl = this_pal_int->lpLcl;
	    this_pal = this_pal_lcl->lpGbl;
	}
    
        if( attach )
	{
	    /*
	     * NOTE: We used to do a lot of HEL specific checking. With the
	     * addition of support for palettes on non-primary surfaces and
	     * non-256 entry palettes this became redundant. We also used
	     * to explicitly check that, if attaching to the primary, the
	     * current mode was palettized and 8-bit. Doesn't look to me like
	     * any of that was necessary as DDPF_PALETTEINDEXED8 should be
	     * set if the primary is 8-bit palettized.
	     */
	    GET_PIXEL_FORMAT( this_lcl, this, pddpf );
	    if( ( ( this_pal->dwFlags & DDRAWIPAL_2   ) && !( pddpf->dwFlags & DDPF_PALETTEINDEXED1 ) ) ||
	        ( ( this_pal->dwFlags & DDRAWIPAL_4   ) && !( pddpf->dwFlags & DDPF_PALETTEINDEXED2 ) ) ||
	        ( ( this_pal->dwFlags & DDRAWIPAL_16  ) && !( pddpf->dwFlags & DDPF_PALETTEINDEXED4 ) ) ||
	        ( ( this_pal->dwFlags & DDRAWIPAL_256 ) && !( pddpf->dwFlags & DDPF_PALETTEINDEXED8 ) ) )
	    {
	        DPF_ERR( "Palette size does not match surface format - cannot set palette" );
		LEAVE_BOTH();
	        return DDERR_INVALIDPIXELFORMAT; 
	    }

            /*
	     * Ensure that both the palette and surface agree on whether they are using
	     * indices into the destination surface's palette.
	     */
	    if( this_pal->dwFlags & DDRAWIPAL_STORED_8INDEX )
	    {
	        if( !(pddpf->dwFlags & DDPF_PALETTEINDEXEDTO8) )
                {
	            DPF_ERR( "Surface is not PALETTEINDEXEDTO8 - cannot set palette" );
		    LEAVE_BOTH();
		    return DDERR_INVALIDPIXELFORMAT;
	        }
	    }
	    else
	    {
	        if( pddpf->dwFlags & DDPF_PALETTEINDEXEDTO8 )
                {
	            DPF_ERR( "Surface is PALETTEINDEXEDTO8 - cannot set palette" );
		    LEAVE_BOTH();
		    return DDERR_INVALIDPIXELFORMAT;
	        }
	    }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_BOTH();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * ATTENTION!!!
     * We shouldn't pass optimized surfaces to an unsuspecting HAL, but if we don't then we could
     * break drivers that hook SetPalette... Since the HAL is probably only going to be watching
     * for a primary, and also is unlikely to go looking at the surface's contents,
     * I'm going to let this one slide.
     */
    if( ( this_pal->dwFlags & DDRAWIPAL_INHEL) ||
	( pdrv_lcl->lpDDCB->HALDDSurface.SetPalette == NULL ) )
    {
	// use HEL
	spfn = pdrv_lcl->lpDDCB->HELDDSurface.SetPalette;
	sphalfn = spfn;
	emulation = TRUE;
    }
    else
    {
	// use HAL
	spfn = pdrv_lcl->lpDDCB->HALDDSurface.SetPalette;
	sphalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.SetPalette;
	emulation = FALSE;
    }
    
    if( sphalfn != NULL )
    {
	spd.SetPalette = sphalfn;
	spd.lpDD = pdrv;
	spd.lpDDPalette = this_pal;
	spd.lpDDSurface = this_lcl;
	spd.Attach = attach;
	DOHALCALL_NOWIN16( SetPalette, spfn, spd, rc, emulation );
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( spd.ddRVal == DD_OK )
	    {
		if( attach )
		{
		    /*
		     * Only AddRef the palette if its being attached to
		     * a new surface.
		     */
		    if( this_lcl->lpDDPalette != this_pal_int )
		    {
		        this_lcl->lpDDPalette = this_pal_int;
		        DD_Palette_AddRef( lpDDPalette );
		    }
		}
		else
		{
		    this_lcl->lpDDPalette = NULL;
		}

		/*
		 * If we had a previous palette and it was different
		 * from the new palette then we must release it.
		 * NOTE: We compare against the incoming parameter
		 * rather than this_pal_lcl as this_pal_lcl is set to the
		 * previous palette if we are removing a palette.
		 * NOTE: It is important that we update the surface's
		 * palette pointer before calling Release() as, otherwise,
		 * release can end up calling SetPalette() and so on.
		 */
		if( ( prev_pal_int != NULL ) &&
		    ( prev_pal_int != (LPDDRAWI_DDRAWPALETTE_INT )lpDDPalette ) )
		{
		    // This palette may no longer the exclusive one
		    if( isprimary )
		    {
			if( has_excl )
			{
			    prev_pal_int->lpLcl->lpGbl->dwFlags &= ~DDRAWIPAL_EXCLUSIVE;
			}
		    }
		    // Release it
		    DD_Palette_Release( (LPDIRECTDRAWPALETTE)prev_pal_int );
		}

		if( attach )
		{
		    // Ok, we have set the palette onto the surface
		    // Check if there are any outstanding DCs that need updating
		    UpdateOutstandingDC( this_lcl, this_pal );
		}
		else
		{
		    // Ok, we have removed a palette onto the surface
		    // Check if there are any outstanding DCs that need updating
		    UpdateOutstandingDC( this_lcl, NULL );
		}

                BUMP_SURFACE_STAMP(this);

                /*
                 * Update the driver's associations and palette entries
                 */
                if( dwHelperPid != GetCurrentProcessId() )
                {
                    BOOL bUpdateEntries = FALSE;

                    if (attach)
                    {
                        if (this_pal->dwHandle == 0)
                        {
                            /*
                             *  The driver has never seen this palette before. We must send an associate notify first, and
                             * then an update entries
                             */
                            bUpdateEntries = TRUE;
                            this_pal->dwHandle = GeneratePaletteHandle(pdrv_lcl);
                        }
                        if (this_pal->dwHandle && pdrv_lcl->pD3DIUnknown ) 
                            //could be zero in low memory conditions
                        {
                            if ( pdrv_lcl->pPaletteAssociateNotify )
                            {
                                // NOTE: we send the handle for DX6 and down
                                // for DX7 we pass the the local itself.
                                // DX7 needs the whole local to get the
                                // batching correct; MB41840

                                if( DDRAWILCL_DIRECTDRAW7 & pdrv_lcl->dwLocalFlags )
                                {
                                    LPPALETTEASSOCIATENOTIFY7 pPaletteAssociateNotify = 
                                        (LPPALETTEASSOCIATENOTIFY7)pdrv_lcl->pPaletteAssociateNotify;

                                    pPaletteAssociateNotify( 
                                        pdrv_lcl->pD3DIUnknown, 
                                        this_pal->dwHandle,
                                        this_pal->dwFlags,
                                        this_lcl );
                                }
                                else
                                {
                                    // When a DX6 app is talking to a DX7 driver,
                                    // we need to force a flush of the token
                                    // stream as part of this SetPalette.
                                    //
                                    // This automatically happens if the number
                                    // of devices is > 1. So if necessary
                                    // we temporarily increment the device
                                    // count. We don't do this for IA64.
                                    // MB41840 for more details.
                                    
                                    #ifndef _WIN64
                                        DWORD *pIUnknown = (DWORD *)(pdrv_lcl->pD3DIUnknown);
                                        DWORD *pD3D      = (DWORD *)(*(pIUnknown + 2));
                                        DWORD *pnumDevs  = (DWORD *)(pD3D + 3);
                                        BOOL  bFixDeviceCount = FALSE;

                                        DDASSERT(pD3D != NULL);

                                        if (*pnumDevs == 1)
                                        {
                                            *pnumDevs = 2;
                                            bFixDeviceCount = TRUE;
                                        }
                                    #endif // _WIN64

                                    pdrv_lcl->pPaletteAssociateNotify( 
                                        pdrv_lcl->pD3DIUnknown, 
                                        this_pal->dwHandle,
                                        this_pal->dwFlags,
                                        this_lcl->lpSurfMore->dwSurfaceHandle );

                                    #ifndef _WIN64
                                        // Restore the device count
                                        if (bFixDeviceCount)
                                        {
                                            DDASSERT(*pnumDevs == 2);
                                            *pnumDevs = 1;
                                        }
                                    #endif // _WIN64
                                }
                            }
                            if ( pdrv_lcl->pPaletteUpdateNotify )
                            {
                                pdrv_lcl->pPaletteUpdateNotify( 
                                    pdrv_lcl->pD3DIUnknown, 
                                    this_pal->dwHandle , 
                                    0, 
                                    FLAGS_TO_SIZE(this_pal->dwFlags), 
                                    this_pal->lpColorTable );
                            }
                        }
                    }
                }
	    }

	    LEAVE_BOTH();
	    return spd.ddRVal;
	}
	LEAVE_BOTH();
	return DDERR_UNSUPPORTED;
    }

    /*
     * !!! NOTE: Currently if the driver does not care about
     * SetPalette we do nothing but return OK. Should we
     * not, however, still point the surface at the palette
     * and point the palette at the surface at the very
     * least?
     */

    LEAVE_BOTH();
    return DD_OK;

} /* DD_Surface_SetPalette */

/*
 * SetPaletteAlways
 */
HRESULT SetPaletteAlways( 
		LPDDRAWI_DDRAWSURFACE_INT psurf_int,
		LPDIRECTDRAWPALETTE lpDDPalette )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD	oldflag;
    HRESULT	ddrval;

    psurf_lcl = psurf_int->lpLcl;
    oldflag = psurf_lcl->dwFlags & DDRAWISURF_INVALID;
    psurf_lcl->dwFlags &= ~DDRAWISURF_INVALID;
    ddrval = DD_Surface_SetPalette( (LPDIRECTDRAWSURFACE) psurf_int, lpDDPalette );
    psurf_lcl->dwFlags |= oldflag;
    return ddrval;

} /* SetPaletteAlways */

#undef DPF_MODNAME
#define DPF_MODNAME	"CreatePalette"

/*
 * DD_CreatePalette
 *
 * Driver function: create a palette
 */
HRESULT DDAPI DD_CreatePalette(
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPPALETTEENTRY lpColorTable,
		LPDIRECTDRAWPALETTE FAR *lplpDDPalette,
		IUnknown FAR *pUnkOuter )
{
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	this;
    LPDDRAWI_DDRAWPALETTE_INT	ppal_int;
    LPDDRAWI_DDRAWPALETTE_LCL	ppal_lcl;
    LPDDRAWI_DDRAWPALETTE_GBL	ppal;
    DWORD			pal_size;
    DDHAL_CREATEPALETTEDATA	cpd;
    DWORD			rc;
    DWORD			pflags;
    BOOL			is_excl;
    LPDDHAL_CREATEPALETTE	cpfn;
    LPDDHAL_CREATEPALETTE	cphalfn;
    BOOL                        emulation;
    BYTE                        indexedpe;
    BYTE                        hackindexedpe;
    PALETTEENTRY		pe;
    PALETTEENTRY                hackpe;
    DWORD			num_entries;
    DWORD                       entry_size;
    int                         num_size_flags;

    if( pUnkOuter != NULL )
    {
	return CLASS_E_NOAGGREGATION;
    }

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_CreatePalette");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( !VALID_PTR_PTR( lplpDDPalette ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*lplpDDPalette = NULL;

	if( dwFlags & ~DDPCAPS_VALID )
	{
	    DPF_ERR( "Invalid caps" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	/*
	 * verify that cooperative level is set
	 */
	if( !(this_lcl->dwLocalFlags & DDRAWILCL_SETCOOPCALLED) )
	{
	    DPF_ERR( "Must call SetCooperativeLevel before calling Create functions" );
	    LEAVE_DDRAW();
	    return DDERR_NOCOOPERATIVELEVELSET;
	}
    
	/*
	 * verify flags
	 */
	if( dwFlags & (DDPCAPS_VSYNC|
		       DDPCAPS_PRIMARYSURFACE|
		       DDPCAPS_PRIMARYSURFACELEFT) )
	{
	    DPF_ERR( "Read only flags specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	num_size_flags = 0;
	if( dwFlags & DDPCAPS_1BIT )
	    num_size_flags++;
	if( dwFlags & DDPCAPS_2BIT )
	    num_size_flags++;
	if( dwFlags & DDPCAPS_4BIT )
	    num_size_flags++;
	if( dwFlags & DDPCAPS_8BIT )
	    num_size_flags++;
	if( num_size_flags != 1 )
	{
	    DPF_ERR( "Must specify one and one only of 2, 4, 16 or 256 color palette" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        if( dwFlags & DDPCAPS_ALPHA )
        {
            if( dwFlags & DDPCAPS_8BITENTRIES )
            {
                DPF_ERR( "8BITENTRIES not valid with ALPHA" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
        }
	if( dwFlags & DDPCAPS_8BIT )
	{
	    if( dwFlags & DDPCAPS_8BITENTRIES )
	    {
		DPF_ERR( "8BITENTRIES only valid with 1BIT, 2BIT or 4BIT palette" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    if( dwFlags & DDPCAPS_ALLOW256 )
	    {
		DPF_ERR( "ALLOW256 only valid with 8BIT palette" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}

        pflags = SIZE_PCAPS_TO_FLAGS( dwFlags );
        num_entries = FLAGS_TO_SIZE( pflags );

        /*
	 * Can't just assume the lpColorTable is an array of PALETTENTRYs.
	 * If DDPCAPS_8BITENTRIES is set then this is in fact an array of
	 * bytes in disguise. Validate appropriately.
	 */
	if( dwFlags & DDPCAPS_8BITENTRIES )
	{
	    entry_size = sizeof(BYTE);
	    indexedpe = ((LPBYTE)lpColorTable)[num_entries-1];   // validate
	    if( !VALID_BYTE_ARRAY( lpColorTable, num_entries ) )
	    {
	        DPF_ERR( "Invalid lpColorTable array" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    /*
	     * NOTE: You may well be wondering what this "hackindexedpe" bit is all about.
	     * Well - indexedpe is not actually used for anything. It's only a probe to
	     * test to see if the color table array is valid. We do this all over the place
	     * but unfortunately we don't actually need the result here so our friend
	     * Mr. Optimizing Compiler decides to discard the assignment and so nullify
	     * the test. In order to ensure the array access stays in we declare dummy
	     * variable and assign to them. This is enough to keep the code in (the
	     * compiler is not smart enough to see that the variable assigned to is
	     * not used). Same goes for hackpe below.
	     */
	    hackindexedpe = indexedpe;
	}
	else
	{
	    entry_size = sizeof(PALETTEENTRY);
	    pe = lpColorTable[num_entries-1];	// validate
	    if( !VALID_PALETTEENTRY_ARRAY( lpColorTable, num_entries ) )
	    {
	        DPF_ERR( "Invalid lpColorTable array" );
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
	    }
	    hackpe = pe;
	}
        CheckExclusiveMode(this_lcl, NULL, &is_excl, FALSE, NULL, FALSE);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * allocate the palette object
     */
    pal_size = sizeof( DDRAWI_DDRAWPALETTE_GBL ) +
	       sizeof( DDRAWI_DDRAWPALETTE_LCL );
    ppal_lcl = (LPDDRAWI_DDRAWPALETTE_LCL) MemAlloc( pal_size );
    if( ppal_lcl == NULL )
    {
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }

    ppal_lcl->lpGbl = (LPDDRAWI_DDRAWPALETTE_GBL) (((LPBYTE)ppal_lcl) +
    			sizeof( DDRAWI_DDRAWPALETTE_LCL ) );
    ppal = ppal_lcl->lpGbl;
    ppal_lcl->lpDD_lcl = this_lcl;
    ppal_lcl->lpDD_Int = this_int;

    /*
     * Initialize some palette global state
     */
    ppal->dwContentsStamp = 1;

    if( dwFlags & DDPCAPS_ALLOW256 )
    {
	pflags |= DDRAWIPAL_ALLOW256;
    }

    if( dwFlags & DDPCAPS_8BITENTRIES )
    {
        pflags |= DDRAWIPAL_STORED_8INDEX;
    }

    if (dwFlags & DDPCAPS_ALPHA )
    {
        pflags |= DDRAWIPAL_ALPHA;
    }

    ppal_lcl->pPrivateDataHead = NULL;

    /*
     * allocate palette
     */
    ppal->lpColorTable = MemAlloc( entry_size * num_entries );
    if( ppal->lpColorTable == NULL )
    {
	MemFree( ppal_lcl );
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }

    /*
     * Create an interface for this palette
     */
#ifdef POSTPONED
    if (LOWERTHANDDRAW4(this_int))
    {
#endif
        ppal_int = newPaletteInterface( ppal_lcl, (LPVOID)&ddPaletteCallbacks );
#ifdef POSTPONED
    }
    else
    {
	ppal_int = newPaletteInterface( ppal_lcl, (LPVOID)&ddPalette2Callbacks );
    }
#endif
    
    if( NULL == ppal_int )
    {
	MemFree( ppal->lpColorTable );
	MemFree( ppal_lcl );
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }

    /*
     * copy the color table
     * we now copy the color table BEFORE we call the device's CreatePalette()
     * this is done as the device may want to overwrite certain of the palette
     * entries (e.g. if you don't specify DDPCAPS_ALLOW256 then the driver may
     * well choose to overwrite the 0 and 255 with black and white).
     */
    memcpy( ppal->lpColorTable, lpColorTable, entry_size * num_entries );

    /*
     * fill in misc stuff
     */
    ppal->lpDD_lcl = this_lcl;
    ppal->dwFlags = pflags;

    /*
     * are palettes even supported by the driver?
     */
    if( ( this->ddCaps.ddsCaps.dwCaps & DDSCAPS_PALETTE ) ||
        ( this->ddHELCaps.ddsCaps.dwCaps & DDSCAPS_PALETTE ) )
    {
	/* GEE: where do we allow the caller to require the palette
	 * be provided in hardware?
	 */
    
        if( (this->dwFlags & DDRAWI_DISPLAYDRV) ||
             this_lcl->lpDDCB->cbDDCallbacks.CreatePalette == NULL )
	{
	    // use HEL
	    cpfn = this_lcl->lpDDCB->HELDD.CreatePalette;
	    cphalfn = cpfn;
	    emulation = TRUE;
	}
	else
	{
	    // use HAL
	    cpfn = this_lcl->lpDDCB->HALDD.CreatePalette;
	    cphalfn = this_lcl->lpDDCB->cbDDCallbacks.CreatePalette;
	    emulation = FALSE;
	}
	cpd.CreatePalette = this_lcl->lpDDCB->cbDDCallbacks.CreatePalette;
	cpd.lpDD = this;
	cpd.lpDDPalette=ppal;
	cpd.lpColorTable=lpColorTable;
	cpd.is_excl = is_excl;
	DOHALCALL( CreatePalette, cpfn, cpd, rc, emulation );
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( cpd.ddRVal != DD_OK )
	    {
	        DPF( 5, "DDHAL_CreatePalette: ddrval = %ld", cpd.ddRVal );
	        LEAVE_DDRAW();
	        return cpd.ddRVal;
	    }
	}
	else
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    else
    {
	LEAVE_DDRAW();
	return DDERR_UNSUPPORTED;
    }

    /*
     * bump reference count, return object
     */
    ppal->dwProcessId = GetCurrentProcessId();
    ppal_lcl->dwLocalRefCnt = OBJECT_ISROOT;
    ppal_int->dwIntRefCnt++;
    ppal_lcl->dwLocalRefCnt++;
    ppal->dwRefCnt++;

    *lplpDDPalette = (LPDIRECTDRAWPALETTE) ppal_int;

    /*
     * If this ddraw object generates independent child objects, then this palette takes
     * a ref count on that ddraw object.
     */
    if (CHILD_SHOULD_TAKE_REFCNT(this_int))
    {
        /*
         * We need to remember which interface created this palette, in case we need to take a ref count
         * and then release it when the palette dies
         */
        lpDD->lpVtbl->AddRef(lpDD);
        ppal_lcl->pAddrefedThisOwner = (IUnknown *) lpDD;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_CreatePalette */

/*
 * ProcessPaletteCleanup
 *
 * A process is done, clean up any surfaces that it may have locked.
 *
 * NOTE: we enter with a lock taken on the DIRECTDRAW object.
 */
void ProcessPaletteCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDRAWPALETTE_INT	ppal_int;
    LPDDRAWI_DDRAWPALETTE_INT	ppnext_int;
    LPDDRAWI_DDRAWPALETTE_GBL	ppal;
    DWORD			rcnt;

    /*
     * run through all palettes owned by the driver object, and find ones
     * that have been accessed by this process
     */
    ppal_int = pdrv->palList;
    DPF( 4, "ProcessPaletteCleanup, ppal=%08lx", ppal_int );
    while( ppal_int != NULL )
    {
	ULONG	rc;
	ppal = ppal_int->lpLcl->lpGbl;
	ppnext_int = ppal_int->lpLink;

	rc = 1;
	if( ( ppal->dwProcessId == pid ) &&
	    ( ( NULL == pdrv_lcl ) || ( pdrv_lcl == ppal_int->lpLcl->lpDD_lcl ) ) )
	{
	    /*
	     * release the references by this process
	     */
	    rcnt = ppal_int->dwIntRefCnt;
	    DPF( 5, "Process %08lx had %ld accesses to palette %08lx", pid, rcnt, ppal_int );
	    while( rcnt >  0 )
	    {
		rc = InternalPaletteRelease( ppal_int );
		if( rc == 0 )
		{
		    break;
		}
		rcnt--;
	    }
	}
	else
	{
	    DPF( 5, "Process %08lx does not have access to palette" );
	}
	ppal_int = ppnext_int;
    }

} /* ProcessPaletteCleanup */


/*
 * DD_Palette_IsEqual
 */

HRESULT EXTERN_DDAPI DD_Palette_IsEqual(
                LPDIRECTDRAWPALETTE lpDDPThis,
                LPDIRECTDRAWPALETTE lpDDPalette )
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_INT	pal_int;
    LPDDRAWI_DDRAWPALETTE_LCL	pal_lcl;
    LPDDRAWI_DDRAWPALETTE_GBL	pal;
    DWORD			size;
    DWORD                       entry_size;
    UINT                        i,j;
    DWORD                       entry;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_IsEqual");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPThis;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

        pal_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( pal_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	pal_lcl = pal_int->lpLcl;
	pal = pal_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * First check the flags
     */
    if (this->dwFlags != pal->dwFlags)
    {
        DPF(2,"Different palette structures");
        LEAVE_DDRAW();
        return DD_FALSE;
    }

    size = FLAGS_TO_SIZE(this->dwFlags);

    if( this->dwFlags & DDRAWIPAL_STORED_8INDEX )
    {
	entry_size = sizeof( BYTE );
    }
    else
    {
	entry_size = sizeof( PALETTEENTRY );
    }
    
    switch (size)
    {
    case 2: // fall-thru
    case 4: // fall-thru
    case 16:
        if (memcmp(this->lpColorTable, pal->lpColorTable, size*entry_size) != 0)
        {
	    DPF(2, "Color tables are not the same" );
	    LEAVE_DDRAW();
    	    return DD_FALSE;
	}
        break;

    case 256:
        for (i = 0; i < 16; ++i)
        {
            entry = i;
            for (j = 0; j < 16; j++)
            {
                if ((*(LPDWORD)&(this->lpColorTable[entry]) != (*(LPDWORD)&pal->lpColorTable[entry])))
                {
                    DPF(5,"Color table entry mismatch: 0x%08x, 0x%08x",
                        *(LPDWORD)&this->lpColorTable[entry],
                        *(LPDWORD)&pal->lpColorTable[entry] );
                    LEAVE_DDRAW();
                    return DD_FALSE;
                }

                entry += 16;
            }
        }
    }

    /*
     * The palettes are the same!
     */
    LEAVE_DDRAW();

    return DD_OK;

} /* DD_Palette_SetEntries */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddmodent.c ===
//=============================================================================
//
//  Copyright (C) 1998 Microsoft Corporation. All rights reserved.
//
//     File:  ddmodent.c
//  Content:  DirectDraw display mode code for NT
//
//  Date        By        Reason
//  ----------  --------  -----------------------------------------------------
//  02/20/1998  johnstep  Initialial implementation, replaces ddmode.c on NT
//  05/29/1998  jeffno    ModeX emulation
//
//=============================================================================

#include "ddrawpr.h"
#include "ddrawgdi.h"

#define MODEX_WIDTH     320
#define MODEX_HEIGHT1   200
#define MODEX_HEIGHT2   240
#define MODEX_BPP       8

//=============================================================================
//
//  Function: GetNumberOfMonitorAttachedToDesktop
//
//  Count number of monitors attached to current desktop.
//
//=============================================================================

DWORD GetNumberOfMonitorAttachedToDesktop()
{
    DWORD dwNumberOfMonitor = 0;
    DWORD iDevNum = 0;
    DISPLAY_DEVICE DisplayDevice;

    ZeroMemory(&DisplayDevice,sizeof(DISPLAY_DEVICE));
    DisplayDevice.cb = sizeof(DISPLAY_DEVICE);

    while (EnumDisplayDevices(NULL,iDevNum,&DisplayDevice,0))
    {
        if (DisplayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP)
        {
            dwNumberOfMonitor++;
        }

        ZeroMemory(&DisplayDevice,sizeof(DISPLAY_DEVICE));
        DisplayDevice.cb = sizeof(DISPLAY_DEVICE);

        iDevNum++;
    }

    return dwNumberOfMonitor;
}


//=============================================================================
//
//  Function: resetAllDirectDrawObjects
//
//  On NT we have to reenable all the DirectDraw objects on any mode change
//  because a mode change disables all the kernel mode DirectDraw objects due
//  to desktop changes, etc.
//
//=============================================================================

void resetAllDirectDrawObjects()
{
    LPDDRAWI_DIRECTDRAW_LCL pdd_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    BOOL bRestoreGamma;
    HDC hdc;
    WORD wMonitorsAttachedToDesktop = (WORD) GetNumberOfMonitorAttachedToDesktop();

    // First mark all DirectDraw global objects as having not changed.

    for (pdd_lcl = lpDriverLocalList; pdd_lcl;)
    {
        if (pdd_lcl->lpGbl)
        {
            pdd_lcl->lpGbl->dwFlags |= DDRAWI_DDRAWDATANOTFETCHED;
        }
        pdd_lcl = pdd_lcl->lpLink;
    }

    // Now reset all drivers unmarking them as we go. We may need to create
    // temporary kernel mode DirectDraw objects in order to pass down a valid
    // handle to the kernel.

    for (pdd_lcl = lpDriverLocalList; pdd_lcl;)
    {
        pdd_gbl = pdd_lcl->lpGbl;

        if (pdd_gbl && (pdd_gbl->dwFlags & DDRAWI_DDRAWDATANOTFETCHED))
        {
            // Determine if the gamma ramp needs to be restored

            bRestoreGamma = ( pdd_lcl->lpPrimary != NULL ) &&
                ( pdd_lcl->lpPrimary->lpLcl->lpSurfMore->lpGammaRamp != NULL ) &&
                ( pdd_lcl->lpPrimary->lpLcl->dwFlags & DDRAWISURF_SETGAMMA );

            pdd_gbl->dwFlags &= ~DDRAWI_DDRAWDATANOTFETCHED;

            if (!(pdd_gbl->dwFlags & DDRAWI_MODEX))
            {
                // If we find a local for this process/driver pair, we will use
                // its hDD to pass to the kernel. If not, we must create a
                // temproary kernel mode DirectDraw object, and delete it after
                // resetting the driver.

                FetchDirectDrawData(pdd_gbl, TRUE, 0, NULL, NULL, 0, pdd_lcl);
            }
            else
            {
                DDHALMODEINFO mi =
                {
	            MODEX_WIDTH,    // width (in pixels) of mode
	            MODEX_HEIGHT1,    // height (in pixels) of mode
	            MODEX_WIDTH,    // pitch (in bytes) of mode
	            MODEX_BPP,      // bits per pixel
	            (WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	            0,      // refresh rate
	            0,      // red bit mask
	            0,      // green bit mask
	            0,      // blue bit mask
	            0       // alpha bit mask
                };

                //fixup the height to the actual height:
                mi.dwHeight = pdd_lcl->dmiPreferred.wHeight;

                fetchModeXData( pdd_gbl, &mi, INVALID_HANDLE_VALUE );
            }

            pdd_gbl->dmiCurrent.wMonitorsAttachedToDesktop = (BYTE)wMonitorsAttachedToDesktop;

            hdc = DD_CreateDC(pdd_gbl->cDriverName);

            if ( pdd_gbl->dwFlags & DDRAWI_NOHARDWARE )
            {
                // The HEL will wipe out our hard-earned modex data otherwise
                if (0 == (pdd_gbl->dwFlags & DDRAWI_MODEX) )
                {
                    extern void UpdateDirectDrawMode(LPDDRAWI_DIRECTDRAW_GBL);
                    UpdateDirectDrawMode(pdd_gbl);
                }
            }
            else
            {
                if( bRestoreGamma )
                {
                    SetGamma( pdd_lcl->lpPrimary->lpLcl, pdd_lcl );
                }

                InitDIB(hdc, pdd_gbl->gpbmiSrc);
                InitDIB(hdc, pdd_gbl->gpbmiDest);
            }

            DD_DoneDC(hdc);
        }
        pdd_lcl = pdd_lcl->lpLink;
    }
    CheckAliasedLocksOnModeChange();
}

//=============================================================================
//
//  Function: ModeChangedOnENTERDDRAW
//
//=============================================================================

void ModeChangedOnENTERDDRAW(void)
{
    resetAllDirectDrawObjects();
}

//=============================================================================
//
//  Function: FillBitMasks
//
//=============================================================================

void FillBitMasks(LPDDPIXELFORMAT pddpf, HDC hdc)
{
    if (hdc)
    {
        HBITMAP hbm;
        BITMAPINFO *pbmi;
        DWORD *pdwColors;

        if (pbmi = LocalAlloc(LPTR, 3 * sizeof (RGBQUAD) + sizeof (BITMAPINFO)))
        {
            if (hbm = CreateCompatibleBitmap(hdc, 1, 1))
            {
                pbmi->bmiHeader.biSize = sizeof (BITMAPINFOHEADER);

                if (GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS))
                {
                    if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                    {
                        GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight,
                            NULL, pbmi, DIB_RGB_COLORS);

                        pdwColors = (DWORD *) &pbmi->bmiColors[0];
                        pddpf->dwRBitMask = pdwColors[0];
                        pddpf->dwGBitMask = pdwColors[1];
                        pddpf->dwBBitMask = pdwColors[2];
                        pddpf->dwRGBAlphaBitMask = 0;
                    }
                }
                DeleteObject(hbm);
            }
            LocalFree(pbmi);
        }
    }
    else
    {
        switch (pddpf->dwRGBBitCount)
        {
        case 15:
            pddpf->dwRBitMask = 0x7C00;
            pddpf->dwGBitMask = 0x03E0;
            pddpf->dwBBitMask = 0x001F;
            pddpf->dwRGBAlphaBitMask = 0;
            break;

        case 16:
            pddpf->dwRBitMask = 0xF800;
            pddpf->dwGBitMask = 0x07E0;
            pddpf->dwBBitMask = 0x001F;
            pddpf->dwRGBAlphaBitMask = 0;
            break;

        case 32:
            pddpf->dwRBitMask = 0x00FF0000;
            pddpf->dwGBitMask = 0x0000FF00;
            pddpf->dwBBitMask = 0x000000FF;
            pddpf->dwRGBAlphaBitMask = 0x00000000;
            break;

        default:
            pddpf->dwRBitMask = 0;
            pddpf->dwGBitMask = 0;
            pddpf->dwBBitMask = 0;
            pddpf->dwRGBAlphaBitMask = 0;
        }
    }
}

//=============================================================================
//
//  Function: setPixelFormat
//
//=============================================================================

static void setPixelFormat(LPDDPIXELFORMAT pddpf, HDC hdc, DWORD bpp)
{
    pddpf->dwSize = sizeof (DDPIXELFORMAT);
    pddpf->dwFlags = DDPF_RGB;
    pddpf->dwRGBBitCount = hdc ? GetDeviceCaps(hdc, BITSPIXEL) : bpp;

    switch (pddpf->dwRGBBitCount)
    {
        case 8:
            pddpf->dwFlags |= DDPF_PALETTEINDEXED8;
            pddpf->dwRBitMask = 0;
            pddpf->dwGBitMask = 0;
            pddpf->dwBBitMask = 0;
            pddpf->dwRGBAlphaBitMask = 0;
            break;

        case 24:
            pddpf->dwRBitMask = 0x00FF0000;
            pddpf->dwGBitMask = 0x0000FF00;
            pddpf->dwBBitMask = 0x000000FF;
            pddpf->dwRGBAlphaBitMask = 0x00000000;
            break;

        default:
            FillBitMasks(pddpf, hdc);
            break;
    }
}

//=============================================================================
//
//  Function: DD_GetDisplayMode
//
//=============================================================================

HRESULT DDAPI DD_GetDisplayMode(LPDIRECTDRAW pdd, LPDDSURFACEDESC pddsd)
{
    LPDDRAWI_DIRECTDRAW_INT pdd_int;
    LPDDRAWI_DIRECTDRAW_LCL pdd_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    HDC hdc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetDisplayMode");

    TRY
    {
        pdd_int = (LPDDRAWI_DIRECTDRAW_INT) pdd;
        if (!VALID_DIRECTDRAW_PTR(pdd_int))
        {
            DPF(0, "Invalid object");
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }

        pdd_lcl = pdd_int->lpLcl;
        pdd_gbl = pdd_lcl->lpGbl;

        if (!VALIDEX_DDSURFACEDESC2_PTR(pddsd) &&
            !VALIDEX_DDSURFACEDESC_PTR(pddsd))
        {
            DPF(0, "Invalid params");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("DD_GetDisplayMode: Exception encountered validating parameters");
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    ZeroMemory(pddsd, pddsd->dwSize);

    if (LOWERTHANDDRAW4(pdd_int))
    {
        pddsd->dwSize = sizeof (DDSURFACEDESC);
    }
    else
    {
        pddsd->dwSize = sizeof (DDSURFACEDESC2);
    }

    pddsd->dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH | DDSD_PIXELFORMAT | DDSD_REFRESHRATE;

    hdc = DD_CreateDC(pdd_gbl->cDriverName);

    pddsd->dwWidth = pdd_gbl->lpModeInfo->dwWidth;
    pddsd->dwHeight = pdd_gbl->lpModeInfo->dwHeight;
    pddsd->dwRefreshRate = pdd_gbl->lpModeInfo->wRefreshRate;

    setPixelFormat(&(pddsd->ddpfPixelFormat), hdc, 0);
    pddsd->lPitch = (pddsd->dwWidth * pddsd->ddpfPixelFormat.dwRGBBitCount) >> 3; // hack

    // set stereo surface caps bits if driver marks mode as stereo mode
    if (GetDDStereoMode(pdd_gbl,
                            pddsd->dwWidth,
                            pddsd->dwHeight,
                            pddsd->ddpfPixelFormat.dwRGBBitCount,
                            pddsd->dwRefreshRate) &&
        !LOWERTHANDDRAW7(pdd_int) &&
        VALIDEX_DDSURFACEDESC2_PTR(pddsd))
    {
        LPDDSURFACEDESC2 pddsd2  = (LPDDSURFACEDESC2)pddsd;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_STEREOSURFACELEFT;
    }

    DD_DoneDC(hdc);

    LEAVE_DDRAW();

    return DD_OK;
}

//=============================================================================
//
//  Function: SetDisplayMode
//
//=============================================================================


/*
 * IsRefreshRateSupported
 */
BOOL IsRefreshRateSupported(LPDDRAWI_DIRECTDRAW_GBL   pdrv,
                            DWORD                     Width,
                            DWORD                     Height,
                            DWORD                     BitsPerPixel,
                            DWORD                     RefreshRate)
{
    DEVMODE dm;
    LPSTR pDeviceName;
    int i;

    pDeviceName = (_stricmp(pdrv->cDriverName, "display") == 0) ?
        g_szPrimaryDisplay : pdrv->cDriverName;

    for (i = 0;; i++)
    {
        ZeroMemory(&dm, sizeof dm);
        dm.dmSize = sizeof dm;

        if (EnumDisplaySettings(pDeviceName, i, &dm))
        {
            if ((dm.dmPelsWidth == Width) &&
                (dm.dmPelsHeight == Height) &&
                (dm.dmBitsPerPel == BitsPerPixel) &&
                (dm.dmDisplayFrequency == RefreshRate))
            {
                return TRUE;
            }
        }
        else
        {
            break;
        }
    }

    return FALSE;
}

/*
 * PickRefreshRate
 *
 * On NT, we want to pick a high reffresh rate, but we don't want to pick one 
 * too high.  In theory, mode pruning would be 100% safe and we can always pick
 * a high one, but we don't trust it 100%.  
 */
DWORD PickRefreshRate(LPDDRAWI_DIRECTDRAW_GBL   pdrv,
                      DWORD                     Width,
                      DWORD                     Height,
                      DWORD                     RefreshRate,
                      DWORD                     BitsPerPixel)
{
    DEVMODE dm;
    LPSTR pDeviceName;

    pDeviceName = (_stricmp(pdrv->cDriverName, "display") == 0) ?
        g_szPrimaryDisplay : pdrv->cDriverName;
    
    if (dwRegFlags & DDRAW_REGFLAGS_FORCEREFRESHRATE)
    {
        if (IsRefreshRateSupported(pdrv,
                                   Width,
                                   Height,
                                   BitsPerPixel,
                                   dwForceRefreshRate))
        {
            return dwForceRefreshRate;
        }
    }

    // If the app specified the refresh rate, we will use it; otherwise, we'll
    // pick one ourselves.
    if (RefreshRate == 0)
    {
        // If the mode requires no more bandwidth than the desktop mode from which
        // the app was launched, we will go ahead and try that mode.
        ZeroMemory(&dm, sizeof dm);
        dm.dmSize = sizeof dm;

        EnumDisplaySettings(pDeviceName, ENUM_REGISTRY_SETTINGS, &dm);

        if ((Width <= dm.dmPelsWidth) &&
            (Height <= dm.dmPelsHeight))
        {
            if (IsRefreshRateSupported(pdrv,
                                       Width,
                                       Height,
                                       BitsPerPixel,
                                       dm.dmDisplayFrequency))
            {
                RefreshRate = dm.dmDisplayFrequency;
            }
        }

        // If we still don't have a refresh rate, try 75hz
        if (RefreshRate == 0)
        {
            if (IsRefreshRateSupported(pdrv,
                                       Width,
                                       Height,
                                       BitsPerPixel,
                                       75))
            {
                RefreshRate = 75;
            }
        }

        // If we still don't have a refresh rate, use 60hz
        if (RefreshRate == 0)
        {
            if (IsRefreshRateSupported(pdrv,
                                       Width,
                                       Height,
                                       BitsPerPixel,
                                       60))
            {
                RefreshRate = 60;
            }
        }
    }

    return RefreshRate;
}

HRESULT SetDisplayMode(
    LPDDRAWI_DIRECTDRAW_LCL pdd_lcl,
    DWORD index,
    BOOL force,
    BOOL useRefreshRate)
{
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    DEVMODE dm;
    LONG result;
    BOOL bNewMode;
    DDHALINFO ddhi;
    LPCTSTR pszDevice;
    DWORD refreshRate;
    BOOL forceRefresh;

    pdd_lcl->dwLocalFlags |= DDRAWILCL_MODEHASBEENCHANGED;

    pdd_gbl = pdd_lcl->lpGbl;

    //
    // If not forcing, do not change mode with surface locks.
    //

    if (!force)
    {
        if (pdd_gbl->dwSurfaceLockCount > 0)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pTemp; 

            // When we enabled vidmem vertex buffers in DX8, we found that some
            // apps do not unlock them before the mode change, but we don't want
            // to break them now, so we will hack around this by allowing the 
            // mode switch to occur if all that's locked are vidmem VBs.

            pTemp = pdd_gbl->dsList;
            while (pTemp != NULL)
            {
                if (pTemp->lpLcl->lpGbl->dwUsageCount > 0)
                {
                    if ((pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                        !(pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
                    {
                        break;
                    }
                }
                pTemp = pTemp->lpLink;
            }

            if (pTemp != NULL)
            {
                return DDERR_SURFACEBUSY;
            }
        }
    }

    //
    // Add code here to not set mode if it didn't change?
    //

    ZeroMemory(&dm, sizeof dm);
    dm.dmSize = sizeof dm;

    dm.dmBitsPerPel = pdd_lcl->dmiPreferred.wBPP;
    dm.dmPelsWidth = pdd_lcl->dmiPreferred.wWidth;
    dm.dmPelsHeight = pdd_lcl->dmiPreferred.wHeight;

    if (dm.dmBitsPerPel == 16)
    {
        if (pdd_gbl->lpModeInfo->wFlags & DDMODEINFO_555MODE)
        {
            dm.dmBitsPerPel = 15;
        }
    }

    dm.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;

    if (useRefreshRate)
    {
        dm.dmDisplayFrequency = PickRefreshRate(pdd_lcl->lpGbl,
                                      dm.dmPelsWidth,
                                      dm.dmPelsHeight,
                                      pdd_lcl->dmiPreferred.wRefreshRate,
                                      dm.dmBitsPerPel);
        dm.dmFields |= DM_DISPLAYFREQUENCY;
    }
    else
    {
        dm.dmDisplayFrequency = PickRefreshRate(pdd_lcl->lpGbl,
                                      dm.dmPelsWidth,
                                      dm.dmPelsHeight,
                                      0,
                                      dm.dmBitsPerPel);
        if (dm.dmDisplayFrequency > 0)
        {
            dm.dmFields |= DM_DISPLAYFREQUENCY;
            pdd_lcl->dmiPreferred.wRefreshRate = (WORD) dm.dmDisplayFrequency;
        }
    }

    if (_stricmp(pdd_gbl->cDriverName, "DISPLAY"))
    {
        pszDevice = pdd_gbl->cDriverName;
    }
    else
    {
        pszDevice = NULL;
    }

    // clean up any previous modex stuff:
    pdd_gbl->dwFlags &= ~DDRAWI_MODEX;

    NotifyDriverToDeferFrees();

    pdd_gbl->dwFlags |= DDRAWI_CHANGINGMODE;
    result = ChangeDisplaySettingsEx(pszDevice, &dm, NULL, CDS_FULLSCREEN, 0);
    pdd_gbl->dwFlags &= ~DDRAWI_CHANGINGMODE;

    DPF(5, "ChangeDisplaySettings: %d", result);

    if (result != DISP_CHANGE_SUCCESSFUL)
    {
        //
        // Check if it's a potentially emulated ModeX mode
        //
        if (pdd_lcl->dwLocalFlags & DDRAWILCL_ALLOWMODEX)
        {
            if (pdd_lcl->dmiPreferred.wBPP == MODEX_BPP &&
                pdd_lcl->dmiPreferred.wWidth == MODEX_WIDTH)
            {
                if (pdd_lcl->dmiPreferred.wHeight == MODEX_HEIGHT2 || pdd_lcl->dmiPreferred.wHeight == MODEX_HEIGHT1)
                {
                    // Set 640x480x8 for consistency with win9x and reliable mouse pos messages.
                    dm.dmFields &= ~DM_DISPLAYFREQUENCY;
                    dm.dmPelsWidth = 640;
                    dm.dmPelsHeight = 480;

                    pdd_gbl->dwFlags |= DDRAWI_CHANGINGMODE;
                    result = ChangeDisplaySettingsEx(pszDevice, &dm, NULL, CDS_FULLSCREEN, 0);
                    pdd_gbl->dwFlags &= ~DDRAWI_CHANGINGMODE;
                }
            }
        }

        if (result == DISP_CHANGE_SUCCESSFUL)
        {
            //now we are in 640x480, we need to mark the ddraw local that it's in emulated modex
            pdd_gbl->dwFlags |= DDRAWI_MODEX;
        }
        else
        {
            //failed to set 640x480
            NotifyDriverOfFreeAliasedLocks();
            return DDERR_UNSUPPORTED;
        }
    }

    uDisplaySettingsUnique = DdQueryDisplaySettingsUniqueness();

    resetAllDirectDrawObjects();
    
    pdd_lcl->dwLocalFlags |= DDRAWILCL_MODEHASBEENCHANGED | DDRAWILCL_DIRTYDC;

    return DD_OK;
}

//=============================================================================
//
//  Function: DD_SetDisplayMode
//
//=============================================================================

HRESULT DDAPI DD_SetDisplayMode(
    LPDIRECTDRAW pdd,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP)
{
    DPF(2,A,"ENTERAPI: DD_SetDisplayMode");
	
    return DD_SetDisplayMode2(pdd, dwWidth, dwHeight, dwBPP, 0, 0);
}

//=============================================================================
//
//  Function: DD_SetDisplayMode2
//
//=============================================================================

HRESULT DDAPI DD_SetDisplayMode2(
    LPDIRECTDRAW pdd,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP,
    DWORD dwRefreshRate,
    DWORD dwFlags)
{
    LPDDRAWI_DIRECTDRAW_INT pdd_int;
    LPDDRAWI_DIRECTDRAW_LCL pdd_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    HRESULT hr;
    DISPLAYMODEINFO dmiSave;
    BOOL excl_exists,has_excl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_SetDisplayMode2");

    TRY
    {
        pdd_int = (LPDDRAWI_DIRECTDRAW_INT) pdd;
        if (!VALID_DIRECTDRAW_PTR(pdd_int))
        {
            DPF(0, "Invalid object");
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }

        if (dwFlags & ~DDSDM_VALID)
        {
            DPF_ERR("Invalid flags");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        pdd_lcl = pdd_int->lpLcl;
        pdd_gbl = pdd_lcl->lpGbl;

        if (pdd_gbl->dwSurfaceLockCount > 0)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pTemp; 

            // When we enabled vidmem vertex buffers in DX8, we found that some
            // apps do not unlock them before the mode change, but we don't want
            // to break them now, so we will hack around this by allowing the 
            // mode switch to occur if all that's locked are vidmem VBs.

            pTemp = pdd_gbl->dsList;
            while (pTemp != NULL)
            {
                if (pTemp->lpLcl->lpGbl->dwUsageCount > 0)
                {
                    if ((pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                        !(pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
                    {
                        break;
                    }
                }
                pTemp = pTemp->lpLink;
            }

            if (pTemp != NULL)
            {
                DPF_ERR("Surfaces are locked, can't switch the mode");
                LEAVE_DDRAW();
                return DDERR_SURFACEBUSY;
            }
        }

        CheckExclusiveMode(pdd_lcl, &excl_exists, &has_excl, FALSE, NULL, FALSE);
        if (excl_exists &&
            (!has_excl))
        {
            DPF_ERR("Can't change mode; exclusive mode not owned");
            LEAVE_DDRAW();
            return DDERR_NOEXCLUSIVEMODE;
        }

        dmiSave = pdd_lcl->dmiPreferred;

        pdd_lcl->dmiPreferred.wWidth = (WORD) dwWidth;
        pdd_lcl->dmiPreferred.wHeight = (WORD) dwHeight;
        pdd_lcl->dmiPreferred.wBPP = (BYTE) dwBPP;
        pdd_lcl->dmiPreferred.wRefreshRate = (WORD) dwRefreshRate;
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("DD_SetDisplayMode2: Exception encountered validating parameters");
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    hr = SetDisplayMode(pdd_lcl, 0, FALSE, dwRefreshRate ? TRUE : FALSE);
    if (FAILED(hr))
    {
        pdd_lcl->dmiPreferred = dmiSave;
    }
    else
    {
        pdd_lcl->dmiPreferred = pdd_gbl->dmiCurrent;
    }

    LEAVE_DDRAW();

    return hr;
}

//=============================================================================
//
//  Function: RestoreDisplayMode
//
//=============================================================================

HRESULT RestoreDisplayMode(LPDDRAWI_DIRECTDRAW_LCL pdd_lcl, BOOL force)
{
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    LPCTSTR pszDevice;
    LONG result;

    pdd_gbl = pdd_lcl->lpGbl;

    pdd_gbl->dwFlags &= ~DDRAWI_MODEX;

    if (!(pdd_lcl->dwLocalFlags & DDRAWILCL_MODEHASBEENCHANGED))
    {
        DPF(2, "Mode was never changed by this app");
        return DD_OK;
    }

    if (!force)
    {
        if (pdd_gbl->dwSurfaceLockCount > 0)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pTemp; 

            // When we enabled vidmem vertex buffers in DX8, we found that some
            // apps do not unlock them before the mode change, but we don't want
            // to break them now, so we will hack around this by allowing the 
            // mode switch to occur if all that's locked are vidmem VBs.

            pTemp = pdd_gbl->dsList;
            while (pTemp != NULL)
            {
                if (pTemp->lpLcl->lpGbl->dwUsageCount > 0)
                {
                    if ((pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                        !(pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
                    {
                        break;
                    }
                }
                pTemp = pTemp->lpLink;
            }

            if (pTemp != NULL)
            {
                return DDERR_SURFACEBUSY;
            }
        }
    }

    if (_stricmp(pdd_gbl->cDriverName, "DISPLAY"))
    {
        pszDevice = pdd_gbl->cDriverName;
    }
    else
    {
        pszDevice = NULL;
    }

    NotifyDriverToDeferFrees();
    pdd_gbl->dwFlags |= DDRAWI_CHANGINGMODE;
    result = ChangeDisplaySettingsEx(pszDevice, NULL, NULL, CDS_FULLSCREEN, 0);
    pdd_gbl->dwFlags &= ~DDRAWI_CHANGINGMODE;

    if (result != DISP_CHANGE_SUCCESSFUL)
    {
        NotifyDriverOfFreeAliasedLocks();
        return DDERR_UNSUPPORTED;
    }

    //
    // FetchDirectDrawData here, which will update the global object with
    // the new mode information.
    //

    uDisplaySettingsUnique = DdQueryDisplaySettingsUniqueness();

    resetAllDirectDrawObjects();

    pdd_lcl->dwLocalFlags &= ~DDRAWILCL_MODEHASBEENCHANGED;
    pdd_lcl->dwLocalFlags |= DDRAWILCL_DIRTYDC;

    RedrawWindow(NULL, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);

    return DD_OK;
}

//=============================================================================
//
//  Function: DD_RestoreDisplayMode
//
//=============================================================================

HRESULT DDAPI DD_RestoreDisplayMode(LPDIRECTDRAW pdd)
{
    LPDDRAWI_DIRECTDRAW_INT pdd_int;
    LPDDRAWI_DIRECTDRAW_LCL pdd_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    BOOL excl_exists,has_excl;
    HRESULT hr;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_RestoreDisplayMode");

    TRY
    {
        pdd_int = (LPDDRAWI_DIRECTDRAW_INT) pdd;
        if (!VALID_DIRECTDRAW_PTR(pdd_int))
        {
            DPF(0, "Invalid object");
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }

        pdd_lcl = pdd_int->lpLcl;
        pdd_gbl = pdd_lcl->lpGbl;

        CheckExclusiveMode(pdd_lcl, &excl_exists, &has_excl, FALSE, NULL, FALSE);
        if (excl_exists &&
            (!has_excl))
        {
            DPF_ERR("Can't change mode; exclusive mode owned");
            LEAVE_DDRAW();
            return DDERR_NOEXCLUSIVEMODE;
        }

        if (pdd_gbl->dwSurfaceLockCount > 0)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pTemp; 

            // When we enabled vidmem vertex buffers in DX8, we found that some
            // apps do not unlock them before the mode change, but we don't want
            // to break them now, so we will hack around this by allowing the 
            // mode switch to occur if all that's locked are vidmem VBs.

            pTemp = pdd_gbl->dsList;
            while (pTemp != NULL)
            {
                if (pTemp->lpLcl->lpGbl->dwUsageCount > 0)
                {
                    if ((pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                        !(pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
                    {
                        break;
                    }
                }
                pTemp = pTemp->lpLink;
            }

            if (pTemp != NULL)
            {
                DPF_ERR("Surfaces are locked, can't switch the mode");
                LEAVE_DDRAW();
                return DDERR_SURFACEBUSY;
            }
        }
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("DD_RestoreDisplayMode: Exception encountered validating parameters");
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    hr = RestoreDisplayMode(pdd_lcl, TRUE);

    LEAVE_DDRAW();

    return hr;
}

//=============================================================================
//
//  Function: DD_EnumDisplayModes
//
//=============================================================================

HRESULT DDAPI DD_EnumDisplayModes(
    LPDIRECTDRAW pdd,
    DWORD dwFlags,
    LPDDSURFACEDESC pddsd,
    LPVOID pContext,
    LPDDENUMMODESCALLBACK pEnumCallback)
{
    DPF(2,A,"ENTERAPI: DD_EnumDisplayModes");

    if (pddsd)
    {
        DDSURFACEDESC2 ddsd2;

        TRY
        {
            if(!VALID_DIRECTDRAW_PTR(((LPDDRAWI_DIRECTDRAW_INT) pdd)))
            {
                return DDERR_INVALIDOBJECT;
            }

            if(!VALID_DDSURFACEDESC_PTR(pddsd))
            {
                DPF_ERR("Invalid surface description. Did you set the dwSize member?");
                DPF_APIRETURNS(DDERR_INVALIDPARAMS);
                return DDERR_INVALIDPARAMS;
            }

            CopyMemory(&ddsd2, pddsd, sizeof *pddsd);
        }
        EXCEPT(EXCEPTION_EXECUTE_HANDLER)
        {
            DPF_ERR("Exception encountered validating parameters: Bad LPDDSURFACEDESC");
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }

        ddsd2.dwSize = sizeof ddsd2;
        ZeroMemory(((LPBYTE)&ddsd2 + sizeof *pddsd), (sizeof ddsd2) - (sizeof *pddsd));

        return DD_EnumDisplayModes4(pdd, dwFlags, &ddsd2, pContext, (LPDDENUMMODESCALLBACK2) pEnumCallback);
    }

    return DD_EnumDisplayModes4(pdd, dwFlags, NULL, pContext, (LPDDENUMMODESCALLBACK2) pEnumCallback);
}

BOOL EnumerateMode(
        LPDDRAWI_DIRECTDRAW_INT pdd_int,
        LPDDENUMMODESCALLBACK2 pEnumCallback,
        LPVOID pContext,
        WORD wWidth,
        WORD wHeight,
        WORD wBPP,
        WORD wRefreshRate,
        DWORD dwFlags,
        BOOL bIsEmulatedModex )
{
    DDSURFACEDESC2 ddsd;

    ZeroMemory(&ddsd, sizeof ddsd);

    if (LOWERTHANDDRAW4(pdd_int))
    {
        ddsd.dwSize = sizeof (DDSURFACEDESC);
    }
    else
    {
        ddsd.dwSize = sizeof (DDSURFACEDESC2);
    }

    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT | DDSD_PITCH | DDSD_REFRESHRATE;
    ddsd.dwWidth = wWidth;
    ddsd.dwHeight = wHeight;
    ddsd.lPitch = (ddsd.dwWidth * wBPP) >> 3; // hack

    setPixelFormat(&(ddsd.ddpfPixelFormat), NULL, wBPP);

    if (dwFlags & DDEDM_REFRESHRATES)
    {
        ddsd.dwRefreshRate = wRefreshRate;
    }
    else
    {
        ddsd.dwRefreshRate = 0;
    }

    if ( bIsEmulatedModex )
    {
        ddsd.ddsCaps.dwCaps |= DDSCAPS_MODEX;
    } else
    { 
        // call driver here if this is a stereo mode!!!
        if (!LOWERTHANDDRAW7(pdd_int) &&
            GetDDStereoMode(pdd_int->lpLcl->lpGbl,
                            wWidth,
                            wHeight,
                            wBPP,
                            ddsd.dwRefreshRate))
        {
            ddsd.ddsCaps.dwCaps2 |= DDSCAPS2_STEREOSURFACELEFT;
        }
    }
    return pEnumCallback(&ddsd, pContext);
}
//=============================================================================
//
//  Function: DD_EnumDisplayModes4
//
//=============================================================================

HRESULT DDAPI DD_EnumDisplayModes4(
    LPDIRECTDRAW pdd,
    DWORD dwFlags,
    LPDDSURFACEDESC2 pddsd,
    LPVOID pContext,
    LPDDENUMMODESCALLBACK2 pEnumCallback)
{
    LPDDRAWI_DIRECTDRAW_INT pdd_int;
    LPDDRAWI_DIRECTDRAW_LCL pdd_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    HRESULT hr;
    DEVMODE dm;
    int i, j;
    DWORD dwResult;
    DISPLAYMODEINFO *pdmi;
    DISPLAYMODEINFO *pdmiTemp;
    int numModes;
    int maxModes;
    LPCTSTR pszDevice;
    BOOL                    bFound320x240x8 = FALSE;
    BOOL                    bFound320x200x8 = FALSE;
    BOOL                    bFound640x480x8 = FALSE;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_EnumDisplayModes4");

    TRY
    {
        pdd_int = (LPDDRAWI_DIRECTDRAW_INT) pdd;
        if (!VALID_DIRECTDRAW_PTR(pdd_int))
        {
            DPF(0, "Invalid object");
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }

        pdd_lcl = pdd_int->lpLcl;
        pdd_gbl = pdd_lcl->lpGbl;

        if (pddsd && !VALID_DDSURFACEDESC2_PTR(pddsd))
        {
            DPF_ERR("Invalid surface description");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if (dwFlags & ~DDEDM_VALID)
        {
            DPF_ERR("Invalid flags");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if (!VALIDEX_CODE_PTR(pEnumCallback))
        {
            DPF_ERR("Invalid enumerate callback pointer");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("Exception encountered validating parameters: Bad LPDDSURFACEDESC");
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    maxModes = 256; // enough to handle most drivers

    pdmi = LocalAlloc(LMEM_FIXED, maxModes * sizeof (DISPLAYMODEINFO));
    if (!pdmi)
    {
        DPF_ERR("Out of memory building mode list");
        LEAVE_DDRAW();
        return DDERR_GENERIC;
    }

    if (_stricmp(pdd_gbl->cDriverName, "DISPLAY"))
    {
        pszDevice = pdd_gbl->cDriverName;
    }
    else
    {
        pszDevice = NULL;
    }

    dm.dmSize = sizeof(dm);
    for (numModes = 0, j = 0; EnumDisplaySettings(pszDevice, j, &dm); ++j)
    {
        //Filter MODEX driver modes
        if ( (_stricmp(dm.dmDeviceName,"MODEX") == 0) || (_stricmp(dm.dmDeviceName,"VGA") == 0) )
        {
            DPF(5,"Filtered mode %dx%dx%d from %s",dm.dmPelsWidth,dm.dmPelsHeight,dm.dmBitsPerPel,dm.dmDeviceName);
            continue;
        }

        if (dm.dmBitsPerPel == MODEX_BPP)
        {
            if (dm.dmPelsWidth == MODEX_WIDTH)
            {
                if (dm.dmPelsHeight == MODEX_HEIGHT1)
                    bFound320x200x8 = TRUE;
                if (dm.dmPelsHeight == MODEX_HEIGHT2)
                    bFound320x240x8 = TRUE;
            }
            if (dm.dmPelsWidth == 640 && dm.dmPelsHeight == 480)
                bFound640x480x8 = TRUE;
        }

        //Filter less than 256 color modes
        if (dm.dmBitsPerPel < 8)
        {
            continue;
        }

        //
        // NOTE: If the driver supports 15 bpp but not 16, then
        // EnumDisplaySettings will return 16 for compatibility reasons. The
        // bitmasks we fill in will be for 16 bpp (since we can't determine
        // which mode it really is), so they may be incorrect.
        //
        // There should never be a case where we got only 15 bpp. If a driver
        // only supports 555, it should be reported as 16 bpp.
        //

        if (dm.dmBitsPerPel == 15)
        {
            dm.dmBitsPerPel = 16;
        }

        //
        // If the caller supplied a DDSURFACEDESC, check for width,
        // height, bpp, and refresh rate for a match.
        //

        if (pddsd &&
            (((pddsd->dwFlags & DDSD_WIDTH) &&
            (dm.dmPelsWidth != pddsd->dwWidth)) ||
            ((pddsd->dwFlags & DDSD_HEIGHT) &&
            (dm.dmPelsHeight != pddsd->dwHeight)) ||
            ((pddsd->dwFlags & DDSD_PIXELFORMAT) &&
            (dm.dmBitsPerPel != pddsd->ddpfPixelFormat.dwRGBBitCount)) ||
            ((pddsd->dwFlags & DDSD_REFRESHRATE) &&
            (dm.dmDisplayFrequency != pddsd->dwRefreshRate))))
        {
            continue; // current mode does not match criteria
        }

        //
        // Check to see if mode is already in the list. The flag which
        // affects this is DDEDM_REFRESHRATES.
        //

        for (i = 0; i < numModes; ++i)
        {
            if ((dm.dmPelsWidth == pdmi[i].wWidth) &&
                (dm.dmPelsHeight == pdmi[i].wHeight) &&
                (dm.dmBitsPerPel == pdmi[i].wBPP))
            {
                if (dwFlags & DDEDM_REFRESHRATES)
                {
                    if (dm.dmDisplayFrequency == pdmi[i].wRefreshRate)
                    {
                        break; // found a match
                    }
                }
                else
                {
                    break; // found a match
                }
            }
        }
        if (i < numModes)
        {
            continue; // mode already in list
        }

        pdmi[numModes].wWidth = (WORD) dm.dmPelsWidth;
        pdmi[numModes].wHeight = (WORD) dm.dmPelsHeight;
        pdmi[numModes].wBPP = (BYTE) dm.dmBitsPerPel;
        pdmi[numModes].wRefreshRate = (dwFlags & DDEDM_REFRESHRATES) ?
            (WORD) dm.dmDisplayFrequency : 0;

        if (++numModes >= maxModes)
        {
            if (maxModes < 8192)
            {
                maxModes <<= 1;

                pdmiTemp = LocalAlloc(LMEM_FIXED, maxModes * sizeof (DISPLAYMODEINFO));
                if (pdmiTemp)
                {
                    CopyMemory(pdmiTemp, pdmi, numModes * sizeof (DISPLAYMODEINFO));
                    LocalFree(pdmi);
                    pdmi = pdmiTemp;
                }
                else
                {
                    LocalFree(pdmi);
                    DPF_ERR("Out of memory expanding mode list");
                    LEAVE_DDRAW();
                    return DDERR_GENERIC;
                }
            }
            else
            {
                LocalFree(pdmi);
                DPF_ERR("Too many display modes");
                LEAVE_DDRAW();
                return DDERR_GENERIC;
            }
        }
    }

    //
    // Should we sort modes here? Probably not.
    //

    for (i = 0; i < numModes; ++i)
    {
        if (!EnumerateMode(
            pdd_int,
            pEnumCallback, pContext,
            pdmi[i].wWidth,
            pdmi[i].wHeight,
            pdmi[i].wBPP,
            pdmi[i].wRefreshRate,
            dwFlags,
            FALSE )) //not a modex mode
        {
            break;
        }
    }

    //
    // Enumerate emulated modex modes if required
    //
    while (1)
    {
        if (pdd_lcl->dwLocalFlags & DDRAWILCL_ALLOWMODEX)
        {
            //640x480 is necessary to turn on emulation
            if ( bFound640x480x8 )
            {
                if ( !bFound320x200x8 )
                {
                    if (!EnumerateMode(
                        pdd_int,
                        pEnumCallback, pContext,
                        MODEX_WIDTH,MODEX_HEIGHT1,MODEX_BPP,60,
                        dwFlags,
                        TRUE )) //not a modex mode
                    {
                        break;
                    }
                }
                if ( !bFound320x240x8 )
                {
                    if (!EnumerateMode(
                        pdd_int,
                        pEnumCallback, pContext,
                        MODEX_WIDTH,MODEX_HEIGHT2,MODEX_BPP,60,
                        dwFlags,
                        TRUE )) //not a modex mode
                    {
                        break;
                    }
                }
            }
        }
        break;
    }

    LocalFree(pdmi);
    LEAVE_DDRAW();

    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddrestor.c ===
//=============================================================================
//
//  Copyright (C) 1997 Microsoft Corporation. All rights reserved.
//
//     File:  ddrestor.c
//  Content:  DirectDraw persistent-content surfaces for Windows 9x
//
//  Date        By        Reason
//  ----------  --------  -----------------------------------------------------
//  09/30/1997  jeffno    Created
//  10/02/1997  johnstep  Initial implementation
//
//=============================================================================

#include "ddrawpr.h"
#include "dx8priv.h"

//
// MEM_SHARED is an undocumented flag for VirtualAlloc, taken from the Windows
// 9x source code.
//

#define MEM_SHARED	0x08000000	// make memory globally visible

//
// QWORD_MULTIPLE is used to compute the pitch of a dummy surface,
// based on its width, given that the pitch must be a QWORD multiple.
//

#define QWORD_MULTIPLE(x) (((x) + 7) & 0xFFFFFFF8)

//=============================================================================
//
//  Function: allocSurfaceContentsMemory
//
//=============================================================================

static HRESULT allocSurfaceContentsMemory(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    LPDDRAWI_DDRAWSURFACE_GBL       this_gbl;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE  this_gbl_more;
    DWORD                           size;
    LPVOID                          pvContents;
    LPDDPIXELFORMAT                 lpddpf;

    this_gbl = this_lcl->lpGbl;
    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE(this_gbl);

    this_gbl_more->pvContents = NULL;
    this_gbl_more->dwBackupStamp = 0;

    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        return DD_OK;
    }

    if (this_gbl->wHeight)
    {
        GET_PIXEL_FORMAT(this_lcl, this_gbl, lpddpf);
        size = QWORD_MULTIPLE((this_gbl->wWidth * lpddpf->dwRGBBitCount) >> 3) * this_gbl->wHeight;
    }
    else
    {
        size = this_gbl->dwLinearSize;
    }

    //
    // Use VirtualAlloc with the undocumented MEM_SHARED flag so the memory
    // is allcocated from the Windows 9x shared arena. We could change this to
    // use MemAlloc() and instead of VirtualFree, MemFree().
    //

    pvContents = VirtualAlloc(NULL, size, MEM_COMMIT | MEM_SHARED, PAGE_READWRITE);

    if (!pvContents)
    {
        return DDERR_GENERIC;
    }

    this_gbl_more->pvContents = pvContents;

    return DD_OK;
}

//=============================================================================
//
//  Function: allocSurfaceAttachContents
//
//=============================================================================

static HRESULT allocSurfaceAttachContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    LPATTACHLIST                pattachList;
    LPDDRAWI_DDRAWSURFACE_INT   curr_int;
    LPDDRAWI_DDRAWSURFACE_LCL   curr_lcl;
    HRESULT                     ddrval;

    for (pattachList = this_lcl->lpAttachList; pattachList; pattachList = pattachList->lpLink)
    {
        curr_int = pattachList->lpIAttached;
        curr_lcl = curr_int->lpLcl;

        if (curr_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE)
        {
            ddrval = AllocSurfaceContents(curr_lcl);
            if (FAILED(ddrval))
            {
                return ddrval;
            }
        }
    }

    return DD_OK;
}

//=============================================================================
//
//  Function: AllocSurfaceContents
//
//=============================================================================

HRESULT AllocSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    HRESULT ddrval;

    ddrval = allocSurfaceContentsMemory(this_lcl);
    if (FAILED(ddrval))
    {
        return ddrval;
    }

    ddrval = allocSurfaceAttachContents(this_lcl);
    if (FAILED(ddrval))
    {
        return ddrval;
    }

    return DD_OK;
}

//=============================================================================
//
//  Function: FreeSurfaceContents
//
//=============================================================================

void FreeSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE    this_gbl_more;

    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE(this_lcl->lpGbl);

    VirtualFree(this_gbl_more->pvContents, 0, MEM_RELEASE);

    this_gbl_more->pvContents = NULL;
}

//=============================================================================
//
//  Function: createDummySurface
//
//=============================================================================

static LPDDRAWI_DDRAWSURFACE_INT createDummySurface(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    LPDDRAWI_DIRECTDRAW_INT pdrv_int;
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    DDSURFACEDESC2 ddsd;
    LPDIRECTDRAWSURFACE lpdds;
    HRESULT ddrval;

    pdrv_int = this_lcl->lpSurfMore->lpDD_int;
    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;

    ZeroMemory(&ddsd, sizeof ddsd);
    ddsd.dwSize = sizeof ddsd;
    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    ddsd.dwWidth = 1;
    ddsd.dwHeight = 1;
    ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY;

    ddrval = InternalCreateSurface(pdrv_lcl, &ddsd, &lpdds, pdrv_int, NULL, 0);
    if (FAILED(ddrval))
    {
        return NULL;
    }

    return (LPDDRAWI_DDRAWSURFACE_INT) lpdds;
}

//=============================================================================
//
//  Function: BackupSurfaceContents
//
//  This function assumes that the surface passed in is a video memory
//  surface.
//
//=============================================================================

HRESULT BackupSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    LPDDRAWI_DDRAWSURFACE_GBL       this_gbl;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE  this_gbl_more;
    HRESULT                         ddrval;
    LPVOID                          pbits;
    LPDDRAWI_DDRAWSURFACE_INT       psurf_int;
    LPDDRAWI_DDRAWSURFACE_INT       pnew_int;
    LPDDRAWI_DIRECTDRAW_GBL         pdrv;
    DDSURFACEDESC2                  ddsd;
    DWORD                           bytes;
    LPBYTE                          psrc;
    LPBYTE                          pdst;
    DWORD                           y;
    LONG                            pitch;
    LPDDPIXELFORMAT                 lpddpf;

    this_gbl = this_lcl->lpGbl;
    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE(this_gbl);

    if (!this_gbl_more->dwBackupStamp &&
        (this_gbl_more->dwBackupStamp == this_gbl_more->dwContentsStamp))
    {
        DPF(3, "Contents unchanged, so not backing up again");
        return DD_OK;
    }

    if (!this_gbl_more->pvContents)
    {
        return DDERR_GENERIC;
    }

    pdrv = this_gbl->lpDD;

    GET_PIXEL_FORMAT(this_lcl, this_gbl, lpddpf);
    pitch = QWORD_MULTIPLE((this_gbl->wWidth * lpddpf->dwRGBBitCount) >> 3);

    psurf_int = createDummySurface(this_lcl);

    //
    // First try to blt, if that fails, we'll lock and copy memory
    //

    if (psurf_int)
    {
        ZeroMemory(&ddsd, sizeof ddsd);
        ddsd.dwSize = sizeof ddsd;
        ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH | DDSD_LPSURFACE | DDSD_PIXELFORMAT;
        ddsd.ddpfPixelFormat.dwSize = sizeof ddsd.ddpfPixelFormat;
        DD_Surface_GetPixelFormat((LPDIRECTDRAWSURFACE) psurf_int, &ddsd.ddpfPixelFormat);
        ddsd.dwWidth = this_gbl->wWidth;
        ddsd.dwHeight = this_gbl->wHeight;
        ddsd.lPitch = pitch;
        ddsd.lpSurface = this_gbl_more->pvContents;

        ddrval = DD_Surface_SetSurfaceDesc4((LPDIRECTDRAWSURFACE3) psurf_int, &ddsd, 0);
        if (SUCCEEDED(ddrval))
        {
            pnew_int = MemAlloc(sizeof (DDRAWI_DDRAWSURFACE_INT));
            if (pnew_int)
            {
                pnew_int->lpVtbl = &ddSurface4Callbacks;
                pnew_int->lpLcl = this_lcl;
                pnew_int->lpLink = pdrv->dsList;
                pdrv->dsList = pnew_int;
                pnew_int->dwIntRefCnt = 0;

                ddrval = ((LPDIRECTDRAWSURFACE) psurf_int)->lpVtbl->Blt(
                    (LPDIRECTDRAWSURFACE) psurf_int,
                    NULL,
                    (LPDIRECTDRAWSURFACE) pnew_int,
                    NULL,
                    DDBLT_WAIT,
                    NULL);

                pdrv->dsList = pnew_int->lpLink;
                MemFree(pnew_int);

                if (SUCCEEDED(ddrval))
                {
                    InternalSurfaceRelease(psurf_int, FALSE, FALSE);

                    this_gbl_more->dwBackupStamp = this_gbl_more->dwContentsStamp;

                    DPF(4, "BackupSurfaceContents Blt succeeded");

                    return DD_OK;
                }
            }
        }

        InternalSurfaceRelease(psurf_int, FALSE, FALSE);
    }

    //
    // Blt failed, so now we'll just lock and copy memory
    //

    ddrval = InternalLock(this_lcl, &pbits, NULL , DDLOCK_WAIT | DDLOCK_TAKE_WIN16);
    if (SUCCEEDED(ddrval))
    {
        psrc = pbits;
        pdst = this_gbl_more->pvContents;
        bytes = this_gbl->wWidth;
        bytes *= lpddpf->dwRGBBitCount;
        bytes >>= 3;

        for (y = 0; y < this_gbl->wHeight; ++y)
        {
            CopyMemory(pdst, psrc, bytes);
            psrc += this_gbl->lPitch;
            pdst += pitch;
        }

        InternalUnlock(this_lcl, NULL, NULL, DDLOCK_TAKE_WIN16);
        DPF(5, "BackupSurfaceContents CopyMemory succeeded");
    }
    else
    {
        FreeSurfaceContents(this_lcl);
        return ddrval;
    }

    return DD_OK;
}

//=============================================================================
//
//  Function: RestoreSurfaceContents
//
//=============================================================================

HRESULT RestoreSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    LPDDRAWI_DDRAWSURFACE_GBL       this_gbl;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE  this_gbl_more;
    HRESULT                         ddrval;
    LPVOID                          pbits;
    LPDDRAWI_DDRAWSURFACE_INT       psurf_int;
    LPDDRAWI_DDRAWSURFACE_INT       pnew_int;
    LPDDRAWI_DIRECTDRAW_GBL         pdrv;
    DDSURFACEDESC2                  ddsd;
    DWORD                           bytes;
    LPBYTE                          psrc;
    LPBYTE                          pdst;
    DWORD                           y;
    LONG                            pitch;
    LPDDPIXELFORMAT                 lpddpf;

    this_gbl = this_lcl->lpGbl;
    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE(this_gbl);

    if (!this_gbl_more->pvContents)
    {
        return DDERR_GENERIC; // backup probably failed
    }

    pdrv = this_gbl->lpDD;

    GET_PIXEL_FORMAT(this_lcl, this_gbl, lpddpf);
    pitch = QWORD_MULTIPLE((this_gbl->wWidth * lpddpf->dwRGBBitCount) >> 3);

    psurf_int = createDummySurface(this_lcl);

    //
    // First try to blt, if that fails, we'll lock and copy memory
    //

    if (psurf_int)
    {
        ZeroMemory(&ddsd, sizeof ddsd);
        ddsd.dwSize = sizeof ddsd;
        ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH | DDSD_LPSURFACE | DDSD_PIXELFORMAT;
        ddsd.ddpfPixelFormat.dwSize = sizeof ddsd.ddpfPixelFormat;
        DD_Surface_GetPixelFormat((LPDIRECTDRAWSURFACE) psurf_int, &ddsd.ddpfPixelFormat);
        ddsd.dwWidth = this_gbl->wWidth;
        ddsd.dwHeight = this_gbl->wHeight;
        ddsd.lPitch = pitch;
        ddsd.lpSurface = this_gbl_more->pvContents;

        ddrval = DD_Surface_SetSurfaceDesc4((LPDIRECTDRAWSURFACE3) psurf_int, &ddsd, 0);
        if (SUCCEEDED(ddrval))
        {
            pnew_int = MemAlloc(sizeof (DDRAWI_DDRAWSURFACE_INT));
            if (pnew_int)
            {
                pnew_int->lpVtbl = &ddSurface4Callbacks;
                pnew_int->lpLcl = this_lcl;
                pnew_int->lpLink = pdrv->dsList;
                pdrv->dsList = pnew_int;
                pnew_int->dwIntRefCnt = 0;

                ddrval = ((LPDIRECTDRAWSURFACE) psurf_int)->lpVtbl->Blt(
                    (LPDIRECTDRAWSURFACE) pnew_int,
                    NULL,
                    (LPDIRECTDRAWSURFACE) psurf_int,
                    NULL,
                    DDBLT_WAIT,
                    NULL);

                this_gbl_more->dwBackupStamp = this_gbl_more->dwContentsStamp;

                pdrv->dsList = pnew_int->lpLink;
                MemFree(pnew_int);

                if (SUCCEEDED(ddrval))
                {
                    InternalSurfaceRelease(psurf_int, FALSE, FALSE);
                    DPF(5, "RestoreSurfaceContents Blt succeeded");

                    return DD_OK;
                }
            }
        }

        InternalSurfaceRelease(psurf_int, FALSE, FALSE);
    }

    //
    // Blt failed, so now we'll just lock and copy memory
    //

    ddrval = InternalLock(this_lcl, &pbits, NULL , DDLOCK_WAIT | DDLOCK_TAKE_WIN16);
    if (SUCCEEDED(ddrval))
    {
        psrc = this_gbl_more->pvContents;
        pdst = pbits;
        bytes = this_gbl->wWidth;
        bytes *= lpddpf->dwRGBBitCount;
        bytes >>= 3;

        for (y = 0; y < this_gbl->wHeight; ++y)
        {
            CopyMemory(pdst, psrc, bytes);
            psrc += pitch;
            pdst += this_gbl->lPitch;
        }

        InternalUnlock(this_lcl, NULL, NULL, DDLOCK_TAKE_WIN16);
        DPF(5, "RestoreSurfaceContents CopyMemory succeeded");

        this_gbl_more->dwBackupStamp = this_gbl_more->dwContentsStamp;
    }
    else
    {
        return ddrval;
    }

    return DD_OK;
}

//=============================================================================
//
//  Function: restoreSurfaces
//
//=============================================================================

static HRESULT restoreSurfaces(LPDDRAWI_DDRAWSURFACE_INT this_int, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl)
{
    HRESULT ddrval;

    if (this_int)
    {
        while (this_int &&
            ((this_int->lpLcl->lpSurfMore->lpDD_lcl != pdrv_lcl) ||
            (this_int->lpLcl->dwFlags & DDRAWISURF_IMPLICITCREATE)))
        {
            this_int = this_int->lpLink;
        }
        if (this_int)
        {
            ddrval = restoreSurfaces(this_int->lpLink, pdrv_lcl);
            if (SUCCEEDED(ddrval))
            {
                ddrval = DD_Surface_Restore((LPDIRECTDRAWSURFACE) this_int);
                if (FAILED(ddrval))
                {
                    return ddrval;
                }
            }
            else
            {
                return ddrval;
            }
        }
    }

    return DD_OK;
}

//=============================================================================
//
//  Function: DD_RestoreAllSurfaces
//
//  Restore all surfaces owned by the DirectDraw object.
//
//=============================================================================

HRESULT EXTERN_DDAPI DD_RestoreAllSurfaces(LPDIRECTDRAW lpDD)
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    HRESULT                 ddrval;


    ENTER_DDRAW()

    DPF(2,A,"ENTERAPI: DD_RestoreALlSurfaces");
    /*DPF(2, "RestoreAllSurfaces");*/

        TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if (!VALID_DIRECTDRAW_PTR(this_int))
        {
            LEAVE_DDRAW()
                return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("Exception encountered validating parameters");
        LEAVE_DDRAW()
            return DDERR_INVALIDPARAMS;
    }

    ddrval = restoreSurfaces(this_lcl->lpGbl->dsList, this_lcl);
    DPF(5, "RestoreAllSurfaces returns: %08x (%u)", ddrval, HRESULT_CODE(ddrval));
    LEAVE_DDRAW()

        return ddrval;
}

//=============================================================================
//
//  Function: BackupAllSurfaces
//
//  Backup all surfaces owned by the DirectDraw object.
//
//=============================================================================

void BackupAllSurfaces(LPDDRAWI_DIRECTDRAW_GBL this_gbl)
{
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;

    DPF(5, "BackupAllSurfaces: %08x", this_gbl);

    psurf_int = this_gbl->dsList;

    while (psurf_int)
    {
        if (!SURFACE_LOST(psurf_int->lpLcl) &&
            (psurf_int->lpLcl->lpSurfMore->lpDD_lcl->lpGbl == this_gbl) &&
            (psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
            (psurf_int->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_PERSISTENTCONTENTS))
        {
            DPF(5, "BackupSurfaceContents: %08x", psurf_int->lpLcl);
            BackupSurfaceContents(psurf_int->lpLcl);
        }

        psurf_int = psurf_int->lpLink;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddrawpr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawpr.h
 *  Content:    DirectDraw private header file
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   25-dec-94  craige  initial implementation
 *   06-jan-95  craige  video memory manager
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   31-jan-95  craige  and even more ongoing work...
 *   22-feb-95  craige  use critical sections on Win95
 *   27-feb-95  craige  new sync. macros
 *   03-mar-95  craige  WaitForVerticalBlank stuff
 *   06-mar-95  craige  HEL integration
 *   08-mar-95  craige  GetFourCCCodes
 *   11-mar-95  craige  palette stuff
 *   19-mar-95  craige  use HRESULTs
 *   20-mar-95  craige  new CSECT work
 *   23-mar-95  craige  attachment work
 *   26-mar-95  craige  added TMPALLOC and TMPFREE
 *   27-mar-95  craige  linear or rectangular vidmem
 *   28-mar-95  craige  switched to PALETTEENTRY from RGBQUAD
 *   29-mar-95  craige  debug memory manager; build.h; hacks for DLL
 *                      unload problem...
 *   31-mar-95  craige  use critical sections with palettes
 *   03-apr-95  craige  added MAKE_SURF_RECT
 *   04-apr-95  craige  added DD_GetPaletteEntries, DD_SetPaletteEntries
 *   06-apr-95  craige  split out process list stuff; fill in free vidmem
 *   12-apr-95  craige  add debugging to CSECT macros
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   14-may-95  craige  added DoneExclusiveMode, DD16_EnableReboot; cleaned out
 *                      obsolete junk
 *   23-may-95  craige  no longer use MapLS_Pool; added Flush, GetBatchLimit
 *                      and SetBatchLimit
 *   24-may-95  craige  added Restore
 *   28-may-95  craige  unicode support; cleaned up HAL: added GetBltStatus;
 *                      GetFlipStatus; GetScanLine
 *   02-jun-95  craige  added SetDisplayMode
 *   04-jun-95  craige  added AllocSurfaceMem, IsLost
 *   05-jun-95  craige  removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *                      change GarbageCollect to Compact
 *   06-jun-95  craige  added RestoreDisplayMode
 *   07-jun-95  craige  added StartExclusiveMode
 *   10-jun-95  craige  split out vmemmgr stuff
 *   13-jun-95  kylej   move FindAttachedFlip to misc.c, added CanBeFlippable
 *   18-jun-95  craige  specify pitch for rectangular heaps
 *   20-jun-95  craige  added DD16_InquireVisRgn; make retail builds
 *                      not bother to check for NULL (since there are 4
 *                      billion other invalid ptrs we don't check for...)
 *   21-jun-95  craige  new clipper stuff
 *   23-jun-95  craige  ATTACHED_PROCESSES stuff
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  replaced batch limit/flush stuff with BltBatch
 *   30-jun-95  kylej   function prototypes to support mult. prim. surfaces
 *   30-jun-95  craige  changed GET_PIXEL_FORMAT to use HASPIXELFORMAT flag
 *   01-jul-95  craige  hide composition & streaming stuff
 *   02-jul-95  craige  SEH macros; added DD16_ChangeDisplaySettings
 *   03-jul-95  kylej   Changed EnumSurfaces declaration
 *   03-jul-95  craige  YEEHAW: new driver struct; Removed GetProcessPrimary
 *   05-jul-95  craige  added Initialize fn to each object
 *   07-jul-95  craige  added some VALIDEX_xxx structs
 *   07-jul-95  kylej   proto XformRect, STRETCH_X and STRETCH_Y macros
 *   08-jul-95  craige  added FindProcessDDObject; added InvalidateAllSurfaces
 *   09-jul-95  craige  added debug output to win16 lock macro; added
 *                      ComputePitch, added hasvram flag to MoveToSystemMemory;
 *                      changed SetExclusiveMode to SetCooperativeLevel;
 *                      added ChangeToSoftwareColorKey
 *   10-jul-95  craige  support SetOverlayPosition
 *   13-jul-95  craige  ENTER_DDRAW is now the win16 lock;
 *                      Get/SetOverlayPosition takes LONGs
 *   13-jul-95  toddla  remove _export from thunk functions
 *   18-jul-95  craige  removed DD_Surface_Flush
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset
 *   28-jul-95  craige  go back to private DDRAW lock
 *   31-jul-95  craige  added DCIIsBanked
 *   01-aug-95  craige  added ENTER/LEAVE_BOTH; DOHALCALL_NOWIN16
 *   04-aug-95  craige  added InternalLock/Unlock
 *   10-aug-95  toddla  changed proto of EnumDisplayModes
 *   10-aug-95  toddla  added VALIDEX_DDSURFACEDESC_PTR
 *   12-aug-95  craige  added use_full_lock parm to MoveToSystemMemory and
 *                      ChangeToSoftwareColorKey
 *   13-aug-95  craige  flags parm for Flip
 *   21-aug-95  craige  mode X support
 *   27-aug-95  craige  bug 735: added SetPaletteAlways
 *                      bug 738: use GUID instead of IID
 *   02-sep-95  craige  bug 786: verify dwSize in retail
 *   04-sep-95  craige  bug 894: force flag to SetDisplayMode
 *   10-sep-95  toddla  added string ids
 *   21-sep-95  craige  bug 1215: added DD16_SetCertified
 *   11-nov-95  colinmc added new pointer validition macro for byte arrays
 *   27-nov-95  colinmc new member to return available vram of a given type
 *                      (defined by DDSCAPS)
 *   10-dec-95  colinmc added execute buffer support
 *   14-dec-95  colinmc added shared back and z-buffer support
 *   25-dec-95  craige  added class factory support
 *   31-dec-95  craige  added VALID_IID_PTR
 *   26-jan-96  jeffno  FlipToGDISurface now only takes 1 arg
 *   09-feb-96  colinmc local surface objects now have invalid surface flag
 *   12-feb-96  jeffno  Cheaper Mutex implementation for NT
 *   15-feb-96  jeffno  GETCURRENTPID needs to call HackCurrentPID on both 95 and NT
 *   17-feb-96  colinmc Removed dependency on Direct3D include files
 *   24-feb-96  colinmc Added prototype for new member which is used to
 *                      determine if the callback tables have already been
 *                      initialized.
 *   02-mar-96  colinmc Simply disgusting and temporary hack to keep
 *                      interim drivers working
 *   14-mar-96  colinmc Changes for the clipper class factory
 *   17-mar-96  colinmc Bug 13124: flippable mip-maps
 *   20-mar-96  colinmc Bug 13634: unidirectional attachments cause infinite
 *                      loop on cleanup
 *   22-mar-96  colinmc Bug 13316: Uninitialized interfaces
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   10-apr-96  colinmc Bug 16903: HEL using obsolete FindProcessDDObject
 *   13-apr-96  colinmc Bug 17736: No driver notifcation of flip to GDI
 *   15-apr-96  colinmc Bug 16885: Can't pass NULL to initialize in C++
 *   16-apr-96  colinmc Bug 17921: Remove interim driver support
 *   26-mar-96  jeffno  Removed cheap mutexes. Added check for mode change for NT's
 *                      ENTERDDRAW.
 *   29-apr-96  colinmc Bug 19954: Must query for Direct3D before texture or
 *                      device interface
 *   11-may-96  colinmc Bug 22293: New macro to validate GUID even if not
 *                      in debug
 *   17-may-96  kylej   Bug 23301: validate DDHALINFO size >= current size
 *   28-jul-96  colinmc Bug 2613:  Minimal support for secondary (stacked)
 *                                 drivers.
 *   16-aug-96  craige  include ddreg.h, added dwRegFlags + flag defns
 *   03-sep-96  craige  added app compat stuff.
 *   23-sep-96  ketand  added InternalGetClipList
 *   01-oct-96  ketand  added TIMING routings
 *   05-oct-96  colinmc Work Item: Remove requirement on taking Win16 lock
 *                      for VRAM surfaces (not primary)
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   09-nov-96  colinmc Fixed problem with old and new drivers not working
 *                      with DirectDraw
 *   17-nov-96  colinmc New ref flag to control the enabling and disabling
 *                      of PrintScreen
 *   02-jan-97  colinmc Initial AGP implementation work
 *   12-jan-97  colinmc More Win16 lock work
 *   13-jan-97 jvanaken Basic support for IDirectDrawSurface3 interface
 *   18-jan-97  colinmc AGP VMM support
 *   21-jan-97  ketand  Change DD16_SetPaletteEntries for multi-mon. Deleted
 *                      unused code.
 *   26-jan-97  ketand  Remove unused DD16_GetPaletteEntries. (It didn't handle
 *                      multi-mon; and wasn't worth fixing.) Also, remove
 *                      globals that don't work anymore with multi-mon.
 *   30-jan-97  colinmc Work item 4125: Need time bomb for final
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *   02-feb-97  toddla  pass driver name to DD16_GetMonitor functions
 *                      added DD16_GetDeviceConfig
 *   02-feb-97  colinmc Bug 5625: V1.0 DirectX drivers don't get recognized
 *                      due to bad size check on DDCALLBACKS
 *   05-feb-97  ketand  Remove unused parameter from ClipRgnToRect
 *   22-feb-97  colinmc Enabled OWNDC for explicit system memory surfaces
 *   03-mar-97  smac    Added kernel mode interface
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   04-mar-97  ketand  Added UpdateOutstandingDC to track palette changes
 *   08-mar-97  colinmc Added support for DMA style AGP parts
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   22-mar-97  colinmc Bug 6673: Add compile time option to allow new
 *                      applications to run against legacy run times.
 *   23-mar-97  colinmc Bug 6673 again: Changed structure numbering scheme
 *                      for consistency's sake
 *   24-mar-97  jeffno  Optimized Surfaces
 *   07-may-97  colinmc Moved AGP support detection from misc.c to ddagp.c
 *   30-sep-97  jeffno  IDirectDraw4
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   26-nov-97 t-craigs Added IDirectDrawPalette2
 *   19-dec-97 jvanaken IDDS4::Unlock now takes a pointer to a rectangle.
 *
 ***************************************************************************/

#ifndef __DDRAWPR_INCLUDED__
#define __DDRAWPR_INCLUDED__

#ifdef WIN95

#ifdef WINNT
#undef WINNT
#endif

#endif

#ifndef WIN95
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#endif

#ifdef WIN95
    #define WIN16_SEPARATE
#endif
#include "verinfo.h"

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <mmsystem.h>

#if defined( WIN95 ) && !defined ( NT_BUILD_ENVIRONMENT )
#undef PBT_APMRESUMEAUTOMATIC
    #include <pbt.h>
#endif

//#ifdef NT_BUILD_ENVIRONMENT
    /*
     * These are various definitions brought over from the win95 world, just to get us
     * compiling under the NT headers.
     */
    #ifdef WIN32
        /*
         * These come from \proj\dev\sdk\inc\winbase.h
         */
        #define FILE_FLAG_GLOBAL_HANDLE         0x00800000  // ;internal
        VOID    // ;internal
        WINAPI  // ;internal
        ReinitializeCriticalSection(    // ;internal
            LPCRITICAL_SECTION lpCriticalSection        // ;internal
            );  // ;internal

       //
       // Windows 9x stuff
       //

       #define CDS_EXCLUSIVE       0x80000000
       #define DISPLAY_DEVICE_VGA  0x00000010
       #define DCX_USESTYLE        0x00010000

    #endif //IS_32


    /*
     * These two come from \proj\dev\msdev\include\pbt.h
     */
    #define PBT_APMSUSPEND                  0x0004
    #define PBT_APMSTANDBY                  0x0005

//#endif //NT_BUILD_ENVIRONMENT

#include <string.h>
#include <stddef.h>

#if defined( IS_32 ) || defined( WIN32 ) || defined( _WIN32 )
    #undef IS_32
    #define IS_32
    #pragma pack(1)
    #include <dibeng.inc>
    #pragma pack()
    #ifndef HARDWARECURSOR
        //#pragma message("defining local version of HARDWARECURSOR")
        #define HARDWARECURSOR 0x0100 // new post-Win95 deFlag
    #endif
#else
    #define IID void
#endif

#pragma warning( disable: 4704)

#include "dpf.h"

/*
 * registry stuff
 */
#include "ddreg.h"

/*
 * application compat. stuff
 */
#define DDRAW_APPCOMPAT_MODEXONLY           0x00000001l
#define DDRAW_APPCOMPAT_NODDSCAPSINDDSD     0x00000002l
#define DDRAW_APPCOMPAT_MMXFORRGB           0x00000004l
#define DDRAW_APPCOMPAT_EXPLICITMONITOR     0x00000008l
#define DDRAW_APPCOMPAT_SCREENSAVER         0x00000010l
#define DDRAW_APPCOMPAT_FORCEMODULATED      0x00000020l
#define DDRAW_APPCOMPAT_TEXENUMINCL_0       0x00000040l  // two bit field
#define DDRAW_APPCOMPAT_TEXENUMINCL_1       0x00000080l
#define DDRAW_APPCOMPAT_TEXENUMLIMIT        0x00000100l
#define DDRAW_APPCOMPAT_SKIPWHEELMSG        0x00000200l // Win98 only
#define DDRAW_APPCOMPAT_TEXENUMDX7FOURCC    0x00000400l
#define DDRAW_APPCOMPAT_VALID               0x000007ffl

#define DDRAW_REGFLAGS_MODEXONLY        0x00000001l
#define DDRAW_REGFLAGS_EMULATIONONLY    0x00000002l
#define DDRAW_REGFLAGS_SHOWFRAMERATE    0x00000004l
#define DDRAW_REGFLAGS_ENABLEPRINTSCRN  0x00000008l
#define DDRAW_REGFLAGS_FORCEAGPSUPPORT  0x00000010l
#define DDRAW_REGFLAGS_DISABLEMMX       0x00000020l
#define DDRAW_REGFLAGS_DISABLEWIDESURF  0x00000040l
#define DDRAW_REGFLAGS_AGPPOLICYMAXBYTES 0x00000200l
#define DDRAW_REGFLAGS_FORCEREFRESHRATE 0x00008000l
#ifdef DEBUG
    #define DDRAW_REGFLAGS_DISABLENOSYSLOCK  0x00000080l
    #define DDRAW_REGFLAGS_FORCENOSYSLOCK    0x00000100l
#endif
#define DDRAW_REGFLAGS_NODDSCAPSINDDSD  0x00000400l
#define DDRAW_REGFLAGS_DISABLEAGPSUPPORT 0x00000800l
#ifdef DEBUG
    #define DDRAW_REGFLAGS_DISABLEINACTIVATE 0x00001000l
    #define DDRAW_REGFLAGS_PREGUARD          0x00002000l
    #define DDRAW_REGFLAGS_POSTGUARD         0x00004000l
#endif
#define DDRAW_REGFLAGS_USENONLOCALVIDMEM    0x00010000l

#define DDRAW_REGFLAGS_ENUMERATEATTACHEDSECONDARIES 0x00008000l
#define DDRAW_REGFLAGS_FLIPNONVSYNC         0x00020000l

extern  DWORD dwRegFlags;

#include "memalloc.h"

#if defined( IS_32 ) || defined( WIN32 ) || defined( _WIN32 )
    #include <objbase.h>
#else
    #define IUnknown void
#endif
#include "ddrawi.h"
#include "dwininfo.h"

#ifdef WIN95
    #include "..\ddraw16\modex.h"
#endif

/*
 * Need this to get CDS_ macros under NT build environment for win95.
 * winuserp.h comes from private\windows\inc
 */
#ifdef NT_BUILD_ENVIRONMENT
    #ifdef WIN32
        #include "winuserp.h"
    #endif
#endif
#include "ids.h"

/*
 * NT kernel mode stub(ish)s
 */
#ifndef WIN95
    #include "ddrawgdi.h"
#endif

/*
 * Driver version info
 */

//========================================================================
// advanced driver information
//========================================================================
typedef struct tagDDDRIVERINFOEX
{
        DDDEVICEIDENTIFIER      di;
        char                    szDeviceID[MAX_DDDEVICEID_STRING];
} DDDRIVERINFOEX, * LPDDDRIVERINFOEX;



/*
 * Direct3D interfacing defines.
 */
#ifndef NO_D3D
#include "ddd3dapi.h"
#endif
#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN95
    #define USE_CRITSECTS
    extern void DDAPI DD16_SetEventHandle( DWORD hInstance, DWORD dwEvent );
    extern void DDAPI DD16_DoneDriver( DWORD hInstance );
    extern void DDAPI DD16_GetDriverFns( LPDDHALDDRAWFNS list );
    extern void DDAPI DD16_GetHALInfo( LPDDHALINFO pinfo );
    extern LONG DDAPI DD16_ChangeDisplaySettings( LPDEVMODE pdm, DWORD flags);
    extern HRGN DDAPI DD16_InquireVisRgn( HDC );
    extern void DDAPI DD16_SelectPalette( HDC, HPALETTE, BOOL );
    extern BOOL DDAPI DD16_SetPaletteEntries( HDC hdc, DWORD dwBase, DWORD dwNum, LPPALETTEENTRY, BOOL fPrimary );
    extern void DDAPI DD16_EnableReboot( BOOL );
    extern void DDAPI DD16_SetCertified( BOOL iscert );
    extern BOOL DDAPI DCIIsBanked( HDC hdc );
    #define GETCURRPID HackGetCurrentProcessId
    VOID WINAPI MakeCriticalSectionGlobal( CSECT_HANDLE lpcsCriticalSection );

    extern HDC  DDAPI DD16_GetDC(HDC hdc, LPDDSURFACEDESC pddsd, LPPALETTEENTRY lpPalette);
    extern void DDAPI DD16_ReleaseDC(HDC hdc);
    extern BOOL DDAPI DD16_SafeMode(HDC hdc, BOOL fSafeMode);

    extern void DDAPI DD16_Exclude(DWORD dwPDevice, RECTL FAR *prcl);
    extern void DDAPI DD16_Unexclude(DWORD dwPDevice);

    extern int DDAPI DD16_Stretch(DWORD DstPtr, int DstPitch, UINT DstBPP, int DstX, int DstY, int DstDX, int DstDY,
                       DWORD SrcPtr, int SrcPitch, UINT SrcBPP, int SrcX, int SrcY, int SrcDX, int SrcDY);
    extern BOOL DDAPI DD16_IsWin95MiniDriver( void );
    extern int  DDAPI DD16_GetMonitorMaxSize(LPSTR szDevice);
    extern BOOL DDAPI DD16_GetMonitorRefreshRateRanges(LPSTR szDevice, int xres, int yres, int FAR *pmin, int FAR *pmax);
    extern DWORD DDAPI DD16_GetDeviceConfig(LPSTR szDevice, LPVOID lpConfig, DWORD size);
    extern BOOL DDAPI DD16_GetMonitorEDIDData(LPSTR szDevice, LPVOID lpEdidData);
    extern DWORD DDAPI DD16_GetRateFromRegistry( LPSTR szDevice );
    extern int DDAPI DD16_SetRateInRegistry( LPSTR szDevice, DWORD dwRateToRestore );

    #ifdef USE_ALIAS
        extern BOOL DDAPI DD16_FixupDIBEngine( void );
    #endif /* USE_ALIAS */
    extern WORD DDAPI DD16_MakeObjectPrivate(HDC hdc, BOOL fPrivate);
    extern BOOL DDAPI DD16_AttemptGamma(HDC hdc);
    extern BOOL DDAPI DD16_IsDeviceBusy(HDC hdc);

#else
    #define DD16_DoneDriver( hInstance ) 0
    #define DD16_GetDriverFns( list ) 0
    #define DD16_GetHALInfo( pinfo ) 0
    #define DD16_ChangeDisplaySettings( pdm, flags) ChangeDisplaySettings( pdm, flags )
    #define DD16_SelectPalette( hdc, hpal ) SelectPalette( hdc, hpal, FALSE )
    #define DD16_EnableReboot( retboot ) 0
    #define DD16_WWOpen( ptr ) 0
    #define DD16_WWClose( ptr, newlist ) 0
    #define DD16_WWNotifyInit( pww, lpcallback, param ) 0
    #define DD16_WWGetClipList( pww, prect, rdsize, prd ) 0
    //
    // On NT, it is an assert that we are never called by DDHELP, so we should always be
    // working on the current process.
    //
    #define GETCURRPID GetCurrentProcessId
    #define DCIIsBanked( hdc ) FALSE
    #define DD16_IsWin95MiniDriver() TRUE
    #define DD16_SetCertified( iscert ) 0
    #define DD16_GetMonitorMaxSize(dev) 0
    #define DD16_GetMonitorRefreshRateRanges( dev, xres, yres, pmin, pmax) 0
    #define DD16_GetRateFromRegistry( szDevice ) 0
    #define DD16_SetRateInRegistry( szDevice, dwRateToRestore ) 0
    #ifdef USE_ALIAS
        #define DD16_FixupDIBEngine() TRUE
    #endif /* USE_ALIAS */
    #define DD16_AttemptGamma( hdc) 0
    #define DD16_IsDeviceBusy( hdc) 0
#endif

#ifndef NO_DDHELP
    #include "w95help.h"
#endif //NO_DDHELP

#define TRY             _try
#define EXCEPT(a)       _except( a )

extern LPDDRAWI_DDRAWCLIPPER_INT lpGlobalClipperList;

/*
 * list of processes attached to DLL
 */
typedef struct ATTACHED_PROCESSES
{
    struct ATTACHED_PROCESSES   *lpLink;
    DWORD                       dwPid;
#ifdef WINNT
    DWORD                       dwNTToldYet;
#endif
} ATTACHED_PROCESSES, FAR *LPATTACHED_PROCESSES;

//extern LPATTACHED_PROCESSES   lpAttachedProcesses;

/* Structure for keeping track of DCs that have
 * been handed out by DDraw for surfaces.
 */
typedef struct _dcinfo
{
    HDC hdc;                            // HDC associated with surface
    LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl; // Surface associated with HDC
    struct _dcinfo * pdcinfoNext;       // Pointer to next
} DCINFO, *LPDCINFO;
/*
 *  Head of the list of DCs handed out.
 */
extern DCINFO *g_pdcinfoHead;

/*
 * macros for doing allocations of a temporary basis.
 * Tries alloca first, if that fails, it will allocate storage from the heap
 */
#ifdef USEALLOCA
    #define TMPALLOC( ptr, size ) \
            ptr = _alloca( (size)+sizeof( DWORD ) ); \
            if( ptr == NULL ) \
            { \
                ptr = MemAlloc( (size)+sizeof( DWORD ) ); \
                if( ptr != NULL ) \
                { \
                    *(DWORD *)ptr = 1; \
                    (LPSTR) ptr += sizeof( DWORD ); \
                } \
            } \
            else \
            { \
                *(DWORD *)ptr = 0; \
                (LPSTR) ptr += sizeof( DWORD ); \
            }

    #define TMPFREE( ptr ) \
            if( ptr != NULL ) \
            { \
                (LPSTR) ptr -= sizeof( DWORD ); \
                if( (*(DWORD *) ptr) ) \
                { \
                    MemFree( ptr ); \
                } \
            }
#else

    #define TMPALLOC( ptr, size )  ptr = MemAlloc( size );
    #define TMPFREE( ptr )  MemFree( ptr );

#endif

/*
 * macros for getting at values that aren't always present in the surface
 * object
 */
#define GET_PIXEL_FORMAT( thisx, thisl, pddpf ) \
    if( thisx->dwFlags & DDRAWISURF_HASPIXELFORMAT ) \
    { \
        pddpf = &thisl->ddpfSurface; \
    } \
    else \
    { \
        pddpf = &thisl->lpDD->vmiData.ddpfDisplay; \
    }

/*
 * macro for building a rectangle that is the size of a surface.
 * For multi-monitor systems, we have a different code path
 * to deal with the fact that the upper-left coord may not be zero.
 */
#define MAKE_SURF_RECT( surf, surf_lcl, r ) \
    r.top = 0;                  \
    r.left = 0;                 \
    r.bottom = (DWORD) surf->wHeight; \
    r.right = (DWORD) surf->wWidth;

/*
 * macro for doing doing HAL call.
 *
 * Takes the Win16 lock for 32-bit Win95 driver routines.  This serves a
 * 2-fold purpose:
 *      1) keeps the 16-bit portion of the driver safe
 *      2) 32-bit routine needs lock others out while its updating
 *         its hardware
 */
#if defined( WIN95 ) && defined( WIN16_SEPARATE )
    #define DOHALCALL( halcall, fn, data, rc, isHEL ) \
        if( (fn != _DDHAL_##halcall) && !isHEL ) { \
            ENTER_WIN16LOCK(); \
            rc = fn( &data ); \
            LEAVE_WIN16LOCK(); \
        } else { \
            rc = fn( &data ); \
        }

    #define DOHALCALL_NOWIN16( halcall, fn, data, rc, isHEL ) \
            rc = fn( &data );
#else
    #define DOHALCALL( halcall, fn, data, rc, isHEL ) \
            if (fn) \
                rc = fn( &data );\
            else\
                rc = DDHAL_DRIVER_NOTHANDLED;
    #define DOHALCALL_NOWIN16( halcall, fn, data, rc, isHEL ) \
            if (fn) \
                rc = fn( &data );\
            else\
                rc = DDHAL_DRIVER_NOTHANDLED;
#endif


/*
 * macro for incrementing/decrementing the driver ref count
 */
#define CHANGE_GLOBAL_CNT( pdrv, thisg, cnt ) \
    if( !(thisg->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED) ) \
    { \
        (int) pdrv->dwSurfaceLockCount += (int) (cnt); \
    }


/*
 * reminder
 */
#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str

/*
 * maximum timeout (in ms) when spinlocked on a surface
 */
#define MAX_TIMEOUT     5000

/*
 * defined in dllmain.c
 */
extern CSECT_HANDLE     lpDDCS;
#ifdef WINNT
    extern HANDLE hDriverObjectListMutex;
    extern DWORD dwNumLockedWhenModeSwitched;
#else
    #ifdef IS_32
        extern CRITICAL_SECTION csDriverObjectList;
    #endif
#endif
#define MAX_TIMER_HWNDS 15
extern HWND ghwndTopmostList[MAX_TIMER_HWNDS];
extern int giTopmostCnt;
extern BOOL bGammaCalibratorExists;
extern BYTE szGammaCalibrator[MAX_PATH];
extern DWORD dwForceRefreshRate;

/*
 * blt flags
 */
#define DDBLT_PRIVATE_ALIASPATTERN      0x80000000l

/*
 * get the fail code based on what HAL and HEL support; used by BLT
 *
 * assumes variables halonly, helonly, fail are defined
 */
#define GETFAILCODEBLT( testhal, testhel, halonly, helonly, flag ) \
    if( halonly ) { \
        if( !(testhal & flag) ) { \
            fail = TRUE; \
        } \
    } else if( helonly ) { \
        if( !(testhel & flag) ) { \
            fail = TRUE; \
        } \
    } else { \
        if( !(testhal & flag) ) { \
            if( !(testhel & flag) ) { \
                fail = TRUE; \
            } else { \
                helonly = TRUE; \
            } \
        } else { \
            halonly = TRUE; \
        } \
    }

/*
 * get the fail code based on what HAL and HEL support
 *
 * assumes variables halonly, helonly, fail are defined
 */
#define GETFAILCODE( testhal, testhel, flag ) \
    if( halonly ) \
    { \
        if( !(testhal & flag) ) \
        { \
            fail = TRUE; \
        } \
    } \
    else if( helonly ) \
    { \
        if( !(testhel & flag) ) \
        { \
            fail = TRUE; \
        } \
    } \
    else \
    { \
        if( !(testhal & flag) ) \
        { \
            if( !(testhel & flag) ) \
            { \
                fail = TRUE; \
            } \
            else \
            { \
                helonly = TRUE; \
            } \
        } \
        else \
        { \
            halonly = TRUE; \
        } \
    }


typedef struct {
    DWORD               src_height;
    DWORD               src_width;
    DWORD               dest_height;
    DWORD               dest_width;
    BOOL                halonly;
    BOOL                helonly;
    LPDDHALSURFCB_BLT   bltfn;
    LPDDHALSURFCB_BLT   helbltfn;
} SPECIAL_BLT_DATA, FAR *LPSPECIAL_BLT_DATA;

/*
 * synchronization
 */
#ifdef WINNT
#define RELEASE_EXCLUSIVEMODE_MUTEX                             \
    {                                                           \
        if (hExclusiveModeMutex)                                \
        {                                                       \
            BOOL bSucceed = ReleaseMutex(hExclusiveModeMutex);  \
            if (!bSucceed)                                      \
            {                                                   \
                DPF_ERR("Release Exclusive Mutex Failed. App "  \
                        "should not release Exclusive Mode on " \
                        "different thread than it was taken."); \
            }                                                   \
        }                                                       \
    }
#else
    #define RELEASE_EXCLUSIVEMODE_MUTEX ;
#endif


//--------------------------------- new cheap mutexes -------------------------------------------
//
// Global Critical Sections have two components. One piece is shared between all
// applications using the global lock. This portion will typically reside in some
// sort of shared memory
//
// The second piece is per-process. This contains a per-process handle to the shared
// critical section lock semaphore. The semaphore is itself shared, but each process
// may have a different handle value to the semaphore.
//
// Global critical sections are attached to by name. The application wishing to
// attach must know the name of the critical section (actually the name of the shared
// lock semaphore, and must know the address of the global portion of the critical
// section
//

typedef struct _GLOBAL_SHARED_CRITICAL_SECTION {
    LONG LockCount;
    LONG RecursionCount;
    DWORD OwningThread;
    DWORD OwningProcess;
    DWORD Reserved;
} GLOBAL_SHARED_CRITICAL_SECTION, *PGLOBAL_SHARED_CRITICAL_SECTION;

typedef struct _GLOBAL_LOCAL_CRITICAL_SECTION {
    PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion;
    HANDLE LockSemaphore;
    DWORD Reserved1;
    DWORD Reserved2;
} GLOBAL_LOCAL_CRITICAL_SECTION, *PGLOBAL_LOCAL_CRITICAL_SECTION;

/*
 * The following functions are defined in mutex.c
 */
BOOL
WINAPI
AttachToGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion,
    PGLOBAL_SHARED_CRITICAL_SECTION lpGlobalPortion,
    LPCSTR lpName
    );
BOOL
WINAPI
DetachFromGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    );
VOID
WINAPI
EnterGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    );
VOID
WINAPI
LeaveGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    );
void
DestroyPIDsLock(
                PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion,
                DWORD                           dwPid,
                LPSTR                           lpName
    );


#define DDRAW_FAST_CS_NAME "DdrawGlobalFastCrit"
extern GLOBAL_LOCAL_CRITICAL_SECTION CheapMutexPerProcess;
extern GLOBAL_SHARED_CRITICAL_SECTION CheapMutexCrossProcess;

#define CHEAP_LEAVE {LeaveGlobalCriticalSection(&CheapMutexPerProcess);}
#define CHEAP_ENTER {EnterGlobalCriticalSection(&CheapMutexPerProcess);}

#ifdef WINNT
//    #define USE_CHEAP_MUTEX
#define NT_USES_CRITICAL_SECTION
#endif

extern void ModeChangedOnENTERDDRAW(void); // in ddmodent.c
extern ULONG uDisplaySettingsUnique;

//
#ifdef IS_32
    #ifndef USE_CRITSECTS
        #define INIT_DDRAW_CSECT()
        #define FINI_DDRAW_CSECT()
        #define ENTER_DDRAW()
        #define LEAVE_DDRAW()
        #define ENTER_DRIVERLISTCSECT()
        #define LEAVE_DRIVERLISTCSECT()
    #else //so use csects:
        #ifdef DEBUG
            //extern int iWin16Cnt;
            //extern int iDLLCSCnt;
            #define INCCSCNT() iDLLCSCnt++;
            #define DECCSCNT() iDLLCSCnt--;
            #define INCW16CNT() iWin16Cnt++;
            #define DECW16CNT() iWin16Cnt--;
        #else
            #define INCCSCNT()
            #define DECCSCNT()
            #define INCW16CNT()
            #define DECW16CNT()
        #endif //debug

        #ifdef WINNT
                extern HANDLE hDirectDrawMutex; //def'd in dllmain.c
                #ifdef USE_CHEAP_MUTEX
                    //--------------------------------- new cheap mutexes -------------------------------------------
                        #define ENTER_DDRAW() {CHEAP_ENTER;}
                        #define ENTER_DDRAW_INDLLMAIN() CHEAP_ENTER
                        #define LEAVE_DDRAW() CHEAP_LEAVE
                    #define INIT_DDRAW_CSECT()                                                                     \
                        {                                                                                          \
                            if (!AttachToGlobalCriticalSection(&CheapMutexPerProcess,&CheapMutexCrossProcess,DDRAW_FAST_CS_NAME) )  \
                                {DPF(0,"===================== Mutex Creation FAILED =================");}          \
                        }

                    #define FINI_DDRAW_CSECT() {DetachFromGlobalCriticalSection(&CheapMutexPerProcess);}

                #else

                    #ifdef NT_USES_CRITICAL_SECTION
                        //
                        // Use critical sections
                        //
                        #define INIT_DDRAW_CSECT() InitializeCriticalSection( lpDDCS );

                        #define FINI_DDRAW_CSECT() DeleteCriticalSection( lpDDCS );

                        extern DWORD gdwRecursionCount;

                        #define ENTER_DDRAW() \
                                {                                                                   \
                                    DWORD dwUniqueness;                                             \
                                    EnterCriticalSection( (LPCRITICAL_SECTION) lpDDCS );            \
                                    gdwRecursionCount++;                                            \
                                    dwUniqueness = DdQueryDisplaySettingsUniqueness();              \
                                    if (dwUniqueness != uDisplaySettingsUnique &&                   \
                                        1 == gdwRecursionCount)                                     \
                                    {                                                               \
                                        ModeChangedOnENTERDDRAW();                                  \
                                        uDisplaySettingsUnique = dwUniqueness;                      \
                                    }                                                               \
                                }

                        #define ENTER_DDRAW_INDLLMAIN() \
                                    EnterCriticalSection( (LPCRITICAL_SECTION) lpDDCS );            \
                                    gdwRecursionCount++;

                        #define LEAVE_DDRAW() { gdwRecursionCount--; LeaveCriticalSection( (LPCRITICAL_SECTION) lpDDCS );}


                    #else
                        //
                        // Use a mutex object.
                        //

                        #define INIT_DDRAW_CSECT()                                                      \
                            { if (hDirectDrawMutex) {DPF(0,"Direct draw mutex initialised twice!");}    \
                              else{                                                                     \
                                hDirectDrawMutex = CreateMutex(NULL,FALSE,"DirectDrawMutexName");       \
                                if (!hDirectDrawMutex) {DPF(0,"===================== Mutex Creation FAILED =================");}\
                                }      \
                            }

                        extern DWORD gdwRecursionCount;
                        #define FINI_DDRAW_CSECT() { if (hDirectDrawMutex) CloseHandle(hDirectDrawMutex); }
                        #define LEAVE_DDRAW() { gdwRecursionCount--;ReleaseMutex(hDirectDrawMutex); }
                        #define ENTER_DDRAW()                                                       \
                                {                                                                   \
                                    DWORD dwUniqueness,dwWaitValue;                                 \
                                    dwWaitValue = WaitForSingleObject(hDirectDrawMutex,INFINITE);   \
                                    gdwRecursionCount++;                                            \
                                    dwUniqueness = DdQueryDisplaySettingsUniqueness();              \
                                    if (dwUniqueness != uDisplaySettingsUnique &&                   \
                                        1 == gdwRecursionCount)                                     \
                                    {                                                               \
                                        ModeChangedOnENTERDDRAW();                                  \
                                        uDisplaySettingsUnique = dwUniqueness;                      \
                                    }                                                               \
                                }
                        #define ENTER_DDRAW_INDLLMAIN() WaitForSingleObject(hDirectDrawMutex,INFINITE);
                    #endif //use (expensive) mutexes
                #endif //use_cheap_mutex

                #define ENTER_DRIVERLISTCSECT() \
                        WaitForSingleObject(hDriverObjectListMutex,INFINITE);
                #define LEAVE_DRIVERLISTCSECT() \
                        ReleaseMutex(hDriverObjectListMutex);

        #else //not winnt:
            #ifdef WIN16_SEPARATE
                #define INIT_DDRAW_CSECT() \
                        ReinitializeCriticalSection( lpDDCS ); \
                        MakeCriticalSectionGlobal( lpDDCS );

                #define FINI_DDRAW_CSECT() \
                        DeleteCriticalSection( lpDDCS );

                #define ENTER_DDRAW() \
                        DPF( 7, "*****%08lx ENTER_DDRAW: CNT = %ld," REMIND( "" ), GETCURRPID(), iDLLCSCnt ); \
                        EnterCriticalSection( (LPCRITICAL_SECTION) lpDDCS ); \
                        INCCSCNT(); \
                        DPF( 7, "*****%08lx GOT DDRAW CSECT: CNT = %ld," REMIND(""), GETCURRPID(), iDLLCSCnt );

                #define LEAVE_DDRAW() \
                        DECCSCNT() \
                        DPF( 7, "*****%08lx LEAVE_DDRAW: CNT = %ld," REMIND( "" ), GETCURRPID(), iDLLCSCnt ); \
                        LeaveCriticalSection( (LPCRITICAL_SECTION) lpDDCS );

            #else //not WIN16_SEPARATE

                #define INIT_DDRAW_CSECT()
                #define FINI_DDRAW_CSECT()
                #define ENTER_DDRAW()   \
                            DPF( 7, "*****%08lx ENTER_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                            _EnterSysLevel( lpWin16Lock ); \
                            INCW16CNT(); \
                            DPF( 7, "*****%08lx GOT WIN16LOCK: CNT = %ld," REMIND(""), GETCURRPID(), iWin16Cnt );
                #define LEAVE_DDRAW() \
                            DECW16CNT() \
                            DPF( 7, "*****%08lx LEAVE_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                            _LeaveSysLevel( lpWin16Lock );

            #endif //win16_separate
            #define ENTER_DRIVERLISTCSECT() \
                        EnterCriticalSection( &csDriverObjectList );

            #define LEAVE_DRIVERLISTCSECT() \
                        LeaveCriticalSection( &csDriverObjectList );
        #endif  //winnt
    #endif //use csects

    extern DWORD gdwSetIME; // from ddraw.c
    // This macro is used to show/hide the IME outside of the ddraw critsect
    #define HIDESHOW_IME()                                          \
            if (gdwSetIME)                                          \
            {                                                       \
                SystemParametersInfo(                               \
                    SPI_SETSHOWIMEUI, gdwSetIME - 1, NULL, 0);      \
                                                                    \
                InterlockedExchange(&gdwSetIME, 0);                 \
            }

    #if defined(WIN95)
        /*
         * selector management functions
         */
        extern DWORD _stdcall MapLS( LPVOID );  // flat -> 16:16
        extern void _stdcall UnMapLS( DWORD ); // unmap 16:16
        extern LPVOID _stdcall MapSLFix( DWORD ); // 16:16->flat
        extern LPVOID _stdcall MapSL( DWORD ); // 16:16->flat
        //extern void _stdcall UnMapSLFix( LPVOID ); // 16:16->flat
        /*
         * win16 lock
         */
        extern void _stdcall    GetpWin16Lock( LPVOID FAR *);
        extern void _stdcall    _EnterSysLevel( LPVOID );
        extern void _stdcall    _LeaveSysLevel( LPVOID );
        extern LPVOID           lpWin16Lock;
    #endif win95
#endif //is_32

#ifdef WIN95
    #ifdef WIN16_SEPARATE
        #define ENTER_WIN16LOCK()       \
                    DPF( 7, "*****%08lx ENTER_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                    _EnterSysLevel( lpWin16Lock ); \
                    INCW16CNT(); \
                    DPF( 7, "*****%08lx GOT WIN16LOCK: CNT = %ld," REMIND(""), GETCURRPID(), iWin16Cnt );
        #define LEAVE_WIN16LOCK()       \
                    DECW16CNT() \
                    DPF( 7,"*****%08lx LEAVE_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                    _LeaveSysLevel( lpWin16Lock );
    #else
        #define ENTER_WIN16LOCK()       badbadbad
        #define LEAVE_WIN16LOCK()       badbadbad
    #endif
#else
    #define ENTER_WIN16LOCK()
    #define LEAVE_WIN16LOCK()
#endif

#ifdef WIN16_SEPARATE
    #define ENTER_BOTH() \
            ENTER_DDRAW(); \
            ENTER_WIN16LOCK();

    #define LEAVE_BOTH() \
            LEAVE_WIN16LOCK(); \
            LEAVE_DDRAW();
#else
    #define ENTER_BOTH() \
            ENTER_DDRAW();
    #define LEAVE_BOTH() \
            LEAVE_DDRAW();
#endif

/* We now have a special case in dllmain on NT... */
#ifndef ENTER_DDRAW_INDLLMAIN
    #define ENTER_DDRAW_INDLLMAIN() ENTER_DDRAW()
#endif

#ifdef WIN95

    /*
     * DDHELP's handle for communicating with the DirectSound VXD. We need this
     * when we are executing DDRAW code with one of DDHELP's threads.
     */
    extern HANDLE hHelperDDVxd;

    /*
     * Macro to return the DirectSound VXD handle to use when communicating with
     * the VXD. This is necessary as we need to communicate with the VXD from
     * DirectDraw executing on a DDHELP thread. In which case we need to use
     * the VXD handle defined above (which is the VXD handle DDHELP got when it
     * loaded DDRAW.VXD). Otherwise, we use the VXD handle out of the given
     * local object.
     *
     * NOTE: We don't use GETCURRPID() or HackGetCurrentProcessId() as we want
     * the real PID not one that has been munged.
     */
    #define GETDDVXDHANDLE( pdrv_lcl ) \
        ( ( GetCurrentProcessId() == ( pdrv_lcl )->dwProcessId ) ? (HANDLE) ( ( pdrv_lcl )->hDDVxd ) : hHelperDDVxd )

#else  /* !WIN95 */

    #define GETDDVXDHANDLE( pdrv_lcl ) NULL

#endif /* !WIN95 */

#define VDPF(Args) DPF Args
#include "ddheap.h"
#include "ddagp.h"
/* apphack.c */
extern void FreeAppHackData(void);


/* cliprgn.h */
extern void ClipRgnToRect( LPRECT prect, LPRGNDATA prd );

/* ddcsurf.c */
extern BOOL isPowerOf2(DWORD dw, int* pPower);
extern HRESULT checkSurfaceDesc( LPDDSURFACEDESC2 lpsd, LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD FAR *psflags, BOOL emulation, BOOL real_sysmem, LPDDRAWI_DIRECTDRAW_INT pdrv_int );
extern DWORD ComputePitch( LPDDRAWI_DIRECTDRAW_GBL thisg, DWORD caps, DWORD width, UINT bpp );
extern DWORD GetBytesFromPixels( DWORD pixels, UINT bpp );
extern HRESULT createsurfaceEx(LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl);
#ifdef WINNT
extern BOOL WINAPI CompleteCreateSysmemSurface(LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl);
#endif
// modified and moved to dx8priv.h
// extern HRESULT InternalCreateSurface( LPDDRAWI_DIRECTDRAW_LCL thisg, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *lplpDDSurface, LPDDRAWI_DIRECTDRAW_INT this_int );

extern HRESULT AllocSurfaceMem( LPDDRAWI_DIRECTDRAW_LCL this_lcl, LPDDRAWI_DDRAWSURFACE_LCL *slist, int nsurf );
#ifdef DEBUG
    void SurfaceSanityTest( LPDDRAWI_DIRECTDRAW_LCL pdrv, LPSTR title );
    #define SURFSANITY( a,b ) SurfaceSanityTest( a, b );
#else
    #define SURFSANITY( a,b )
#endif

/* ddclip.c */
extern HRESULT InternalCreateClipper( LPDDRAWI_DIRECTDRAW_GBL lpDD, DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter, BOOL fInitialized, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DIRECTDRAW_INT pdrv_int );
void ProcessClipperCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

/* ddcreate.c */
extern BOOL IsVGADevice(LPSTR szDevice);
extern char g_szPrimaryDisplay[];
extern BOOL xxxEnumDisplayDevicesA(LPVOID lpUnused, DWORD iDevice, struct _DISPLAY_DEVICEA *pdd, DWORD dwFlags);
extern BOOL CurrentProcessCleanup( BOOL );
extern LPHEAPALIGNMENT GetExtendedHeapAlignment( LPDDRAWI_DIRECTDRAW_GBL pddd , LPDDHAL_GETHEAPALIGNMENTDATA pghad, int iHeap);
extern void RemoveDriverFromList( LPDDRAWI_DIRECTDRAW_INT lpDD, BOOL );
extern void RemoveLocalFromList( LPDDRAWI_DIRECTDRAW_LCL lpDD_lcl );
extern LPDDRAWI_DIRECTDRAW_GBL DirectDrawObjectCreate( LPDDHALINFO lpDDHALInfo, BOOL reset, LPDDRAWI_DIRECTDRAW_GBL pdrv, HANDLE hDDVxd, char *szDrvName, DWORD dwDriverContext, DWORD dwLocalFlags );
extern LPDDRAWI_DIRECTDRAW_GBL FetchDirectDrawData( LPDDRAWI_DIRECTDRAW_GBL pdrv, BOOL reset, DWORD hInstance, HANDLE hDDVxd, char *szDrvName, DWORD dwDriverContext, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern LPVOID NewDriverInterface( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPVOID lpvtbl );
extern DWORD DirectDrawMsg(LPSTR msg);
extern BOOL DirectDrawSupported( BOOL bDisplayMessage );
extern BOOL IsMultiMonitor( void );
extern LPDDRAWI_DIRECTDRAW_GBL fetchModeXData(LPDDRAWI_DIRECTDRAW_GBL pdrv,LPDDHALMODEINFO pmi, HANDLE hDDVxd );

#ifdef WINNT
extern BOOL GetCurrentMode(LPDDRAWI_DIRECTDRAW_GBL, LPDDHALINFO lpHalInfo, char *szDrvName);
extern HRESULT GetNTDeviceRect( LPSTR pDriverName, LPRECT lpRect );
extern void CheckAliasedLocksOnModeChange( void );
extern void NotifyDriverOfFreeAliasedLocks( void );
extern void NotifyDriverToDeferFrees( void );
#endif

extern HDC  DD_CreateDC(LPSTR pdrvname);
extern void DD_DoneDC(HDC hdc);

#ifdef IS_32
extern LONG xxxChangeDisplaySettingsExA(LPCSTR szDevice, LPDEVMODEA pdm, HWND hwnd, DWORD dwFlags,LPVOID lParam);

// modified and moved to dx8priv.h
//extern HRESULT InternalDirectDrawCreate( GUID * lpGUID, LPDIRECTDRAW *lplpDD, LPDDRAWI_DIRECTDRAW_INT pnew_int, DWORD dwFlags );

extern void UpdateRectFromDevice( LPDDRAWI_DIRECTDRAW_GBL pdrv );
extern void UpdateAllDeviceRects( void );
#endif

/* ddiunk.c */
extern HRESULT InitD3D( LPDDRAWI_DIRECTDRAW_INT this_int );
extern HRESULT InitDDrawPrivateD3DContext( LPDDRAWI_DIRECTDRAW_INT this_int );

/* dddefwp.c */
extern HRESULT SetAppHWnd( LPDDRAWI_DIRECTDRAW_LCL thisg, HWND hWnd, DWORD dwFlags );
extern VOID CleanupWindowList( DWORD pid );
extern void ClipTheCursor(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPRECT lpRect);

/* ddesurf.c */
extern void FillDDSurfaceDesc( LPDDRAWI_DDRAWSURFACE_LCL psurf, LPDDSURFACEDESC lpdsd );
extern void FillDDSurfaceDesc2( LPDDRAWI_DDRAWSURFACE_LCL psurf, LPDDSURFACEDESC2 lpdsd );
extern void FillEitherDDSurfaceDesc( LPDDRAWI_DDRAWSURFACE_LCL psurf, LPDDSURFACEDESC2 lpdsd );

/* ddfake.c */
extern BOOL getBitMask( LPDDHALMODEINFO pmi );
extern LPDDRAWI_DIRECTDRAW_GBL FakeDDCreateDriverObject( HDC hdc_dd, LPSTR szDrvName, LPDDRAWI_DIRECTDRAW_GBL, BOOL reset, HANDLE hDDVxd );
extern DWORD BuildModes( LPSTR szDevice, LPDDHALMODEINFO FAR *ppddhmi );
extern void BuildPixelFormat(HDC, LPDDHALMODEINFO, LPDDPIXELFORMAT);

/* ddpal.c */
extern void ResetSysPalette( LPDDRAWI_DDRAWSURFACE_GBL psurf, BOOL dofree );
extern void ProcessPaletteCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern ULONG DDAPI InternalPaletteRelease( LPDDRAWI_DDRAWPALETTE_INT this_int );
extern HRESULT SetPaletteAlways( LPDDRAWI_DDRAWSURFACE_INT psurf_int, LPDIRECTDRAWPALETTE lpDDPalette );

/* ddraw.c */
extern void DoneExclusiveMode( LPDDRAWI_DIRECTDRAW_LCL pdrv );
extern void StartExclusiveMode( LPDDRAWI_DIRECTDRAW_LCL pdrv, DWORD dwFlags, DWORD pid );
extern HRESULT FlipToGDISurface( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_INT psurf_int); //, FLATPTR fpprim );
extern void CheckExclusiveMode(LPDDRAWI_DIRECTDRAW_LCL this_lcl, LPBOOL pbExclusiveExists, LPBOOL pbThisLclOwnsExclusive, BOOL bKeepMutex, HWND hwnd, BOOL bCanGetIt);

/* ddsacc.c */
void WINAPI AcquireDDThreadLock(void);
void WINAPI ReleaseDDThreadLock(void);
extern void RemoveProcessLocks( LPDDRAWI_DIRECTDRAW_LCL pdrv, LPDDRAWI_DDRAWSURFACE_LCL this_lcl, DWORD pid );
extern HRESULT InternalLock( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID *pbits,
                             LPRECT lpDestRect, DWORD dwFlags);
extern HRESULT InternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID lpSurfaceData, LPRECT lpDestRect, DWORD dwFlags );
#ifdef USE_ALIAS
    extern void BreakSurfaceLocks( LPDDRAWI_DDRAWSURFACE_GBL thisg );
#endif /* USE_ALIAS */

/* ddsatch.c */
extern void UpdateMipMapCount( LPDDRAWI_DDRAWSURFACE_INT psurf_int );
extern HRESULT AddAttachedSurface( LPDDRAWI_DDRAWSURFACE_INT psurf_from, LPDDRAWI_DDRAWSURFACE_INT psurf_to, BOOL implicit );
extern void DeleteAttachedSurfaceLists( LPDDRAWI_DDRAWSURFACE_LCL psurf );
#define DOA_DONTDELETEIMPLICIT FALSE
#define DOA_DELETEIMPLICIT     TRUE
extern HRESULT DeleteOneAttachment( LPDDRAWI_DDRAWSURFACE_INT this_int, LPDDRAWI_DDRAWSURFACE_INT pattsurf_int, BOOL cleanup, BOOL delete_implicit );
extern HRESULT DeleteOneLink( LPDDRAWI_DDRAWSURFACE_INT this_int, LPDDRAWI_DDRAWSURFACE_INT pattsurf_int );

/* ddsblt.c */
extern void WaitForDriverToFinishWithSurface(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_LCL this_lcl );
extern LPDDRAWI_DDRAWSURFACE_LCL FindAttached( LPDDRAWI_DDRAWSURFACE_LCL ptr, DWORD caps );
extern HRESULT XformRect(RECT * prcSrc,RECT * prcDest,RECT * prcClippedDest,RECT * prcClippedSrc,DWORD scale_x,DWORD scale_y);
// SCALE_X and SCALE_Y are fixed point variables scaled 16.16. These macros used by calls to XformRect.
#define SCALE_X(rcSrc,rcDest) ( ((rcSrc.right - rcSrc.left) << 16) / (rcDest.right - rcDest.left))
#define SCALE_Y(rcSrc,rcDest) ( ((rcSrc.bottom - rcSrc.top) << 16) / (rcDest.bottom - rcDest.top))

/* ddsckey.c */
extern HRESULT CheckColorKey( DWORD dwFlags, LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDCOLORKEY lpDDColorKey, LPDWORD psflags, BOOL halonly, BOOL helonly );
extern HRESULT ChangeToSoftwareColorKey( LPDDRAWI_DDRAWSURFACE_INT this_int, BOOL );

/* ddsiunk.c */
extern LPDDRAWI_DDRAWSURFACE_LCL NewSurfaceLocal( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID lpvtbl );
extern LPDDRAWI_DDRAWSURFACE_INT NewSurfaceInterface( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID lpvtbl );
extern void DestroySurface( LPDDRAWI_DDRAWSURFACE_LCL thisg );
extern void LooseManagedSurface( LPDDRAWI_DDRAWSURFACE_LCL thisg );
extern DWORD InternalSurfaceRelease( LPDDRAWI_DDRAWSURFACE_INT this_int, BOOL bLightweight, BOOL bDX8 );
extern void ProcessSurfaceCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern void FreeD3DSurfaceIUnknowns( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

/* ddmode.c */
extern HRESULT SetDisplayMode( LPDDRAWI_DIRECTDRAW_LCL thisx, DWORD modeidx, BOOL force, BOOL useRefreshRate );
extern HRESULT RestoreDisplayMode( LPDDRAWI_DIRECTDRAW_LCL thisx, BOOL force );
extern void AddModeXModes( LPDDRAWI_DIRECTDRAW_GBL pdrv );
extern BOOL MonitorCanHandleMode(LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD width, DWORD height, WORD refreshRate );
extern BOOL GetDDStereoMode( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD dwWidth, DWORD dwHeight, DWORD dwBpp, DWORD dwRefreshRate);

/* ddsurf.c */
extern HRESULT InternalGetBltStatus(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_LCL this_lcl , DWORD dwFlags );
extern HRESULT MoveToSystemMemory( LPDDRAWI_DDRAWSURFACE_INT this_int, BOOL hasvram, BOOL use_full_lock );
extern void InvalidateAllPrimarySurfaces( LPDDRAWI_DIRECTDRAW_GBL );
extern LPDDRAWI_DDRAWSURFACE_GBL FindGlobalPrimary( LPDDRAWI_DIRECTDRAW_GBL );
extern BOOL MatchPrimary( LPDDRAWI_DIRECTDRAW_GBL thisg, LPDDSURFACEDESC2 lpDDSD );
extern void InvalidateAllSurfaces( LPDDRAWI_DIRECTDRAW_GBL thisg, HANDLE hDDVxd, BOOL fRebuildAliases );
#ifdef SHAREDZ
extern LPDDRAWI_DDRAWSURFACE_GBL FindGlobalZBuffer( LPDDRAWI_DIRECTDRAW_GBL );
extern LPDDRAWI_DDRAWSURFACE_GBL FindGlobalBackBuffer( LPDDRAWI_DIRECTDRAW_GBL );
extern BOOL MatchSharedZBuffer( LPDDRAWI_DIRECTDRAW_GBL thisg, LPDDSURFACEDESC lpDDSD );
extern BOOL MatchSharedBackBuffer( LPDDRAWI_DIRECTDRAW_GBL thisg, LPDDSURFACEDESC lpDDSD );
#endif
extern HRESULT InternalPageLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern HRESULT InternalPageUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

extern LPDDRAWI_DDRAWSURFACE_INT getDDSInterface( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID lpddcb );

extern HRESULT InternalGetDC( LPDDRAWI_DDRAWSURFACE_INT this_int, HDC FAR *lphdc
#ifdef WIN95
        , BOOL bWin16Lock
#endif  //WIN95
        );
extern HRESULT InternalReleaseDC( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, HDC hdc
#ifdef WIN95
        , BOOL bWin16Lock
#endif  //WIN95
        );
extern HRESULT EXTERN_DDAPI GetSurfaceFromDC( HDC hdc, LPDIRECTDRAWSURFACE *ppdds, HDC *phdcDriver );
extern HRESULT InternalAssociateDC( HDC hdc, LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl );
extern HRESULT InternalRemoveDCFromList( HDC hdc, LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl );

// ddgdi32.c
#ifdef WIN95
extern void CleanupD3D8( LPDDRAWI_DIRECTDRAW_GBL pdrv, BOOL bDestroyAll, DWORD PID);
#endif

// function from ddsprite.c to clean pid from master sprite list:
void ProcessSpriteCleanup(LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid);

#ifdef WIN95
extern void UpdateOutstandingDC( LPDDRAWI_DDRAWSURFACE_LCL psurf_lcl, LPDDRAWI_DDRAWPALETTE_GBL ppal_gbl );
extern void UpdateDCOnPaletteChanges( LPDDRAWI_DDRAWPALETTE_GBL ppal_gbl );
#else
#define UpdateOutstandingDC(x,y)
#define UpdateDCOnPaletteChanges(x)
#endif


#ifdef USE_ALIAS
    /* ddalias.c */
    extern HRESULT CreateHeapAliases( HANDLE hvxd, LPDDRAWI_DIRECTDRAW_GBL pdrv );
    extern BOOL    ReleaseHeapAliases( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );
    extern HRESULT MapHeapAliasesToVidMem( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );
    extern HRESULT MapHeapAliasesToDummyMem( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );
    extern FLATPTR GetAliasedVidMem( LPDDRAWI_DIRECTDRAW_LCL   pdrv,
                                     LPDDRAWI_DDRAWSURFACE_LCL surf_lcl,
                                     FLATPTR                   fpVidMem );
#endif /* USE_ALIAS */

/* dllmain.c */
extern BOOL RemoveProcessFromDLL( DWORD pid );

/* misc.c */
extern BOOL CanBeFlippable( LPDDRAWI_DDRAWSURFACE_LCL thisg, LPDDRAWI_DDRAWSURFACE_LCL this_attach);
extern LPDDRAWI_DDRAWSURFACE_INT FindAttachedFlip( LPDDRAWI_DDRAWSURFACE_INT thisg );
extern LPDDRAWI_DDRAWSURFACE_INT FindAttachedSurfaceLeft( LPDDRAWI_DDRAWSURFACE_INT thisg );
extern LPDDRAWI_DDRAWSURFACE_INT FindAttachedMipMap( LPDDRAWI_DDRAWSURFACE_INT thisg );
extern LPDDRAWI_DDRAWSURFACE_INT FindParentMipMap( LPDDRAWI_DDRAWSURFACE_INT thisg );
#ifdef WIN95
    extern HANDLE GetDXVxdHandle( void );
#endif /* WIN95 */

/* ddcallbk.c */
extern void InitCallbackTables( void );
extern BOOL CallbackTablesInitialized( void );

/* ddvp.c */
extern void ProcessVideoPortCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern HRESULT InternalStopVideo( LPDDRAWI_DDVIDEOPORT_INT this_int );
extern LPDDRAWI_DDVIDEOPORT_LCL GetVideoPortFromSurface( LPDDRAWI_DDRAWSURFACE_INT surf_int );
extern DWORD IsValidAutoFlipSurface( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int );
#define IVAS_NOAUTOFLIPPING             0
#define IVAS_SOFTWAREAUTOFLIPPING       1
#define IVAS_HARDWAREAUTOFLIPPING       2
extern VOID RequireSoftwareAutoflip( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int );
extern VOID SetRingZeroSurfaceData( LPDDRAWI_DDRAWSURFACE_LCL lpSurface_lcl );
extern DWORD FlipVideoPortSurface( LPDDRAWI_DDRAWSURFACE_INT , DWORD );
extern VOID OverrideOverlay( LPDDRAWI_DDRAWSURFACE_INT lpSurf_int, LPDWORD lpdwFlags );
extern BOOL MustSoftwareBob( LPDDRAWI_DDRAWSURFACE_INT lpSurf_int );
extern VOID RequireSoftwareBob( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int );
extern VOID DecrementRefCounts( LPDDRAWI_DDRAWSURFACE_INT surf_int );

/* ddcolor.c */
extern VOID ReleaseColorControl( LPDDRAWI_DDRAWSURFACE_LCL lpSurface );

/* ddgamma.c */
extern VOID ReleaseGammaControl( LPDDRAWI_DDRAWSURFACE_LCL lpSurface );
extern BOOL SetGamma( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern VOID RestoreGamma( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern VOID InitGamma( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPSTR szDrvName );

/* ddkernel.c */
extern HRESULT InternalReleaseKernelSurfaceHandle( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, BOOL bLosingSurface );
extern HRESULT InternalCreateKernelSurfaceHandle( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, PULONG_PTR lpHandle );
extern HRESULT UpdateKernelSurface( LPDDRAWI_DDRAWSURFACE_LCL lpSurface );
extern HRESULT UpdateKernelVideoPort( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwFlags );
extern HRESULT GetKernelFieldNum( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, LPDWORD lpdwFieldNum );
extern HRESULT SetKernelFieldNum( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwFieldNum );
extern HRESULT SetKernelSkipPattern( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwStartField, DWORD dwPatternSize, DWORD dwPattern );
extern HRESULT InitKernelInterface( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern HRESULT GetKernelSurfaceState( LPDDRAWI_DDRAWSURFACE_LCL lpSurf, LPDWORD lpdwStateFlags );
extern HRESULT ReleaseKernelInterface( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern BOOL CanSoftwareAutoflip( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort );
extern BOOL IsKernelInterfaceSupported( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern HRESULT SetKernelDOSBoxEvent( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern VOID EnableAutoflip( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, BOOL bEnable );
extern BOOL IsWindows98( VOID );

/* ddmc.c */
extern BOOL IsMotionCompSupported( LPDDRAWI_DIRECTDRAW_LCL this_lcl );
extern void ProcessMotionCompCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

/* private.c */
extern void FreeAllPrivateData(LPPRIVATEDATANODE * ppListHead);

/* factory.c */
extern HRESULT InternalCreateDDFactory2(void **, IUnknown * pUnkOuter);

// ddrestor.c
extern HRESULT AllocSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern void FreeSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern HRESULT BackupSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern HRESULT RestoreSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern void BackupAllSurfaces(LPDDRAWI_DIRECTDRAW_GBL this_gbl);
extern void MungeAutoflipCaps(LPDDRAWI_DIRECTDRAW_GBL pdrv);

/* ddrefrsh.c */
extern HRESULT DDGetMonitorInfo( LPDDRAWI_DIRECTDRAW_INT lpDD_int);
extern void MassageModeTable(LPDDRAWI_DIRECTDRAW_GBL);
extern HRESULT ExpandModeTable( LPDDRAWI_DIRECTDRAW_GBL pddd );
extern BOOL CanMonitorHandleRefreshRate( LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD dwWidth, DWORD dwHeight, int wRefresh );

/* drvinfo.c */
extern BOOL Voodoo1GoodToGo( GUID * pGuid );
extern HRESULT InternalGetDeviceIdentifier7( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER2 pDI, DWORD dwFlags, BOOL bWHQL);


/* A handy one from ddhel.c */
/* DDRAW16 doesn't need this. */
#ifdef WIN32
    SCODE InitDIB(HDC hdc, LPBITMAPINFO lpbmi);
#endif
void ResetBITMAPINFO(LPDDRAWI_DIRECTDRAW_GBL thisg);
BOOL doPixelFormatsMatch(LPDDPIXELFORMAT lpddpf1,
                                LPDDPIXELFORMAT lpddpf2);
HRESULT ConvertToPhysColor(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl, LPDDARGB pSource, LPDWORD pdwPhysColor);
HRESULT ConvertFromPhysColor(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl, LPDWORD pdwPhysColor, LPDDARGB pDest);
extern DWORD GetSurfPFIndex(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl);
extern DWORD GetDxtBlkSize(DWORD dwFourCC);

/*
 * HEL's public memory allocator
 */
extern void HELFreeSurfaceSysMem(LPDDRAWI_DDRAWSURFACE_LCL lpsurf_lcl);
extern LPVOID HELAllocateSurfaceSysMem(LPDDRAWI_DDRAWSURFACE_LCL lpsurf_lcl, DWORD nWidth,
                                DWORD nHeight, LPDWORD lpdwSurfaceSize, LPLONG lpSurfPitch );
#ifndef NO_DDHELP
    /* w95hack.c */
    extern DWORD HackGetCurrentProcessId( void );
    extern BOOL DDAPI DDNotify( LPDDHELPDATA phd );
    extern void DDAPI DDNotifyModeSet( LPDDRAWI_DIRECTDRAW_GBL );
    extern void DDAPI DDNotifyDOSBox( LPDDRAWI_DIRECTDRAW_GBL );
#endif //NO_DDHELP

#ifdef POSTPONED
/* Delegating IUnknown functions */
extern HRESULT EXTERN_DDAPI DD_DelegatingQueryInterface(LPDIRECTDRAW, REFIID, LPVOID FAR *);
extern DWORD EXTERN_DDAPI DD_DelegatingAddRef( LPDIRECTDRAW lpDD );
extern DWORD EXTERN_DDAPI DD_DelegatingRelease( LPDIRECTDRAW lpDD );
#endif

/* DirectDrawFactory2 functions */
extern HRESULT EXTERN_DDAPI DDFac2_QueryInterface(LPDIRECTDRAWFACTORY2, REFIID, LPVOID FAR *);
extern DWORD EXTERN_DDAPI DDFac2_AddRef( LPDIRECTDRAWFACTORY2 lpDDFac );
extern ULONG EXTERN_DDAPI DDFac2_Release( LPDIRECTDRAWFACTORY2 lpDDFac );
extern HRESULT EXTERN_DDAPI DDFac2_CreateDirectDraw(LPDIRECTDRAWFACTORY2, GUID FAR *, HWND, DWORD dwCoopLevelFlags, DWORD, IUnknown *, struct IDirectDraw4 ** );
#ifdef IS_32
#ifdef SM_CMONITORS
    extern HRESULT EXTERN_DDAPI DDFac2_DirectDrawEnumerate(LPDIRECTDRAWFACTORY2 , LPDDENUMCALLBACKEX , LPVOID  , DWORD );
#else
    /*
     * This def'n is a hack to keep us building under NT build which doesn't have the
     * multimon headers in it yet
     */
    extern HRESULT EXTERN_DDAPI DDFac2_DirectDrawEnumerate(LPDIRECTDRAWFACTORY2 , LPDDENUMCALLBACK , LPVOID  , DWORD );
#endif
#endif

/* DIRECTDRAW functions */
extern HRESULT EXTERN_DDAPI DD_UnInitedQueryInterface( LPDIRECTDRAW lpDD, REFIID riid, LPVOID FAR * ppvObj );
extern HRESULT EXTERN_DDAPI DD_QueryInterface( LPDIRECTDRAW lpDD, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_AddRef( LPDIRECTDRAW lpDD );
extern DWORD   EXTERN_DDAPI DD_Release( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_Compact( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_CreateClipper( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_CreatePalette( LPDIRECTDRAW lpDD, DWORD dwFlags, LPPALETTEENTRY lpDDColorTable, LPDIRECTDRAWPALETTE FAR *lplpDDPalette, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_CreateSurface( LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_CreateSurface4( LPDIRECTDRAW lpDD, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_DuplicateSurface( LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSurface, LPDIRECTDRAWSURFACE FAR *lplpDupDDSurface );
extern HRESULT EXTERN_DDAPI DD_EnumDisplayModes( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMMODESCALLBACK lpEnumModesCallback );
extern HRESULT EXTERN_DDAPI DD_EnumDisplayModes4( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMMODESCALLBACK2 lpEnumModesCallback );
extern HRESULT EXTERN_DDAPI DD_EnumSurfaces( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpEnumCallback );
extern HRESULT EXTERN_DDAPI DD_EnumSurfaces4( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMSURFACESCALLBACK2 lpEnumCallback );
extern HRESULT EXTERN_DDAPI DD_FlipToGDISurface( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_GetCaps( LPDIRECTDRAW lpDD, LPDDCAPS lpDDDriverCaps, LPDDCAPS lpHELCaps );
extern HRESULT EXTERN_DDAPI DD_GetColorKey( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_GetDisplayMode( LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpSurfaceDesc );
extern HRESULT EXTERN_DDAPI DD_GetFourCCCodes(LPDIRECTDRAW,DWORD FAR *,DWORD FAR *);
extern HRESULT EXTERN_DDAPI DD_GetGDISurface( LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE FAR * );
extern HRESULT EXTERN_DDAPI DD_GetScanLine( LPDIRECTDRAW lpDD, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_GetVerticalBlankStatus( LPDIRECTDRAW lpDD, BOOL FAR * );
extern HRESULT EXTERN_DDAPI DD_Initialize(LPDIRECTDRAW, GUID FAR *);
extern HRESULT EXTERN_DDAPI DD_SetColorKey( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_SetCooperativeLevel(LPDIRECTDRAW,HWND,DWORD);
extern HRESULT EXTERN_DDAPI DD_SetDisplayMode(LPDIRECTDRAW,DWORD,DWORD,DWORD);
extern HRESULT EXTERN_DDAPI DD_SetDisplayMode2(LPDIRECTDRAW,DWORD,DWORD,DWORD,DWORD,DWORD);
extern HRESULT EXTERN_DDAPI DD_RestoreDisplayMode(LPDIRECTDRAW);
extern HRESULT EXTERN_DDAPI DD_GetMonitorFrequency( LPDIRECTDRAW lpDD, LPDWORD lpdwFrequency);
extern HRESULT EXTERN_DDAPI DD_WaitForVerticalBlank( LPDIRECTDRAW lpDD, DWORD dwFlags, HANDLE hEvent );
extern HRESULT EXTERN_DDAPI DD_GetAvailableVidMem( LPDIRECTDRAW lpDD, LPDDSCAPS lpDDSCaps, LPDWORD lpdwTotal, LPDWORD lpdwFree );
extern HRESULT EXTERN_DDAPI DD_GetAvailableVidMem4( LPDIRECTDRAW lpDD, LPDDSCAPS2 lpDDSCaps, LPDWORD lpdwTotal, LPDWORD lpdwFree );
extern HRESULT EXTERN_DDAPI DD_GetSurfaceFromDC( LPDIRECTDRAW lpDD, HDC, LPDIRECTDRAWSURFACE *);
extern HRESULT EXTERN_DDAPI DD_RestoreAllSurfaces( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_GetDeviceIdentifier( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER, DWORD);
extern HRESULT EXTERN_DDAPI DD_GetDeviceIdentifier7( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER2, DWORD);
extern HRESULT EXTERN_DDAPI DD_StartModeTest( LPDIRECTDRAW7 lpDD, LPSIZE lpModesToTest, DWORD dwNumEntries, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_EvaluateMode( LPDIRECTDRAW7 lpDD, DWORD dwFlags, DWORD *pSecondsUntilTimeout);
#ifdef IS_32
    //streaming stuff confuses ddraw16
    #ifndef __cplusplus
        extern HRESULT EXTERN_DDAPI DD_CreateSurfaceFromStream( LPDIRECTDRAW4 lpDD, IStream *, LPDDSURFACEDESC2, DWORD, LPDIRECTDRAWSURFACE4 *, IUnknown *);
        extern HRESULT EXTERN_DDAPI DD_CreateSurfaceFromFile( LPDIRECTDRAW4 lpDD, BSTR, LPDDSURFACEDESC2, DWORD, LPDIRECTDRAWSURFACE4 *, IUnknown *);
    #endif
#endif
extern HRESULT EXTERN_DDAPI DD_CreateOptSurface( LPDIRECTDRAW, LPDDOPTSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *pUnkOuter);
extern HRESULT EXTERN_DDAPI DD_ListOptSurfaceGUIDS(LPDIRECTDRAW, DWORD *, LPGUID);
extern HRESULT EXTERN_DDAPI DD_CanOptimizeSurface(LPDIRECTDRAW, LPDDSURFACEDESC2, LPDDOPTSURFACEDESC, BOOL FAR *);
extern HRESULT EXTERN_DDAPI DD_TestCooperativeLevel(LPDIRECTDRAW);

/* DIRECTDRAWPALETTE functions */
extern HRESULT EXTERN_DDAPI DD_Palette_QueryInterface( LPDIRECTDRAWPALETTE lpDDPalette, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_Palette_AddRef( LPDIRECTDRAWPALETTE lpDDPalette );
extern DWORD   EXTERN_DDAPI DD_Palette_Release( LPDIRECTDRAWPALETTE lpDDPalette );
extern HRESULT EXTERN_DDAPI DD_Palette_GetCaps( LPDIRECTDRAWPALETTE lpDDPalette, LPDWORD lpdwFlags );
extern HRESULT EXTERN_DDAPI DD_Palette_Initialize( LPDIRECTDRAWPALETTE, LPDIRECTDRAW lpDD, DWORD dwFlags, LPPALETTEENTRY lpDDColorTable );
extern HRESULT EXTERN_DDAPI DD_Palette_SetEntries( LPDIRECTDRAWPALETTE lpDDPalette, DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpEntries );
extern HRESULT EXTERN_DDAPI DD_Palette_GetEntries( LPDIRECTDRAWPALETTE lpDDPalette, DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpEntries );
extern HRESULT EXTERN_DDAPI DD_Palette_SetPrivateData( LPDIRECTDRAWPALETTE, REFIID, LPVOID, DWORD, DWORD);
extern HRESULT EXTERN_DDAPI DD_Palette_GetPrivateData( LPDIRECTDRAWPALETTE, REFIID, LPVOID, LPDWORD);
extern HRESULT EXTERN_DDAPI DD_Palette_FreePrivateData( LPDIRECTDRAWPALETTE, REFIID );
extern HRESULT EXTERN_DDAPI DD_Palette_GetUniquenessValue( LPDIRECTDRAWPALETTE, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_Palette_ChangeUniquenessValue( LPDIRECTDRAWPALETTE );
extern HRESULT EXTERN_DDAPI DD_Palette_IsEqual( LPDIRECTDRAWPALETTE, LPDIRECTDRAWPALETTE );


/* DIRECTDRAWCLIPPER functions */
extern HRESULT EXTERN_DDAPI DD_UnInitedClipperQueryInterface( LPDIRECTDRAWCLIPPER lpDD, REFIID riid, LPVOID FAR * ppvObj );
extern HRESULT EXTERN_DDAPI DD_Clipper_QueryInterface( LPVOID lpDDClipper, REFIID riid, LPVOID FAR * ppvObj );
extern ULONG   EXTERN_DDAPI DD_Clipper_AddRef( LPVOID lpDDClipper );
extern ULONG   EXTERN_DDAPI DD_Clipper_Release( LPVOID lpDDClipper );
extern HRESULT EXTERN_DDAPI DD_Clipper_GetClipList( LPDIRECTDRAWCLIPPER, LPRECT, LPRGNDATA, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_Clipper_GetHWnd(LPDIRECTDRAWCLIPPER,HWND FAR *);
extern HRESULT EXTERN_DDAPI DD_Clipper_Initialize( LPDIRECTDRAWCLIPPER, LPDIRECTDRAW lpDD, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_Clipper_IsClipListChanged(LPDIRECTDRAWCLIPPER,BOOL FAR *);
extern HRESULT EXTERN_DDAPI DD_Clipper_SetClipList(LPDIRECTDRAWCLIPPER,LPRGNDATA, DWORD);
extern HRESULT EXTERN_DDAPI DD_Clipper_SetHWnd(LPDIRECTDRAWCLIPPER, DWORD, HWND );
extern HRESULT EXTERN_DDAPI DD_Clipper_SetNotificationCallback(LPDIRECTDRAWCLIPPER, DWORD,LPCLIPPERCALLBACK, LPVOID);

/* Private DIRECTDRAWCLIPPER functions */
extern HRESULT InternalGetClipList( LPDIRECTDRAWCLIPPER lpDDClipper, LPRECT lpRect, LPRGNDATA lpClipList, LPDWORD lpdwSize, LPDDRAWI_DIRECTDRAW_GBL pdrv);

/* DIRECTDRAWSURFACE functions */
extern HRESULT EXTERN_DDAPI DD_Surface_QueryInterface( LPVOID lpDDSurface, REFIID riid, LPVOID FAR * ppvObj );
extern ULONG   EXTERN_DDAPI DD_Surface_AddRef( LPVOID lpDDSurface );
extern ULONG   EXTERN_DDAPI DD_Surface_Release( LPVOID lpDDSurface );
extern HRESULT EXTERN_DDAPI DD_Surface_AddAttachedSurface(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_Surface_AddOverlayDirtyRect(LPDIRECTDRAWSURFACE, LPRECT);
extern HRESULT EXTERN_DDAPI DD_Surface_AlphaBlt(LPDIRECTDRAWSURFACE, LPRECT, LPDIRECTDRAWSURFACE, LPRECT, DWORD, LPDDALPHABLTFX);
extern HRESULT EXTERN_DDAPI DD_Surface_Blt(LPDIRECTDRAWSURFACE,LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX);
extern HRESULT EXTERN_DDAPI DD_Surface_BltFast(LPDIRECTDRAWSURFACE,DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_BltBatch( LPDIRECTDRAWSURFACE, LPDDBLTBATCH, DWORD, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_ChangeUniquenessValue( LPDIRECTDRAWSURFACE );
extern HRESULT EXTERN_DDAPI DD_Surface_DeleteAttachedSurfaces(LPDIRECTDRAWSURFACE, DWORD,LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_Surface_EnumAttachedSurfaces(LPDIRECTDRAWSURFACE,LPVOID, LPDDENUMSURFACESCALLBACK );
extern HRESULT EXTERN_DDAPI DD_Surface_EnumOverlayZOrders(LPDIRECTDRAWSURFACE,DWORD,LPVOID,LPDDENUMSURFACESCALLBACK);
extern HRESULT EXTERN_DDAPI DD_Surface_Flip(LPDIRECTDRAWSURFACE,LPDIRECTDRAWSURFACE, DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_FreePrivateData(LPDIRECTDRAWSURFACE, REFIID);
extern HRESULT EXTERN_DDAPI DD_Surface_GetAttachedSurface(LPDIRECTDRAWSURFACE,LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *);
extern HRESULT EXTERN_DDAPI DD_Surface_GetAttachedSurface4(LPDIRECTDRAWSURFACE4,LPDDSCAPS2, LPDIRECTDRAWSURFACE4 FAR *);
extern HRESULT EXTERN_DDAPI DD_Surface_GetAttachedSurface7(LPDIRECTDRAWSURFACE7,LPDDSCAPS2, LPDIRECTDRAWSURFACE7 FAR *);
extern HRESULT EXTERN_DDAPI DD_Surface_GetBltStatus(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetCaps( LPDIRECTDRAWSURFACE lpDDSurface, LPDDSCAPS lpDDSCaps );
extern HRESULT EXTERN_DDAPI DD_Surface_GetCaps4( LPDIRECTDRAWSURFACE lpDDSurface, LPDDSCAPS2 lpDDSCaps );
extern HRESULT EXTERN_DDAPI DD_Surface_GetClipper( LPDIRECTDRAWSURFACE, LPDIRECTDRAWCLIPPER FAR * );
extern HRESULT EXTERN_DDAPI DD_Surface_GetColorKey( LPDIRECTDRAWSURFACE lpDDSurface, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_Surface_GetDC( LPDIRECTDRAWSURFACE, HDC FAR * );
extern HRESULT EXTERN_DDAPI DD_Surface_GetDDInterface(LPDIRECTDRAWSURFACE lpDDSurface, LPVOID FAR *lplpDD );
extern HRESULT EXTERN_DDAPI DD_Surface_GetOverlayPosition( LPDIRECTDRAWSURFACE, LPLONG, LPLONG );
extern HRESULT EXTERN_DDAPI DD_Surface_GetPalette(LPDIRECTDRAWSURFACE,LPDIRECTDRAWPALETTE FAR*);
extern HRESULT EXTERN_DDAPI DD_Surface_GetPixelFormat(LPDIRECTDRAWSURFACE, LPDDPIXELFORMAT);
extern HRESULT EXTERN_DDAPI DD_Surface_GetPrivateData(LPDIRECTDRAWSURFACE, REFIID, LPVOID, LPDWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetSurfaceDesc(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC);
extern HRESULT EXTERN_DDAPI DD_Surface_GetSurfaceDesc4(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC2);
extern HRESULT EXTERN_DDAPI DD_Surface_GetFlipStatus(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetUniquenessValue( LPDIRECTDRAWSURFACE, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_Initialize( LPDIRECTDRAWSURFACE, LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpDDSurfaceDesc);
extern HRESULT EXTERN_DDAPI DD_Surface_IsLost( LPDIRECTDRAWSURFACE lpDDSurface );
extern HRESULT EXTERN_DDAPI DD_Surface_Lock(LPDIRECTDRAWSURFACE,LPRECT,LPDDSURFACEDESC lpDDSurfaceDesc, DWORD, HANDLE hEvent );
extern HRESULT EXTERN_DDAPI DD_Surface_PageLock(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_PageUnlock(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_ReleaseDC(LPDIRECTDRAWSURFACE,HDC );
#ifdef POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_Resize(LPDIRECTDRAWSURFACE,DWORD,DWORD,DWORD);
#endif //POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_Restore( LPDIRECTDRAWSURFACE lpDDSurface );
extern HRESULT EXTERN_DDAPI DD_Surface_SetBltOrder(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_SetClipper( LPDIRECTDRAWSURFACE, LPDIRECTDRAWCLIPPER );
extern HRESULT EXTERN_DDAPI DD_Surface_SetColorKey( LPDIRECTDRAWSURFACE lpDDSurface, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_Surface_SetOverlayPosition( LPDIRECTDRAWSURFACE, LONG, LONG );
extern HRESULT EXTERN_DDAPI DD_Surface_SetPalette(LPDIRECTDRAWSURFACE,LPDIRECTDRAWPALETTE);
extern HRESULT EXTERN_DDAPI DD_Surface_SetPrivateData(LPDIRECTDRAWSURFACE, REFIID, LPVOID, DWORD, DWORD);
#ifdef POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_SetSpriteDisplayList(LPDIRECTDRAWSURFACE,LPDDSPRITE *,DWORD,DWORD,LPDIRECTDRAWSURFACE,DWORD);
#endif //POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_SetSurfaceDesc( LPDIRECTDRAWSURFACE3, LPDDSURFACEDESC, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_SetSurfaceDesc4( LPDIRECTDRAWSURFACE3, LPDDSURFACEDESC2, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_Unlock(LPDIRECTDRAWSURFACE,LPVOID);
extern HRESULT EXTERN_DDAPI DD_Surface_Unlock4(LPDIRECTDRAWSURFACE,LPRECT);
extern HRESULT EXTERN_DDAPI DD_Surface_UpdateOverlay(LPDIRECTDRAWSURFACE,LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX);
extern HRESULT EXTERN_DDAPI DD_Surface_UpdateOverlayDisplay(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_UpdateOverlayZOrder(LPDIRECTDRAWSURFACE,DWORD,LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_Surface_SetPriority(LPDIRECTDRAWSURFACE7 lpDDSurface, DWORD dwPriority);
extern HRESULT EXTERN_DDAPI DD_Surface_GetPriority(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDWORD lpdwPriority);
extern HRESULT EXTERN_DDAPI DD_Surface_SetLOD(LPDIRECTDRAWSURFACE7 lpDDSurface, DWORD dwLOD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetLOD(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDWORD lpdwLOD);

/* DrawDrawVideoPortContainer functions */
extern HRESULT EXTERN_DDAPI DDVPC_QueryInterface(LPDDVIDEOPORTCONTAINER lpDVP, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DDVPC_AddRef(LPDDVIDEOPORTCONTAINER lpDVP );
extern DWORD   EXTERN_DDAPI DDVPC_Release( LPDDVIDEOPORTCONTAINER lpDD );
extern HRESULT EXTERN_DDAPI DDVPC_CreateVideoPort(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwFlags, LPDDVIDEOPORTDESC lpDesc, LPDIRECTDRAWVIDEOPORT FAR *lplpVideoPort, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DDVPC_EnumVideoPorts(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwReserved, LPDDVIDEOPORTCAPS lpCaps, LPVOID lpContext, LPDDENUMVIDEOCALLBACK lpCallback );
extern HRESULT EXTERN_DDAPI DDVPC_GetVideoPortConnectInfo(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwVideoPortID, LPDWORD lpdwNumGUIDs, LPDDVIDEOPORTCONNECT lpConnect );
extern HRESULT EXTERN_DDAPI DDVPC_QueryVideoPortStatus(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwVideoPortID, LPDDVIDEOPORTSTATUS lpStatus );

/* DirectDrawVideoPort functions */
extern HRESULT EXTERN_DDAPI DD_VP_QueryInterface(LPDIRECTDRAWVIDEOPORT lpDVP, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_VP_AddRef(LPDIRECTDRAWVIDEOPORT lpDVP );
extern DWORD   EXTERN_DDAPI DD_VP_Release(LPDIRECTDRAWVIDEOPORT lpDVP );
extern HRESULT EXTERN_DDAPI DD_VP_SetTargetSurface(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE lpSurface, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_VP_Flip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE lpSurface, DWORD );
extern HRESULT EXTERN_DDAPI DD_VP_GetBandwidth(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDPIXELFORMAT lpf, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags, LPDDVIDEOPORTBANDWIDTH lpBandwidth );
extern HRESULT EXTERN_DDAPI DD_VP_GetInputFormats(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwNum, LPDDPIXELFORMAT lpf, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_VP_GetOutputFormats(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDPIXELFORMAT lpf, LPDWORD lp1, LPDDPIXELFORMAT lp2, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_VP_GetCurrentAutoFlip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE FAR* lpSurf, LPDIRECTDRAWSURFACE FAR* lpVBI, LPBOOL lpField );
extern HRESULT EXTERN_DDAPI DD_VP_GetLastAutoFlip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE FAR* lpSurf, LPDIRECTDRAWSURFACE FAR* lpVBI, LPBOOL lpField );
extern HRESULT EXTERN_DDAPI DD_VP_GetField(LPDIRECTDRAWVIDEOPORT lpDVP, LPBOOL lpField );
extern HRESULT EXTERN_DDAPI DD_VP_GetLine(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwLine );
extern HRESULT EXTERN_DDAPI DD_VP_StartVideo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDVIDEOPORTINFO lpInfo );
extern HRESULT EXTERN_DDAPI DD_VP_StopVideo(LPDIRECTDRAWVIDEOPORT lpDVP );
extern HRESULT EXTERN_DDAPI DD_VP_UpdateVideo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDVIDEOPORTINFO lpInfo );
extern HRESULT EXTERN_DDAPI DD_VP_WaitForSync(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwFlags, DWORD dwLine, DWORD dwTimeOut );
extern HRESULT EXTERN_DDAPI DD_VP_SetFieldNumber(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwFieldNum );
extern HRESULT EXTERN_DDAPI DD_VP_GetFieldNumber(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwFieldNum );
extern HRESULT EXTERN_DDAPI DD_VP_SetSkipFieldPattern(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwStartField, DWORD dwPattSize, DWORD dwPatt );
extern HRESULT EXTERN_DDAPI DD_VP_GetSignalStatus(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwStatus );
extern HRESULT EXTERN_DDAPI DD_VP_GetColorControls(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDCOLORCONTROL lpColor );
extern HRESULT EXTERN_DDAPI DD_VP_SetColorControls(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDCOLORCONTROL lpColor );
extern HRESULT EXTERN_DDAPI DD_VP_GetStateInfo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwStateFlags );

/* DirectDrawVideoPortNotify functions */
extern HRESULT EXTERN_DDAPI DD_VP_Notify_AcquireNotification( LPDIRECTDRAWVIDEOPORTNOTIFY lpNotify, HANDLE* pEvent, LPDDVIDEOPORTNOTIFY pBuffer );
extern HRESULT EXTERN_DDAPI DD_VP_Notify_ReleaseNotification( LPDIRECTDRAWVIDEOPORTNOTIFY lpNotify, HANDLE pEvent );

/* DrawDrawColorControl functions */
extern HRESULT EXTERN_DDAPI DD_Color_GetColorControls(LPDIRECTDRAWCOLORCONTROL lpDDCC, LPDDCOLORCONTROL lpColor );
extern HRESULT EXTERN_DDAPI DD_Color_SetColorControls(LPDIRECTDRAWCOLORCONTROL lpDDCC, LPDDCOLORCONTROL lpColor );

/* DrawDrawGammaControl functions */
extern HRESULT EXTERN_DDAPI DD_Gamma_GetGammaRamp(LPDIRECTDRAWGAMMACONTROL lpDDGC, DWORD dwFlags, LPVOID lpGammaTable );
extern HRESULT EXTERN_DDAPI DD_Gamma_SetGammaRamp(LPDIRECTDRAWGAMMACONTROL lpDDGC, DWORD dwFlags, LPVOID lpGammaTable );

/* DirectDrawKernel functions */
extern HRESULT EXTERN_DDAPI DD_Kernel_GetCaps(LPDIRECTDRAWKERNEL lpDDK, LPDDKERNELCAPS lpCaps );
extern HRESULT EXTERN_DDAPI DD_Kernel_GetKernelHandle(LPDIRECTDRAWKERNEL lpDDK, PULONG_PTR lpHandle );
extern HRESULT EXTERN_DDAPI DD_Kernel_ReleaseKernelHandle(LPDIRECTDRAWKERNEL lpDDK );

/* DirectDrawSurfaceKernel functions */
extern HRESULT EXTERN_DDAPI DD_SurfaceKernel_GetKernelHandle(LPDIRECTDRAWSURFACEKERNEL lpDDK, PULONG_PTR lpHandle );
extern HRESULT EXTERN_DDAPI DD_SurfaceKernel_ReleaseKernelHandle(LPDIRECTDRAWSURFACEKERNEL lpDDK );

/* DIrectDrawSurface and palette IPersist and IPersistStream functions */
#ifdef IS_32
    extern HRESULT EXTERN_DDAPI DD_PStream_GetSizeMax(IPersistStream * lpSurfOrPalette, ULARGE_INTEGER * pMax);
    extern HRESULT EXTERN_DDAPI DD_Surface_PStream_Save(LPDIRECTDRAWSURFACE lpDDS, IStream * pStrm, BOOL bClearDirty);
    extern HRESULT EXTERN_DDAPI DD_Surface_PStream_IsDirty(LPDIRECTDRAWSURFACE lpDDS);
    extern HRESULT EXTERN_DDAPI DD_Surface_Persist_GetClassID(LPDIRECTDRAWSURFACE lpDDS, CLSID * pClassID);
    extern HRESULT EXTERN_DDAPI DD_Surface_PStream_Load(LPDIRECTDRAWSURFACE lpDDS, IStream * pStrm);
    extern HRESULT EXTERN_DDAPI DD_Palette_PStream_Save(LPDIRECTDRAWPALETTE lpDDS, IStream * pStrm, BOOL bClearDirty);
    extern HRESULT EXTERN_DDAPI DD_Palette_PStream_IsDirty(LPDIRECTDRAWPALETTE lpDDS);
    extern HRESULT EXTERN_DDAPI DD_Palette_Persist_GetClassID(LPDIRECTDRAWPALETTE lpDDS, CLSID * pClassID);
    extern HRESULT EXTERN_DDAPI DD_Palette_PStream_Load(LPDIRECTDRAWPALETTE lpDDS, IStream * pStrm);
#endif

/* DirectDrawOptSurface functions */
extern HRESULT EXTERN_DDAPI DD_OptSurface_GetOptSurfaceDesc(LPDIRECTDRAWSURFACE, LPDDOPTSURFACEDESC);
extern HRESULT EXTERN_DDAPI DD_OptSurface_LoadUnoptimizedSurf(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_OptSurface_CopyOptimizedSurf(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_OptSurface_Unoptimize(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *);

/* DrawDrawMotionCompContainer functions */
extern HRESULT EXTERN_DDAPI DDMCC_CreateMotionComp(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDDVAUncompDataInfo lpUncompInfo, LPVOID lpData, DWORD dwDataSize, LPDIRECTDRAWVIDEOACCELERATOR FAR *lplpMotionComp, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DDMCC_GetUncompressedFormats(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDWORD lpNumFormats, LPDDPIXELFORMAT lpFormats );
extern HRESULT EXTERN_DDAPI DDMCC_GetMotionCompGUIDs(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPDWORD lpNumGuids, LPGUID lpGuids );
extern HRESULT EXTERN_DDAPI DDMCC_GetCompBuffInfo(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDDVAUncompDataInfo lpUncompInfo, LPDWORD lpNumBuffInfo, LPDDVACompBufferInfo lpCompBuffInfo );
extern HRESULT EXTERN_DDAPI DDMCC_GetInternalMoCompInfo(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDDVAUncompDataInfo lpUncompInfo, LPDDVAInternalMemInfo lpMemInfo );

/* DrawDrawMotionComp functions */
extern HRESULT EXTERN_DDAPI DD_MC_QueryInterface(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_MC_AddRef(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC);
extern DWORD   EXTERN_DDAPI DD_MC_Release(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC);
extern HRESULT EXTERN_DDAPI DD_MC_BeginFrame(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, LPDDVABeginFrameInfo lpInfo);
extern HRESULT EXTERN_DDAPI DD_MC_EndFrame(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, LPDDVAEndFrameInfo lpInfo);
extern HRESULT EXTERN_DDAPI DD_MC_QueryRenderStatus(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, LPDIRECTDRAWSURFACE7 lpSurface, DWORD dwFlags);
extern HRESULT EXTERN_DDAPI DD_MC_RenderMacroBlocks(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, DWORD dwFunction, LPVOID lpInput, DWORD dwInputSize, LPVOID lpOutput, DWORD dwOutSize, DWORD dwNumBuffers, LPDDVABUFFERINFO lpBuffInfo);

//#endif //WIN95

/*
 * HAL fns
 */

//#ifdef WIN95
/*
 * thunk helper fns
 */
extern DWORD DDAPI _DDHAL_CreatePalette( LPDDHAL_CREATEPALETTEDATA lpCreatePaletteData );
extern DWORD DDAPI DDThunk16_CreatePalette( LPDDHAL_CREATEPALETTEDATA lpCreatePaletteData );

extern DWORD DDAPI _DDHAL_CreateSurface( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData );
extern DWORD DDAPI DDThunk16_CreateSurface( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData );

extern DWORD DDAPI _DDHAL_CanCreateSurface( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData );
extern DWORD DDAPI DDThunk16_CanCreateSurface( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData );

extern DWORD DDAPI _DDHAL_WaitForVerticalBlank( LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlankData );
extern DWORD DDAPI DDThunk16_WaitForVerticalBlank( LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlankData );

extern DWORD DDAPI _DDHAL_DestroyDriver( LPDDHAL_DESTROYDRIVERDATA lpDestroyDriverData );
extern DWORD DDAPI DDThunk16_DestroyDriver( LPDDHAL_DESTROYDRIVERDATA lpDestroyDriverData );

extern DWORD DDAPI _DDHAL_SetMode( LPDDHAL_SETMODEDATA lpSetModeData );
extern DWORD DDAPI DDThunk16_SetMode( LPDDHAL_SETMODEDATA lpSetModeData );

extern DWORD DDAPI _DDHAL_GetScanLine( LPDDHAL_GETSCANLINEDATA lpGetScanLineData );
extern DWORD DDAPI DDThunk16_GetScanLine( LPDDHAL_GETSCANLINEDATA lpGetScanLineData );

extern DWORD DDAPI _DDHAL_SetExclusiveMode( LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveModeData );
extern DWORD DDAPI DDThunk16_SetExclusiveMode( LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveModeData );

extern DWORD DDAPI _DDHAL_FlipToGDISurface( LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurfaceData );
extern DWORD DDAPI DDThunk16_FlipToGDISurface( LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurfaceData );

extern DWORD DDAPI _DDHAL_GetAvailDriverMemory ( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpGetAvailDriverMemoryData );
extern DWORD DDAPI DDThunk16_GetAvailDriverMemory ( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpGetAvailDriverMemoryData );

extern DWORD DDAPI _DDHAL_UpdateNonLocalHeap ( LPDDHAL_UPDATENONLOCALHEAPDATA lpUpdateNonLocalHeapData );
extern DWORD DDAPI DDThunk16_UpdateNonLocalHeap ( LPDDHAL_UPDATENONLOCALHEAPDATA lpUpdateNonLocalHeapData );

/*
 * Palette Object HAL fns
 */
extern DWORD DDAPI _DDHAL_DestroyPalette( LPDDHAL_DESTROYPALETTEDATA );
extern DWORD DDAPI DDThunk16_DestroyPalette( LPDDHAL_DESTROYPALETTEDATA );

extern DWORD DDAPI _DDHAL_SetEntries( LPDDHAL_SETENTRIESDATA );
extern DWORD DDAPI DDThunk16_SetEntries( LPDDHAL_SETENTRIESDATA );

/*
 * Surface Object HAL fns
 */
extern DWORD DDAPI _DDHAL_DestroySurface( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData );
extern DWORD DDAPI DDThunk16_DestroySurface( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData );

extern DWORD DDAPI _DDHAL_Flip( LPDDHAL_FLIPDATA lpFlipData );
extern DWORD DDAPI DDThunk16_Flip( LPDDHAL_FLIPDATA lpFlipData );

extern DWORD DDAPI _DDHAL_Blt( LPDDHAL_BLTDATA lpBltData );
extern DWORD DDAPI DDThunk16_Blt( LPDDHAL_BLTDATA lpBltData );

extern DWORD DDAPI _DDHAL_Lock( LPDDHAL_LOCKDATA lpLockData );
extern DWORD DDAPI DDThunk16_Lock( LPDDHAL_LOCKDATA lpLockData );

extern DWORD DDAPI _DDHAL_Unlock( LPDDHAL_UNLOCKDATA lpUnlockData );
extern DWORD DDAPI DDThunk16_Unlock( LPDDHAL_UNLOCKDATA lpUnlockData );

extern DWORD DDAPI _DDHAL_AddAttachedSurface( LPDDHAL_ADDATTACHEDSURFACEDATA lpAddAttachedSurfaceData );
extern DWORD DDAPI DDThunk16_AddAttachedSurface( LPDDHAL_ADDATTACHEDSURFACEDATA lpAddAttachedSurfaceData );

extern DWORD DDAPI _DDHAL_SetColorKey( LPDDHAL_SETCOLORKEYDATA lpSetColorKeyData );
extern DWORD DDAPI DDThunk16_SetColorKey( LPDDHAL_SETCOLORKEYDATA lpSetColorKeyData );

extern DWORD DDAPI _DDHAL_SetClipList( LPDDHAL_SETCLIPLISTDATA lpSetClipListData );
extern DWORD DDAPI DDThunk16_SetClipList( LPDDHAL_SETCLIPLISTDATA lpSetClipListData );

extern DWORD DDAPI _DDHAL_UpdateOverlay( LPDDHAL_UPDATEOVERLAYDATA lpUpdateOverlayData );
extern DWORD DDAPI DDThunk16_UpdateOverlay( LPDDHAL_UPDATEOVERLAYDATA lpUpdateOverlayData );

extern DWORD DDAPI _DDHAL_SetOverlayPosition( LPDDHAL_SETOVERLAYPOSITIONDATA lpSetOverlayPositionData );
extern DWORD DDAPI DDThunk16_SetOverlayPosition( LPDDHAL_SETOVERLAYPOSITIONDATA lpSetOverlayPositionData );

extern DWORD DDAPI _DDHAL_SetPalette( LPDDHAL_SETPALETTEDATA lpSetPaletteData );
extern DWORD DDAPI DDThunk16_SetPalette( LPDDHAL_SETPALETTEDATA lpSetPaletteData );

extern DWORD DDAPI _DDHAL_GetBltStatus( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatusData );
extern DWORD DDAPI DDThunk16_GetBltStatus( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatusData );

extern DWORD DDAPI _DDHAL_GetFlipStatus( LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatusData );
extern DWORD DDAPI DDThunk16_GetFlipStatus( LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatusData );

/*
 * Execute Buffer Pseudo Object HAL fns
 *
 * NOTE: No DDThunk16 equivalents as these are just dummy place holders to keep
 * DOHALCALL happy.
 */
extern DWORD DDAPI _DDHAL_CanCreateExecuteBuffer( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData );
extern DWORD DDAPI _DDHAL_CreateExecuteBuffer( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData );
extern DWORD DDAPI _DDHAL_DestroyExecuteBuffer( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData );
extern DWORD DDAPI _DDHAL_LockExecuteBuffer( LPDDHAL_LOCKDATA lpLockData );
extern DWORD DDAPI _DDHAL_UnlockExecuteBuffer( LPDDHAL_UNLOCKDATA lpUnlockData );

/*
 * Video Port Pseudo Object HAL fns
 *
 * NOTE: No DDThunk16 equivalents as these are just dummy place holders to keep
 * DOHALCALL happy.
 */
extern DWORD DDAPI _DDHAL_GetVideoPortConnectInfo( LPDDHAL_GETVPORTCONNECTDATA lpGetTypeData );
extern DWORD DDAPI _DDHAL_CanCreateVideoPort( LPDDHAL_CANCREATEVPORTDATA lpCanCreateData );
extern DWORD DDAPI _DDHAL_CreateVideoPort( LPDDHAL_CREATEVPORTDATA lpCreateData );
extern DWORD DDAPI _DDHAL_DestroyVideoPort( LPDDHAL_DESTROYVPORTDATA lpDestroyData );
extern DWORD DDAPI _DDHAL_GetVideoPortInputFormats( LPDDHAL_GETVPORTINPUTFORMATDATA lpGetFormatData );
extern DWORD DDAPI _DDHAL_GetVideoPortOutputFormats( LPDDHAL_GETVPORTOUTPUTFORMATDATA lpGetFormatData );
extern DWORD DDAPI _DDHAL_GetVideoPortBandwidthInfo( LPDDHAL_GETVPORTBANDWIDTHDATA lpGetBandwidthData );
extern DWORD DDAPI _DDHAL_UpdateVideoPort( LPDDHAL_UPDATEVPORTDATA lpUpdateData );
extern DWORD DDAPI _DDHAL_GetVideoPortField( LPDDHAL_GETVPORTFIELDDATA lpGetFieldData );
extern DWORD DDAPI _DDHAL_GetVideoPortLine( LPDDHAL_GETVPORTLINEDATA lpGetLineData );
extern DWORD DDAPI _DDHAL_WaitForVideoPortSync( LPDDHAL_WAITFORVPORTSYNCDATA lpWaitSyncData );
extern DWORD DDAPI _DDHAL_FlipVideoPort( LPDDHAL_FLIPVPORTDATA lpFlipData );
extern DWORD DDAPI _DDHAL_GetVideoPortFlipStatus( LPDDHAL_GETVPORTFLIPSTATUSDATA lpFlipData );
extern DWORD DDAPI _DDHAL_GetVideoSignalStatus( LPDDHAL_GETVPORTSIGNALDATA lpData );
extern DWORD DDAPI _DDHAL_VideoColorControl( LPDDHAL_VPORTCOLORDATA lpData );

/*
 * Color Control Pseudo Object HAL fns
 */
extern DWORD DDAPI _DDHAL_ColorControl( LPDDHAL_COLORCONTROLDATA lpColorData );
extern DWORD DDAPI DDThunk16_ColorControl( LPDDHAL_COLORCONTROLDATA lpColorData );

/*
 * Kernel Pseudo Object HAL fns
 */
extern DWORD DDAPI _DDHAL_SyncSurfaceData( LPDDHAL_SYNCSURFACEDATA lpSyncData );
extern DWORD DDAPI _DDHAL_SyncVideoPortData( LPDDHAL_SYNCVIDEOPORTDATA lpSyncData );

/*
 * MotionComp Pseudo Object HAL fns
 */
extern DWORD DDAPI _DDHAL_GetMoCompGuids( LPDDHAL_GETMOCOMPGUIDSDATA lpGetGuidData );
extern DWORD DDAPI _DDHAL_GetMoCompFormats( LPDDHAL_GETMOCOMPFORMATSDATA lpGetFormatData );
extern DWORD DDAPI _DDHAL_CreateMoComp( LPDDHAL_CREATEMOCOMPDATA lpCreateData );
extern DWORD DDAPI _DDHAL_GetMoCompBuffInfo( LPDDHAL_GETMOCOMPCOMPBUFFDATA lpBuffData );
extern DWORD DDAPI _DDHAL_GetInternalMoCompInfo( LPDDHAL_GETINTERNALMOCOMPDATA lpInternalData );
extern DWORD DDAPI _DDHAL_DestroyMoComp( LPDDHAL_DESTROYMOCOMPDATA lpDestroyData );
extern DWORD DDAPI _DDHAL_BeginMoCompFrame( LPDDHAL_BEGINMOCOMPFRAMEDATA lpFrameData );
extern DWORD DDAPI _DDHAL_EndMoCompFrame( LPDDHAL_ENDMOCOMPFRAMEDATA lpFrameData );
extern DWORD DDAPI _DDHAL_RenderMoComp( LPDDHAL_RENDERMOCOMPDATA lpRenderData );
extern DWORD DDAPI _DDHAL_QueryMoCompStatus( LPDDHAL_QUERYMOCOMPSTATUSDATA lpStatusData );
#ifdef POSTPONED
extern DWORD DDAPI _DDHAL_CanOptimizeSurface( LPDDHAL_CANOPTIMIZESURFACEDATA);
extern DWORD DDAPI _DDHAL_OptimizeSurface( LPDDHAL_OPTIMIZESURFACEDATA);
extern DWORD DDAPI _DDHAL_UnOptimizeSurface( LPDDHAL_UNOPTIMIZESURFACEDATA);
extern DWORD DDAPI _DDHAL_CopyOptSurface( LPDDHAL_COPYOPTSURFACEDATA);
#endif
//#endif

#ifdef POSTPONED
    #ifdef IS_32
    /*
     * DirectDrawFactory2 implementation
     */
    typedef struct _DDFACTORY2
    {
        IDirectDrawFactory2Vtbl *lpVtbl;
        DWORD                   dwRefCnt;
        /* internal data */
    } DDFACTORY2, FAR * LPDDFACTORY2;
    #endif
#endif //POSTPONED

/*
 * Macros for checking interface versions
 */

#define LOWERTHANDDRAW7(lpDD) \
    (lpDD->lpVtbl == &ddCallbacks || lpDD->lpVtbl == &dd2Callbacks || lpDD->lpVtbl == &dd4Callbacks )

#define LOWERTHANDDRAW4(lpDD) \
    (lpDD->lpVtbl == &ddCallbacks || lpDD->lpVtbl == &dd2Callbacks)

#define LOWERTHANDDRAW3(lpDD) \
    (lpDD->lpVtbl == &ddCallbacks || lpDD->lpVtbl == &dd2Callbacks)

#define LOWERTHANSURFACE7(lpDDS) \
    (lpDDS->lpVtbl == &ddSurfaceCallbacks || lpDDS->lpVtbl == &ddSurface2Callbacks || \
     lpDDS->lpVtbl == &ddSurface3Callbacks || lpDDS->lpVtbl == &ddSurface4Callbacks )

#define LOWERTHANSURFACE4(lpDDS) \
    (lpDDS->lpVtbl == &ddSurfaceCallbacks || lpDDS->lpVtbl == &ddSurface2Callbacks || lpDDS->lpVtbl == &ddSurface3Callbacks )

/*
 * This macro allows testing an interface pointer to see if it's one that come from
 * our implementation of ddraw, or somebody else's
 */
#define IS_NATIVE_DDRAW_INTERFACE(ptr) \
        ( ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd2Callbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd4Callbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd7Callbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd2UninitCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd4UninitCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd5UninitCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddVideoPortContainerCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddKernelCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddMotionCompContainerCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddUninitCallbacks) )

/*
 * This macro tests if this ddraw interface is one for which child objects should take
 * a ref count on that interface and thus achieve immortality wrt that interface.
 */
#define CHILD_SHOULD_TAKE_REFCNT(dd_int) (!LOWERTHANDDRAW3(dd_int))

/*
 * macros for checking if surface as been lost due to mode change
 * NOTE: The flag for determining if a surface is lost or not is now
 * stored in the local than global object. This prevents the scenario
 * where a surface being shared by two processes is lost and restored
 * by one of them - giving the other no notification that the contents
 * of the surface are gone.
 */
#define SURFACE_LOST( lcl_ptr ) (((lcl_ptr)->dwFlags & DDRAWISURF_INVALID))

/*
 * Useful palette macros
 *
 * All these flags are really iritating to handle but but changing
 * to use a numeric palette size would require an API change and
 * internal structure mods (visible to the driver) so I am sticking
 * with flags.
 */
#define SIZE_PCAPS_TO_FLAGS( pcaps )                              \
    (((pcaps) & DDPCAPS_1BIT) ? DDRAWIPAL_2 :                     \
     (((pcaps) & DDPCAPS_2BIT) ? DDRAWIPAL_4 :                    \
      (((pcaps) & DDPCAPS_4BIT) ? DDRAWIPAL_16 : DDRAWIPAL_256)))

#define SIZE_FLAGS_TO_PCAPS( flags )                              \
    (((flags) & DDRAWIPAL_2) ? DDPCAPS_1BIT :                     \
     (((flags) & DDRAWIPAL_4) ? DDPCAPS_2BIT :                    \
      (((flags) & DDRAWIPAL_16) ? DDPCAPS_4BIT : DDPCAPS_8BIT)))

#define FLAGS_TO_SIZE( flags )                                    \
    (((flags) & DDRAWIPAL_2)  ? 2 :                               \
     (((flags) & DDRAWIPAL_4)  ? 4 :                              \
      (((flags) & DDRAWIPAL_16) ? 16 : 256)))

/*
 * has Direct3D been initialized for this DirectDraw driver object?
 */
#define D3D_INITIALIZED( lcl_ptr )  (( NULL != (lcl_ptr)->pD3DIUnknown)  && ( NULL != (lcl_ptr)->hD3DInstance ))

#if defined( _WIN32 ) && !defined( WINNT )
/*
 * Macros and types to support secondary (stacked) drivers.
 *
 * NOTE: This stuff is only relevant to 32-bit DirectDraw and the GUIDs
 * confuse DDRAW16.
 */
#define MAX_SECONDARY_DRIVERNAME              MAX_PATH
#define MAX_SECONDARY_ENTRYPOINTNAME          32UL
#define DEFAULT_SECONDARY_ENTRYPOINTNAME      "GetInfo"

#define REGSTR_PATH_SECONDARY                 "Software\\Microsoft\\DirectDraw\\Secondary"
#define REGSTR_VALUE_SECONDARY_ENTRYPOINTNAME "Entry"
#define REGSTR_VALUE_SECONDARY_DRIVERNAME     "Name"

typedef DWORD                    (WINAPI * LPSECONDARY_PATCHHALINFO)(
                                        LPDDHALINFO                lpDDHALInfo,
                                        LPDDHAL_DDCALLBACKS        lpDDCallbacks,
                                        LPDDHAL_DDSURFACECALLBACKS lpDDSurfaceCallbacks,
                                        LPDDHAL_DDPALETTECALLBACKS lpDDPaletteCallbacks,
                                        LPDDHAL_DDEXEBUFCALLBACKS  lpDDExeBufCallbacks);
typedef LPSECONDARY_PATCHHALINFO (WINAPI * LPSECONDARY_VALIDATE)(LPGUID lpGuid);

DEFINE_GUID( guidCertifiedSecondaryDriver, 0x8061d4e0,0xe895,0x11cf,0xa2,0xe0,0x00,0xaa,0x00,0xb9,0x33,0x56 );
#endif

#if defined( _WIN32 )
DEFINE_GUID( guidVoodoo1A, 0x3a0cfd01,0x9320,0x11cf,0xac,0xa1,0x00,0xa0,0x24,0x13,0xc2,0xe2 );
DEFINE_GUID( guidVoodoo1B, 0xaba52f41,0xf744,0x11cf,0xb4,0x52,0x00,0x00,0x1d,0x1b,0x41,0x26 );
#endif

/*
 * macros for validating pointers
 */
extern DIRECTDRAWCALLBACKS                      ddCallbacks;
extern DIRECTDRAWCALLBACKS                      ddUninitCallbacks;
extern DIRECTDRAW2CALLBACKS                     dd2UninitCallbacks;
extern DIRECTDRAW2CALLBACKS                     dd2Callbacks;
extern DIRECTDRAW4CALLBACKS                     dd4UninitCallbacks;
extern DIRECTDRAW4CALLBACKS                     dd4Callbacks;
extern DIRECTDRAW7CALLBACKS                     dd7UninitCallbacks;
extern DIRECTDRAW7CALLBACKS                     dd7Callbacks;
extern DIRECTDRAWSURFACECALLBACKS               ddSurfaceCallbacks;
extern DIRECTDRAWSURFACE2CALLBACKS              ddSurface2Callbacks;
extern DIRECTDRAWSURFACE3CALLBACKS              ddSurface3Callbacks;
extern DIRECTDRAWSURFACE4CALLBACKS              ddSurface4Callbacks;
extern DIRECTDRAWSURFACE7CALLBACKS              ddSurface7Callbacks;
extern DIRECTDRAWCLIPPERCALLBACKS               ddClipperCallbacks;
extern DIRECTDRAWCLIPPERCALLBACKS               ddUninitClipperCallbacks;
extern DIRECTDRAWPALETTECALLBACKS               ddPaletteCallbacks;
extern DDVIDEOPORTCONTAINERCALLBACKS            ddVideoPortContainerCallbacks;
extern DIRECTDRAWVIDEOPORTCALLBACKS             ddVideoPortCallbacks;
extern DIRECTDRAWVIDEOPORTNOTIFYCALLBACKS       ddVideoPortNotifyCallbacks;
extern DIRECTDRAWKERNELCALLBACKS                ddKernelCallbacks;
extern DIRECTDRAWSURFACEKERNELCALLBACKS         ddSurfaceKernelCallbacks;
extern DIRECTDRAWPALETTECALLBACKS               ddPaletteCallbacks;
extern DIRECTDRAWCOLORCONTROLCALLBACKS          ddColorControlCallbacks;
extern DIRECTDRAWGAMMACONTROLCALLBACKS          ddGammaControlCallbacks;
#ifdef POSTPONED
extern NONDELEGATINGUNKNOWNCALLBACKS            ddNonDelegatingUnknownCallbacks;
extern NONDELEGATINGUNKNOWNCALLBACKS            ddUninitNonDelegatingUnknownCallbacks;
extern LPVOID NonDelegatingIUnknownInterface;
extern LPVOID UninitNonDelegatingIUnknownInterface;
#endif
extern DDVIDEOACCELERATORCONTAINERCALLBACKS     ddMotionCompContainerCallbacks;
extern DIRECTDRAWVIDEOACCELERATORCALLBACKS      ddMotionCompCallbacks;

#ifdef POSTPONED
extern DDFACTORY2CALLBACKS                      ddFactory2Callbacks;
extern DIRECTDRAWPALETTE2CALLBACKS              ddPalette2Callbacks;
extern DIRECTDRAWPALETTEPERSISTCALLBACKS        ddPalettePersistCallbacks;
extern DIRECTDRAWPALETTEPERSISTSTREAMCALLBACKS  ddPalettePersistStreamCallbacks;
extern DIRECTDRAWSURFACEPERSISTCALLBACKS        ddSurfacePersistCallbacks;
extern DIRECTDRAWSURFACEPERSISTSTREAMCALLBACKS  ddSurfacePersistStreamCallbacks;
extern DIRECTDRAWOPTSURFACECALLBACKS            ddOptSurfaceCallbacks;
#endif

#ifndef DEBUG
#define FAST_CHECKING
#endif

/*
 * VALIDEX_xxx macros are the same for debug and retail
 */
#define VALIDEX_PTR( ptr, size ) \
        (!IsBadReadPtr( ptr, size) )

#define VALIDEX_IID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( IID )) )

#define VALIDEX_PTR_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID )) )

#define VALIDEX_CODE_PTR( ptr ) \
        (!IsBadCodePtr( (LPVOID) ptr ) )

#define VALIDEX_GUID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( GUID ) ) )

#define VALIDEX_DIRECTDRAWFACTORY2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDFACTORY2 )) && \
        (ptr->lpVtbl == &ddFactory2Callbacks) )
#define VALIDEX_DIRECTDRAW_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DIRECTDRAW_INT )) && \
        ( (ptr->lpVtbl == &ddCallbacks) || \
          (ptr->lpVtbl == &dd2Callbacks) || \
          (ptr->lpVtbl == &dd4Callbacks) || \
          (ptr->lpVtbl == &dd7Callbacks) || \
          (ptr->lpVtbl == &dd2UninitCallbacks) || \
          (ptr->lpVtbl == &dd4UninitCallbacks) || \
          (ptr->lpVtbl == &dd7UninitCallbacks) || \
          (ptr->lpVtbl == &ddVideoPortContainerCallbacks) || \
          (ptr->lpVtbl == &ddKernelCallbacks) || \
          (ptr->lpVtbl == &ddMotionCompContainerCallbacks) || \
          (ptr->lpVtbl == &ddUninitCallbacks) ) )
#define VALIDEX_DIRECTDRAWSURFACE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWSURFACE_INT )) && \
        ( (ptr->lpVtbl == &ddSurfaceCallbacks ) || \
          (ptr->lpVtbl == &ddSurface7Callbacks ) || \
          (ptr->lpVtbl == &ddSurface4Callbacks ) || \
          (ptr->lpVtbl == &ddSurface3Callbacks ) || \
          (ptr->lpVtbl == &ddSurface2Callbacks ) || \
          (ptr->lpVtbl == &ddSurfaceKernelCallbacks ) || \
          (ptr->lpVtbl == &ddColorControlCallbacks ) || \
          (ptr->lpVtbl == &ddGammaControlCallbacks ) ) )
#define VALIDEX_DIRECTDRAWPALETTE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWPALETTE_INT )) && \
        (ptr->lpVtbl == &ddPaletteCallbacks) )
#define VALIDEX_DIRECTDRAWCLIPPER_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWCLIPPER_INT )) && \
        ( (ptr->lpVtbl == &ddClipperCallbacks) || \
          (ptr->lpVtbl == &ddUninitClipperCallbacks) ) )
#define VALIDEX_DDCOLORCONTROL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDCOLORCONTROL_INT )) && \
        (ptr->lpVtbl == &ddColorControlCallbacks) )
#define VALIDEX_DDDEVICEIDENTIFIER_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof( DDDEVICEIDENTIFIER )))
#define VALIDEX_DDDEVICEIDENTIFIER2_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof( DDDEVICEIDENTIFIER2 )))


/*
 * These macros validate the size (in debug and retail) of callback
 * tables.
 *
 * NOTE: It is essential that the comparison against the current
 * callback size expected by this DirectDraw the comparison operator
 * be >= rather than ==. This is to ensure that newer drivers can run
 * against older DirectDraws.
 */
#define VALIDEX_DDCALLBACKSSIZE( ptr )                       \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ( ptr )->dwSize == DDCALLBACKSSIZE_V1   )   || \
            ( ( ptr )->dwSize >= DDCALLBACKSSIZE      ) ) )

#define VALIDEX_DDSURFACECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDSURFACECALLBACKSSIZE ) )

#define VALIDEX_DDPALETTECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDPALETTECALLBACKSSIZE ) )

#define VALIDEX_DDPALETTECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDPALETTECALLBACKSSIZE ) )

#define VALIDEX_DDEXEBUFCALLBACKSSIZE( ptr )                 \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDEXEBUFCALLBACKSSIZE ) )

#define VALIDEX_DDVIDEOPORTCALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDVIDEOPORTCALLBACKSSIZE ) )

#define VALIDEX_DDMOTIONCOMPCALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMOTIONCOMPCALLBACKSSIZE ) )

#define VALIDEX_DDCOLORCONTROLCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDCOLORCONTROLCALLBACKSSIZE ) )

#define VALIDEX_DDMISCELLANEOUSCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMISCELLANEOUSCALLBACKSSIZE ) )

#define VALIDEX_DDMISCELLANEOUS2CALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMISCELLANEOUS2CALLBACKSSIZE ) )

#define VALIDEX_D3DCALLBACKS2SIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( (( ptr )->dwSize >= D3DHAL_CALLBACKS2SIZE ) ))

#define VALIDEX_D3DCOMMANDBUFFERCALLBACKSSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= D3DHAL_COMMANDBUFFERCALLBACKSSIZE ) )

#define VALIDEX_D3DCALLBACKS3SIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= D3DHAL_CALLBACKS3SIZE ) )

#define VALIDEX_DDKERNELCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDKERNELCALLBACKSSIZE ) )

#define VALIDEX_DDUMODEDRVINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDHAL_DDUMODEDRVINFOSIZE ) )
#define VALIDEX_DDOPTSURFKMODEINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDOPTSURFACEKMODEINFOSIZE ) )

#define VALIDEX_DDOPTSURFUMODEINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDOPTSURFACEUMODEINFOSIZE ) )

#ifndef WIN95
#define VALIDEX_DDNTCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDNTCALLBACKSSIZE ) )

#define VALIDEX_DDVPE2CALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDVPE2CALLBACKSSIZE ) )
#endif

#ifndef FAST_CHECKING
#define VALID_DIRECTDRAW_PTR( ptr )        VALIDEX_DIRECTDRAW_PTR( ptr )
#define VALID_DIRECTDRAWFACTORY2_PTR( ptr )        VALIDEX_DIRECTDRAWFACTORY2_PTR( ptr )
#define VALID_DIRECTDRAWSURFACE_PTR( ptr ) VALIDEX_DIRECTDRAWSURFACE_PTR( ptr )
#define VALID_DIRECTDRAWPALETTE_PTR( ptr ) VALIDEX_DIRECTDRAWPALETTE_PTR( ptr )
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr ) VALIDEX_DIRECTDRAWCLIPPER_PTR( ptr )
#define VALID_DDSURFACEDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC )))
#define VALID_DDSURFACEDESC2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC2 ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC2 )))
#define VALID_DDVIDEOPORTDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTDESC ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTDESC )) )
#define VALID_DDVIDEOPORTCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTCAPS ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTCAPS )) )
#define VALID_DDVIDEOPORTINFO_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTINFO ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTINFO )) )
#define VALID_DDVIDEOPORTBANDWIDTH_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTBANDWIDTH ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTBANDWIDTH )) )
#define VALID_DDVIDEOPORTSTATUS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTSTATUS ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTSTATUS )) )
#define VALID_DDVIDEOPORTNOTIFY_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTNOTIFY ) ) )
#define VALID_DDCOLORCONTROL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCOLORCONTROL ) ) && \
        (ptr->dwSize == sizeof( DDCOLORCONTROL )) )
#define VALID_DDKERNELCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDKERNELCAPS ) ) && \
        (ptr->dwSize == sizeof( DDKERNELCAPS )) )
#define VALID_DWORD_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DWORD ) ))
#define VALID_BOOL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( BOOL ) ))
#define VALID_HDC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( HDC ) ))
#define VALID_DDPIXELFORMAT_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDPIXELFORMAT ) ) && \
        (ptr->dwSize == sizeof( DDPIXELFORMAT )) )
#define VALID_DDCOLORKEY_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCOLORKEY ) ) )
#define VALID_RGNDATA_PTR( ptr, size ) \
        (!IsBadWritePtr( ptr, size ) )
#define VALID_RECT_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( RECT ) ) )
#define VALID_DDBLTFX_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDBLTFX ) ) && \
        (ptr->dwSize == sizeof( DDBLTFX )) )
#define VALID_DDBLTBATCH_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDBLTBATCH ) ) )
#define VALID_DDOVERLAYFX_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDOVERLAYFX ) ) && \
        (ptr->dwSize == sizeof( DDOVERLAYFX )) )
#define VALID_DDSCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSCAPS ) ) )
#define VALID_DDSCAPS2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSCAPS2 ) ) )
#define VALID_PTR_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID )) )
#define VALID_IID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( IID )) )
#define VALID_HWND_PTR( ptr ) \
        (!IsBadWritePtr( (LPVOID) ptr, sizeof( HWND )) )
#define VALID_VMEM_PTR( ptr ) \
        (!IsBadWritePtr( (LPVOID) ptr, sizeof( VMEM )) )
#define VALID_POINTER_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID ) * cnt ) )
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( PALETTEENTRY ) * cnt ) )
#define VALID_HANDLE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( HANDLE )) )
#define VALID_DDCORECAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCORECAPS ) ) && \
         (ptr->dwSize == sizeof( DDCORECAPS ) ) )
#define VALID_DDCAPS_PTR( ptr )                          \
         ( ( !IsBadWritePtr( ptr, sizeof( DWORD ) ) ) && \
           ( !IsBadWritePtr( ptr, ptr->dwSize     ) ) && \
           ( ( ptr->dwSize == sizeof( DDCAPS_DX1 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX3 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX5 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX6 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX7 ) ) ) )
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt ) \
        (!IsBadReadPtr( ptr, sizeof( DDSURFACEDESC ) * 1 * cnt ) )
#define VALID_DWORD_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( DWORD ) * 1 * cnt ) )
#define VALID_GUID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( GUID ) ) )
#define VALID_BYTE_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( BYTE ) * 1 * cnt ) )
#define VALID_PTR( ptr, size ) \
        (!IsBadReadPtr( ptr, size) )
#define VALID_DDVIDEOPORT_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDVIDEOPORT_INT )) && \
        (   (ptr->lpVtbl == &ddVideoPortCallbacks) ||              \
            (ptr->lpVtbl == &ddVideoPortNotifyCallbacks)))
#define VALID_DDOPTSURFACEDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDOPTSURFACEDESC ) ) && \
        (ptr->dwSize == sizeof( DDOPTSURFACEDESC )))
#define VALID_DDMOTIONCOMP_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDMOTIONCOMP_INT )) && \
        (ptr->lpVtbl == &ddMotionCompCallbacks) )

#else
#define VALID_PTR( ptr, size )          1
#define VALID_DIRECTDRAW_PTR( ptr )     1
#define VALID_DIRECTDRAWFACTORY2_PTR( ptr )     1
#define VALID_DIRECTDRAWSURFACE_PTR( ptr )      1
#define VALID_DIRECTDRAWPALETTE_PTR( ptr )      1
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr )      1
#define VALID_DDSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC ))
#define VALID_DDSURFACEDESC2_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC2 ))
#define VALID_DDVIDEOPORTDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTDESC ))
#define VALID_DDVIDEOPORTCAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTCAPS ))
#define VALID_DDVIDEOPORTINFO_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTINFO ))
#define VALID_DDVIDEOPORTBANDWIDTH_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTBANDWIDTH ))
#define VALID_DDVIDEOPORTSTATUS_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTSTATUS ))
#define VALID_DDVIDEOPORTNOTIFY_PTR( ptr ) 1
#define VALID_DDCOLORCONTROL_PTR( ptr ) (ptr->dwSize == sizeof( DDCOLORCONTROL ))
#define VALID_DDKERNELCAPS_PTR( ptr) (ptr->dwSize == sizeof( DDKERNELCAPS ))
#define VALID_DWORD_PTR( ptr )  1
#define VALID_BOOL_PTR( ptr )   1
#define VALID_HDC_PTR( ptr )    1
#define VALID_DDPIXELFORMAT_PTR( ptr ) (ptr->dwSize == sizeof( DDPIXELFORMAT ))
#define VALID_DDCOLORKEY_PTR( ptr )     1
#define VALID_RGNDATA_PTR( ptr )        1
#define VALID_RECT_PTR( ptr )   1
#define VALID_DDOVERLAYFX_PTR( ptr ) (ptr->dwSize == sizeof( DDOVERLAYFX ))
#define VALID_DDBLTFX_PTR( ptr ) (ptr->dwSize == sizeof( DDBLTFX ))
#define VALID_DDBLTBATCH_PTR( ptr )     1
#define VALID_DDMASK_PTR( ptr ) 1
#define VALID_DDSCAPS_PTR( ptr )        1
#define VALID_DDSCAPS2_PTR( ptr )       1
#define VALID_PTR_PTR( ptr )    1
#define VALID_IID_PTR( ptr )    1
#define VALID_HWND_PTR( ptr )   1
#define VALID_VMEM_PTR( ptr )   1
#define VALID_POINTER_ARRAY( ptr, cnt ) 1
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt )    1
#define VALID_HANDLE_PTR( ptr ) 1
#define VALID_DDCORECAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDCORECAPS )
#define VALID_DDCAPS_PTR( ptr )                  \
    ( ( ptr->dwSize == sizeof( DDCAPS_DX1 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX3 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX5 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX6 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX7 ) ) )
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt )      1
#define VALID_DWORD_ARRAY( ptr, cnt )   1
#define VALID_GUID_PTR( ptr )   1
#define VALID_BYTE_ARRAY( ptr, cnt ) 1
#define VALID_DDVIDEOPORT_PTR( ptr ) 1
#define VALID_DDOPTSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDOPTSURFACEDESC ))
#define VALID_DDMOTIONCOMP_PTR( ptr ) 1

#endif

/*
 * All global (i.e. cross-process) values now reside in an instance of the following structure.
 * This instance is in its own shared data section.
 */

#undef GLOBALS_IN_STRUCT

#ifdef GLOBALS_IN_STRUCT
    #define GLOBAL_STORAGE_CLASS
    typedef struct
    {
#else
    #define GLOBAL_STORAGE_CLASS extern
#endif

    /*
     * This member should stay at the top in order to guarantee that it be intialized to zero
     * -see dllmain.c 's instance of this structure
     */
GLOBAL_STORAGE_CLASS    DWORD               dwRefCnt;

GLOBAL_STORAGE_CLASS    DWORD                   dwLockCount;

GLOBAL_STORAGE_CLASS    DWORD                   dwFakeCurrPid;
GLOBAL_STORAGE_CLASS    DWORD                   dwGrimReaperPid;

GLOBAL_STORAGE_CLASS    LPDDWINDOWINFO      lpWindowInfo;  // the list of WINDOWINFO structures
GLOBAL_STORAGE_CLASS    LPDDRAWI_DIRECTDRAW_INT lpDriverObjectList;
GLOBAL_STORAGE_CLASS    LPDDRAWI_DIRECTDRAW_LCL lpDriverLocalList;
GLOBAL_STORAGE_CLASS    volatile DWORD      dwMarker;
    /*
     * This is the globally maintained list of clippers not owned by any
     * DirectDraw object. All clippers created with DirectDrawClipperCreate
     * are placed on this list. Those created by IDirectDraw_CreateClipper
     * are placed on the clipper list of thier owning DirectDraw object.
     *
     * The objects on this list are NOT released when an app's DirectDraw
     * object is released. They remain alive until explictly released or
     * the app. dies.
     */
GLOBAL_STORAGE_CLASS    LPDDRAWI_DDRAWCLIPPER_INT lpGlobalClipperList;

GLOBAL_STORAGE_CLASS    HINSTANCE                   hModule;
GLOBAL_STORAGE_CLASS    LPATTACHED_PROCESSES    lpAttachedProcesses;
GLOBAL_STORAGE_CLASS    BOOL                bFirstTime;

    #ifdef DEBUG
GLOBAL_STORAGE_CLASS        int             iDLLCSCnt;
GLOBAL_STORAGE_CLASS        int             iWin16Cnt;
    #endif

        /*
         * Winnt specific global statics
         */
        /*
         *Hel globals:
         */

    // used to count how many drivers are currently using the HEL
GLOBAL_STORAGE_CLASS    DWORD               dwHELRefCnt;
#ifdef WINNT
    GLOBAL_STORAGE_CLASS  LPDCISURFACEINFO  gpdci;
#endif

#ifdef DEBUG
        // these are used by myCreateSurface
    GLOBAL_STORAGE_CLASS        int                 gcSurfMem; // surface memory in bytes
    GLOBAL_STORAGE_CLASS        int                 gcSurf;  // number of surfaces
#endif

GLOBAL_STORAGE_CLASS    DWORD               dwHelperPid;

#ifdef WINNT
GLOBAL_STORAGE_CLASS    HANDLE              hExclusiveModeMutex;
GLOBAL_STORAGE_CLASS    HANDLE              hCheckExclusiveModeMutex;
#endif

#ifdef GLOBALS_IN_STRUCT

    } GLOBALS;

    /*
     * And this is the pointer to the globals. Each process has an instance (contained in dllmain.c)
     */
    //extern GLOBALS * gp;
    extern GLOBALS g_s;
#endif //globals in struct

/*
 * IMPORTANT NOTE: This function validates the HAL information passed to us from the driver.
 * It is vital that we code this check so that we will pass HAL information structures
 * larger than the ones we know about so that new drivers can work with old DirectDraws.
 */
#define VALIDEX_DDHALINFO_PTR( ptr )                         \
        ( ( ( ( ptr )->dwSize == sizeof( DDHALINFO_V1 ) ) || \
            ( ( ptr )->dwSize == DDHALINFOSIZE_V2 )       || \
            ( ( ptr )->dwSize >= sizeof( DDHALINFO ) ) ) &&  \
          !IsBadWritePtr( ( ptr ), ( UINT ) ( ( ptr )->dwSize ) ) )

#define VALIDEX_STR_PTR( ptr, len ) \
        (!IsBadReadPtr( ptr, 1 ) && (lstrlen( ptr ) <len) )
#define VALIDEX_DDSURFACEDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC )) )
#define VALIDEX_DDSURFACEDESC2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC2 ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC2 )) )


// Internal flags required to create special DX8 surfaces

#define DX8SFLAG_DX8                0x00000001
#define DX8SFLAG_ISLOST             0x00000002
#define DX8SFLAG_ISLIGHTWEIGHT      0x00000004
#define DX8SFLAG_IMAGESURF          0x00000008

/* Turn on D3D stats collection for Debug builds HERE */
#define COLLECTSTATS    DBG

#ifdef __cplusplus
}       // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddsacc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsacc.c
 *  Content:    Direct Draw surface access support
 *              Lock & Unlock
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   10-jan-94	craige	initial implementation
 *   13-jan-95	craige	re-worked to updated spec + ongoing work
 *   22-jan-95	craige	made 32-bit + ongoing work
 *   31-jan-95	craige	and even more ongoing work...
 *   04-feb-95	craige	performance tuning, ongoing work
 *   27-feb-95	craige	new sync. macros
 *   02-mar-95	craige	use pitch (not stride)
 *   15-mar-95	craige	HEL
 *   19-mar-95	craige	use HRESULTs
 *   20-mar-95	craige	validate locking rectangle
 *   01-apr-95	craige	happy fun joy updated header file
 *   07-apr-95	craige	bug 2 - unlock should accept the screen ptr
 *			take/release Win16Lock when access GDI's surface
 *   09-apr-95	craige	maintain owner of Win16Lock so we can release it
 *			if someone forgets; remove locks from dead processes
 *   12-apr-95	craige	don't use GETCURRPID; fixed Win16 lock deadlock
 *			condition
 *   06-may-95	craige	use driver-level csects only
 *   12-jun-95	craige	new process list stuff
 *   18-jun-95	craige	allow duplicate surfaces
 *   25-jun-95	craige	one ddraw mutex; hold DDRAW lock when locking primary
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns
 *   03-jul-95	craige	YEEHAW: new driver struct; SEH
 *   07-jul-95	craige	added test for BUSY
 *   08-jul-95	craige	take Win16 lock always on surface lock
 *   09-jul-95	craige	win16 lock re-entrant, so count it!
 *   11-jul-95	craige	set busy bit when taking win16 lock to avoid GDI from
 *			drawing on the display.
 *   13-jul-95	craige	ENTER_DDRAW is now the win16 lock
 *   16-jul-95	craige	check DDRAWISURF_HELCB
 *   31-jul-95	craige	don't return error from HAL unlock if not handled;
 *			validate flags
 *   01-aug-95	craig	use bts for setting & testing BUSY bit
 *   04-aug-95	craige	added InternalLock/Unlock
 *   10-aug-95	toddla	added DDLOCK_WAIT flag
 *   12-aug-95	craige	bug 488: need to call tryDoneLock even after HAL call
 *			to Unlock
 *   18-aug-95	toddla	DDLOCK_READONLY and DDLOCK_WRITEONLY
 *   27-aug-95	craige	bug 723 - treat vram & sysmem the same when locking
 *   09-dec-95	colinmc Added execute buffer support
 *   11-dec-95	colinmc Added lightweight(-ish) Lock and Unlock for use by
 *			Direct3D (exported as private DLL API).
 *   02-jan-96	kylej	handle new interface structs.
 *   26-jan-96	jeffno	Lock/Unlock no longer special-case whole surface...
 *			You need to record what ptr was given to user since
 *			it will not be same as kernel-mode ptr
 *   01-feb-96	colinmc Fixed nasty bug causing Win16 lock to be released
 *			on surfaces explicitly created in system memory
 *			which did not take the lock in the first place
 *   12-feb-96	colinmc Surface lost flag moved from global to local object
 *   13-mar-96	jeffno	Do not allow lock on an NT emulated primary!
 *   18-apr-96	kylej	Bug 18546: Take bytes per pixel into account when
 *			calculating lock offset.
 *   20-apr-96	kylej	Bug 15268: exclude the cursor when a primary
 *			surface rect is locked.
 *   01-may-96	colinmc Bug 20005: InternalLock does not check for lost
 *			surfaces
 *   17-may-96	mdm	Bug 21499: perf problems with new InternalLock
 *   14-jun-96	kylej	NT Bug 38227: Added DDLOCK_FAILONVISRGNCHANGED so
 *			that InternalLock() can fail if the vis rgn is not
 *			current.  This flag is only used on NT.
 *   05-jul-96  colinmc Work Item: Remove requirement on taking Win16 lock
 *                      for VRAM surfaces (not primary)
 *   10-oct-96  colinmc Refinements of the Win16 locking stuff
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   23-mar-97  colinmc Hold Win16 lock for AGP surfaces for now
 *   24-mar-97  jeffno  Optimized Surfaces
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   19-dec-97 jvanaken IDDS4::Unlock now takes pointer to rectangle.
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
#include "ddrawgdi.h"
#endif

/*
 * Bit number of the VRAM flag in the PDEVICE dwFlags field.
 */
#define VRAM_BIT 15

/* doneBusyWin16Lock releases the win16 lock and busy bit.  It is used
 * in lock routines for failure cases in which we have not yet
 * incremented the win16 lock or taken the DD critical section a
 * second time.  It is also called by tryDoneLock.  */
static void doneBusyWin16Lock( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    #ifdef WIN95
        if( pdrv->dwWin16LockCnt == 0 )
        {
            *(pdrv->lpwPDeviceFlags) &= ~BUSY;
        }
        #ifdef WIN16_SEPARATE
            LEAVE_WIN16LOCK();
        #endif
    #endif
} /* doneBusyWin16Lock */

/* tryDoneLock releases the win16 lock and busy bit.  It is used in
 * unlock routines since it decrements the Win16 count in addition to
 * releasing the lock.  WARNING: This function does nothing and
 * returns no error if the win16 lock is not owned by the current DD
 * object. This will result in the lock being held and will probably
 * bring the machine to its knees. */
static void tryDoneLock( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, DWORD pid )
{
    LPDDRAWI_DIRECTDRAW_GBL pdrv = pdrv_lcl->lpGbl;

    if( pdrv->dwWin16LockCnt == 0 )
    {
        return;
    }
    pdrv->dwWin16LockCnt--;
        doneBusyWin16Lock( pdrv );
        LEAVE_DDRAW();
} /* tryDoneLock */

#ifdef USE_ALIAS
    /*
     * Undo an aliased lock.
     *
     * An aliased lock is one which required the PDEVICE VRAM bit
     * to be cleared to prevent the accelerator touching memory
     * at the same time as the locked surface.
     *
     * NOTE: The lock does not necessarily have to be on a VRAM
     * surface. Locks of implicit system memory surfaces also
     * clear the VRAM bit (to ensure similar behaviour for
     * system and video memory surfaces).
     */
    static void undoAliasedLock( LPDDRAWI_DIRECTDRAW_GBL pdrv )
    {
        DDASSERT( 0UL != pdrv->dwAliasedLockCnt );

        #ifdef WIN16_SEPARATE
            ENTER_WIN16LOCK();
        #endif

        pdrv->dwAliasedLockCnt--;
        if( 0UL == pdrv->dwAliasedLockCnt )
        {
            /*
             * That was the last outstanding aliased lock on this
             * device so put the VRAM bit in the PDEVICE back the
             * way it was.
             */
            if( pdrv->dwFlags & DDRAWI_PDEVICEVRAMBITCLEARED )
            {
                /*
                 * The VRAM bit was set when we took the first lock so
                 * we had to clear it. We must now set it again.
                 */
                DPF( 4, "PDevice was VRAM - restoring VRAM bit", pdrv );
                *(pdrv->lpwPDeviceFlags) |= VRAM;
                pdrv->dwFlags &= ~DDRAWI_PDEVICEVRAMBITCLEARED;
            }
        }
        #ifdef WIN16_SEPARATE
            LEAVE_WIN16LOCK();
        #endif
    }

#endif /* USE_ALIAS */

#ifdef WIN95
#define DONE_LOCK_EXCLUDE() \
    if( this_lcl->dwFlags & DDRAWISURF_LOCKEXCLUDEDCURSOR ) \
    { \
        DD16_Unexclude(pdrv->dwPDevice); \
        this_lcl->dwFlags &= ~DDRAWISURF_LOCKEXCLUDEDCURSOR; \
    }
#else
#define DONE_LOCK_EXCLUDE() ;
#endif


/*
 * The following two routines are used by D3D on NT to manipulate
 * the DDraw mutex exclusion mechanism
 */
void WINAPI AcquireDDThreadLock(void)
{
    ENTER_DDRAW();
}
void WINAPI ReleaseDDThreadLock(void)
{
    LEAVE_DDRAW();
}


HRESULT WINAPI DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits )
{
    return InternalLock(this_lcl, lpBits, NULL, DDLOCK_TAKE_WIN16_VRAM |
                                                DDLOCK_FAILLOSTSURFACES);
}

HRESULT WINAPI DDInternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    BUMP_SURFACE_STAMP(this_lcl->lpGbl);
    return InternalUnlock(this_lcl, NULL, NULL, DDLOCK_TAKE_WIN16_VRAM);
}

#define DPF_MODNAME     "InternalLock"

#if !defined( WIN16_SEPARATE) || defined(WINNT)
#pragma message(REMIND("InternalLock not tested without WIN16_SEPARATE."))
#endif // WIN16_SEPARATE

/*
 * InternalLock provides the basics of locking for trusted clients.
 * No parameter validation is done and no ddsd is filled in.  The
 * client promises the surface is not lost and is otherwise well
 * constructed.  If caller does not pass DDLOCK_TAKE_WIN16 in dwFlags,
 * we assume the DDraw critical section, Win16 lock, and busy bit are
 * already entered/set. If caller does pass DDLOCK_TAKE_WIN16,
 * InternalLock will do so if needed. Note that passing
 * DDLOCK_TAKE_WIN16 does not necessarily result in the Win16 lock
 * being taken.  It is only taken if needed.
 */
HRESULT InternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID *pbits,
                      LPRECT lpDestRect, DWORD dwFlags )
{
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    DWORD                       this_lcl_caps;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    DWORD                       rc;
    DDHAL_LOCKDATA              ld;
    LPDDHALSURFCB_LOCK          lhalfn;
    LPDDHALSURFCB_LOCK          lfn;
    BOOL                        emulation;
    LPACCESSRECTLIST            parl;
    LPWORD                      pdflags = NULL;
    BOOL                        isvramlock = FALSE;
    #ifdef USE_ALIAS
        BOOL                        holdwin16lock;
    #endif /* USE_ALIAS */
    FLATPTR                     OldfpVidMem;        //Used to detect if driver moved surface on Lock call


    this = this_lcl->lpGbl;
    this_lcl_caps = this_lcl->ddsCaps.dwCaps;
    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;
    #ifdef WINNT
        // Update DDraw handle in driver GBL object.
        pdrv->hDD = pdrv_lcl->hDD;
    #endif

    ENTER_DDRAW();

    /*
     * If the surface was involved in a hardware op, we need to
     * probe the driver to see if it's done. NOTE this assumes
     * that only one driver can be responsible for a system memory
     * operation.
     * This operation is done at the API level Lock since the situation we
     * need to avoid is the CPU and the DMA/Busmaster hitting a surface
     * at the same time. We can trust the HAL driver to know it should not
     * try to DMA out of the same surface twice. This is almost certainly
     * enforced anyway by the likelihood that the hardware will have only
     * one context with which to perform the transfer: it has to wait.
     */
    if( this->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
    {
        WaitForDriverToFinishWithSurface(this_lcl->lpSurfMore->lpDD_lcl, this_lcl);
    }

    // The following code was added to keep all of the HALs from
    // changing their Lock() code when they add video port support.
    // If the video port was using this surface but was recently
    // flipped, we will make sure that the flip actually occurred
    // before allowing access.  This allows double buffered capture
    // w/o tearing.
    // ScottM 7/10/96
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT )
    {
        LPDDRAWI_DDVIDEOPORT_INT lpVideoPort;
        LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort_lcl;

        // Look at all video ports to see if any of them recently
        // flipped from this surface.
        lpVideoPort = pdrv->dvpList;
        while( NULL != lpVideoPort )
        {
            lpVideoPort_lcl = lpVideoPort->lpLcl;
            if( lpVideoPort_lcl->fpLastFlip == this->fpVidMem )
            {
                // This can potentially tear - check the flip status
                LPDDHALVPORTCB_GETFLIPSTATUS pfn;
                DDHAL_GETVPORTFLIPSTATUSDATA GetFlipData;
                LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;

                pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
                pfn = pdrv_lcl->lpDDCB->HALDDVideoPort.GetVideoPortFlipStatus;
                if( pfn != NULL )  // Will simply tear if function not supproted
                {
                    GetFlipData.lpDD = pdrv_lcl;
                    GetFlipData.fpSurface = this->fpVidMem;

            KeepTrying:
                    rc = DDHAL_DRIVER_NOTHANDLED;
                    DOHALCALL( GetVideoPortFlipStatus, pfn, GetFlipData, rc, 0 );
                    if( ( DDHAL_DRIVER_HANDLED == rc ) &&
                        ( DDERR_WASSTILLDRAWING == GetFlipData.ddRVal ) )
                    {
                        if( dwFlags & DDLOCK_WAIT)
                        {
                            goto KeepTrying;
                        }
                        LEAVE_DDRAW();
                        return DDERR_WASSTILLDRAWING;
                    }
                }
            }
            lpVideoPort = lpVideoPort->lpLink;
        }
    }

    // Check for VRAM access - if yes, we need to take the win16 lock
    // and the busy bit.  From the user API, we treat the vram and
    // implicit sysmemory cases the same because many developers were
    // treating them differently and then breaking when they actually
    // got vram.  Also, we only bother with this if the busy bit (and
    // Win16 lock) are currently available.

    /*
     * NOTE: The semantics are that for each VRAM (or simulated VRAM lock)
     * the Win16 lock and BUSY bit are held until we have called the
     * driver and are sure we can do an aliased lock (in which case we
     * release them). Otherwise, we keep holding them.
     *
     * IMPORTANT NOTE: Behaviour change. Previously we did not perform
     * the Win16 locking actions if this was not the first lock of this
     * surface. This no longer works as we can no longer ensure all the
     * necessary locking actions will happen on the first lock of the
     * surface. For example, the first lock on the surface may be
     * aliasable so we don't set the busy bit. A subsequent lock may
     * not be aliasable, however, so we need to take the lock on that
     * occassion. This should not, however, be much of a hit as the
     * really expensive actions only take place on the first
     * Win16 lock (0UL == pdrv->dwWin16LockCnt) so once someone has
     * taken the Win16 lock remaining locks should be cheap. Also,
     * multiple locks are unusual so, all in all, this should be pretty
     * low risk.
     */
    FlushD3DStates(this_lcl);
#if COLLECTSTATS
    if(this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
        ++this_lcl->lpSurfMore->lpDD_lcl->dwNumTexLocks;
#endif
    if( ( ((dwFlags & DDLOCK_TAKE_WIN16)      && !(this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED)) ||
          ((dwFlags & DDLOCK_TAKE_WIN16_VRAM) &&  (this_lcl_caps & DDSCAPS_VIDEOMEMORY)) )
        && (pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
    {
        DDASSERT(!(this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) ||
                  !(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE));
            
        DPF( 5, "Performing VRAM style lock for surface 0x%08x", this_lcl );

        /*
         * Lock of a VRAM surface (or a surface being treated like a VRAM surface)
         * with no outstanding locks pending. Take the Win16 lock.
         */
        isvramlock = TRUE;

        #ifdef WIN95
            // Don't worry about the busy bit for NT
            /*
             * We always take the Win16 lock while we mess with the driver's
             * busy bits. However, if we have a surface with an alias we
             * will release the Win16 lock before we exit this function.
             */

            #ifdef WIN16_SEPARATE
            ENTER_WIN16LOCK();
            #endif // WIN16_SEPARATE

            // If dwWin16LockCnt > 0 then we already set the busy bit, so
            // don't bother doing it again.  NOTE: this assumption may be
            // limiting.
            if( 0UL == pdrv->dwWin16LockCnt )
            {
                BOOL    isbusy;

                pdflags = pdrv->lpwPDeviceFlags;
                isbusy = 0;

                _asm
                {
                    mov eax, pdflags
                    bts word ptr [eax], BUSY_BIT
                    adc isbusy,0
                }

                if( isbusy )
                {
                    DPF( 2, "BUSY - Lock, dwWin16LockCnt = %ld, %04x, %04x (%ld)",
                         pdrv->dwWin16LockCnt, *pdflags, BUSY, BUSY_BIT );
                    #ifdef WIN16_SEPARATE
                        LEAVE_WIN16LOCK();
                    #endif // WIN16_SEPARATE
                    LEAVE_DDRAW();
                    return DDERR_SURFACEBUSY;
                } // isbusy
            } // ( 0UL == pdrv->dwWin16LockCnt )
        #endif // WIN95
    } // VRAM locking actions (Win16 lock, busy bit).

    // If we have been asked to check for lost surfaces do it NOW after
    // the Win16 locking code. This is essential as otherwise we may
    // lose the surface after the check but before we actually get round
    // to doing anything with the surface
    if( ( dwFlags & DDLOCK_FAILLOSTSURFACES ) && SURFACE_LOST( this_lcl ) )
    {
        DPF_ERR( "Surface is lost - can't lock" );
        #if defined( WIN16_SEPARATE) && !defined(WINNT)
           if( isvramlock )
               doneBusyWin16Lock( pdrv );
        #endif
        LEAVE_DDRAW();
        return DDERR_SURFACELOST;
    }

    // Make sure someone else has not already locked the part of the
    // surface we want. We don't need to worry about this for DX8
    // resource management. In fact, for vertex buffers, the following
    // code doesn't work because the Rect is actually a linear range.
    if(!(this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) ||
       !(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
    {
        BOOL hit = FALSE;

        if( lpDestRect != NULL )
        {
            // Caller has asked to lock a subsection of the surface.

            parl = this->lpRectList;

            // Run through all rectangles, looking for an intersection.
            while( parl != NULL )
            {
                RECT res;

                if( IntersectRect( &res, lpDestRect, &parl->rDest ) )
                {
                    hit = TRUE;
                    break;
                }
                parl = parl->lpLink;
            }
        }

        // Either (our rect overlaps with someone else's rect), or
        // (someone else has locked the entire surface), or
        // (someone locked part of the surface but we want to lock the whole thing).
        if( hit ||
            (this->lpRectList == NULL && this->dwUsageCount > 0) ||
            ((lpDestRect == NULL) && ((this->dwUsageCount > 0) || (this->lpRectList != NULL))) )
        {
            DPF(2,"Surface is busy: parl=0x%x, lpDestRect=0x%x, "
                "this->dwUsageCount=0x%x, this->lpRectList=0x%x, hit=%d",
                parl,lpDestRect,this->dwUsageCount,this->lpRectList,hit );
            #if defined( WIN16_SEPARATE) && !defined(WINNT)
            if( isvramlock )
            {
                doneBusyWin16Lock( pdrv );
            }
            #endif
            LEAVE_DDRAW();
            return DDERR_SURFACEBUSY;
        }

        // Create a rectangle access list member.  Note that for
        // performance, we don't do this on 95 if the user is locking
        // the whole surface.
        parl = NULL;
        if(lpDestRect)
        {
            parl = MemAlloc( sizeof( ACCESSRECTLIST ) );
            if( parl == NULL )
            {
            #if defined( WIN16_SEPARATE) && !defined(WINNT)
                if( isvramlock )
                {
                    doneBusyWin16Lock( pdrv );
                }
            #endif
                DPF(0,"InternalLock: Out of memory.");
                LEAVE_DDRAW();
                return DDERR_OUTOFMEMORY;
            }
            if(lpDestRect != NULL)
            {
                parl->lpLink = this->lpRectList;
                parl->rDest = *lpDestRect;
            }
            else
            {
                parl->lpLink        = NULL;
                parl->rDest.top     = 0;
                parl->rDest.left    = 0;
                parl->rDest.bottom  = (int) (DWORD) this->wHeight;
                parl->rDest.right   = (int) (DWORD) this->wWidth;
            }
            parl->lpOwner = pdrv_lcl;
            #ifdef USE_ALIAS
                parl->dwFlags = 0UL;
                parl->lpHeapAliasInfo = NULL;
            #endif /* USE_ALIAS */
            this->lpRectList = parl;
            //parl->lpSurfaceData is filled below, after HAL call

            /*
             * Add a rect to the region list if this is a managed surface and not a read only lock
             */
            if(IsD3DManaged(this_lcl) && !(dwFlags & DDLOCK_READONLY))
            {
                LPREGIONLIST lpRegionList = this_lcl->lpSurfMore->lpRegionList;
                if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                {
                    lpRegionList->rect[(lpRegionList->rdh.nCount)++] = *((LPRECTL)lpDestRect);
                    lpRegionList->rdh.nRgnSize += sizeof(RECT);
                    if((lpDestRect->left & 0xffff) < lpRegionList->rdh.rcBound.left)
                        lpRegionList->rdh.rcBound.left = lpDestRect->left & 0xffff;
                    if((lpDestRect->right & 0xfff)> lpRegionList->rdh.rcBound.right)
                        lpRegionList->rdh.rcBound.right = lpDestRect->right & 0xffff;
                    if(lpDestRect->top < lpRegionList->rdh.rcBound.top)
                        lpRegionList->rdh.rcBound.top = lpDestRect->top;
                    if(lpDestRect->bottom > lpRegionList->rdh.rcBound.bottom)
                        lpRegionList->rdh.rcBound.bottom = lpDestRect->bottom;
                }
            }
        }
        else
        {
            /*
             * We are locking the whole surface, so by setting nCount to the
             * max number of dirty rects allowed, we will force the cache
             * manager to update the entire surface
             */
            if(IsD3DManaged(this_lcl) && !(dwFlags & DDLOCK_READONLY))
            {
                this_lcl->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
            }
        }
    }
    else
    {
        parl = NULL;
        DDASSERT(this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8);
        DDASSERT(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE);
    }

    // Increment the usage count of this surface.
    this->dwUsageCount++;
    CHANGE_GLOBAL_CNT( pdrv, this, 1 );

    // Is this an emulation surface or driver surface?
    //
    // NOTE: There are different HAL entry points for execute buffers
    // and conventional surfaces.
    if( (this_lcl_caps & DDSCAPS_SYSTEMMEMORY) ||
        (this_lcl->dwFlags & DDRAWISURF_HELCB) )
    {
        if( this_lcl_caps & DDSCAPS_EXECUTEBUFFER )
            lfn = pdrv_lcl->lpDDCB->HELDDExeBuf.LockExecuteBuffer;
        else
            lfn = pdrv_lcl->lpDDCB->HELDDSurface.Lock;
        lhalfn = lfn;
        emulation = TRUE;
    }
    else
    {
        if( this_lcl_caps & DDSCAPS_EXECUTEBUFFER )
        {
            lfn = pdrv_lcl->lpDDCB->HALDDExeBuf.LockExecuteBuffer;
            lhalfn = pdrv_lcl->lpDDCB->cbDDExeBufCallbacks.LockExecuteBuffer;
        }
        else
        {
            lfn = pdrv_lcl->lpDDCB->HALDDSurface.Lock;
            lhalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.Lock;
        }
        emulation = FALSE;
    }


#ifdef WIN95
        /*
         * exclude the mouse cursor if this is the display driver
         * and we are locking a rect on the primary surface.
         * and the driver is not using a HW cursor
         */
        if ( (pdrv->dwFlags & DDRAWI_DISPLAYDRV) && pdrv->dwPDevice &&
             (this_lcl_caps & DDSCAPS_PRIMARYSURFACE) && lpDestRect &&
            !(*pdrv->lpwPDeviceFlags & HARDWARECURSOR))
        {
            DD16_Exclude(pdrv->dwPDevice, (RECTL *)lpDestRect);
            this_lcl->dwFlags |= DDRAWISURF_LOCKEXCLUDEDCURSOR;
        }
#endif


    //Remember the old fpVidMem in case the driver changes is
    OldfpVidMem = this->fpVidMem;

        // See if the driver wants to say something...
    rc = DDHAL_DRIVER_NOTHANDLED;
    if( lhalfn != NULL )
    {
        DPF(4,"InternalLock: Calling driver Lock.");
        ld.Lock = lhalfn;
        ld.lpDD = pdrv;
        ld.lpDDSurface = this_lcl;
        #ifdef WIN95
        ld.dwFlags = dwFlags;
        #else
        #pragma message(REMIND("So far the s3 driver will only succeed if flags==0"))
        ld.dwFlags = dwFlags & (DDLOCK_NOOVERWRITE | DDLOCK_READONLY | DDLOCK_WRITEONLY | DDLOCK_NOSYSLOCK | DDLOCK_DISCARDCONTENTS);
        #endif
        if( lpDestRect != NULL )
        {
            ld.bHasRect = TRUE;
            ld.rArea = *(LPRECTL)lpDestRect;
        }
        else
        {
            ld.bHasRect = FALSE;
        }

    try_again:
        #ifdef WINNT
            do
            {
                if( this_lcl_caps & DDSCAPS_EXECUTEBUFFER )
                {
                    DOHALCALL( LockExecuteBuffer, lfn, ld, rc, emulation );
                }
                else
                {
                    DOHALCALL( Lock, lfn, ld, rc, emulation );

                    if ( (dwFlags & DDLOCK_FAILONVISRGNCHANGED) ||
                        !(rc == DDHAL_DRIVER_HANDLED && ld.ddRVal == DDERR_VISRGNCHANGED) )
                        break;

                    DPF(4,"Resetting VisRgn for surface %x", this_lcl);
                    DdResetVisrgn(this_lcl, (HWND)0);
                }
            }
            while (rc == DDHAL_DRIVER_HANDLED && ld.ddRVal == DDERR_VISRGNCHANGED);
        #else
            if( this_lcl_caps & DDSCAPS_EXECUTEBUFFER )
            {
                DOHALCALL( LockExecuteBuffer, lfn, ld, rc, emulation );
            }
            else
            {
                DOHALCALL( Lock, lfn, ld, rc, emulation );
            }
        #endif


    }

    if( rc == DDHAL_DRIVER_HANDLED )
    {
        if( ld.ddRVal == DD_OK )
        {
            DPF(5,"lpsurfdata is %08x",ld.lpSurfData);
            #ifdef WINNT
                if ( (ld.lpSurfData == (void*) ULongToPtr(0xffbadbad)) && (dwFlags & DDLOCK_FAILEMULATEDNTPRIMARY) )
                {
                    ld.ddRVal = DDERR_CANTLOCKSURFACE;
                }
            #endif
            *pbits = ld.lpSurfData;
        }
        else if( (dwFlags & DDLOCK_WAIT) && ld.ddRVal == DDERR_WASSTILLDRAWING )
        {
            DPF(4, "Waiting...");
            goto try_again;
        }

        if (ld.ddRVal != DD_OK)
        {
            // Failed!

            #ifdef DEBUG
            if( (ld.ddRVal != DDERR_WASSTILLDRAWING) && (ld.ddRVal != DDERR_SURFACELOST) )
            {
                DPF( 0, "Driver failed Lock request: %ld", ld.ddRVal );
            }
            #endif

            // Unlink the rect list item.
            if(parl)
            {
                this->lpRectList = parl->lpLink;
                MemFree( parl );
            }

            // Now unlock the surface and bail.
            this->dwUsageCount--;
            CHANGE_GLOBAL_CNT( pdrv, this, -1 );
            #if defined( WIN16_SEPARATE) && !defined(WINNT)
            if( isvramlock )
            {
                doneBusyWin16Lock( pdrv );
            }
            #endif
            DONE_LOCK_EXCLUDE();
            LEAVE_DDRAW();
            return ld.ddRVal;
        } // ld.ddRVal
    }
    else // DDHAL_DRIVER_HANDLED
    {
        #ifdef WINNT
            // If the driver fails the lock, we can't allow the app to scribble with
            // who knows what fpVidMem...
            *pbits = (LPVOID) ULongToPtr(0x80000000); // Illegal for user-mode, as is anything higher.
            DPF_ERR("Driver did not handle Lock call. App may Access Violate");

            // Unlink the rect list item.
            if( parl )
            {
                this->lpRectList = parl->lpLink;
                MemFree( parl );
            }

            // Now unlock the surface and bail.
            this->dwUsageCount--;
            CHANGE_GLOBAL_CNT( pdrv, this, -1 );
            DONE_LOCK_EXCLUDE();
            LEAVE_DDRAW();

            return DDERR_SURFACEBUSY;  //GEE: Strange error to use, but most appropriate
        #else // WIN95
            DPF(4,"Driver did not handle Lock call.  Figure something out.");

            // Get a pointer to the surface bits.
            if( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
            {
                *pbits = (LPVOID) pdrv->vmiData.fpPrimary;
            }
            else
            {
                *pbits = (LPVOID) this->fpVidMem;
            }

            if( ld.bHasRect)
            {
                DWORD   bpp;
                DWORD   byte_offset;
                DWORD   left = (DWORD) ld.rArea.left;

                // Make the surface pointer point to the first byte of the requested rectangle.
                if( ld.lpDDSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT )
                {
                    bpp = ld.lpDDSurface->lpGbl->ddpfSurface.dwRGBBitCount;
                }
                else
                {
                    bpp = ld.lpDD->vmiData.ddpfDisplay.dwRGBBitCount;
                }
                if (ld.lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
                {
                    left &= 0xffff;
                }
                switch(bpp)
                {
                case 1:  byte_offset = left>>3;     break;
                case 2:  byte_offset = left>>2;     break;
                case 4:  byte_offset = left>>1;     break;
                case 8:  byte_offset = left;        break;
                case 16: byte_offset = left*2;      break;
                case 24: byte_offset = left *3;     break;
                case 32: byte_offset = left *4;     break;
                }
                *pbits = (LPVOID) ((DWORD)*pbits +
                                   (DWORD)ld.rArea.top * ld.lpDDSurface->lpGbl->lPitch +
                                   byte_offset);
                if (ld.lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
                {
                    ((BYTE*)*pbits) += (ld.rArea.left >> 16) * ld.lpDDSurface->lpGbl->lSlicePitch;
                }
            }
        #endif // WIN95
    } // !DDHAL_DRIVER_HANDLED

    if(!(dwFlags & DDLOCK_READONLY) && IsD3DManaged(this_lcl))
        MarkDirty(this_lcl);

    // Filled in, as promised above.
    if(parl)
    {
        parl->lpSurfaceData = *pbits;
    }

    //
    // At this point we are committed to the lock.
    //

    // stay holding the lock if needed
    if( isvramlock )
    {
#ifdef USE_ALIAS
            LPHEAPALIASINFO pheapaliasinfo;

            pheapaliasinfo = NULL;
            holdwin16lock = TRUE;

            #ifdef DEBUG
                /*
                 * Force or disable the Win16 locking behaviour
                 * dependent on the registry settings.
                 */
                if( dwRegFlags & DDRAW_REGFLAGS_DISABLENOSYSLOCK )
                    dwFlags &= ~DDLOCK_NOSYSLOCK;
                if( dwRegFlags & DDRAW_REGFLAGS_FORCENOSYSLOCK )
                    dwFlags |= DDLOCK_NOSYSLOCK;
            #endif /* DEBUG */
#endif
            DDASSERT(!(this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) ||
                     !(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE));

            if( dwFlags & DDLOCK_NOSYSLOCK )
            {
#ifdef WINNT
                if( NULL != parl )
                    parl->dwFlags |= ACCESSRECT_NOTHOLDINGWIN16LOCK;
                else
                    this->dwGlobalFlags |= DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK;
                LEAVE_DDRAW();
            }
            else
#endif /* WINNT */

#ifdef USE_ALIAS
                /*
                 * Remember that this was a VRAM style lock (need this when cleaning
                 * up).
                 */
                if( NULL != parl )
                    parl->dwFlags |= ACCESSRECT_VRAMSTYLE;
                else
                    this->dwGlobalFlags |= DDRAWISURFGBL_LOCKVRAMSTYLE;
                /*
                 * At this point we have a pointer to the non-aliased video memory which was
                 * either returned to us by the driver or which we computed ourselves. In
                 * either case, if this is a video memory style lock on a surface that is
                 * aliasable and the pointer computed lies in the range of one our aliased
                 * video memory heaps we wish to use that pointer instead of the real video
                 * memory pointer.
                 */
                if( ( this_lcl_caps & DDSCAPS_PRIMARYSURFACE ) )
                {
                    /*
                     * If we have a primary surface we need to hold the Win16 lock even
                     * though we have aliases. This is to prevent USER
                     * from coming in and changing clip lists or drawing all over our locked
                     * data.
                     */
                    DPF( 2, "Surface is primary. Holding the Win16 lock" );
                }
                else
                {
                    if( pdrv->dwFlags & DDRAWI_NEEDSWIN16FORVRAMLOCK )
                    {
                        /*
                         * For some reason this device needs the Win16 lock for VRAM surface
                         * locking. This is probably because its bankswitched or we have a
                         * DIB engine we don't understand.
                         */
                        DPF( 2, "Device needs to hold Win16 lock for VRAM surface locks" );
                    }
                    else
                    {
                        if( NULL == pdrv->phaiHeapAliases )
                        {
                            /*
                             * We don't have any heaps aliases but we are not a device which
                             * needs the Win16 lock. This means we must be an emulation or
                             * ModeX device. In which case we don't need to hold the Win16
                             * lock for the duration.
                             */
                            DDASSERT( ( pdrv->dwFlags & DDRAWI_NOHARDWARE ) || ( pdrv->dwFlags & DDRAWI_MODEX ) );
                            DPF( 2, "Emulation or ModeX device. No need to hold Win16 lock" );
                            holdwin16lock = FALSE;
                        }
                        else
                        {
                            if( this_lcl_caps & DDSCAPS_SYSTEMMEMORY )
                            {
                                /*
                                 * If the surface is an implicit system memory surface then we
                                 * take aliased style actions but we don't actually compute an alias.
                                 */
                                holdwin16lock = FALSE;
                            }
                            else
                            {
                                FLATPTR                        paliasbits;
                                LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

                                DDASSERT( this_lcl_caps & DDSCAPS_VIDEOMEMORY );

                                lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE( this );

                                // We use the cached alias if available and valid. We determine validity by comparing
                                // *pbits with the original fpVidMem that was used to compute the alias. If they match
                                // then it is safe to use the pointer.
                                // The reason we need to do this is that the driver can change the fpVidMem of the surface.
                                // This change can occur during any Lock calls or (in case of D3D Vertex / Command buffers)
                                // outside of lock (during DrawPrimitives2 DDI call). Thus we need to make sure the surface
                                // is pointing to the same memory as it was when we computed the alias. (anujg 8/13/99)
                                if( ( 0UL != lpGblMore->fpAliasedVidMem ) &&
                                    ( lpGblMore->fpAliasOfVidMem == (FLATPTR) *pbits ) )
                                {
                                    DPF( 4, "Lock vidmem pointer matches stored vidmem pointer - using cached alias" );
                                    paliasbits = lpGblMore->fpAliasedVidMem;
                                }
                                else
                                {
                                    DPF( 4, "Lock vidmem pointer does not match vidmem pointer - recomputing" );
                                    paliasbits = GetAliasedVidMem( pdrv_lcl, this_lcl, (FLATPTR) *pbits );
                                    // Store this value for future use...
                                    if (this->fpVidMem == (FLATPTR)*pbits)
                                    {
                                        lpGblMore->fpAliasedVidMem = paliasbits;
                                        lpGblMore->fpAliasOfVidMem = this->fpVidMem;
                                    }
                                }

                                if( 0UL != paliasbits )
                                {
                                    DPF( 5, "Got aliased pointer = 0x%08x", paliasbits );
                                    *pbits = (LPVOID) paliasbits;

                                    if( NULL != parl )
                                        parl->lpSurfaceData = *pbits;

                                    holdwin16lock = FALSE;
                                    pheapaliasinfo = pdrv->phaiHeapAliases;
                                }
                            }
                            /*
                             * If we have got this far for an execute buffer, it means that we have a
                             * pointer to system memory even though the DDSCAPS_SYSTEMMEMORY is not
                             * set. Thus it is ok to not hold the win16 lock, etc.
                             * Basically what this amounts to is that we never take the win16 lock
                             * for execute buffers. We first try and see if we can find an alias
                             * to the pointer, and if we can't we assume it is in system memory and
                             * not take the win16 lock in any case. (anujg 4/7/98)
                             */
                            if( this_lcl_caps & DDSCAPS_EXECUTEBUFFER )
                            {
                                holdwin16lock = FALSE;
                            }
                        }
                    }
                }
            }

            if( !holdwin16lock )
            {
                /*
                 * We have an aliased lock so we don't need to hold onto the Win16
                 * and busy bit. However, we do need to clear the VRAM bit in the
                 * PDEVICE (if we have not done this already). We also need to
                 * patch the DIB engine to correct the some of the problems we
                 * have in turning the VRAM bit off. Once that is done we can
                 * release the Win16 lock and BUSY bit.
                 *
                 * NOTE: We only need do this if there are no outstanding aliased
                 * locks off this device
                 *
                 * NOTE #2: We also do not need to do this for aliased locks to
                 * execute buffers as this is just trying to prevent DIB Engine
                 * from using HW accelleration when there is an outstanding aliased lock
                 * This is not necessary for the new HW which will be implementing EB
                 * in video memory
                 */
                if( 0UL == pdrv->dwAliasedLockCnt && !(this_lcl_caps & DDSCAPS_EXECUTEBUFFER))
                {
                    BOOL vrambitset;

                    pdflags = pdrv->lpwPDeviceFlags;

                    /*
                     * Clear the PDEVICE's VRAM bit and return its previous status
                     * in vrambit
                     */
                    vrambitset = 0;
                    _asm
                    {
                        mov eax, pdflags
                        btr word ptr [eax], VRAM_BIT
                        adc vrambitset,0
                    }

                    /*
                     * We use a global device object flag to remember the original
                     * state of the VRAM flag.
                     */
                    if( vrambitset )
                    {
                        /*
                         * The VRAM bit in the PDEVICE was set. Need to record the fact
                         * that it was cleared by a lock (so we can put the correct
                         * state back).
                         */
                        DPF( 4, "VRAM bit was cleared for lock of surface 0x%08x", this_lcl );
                        pdrv->dwFlags |= DDRAWI_PDEVICEVRAMBITCLEARED;
                    }
                    #ifdef DEBUG
                        else
                        {
                            /*
                             * NOTE: This can happen if we are running emulated.
                             */
                            DPF( 4, "VRAM bit was already clear on lock of surface 0x%08x", this_lcl );
                            DDASSERT( !( pdrv->dwFlags & DDRAWI_PDEVICEVRAMBITCLEARED ) );
                        }
                    #endif
                }

                /*
                 * Bump the count on the number of outstanding aliased locks.
                 */
                pdrv->dwAliasedLockCnt++;
                if(!(this_lcl_caps & DDSCAPS_EXECUTEBUFFER))
                {
                    // This is used to check if the graphics adapter is busy for Blts, Flips, etc
                    // instead of dwAliasedLockCnt. This enables Blts & Flips when we have an
                    // outstanding aliased lock to an exceute buffer since this will be common
                    // in D3D. We increment this is all other cases to preserve original behavior.
                    if( ( pdrv->lpDDKernelCaps == NULL ) ||
                        !( pdrv->lpDDKernelCaps->dwCaps  & DDKERNELCAPS_LOCK ) )
                    {
                        pdrv->dwBusyDueToAliasedLock++;
                    }
                }

                /*
                 * If we are a real video memory surface then we need to hold a
                 * reference to the heap aliases so they don't go away before we
                 * unlock.
                 */
                if( NULL != pheapaliasinfo )
                {
                    DDASSERT( this_lcl_caps & DDSCAPS_VIDEOMEMORY );
                    DDASSERT( pheapaliasinfo->dwFlags & HEAPALIASINFO_MAPPEDREAL );
                    pheapaliasinfo->dwRefCnt++;
                }

                /*
                 * Remember that this lock is using an alias and not holding the Win16 lock.
                 */
                if( NULL != parl )
                {
                    parl->lpHeapAliasInfo = pheapaliasinfo;
                    parl->dwFlags |= ACCESSRECT_NOTHOLDINGWIN16LOCK;
                }
                else
                {
                    this_lcl->lpSurfMore->lpHeapAliasInfo = pheapaliasinfo;
                    this->dwGlobalFlags |= DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK;
                }

                /*
                 * All has gone well so there is no need to hold the Win16 lock and busy
                 * bit. Release them now.
                 */
                doneBusyWin16Lock( pdrv );

                /*
                 * We do not hold the DirectDraw critical section across the lock
                 * either.
                 */
                LEAVE_DDRAW();

                DPF( 5, "Win16 lock not held for lock of surface 0x%08x", this_lcl );
            }
            else
        #endif /* USE_ALIAS */
        {
            /*
             * We don't LEAVE_DDRAW() to avoid race conditions (someone
             * could ENTER_DDRAW() and then wait on the Win16 lock but we
             * can't release it because we can't get in the critical
             * section).
             * Even though we don't take the Win16 lock under NT, we
             * continue to hold the DirectDraw critical section as
             * long as a vram surface is locked.
             */
            pdrv->dwWin16LockCnt++;

            DPF( 5, "Win16 lock was held for lock of surface 0x%08x", this_lcl );
        }
    }
    else
    {
        LEAVE_DDRAW();
    }
    return DD_OK;

} /* InternalLock */


/*
 * InternalUnlock
 */
HRESULT InternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID lpSurfaceData,
                        LPRECT lpDestRect, DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    DWORD                       rc;
    DDHAL_UNLOCKDATA            uld;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDHALSURFCB_UNLOCK        ulhalfn;
    LPDDHALSURFCB_UNLOCK        ulfn;
    BOOL                        emulation;
    LPACCESSRECTLIST            parl;
    DWORD                       caps;
    BOOL                        holdingwin16;
#ifdef USE_ALIAS
    LPHEAPALIASINFO             pheapaliasinfo;
    BOOL                        lockbroken = FALSE;
#endif /* USE_ALIAS */

    DDASSERT(lpSurfaceData == NULL || lpDestRect == NULL);

    this = this_lcl->lpGbl;
    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;
    caps = this_lcl->ddsCaps.dwCaps;

    if( this->dwUsageCount == 0 )
    {
        DPF_ERR( "ERROR: Surface not locked." );
        return DDERR_NOTLOCKED;
    }

    ENTER_DDRAW();

    /* under NT we cannot compare the locked ptr with fpPrimary since
     * a user-mode address may not necesarily match a kernel-mode
     * address. Now we allocate an ACCESSRECTLIST structure on every
     * lock, and store the user's vidmem ptr in that. The user's
     * vidmem ptr cannot change between a lock and an unlock because
     * the surface will be locked during that time (!) (even tho the
     * physical ram that's mapped at that address might change... that
     * win16lock avoidance thing).  This is a very very small
     * performance hit over doing it the old way. ah well. jeffno
     * 960122 */

    if( NULL != this->lpRectList )
    {
        DDASSERT(!(this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) ||
                  !(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE));
        /*
         * One or more locks are active on this surface.
         */
        if( NULL != lpDestRect || NULL != lpSurfaceData )
        {
            LPACCESSRECTLIST    last;
            BOOL                found;

            found = FALSE;

            /*
             * The locked region of the surface is specified by either a
             * dest rect or a surface pointer (but never both).  Find the
             * specified region in our list of locked regions on this surface.
             */
            last = NULL;
            parl = this->lpRectList;

            if( NULL != lpDestRect )
            {
                /*
                 * Locked region of surface is specified by dest rect.
                 */
                while( parl != NULL )
                {
                    if( !memcmp(&parl->rDest, lpDestRect, sizeof(RECT)) )
                    {
                        found = TRUE;
                        break;
                    }
                    last = parl;
                    parl = parl->lpLink;
                }
            }
            else
            {
                /*
                 * Locked region of surface is specified by surface ptr.
                 */
                while( parl != NULL )
                {
                    if( parl->lpSurfaceData == lpSurfaceData )
                    {
                        found = TRUE;
                        break;
                    }
                    last = parl;
                    parl = parl->lpLink;
                }
            }

            /*
             * did we find a match?
             */
            if( !found )
            {
                DPF_ERR( "Specified rectangle is not a locked area" );
                LEAVE_DDRAW();
                return DDERR_NOTLOCKED;
            }

            /*
             * make sure unlocking process is the one who locked it
             */
            if( pdrv_lcl != parl->lpOwner )
            {
                DPF_ERR( "Current process did not lock this rectangle" );
                LEAVE_DDRAW();
                return DDERR_NOTLOCKED;
            }

            /*
             * delete this rect
             */
            if( last == NULL )
            {
                this->lpRectList = parl->lpLink;
            }
            else
            {
                last->lpLink = parl->lpLink;
            }
        }
        else
        {
            // Both lpDestRect and lpSurfaceData are null, so there better be
            // only one lock on the surface - the whole thing.  Make sure that
            // if no rectangle was specified that there's only one entry in the
            // access list - the one that was made during lock.
            parl = this->lpRectList;
            if( parl->lpLink == NULL )
            {
                DPF(5,"--Unlock: parl->rDest really set to (L=%d,T=%d,R=%d,B=%d)",
                    parl->rDest.left, parl->rDest.top, parl->rDest.right, parl->rDest.bottom);

                /*
                 * make sure unlocking process is the one who locked it
                 */
                if( pdrv_lcl != parl->lpOwner )
                {
                    DPF_ERR( "Current process did not lock this rectangle" );
                    LEAVE_DDRAW();
                    return DDERR_NOTLOCKED; //what's a better error than this?
                }

                this->lpRectList = NULL;
            }
            else
            {
                DPF_ERR( "Multiple locks on surface -- you must specify a rectangle" );
                LEAVE_DDRAW();
                return DDERR_INVALIDRECT;
            }
        }
        DDASSERT( NULL != parl );
        if( parl->dwFlags & ACCESSRECT_NOTHOLDINGWIN16LOCK )
        {
            holdingwin16 = FALSE;
#ifdef USE_ALIAS
            /*
             * This flag should only be set for VRAM style locks.
             */
            DDASSERT( parl->dwFlags & ACCESSRECT_VRAMSTYLE );
            pheapaliasinfo = parl->lpHeapAliasInfo;
#endif /* USE_ALIAS */
        }
        else
        {
            holdingwin16 = TRUE;
        }
#ifdef USE_ALIAS
        if( parl->dwFlags & ACCESSRECT_BROKEN )
            lockbroken = TRUE;
#endif /* USE_ALIAS */
        MemFree( parl );
    }
    else
    {
        /*
         * Lock of the entire surface (no access rect). Determine whether
         * this lock held the Win16 lock by using global surface object
         * flags (as we have no access rect).
         */
        if( this->dwGlobalFlags & DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK )
        {
            holdingwin16 = FALSE;
#ifdef USE_ALIAS
            /*
             * This flag should only get set for VRAM style locks.
             */
            DDASSERT( this->dwGlobalFlags & DDRAWISURFGBL_LOCKVRAMSTYLE );
            pheapaliasinfo = this_lcl->lpSurfMore->lpHeapAliasInfo;
            this_lcl->lpSurfMore->lpHeapAliasInfo = NULL;
#endif /* USE_ALIAS */
        }
        else
        {
            holdingwin16 = TRUE;
        }
#ifdef USE_ALIAS
        if( this->dwGlobalFlags & DDRAWISURFGBL_LOCKBROKEN )
            lockbroken = TRUE;
#endif /* USE_ALIAS */
        this->dwGlobalFlags &= ~( DDRAWISURFGBL_LOCKVRAMSTYLE |
                                  DDRAWISURFGBL_LOCKBROKEN    |
                                  DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK );
    }

    #ifdef WINNT
        if (this->dwGlobalFlags & DDRAWISURFGBL_NOTIFYWHENUNLOCKED)
        {
            if (--dwNumLockedWhenModeSwitched == 0)
            {
                NotifyDriverOfFreeAliasedLocks();
            }
            this->dwGlobalFlags &= ~DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
        }
    #endif

    /*
     * remove one of the users...
     */
    this->dwUsageCount--;
    CHANGE_GLOBAL_CNT( pdrv, this, -1 );

    #ifdef USE_ALIAS
    /*
     * The semantics I have choosen for surfaces which are locked when they
     * get themselves invalidates is to make the application call unlock the
     * appropriate number of times (this for our housekeeping and also for
     * back compatability with existing applications which don't expect to
     * lose locked surfaces and so we be set up to call lock regardless.
     * However, in the case of surfaces that are released when locked we
     * break the locks but don't call the unlock method in the driver we
     * mirror that here. If a lock has been broken we don't call the HAL.
     */
    if( !lockbroken )
    {
    #endif /* USE_ALIAS */
        /*
         * Is this an emulation surface or driver surface?
         *
         * NOTE: Different HAL entry points for execute
         * buffers.
         */
        if( (caps & DDSCAPS_SYSTEMMEMORY) ||
            (this_lcl->dwFlags & DDRAWISURF_HELCB) )
        {
            if( caps & DDSCAPS_EXECUTEBUFFER )
                ulfn = pdrv_lcl->lpDDCB->HELDDExeBuf.UnlockExecuteBuffer;
            else
                ulfn = pdrv_lcl->lpDDCB->HELDDSurface.Unlock;
            ulhalfn = ulfn;
            emulation = TRUE;
        }
        else
        {
            if( caps & DDSCAPS_EXECUTEBUFFER )
            {
                ulfn = pdrv_lcl->lpDDCB->HALDDExeBuf.UnlockExecuteBuffer;
                ulhalfn = pdrv_lcl->lpDDCB->cbDDExeBufCallbacks.UnlockExecuteBuffer;
            }
            else
            {
                ulfn = pdrv_lcl->lpDDCB->HALDDSurface.Unlock;
                ulhalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.Unlock;
            }
            emulation = FALSE;
        }

        /*
         * Let the driver know about the unlock.
         */
        uld.ddRVal = DD_OK;
        if( ulhalfn != NULL )
        {
            uld.Unlock = ulhalfn;
            uld.lpDD = pdrv;
            uld.lpDDSurface = this_lcl;

            if( caps & DDSCAPS_EXECUTEBUFFER )
            {
                DOHALCALL( UnlockExecuteBuffer, ulfn, uld, rc, emulation );
            }
            else
            {
                DOHALCALL( Unlock, ulfn, uld, rc, emulation );
            }

            if( rc != DDHAL_DRIVER_HANDLED )
            {
                uld.ddRVal = DD_OK;
            }
        }
    #ifdef USE_ALIAS
        }
        else
        {
            DPF( 4, "Lock broken - not calling HAL on Unlock" );
            uld.ddRVal = DD_OK;
        }
    #endif /* USE_ALIAS */
    /* Release the win16 lock but only if the corresponding lock took
     * the win16 lock which in the case of the API level lock and
     * unlock calls is if the user requests it and the surface was not
     * explicitly allocated in system memory.
     *
     * IMPORTANT NOTE: Again we no longer only do this for the first lock
     * on a surface. This matches the code path for lock.
     */
    if( ( ((dwFlags & DDLOCK_TAKE_WIN16)      && !(this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED)) ||
          ((dwFlags & DDLOCK_TAKE_WIN16_VRAM) &&  (caps & DDSCAPS_VIDEOMEMORY)) )
        && (pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
    {
        DDASSERT(!(this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) ||
                  !(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE));
        if( !holdingwin16 )
        {
#ifdef USE_ALIAS
            /*
             * Cleanup the PDEVICE's VRAM bit (if this is the last outstanding
             * VRAM lock.
             */
            undoAliasedLock( pdrv );
            if(!(caps & DDSCAPS_EXECUTEBUFFER))
            {
                // This is used to check if the graphics adapter is busy for Blts, Flips, etc
                // instead of dwAliasedLockCnt. Make sure we decrement it for everything but
                // execute buffers.
                if( ( pdrv->lpDDKernelCaps == NULL ) ||
                    !( pdrv->lpDDKernelCaps->dwCaps  & DDKERNELCAPS_LOCK ) )
                {
                    pdrv->dwBusyDueToAliasedLock--;
                }
            }


            /*
             * We don't need the aliases anymore.
             *
             * NOTE: We don't actually have to have an alias. If this is
             * a VRAM style lock of an implicit system memory surface then
             * no alias is actually used.
             */
            if( NULL != pheapaliasinfo )
            {
                DDASSERT( 0UL != pdrv_lcl->hDDVxd );
                ReleaseHeapAliases( (HANDLE) pdrv_lcl->hDDVxd, pheapaliasinfo );
            }
#endif /* USE_ALIAS */
        }
        else
        {
            tryDoneLock( pdrv_lcl, 0 );
        }
        /*
         * If it was a vram lock then we did not release the DirectDraw critical
         * section on the lock. We need to release it now.
         */
    }

    // Unexclude the cursor if it was excluded in Lock.
    DONE_LOCK_EXCLUDE();

    LEAVE_DDRAW();
    return uld.ddRVal;

} /* InternalUnlock */

#undef DPF_MODNAME
#define DPF_MODNAME     "Lock"

/*
 * DD_Surface_Lock
 *
 * Allows access to a surface.
 *
 * A pointer to the video memory is returned. The primary surface
 * can change from call to call, if page flipping is turned on.
 */

//#define ALLOW_COPY_ON_LOCK

#ifdef ALLOW_COPY_ON_LOCK
HDC hdcPrimaryCopy=0;
HBITMAP hbmPrimaryCopy=0;
#endif

HRESULT DDAPI DD_Surface_Lock(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPRECT lpDestRect,
    LPDDSURFACEDESC lpDDSurfaceDesc,
    DWORD dwFlags,
    HANDLE hEvent )
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    DWORD                       this_lcl_caps;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    HRESULT ddrval;
    LPVOID pbits;
    BOOL fastlock;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Lock %p", ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface)->lpLcl);
    if (lpDestRect != NULL)
        DPF(2,A,"Lock rectangle (%d, %d, %d, %d)", lpDestRect->left, lpDestRect->top, lpDestRect->right, lpDestRect->bottom);
    /* DPF_ENTERAPI(lpDDSurface); */

    /*
     * Problem: Under NT, there is no cross-process pointer to any given video-memory surface.
     * So how do you tell if an lpVidMem you passed back to the user is the same as the fpPrimaryOrig that
     * was previously stored in the ddraw gbl struct? You can't. Previously, we did a special case lock
     * when the user requested the whole surface (lpDestRect==NULL). Now we allocate a ACCESSRECTLIST
     * structure on every lock, and if lpDestRect==NULL, we put the top-left vidmemptr into that structure.
     * Notice we can guarantee that this ptr will be valid at unlock time because the surface remains
     * locked for all that time (obviously!).
     * This is a minor minor minor perf hit, but what the hey.
     * jeffno 960122
     */

    TRY
    {
        /*
     * validate parms
     */
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        this_lcl_caps = this_lcl->ddsCaps.dwCaps;
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
        pdrv = pdrv_lcl->lpGbl;

        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        fastlock = (this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7) &&
                    (NULL == pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus ||
                        !(this->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED)) &&
                    !(this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) &&
                    (this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED) &&
                    (this_lcl_caps & DDSCAPS_TEXTURE);

#ifndef DEBUG
        if(!fastlock)
#endif
        {
            if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
            {
                DPF_ERR( "It is an optimized surface" );
                LEAVE_DDRAW();
                return DDERR_ISOPTIMIZEDSURFACE;
            }

            if( dwFlags & ~DDLOCK_VALID )
            {
                DPF_ERR( "Invalid flags" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }

            if (!LOWERTHANSURFACE7(this_int))
            {
                if (dwFlags & DDLOCK_DONOTWAIT)
                {
                    dwFlags &= ~DDLOCK_WAIT;
                }
                else
                {
                    dwFlags |= DDLOCK_WAIT;
                }
            }

            if( !VALID_DDSURFACEDESC_PTR( lpDDSurfaceDesc ) &&
                !VALID_DDSURFACEDESC2_PTR( lpDDSurfaceDesc ) )
            {
                DPF_ERR( "Invalid surface description ptr" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
            lpDDSurfaceDesc->lpSurface = NULL;

            /*
             * Make sure the process locking this surface is the one
             * that created it.
             */
            if( this_lcl->dwProcessId != GetCurrentProcessId() )
            {
                DPF_ERR( "Current process did not create this surface" );
                LEAVE_DDRAW();
                return DDERR_SURFACEBUSY;
            }

            /* Check out the rectangle, if any.
             *
             * NOTE: We don't allow the specification of a rectangle with an
             * execute buffer.
             */
            if( lpDestRect != NULL )
            {
                if( !VALID_RECT_PTR( lpDestRect ) || ( this_lcl_caps & DDSCAPS_EXECUTEBUFFER ) )
                {
                    DPF_ERR( "Invalid destination rectangle pointer" );
                    LEAVE_DDRAW();
                    return DDERR_INVALIDPARAMS;
                } // valid pointer

                /*
                 * make sure rectangle is OK
                 */
                if( (lpDestRect->left < 0) ||
                    (lpDestRect->top < 0) ||
                    (lpDestRect->left > lpDestRect->right) ||
                    (lpDestRect->top > lpDestRect->bottom) ||
                    (lpDestRect->bottom > (int) (DWORD) this->wHeight) ||
                    (lpDestRect->right > (int) (DWORD) this->wWidth) )
                {
                    DPF_ERR( "Invalid rectangle given" );
                    LEAVE_DDRAW();
                    return DDERR_INVALIDPARAMS;
                } // checking rectangle
            }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    if(fastlock)
    {
        DPF(4, "Performing fast lock");
        lpDDSurfaceDesc->lpSurface = NULL;
#ifdef DEBUG
        if(this->fpVidMem != (FLATPTR)NULL)
        {
            if(this->fpVidMem != (FLATPTR)0xFFBADBAD)
#endif
            {
                if(this->dwUsageCount == 0)
                {
                    FlushD3DStates(this_lcl);
#if COLLECTSTATS
                    if(this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
                        ++this_lcl->lpSurfMore->lpDD_lcl->dwNumTexLocks;
#endif
                    if( lpDestRect != NULL )
                    {
                        DWORD   byte_offset;
                        /*
                         * Add a rect to the region list if this is a managed surface and not a read only lock
                         */
                        if(IsD3DManaged(this_lcl) && !(dwFlags & DDLOCK_READONLY))
                        {
                            LPREGIONLIST lpRegionList = this_lcl->lpSurfMore->lpRegionList;
                            if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                            {
                                lpRegionList->rect[(lpRegionList->rdh.nCount)++] = *((LPRECTL)lpDestRect);
                                lpRegionList->rdh.nRgnSize += sizeof(RECT);
                                if(lpDestRect->left < lpRegionList->rdh.rcBound.left)
                                    lpRegionList->rdh.rcBound.left = lpDestRect->left;
                                if(lpDestRect->right > lpRegionList->rdh.rcBound.right)
                                    lpRegionList->rdh.rcBound.right = lpDestRect->right;
                                if(lpDestRect->top < lpRegionList->rdh.rcBound.top)
                                    lpRegionList->rdh.rcBound.top = lpDestRect->top;
                                if(lpDestRect->bottom > lpRegionList->rdh.rcBound.bottom)
                                    lpRegionList->rdh.rcBound.bottom = lpDestRect->bottom;
                            }
                            MarkDirty(this_lcl);
                        }
                        // Make the surface pointer point to the first byte of the requested rectangle.
                        switch((this_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? this->ddpfSurface.dwRGBBitCount : pdrv->vmiData.ddpfDisplay.dwRGBBitCount)
                        {
                        case 1:  byte_offset = ((DWORD)lpDestRect->left)>>3;   break;
                        case 2:  byte_offset = ((DWORD)lpDestRect->left)>>2;   break;
                        case 4:  byte_offset = ((DWORD)lpDestRect->left)>>1;   break;
                        case 8:  byte_offset = (DWORD)lpDestRect->left;        break;
                        case 16: byte_offset = (DWORD)lpDestRect->left*2;      break;
                        case 24: byte_offset = (DWORD)lpDestRect->left*3;      break;
                        case 32: byte_offset = (DWORD)lpDestRect->left*4;      break;
                        }
                        pbits = (LPVOID) ((ULONG_PTR)this->fpVidMem + (DWORD)lpDestRect->top * this->lPitch + byte_offset);
                    }
                    else
                    {
                        /*
                         * We are locking the whole surface, so by setting nCount to the
                         * max number of dirty rects allowed, we will force the cache
                         * manager to update the entire surface
                         */
                        if(IsD3DManaged(this_lcl) && !(dwFlags & DDLOCK_READONLY))
                        {
                            this_lcl->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
                            MarkDirty(this_lcl);
                        }
                        pbits = (LPVOID) this->fpVidMem;
                    }
                    // Increment the usage count of this surface.
                    this->dwUsageCount++;
                    // Reset hardware op status
                    this->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                    // Free cached RLE data
                    if( GET_LPDDRAWSURFACE_GBL_MORE(this)->dwHELReserved )
                    {
                        MemFree( (void *)(GET_LPDDRAWSURFACE_GBL_MORE(this)->dwHELReserved) );
                        GET_LPDDRAWSURFACE_GBL_MORE(this)->dwHELReserved = 0;
                    }
                    this->dwGlobalFlags |= DDRAWISURFGBL_FASTLOCKHELD;
                    ddrval = DD_OK;
                }
                else
                {
                    DPF_ERR("Surface already locked");
                    ddrval = DDERR_SURFACEBUSY;
                }
            }
#ifdef DEBUG
            else
            {
                this->dwGlobalFlags |= DDRAWISURFGBL_FASTLOCKHELD;
                ddrval = DD_OK;
            }
        }
        else
        {
            ddrval = DDERR_GENERIC;
        }
#endif
    }
    else
    {
        // Params are okay, so call InternalLock() to do the work.
        ddrval = InternalLock(this_lcl, &pbits, lpDestRect, dwFlags | DDLOCK_TAKE_WIN16 | DDLOCK_FAILEMULATEDNTPRIMARY);
    }

    if(ddrval != DD_OK)
    {
        if( (ddrval != DDERR_WASSTILLDRAWING) && (ddrval != DDERR_SURFACELOST) )//both useless as spew
        {
            DPF_ERR("InternalLock failed.");
        }
        LEAVE_DDRAW();
        return ddrval;
    }

    if (dwFlags & DDLOCK_READONLY)
        this->dwGlobalFlags |= DDRAWISURFGBL_READONLYLOCKHELD;
    else
        this->dwGlobalFlags &= ~DDRAWISURFGBL_READONLYLOCKHELD;


    FillEitherDDSurfaceDesc( this_lcl, (LPDDSURFACEDESC2) lpDDSurfaceDesc );
    lpDDSurfaceDesc->lpSurface = pbits;

    DPF_STRUCT(3,A,DDSURFACEDESC,lpDDSurfaceDesc);

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_Lock */

#undef DPF_MODNAME
#define DPF_MODNAME     "Unlock"


/*
 * Perform the parameter checking and surface unlocking for the
 * IDirectDrawSurface::Unlock API call.  This function is called
 * from both the DD_Surface_Unlock and DD_Surface_Unlock4 entry
 * points.  Argument lpSurfaceData is always NULL when the call
 * is from DD_SurfaceUnlock4, and argument lpDestRect is always
 * NULL when the call is from DD_Surface_Unlock.
 */
HRESULT unlockMain(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPVOID lpSurfaceData,
    LPRECT lpDestRect )
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPACCESSRECTLIST            parl;
    HRESULT                     err;

    /*
     * validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
        pdrv = pdrv_lcl->lpGbl;

#ifndef DEBUG
        if(!(this->dwGlobalFlags & DDRAWISURFGBL_FASTLOCKHELD))
#endif
        {
            //
            // For now, if the current surface is optimized, quit
            //
            if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
            {
                DPF_ERR( "It is an optimized surface" );
                return DDERR_ISOPTIMIZEDSURFACE;
            }

            if (lpDestRect != NULL)
            {
                /*
                 * Make sure the specified rectangle pointer is valid.
                 */
                if (!VALID_RECT_PTR(lpDestRect))
                {
                    DPF_ERR( "Invalid destination rectangle pointer" );
                    return DDERR_INVALIDPARAMS;
                }
            }

            /*
             * make sure process accessed this surface
             */
            if( this_lcl->dwProcessId != GetCurrentProcessId() )
            {
                DPF_ERR( "Current process did not lock this surface" );
                return DDERR_NOTLOCKED;
            }

            /*
             * was surface accessed?
             */
            if( this->dwUsageCount == 0 )
            {
                return DDERR_NOTLOCKED;
            }

            /*
             * if the usage count is bigger than one, then you had better tell
             * me what region of the screen you were using...
             */
            if( this->dwUsageCount > 1 && lpSurfaceData == NULL && lpDestRect == NULL)
            {
                return DDERR_INVALIDRECT;
            }

            /*
             * We don't want apps to hold a DC when the surface is not locked,
             * but failing right now could cause regression issues, so we will
             * output a banner when we see this an fail on the new interfaces.
             */
            if( ( this_lcl->dwFlags & DDRAWISURF_HASDC ) &&
                !( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
            {
                DPF_ERR( "***************************************************" );
                DPF_ERR( "** Application called Unlock w/o releasing the DC!!" );
                DPF_ERR( "***************************************************" );

                if( ( this_int->lpVtbl != &ddSurfaceCallbacks ) &&
                    ( this_int->lpVtbl != &ddSurface2Callbacks ) )
                {
                    return DDERR_GENERIC;
                }
            }

            /*
             * if no rect list, no one has locked
             */
            parl = this->lpRectList;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if(this->dwGlobalFlags & DDRAWISURFGBL_FASTLOCKHELD)
    {
        DPF(4, "Performing fast unlock");
        --this->dwUsageCount;
        DDASSERT(this->dwUsageCount == 0);
        err = DD_OK;
        this->dwGlobalFlags &= ~DDRAWISURFGBL_FASTLOCKHELD;
    }
    else
    {
        err = InternalUnlock(this_lcl,lpSurfaceData,lpDestRect,DDLOCK_TAKE_WIN16);
    }

    //We only bump the surface stamp if the lock was NOT read only
    if ( (this->dwGlobalFlags & DDRAWISURFGBL_READONLYLOCKHELD) == 0)
    {
        DPF(4,"Bumping surface stamp");
        BUMP_SURFACE_STAMP(this);
    }
    this->dwGlobalFlags &= ~DDRAWISURFGBL_READONLYLOCKHELD;

    #ifdef WINNT
        if( SURFACE_LOST( this_lcl ) )
        {
            err = DDERR_SURFACELOST;
        }
    #endif

    return err;

} /* unlockMain */


/*
 * DD_Surface_Unlock
 *
 * Done accessing a surface.  This is the version used for interfaces
 * IDirectDrawSurface, IDirectDrawSurface2, and IDirectDrawSurface3.
 */
HRESULT DDAPI DD_Surface_Unlock(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPVOID lpSurfaceData )
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    HRESULT                     ddrval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Unlock %p", lpDDSurface);

    ddrval = unlockMain(lpDDSurface, lpSurfaceData, NULL);

    LEAVE_DDRAW();

    return (ddrval);

}  /* DD_Surface_Unlock */


/*
 * DD_Surface_Unlock4
 *
 * Done accessing a surface.  This is the version used for interfaces
 * IDirectDrawSurface4 and higher.
 */
HRESULT DDAPI DD_Surface_Unlock4(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPRECT lpDestRect )
{
    HRESULT ddrval;
    RECT rDest;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Unlock4");

    ddrval = unlockMain(lpDDSurface, NULL, lpDestRect);

    LEAVE_DDRAW();

    return (ddrval);

}  /* DD_Surface_Unlock4 */


#ifdef USE_ALIAS
    /*
     * BreakSurfaceLocks
     *
     * Mark any locks held by a surface as broken. This is called when
     * invalidating a surface (due to a mode switch). The semantics are
     * that a surface destroy is an implict unlock on all locks on the
     * surface. Thus, we don't call the HAL unlock, only the HAL destroy.
     */
    void BreakSurfaceLocks( LPDDRAWI_DDRAWSURFACE_GBL this )
    {
        LPACCESSRECTLIST lpRect;

        DPF( 4, "Breaking locks on the surface 0x%08x", this );

        if( 0UL != this->dwUsageCount )
        {
            if( NULL != this->lpRectList )
            {
                for( lpRect = this->lpRectList; NULL != lpRect; lpRect = lpRect->lpLink )
                    lpRect->dwFlags |= ACCESSRECT_BROKEN;
            }
            else
            {
                DDASSERT( 1UL == this->dwUsageCount );

                this->dwGlobalFlags |= DDRAWISURFGBL_LOCKBROKEN;
            }
        }
    } /* BreakSurfaceLocks */
#endif /* USE_ALIAS */

/*
 * RemoveProcessLocks
 *
 * Remove all Lock calls made a by process on a surface.
 * assumes driver lock is taken
 */
void RemoveProcessLocks(
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl,
    LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
    DWORD pid )
{
    LPDDRAWI_DIRECTDRAW_GBL   pdrv=pdrv_lcl->lpGbl;
    LPDDRAWI_DDRAWSURFACE_GBL this=this_lcl->lpGbl;
    DWORD                     refcnt;
    LPACCESSRECTLIST          parl;
    LPACCESSRECTLIST          last;
    LPACCESSRECTLIST          next;

    /*
     * remove all rectangles we have accessed
     */
    refcnt = (DWORD) this->dwUsageCount;
    if( refcnt == 0 )
    {
        return;
    }
    parl = this->lpRectList;
    last = NULL;
    while( parl != NULL )
    {
        next = parl->lpLink;
        if( parl->lpOwner == pdrv_lcl )
        {
            DPF( 5, "Cleaning up lock to rectangle (%ld,%ld),(%ld,%ld) by pid %08lx",
                 parl->rDest.left,parl->rDest.top,
                 parl->rDest.right,parl->rDest.bottom,
                 pid );
            refcnt--;
            this->dwUsageCount--;
            CHANGE_GLOBAL_CNT( pdrv, this, -1 );
            #ifdef USE_ALIAS
                /*
                 * If this was a vram style lock and it didn't hold the Win16 lock
                 * then we need to decrement the number of aliased locks held.
                 */
                if( ( parl->dwFlags & ACCESSRECT_VRAMSTYLE ) &&
                    ( parl->dwFlags & ACCESSRECT_NOTHOLDINGWIN16LOCK ) )
                {
                    DDASSERT( 0UL != pdrv->dwAliasedLockCnt );
                    undoAliasedLock( pdrv );
                    if(!(this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
                    {
                        // This is used to check if the graphics adapter is busy for Blts, Flips, etc
                        // instead of dwAliasedLockCnt. Make sure we decrement it for everything but
                        // execute buffers.
                        if( ( pdrv->lpDDKernelCaps == NULL ) ||
                            !( pdrv->lpDDKernelCaps->dwCaps  & DDKERNELCAPS_LOCK ) )
                        {
                            pdrv->dwBusyDueToAliasedLock--;
                        }
                    }

                    /*
                     * If we are holding a referenced to an aliased heap release it
                     * now.
                     */
                    if( NULL != parl->lpHeapAliasInfo )
                        ReleaseHeapAliases( GETDDVXDHANDLE( pdrv_lcl ) , parl->lpHeapAliasInfo );
                }
            #endif /* USE_ALIAS */
            if( last == NULL )
            {
                this->lpRectList = next;
            }
            else
            {
                last->lpLink = next;
            }
            MemFree( parl );
        }
        else
        {
            last = parl;
        }
        parl = next;
    }

    #ifdef USE_ALIAS
        /*
         * Was the entire surface locked with a video memory style
         * lock (but without the Win16 lock held)? If so then we
         * again need to decrement the aliased lock count.
         */
        if( ( this->dwGlobalFlags & DDRAWISURFGBL_LOCKVRAMSTYLE ) &&
            ( this->dwGlobalFlags & DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK ) )
        {
            DDASSERT( 0UL != pdrv->dwAliasedLockCnt );
            undoAliasedLock( pdrv );
            if(!(this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
            {
                // This is used to check if the graphics adapter is busy for Blts, Flips, etc
                // instead of dwAliasedLockCnt. Make sure we decrement it for everything but
                // execute buffers.
                if( ( pdrv->lpDDKernelCaps == NULL ) ||
                   !( pdrv->lpDDKernelCaps->dwCaps  & DDKERNELCAPS_LOCK ) )
                {
                    pdrv->dwBusyDueToAliasedLock--;
                }
            }

            /*
             * If we are holding a referenced to an aliased heap release it
             * now.
             */
            if( NULL != this_lcl->lpSurfMore->lpHeapAliasInfo )
            {
                ReleaseHeapAliases( GETDDVXDHANDLE( pdrv_lcl ), this_lcl->lpSurfMore->lpHeapAliasInfo );
                this_lcl->lpSurfMore->lpHeapAliasInfo = NULL;
            }
        }
    #endif /* USE_ALIAS */

    /*
     * remove the last of the refcnts we have
     */
    this->dwUsageCount -= (short) refcnt;
    CHANGE_GLOBAL_CNT( pdrv, this, -1*refcnt );

    /*
     * clean up the win16 lock
     *
     * NOTE: This is not surface related this just breaks the Win16
     * lock and device busy bits held by the device. You realy only
     * want to do this once not once per surface.
     */

    /*
    * blow away extra locks if the the process is still alive
    */
    if( pid == GetCurrentProcessId() )
    {
        DPF( 5, "Cleaning up %ld Win16 locks", pdrv->dwWin16LockCnt );
        while( pdrv->dwWin16LockCnt > 0 )
        {
            tryDoneLock( pdrv_lcl, pid );
        }
    }
    else
    {
        /*
        * !!! NOTE: Does not reset the BUSY bit!
        */
        DPF( 4, "Process dead, resetting Win16 lock cnt" );
        pdrv->dwWin16LockCnt = 0;
    }
    DPF( 5, "Cleaned up %ld locks taken by by pid %08lx", refcnt, pid );

} /* RemoveProcessLocks */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddsblt.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsblt.c
 *  Content:    DirectDraw Surface support for blt
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   24-jan-95  craige  split out of ddsurf.c, enhanced
 *   31-jan-95  craige  and even more ongoing work...
 *   03-feb-95  craige  performance tuning, ongoing work
 *   21-feb-95  craige  work work work
 *   27-feb-95  craige  new sync. macros
 *   08-mar-95  craige  new stretch flags
 *   11-mar-95  craige  take Win16 lock on Win95 before calling 32-bit fns
 *   15-mar-95  craige  HEL integration
 *   19-mar-95  craige  use HRESULTs
 *   29-mar-95  craige  make colorfill work
 *   01-apr-95  craige  happy fun joy updated header file
 *   03-apr-95  craige  off by one when rect specified; need to validate
 *                      rectangles against surfaces
 *   12-apr-95  craige  pulled out clipped stretching code optimization for now
 *   15-apr-95  craige  can't allow source surface with colorfill; don't
 *                      allow < 0 left, top coords
 *   06-may-95  craige  use driver-level csects only
 *   11-jun-95  craige  check for locked surface before blt
 *   21-jun-95  kylej   lock non-emulated surfaces before calling HEL blt
 *   21-jun-95  craige  clipping changes
 *   24-jun-95  kylej   move video memory source surfaces to system memory
 *                      if there is no hardware blt support.
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  use clipper to do clipping; started BltBatch;
 *                      moved CheckBltStretching back in
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns; disabled alpha & Z blt
 *   04-jul-95  craige  YEEHAW: new driver struct; SEH
 *   05-jul-95  kylej   debugged clipping code and added clipped stretched blts
 *   07-jul-95  craige  added test for BUSY
 *   07-jul-95  kylej   replace inline code with call to XformRect
 *   08-jul-95  craige  BltFast: need to use HEL if src or dest is in
 *                      system memory!
 *   09-jul-95  craige  hasvram flag in MoveToSystemMemory; handle loss
 *                      of color key resource after blt
 *   10-jul-95  kylej   added mirroring caps checks in Blt
 *   13-jul-95  craige  ENTER_DDRAW is now the win16 lock
 *   16-jul-95  craige  check DDRAWISURF_HELCB
 *   27-jul-95  craige  check for color fill support in hardware!
 *   31-jul-95  craige  check Lock calls for WASSTILLDRAWING;
 *                      test for valid flags
 *   01-aug-95  craige  hold win16 early to keep busy bit test valid
 *   01-aug-95  toddla  added DD16_Exclude and DD16_Unexclude
 *   04-aug-95  craige  use InternalLock/Unlock
 *   06-aug-95  craige  do DD16_Exclude before lock, unexclude after unlock
 *   10-aug-95  toddla  added DDBLT_WAIT and DDBLTFAST_WAIT flags
 *   12-aug-95  craige  use_full_lock parm for MoveToSystemMemory and
 *                      ChangeToSoftwareColorKey
 *   23-aug-95  craige  wasn't unlocking surfaces or unexcluding cursor on
 *                      a few error conditions
 *   16-sep-95  craige  bug 1175: set return code if NULL clip list
 *   02-jan-96  kylej   handle new interface structures
 *   04-jan-96  colinmc added DDBLT_DEPTHFILL for clearing Z-buffers
 *   01-feb-96  jeffno  NT: pass user-mode ptrs to vram surfaces to HEL
 *                      in Blt and BltFast
 *   12-feb-96  colinmc Surface lost flag moved from global to local object
 *   29-feb-96  kylej   Enable System->Video bltting
 *   03-mar-96  colinmc Fixed a couple of nasty bugs causing blts to system
 *                      memory to be done by hardware
 *   21-mar-96  colinmc Bug 14011: Insufficient parameter validation on
 *                      BltFast
 *   26-mar-96  jeffno  Handle visrgn changes under NT
 *   20-apr-96  colinmc Fixed problem with releasePageLocks spinning on
 *                      busy bit
 *   23-apr-96  kylej   Bug 10196: Added check for software dest blt
 *   17-may-96  craige  bug 21499: perf problems with BltFast
 *   14-jun-96  kylej   NT Bug 38227: Internal lock was not correctly reporting
 *                      when the visrgn had changed.
 *   13-aug-96  colinmc Bug 3194: Blitting through a clipper without
 *                      DDBLT_WAIT could cause infinite loop in app.
 *   01-oct-96  ketand  Perf for clipped blits
 *   21-jan-97  ketand  Fix rectangle checking for multi-mon systems. Clip blits to
 *                      the destination surface if a clipper is used.
 *   31-jan-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *   03-mar-97  jeffno  Bug #5061: Trashing fpVidMem on blt.
 *   08-mar-97  colinmc Support for DMA style AGP parts
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   24-mar-97  jeffno  Optimized Surfaces
 *
 ***************************************************************************/
#include "ddrawpr.h"
#define DONE_BUSY()          \
    (*pdflags) &= ~BUSY; \

#define LEAVE_BOTH_NOBUSY() \
    { if(pdflags)\
        (*pdflags) &= ~BUSY; \
    } \
    LEAVE_BOTH();

#define DONE_LOCKS() \
    if( dest_lock_taken ) \
    { \
        if (subrect_lock_taken) \
        {   \
            InternalUnlock( this_dest_lcl, NULL, &subrect_lock_rect, 0);    \
            subrect_lock_taken = FALSE; \
        }       \
        else    \
        {       \
            InternalUnlock( this_dest_lcl,NULL,NULL,0 ); \
        }       \
        dest_lock_taken = FALSE; \
    } \
    if( src_lock_taken && this_src_lcl) \
    { \
        InternalUnlock( this_src_lcl,NULL,NULL,0 ); \
        src_lock_taken = FALSE; \
    }


#undef DPF_MODNAME
#define DPF_MODNAME     "BltFast"

DWORD dwSVBHack;

// turns off SEH for bltfast
#define FASTFAST

typedef struct _bltcaps
{
    LPDWORD     dwCaps;
    LPDWORD     dwFXCaps;
    LPDWORD     dwCKeyCaps;
    LPDWORD     dwRops;

    LPDWORD     dwHELCaps;
    LPDWORD     dwHELFXCaps;
    LPDWORD     dwHELCKeyCaps;
    LPDWORD     dwHELRops;

    LPDWORD     dwBothCaps;
    LPDWORD     dwBothFXCaps;
    LPDWORD     dwBothCKeyCaps;
    LPDWORD     dwBothRops;
    BOOL        bHALSeesSysmem;
    BOOL        bSourcePagelockTaken;
    BOOL        bDestPagelockTaken;
} BLTCAPS, *LPBLTCAPS;

void initBltCaps( DWORD dwDstCaps, DWORD dwDstFlags, DWORD dwSrcCaps, LPDDRAWI_DIRECTDRAW_GBL pdrv, LPBLTCAPS lpbc, LPBOOL helonly )
{
#ifdef WINNT
    BOOL bPrimaryHack = FALSE;
#endif

    if (lpbc)
    {
        /*
         * Not really expecting lpbc to be null, but this is late and I'm paranoid
         */
        lpbc->bSourcePagelockTaken = FALSE;
        lpbc->bDestPagelockTaken = FALSE;
    }

    #ifdef WINNT
        // On NT, the kernel needs to handle blts from system to the primary
        // surface, otherwise the sprite stuff won't work

        if( ( dwDstFlags & DDRAWISURFGBL_ISGDISURFACE ) &&
            ( dwDstCaps & DDSCAPS_VIDEOMEMORY ) &&
            ( dwSrcCaps & DDSCAPS_SYSTEMMEMORY ) &&
            !(pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM) &&
            ( pdrv->ddCaps.dwCaps & DDCAPS_BLT ) )
        {
            bPrimaryHack = TRUE;
            pdrv->ddCaps.dwCaps |= DDCAPS_CANBLTSYSMEM;
        }
    #endif

    if( ( ( dwSrcCaps & DDSCAPS_NONLOCALVIDMEM ) || ( dwDstCaps & DDSCAPS_NONLOCALVIDMEM ) ) &&
        ( pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS ) )
    {
        /*
         * At least one of the surfaces is non local and the device exports
         * different capabilities for non-local video memory. If this is non-local
         * to local transfer then check the appropriate caps. Otherwise force
         * emulation.
         */
        if( ( dwSrcCaps & DDSCAPS_NONLOCALVIDMEM ) && ( dwDstCaps & DDSCAPS_LOCALVIDMEM ) )
        {
            /*
             * Non-local to local video memory transfer.
             */
            DDASSERT( NULL != pdrv->lpddNLVCaps );
            DDASSERT( NULL != pdrv->lpddNLVHELCaps );
            DDASSERT( NULL != pdrv->lpddNLVBothCaps );

            /*
             * We have specific caps. Use them
             */
            lpbc->dwCaps =          &(pdrv->lpddNLVCaps->dwNLVBCaps);
            lpbc->dwFXCaps =        &(pdrv->lpddNLVCaps->dwNLVBFXCaps);
            lpbc->dwCKeyCaps =      &(pdrv->lpddNLVCaps->dwNLVBCKeyCaps);
            lpbc->dwRops =          pdrv->lpddNLVCaps->dwNLVBRops;
            lpbc->dwHELCaps =       &(pdrv->lpddNLVHELCaps->dwNLVBCaps);
            lpbc->dwHELFXCaps =     &(pdrv->lpddNLVHELCaps->dwNLVBFXCaps);
            lpbc->dwHELCKeyCaps =   &(pdrv->lpddNLVHELCaps->dwNLVBCKeyCaps);
            lpbc->dwHELRops =       pdrv->lpddNLVHELCaps->dwNLVBRops;
            lpbc->dwBothCaps =      &(pdrv->lpddNLVBothCaps->dwNLVBCaps);
            lpbc->dwBothFXCaps =    &(pdrv->lpddNLVBothCaps->dwNLVBFXCaps);
            lpbc->dwBothCKeyCaps =  &(pdrv->lpddNLVBothCaps->dwNLVBCKeyCaps);
            lpbc->dwBothRops =      pdrv->lpddNLVBothCaps->dwNLVBRops;
            lpbc->bHALSeesSysmem =  FALSE;
            return;
        }
        else if( ( dwSrcCaps & DDSCAPS_SYSTEMMEMORY ) && ( dwDstCaps & DDSCAPS_NONLOCALVIDMEM )
            && ( pdrv->ddCaps.dwCaps2 & DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL ) )
        {
            /*
             * See the definition of the above caps bit in ddrawp.h for more details
             */
            DPF(4,"System to non-local Blt is a candidate for passing to driver.");
            lpbc->dwCaps =              &(pdrv->ddCaps.dwSVBCaps);
            lpbc->dwFXCaps =    &(pdrv->ddCaps.dwSVBFXCaps);
            lpbc->dwCKeyCaps =  &(pdrv->ddCaps.dwSVBCKeyCaps);
            lpbc->dwRops =              pdrv->ddCaps.dwSVBRops;
            lpbc->dwHELCaps =   &(pdrv->ddHELCaps.dwSVBCaps);
            lpbc->dwHELFXCaps = &(pdrv->ddHELCaps.dwSVBFXCaps);
            lpbc->dwHELCKeyCaps =       &(pdrv->ddHELCaps.dwSVBCKeyCaps);
            lpbc->dwHELRops =   pdrv->ddHELCaps.dwSVBRops;
            lpbc->dwBothCaps =  &(pdrv->ddBothCaps.dwSVBCaps);
            lpbc->dwBothFXCaps =        &(pdrv->ddBothCaps.dwSVBFXCaps);
            lpbc->dwBothCKeyCaps =      &(pdrv->ddBothCaps.dwSVBCKeyCaps);
            lpbc->dwBothRops =  pdrv->ddBothCaps.dwSVBRops;
            lpbc->bHALSeesSysmem = TRUE;
            return;
        }
        else
        {
            /*
             * Non-local to non-local or local to non-local transfer. Force emulation.
             */
            *helonly = TRUE;
        }
    }

    if( !(pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM) )
    {
        if( (dwSrcCaps & DDSCAPS_SYSTEMMEMORY) || (dwDstCaps & DDSCAPS_SYSTEMMEMORY) )
        {
            *helonly = TRUE;
        }
    }
    if( ( (dwSrcCaps & DDSCAPS_VIDEOMEMORY) && (dwDstCaps & DDSCAPS_VIDEOMEMORY) ) ||
        !( pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM ) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwCaps);
        lpbc->dwFXCaps =        &(pdrv->ddCaps.dwFXCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwCKeyCaps);
        lpbc->dwRops =          pdrv->ddCaps.dwRops;
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwCaps);
        lpbc->dwHELFXCaps =     &(pdrv->ddHELCaps.dwFXCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwCKeyCaps);
        lpbc->dwHELRops =       pdrv->ddHELCaps.dwRops;
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwCaps);
        lpbc->dwBothFXCaps =    &(pdrv->ddBothCaps.dwFXCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwCKeyCaps);
        lpbc->dwBothRops =      pdrv->ddBothCaps.dwRops;
        lpbc->bHALSeesSysmem = FALSE;
    }
    else if( (dwSrcCaps & DDSCAPS_SYSTEMMEMORY) && (dwDstCaps & DDSCAPS_VIDEOMEMORY) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwSVBCaps);
        lpbc->dwFXCaps =        &(pdrv->ddCaps.dwSVBFXCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwSVBCKeyCaps);
        lpbc->dwRops =          pdrv->ddCaps.dwSVBRops;
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwSVBCaps);
        lpbc->dwHELFXCaps =     &(pdrv->ddHELCaps.dwSVBFXCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwSVBCKeyCaps);
        lpbc->dwHELRops =       pdrv->ddHELCaps.dwSVBRops;
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwSVBCaps);
        lpbc->dwBothFXCaps =    &(pdrv->ddBothCaps.dwSVBFXCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwSVBCKeyCaps);
        lpbc->dwBothRops =      pdrv->ddBothCaps.dwSVBRops;
        lpbc->bHALSeesSysmem = TRUE;
    }
    else if( (dwSrcCaps & DDSCAPS_VIDEOMEMORY) && (dwDstCaps & DDSCAPS_SYSTEMMEMORY) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwVSBCaps);
        lpbc->dwFXCaps =        &(pdrv->ddCaps.dwVSBFXCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwVSBCKeyCaps);
        lpbc->dwRops =          pdrv->ddCaps.dwVSBRops;
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwVSBCaps);
        lpbc->dwHELFXCaps =     &(pdrv->ddHELCaps.dwVSBFXCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwVSBCKeyCaps);
        lpbc->dwHELRops =       pdrv->ddHELCaps.dwVSBRops;
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwVSBCaps);
        lpbc->dwBothFXCaps =    &(pdrv->ddBothCaps.dwVSBFXCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwVSBCKeyCaps);
        lpbc->dwBothRops =      pdrv->ddBothCaps.dwVSBRops;
        lpbc->bHALSeesSysmem = TRUE;
    }
    else if( (dwSrcCaps & DDSCAPS_SYSTEMMEMORY) && (dwDstCaps & DDSCAPS_SYSTEMMEMORY) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwSSBCaps);
        lpbc->dwFXCaps =        &(pdrv->ddCaps.dwSSBFXCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwSSBCKeyCaps);
        lpbc->dwRops =          pdrv->ddCaps.dwSSBRops;
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwSSBCaps);
        lpbc->dwHELFXCaps =     &(pdrv->ddHELCaps.dwSSBFXCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwSSBCKeyCaps);
        lpbc->dwHELRops =       pdrv->ddHELCaps.dwSSBRops;
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwSSBCaps);
        lpbc->dwBothFXCaps =    &(pdrv->ddBothCaps.dwSSBFXCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwSSBCKeyCaps);
        lpbc->dwBothRops =      pdrv->ddBothCaps.dwSSBRops;
        lpbc->bHALSeesSysmem = TRUE;
    }

    #ifdef WINNT
        if( bPrimaryHack )
        {
            pdrv->ddCaps.dwCaps &= ~DDCAPS_CANBLTSYSMEM;
            dwSVBHack = DDCAPS_BLT;
            lpbc->dwCaps = &dwSVBHack;
            lpbc->dwBothCaps = &dwSVBHack;
        }
    #endif
}

__inline void initBltCapsFast(
        DWORD dwDstCaps,
        DWORD dwSrcCaps,
        LPDDRAWI_DIRECTDRAW_GBL pdrv,
        LPBLTCAPS lpbc )
{
    if (lpbc)
    {
        /*
         * Not really expecting lpbc to be null, but this is late and I'm paranoid
         */
        lpbc->bSourcePagelockTaken = FALSE;
        lpbc->bDestPagelockTaken = FALSE;
    }

    if( ( ( dwSrcCaps & DDSCAPS_NONLOCALVIDMEM ) && ( dwDstCaps && DDSCAPS_LOCALVIDMEM ) ) &&
          ( pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS ) )
    {
        DDASSERT( NULL != pdrv->lpddNLVCaps );
        lpbc->dwCaps =          &(pdrv->lpddNLVCaps->dwNLVBCaps);
        lpbc->dwHELCaps =       &(pdrv->lpddNLVHELCaps->dwNLVBCaps);
        lpbc->dwBothCaps =      &(pdrv->lpddNLVBothCaps->dwNLVBCaps);
        lpbc->dwCKeyCaps =      &(pdrv->lpddNLVCaps->dwNLVBCKeyCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->lpddNLVHELCaps->dwNLVBCKeyCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->lpddNLVBothCaps->dwNLVBCKeyCaps);
        lpbc->bHALSeesSysmem =  FALSE;
    }
    else if( ( (dwSrcCaps & DDSCAPS_VIDEOMEMORY) && (dwDstCaps & DDSCAPS_VIDEOMEMORY) ) ||
             !( pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM ) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwCaps);
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwCaps);
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwCKeyCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwCKeyCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwCKeyCaps);
        lpbc->bHALSeesSysmem = FALSE;
    }
    else if( (dwSrcCaps & DDSCAPS_SYSTEMMEMORY) && (dwDstCaps & DDSCAPS_VIDEOMEMORY) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwSVBCaps);
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwSVBCaps);
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwSVBCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwSVBCKeyCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwSVBCKeyCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwSVBCKeyCaps);
        lpbc->bHALSeesSysmem = TRUE;
    }
    else if( (dwSrcCaps & DDSCAPS_VIDEOMEMORY) && (dwDstCaps & DDSCAPS_SYSTEMMEMORY) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwVSBCaps);
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwVSBCaps);
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwVSBCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwVSBCKeyCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwVSBCKeyCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwVSBCKeyCaps);
        lpbc->bHALSeesSysmem = TRUE;
    }
    else if( (dwSrcCaps & DDSCAPS_SYSTEMMEMORY) && (dwDstCaps & DDSCAPS_SYSTEMMEMORY) )
    {
        lpbc->dwCaps =          &(pdrv->ddCaps.dwSSBCaps);
        lpbc->dwHELCaps =       &(pdrv->ddHELCaps.dwSSBCaps);
        lpbc->dwBothCaps =      &(pdrv->ddBothCaps.dwSSBCaps);
        lpbc->dwCKeyCaps =      &(pdrv->ddCaps.dwSSBCKeyCaps);
        lpbc->dwHELCKeyCaps =   &(pdrv->ddHELCaps.dwSSBCKeyCaps);
        lpbc->dwBothCKeyCaps =  &(pdrv->ddBothCaps.dwSSBCKeyCaps);
        lpbc->bHALSeesSysmem = TRUE;
    }
}

/*
 * OverlapsDevices
 *
 * This function checks for Blts that are on the destop, but not entirely
 * on the device.  When found, we will emulate the Blt (punting to GDI).
 */
BOOL OverlapsDevices( LPDDRAWI_DDRAWSURFACE_LCL lpSurf_lcl, LPRECT lpRect )
{
    LPDDRAWI_DIRECTDRAW_GBL lpGbl;
    RECT rect;

    lpGbl = lpSurf_lcl->lpSurfMore->lpDD_lcl->lpGbl;

    /*
     * If the device was explicitly specified, assume that they know
     * what they're doing.
     */
    if( lpSurf_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_EXPLICITMONITOR )
    {
        return FALSE;
    }

    /*
     * Do a real quick check w/o accounting for the clipper
     */
    if( ( lpRect->top < lpGbl->rectDevice.top ) ||
        ( lpRect->left < lpGbl->rectDevice.left ) ||
        ( lpRect->right > lpGbl->rectDevice.right ) ||
        ( lpRect->bottom > lpGbl->rectDevice.bottom ) )
    {
        /*
         * It may only be that part of the rect is off of the desktop,
         * in which case we don't neccesarily need to drop to emulation.
         */
        IntersectRect( &rect, lpRect, &lpGbl->rectDesktop );
        if( ( rect.top < lpGbl->rectDevice.top ) ||
            ( rect.left < lpGbl->rectDevice.left ) ||
            ( rect.right > lpGbl->rectDevice.right ) ||
            ( rect.bottom > lpGbl->rectDevice.bottom ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*
 * WaitForDriverToFinishWithSurface
 *
 * This function waits for the hardware driver to report that it has finished
 * operating on the given surface. We should only call this function if the
 * surface was a system memory surface involved in a DMA/busmastering transfer.
 * Note this function clears the DDRAWISURFGBL_HARDWAREOPSTARTED flags (both
 * of them).
 */
void WaitForDriverToFinishWithSurface(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    HRESULT hr;
#ifdef DEBUG
    DWORD dwStart;
    BOOL bSentMessage=FALSE;
    dwStart = GetTickCount();
#endif
    DDASSERT( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY );
    DPF(4,"Waiting for driver to finish with %08x",this_lcl->lpGbl);
    do
    {
        hr = InternalGetBltStatus( pdrv_lcl , this_lcl , DDGBS_ISBLTDONE );
#ifdef DEBUG
        if ( GetTickCount() -dwStart >= 10000 )
        {
            if (!bSentMessage)
            {
                bSentMessage = TRUE;
                DPF_ERR("Driver reports operation still pending on surface after 5s! Driver error!");
            }
        }
#endif
    } while (hr == DDERR_WASSTILLDRAWING);

    DDASSERT(hr == DD_OK);
    DPF(5,B,"Driver finished with that surface");
    this_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
}

/*
 * DD_Surface_BltFast
 *
 * Bit Blt from one surface to another FAST
 */
HRESULT DDAPI DD_Surface_BltFast(
                LPDIRECTDRAWSURFACE lpDDDestSurface,
                DWORD dwX,
                DWORD dwY,
                LPDIRECTDRAWSURFACE lpDDSrcSurface,
                LPRECT lpSrcRect,
                DWORD dwTrans )
{
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DDRAWSURFACE_INT   this_src_int;
    LPDDRAWI_DDRAWSURFACE_INT   this_dest_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_src_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL   this_dest_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this_src;
    LPDDRAWI_DDRAWSURFACE_GBL   this_dest;
    DDHAL_BLTDATA               bd;
    DWORD                       rc;
    LPDDHALSURFCB_BLT           bltfn;
    BOOL                        halonly;
    BOOL                        helonly;
    BOOL                        gdiblt;
    int                         src_height;
    int                         src_width;
    BOOL                        dest_lock_taken=FALSE;
    BOOL                        src_lock_taken=FALSE;
    LPVOID                      dest_bits;
    LPVOID                      src_bits;
    HRESULT                     ddrval;
    BLTCAPS                     bc;
    LPBLTCAPS                   lpbc = &bc;
    LPWORD                      pdflags=0;
    DWORD                       dwSourceLockFlags=0;
    DWORD                       dwDestLockFlags=0;
    BOOL                        subrect_lock_taken = FALSE;
    RECT                        subrect_lock_rect;

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_BltFast");
    /* DPF_ENTERAPI(lpDDDestSurface); */

    /*
     * prepare parameters.  An exception here is considered a bad parameter
     */

    #ifndef FASTFAST
    TRY
    #endif
    {
        ZeroMemory(&bd, sizeof(bd));    // initialize to zero

        this_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDDestSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_dest_int ) )
        {
            LEAVE_BOTH()
            return DDERR_INVALIDOBJECT;
        }
        this_dest_lcl = this_dest_int->lpLcl;
        this_dest = this_dest_lcl->lpGbl;
        if( SURFACE_LOST( this_dest_lcl ) )
        {
            DPF( 1, "Destination (%08lx) is lost", this_dest_int );
            LEAVE_BOTH();
            return DDERR_SURFACELOST;
        }

        this_src_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSrcSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_src_int ) )
        {
            LEAVE_BOTH();
            return DDERR_INVALIDOBJECT;
        }
        this_src_lcl = this_src_int->lpLcl;
        this_src = this_src_lcl->lpGbl;
        if( SURFACE_LOST( this_src_lcl ) )
        {
            DPF( 1, "Source (%08lx) is lost", this_src_int );
            LEAVE_BOTH();
            return DDERR_SURFACELOST;
        }
        if( lpSrcRect != NULL )
        {
            if( !VALID_RECT_PTR( lpSrcRect ) )
            {
                LEAVE_BOTH()
                return DDERR_INVALIDPARAMS;
            }
        }
        if( dwTrans & ~DDBLTFAST_VALID )
        {
            DPF_ERR( "Invalid flags") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

        //
        // If either surface is optimized, quit
        //
        if (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "Can't blt from an optimized surface") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

        if (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "Can't blt to optimized surfaces") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * BEHAVIOUR CHANGE FOR DX5
         *
         * We do not allow bltting between surfaces created with different DirectDraw
         * objects.
         */
        if (this_dest_lcl->lpSurfMore->lpDD_lcl->lpGbl != this_src_lcl->lpSurfMore->lpDD_lcl->lpGbl)
        {
            if ((this_dest_lcl->lpSurfMore->lpDD_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV) &&
               (this_src_lcl->lpSurfMore->lpDD_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV))
            {
                DPF_ERR("Can't blt surfaces between different direct draw devices");
                LEAVE_BOTH();
                return DDERR_DEVICEDOESNTOWNSURFACE;
            }
        }


        pdrv = this_dest->lpDD;
        pdrv_lcl = this_dest_lcl->lpSurfMore->lpDD_lcl;
#ifdef WINNT
        // Update DDraw handle in driver GBL object.
        pdrv->hDD = pdrv_lcl->hDD;
#endif

        /*
         * DX5 or greater drivers get to know about read/write only locks
         * Note that dwDestFlags may later be zeroed for dest color key.
         * We pass read+write if the blt goes to/from the same buffer, of course.
         */
        if (pdrv->dwInternal1 >= 0x500 && this_src != this_dest )
        {
            dwSourceLockFlags = DDLOCK_READONLY;
            dwDestLockFlags = DDLOCK_WRITEONLY;
        }

        #ifdef USE_ALIAS
            if( pdrv->dwBusyDueToAliasedLock > 0 )
            {
                /*
                 * Aliased locks (the ones that don't take the Win16 lock) don't
                 * set the busy bit either (it can't or USER get's very confused).
                 * However, we must prevent blits happening via DirectDraw as
                 * otherwise we get into the old host talking to VRAM while
                 * blitter does at the same time. Bad. So fail if there is an
                 * outstanding aliased lock just as if the BUST bit had been
                 * set.
                 */
                DPF_ERR( "Graphics adapter is busy (due to a DirectDraw lock)" );
                LEAVE_BOTH();
                return DDERR_SURFACEBUSY;
            }
        #endif /* USE_ALIAS */

        /*
         * Behavior change:  In DX7, the default is to wait unless DDFASTBLT_DONOTWAIT=1.
         * In earlier releases, the default was to NOT wait unless DDFASTBLT_WAIT=1.
         * (The DDFASTBLT_DONOTWAIT flag was not defined until the DX7 release.)
         */
        if (!LOWERTHANSURFACE7(this_dest_int))
        {
            if (dwTrans & DDBLTFAST_DONOTWAIT)
            {
                if (dwTrans & DDBLTFAST_WAIT)
                {
                    DPF_ERR( "WAIT and DONOTWAIT flags are mutually exclusive" );
                    LEAVE_BOTH();
                    return DDERR_INVALIDPARAMS;
                }
            }
            else
            {
                dwTrans |= DDBLTFAST_WAIT;
            }
        }

        FlushD3DStates(this_src_lcl); // Need to flush src because it could be a rendertarget
        FlushD3DStates(this_dest_lcl);

        // Test and set the busy bit.  If it was already set, bail.
        {
            BOOL    isbusy = 0;

            pdflags = pdrv->lpwPDeviceFlags;
            #ifdef WIN95
                _asm
                {
                    mov eax, pdflags
                    bts word ptr [eax], BUSY_BIT
                    adc byte ptr isbusy,0
                }
            #else
                isbusy -= (InterlockedExchange((LPDWORD)pdflags,
                    *((LPDWORD)pdflags) | (1<<BUSY_BIT) ) == (1<<BUSY_BIT) );
            #endif
            if( isbusy )
            {
                DPF( 1, "BUSY - BltFast" );
                LEAVE_BOTH();
                return DDERR_SURFACEBUSY;
            }
        }
        /*
         * The following code was added to keep all of the HALs from
         * changing their Blt() code when they add video port support.
         * If the video port was using this surface but was recently
         * flipped, we will make sure that the flip actually occurred
         * before allowing access.  This allows double buffered capture
         * w/o tearing.
         */
        if( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT )
        {
            LPDDRAWI_DDVIDEOPORT_INT lpVideoPort;
            LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort_lcl;

            // Look at all video ports to see if any of them recently
            // flipped from this surface.
            lpVideoPort = pdrv->dvpList;
            while( NULL != lpVideoPort )
            {
                lpVideoPort_lcl = lpVideoPort->lpLcl;
                if( lpVideoPort_lcl->fpLastFlip == this_src->fpVidMem )
                {
                    // This can potentially tear - check the flip status
                    LPDDHALVPORTCB_GETFLIPSTATUS pfn;
                    DDHAL_GETVPORTFLIPSTATUSDATA GetFlipData;
                    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;

                    pdrv_lcl = this_src_lcl->lpSurfMore->lpDD_lcl;
                    pfn = pdrv_lcl->lpDDCB->HALDDVideoPort.GetVideoPortFlipStatus;
                    if( pfn != NULL )  // Will simply tear if function not supproted
                    {
                        GetFlipData.lpDD = pdrv_lcl;
                        GetFlipData.fpSurface = this_src->fpVidMem;

                    KeepTrying:
                        rc = DDHAL_DRIVER_NOTHANDLED;
                        DOHALCALL_NOWIN16( GetVideoPortFlipStatus, pfn, GetFlipData, rc, 0 );
                        if( ( DDHAL_DRIVER_HANDLED == rc ) &&
                            ( DDERR_WASSTILLDRAWING == GetFlipData.ddRVal ) )
                        {
                            if( dwTrans & DDBLTFAST_WAIT)
                            {
                                goto KeepTrying;
                            }
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_WASSTILLDRAWING;
                        }
                    }
                }
                lpVideoPort = lpVideoPort->lpLink;
            }
        }

RESTART_BLTFAST:

        /*
         *  Remove any cached RLE stuff for source surface
         */
        if( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
        {
            extern void FreeRleData(LPDDRAWI_DDRAWSURFACE_LCL psurf); //in fasthel.c
            FreeRleData( this_dest_lcl );
        }

        BUMP_SURFACE_STAMP(this_dest);
        /*
         * is either surface locked?
         */
        if( this_src->dwUsageCount > 0 || this_dest->dwUsageCount > 0 )
        {
            DPF_ERR( "Surface is locked" );
            LEAVE_BOTH_NOBUSY()
            return DDERR_SURFACEBUSY;
        }

        /*
         * It is possible this function could be called in the middle
         * of a mode, in which case we could trash the frame buffer.
         * To avoid regression, we will simply succeed the call without
         * actually doing anything.
         */
        if( ( pdrv->dwFlags & DDRAWI_CHANGINGMODE ) &&
            !( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
        {
            LEAVE_BOTH_NOBUSY()
            return DD_OK;
        }

        // no restrictions yet
        halonly = FALSE;
        helonly = FALSE;
        gdiblt = FALSE;

        // initialize the blit caps according to the surface types
        initBltCapsFast( this_dest_lcl->ddsCaps.dwCaps, this_src_lcl->ddsCaps.dwCaps, pdrv, lpbc );

        if( !( pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM ) &&
             ( ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) ||
               ( this_src_lcl->ddsCaps.dwCaps  & DDSCAPS_SYSTEMMEMORY ) ) )
        {
            lpbc->bHALSeesSysmem = FALSE;
            helonly = TRUE;

         
            #ifdef WINNT
                // On NT, the kernel needs to handle blts from system to the primary
                // surface, otherwise the sprite stuff won't work

                if( ( this_dest->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE ) &&
                    ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY ) &&
                    ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
                {
                    // However, there are several cases that the kernel
                    // emulation will not handle, so filter these out:

                    if (((dwTrans & DDBLTFAST_COLORKEY_MASK) == 0) &&
                        doPixelFormatsMatch(&this_src->ddpfSurface,
                                            &this_dest->lpDD->vmiData.ddpfDisplay))
                    {
                        lpbc->bHALSeesSysmem = TRUE;
                        helonly = FALSE;
                    }
                }
            #endif
        }
        if( ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM ) &&
            ( pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS ) )
        {
            /*
             * All blits where the destination is non-local are emulated,
             * unless its sys->NL, in which case we let the driver see it
             * if it set DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL.
             * initBltFastCaps() set up the correct caps for emulation as
             * both surfaces are video memory so all we need to do is to force
             * on emulation
             */
            if (! ((this_src_lcl->ddsCaps.dwCaps  & DDSCAPS_SYSTEMMEMORY) &&
                  (pdrv->ddCaps.dwCaps2 & DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL ))        )
            {
                lpbc->bHALSeesSysmem = FALSE;
                helonly = TRUE;
            }
        }

        /*
         * check for HEL composition buffer
         */
        if( (this_dest_lcl->dwFlags & DDRAWISURF_HELCB) ||
            (this_src_lcl->dwFlags & DDRAWISURF_HELCB) )
        {
            lpbc->bHALSeesSysmem = FALSE;
            helonly = TRUE;
        }


        /*
         * does the driver even allow bltting?
         */
        if( !(*(lpbc->dwBothCaps) & DDCAPS_BLT) )
        {
            BOOL        fail;
            fail = FALSE;
            GETFAILCODEBLT( *(lpbc->dwCaps),
                            *(lpbc->dwHELCaps),
                            halonly,
                            helonly,
                            DDCAPS_BLT );

            if( fail )
            {
                DPF_ERR( "Blt not supported" );
                LEAVE_BOTH_NOBUSY()
                return DDERR_NOBLTHW;
            }
        }

        /*
         * Check for special cases involving FOURCC surfaces:
         *   -- Copy blits between surfaces with identical FOURCC formats
         *   -- Compression/decompression of DXT* compressed textures
         */
        {
            DWORD dwDest4CC = 0;
            DWORD dwSrc4CC = 0;

            /*
             * Does either the source or dest surface have a FOURCC format?
             */
            if ((this_dest_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (this_dest->ddpfSurface.dwFlags & DDPF_FOURCC))
            {
                dwDest4CC = this_dest->ddpfSurface.dwFourCC;   // dest FOURCC format
            }

            if ((this_src_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (this_src->ddpfSurface.dwFlags & DDPF_FOURCC))
            {
                dwSrc4CC = this_src->ddpfSurface.dwFourCC;   // source FOURCC format
            }

            if (dwDest4CC | dwSrc4CC)
            {
                /*
                 * Yes, at least one of the two surfaces has a FOURCC format.
                 * Do the source and dest surfaces have precisely the same
                 * FOURCC format?  (If so, this is a FOURCC copy blit.)
                 */
                if (dwDest4CC == dwSrc4CC)
                {
                    // Yes, this is a FOURCC copy blit.  Can the driver handle this?
                    if ((pdrv->ddCaps.dwCaps2 & DDCAPS2_COPYFOURCC) == 0)
                    {
                        // The driver cannot handle FOURCC copy blits.
                        helonly = TRUE;
                    }
                }
                else
                {
                    /*
                     * No, the two surfaces have different pixel formats.
                     * Now determine if either surface has a DXT* FOURCC format.
                     * The rule for the Blt API call is that the HEL _ALWAYS_
                     * performs a blit involving a DXT* source or dest surface.
                     * Hardware acceleration for DXT* blits is available only
                     * with the AlphaBlt API call.  We now enforce this rule:
                     */
                    switch (dwDest4CC)
                    {
                    case MAKEFOURCC('D','X','T','1'):
                    case MAKEFOURCC('D','X','T','2'):
                    case MAKEFOURCC('D','X','T','3'):
                    case MAKEFOURCC('D','X','T','4'):
                    case MAKEFOURCC('D','X','T','5'):
                        // This is a blit to a DXT*-formatted surface.
                        helonly = TRUE;
                        break;
                    default:
                        break;
                    }
                    switch (dwSrc4CC)
                    {
                    case MAKEFOURCC('D','X','T','1'):
                    case MAKEFOURCC('D','X','T','2'):
                    case MAKEFOURCC('D','X','T','3'):
                    case MAKEFOURCC('D','X','T','4'):
                    case MAKEFOURCC('D','X','T','5'):
                        // This is a blit from a DXT*-formatted surface.
                        helonly = TRUE;
                        break;
                    default:
                        break;
                    }
                }
            }
        }

        /*
         * get src rectangle
         */
        if( lpSrcRect == NULL )
        {
            MAKE_SURF_RECT( this_src, this_src_lcl, bd.rSrc );
            src_height = this_src->wHeight;
            src_width = this_src->wWidth;
        }
        else
        {
            bd.rSrc = *(LPRECTL)lpSrcRect;
            src_height = (bd.rSrc.bottom-bd.rSrc.top);
            src_width = (bd.rSrc.right-bd.rSrc.left);

            if( (src_height <= 0) || ((int)src_width <= 0) )
            {
                DPF_ERR( "BLTFAST error. Can't have non-positive height or width for source rect" );
                LEAVE_BOTH_NOBUSY();
                return DDERR_INVALIDRECT;
            }

            // Multi-mon: is this the primary for the desktop? This
            // is the only case where the upper-left coord of the surface is not
            // (0,0)
            if( (this_src->lpDD->dwFlags & DDRAWI_VIRTUALDESKTOP) &&
                (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) )
            {
                if( (bd.rSrc.left   < this_src->lpDD->rectDesktop.left) ||
                    (bd.rSrc.top    < this_src->lpDD->rectDesktop.top)  ||
                    (bd.rSrc.right  > this_src->lpDD->rectDesktop.right)||
                    (bd.rSrc.bottom > this_src->lpDD->rectDesktop.bottom) )
                {
                    DPF_ERR( "BltFast Source dimensions doesn't fit on Desktop" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDRECT;
                }
                if( OverlapsDevices( this_src_lcl, (LPRECT) &bd.rSrc ) )
                {
                    helonly = gdiblt = TRUE;
                }
            }
            else
            {
                if( (int)bd.rSrc.left < 0 ||
                    (int)bd.rSrc.top < 0  ||
                    (DWORD)bd.rSrc.bottom > (DWORD)this_src->wHeight ||
                    (DWORD)bd.rSrc.right > (DWORD)this_src->wWidth )
                {
                    DPF_ERR( "Invalid BltFast Source dimensions" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDRECT;
                }

            }

        }

        /*
         * get destination rectangle
         */
        bd.rDest.top = dwY;
        bd.rDest.left = dwX;
        bd.rDest.bottom = dwY + (DWORD) src_height;
        bd.rDest.right = dwX + (DWORD) src_width;

        /*
         * Ensure the destination offsets are valid.
         */

        // Multi-mon: is this the primary for the desktop? This
        // is the only case where the upper-left coord of the surface is not
        // (0,0)
        if( (pdrv->dwFlags & DDRAWI_VIRTUALDESKTOP) &&
            (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) )
        {
            if( (bd.rDest.left   < pdrv->rectDesktop.left) ||
                (bd.rDest.top    < pdrv->rectDesktop.top)  ||
                (bd.rDest.right  > pdrv->rectDesktop.right)||
                (bd.rDest.bottom > pdrv->rectDesktop.bottom) )
            {
                DPF_ERR( "BltFast Destination doesn't fit on Desktop And No Clipper was specified" );
                LEAVE_BOTH_NOBUSY();
                return DDERR_INVALIDRECT;
            }
            if( OverlapsDevices( this_dest_lcl, (LPRECT) &bd.rDest ) )
            {
                helonly = gdiblt = TRUE;
            }
        }
        else
        {
            if( (int)bd.rDest.left < 0 ||
                (int)bd.rDest.top < 0  ||
                (DWORD)bd.rDest.bottom > (DWORD)this_dest->wHeight ||
                (DWORD)bd.rDest.right > (DWORD)this_dest->wWidth )
            {
                DPF_ERR( "Invalid BltFast destination dimensions" );
                LEAVE_BOTH_NOBUSY();
                return DDERR_INVALIDRECT;
            }
        }


        /*
         * transparent?
         */
        switch( dwTrans & DDBLTFAST_COLORKEY_MASK )
        {
        case DDBLTFAST_NOCOLORKEY:
            bd.dwFlags = DDBLT_ROP;
            break;
        case DDBLTFAST_SRCCOLORKEY:
            if( !(this_src_lcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) )
            {
                DPF_ERR( "No colorkey on source" );
                LEAVE_BOTH_NOBUSY()
                return DDERR_INVALIDPARAMS;
            }
            if( !(*(lpbc->dwBothCKeyCaps) & DDCKEYCAPS_SRCBLT) )
            {
                BOOL    fail;
                fail = FALSE;
                GETFAILCODEBLT( *(lpbc->dwCKeyCaps),
                    *(lpbc->dwHELCKeyCaps),
                    halonly,
                    helonly,
                    DDCKEYCAPS_SRCBLT );
                if( fail )
                {
                    DPF_ERR( "KEYSRC specified, not supported" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_NOCOLORKEYHW;
                }
            }
            bd.bltFX.ddckSrcColorkey = this_src_lcl->ddckCKSrcBlt;
            bd.dwFlags = DDBLT_ROP | DDBLT_KEYSRCOVERRIDE;
            break;
        case DDBLTFAST_DESTCOLORKEY:
            if( !(this_dest_lcl->dwFlags & DDRAWISURF_HASCKEYDESTBLT) )
            {
                DPF_ERR( "No colorkey on dest" );
                LEAVE_BOTH_NOBUSY()
                return DDERR_INVALIDPARAMS;
            }
            if( !(*(lpbc->dwBothCKeyCaps) & DDCKEYCAPS_DESTBLT) )
            {
                BOOL    fail;
                fail = FALSE;
                GETFAILCODEBLT( *(lpbc->dwCKeyCaps),
                    *(lpbc->dwHELCKeyCaps),
                    halonly,
                    helonly,
                    DDCKEYCAPS_DESTBLT );
                if( fail )
                {
                    DPF_ERR( "KEYDEST specified, not supported" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_NOCOLORKEYHW;
                }
            }
            bd.bltFX.ddckDestColorkey = this_dest_lcl->ddckCKDestBlt;
            bd.dwFlags = DDBLT_ROP | DDBLT_KEYDESTOVERRIDE;
            dwDestLockFlags = 0; //this means read/write
            break;
        }
    }
    #ifndef FASTFAST
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_BOTH_NOBUSY()
        return DDERR_INVALIDPARAMS;
    }
    #endif

    /*
     * do the blt
     */
    #ifndef FASTFAST
    TRY
    #endif
    {
        bd.bltFX.dwROP = SRCCOPY;
        bd.lpDDDestSurface = this_dest_lcl;
        bd.lpDDSrcSurface = this_src_lcl;

        if( helonly && halonly )
        {
            DPF_ERR( "BLT not supported in software or hardware" );
            LEAVE_BOTH_NOBUSY()
            return DDERR_NOBLTHW;
        }
        // Did the mode change since ENTER_DDRAW?
#ifdef WINNT
        if ( DdQueryDisplaySettingsUniqueness() != uDisplaySettingsUnique )
        {
            // mode changed, don't do the blt
            DPF_ERR( "Mode changed between ENTER_DDRAW and HAL call" );
            LEAVE_BOTH_NOBUSY()
            return DDERR_SURFACELOST;
        }
        if( !helonly )
        {
            if (!this_src_lcl->hDDSurface 
                && !CompleteCreateSysmemSurface(this_src_lcl))
            {
                DPF_ERR("Can't blt from SYSTEM surface w/o Kernel Object");
                LEAVE_BOTH_NOBUSY()
                return DDERR_GENERIC;
            }
            if (!this_dest_lcl->hDDSurface 
                && !CompleteCreateSysmemSurface(this_dest_lcl))
            {
                DPF_ERR("Can't blt to SYSTEM surface w/o Kernel Object");
                LEAVE_BOTH_NOBUSY()
                return DDERR_GENERIC;
            }
        }
#endif
        if( helonly ) // must be HEL call
        {
            DPF( 4, "Software FastBlt");
            bltfn = pdrv_lcl->lpDDCB->HELDDSurface.Blt;

            // take locks on vram surfaces
            if( ( ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) == 0) &&
                ( !gdiblt || !( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) ) )
            {
                while( 1 )
                {
                    ddrval = InternalLock( this_dest_lcl, &dest_bits, NULL, dwDestLockFlags );
                    if( ddrval == DD_OK )
                    {
                        GET_LPDDRAWSURFACE_GBL_MORE(this_dest)->fpNTAlias = (FLATPTR) dest_bits;
                        break;
                    }
                    if( ddrval == DDERR_WASSTILLDRAWING )
                    {
                        continue;
                    }
                    LEAVE_BOTH_NOBUSY()
                    return ddrval;
                }
                dest_lock_taken = TRUE;
            }
            else
            {
                /*
                 * If either surface was involved in a hardware op, we need to
                 * probe the driver to see if it's done. NOTE this assumes
                 * that only one driver can be responsible for a system memory
                 * operation.
                 */
                if( this_dest->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
                {
                    WaitForDriverToFinishWithSurface(pdrv_lcl, this_dest_lcl );
                }
                dest_lock_taken = FALSE;
            }

            if( (lpDDSrcSurface != lpDDDestSurface) &&
                ( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) == 0) )
            {
                if( MoveToSystemMemory( this_src_int, TRUE, FALSE ) == DD_OK )
                {
                    /*
                     * Don't need to check for continuing hardware op here because
                     * MoveToSystemMemory does InternalLock
                     */
                    src_lock_taken = FALSE;
                }
                else
                {
                    while( 1 )
                    {
                        ddrval = InternalLock( this_src_lcl, &src_bits, NULL, dwSourceLockFlags );
                        if( ddrval == DD_OK )
                        {
                            GET_LPDDRAWSURFACE_GBL_MORE(this_src)->fpNTAlias = (FLATPTR) src_bits;
                            break;
                        }
                        if( ddrval == DDERR_WASSTILLDRAWING )
                        {
                            continue;
                        }
                        if( dest_lock_taken )
                        {
                            InternalUnlock( this_dest_lcl, NULL, NULL, 0 );
                        }
                        LEAVE_BOTH_NOBUSY()
                        return ddrval;
                    }
                    src_lock_taken = TRUE;
                }
            }
            else
            {
                if( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) &&
                        (this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED ) )
                {
                    WaitForDriverToFinishWithSurface(pdrv_lcl, this_src_lcl );
                }
                src_lock_taken = FALSE;
            }
        }
        else
        {
            DPF( 4, "Hardware FastBlt");
            bltfn = pdrv_lcl->lpDDCB->HALDDSurface.Blt;
            bd.Blt = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.Blt;

            /*
             * Take pagelocks if required.
             * If we take the pagelocks, then the blt becomes synchronous.
             * A failure taking the pagelocks is pretty catastrophic, so no attempt
             * is made to fail over to software.
             */
            lpbc->bSourcePagelockTaken=FALSE;
            lpbc->bDestPagelockTaken=FALSE;

            if ( lpbc->bHALSeesSysmem )
            {
                /*
                 * If the HAL requires page locks...
                 */
                if ( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_NOPAGELOCKREQUIRED ) )
                {
                    HRESULT hr;
                    /*
                     * ...then setup to take them if they're not already pagelocked.
                     */
                    if ( ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY &&
                                                this_dest_lcl->lpSurfMore->dwPageLockCount == 0 ) )
                    {
                        hr = InternalPageLock( this_dest_lcl, pdrv_lcl );
                        if (FAILED(hr))
                        {
                            LEAVE_BOTH_NOBUSY()
                            return hr;
                        }
                        else
                        {
                            lpbc->bDestPagelockTaken=TRUE;
                        }
                    }

                    if ( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY &&
                                                this_src_lcl->lpSurfMore->dwPageLockCount == 0 ))
                    {
                        hr = InternalPageLock( this_src_lcl, pdrv_lcl );
                        if (FAILED(hr))
                        {
                            if (lpbc->bDestPagelockTaken)
                                InternalPageUnlock( this_dest_lcl, pdrv_lcl );

                            LEAVE_BOTH_NOBUSY()
                            return hr;
                        }
                        else
                        {
                            lpbc->bSourcePagelockTaken=TRUE;
                        }
                    }

                    /*
                    {
                        if (pdrv->dwFlags & DDRAWI_DISPLAYDRV)
                        {
                            lpbc->bHALSeesSysmem = FALSE;
                            helonly = TRUE;
                        }
                    } */
                }
            }
        }

        bd.lpDD = pdrv;
        bd.bltFX.dwSize = sizeof( bd.bltFX );

        if( this_dest_lcl->lpDDClipper == NULL )
        {
            bd.IsClipped = FALSE;   // no clipping in BltFast
try_again:
            if( helonly )
            {
                // Release busy now or GDI blt will fail
                DONE_BUSY();
            }
            DOHALCALL_NOWIN16( Blt, bltfn, bd, rc, helonly );
#ifdef WINNT
            if (rc == DDHAL_DRIVER_HANDLED && bd.ddRVal == DDERR_VISRGNCHANGED)
            {
                DPF(5,"Resetting VisRgn for surface %x", this_dest_lcl);
                DdResetVisrgn(this_dest_lcl, (HWND)0);
                goto try_again;
            }
#endif

            if ( (dwTrans & DDBLTFAST_WAIT) &&
                rc == DDHAL_DRIVER_HANDLED &&
                bd.ddRVal == DDERR_WASSTILLDRAWING )
            {
                DPF(4, "Waiting...");
                goto try_again;
            }
            DPF(5,"Driver returned %08x",bd.ddRVal);
            /*
             * Note that the !helonly here is pretty much an assert.
             * Thought it safer to actually test it, since that is actually what we mean.
             */
            if( !helonly && lpbc->bHALSeesSysmem && rc == DDHAL_DRIVER_HANDLED && bd.ddRVal == DD_OK)
            {
                DPF(5,B,"Tagging surfaces %08x and %08x",this_dest,this_src);
                if( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                    this_dest->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPDEST;
                if( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                    this_src->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPSOURCE;
            }
        }
        else
        {
            DPF_ERR( "Can't clip in BltFast" );
            bd.ddRVal = DDERR_BLTFASTCANTCLIP;
            rc = DDHAL_DRIVER_HANDLED;
        }

        if( helonly )
        {
            DONE_LOCKS();
        }

        if( rc != DDHAL_DRIVER_HANDLED )
        {
            /*
             * did the driver run out of hardware color key resources?
             */
            if( (rc == DDHAL_DRIVER_NOCKEYHW) &&
                ((dwTrans & DDBLTFAST_COLORKEY_MASK) == DDBLTFAST_SRCCOLORKEY) )
            {
                ddrval = ChangeToSoftwareColorKey( this_src_int, FALSE );
                if( ddrval == DD_OK )
                {
                    halonly = FALSE;
                    helonly = FALSE;
                    if (lpbc->bSourcePagelockTaken)
                    {
                        lpbc->bSourcePagelockTaken = FALSE;
                        InternalPageUnlock(this_src_lcl, pdrv_lcl);
                    }
                    if (lpbc->bDestPagelockTaken)
                    {
                        lpbc->bDestPagelockTaken = FALSE;
                        InternalPageUnlock(this_dest_lcl, pdrv_lcl);
                    }

                    goto RESTART_BLTFAST;
                }
                else
                {
                    bd.ddRVal = DDERR_NOCOLORKEYHW;
                }
            }
            else
            {
                bd.ddRVal = DDERR_UNSUPPORTED;
            }
        }

        DONE_BUSY();

        /*
         * Maintain old behaviour for old drivers (which do not export the
         * GetSysmemBltStatus HAL call) and just spin until they're done.
         * Any alternative could exercise new code paths in the driver
         * (e.g. reentered for a DMA operation)
         * We also spin if we had to take either pagelock ourselves.
         */
        if ( lpbc->bHALSeesSysmem &&
            (NULL == pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus || lpbc->bDestPagelockTaken || lpbc->bSourcePagelockTaken)
            )
        {
            if( this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
            {
                /*
                 * Wait on the destination surface only
                 */
                DDASSERT(this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
                while (DDERR_WASSTILLDRAWING == InternalGetBltStatus(pdrv_lcl, this_dest_lcl, DDGBS_ISBLTDONE))
                    ;
                this_src_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                this_dest_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
            }
            /*
             * Unpagelock if we took the pagelocks
             */
            if (lpbc->bDestPagelockTaken )
                InternalPageUnlock(this_dest_lcl, pdrv_lcl);
            if (lpbc->bSourcePagelockTaken)
                InternalPageUnlock(this_src_lcl, pdrv_lcl);
        }

        LEAVE_BOTH();
        if(IsD3DManaged(this_dest_lcl))
        {
            LPREGIONLIST lpRegionList = this_dest_lcl->lpSurfMore->lpRegionList;
            MarkDirty(this_dest_lcl);
            if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
            {
                lpRegionList->rect[(lpRegionList->rdh.nCount)++] = bd.rDest;
                lpRegionList->rdh.nRgnSize += sizeof(RECT);
                if(bd.rDest.left < lpRegionList->rdh.rcBound.left)
                    lpRegionList->rdh.rcBound.left = bd.rDest.left;
                if(bd.rDest.right > lpRegionList->rdh.rcBound.right)
                    lpRegionList->rdh.rcBound.right = bd.rDest.right;
                if(bd.rDest.top < lpRegionList->rdh.rcBound.top)
                    lpRegionList->rdh.rcBound.top = bd.rDest.top;
                if(bd.rDest.bottom > lpRegionList->rdh.rcBound.bottom)
                    lpRegionList->rdh.rcBound.bottom = bd.rDest.bottom;
            }
        }
        return bd.ddRVal;

    }
    #ifndef FASTFAST
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered processing blt" );
        DONE_LOCKS();
        DONE_BUSY();
        /*
         * Maintain old behaviour for old drivers (which do not export the
         * GetSysmemBltStatus HAL call) and just spin until they're done.
         * Any alternative could exercise new code paths in the driver
         * (e.g. reentered for a DMA operation)
         */
        if ( lpbc->bHALSeesSysmem &&
            (NULL == pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus || lpbc->bDestPagelockTaken || lpbc->bSourcePagelockTaken)
            )
        {
            if( this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
            {
                /*
                 * Wait on the destination surface only
                 */
                DDASSERT(this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
                while (DDERR_WASSTILLDRAWING == InternalGetBltStatus(pdrv_lcl, this_dest_lcl, DDGBS_ISBLTDONE))
                    ;
                this_src_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                this_dest_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
            }
            /*
             * Unpagelock if we took the pagelocks
             */
            if (lpbc->bDestPagelockTaken )
                InternalPageUnlock(this_dest_lcl, pdrv_lcl);
            if (lpbc->bSourcePagelockTaken)
                InternalPageUnlock(this_src_lcl, pdrv_lcl);
        }
        LEAVE_BOTH();
        return DDERR_EXCEPTION;
    }
    #endif

} /* DD_Surface_BltFast */

#undef DPF_MODNAME
#define DPF_MODNAME     "Blt"

/*
 * ROP table
 *
 * tells which ROPS require pattern surfaces and/or source surfaces
 */
static char cROPTable[] = {
        0,                      // 00  0         BLACKNESS
        ROP_HAS_SOURCEPATTERN,  // 01  DPSoon
        ROP_HAS_SOURCEPATTERN,  // 02  DPSona
        ROP_HAS_SOURCEPATTERN,  // 03  PSon
        ROP_HAS_SOURCEPATTERN,  // 04  SDPona
        ROP_HAS_PATTERN,        // 05  DPon
        ROP_HAS_SOURCEPATTERN,  // 06  PDSxnon
        ROP_HAS_SOURCEPATTERN,  // 07  PDSaon
        ROP_HAS_SOURCEPATTERN,  // 08  SDPnaa
        ROP_HAS_SOURCEPATTERN,  // 09  PDSxon
        ROP_HAS_PATTERN,        // 0A  DPna
        ROP_HAS_SOURCEPATTERN,  // 0B  PSDnaon
        ROP_HAS_SOURCEPATTERN,  // 0C  SPna
        ROP_HAS_SOURCEPATTERN,  // 0D  PDSnaon
        ROP_HAS_SOURCEPATTERN,  // 0E  PDSonon
        ROP_HAS_PATTERN,        // 0F  Pn
        ROP_HAS_SOURCEPATTERN,  // 10  PDSona
        ROP_HAS_SOURCE,         // 11  DSon      NOTSRCERASE
        ROP_HAS_SOURCEPATTERN,  // 12  SDPxnon
        ROP_HAS_SOURCEPATTERN,  // 13  SDPaon
        ROP_HAS_SOURCEPATTERN,  // 14  DPSxnon
        ROP_HAS_SOURCEPATTERN,  // 15  DPSaon
        ROP_HAS_SOURCEPATTERN,  // 16  PSDPSanaxx
        ROP_HAS_SOURCEPATTERN,  // 17  SSPxDSxaxn
        ROP_HAS_SOURCEPATTERN,  // 18  SPxPDxa
        ROP_HAS_SOURCEPATTERN,  // 19  SDPSanaxn
        ROP_HAS_SOURCEPATTERN,  // 1A  PDSPaox
        ROP_HAS_SOURCEPATTERN,  // 1B  SDPSxaxn
        ROP_HAS_SOURCEPATTERN,  // 1C  PSDPaox
        ROP_HAS_SOURCEPATTERN,  // 1D  DSPDxaxn
        ROP_HAS_SOURCEPATTERN,  // 1E  PDSox
        ROP_HAS_SOURCEPATTERN,  // 1F  PDSoan
        ROP_HAS_SOURCEPATTERN,  // 20  DPSnaa
        ROP_HAS_SOURCEPATTERN,  // 21  SDPxon
        ROP_HAS_SOURCE,         // 22  DSna
        ROP_HAS_SOURCEPATTERN,  // 23  SPDnaon
        ROP_HAS_SOURCEPATTERN,  // 24  SPxDSxa
        ROP_HAS_SOURCEPATTERN,  // 25  PDSPanaxn
        ROP_HAS_SOURCEPATTERN,  // 26  SDPSaox
        ROP_HAS_SOURCEPATTERN,  // 27  SDPSxnox
        ROP_HAS_SOURCEPATTERN,  // 28  DPSxa
        ROP_HAS_SOURCEPATTERN,  // 29  PSDPSaoxxn
        ROP_HAS_SOURCEPATTERN,  // 2A  DPSana
        ROP_HAS_SOURCEPATTERN,  // 2B  SSPxPDxaxn
        ROP_HAS_SOURCEPATTERN,  // 2C  SPDSoax
        ROP_HAS_SOURCEPATTERN,  // 2D  PSDnox
        ROP_HAS_SOURCEPATTERN,  // 2E  PSDPxox
        ROP_HAS_SOURCEPATTERN,  // 2F  PSDnoan
        ROP_HAS_SOURCEPATTERN,  // 30  PSna
        ROP_HAS_SOURCEPATTERN,  // 31  SDPnaon
        ROP_HAS_SOURCEPATTERN,  // 32  SDPSoox
        ROP_HAS_SOURCE,         // 33  Sn        NOTSRCCOPY
        ROP_HAS_SOURCEPATTERN,  // 34  SPDSaox
        ROP_HAS_SOURCEPATTERN,  // 35  SPDSxnox
        ROP_HAS_SOURCEPATTERN,  // 36  SDPox
        ROP_HAS_SOURCEPATTERN,  // 37  SDPoan
        ROP_HAS_SOURCEPATTERN,  // 38  PSDPoax
        ROP_HAS_SOURCEPATTERN,  // 39  SPDnox
        ROP_HAS_SOURCEPATTERN,  // 3A  SPDSxox
        ROP_HAS_SOURCEPATTERN,  // 3B  SPDnoan
        ROP_HAS_SOURCEPATTERN,  // 3C  PSx
        ROP_HAS_SOURCEPATTERN,  // 3D  SPDSonox
        ROP_HAS_SOURCEPATTERN,  // 3E  SPDSnaox
        ROP_HAS_SOURCEPATTERN,  // 3F  PSan
        ROP_HAS_SOURCEPATTERN,  // 40  PSDnaa
        ROP_HAS_SOURCEPATTERN,  // 41  DPSxon
        ROP_HAS_SOURCEPATTERN,  // 42  SDxPDxa
        ROP_HAS_SOURCEPATTERN,  // 43  SPDSanaxn
        ROP_HAS_SOURCE,         // 44  SDna      SRCERASE
        ROP_HAS_SOURCEPATTERN,  // 45  DPSnaon
        ROP_HAS_SOURCEPATTERN,  // 46  DSPDaox
        ROP_HAS_SOURCEPATTERN,  // 47  PSDPxaxn
        ROP_HAS_SOURCEPATTERN,  // 48  SDPxa
        ROP_HAS_SOURCEPATTERN,  // 49  PDSPDaoxxn
        ROP_HAS_SOURCEPATTERN,  // 4A  DPSDoax
        ROP_HAS_SOURCEPATTERN,  // 4B  PDSnox
        ROP_HAS_SOURCEPATTERN,  // 4C  SDPana
        ROP_HAS_SOURCEPATTERN,  // 4D  SSPxDSxoxn
        ROP_HAS_SOURCEPATTERN,  // 4E  PDSPxox
        ROP_HAS_SOURCEPATTERN,  // 4F  PDSnoan
        ROP_HAS_PATTERN,        // 50  PDna
        ROP_HAS_SOURCEPATTERN,  // 51  DSPnaon
        ROP_HAS_SOURCEPATTERN,  // 52  DPSDaox
        ROP_HAS_SOURCEPATTERN,  // 53  SPDSxaxn
        ROP_HAS_SOURCEPATTERN,  // 54  DPSonon
        0,                      // 55  Dn        DSTINVERT
        ROP_HAS_SOURCEPATTERN,  // 56  DPSox
        ROP_HAS_SOURCEPATTERN,  // 57  DPSoan
        ROP_HAS_SOURCEPATTERN,  // 58  PDSPoax
        ROP_HAS_SOURCEPATTERN,  // 59  DPSnox
        ROP_HAS_PATTERN,        // 5A  DPx       PATINVERT
        ROP_HAS_SOURCEPATTERN,  // 5B  DPSDonox
        ROP_HAS_SOURCEPATTERN,  // 5C  DPSDxox
        ROP_HAS_SOURCEPATTERN,  // 5D  DPSnoan
        ROP_HAS_SOURCEPATTERN,  // 5E  DPSDnaox
        ROP_HAS_PATTERN,        // 5F  DPan
        ROP_HAS_SOURCEPATTERN,  // 60  PDSxa
        ROP_HAS_SOURCEPATTERN,  // 61  DSPDSaoxxn
        ROP_HAS_SOURCEPATTERN,  // 62  DSPDoax
        ROP_HAS_SOURCEPATTERN,  // 63  SDPnox
        ROP_HAS_SOURCEPATTERN,  // 64  SDPSoax
        ROP_HAS_SOURCEPATTERN,  // 65  DSPnox
        ROP_HAS_SOURCE,         // 66  DSx       SRCINVERT
        ROP_HAS_SOURCEPATTERN,  // 67  SDPSonox
        ROP_HAS_SOURCEPATTERN,  // 68  DSPDSonoxxn
        ROP_HAS_SOURCEPATTERN,  // 69  PDSxxn
        ROP_HAS_SOURCEPATTERN,  // 6A  DPSax
        ROP_HAS_SOURCEPATTERN,  // 6B  PSDPSoaxxn
        ROP_HAS_SOURCEPATTERN,  // 6C  SDPax
        ROP_HAS_SOURCEPATTERN,  // 6D  PDSPDoaxxn
        ROP_HAS_SOURCEPATTERN,  // 6E  SDPSnoax
        ROP_HAS_SOURCEPATTERN,  // 6F  PDSxnan
        ROP_HAS_SOURCEPATTERN,  // 70  PDSana
        ROP_HAS_SOURCEPATTERN,  // 71  SSDxPDxaxn
        ROP_HAS_SOURCEPATTERN,  // 72  SDPSxox
        ROP_HAS_SOURCEPATTERN,  // 73  SDPnoan
        ROP_HAS_SOURCEPATTERN,  // 74  DSPDxox
        ROP_HAS_SOURCEPATTERN,  // 75  DSPnoan
        ROP_HAS_SOURCEPATTERN,  // 76  SDPSnaox
        ROP_HAS_SOURCE,         // 77  DSan
        ROP_HAS_SOURCEPATTERN,  // 78  PDSax
        ROP_HAS_SOURCEPATTERN,  // 79  DSPDSoaxxn
        ROP_HAS_SOURCEPATTERN,  // 7A  DPSDnoax
        ROP_HAS_SOURCEPATTERN,  // 7B  SDPxnan
        ROP_HAS_SOURCEPATTERN,  // 7C  SPDSnoax
        ROP_HAS_SOURCEPATTERN,  // 7D  DPSxnan
        ROP_HAS_SOURCEPATTERN,  // 7E  SPxDSxo
        ROP_HAS_SOURCEPATTERN,  // 7F  DPSaan
        ROP_HAS_SOURCEPATTERN,  // 80  DPSaa
        ROP_HAS_SOURCEPATTERN,  // 81  SPxDSxon
        ROP_HAS_SOURCEPATTERN,  // 82  DPSxna
        ROP_HAS_SOURCEPATTERN,  // 83  SPDSnoaxn
        ROP_HAS_SOURCEPATTERN,  // 84  SDPxna
        ROP_HAS_SOURCEPATTERN,  // 85  PDSPnoaxn
        ROP_HAS_SOURCEPATTERN,  // 86  DSPDSoaxx
        ROP_HAS_SOURCEPATTERN,  // 87  PDSaxn
        ROP_HAS_SOURCE,         // 88  DSa       SRCAND
        ROP_HAS_SOURCEPATTERN,  // 89  SDPSnaoxn
        ROP_HAS_SOURCEPATTERN,  // 8A  DSPnoa
        ROP_HAS_SOURCEPATTERN,  // 8B  DSPDxoxn
        ROP_HAS_SOURCEPATTERN,  // 8C  SDPnoa
        ROP_HAS_SOURCEPATTERN,  // 8D  SDPSxoxn
        ROP_HAS_SOURCEPATTERN,  // 8E  SSDxPDxax
        ROP_HAS_SOURCEPATTERN,  // 8F  PDSanan
        ROP_HAS_SOURCEPATTERN,  // 90  PDSxna
        ROP_HAS_SOURCEPATTERN,  // 91  SDPSnoaxn
        ROP_HAS_SOURCEPATTERN,  // 92  DPSDPoaxx
        ROP_HAS_SOURCEPATTERN,  // 93  SPDaxn
        ROP_HAS_SOURCEPATTERN,  // 94  PSDPSoaxx
        ROP_HAS_SOURCEPATTERN,  // 95  DPSaxn
        ROP_HAS_SOURCEPATTERN,  // 96  DPSxx
        ROP_HAS_SOURCEPATTERN,  // 97  PSDPSonoxx
        ROP_HAS_SOURCEPATTERN,  // 98  SDPSonoxn
        ROP_HAS_SOURCE,         // 99  DSxn
        ROP_HAS_SOURCEPATTERN,  // 9A  DPSnax
        ROP_HAS_SOURCEPATTERN,  // 9B  SDPSoaxn
        ROP_HAS_SOURCEPATTERN,  // 9C  SPDnax
        ROP_HAS_SOURCEPATTERN,  // 9D  DSPDoaxn
        ROP_HAS_SOURCEPATTERN,  // 9E  DSPDSaoxx
        ROP_HAS_SOURCEPATTERN,  // 9F  PDSxan
        ROP_HAS_PATTERN,        // A0  DPa
        ROP_HAS_SOURCEPATTERN,  // A1  PDSPnaoxn
        ROP_HAS_SOURCEPATTERN,  // A2  DPSnoa
        ROP_HAS_SOURCEPATTERN,  // A3  DPSDxoxn
        ROP_HAS_SOURCEPATTERN,  // A4  PDSPonoxn
        ROP_HAS_PATTERN,        // A5  PDxn
        ROP_HAS_SOURCEPATTERN,  // A6  DSPnax
        ROP_HAS_SOURCEPATTERN,  // A7  PDSPoaxn
        ROP_HAS_SOURCEPATTERN,  // A8  DPSoa
        ROP_HAS_SOURCEPATTERN,  // A9  DPSoxn
        0,                      // AA  D
        ROP_HAS_SOURCEPATTERN,  // AB  DPSono
        ROP_HAS_SOURCEPATTERN,  // AC  SPDSxax
        ROP_HAS_SOURCEPATTERN,  // AD  DPSDaoxn
        ROP_HAS_SOURCEPATTERN,  // AE  DSPnao
        ROP_HAS_PATTERN,        // AF  DPno
        ROP_HAS_SOURCEPATTERN,  // B0  PDSnoa
        ROP_HAS_SOURCEPATTERN,  // B1  PDSPxoxn
        ROP_HAS_SOURCEPATTERN,  // B2  SSPxDSxox
        ROP_HAS_SOURCEPATTERN,  // B3  SDPanan
        ROP_HAS_SOURCEPATTERN,  // B4  PSDnax
        ROP_HAS_SOURCEPATTERN,  // B5  DPSDoaxn
        ROP_HAS_SOURCEPATTERN,  // B6  DPSDPaoxx
        ROP_HAS_SOURCEPATTERN,  // B7  SDPxan
        ROP_HAS_SOURCEPATTERN,  // B8  PSDPxax
        ROP_HAS_SOURCEPATTERN,  // B9  DSPDaoxn
        ROP_HAS_SOURCEPATTERN,  // BA  DPSnao
        ROP_HAS_SOURCE,         // BB  DSno      MERGEPAINT
        ROP_HAS_SOURCEPATTERN,  // BC  SPDSanax
        ROP_HAS_SOURCEPATTERN,  // BD  SDxPDxan
        ROP_HAS_SOURCEPATTERN,  // BE  DPSxo
        ROP_HAS_SOURCEPATTERN,  // BF  DPSano    MERGECOPY
        ROP_HAS_SOURCEPATTERN,  // C0  PSa
        ROP_HAS_SOURCEPATTERN,  // C1  SPDSnaoxn
        ROP_HAS_SOURCEPATTERN,  // C2  SPDSonoxn
        ROP_HAS_SOURCEPATTERN,  // C3  PSxn
        ROP_HAS_SOURCEPATTERN,  // C4  SPDnoa
        ROP_HAS_SOURCEPATTERN,  // C5  SPDSxoxn
        ROP_HAS_SOURCEPATTERN,  // C6  SDPnax
        ROP_HAS_SOURCEPATTERN,  // C7  PSDPoaxn
        ROP_HAS_SOURCEPATTERN,  // C8  SDPoa
        ROP_HAS_SOURCEPATTERN,  // C9  SPDoxn
        ROP_HAS_SOURCEPATTERN,  // CA  DPSDxax
        ROP_HAS_SOURCEPATTERN,  // CB  SPDSaoxn
        ROP_HAS_SOURCE,         // CC  S         SRCCOPY
        ROP_HAS_SOURCEPATTERN,  // CD  SDPono
        ROP_HAS_SOURCEPATTERN,  // CE  SDPnao
        ROP_HAS_SOURCEPATTERN,  // CF  SPno
        ROP_HAS_SOURCEPATTERN,  // D0  PSDnoa
        ROP_HAS_SOURCEPATTERN,  // D1  PSDPxoxn
        ROP_HAS_SOURCEPATTERN,  // D2  PDSnax
        ROP_HAS_SOURCEPATTERN,  // D3  SPDSoaxn
        ROP_HAS_SOURCEPATTERN,  // D4  SSPxPDxax
        ROP_HAS_SOURCEPATTERN,  // D5  DPSanan
        ROP_HAS_SOURCEPATTERN,  // D6  PSDPSaoxx
        ROP_HAS_SOURCEPATTERN,  // D7  DPSxan
        ROP_HAS_SOURCEPATTERN,  // D8  PDSPxax
        ROP_HAS_SOURCEPATTERN,  // D9  SDPSaoxn
        ROP_HAS_SOURCEPATTERN,  // DA  DPSDanax
        ROP_HAS_SOURCEPATTERN,  // DB  SPxDSxan
        ROP_HAS_SOURCEPATTERN,  // DC  SPDnao
        ROP_HAS_SOURCE,         // DD  SDno
        ROP_HAS_SOURCEPATTERN,  // DE  SDPxo
        ROP_HAS_SOURCEPATTERN,  // DF  SDPano
        ROP_HAS_SOURCEPATTERN,  // E0  PDSoa
        ROP_HAS_SOURCEPATTERN,  // E1  PDSoxn
        ROP_HAS_SOURCEPATTERN,  // E2  DSPDxax
        ROP_HAS_SOURCEPATTERN,  // E3  PSDPaoxn
        ROP_HAS_SOURCEPATTERN,  // E4  SDPSxax
        ROP_HAS_SOURCEPATTERN,  // E5  PDSPaoxn
        ROP_HAS_SOURCEPATTERN,  // E6  SDPSanax
        ROP_HAS_SOURCEPATTERN,  // E7  SPxPDxan
        ROP_HAS_SOURCEPATTERN,  // E8  SSPxDSxax
        ROP_HAS_SOURCEPATTERN,  // E9  DSPDSanaxxn
        ROP_HAS_SOURCEPATTERN,  // EA  DPSao
        ROP_HAS_SOURCEPATTERN,  // EB  DPSxno
        ROP_HAS_SOURCEPATTERN,  // EC  SDPao
        ROP_HAS_SOURCEPATTERN,  // ED  SDPxno
        ROP_HAS_SOURCE,         // EE  DSo       SRCPAINT
        ROP_HAS_SOURCEPATTERN,  // EF  SDPnoo
        ROP_HAS_PATTERN,        // F0  P         PATCOPY
        ROP_HAS_SOURCEPATTERN,  // F1  PDSono
        ROP_HAS_SOURCEPATTERN,  // F2  PDSnao
        ROP_HAS_SOURCEPATTERN,  // F3  PSno
        ROP_HAS_SOURCEPATTERN,  // F4  PSDnao
        ROP_HAS_PATTERN,        // F5  PDno
        ROP_HAS_SOURCEPATTERN,  // F6  PDSxo
        ROP_HAS_SOURCEPATTERN,  // F7  PDSano
        ROP_HAS_SOURCEPATTERN,  // F8  PDSao
        ROP_HAS_SOURCEPATTERN,  // F9  PDSxno
        ROP_HAS_PATTERN,        // FA  DPo
        ROP_HAS_SOURCEPATTERN,  // FB  DPSnoo    PATPAINT
        ROP_HAS_SOURCEPATTERN,  // FC  PSo
        ROP_HAS_SOURCEPATTERN,  // FD  PSDnoo
        ROP_HAS_SOURCEPATTERN,  // FE  DPSoo
        0                       // FF  1         WHITENESS
};

/*
 * checkBltStretching
 *
 * check and see if we can stretch or not
 */
HRESULT checkBltStretching(
                LPBLTCAPS lpbc,
                LPSPECIAL_BLT_DATA psbd )
{
    DWORD               caps;
    BOOL                fail;

    fail = FALSE;

    /*
     * can we even stretch at all?
     */
    if( !(*(lpbc->dwBothCaps) & DDCAPS_BLTSTRETCH))
    {
        GETFAILCODEBLT( *(lpbc->dwCaps),
                        *(lpbc->dwHELCaps),
                        psbd->halonly,
                        psbd->helonly,
                        DDCAPS_BLTSTRETCH );
        if( fail )
        {
            return DDERR_NOSTRETCHHW;
        }
    }

    if (psbd->helonly)
        caps = *(lpbc->dwHELFXCaps);
    else
        caps = *(lpbc->dwFXCaps);

    /*
     * verify height
     */
    if( psbd->src_height != psbd->dest_height )
    {
        if( psbd->src_height > psbd->dest_height )
        {
            /*
             * can we shrink Y arbitrarily?
             */
            if( !(caps & (DDFXCAPS_BLTSHRINKY) ) )
            {
                /*
                 * see if this is a non-integer shrink
                 */
                if( (psbd->src_height % psbd->dest_height) != 0 )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSHRINKY );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                /*
                 * see if we can integer shrink
                 */
                }
                else if( !(caps & DDFXCAPS_BLTSHRINKYN) )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSHRINKYN );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                }
            }
        }
        else
        {
            if( !(caps & DDFXCAPS_BLTSTRETCHY) )
            {
                /*
                 * see if this is a non-integer stretch
                 */
                if( (psbd->dest_height % psbd->src_height) != 0 )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSTRETCHY );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                /*
                 * see if we can integer stretch
                 */
                }
                else if( !(caps & DDFXCAPS_BLTSTRETCHYN) )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSTRETCHYN );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                }
            }
        }
    }

    /*
     * verify width
     */
    if( psbd->src_width != psbd->dest_width )
    {
        if( psbd->src_width > psbd->dest_width )
        {
            if( !(caps & DDFXCAPS_BLTSHRINKX) )
            {
                /*
                 * see if this is a non-integer shrink
                 */
                if( (psbd->src_width % psbd->dest_width) != 0 )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSHRINKX );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                /*
                 * see if we can integer shrink
                 */
                }
                else if( !(caps & DDFXCAPS_BLTSHRINKXN) )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSHRINKXN );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                }
            }
        }
        else
        {
            if( !(caps & DDFXCAPS_BLTSTRETCHX) )
            {
                /*
                 * see if this is a non-integer stretch
                 */
                if( (psbd->dest_width % psbd->src_width) != 0 )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSTRETCHX );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                }
                if( !(caps & DDFXCAPS_BLTSTRETCHXN) )
                {
                    GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                    *(lpbc->dwHELFXCaps),
                                    psbd->halonly,
                                    psbd->helonly,
                                    DDFXCAPS_BLTSTRETCHXN );
                    if( fail )
                    {
                        return DDERR_NOSTRETCHHW;
                    }
                }
            }
        }
    }

    return DD_OK;

} /* checkBltStretching */

/*
 * FindAttached
 *
 * find an attached surface with particular caps
 */
LPDDRAWI_DDRAWSURFACE_LCL FindAttached( LPDDRAWI_DDRAWSURFACE_LCL ptr_lcl, DWORD caps )
{
    LPATTACHLIST                pal;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;

    pal = ptr_lcl->lpAttachList;
    while( pal != NULL )
    {
        psurf_lcl = pal->lpAttached;
        if( psurf_lcl->ddsCaps.dwCaps & caps )
        {
            return psurf_lcl;
        }
        pal = pal->lpLink;
    }
    return NULL;

} /* FindAttached */

#if defined(WIN95)
    #define DONE_EXCLUDE() \
        if( this_dest_lcl->lpDDClipper != NULL ) \
        { \
            if ( (pdrv->dwFlags & DDRAWI_DISPLAYDRV) && pdrv->dwPDevice && \
                !(*pdrv->lpwPDeviceFlags & HARDWARECURSOR)) \
            { \
                DD16_Unexclude(pdrv->dwPDevice); \
            } \
        }
#elif defined(WINNT)
    #define DONE_EXCLUDE() ;
#endif

/*
 * DD_Surface_Blt
 *
 * Bit Blt from one surface to another
 */
HRESULT DDAPI DD_Surface_Blt(
                LPDIRECTDRAWSURFACE lpDDDestSurface,
                LPRECT lpDestRect,
                LPDIRECTDRAWSURFACE lpDDSrcSurface,
                LPRECT lpSrcRect,
                DWORD dwFlags,
                LPDDBLTFX lpDDBltFX )
{
    DWORD           rc;
    DWORD           rop;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_src_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL   this_dest_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this_src;
    LPDDRAWI_DDRAWSURFACE_GBL   this_dest;
    LPDDRAWI_DDRAWSURFACE_INT   this_src_int;
    LPDDRAWI_DDRAWSURFACE_INT   this_dest_int;
    BOOL            need_pat;
    SPECIAL_BLT_DATA        sbd;
    BOOL            stretch_blt;
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    DDHAL_BLTDATA       bd;
    RECT            DestRect;
    BOOL            fail;
    BOOL            dest_lock_taken=FALSE;
    BOOL            src_lock_taken=FALSE;
    BOOL            dest_pagelock_taken=FALSE;
    BOOL            src_pagelock_taken=FALSE;
    LPVOID          dest_bits;
    LPVOID          src_bits;
    HRESULT         ddrval;
    BLTCAPS         bc;
    LPBLTCAPS           lpbc=&bc;
    LPWORD          pdflags=0;
    DWORD                       dwSourceLockFlags=0;
    DWORD                       dwDestLockFlags=0;
    BOOL            gdiblt;
    LPDDPIXELFORMAT pddpf;
    BOOL            subrect_lock_taken = FALSE;
    RECT            subrect_lock_rect;
    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_Blt");

    TRY
    {
        ZeroMemory(&bd, sizeof(bd));    // initialize to zero

        /*
         * validate surface ptrs
         */
        this_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDDestSurface;
        this_src_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSrcSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_dest_int ) )
        {
            DPF_ERR( "Invalid dest specified") ;
            LEAVE_BOTH();
            return DDERR_INVALIDOBJECT;
        }
        this_dest_lcl = this_dest_int->lpLcl;
        this_dest = this_dest_lcl->lpGbl;
        if( SURFACE_LOST( this_dest_lcl ) )
        {
            DPF( 1, "Dest lost") ;
            LEAVE_BOTH();
            return DDERR_SURFACELOST;
        }
        if( this_src_int != NULL )
        {
            if( !VALID_DIRECTDRAWSURFACE_PTR( this_src_int ) )
            {
                DPF_ERR( "Invalid source specified" );
                LEAVE_BOTH();
                return DDERR_INVALIDOBJECT;
            }
            this_src_lcl = this_src_int->lpLcl;
            this_src = this_src_lcl->lpGbl;
            if( SURFACE_LOST( this_src_lcl ) )
            {
                DPF_ERR( "Src lost") ;
                LEAVE_BOTH();
                return DDERR_SURFACELOST;
            }
        }
        else
        {
            this_src_lcl = NULL;
            this_src = NULL;
        }

        if ( ( DDBLT_DX8ORHIGHER & dwFlags ) && ( DDBLT_WINDOWCLIP & dwFlags ) )
        {
            LPDDRAWI_DDRAWCLIPPER_INT   lpDDIClipper =
                this_dest_lcl->lpSurfMore->lpDDIClipper;
            if (lpDDIClipper && (DDSCAPS_PRIMARYSURFACE &
                this_dest_lcl->ddsCaps.dwCaps))
            {
                HWND    hWnd = (HWND)lpDDIClipper->lpLcl->lpGbl->hWnd;
                if (GetClientRect(hWnd, &DestRect))
                {
                    if(( lpDestRect != NULL ) && VALID_RECT_PTR( lpDestRect ))
                    {
                        if (DestRect.right > lpDestRect->right)
                            DestRect.right = lpDestRect->right;
                        if (DestRect.bottom > lpDestRect->bottom)
                            DestRect.bottom = lpDestRect->bottom;
                        if (0 < lpDestRect->left)
                            DestRect.left = lpDestRect->left;
                        if (0 < lpDestRect->top)
                            DestRect.top = lpDestRect->top;
                        if (DestRect.top >= DestRect.bottom ||
                            DestRect.left >= DestRect.right)
                        {
                            // in case of insane RECT, fail it
                            DPF_ERR("Unable to Blt with invalid dest RECT");
                            LEAVE_BOTH();
                            return DDERR_INVALIDPARAMS;
                        }
                    }
                    if (!ClientToScreen(hWnd,(POINT*)&DestRect))
                        DPF_ERR("ClientToScreen Failed on DestRect?");
                    if (!ClientToScreen(hWnd,(POINT*)&DestRect.right))
                        DPF_ERR("ClientToScreen Failed on DestRect.right?");
                    // in DX8 we always have DDRAWILCL_EXPLICITMONITOR so
                    // DestRect must be checked and adjusted against DeviceRect
                    pdrv = this_dest->lpDD;  
                    /*
                     * Do a real quick check w/o accounting for the clipper
                     */
                    if( ( DestRect.top < pdrv->rectDevice.top ) ||
                        ( DestRect.left < pdrv->rectDevice.left ) ||
                        ( DestRect.right > pdrv->rectDevice.right ) ||
                        ( DestRect.bottom > pdrv->rectDevice.bottom ) )
                    {
                        RECT    rect;
                        /*
                         * It may only be that part of the rect is off of the desktop,
                         * in which case we don't neccesarily need to drop to emulation.
                         */
                        IntersectRect( &rect, &DestRect, &pdrv->rectDesktop );
                        if( ( rect.top < pdrv->rectDevice.top ) ||
                            ( rect.left < pdrv->rectDevice.left ) ||
                            ( rect.right > pdrv->rectDevice.right ) ||
                            ( rect.bottom > pdrv->rectDevice.bottom ) )
                        {
                            // fail crossdevice blt and let GDI do it in DdBlt()
                            LEAVE_BOTH();
                            return DDERR_INVALIDPARAMS;
                        }
                    }
                    if (!OffsetRect(&DestRect, -pdrv->rectDevice.left,
                        -pdrv->rectDevice.top))
                        DPF_ERR("OffsetRect Failed on DestRect?");
                    lpDestRect = &DestRect; // replace it with new Rect
                    DPF(10,"Got a new dest RECT !!");
                    if (DDBLT_COPYVSYNC & dwFlags) 
                    {
                        DWORD                msCurrentTime = 0;
                        DWORD                msStartTime = GetTickCount();
                        LPDDHAL_GETSCANLINE gslhalfn;
                        LPDDHAL_GETSCANLINE gslfn;
                        LPDDRAWI_DIRECTDRAW_LCL this_lcl =
                            this_dest_lcl->lpSurfMore->lpDD_lcl;
                        gslfn = this_lcl->lpDDCB->HALDD.GetScanLine;
                        gslhalfn = this_lcl->lpDDCB->cbDDCallbacks.GetScanLine;
                        if( gslhalfn != NULL )
                        {
                            DDHAL_GETSCANLINEDATA       gsld;
                            DWORD                       rc;
                            gsld.GetScanLine = gslhalfn;
                            gsld.lpDD = this_lcl->lpGbl;
                            do
                            {
                                DOHALCALL_NOWIN16( GetScanLine, gslfn, gsld, rc, FALSE );
                                if ( DD_OK != gsld.ddRVal )
                                    break;
                                if ( (LONG)gsld.dwScanLine >= DestRect.bottom )
                                    break;

                                msCurrentTime = GetTickCount();
                        
                                // If we've been spinning here for 30ms
                                // then blt anyway; probably something
                                // taking up CPU cycles
                                if ( (msCurrentTime - msStartTime) > 30 )
                                {
                                    break;
                                }

                            } while ( DDHAL_DRIVER_HANDLED == rc );
                        }
                    }
                }
                else
                {
                    DPF_ERR("GetClientRect Failed ?");
                }
            }
            // Don't let these DX8-only flags propagate to driver (or rest of Blt code)
            // since they alias other existing flags.
            dwFlags &= ~(DDBLT_WINDOWCLIP | DDBLT_COPYVSYNC | DDBLT_DX8ORHIGHER);
        }

        if( dwFlags & ~DDBLT_VALID )
        {
            DPF_ERR( "Invalid flags") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * BEHAVIOUR CHANGE FOR DX5
         *
         * We do not allow bltting between surfaces created with different DirectDraw
         * objects.
         */
        if (this_src)
        {
            if (this_dest_lcl->lpSurfMore->lpDD_lcl->lpGbl != this_src_lcl->lpSurfMore->lpDD_lcl->lpGbl)
            {
                if ((this_dest_lcl->lpSurfMore->lpDD_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV) &&
                    (this_src_lcl->lpSurfMore->lpDD_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV))
                {
                    DPF_ERR("Can't blt surfaces between different direct draw devices");
                    LEAVE_BOTH();
                    return DDERR_DEVICEDOESNTOWNSURFACE;
                }
            }
        }

        //
        // If either surface is optimized, quit
        //
        if (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "Can't blt optimized surfaces") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

        if (this_src)
        {
            if (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
            {
                DPF_ERR( "Can't blt optimized surfaces") ;
                LEAVE_BOTH();
                return DDERR_INVALIDPARAMS;
            }
        }

        /*
     * Since Z Blts are currently turned off, we might as well give some
     * hint that this is the case.
     */
#ifdef DEBUG
        if( dwFlags & ( DDBLT_ZBUFFER | DDBLT_ZBUFFERDESTCONSTOVERRIDE |
                        DDBLT_ZBUFFERDESTOVERRIDE | DDBLT_ZBUFFERSRCCONSTOVERRIDE |
                        DDBLT_ZBUFFERSRCOVERRIDE ) )
        {
            DPF_ERR( "Z aware BLTs are not currently supported" );
            LEAVE_BOTH();
            return DDERR_NOZBUFFERHW;
        }
#endif

        pdrv = this_dest->lpDD;
        pdrv_lcl = this_dest_lcl->lpSurfMore->lpDD_lcl;
        #ifdef WINNT
            // Update DDraw handle in driver GBL object.
            pdrv->hDD = pdrv_lcl->hDD;
        #endif

        /*
         * DX5 or greater drivers get to know about read/write only locks
         * Note that dwDestFlags may later be modified for dest color key.
         * Pass zero for both flags unless:
         *  -it's a color fill, in which case turn on writeonly for dest.
         *  -the blt goes from/to different surfaces,
         */
        if ( (pdrv->dwInternal1 >= 0x500)
             && ((this_src == NULL) || (this_src != this_dest) ) )
        {
            dwSourceLockFlags = DDLOCK_READONLY;
            dwDestLockFlags = DDLOCK_WRITEONLY;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_BOTH();
        return DDERR_INVALIDPARAMS;
    }

#ifdef USE_ALIAS
    if( pdrv->dwBusyDueToAliasedLock > 0 )
    {
        /*
         * Aliased locks (the ones that don't take the Win16 lock) don't
         * set the busy bit either (it can't or USER get's very confused).
         * However, we must prevent blits happening via DirectDraw as
         * otherwise we get into the old host talking to VRAM while
         * blitter does at the same time. Bad. So fail if there is an
         * outstanding aliased lock just as if the BUST bit had been
         * set.
         */
        DPF_ERR( "Graphics adapter is busy (due to a DirectDraw lock)" );
        LEAVE_BOTH();
        return DDERR_SURFACEBUSY;
    }
#endif /* USE_ALIAS */

    /*
     * Behavior change:  In DX7, the default is to wait unless DDBLT_DONOTWAIT=1.
     * In earlier releases, the default was to NOT wait unless DDBLT_WAIT=1.
     * (The DDBLT_DONOTWAIT flag was not defined until the DX7 release.)
     */
    if (!LOWERTHANSURFACE7(this_dest_int))
    {
        if (dwFlags & DDBLT_DONOTWAIT)
        {
            if (dwFlags & DDBLT_WAIT)
            {
                DPF_ERR( "WAIT and DONOTWAIT flags are mutually exclusive" );
                LEAVE_BOTH();
                return DDERR_INVALIDPARAMS;
            }
        }
        else
        {
            dwFlags |= DDBLT_WAIT;
        }
    }

    if(this_src_lcl)
        FlushD3DStates(this_src_lcl); // Need to flush src because it could be a rendertarget
    FlushD3DStates(this_dest_lcl);

    // Test and set the busy bit.  If it was already set, bail.
    {
        BOOL    isbusy = 0;

        pdflags = pdrv->lpwPDeviceFlags;
#ifdef WIN95
        _asm
            {
                mov eax, pdflags
                    bts word ptr [eax], BUSY_BIT
                    adc byte ptr isbusy,0
                    }
#else
        isbusy -= (InterlockedExchange((LPDWORD)pdflags,
                                       *((LPDWORD)pdflags) | (1<<BUSY_BIT) ) == (1<<BUSY_BIT) );
#endif
        if( isbusy )
        {
            DPF( 1, "BUSY - Blt" );
            LEAVE_BOTH();
            return DDERR_SURFACEBUSY;
        }

    }
    /*
     * The following code was added to keep all of the HALs from
     * changing their Blt() code when they add video port support.
     * If the video port was using this surface but was recently
     * flipped, we will make sure that the flip actually occurred
     * before allowing access.  This allows double buffered capture
     * w/o tearing.
     */
    if( ( this_src_lcl != NULL ) &&
        ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT ) )
    {
        LPDDRAWI_DDVIDEOPORT_INT lpVideoPort;
        LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort_lcl;

        // Look at all video ports to see if any of them recently
        // flipped from this surface.
        lpVideoPort = pdrv->dvpList;
        while( NULL != lpVideoPort )
        {
            lpVideoPort_lcl = lpVideoPort->lpLcl;
            if( lpVideoPort_lcl->fpLastFlip == this_src->fpVidMem )
            {
                // This can potentially tear - check the flip status
                LPDDHALVPORTCB_GETFLIPSTATUS pfn;
                DDHAL_GETVPORTFLIPSTATUSDATA GetFlipData;
                LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;

                pdrv_lcl = this_src_lcl->lpSurfMore->lpDD_lcl;
                pfn = pdrv_lcl->lpDDCB->HALDDVideoPort.GetVideoPortFlipStatus;
                if( pfn != NULL )  // Will simply tear if function not supproted
                {
                    GetFlipData.lpDD = pdrv_lcl;
                    GetFlipData.fpSurface = this_src->fpVidMem;

                KeepTrying:
                    rc = DDHAL_DRIVER_NOTHANDLED;
                    DOHALCALL_NOWIN16( GetVideoPortFlipStatus, pfn, GetFlipData, rc, 0 );
                    if( ( DDHAL_DRIVER_HANDLED == rc ) &&
                        ( DDERR_WASSTILLDRAWING == GetFlipData.ddRVal ) )
                    {
                        if( dwFlags & DDBLT_WAIT)
                        {
                            goto KeepTrying;
                        }
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_WASSTILLDRAWING;
                    }
                }
            }
            lpVideoPort = lpVideoPort->lpLink;
        }
    }

RESTART_BLT:
    TRY
    {

        /*
         *  Remove any cached RLE stuff for source surface
         */
        if( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
        {
            extern void FreeRleData(LPDDRAWI_DDRAWSURFACE_LCL psurf); //in fasthel.c
            FreeRleData( this_dest_lcl );
        }

        /*
         * is either surface locked?
         */
        if( (this_dest->dwUsageCount > 0) ||
            ((this_src != NULL) && (this_src->dwUsageCount > 0)) )
        {
            DPF_ERR( "Surface is locked" );
            LEAVE_BOTH_NOBUSY();
            return DDERR_SURFACEBUSY;
        }

        BUMP_SURFACE_STAMP(this_dest);

        /*
         * It is possible this function could be called in the middle
         * of a mode, in which case we could trash the frame buffer.
         * To avoid regression, we will simply succeed the call without
         * actually doing anything.
         */
        if( ( pdrv->dwFlags & DDRAWI_CHANGINGMODE ) &&
            !( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
        {
            LEAVE_BOTH_NOBUSY()
                return DD_OK;
        }

        sbd.halonly = FALSE;
        sbd.helonly = FALSE;
        gdiblt = FALSE;
        if( this_src != NULL )
        {
            // initialize the blit caps according to the surface types
            initBltCaps( 
                this_dest_lcl->ddsCaps.dwCaps, 
                this_dest->dwGlobalFlags,
                this_src_lcl->ddsCaps.dwCaps, pdrv, lpbc, &(sbd.helonly) );
        }
        else
        {
            // no source surface, use vram->vram caps and determine hal or hel
            // based on system memory status of destination surface
            // if the destination is non-local we also force emulation as we
            // don't currently support accelerated operation with non-local
            // video memory are a target
            initBltCaps( DDSCAPS_VIDEOMEMORY, 0, DDSCAPS_VIDEOMEMORY, pdrv, lpbc, &sbd.helonly );
            if( ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) ||
                ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM ) )
            {
                lpbc->bHALSeesSysmem = FALSE;
                sbd.helonly = TRUE;
            }
        }

        fail = FALSE;

        /*
         * can we really blt?
         */
        if( !(*(lpbc->dwBothCaps) & DDCAPS_BLT) )
        {
            if( *(lpbc->dwCaps) & DDCAPS_BLT )
            {
                sbd.halonly = TRUE;
            }
            else if( *(lpbc->dwHELCaps) & DDCAPS_BLT )
            {
                lpbc->bHALSeesSysmem = FALSE;
                sbd.helonly = TRUE;
            }
            else
            {
                DPF_ERR( "Driver does not support Blt" );
                LEAVE_BOTH_NOBUSY();
                return DDERR_NOBLTHW;
            }
        }

        /*
         * Check for special cases involving FOURCC surfaces:
         *   -- Copy blits between surfaces with identical FOURCC formats
         *   -- Compression/decompression of DXT* compressed textures
         */
        {
            DWORD dwDest4CC = 0;
            DWORD dwSrc4CC = 0;

            /*
             * Does either the source or dest surface have a FOURCC format?
             */
            if ((this_dest_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (this_dest->ddpfSurface.dwFlags & DDPF_FOURCC))
            {
                dwDest4CC = this_dest->ddpfSurface.dwFourCC;   // dest FOURCC format
            }

            if ((this_src_lcl != NULL) &&
                (this_src_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (this_src->ddpfSurface.dwFlags & DDPF_FOURCC))
            {
                dwSrc4CC = this_src->ddpfSurface.dwFourCC;   // source FOURCC format
            }

            if (dwDest4CC | dwSrc4CC)
            {
                /*
                 * Yes, at least one of the two surfaces has a FOURCC format.
                 * Do the source and dest surfaces have precisely the same
                 * FOURCC format?  (If so, this is a FOURCC copy blit.)
                 */
                if (dwDest4CC == dwSrc4CC)
                {
                    // Yes, this is a FOURCC copy blit.  Can the driver handle this?
                    if ((pdrv->ddCaps.dwCaps2 & DDCAPS2_COPYFOURCC) == 0)
                    {
                        // The driver cannot handle FOURCC copy blits.
                        sbd.helonly = TRUE;
                    }
                }
                else
                {
                    /*
                     * No, the two surfaces have different pixel formats.
                     * Now determine if either surface has a DXT* FOURCC format.
                     * The rule for the Blt API call is that the HEL _ALWAYS_
                     * performs a blit involving a DXT* source or dest surface.
                     * Hardware acceleration for DXT* blits is available only
                     * with the AlphaBlt API call.  We now enforce this rule:
                     */
                    switch (dwDest4CC)
                    {
                    case MAKEFOURCC('D','X','T','1'):
                    case MAKEFOURCC('D','X','T','2'):
                    case MAKEFOURCC('D','X','T','3'):
                    case MAKEFOURCC('D','X','T','4'):
                    case MAKEFOURCC('D','X','T','5'):
                        // This is a blit to a DXT*-formatted surface.
                        sbd.helonly = TRUE;
                        break;
                    default:
                        break;
                    }
                    switch (dwSrc4CC)
                    {
                    case MAKEFOURCC('D','X','T','1'):
                    case MAKEFOURCC('D','X','T','2'):
                    case MAKEFOURCC('D','X','T','3'):
                    case MAKEFOURCC('D','X','T','4'):
                    case MAKEFOURCC('D','X','T','5'):
                        // This is a blit from a DXT*-formatted surface.
                        sbd.helonly = TRUE;
                        break;
                    default:
                        break;
                    }
                }
            }
        }

            /*
             * check for HEL composition buffer
             */
            if( (this_dest_lcl->dwFlags & DDRAWISURF_HELCB) ||
                ((this_src_lcl != NULL) && (this_src_lcl->dwFlags & DDRAWISURF_HELCB)) )
            {
                lpbc->bHALSeesSysmem = FALSE;
                sbd.helonly = TRUE;
            }

            bd.lpDD = pdrv;

            /*
             * make sure BltFX struct is OK
             */
            bd.bltFX.dwSize = sizeof( bd.bltFX );
            if( lpDDBltFX != NULL )
            {
                if( !VALID_DDBLTFX_PTR( lpDDBltFX ) )
                {
                    DPF_ERR( "Invalid BLTFX specified" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDPARAMS;
                }
            }
            else
            {
                if( dwFlags & ( DDBLT_ALPHASRCCONSTOVERRIDE |
                                DDBLT_ALPHADESTCONSTOVERRIDE |
                                DDBLT_ALPHASRCSURFACEOVERRIDE |
                                DDBLT_ALPHADESTSURFACEOVERRIDE |
                                DDBLT_COLORFILL |
                                DDBLT_DDFX |
                                DDBLT_DDROPS |
                                DDBLT_DEPTHFILL |
                                DDBLT_KEYDESTOVERRIDE |
                                DDBLT_KEYSRCOVERRIDE |
                                DDBLT_ROP |
                                DDBLT_ROTATIONANGLE |
                                DDBLT_ZBUFFERDESTCONSTOVERRIDE |
                                DDBLT_ZBUFFERDESTOVERRIDE |
                                DDBLT_ZBUFFERSRCCONSTOVERRIDE |
                                DDBLT_ZBUFFERSRCOVERRIDE ) )
                {
                    DPF_ERR( "BltFX required but not specified" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDPARAMS;
                }
            }

            /*
             * make sure flags & associated bd.bltFX are specified OK
             */
            need_pat = FALSE;
            if( dwFlags & ~DDBLT_WAIT )
            {

                /*
                 * isolate lower use tests together
                 */
                if( dwFlags & (DDBLT_KEYSRCOVERRIDE|
                               DDBLT_KEYDESTOVERRIDE|
                               DDBLT_KEYSRC |
                               DDBLT_KEYDEST ) )
                {

#pragma message( REMIND( "Alpha turned off in Rev 1" ) )
#pragma message( REMIND( "Set read/write flags for alpha and Z" ) )
#if 0
                    /*
                     * verify ALPHA
                     */
                    if( dwFlags & DDBLT_ANYALPHA )
                    {
                        BOOL    no_alpha;

                        no_alpha = TRUE;

                        // check to see if alpha is supported
                        if( !(*(lpbc->dwBothCaps) & DDCAPS_ALPHA) )
                        {
                            GETFAILCODEBLT( *(lpbc->dwCaps),
                                            *(lpbc->dwHELCaps),
                                            sbd.halonly,
                                            sbd.helonly,
                                            DDCAPS_ALPHA );
                            if( fail )
                            {
                                DPF_ERR( "Alpha blt requested, not supported" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_NOALPHAHW;
                            }
                        }

                        /*
                         * dest alpha
                         */
                        if( dwFlags & DDBLT_ALPHADEST )
                        {
                            if( dwFlags & ( DDBLT_ALPHADESTCONSTOVERRIDE |
                                            DDBLT_ALPHADESTSURFACEOVERRIDE) )
                            {
                                DPF_ERR( "ALPHADEST and other alpha dests specified" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            psurf_lcl = FindAttached( this_dest_lcl, DDSCAPS_ALPHA );
                            if( psurf_lcl == NULL )
                            {
                                DPF_ERR( "ALPHADEST requires an attached alpha to the dest" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            dwFlags &= ~DDBLT_ALPHADEST;
                            dwFlags |= DDBLT_ALPHADESTSURFACEOVERRIDE;
                            bd.bltFX.lpDDSAlphaDest = (LPDIRECTDRAWSURFACE) psurf_lcl;
                            no_alpha = FALSE;
                            // check to see if alpha surfaces are supported
                            if( !(*(lpbc->dwBothCaps) & DDFXCAPS_ALPHASURFACES) )
                            {
                                GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                                *(lpbc->dwHELFXCaps),
                                                sbd.halonly,
                                                sbd.helonly,
                                                DDFXCAPS_ALPHASURFACES );
                                if( fail )
                                {
                                    DPF_ERR( "AlphaDest surface requested, not supported" );
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_NOALPHAHW;
                                }
                            }
                        }
                        else if( dwFlags & DDBLT_ALPHADESTCONSTOVERRIDE )
                        {
                            if( dwFlags & ( DDBLT_ALPHADESTSURFACEOVERRIDE ))
                            {
                                DPF_ERR( "ALPHADESTCONSTOVERRIDE and other alpha sources specified" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            bd.bltFX.dwConstAlphaDest = lpDDBltFX->dwConstAlphaDest;
                            no_alpha = FALSE;
                        }
                        else if( dwFlags & DDBLT_ALPHADESTSURFACEOVERRIDE )
                        {
                            psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDBltFX->lpDDSAlphaDest;
                            if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_lcl ) )
                            {
                                DPF_ERR( "ALPHASURFACEOVERRIDE requires surface ptr" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            if( SURFACE_LOST( psurf_lcl ) )
                            {
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_SURFACELOST;
                            }
                            bd.bltFX.lpDDSAlphaDest = (LPDIRECTDRAWSURFACE) psurf_lcl;
                            no_alpha = FALSE;
                            // check to see if alpha surfaces are supported
                            if( !(*(lpbc->dwBothCaps) & DDFXCAPS_ALPHASURFACES) )
                            {
                                GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                                *(lpbc->dwHELFXCaps),
                                                sbd.halonly,
                                                sbd.helonly,
                                                DDFXCAPS_ALPHASURFACES );
                                if( fail )
                                {
                                    DPF_ERR( "AlphaDestOvr surface requested, not supported" );
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_NOALPHAHW;
                                }
                            }
                        }

                        /*
                         * source alpha
                         */
                        if( dwFlags & DDBLT_ALPHASRC )
                        {
                            if( dwFlags & (DDBLT_ALPHASRCCONSTOVERRIDE|
                                           DDBLT_ALPHASRCSURFACEOVERRIDE) )
                            {
                                DPF_ERR( "ALPHASRC and other alpha sources specified" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            if( this_src == NULL )
                            {
                                DPF_ERR( "ALPHASRC requires a source surface" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            psurf_lcl = FindAttached( this_src_lcl, DDSCAPS_ALPHA );
                            if( psurf_lcl == NULL )
                            {
                                DPF_ERR( "ALPHASRC requires an attached alpha to the src" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            dwFlags &= ~DDBLT_ALPHASRC;
                            dwFlags |= DDBLT_ALPHASRCSURFACEOVERRIDE;
                            bd.bltFX.lpDDSAlphaSrc = (LPDIRECTDRAWSURFACE) psurf_lcl;
                            no_alpha = FALSE;
                            // check to see if alpha surfaces are supported
                            if( !(*(lpbc->dwBothCaps) & DDFXCAPS_ALPHASURFACES) )
                            {
                                GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                                *(lpbc->dwHELFXCaps),
                                                sbd.halonly,
                                                sbd.helonly,
                                                DDFXCAPS_ALPHASURFACES );
                                if( fail )
                                {
                                    DPF_ERR( "AlphaSrc surface requested, not supported" );
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_NOALPHAHW;
                                }
                            }
                        }
                        else if( dwFlags & DDBLT_ALPHASRCCONSTOVERRIDE )
                        {
                            if( dwFlags & ( DDBLT_ALPHASRCSURFACEOVERRIDE ))
                            {
                                DPF_ERR( "ALPHASRCCONSTOVERRIDE and other alpha sources specified" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            bd.bltFX.dwConstAlphaSrc = lpDDBltFX->dwConstAlphaSrc;
                            no_alpha = FALSE;
                        }
                        else if( dwFlags & DDBLT_ALPHASRCSURFACEOVERRIDE )
                        {
                            psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDBltFX->lpDDSAlphaSrc;
                            if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_int ) )
                            {
                                DPF_ERR( "ALPHASURFACEOVERRIDE requires surface ptr" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            psurf_lcl = psurf_int->lpLcl;
                            if( SURFACE_LOST( psurf_lcl ) )
                            {
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_SURFACELOST;
                            }
                            bd.bltFX.lpDDSAlphaSrc = (LPDIRECTDRAWSURFACE) psurf_lcl;
                            no_alpha = FALSE;
                            // check to see if alpha surfaces are supported
                            if( !(*(lpbc->dwBothCaps) & DDFXCAPS_ALPHASURFACES) )
                            {
                                GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                                *(lpbc->dwHELFXCaps),
                                                sbd.halonly,
                                                sbd.helonly,
                                                DDFXCAPS_ALPHASURFACES );
                                if( fail )
                                {
                                    DPF_ERR( "AlphaSrcOvr surface requested, not supported" );
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_NOALPHAHW;
                                }
                            }
                        }

                        if( no_alpha )
                        {
                            DPF_ERR( "ALPHA specified with no alpha surface to use" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                    }
#endif

#pragma message( REMIND( "Z blts turned off in Rev 1" ) )
#if 0
                    /*
                     * verify Z Buffer
                     */
                    if( dwFlags & DDBLT_ZBUFFER )
                    {
                        if( this_src_lcl == NULL )
                        {
                            DPF_ERR( "ZBUFFER specified, but no source data" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                        // check to see if the driver supports zbuffer blts
                        if( !(*(lpbc->dwBothCaps) & DDCAPS_ZBLTS) )
                        {
                            GETFAILCODEBLT( *(lpbc->dwCaps),
                                            *(lpbc->dwHELCaps),
                                            sbd.halonly,
                                            sbd.helonly,
                                            DDCAPS_ZBLTS );
                            if( fail )
                            {
                                DPF_ERR( "ZBuffer blt requested, not supported" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_NOZBUFFERHW;
                            }
                        }

                        bd.bltFX.dwZBufferOpCode = lpDDBltFX->dwZBufferOpCode;
                        if( dwFlags & DDBLT_ZBUFFERCONSTDESTOVERRIDE )
                        {
                            if( dwFlags & (DDBLT_ZBUFFERDESTOVERRIDE) )
                            {
                                DPF_ERR( "ZBUFFERCONSTDESTOVERRIDE and z surface specified" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            bd.bltFX.dwConstZDest = lpDDBltFX->dwConstZDest;
                        }
                        else if( dwFlags & DDBLT_ZBUFFERDESTOVERRIDE )
                        {
                            psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDBltFX->lpDDSZBufferDest;
                            if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_int ) )
                            {
                                DPF_ERR( "ZBUFFERSURFACEDESTOVERRIDE requires surface ptr" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            psurf_lcl = psurf_int->lpLcl;
                            if( SURFACE_LOST( psurf_lcl ) )
                            {
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_SURFACELOST;
                            }
                            bd.bltFX.lpDDSZBufferDest = (LPDIRECTDRAWSURFACE) psurf_lcl;
                        }
                        else
                        {
                            psurf_lcl = FindAttached( this_dest_lcl, DDSCAPS_ZBUFFER );
                            if( psurf_lcl == NULL )
                            {
                                DPF_ERR( "ZBUFFER requires an attached Z to dest" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            dwFlags |= DDBLT_ZBUFFERDESTOVERRIDE;
                            bd.bltFX.lpDDSZBufferDest = (LPDIRECTDRAWSURFACE) psurf_lcl;
                        }
                        if( dwFlags & DDBLT_ZBUFFERCONSTSRCOVERRIDE )
                        {
                            if( dwFlags & (DDBLT_ZBUFFERSRCOVERRIDE) )
                            {
                                DPF_ERR( "ZBUFFERCONSTSRCOVERRIDE and z surface specified" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            bd.bltFX.dwConstZSrc = lpDDBltFX->dwConstZSrc;
                        } else if( dwFlags & DDBLT_ZBUFFERSRCOVERRIDE )
                        {
                            psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDBltFX->lpDDSZBufferSrc;
                            if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_int ) )
                            {
                                DPF_ERR( "ZBUFFERSURFACESRCOVERRIDE requires surface ptr" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            psurf_lcl = psurf_int->lpLcl
                                if( SURFACE_LOST( psurf_lcl ) )
                                {
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_SURFACELOST;
                                }
                            bd.bltFX.lpDDSZBufferSrc = (LPDIRECTDRAWSURFACE) psurf_lcl;
                        }
                        else
                        {
                            psurf_lcl = FindAttached( this_src_lcl, DDSCAPS_ZBUFFER );
                            if( psurf_lcl == NULL )
                            {
                                DPF_ERR( "ZBUFFER requires an attached Z to src" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_INVALIDPARAMS;
                            }
                            dwFlags |= DDBLT_ZBUFFERSRCOVERRIDE;
                            bd.bltFX.lpDDSZBufferSrc = (LPDIRECTDRAWSURFACE) psurf_lcl;
                        }
                    }
#endif

                    /*
                     * verify color key overrides
                     */
                    if( dwFlags & (DDBLT_KEYSRCOVERRIDE|DDBLT_KEYDESTOVERRIDE) )
                    {
                        // see if the driver supports color key blts
                        if( !(*(lpbc->dwBothCaps) & DDCAPS_COLORKEY) )
                        {
                            GETFAILCODEBLT( *(lpbc->dwCaps),
                                            *(lpbc->dwHELCaps),
                                            sbd.halonly,
                                            sbd.helonly,
                                            DDCAPS_COLORKEY );
                            if( fail )
                            {
                                DPF_ERR( "KEYOVERRIDE specified, not supported" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_NOCOLORKEYHW;
                            }
                        }
                        if( dwFlags & DDBLT_KEYSRCOVERRIDE )
                        {
                            if( !(*(lpbc->dwBothCKeyCaps) & DDCKEYCAPS_SRCBLT) )
                            {
                                GETFAILCODEBLT( *(lpbc->dwCKeyCaps),
                                                *(lpbc->dwHELCKeyCaps),
                                                sbd.halonly,
                                                sbd.helonly,
                                                DDCKEYCAPS_SRCBLT );
                                if( fail )
                                {
                                    DPF_ERR( "KEYSRCOVERRIDE specified, not supported" );
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_NOCOLORKEYHW;
                                }
                            }
                            bd.bltFX.ddckSrcColorkey = lpDDBltFX->ddckSrcColorkey;
                        }
                        if( dwFlags & DDBLT_KEYDESTOVERRIDE )
                        {
                            if( !(*(lpbc->dwBothCKeyCaps) & DDCKEYCAPS_DESTBLT) )
                            {
                                GETFAILCODEBLT( *(lpbc->dwCKeyCaps),
                                                *(lpbc->dwHELCKeyCaps),
                                                sbd.halonly,
                                                sbd.helonly,
                                                DDCKEYCAPS_DESTBLT );
                                if( fail )
                                {
                                    DPF_ERR( "KEYDESTOVERRIDE specified, not supported" );
                                    LEAVE_BOTH_NOBUSY();
                                    return DDERR_NOCOLORKEYHW;
                                }
                            }
                            bd.bltFX.ddckDestColorkey = lpDDBltFX->ddckDestColorkey;
                            dwDestLockFlags = 0; //meaning read/write
                        }
                    }

                    /*
                     * verify src color key
                     */
                    if( dwFlags & DDBLT_KEYSRC )
                    {
                        if( this_src == NULL )
                        {
                            DPF_ERR( "KEYSRC specified, but no source data" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDOBJECT;
                        }
                        if( dwFlags & DDBLT_KEYSRCOVERRIDE )
                        {
                            DPF_ERR( "KEYSRC specified with KEYSRCOVERRIDE" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                        if( !(this_src_lcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) )
                        {
                            DPF_ERR( "KEYSRC specified, but no color key" );
                            DPF( 1, "srcFlags = %08lx", this_src_lcl->dwFlags );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                        // make sure we can do this
                        if( !(*(lpbc->dwBothCKeyCaps) & DDCKEYCAPS_SRCBLT) )
                        {
                            GETFAILCODEBLT( *(lpbc->dwCKeyCaps),
                                            *(lpbc->dwHELCKeyCaps),
                                            sbd.halonly,
                                            sbd.helonly,
                                            DDCKEYCAPS_SRCBLT );
                            if( fail )
                            {
                                DPF_ERR( "KEYSRC specified, not supported" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_NOCOLORKEYHW;
                            }
                        }
                        bd.bltFX.ddckSrcColorkey = this_src_lcl->ddckCKSrcBlt;
                        dwFlags &= ~DDBLT_KEYSRC;
                        dwFlags |= DDBLT_KEYSRCOVERRIDE;
                    }

                    /*
                     * verify dest color key
                     */
                    if( dwFlags & DDBLT_KEYDEST )
                    {
                        if( dwFlags & DDBLT_KEYDESTOVERRIDE )
                        {
                            DPF_ERR( "KEYDEST specified with KEYDESTOVERRIDE" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                        if( !(this_dest_lcl->dwFlags & DDRAWISURF_HASCKEYDESTBLT) )
                        {
                            DPF_ERR( "KEYDEST specified, but no color key" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                        // make sure we can do this
                        if( !(*(lpbc->dwBothCKeyCaps) & DDCKEYCAPS_DESTBLT) )
                        {
                            GETFAILCODEBLT( *(lpbc->dwCKeyCaps),
                                            *(lpbc->dwHELCKeyCaps),
                                            sbd.halonly,
                                            sbd.helonly,
                                            DDCKEYCAPS_DESTBLT );
                            if( fail )
                            {
                                DPF_ERR( "KEYDEST specified, not supported" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_NOCOLORKEYHW;
                            }
                        }

                        /*
                         * This next part is bug that has existed since DX1.
                         * We'd like to fix it, but we fear regression, so we
                         * only fix it for surface 3 interfaces.
                         */
                        if( ( this_src_int->lpVtbl == &ddSurfaceCallbacks ) ||
                            ( this_src_int->lpVtbl == &ddSurface2Callbacks ) )
                        {
                            bd.bltFX.ddckDestColorkey = this_src_lcl->ddckCKDestBlt;
                        }
                        else
                        {
                            bd.bltFX.ddckDestColorkey = this_dest_lcl->ddckCKDestBlt;
                        }
                        dwFlags &= ~DDBLT_KEYDEST;
                        dwFlags |= DDBLT_KEYDESTOVERRIDE;
                        dwDestLockFlags = 0; //meaning read/write
                    }
                }

                /*
                 * verify various flags
                 */
                if( !(dwFlags &(DDBLT_ROP |
                                DDBLT_COLORFILL |
                                DDBLT_DDROPS |
                                DDBLT_DEPTHFILL |
                                DDBLT_ROTATIONANGLE |
                                DDBLT_DDFX) ) )
                {
                    if( this_src == NULL )
                    {
                        DPF_ERR( "Need a source for blt" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    dwFlags |= DDBLT_ROP;
                    bd.bltFX.dwROP = SRCCOPY;
                }
                /*
                 * verify ROP
                 */
                else if( dwFlags & DDBLT_ROP )
                {
                    DWORD   idx;
                    DWORD   bit;

                    if( dwFlags & (DDBLT_DDFX |
                                   DDBLT_COLORFILL|
                                   DDBLT_DEPTHFILL|
                                   DDBLT_ROTATIONANGLE|
                                   DDBLT_DDROPS))
                    {
                        DPF_ERR( "Invalid flags specified with ROP" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    bd.bltFX.dwROP = lpDDBltFX->dwROP;

                    rop = (DWORD) LOBYTE( HIWORD( bd.bltFX.dwROP ) );
                    idx = rop/32;
                    bit = 1 << (rop % 32 );
                    DPF( 4, "Trying ROP %d, idx=%d, bit=%08lx", rop, idx, bit );

                    /*
                     * We disable ROP flags on NT, so don't fail if they're only doing a SRCCOPY
                     */
                    if( lpDDBltFX->dwROP != SRCCOPY )
                    {
                        /*
                         * see if both HEL & HAL support the ROP
                         */
                        if( !(lpbc->dwBothRops[idx] & bit ) )
                        {
                            GETFAILCODEBLT( lpbc->dwRops[idx],
                                            lpbc->dwHELRops[idx],
                                            sbd.halonly,
                                            sbd.helonly,
                                            bit );
                            if( fail )
                            {
                                DPF_ERR( "ROP not supported" );
                                LEAVE_BOTH_NOBUSY();
                                return DDERR_NORASTEROPHW;
                            }
                        }
                    }
                    bd.dwROPFlags = cROPTable[ rop ];
                    if( bd.dwROPFlags & ROP_HAS_SOURCE )
                    {
                        if( this_src == NULL )
                        {
                            DPF_ERR( "ROP required a surface" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_INVALIDPARAMS;
                        }
                    }
                    if( bd.dwROPFlags & ROP_HAS_PATTERN )
                    {
                        need_pat = TRUE;
                    }
                }
                /*
                 * verify COLORFILL
                 */
                else if( dwFlags & DDBLT_COLORFILL )
                {
                    if( this_src != NULL )
                    {
                        DPF_ERR( "COLORFILL specified along with source surface" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    /*
                     * You cannot use COLORFILL to clear Z-buffers anymore. You must
                     * explicitly use DEPTHFILL. Disallow Z-buffer destinations.
                     */
                    if( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
                    {
                        DPF_ERR( "Z-Buffer cannot be target of a color fill blt" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    if( !(*(lpbc->dwBothCaps) & DDCAPS_BLTCOLORFILL) )
                    {
                        GETFAILCODEBLT( *(lpbc->dwCaps),
                                        *(lpbc->dwHELCaps),
                                        sbd.halonly,
                                        sbd.helonly,
                                        DDCAPS_BLTCOLORFILL );
                        if( fail )
                        {
                            DPF_ERR( "COLORFILL specified, not supported" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_UNSUPPORTED;
                        }
                    }

                    /*
                     * Maks off the high order bits of the colorfill
                     * value since some drivers will fail if they're set.
                     */
                    GET_PIXEL_FORMAT( this_dest_lcl, this_dest, pddpf );
                    if( pddpf->dwRGBBitCount <= 8 )
                    {
                         lpDDBltFX->dwFillColor &= 0x00ff;
                    }
                    else if( pddpf->dwRGBBitCount == 16 )
                    {
                         lpDDBltFX->dwFillColor &= 0x00ffff;
                    }
                    else if( pddpf->dwRGBBitCount == 24 )
                    {
                        lpDDBltFX->dwFillColor &= 0x00ffffff;
                    }

                    bd.bltFX.dwFillColor = lpDDBltFX->dwFillColor;
                }
                /*
                 * verify DEPTHFILL
                 */
                else if( dwFlags & DDBLT_DEPTHFILL )
                {
                    if( this_src != NULL )
                    {
                        DPF_ERR( "DEPTHFILL specified along with source surface" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    /*
                     * Ensure the destination is a z-buffer.
                     */
                    if( !( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER ) )
                    {
                        DPF_ERR( "DEPTHFILL specified but destination is not a Z-buffer" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }

                    if( !(*(lpbc->dwBothCaps) & DDCAPS_BLTDEPTHFILL) )
                    {
                        GETFAILCODEBLT( *(lpbc->dwCaps),
                                        *(lpbc->dwHELCaps),
                                        sbd.halonly,
                                        sbd.helonly,
                                        DDCAPS_BLTDEPTHFILL );
                        if( fail )
                        {
                            DPF_ERR( "DEPTHFILL specified, not supported" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_UNSUPPORTED;
                        }
                    }
                    bd.bltFX.dwFillDepth = lpDDBltFX->dwFillDepth;

                    // hack to pass DepthBlt WriteMask to BlitLib
                    bd.bltFX.dwZDestConstBitDepth = lpDDBltFX->dwZDestConstBitDepth;
                }
                /*
                 * verify DDROPS
                 */
                else if( dwFlags & DDBLT_DDROPS )
                {
                    if( dwFlags & (DDBLT_DDFX |
                                   DDBLT_COLORFILL|
                                   DDBLT_DEPTHFILL|
                                   DDBLT_ROTATIONANGLE) )
                    {
                        DPF_ERR( "Invalid flags specified with DDROPS" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    bd.bltFX.dwDDROP = lpDDBltFX->dwDDROP;
                    DPF_ERR( "DDROPS unsupported" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_NODDROPSHW;
                }
                /*
                 * verify DDFX
                 */
                else if( dwFlags & DDBLT_DDFX )
                {
                    if( dwFlags & (DDBLT_COLORFILL |
                                   DDBLT_DEPTHFILL |
                                   DDBLT_ROTATIONANGLE) )
                    {
                        DPF_ERR( "Invalid flags specified with DDFX" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }

                    if( lpDDBltFX->dwDDFX & ( DDBLTFX_ARITHSTRETCHY ) )
                    {
                        DPF_ERR( "DDBLTFX_ARITHSTRETCHY unsupported" );

                        LEAVE_BOTH_NOBUSY();
                        return DDERR_NOSTRETCHHW;
                    }

                    if( lpDDBltFX->dwDDFX & ( DDBLTFX_MIRRORLEFTRIGHT ) )
                    {
                        GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                        *(lpbc->dwHELFXCaps),
                                        sbd.halonly,
                                        sbd.helonly,
                                        DDFXCAPS_BLTMIRRORLEFTRIGHT );
                        if( fail )
                        {
                            DPF_ERR( "Mirroring along vertical axis not supported" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_NOMIRRORHW;
                        }
                    }
                    if( lpDDBltFX->dwDDFX & ( DDBLTFX_MIRRORUPDOWN ) )
                    {
                        GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                        *(lpbc->dwHELFXCaps),
                                        sbd.halonly,
                                        sbd.helonly,
                                        DDFXCAPS_BLTMIRRORUPDOWN );
                        if( fail )
                        {
                            DPF_ERR( "Mirroring along horizontal axis not supported" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_NOMIRRORHW;
                        }
                    }
                    if( lpDDBltFX->dwDDFX & ( DDBLTFX_ROTATE90 | DDBLTFX_ROTATE180 | DDBLTFX_ROTATE270 ) )
                    {
                        GETFAILCODEBLT( *(lpbc->dwFXCaps),
                                        *(lpbc->dwHELFXCaps),
                                        sbd.halonly,
                                        sbd.helonly,
                                        DDFXCAPS_BLTROTATION90 );
                        if( fail )
                        {
                            DPF_ERR( "90-degree rotations not supported" );
                            LEAVE_BOTH_NOBUSY();
                            return DDERR_NOROTATIONHW;
                        }
                    }
                    bd.bltFX.dwDDFX = lpDDBltFX->dwDDFX;
                    dwFlags |= DDBLT_ROP;
                    bd.bltFX.dwROP = SRCCOPY;
                    /*
                     * verify ROTATIONANGLE
                     */
                }
                else if( dwFlags & DDBLT_ROTATIONANGLE )
                {
                    if( dwFlags & (DDBLT_COLORFILL | DDBLT_DEPTHFILL) )
                    {
                        DPF_ERR( "Invalid flags specified with ROTATIONANGLE" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDPARAMS;
                    }
                    bd.bltFX.dwRotationAngle = lpDDBltFX->dwRotationAngle;
                    DPF_ERR( "ROTATIONANGLE unsupported" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_NOROTATIONHW;
                    /*
                     * you should have told me SOMETHING!
                     */
                }
                else
                {
                    DPF_ERR( "no blt type specified!" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDPARAMS;
                }
                /*
                 * no flags, we are doing a generic SRCCOPY
                 */
            }
            else
            {
                if( this_src == NULL )
                {
                    DPF_ERR( "Need a source for blt" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDPARAMS;
                }
                dwFlags |= DDBLT_ROP;
                bd.bltFX.dwROP = SRCCOPY;
            }

            /*
             * verify pattern
             */
            if( need_pat )
            {
                psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDBltFX->lpDDSPattern;
                if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_int ) )
                {
                    DPF_ERR( "Invalid pattern surface specified" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDOBJECT;
                }
                psurf_lcl = psurf_int->lpLcl;
                bd.bltFX.lpDDSPattern = (LPDIRECTDRAWSURFACE) psurf_lcl;
                if( SURFACE_LOST( psurf_lcl ) )
                {
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_SURFACELOST;
                }

#pragma message( REMIND( "What about general (non-8x8) patterns?" ))
                if( psurf_lcl->lpGbl->wHeight != 8 || psurf_lcl->lpGbl->wWidth != 8 )
                {
                    DPF_ERR( "Pattern surface must be 8 by 8" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDPARAMS;
                }
                dwFlags |= DDBLT_PRIVATE_ALIASPATTERN;
            }

            /*
             * make sure dest rect is OK
             */
            if( lpDestRect != NULL )
            {
                if( !VALID_RECT_PTR( lpDestRect ) )
                {
                    DPF_ERR( "Invalid dest rect specified" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDRECT;
                }
                bd.rDest = *(LPRECTL)lpDestRect;
            }
            else
            {
                MAKE_SURF_RECT( this_dest, this_dest_lcl, bd.rDest );
            }

            /*
             * make sure src rect is OK
             */
            if( lpSrcRect != NULL )
            {
                if( !VALID_RECT_PTR( lpSrcRect ) )
                {
                    DPF_ERR( "Invalid src rect specified" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDRECT;
                }
                bd.rSrc = *(LPRECTL)lpSrcRect;
            }
            else
            {
                if( this_src != NULL )
                {
                    MAKE_SURF_RECT( this_src, this_src_lcl, bd.rSrc );
                }
            }

            /*
             * get dimensions & check them
             */
            stretch_blt = FALSE;
            sbd.dest_height = bd.rDest.bottom - bd.rDest.top;
            sbd.dest_width = bd.rDest.right - bd.rDest.left;

            // Need positive heights/widths
            if( ((int)sbd.dest_height <= 0) || ((int)sbd.dest_width <= 0) )
            {
                DPF_ERR( "Invalid destination dimensions: Zero/Negative Heights and/or Widths not allowed");
                DPF(0,"Erroneous dest dimensions were: (wid %d, hgt %d)",(int)sbd.dest_width,(int)sbd.dest_height);
                LEAVE_BOTH_NOBUSY();
                return DDERR_INVALIDRECT;
            }
            // Is there a clipper? If so no more checks.
            if( this_dest_lcl->lpDDClipper == NULL )
            {
                // Multi-mon: is this the primary for the desktop? This
                // is the only case where the upper-left coord of the surface is not
                // (0,0)
                if( (pdrv->dwFlags & DDRAWI_VIRTUALDESKTOP) &&
                    (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) )
                {
                    if( (bd.rDest.left   < pdrv->rectDesktop.left) ||
                        (bd.rDest.top    < pdrv->rectDesktop.top)  ||
                        (bd.rDest.right  > pdrv->rectDesktop.right)||
                        (bd.rDest.bottom > pdrv->rectDesktop.bottom) )
                    {
                        DPF_ERR( "Blt Destination doesn't fit on Desktop And No Clipper was specified" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDRECT;
                    }
                    if( OverlapsDevices( this_dest_lcl, (LPRECT) &bd.rDest ) )
                    {
                        sbd.helonly = gdiblt = TRUE;
                    }
                }
                else
                {
                    if( (int)bd.rDest.left < 0 ||
                        (int)bd.rDest.top < 0  ||
                        (DWORD)bd.rDest.bottom > (DWORD)this_dest->wHeight ||
                        (DWORD)bd.rDest.right > (DWORD)this_dest->wWidth )
                    {
                        DPF_ERR( "Invalid Blt destination dimensions" );
                        DPF(0, "width/height = %d x %d, dest rect = (%d, %d)-(%d, %d)",
                            this_dest->wWidth, this_dest->wHeight,
                            bd.rDest.left, bd.rDest.top, bd.rDest.right, bd.rDest.bottom);
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDRECT;
                    }
                }
            }
            else if( (pdrv->dwFlags & DDRAWI_VIRTUALDESKTOP) &&
                     (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) )
            {
                if( OverlapsDevices( this_dest_lcl, (LPRECT) &bd.rDest ) )
                {
                    sbd.helonly = gdiblt = TRUE;
                }
            }

            if( this_src != NULL )
            {
                sbd.src_height = bd.rSrc.bottom - bd.rSrc.top;
                sbd.src_width = bd.rSrc.right - bd.rSrc.left;
                if( ((int)sbd.src_height <= 0) || ((int)sbd.src_width <= 0) )
                {
                    DPF_ERR( "BLT error. Can't have non-positive height or width" );
                    LEAVE_BOTH_NOBUSY();
                    return DDERR_INVALIDRECT;
                }
                // Multi-mon: is this the primary for the desktop? This
                // is the only case where the upper-left coord of the surface is not
                // (0,0)
                if( (this_src->lpDD->dwFlags & DDRAWI_VIRTUALDESKTOP) &&
                    (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) )
                {

                    if( (bd.rSrc.left   < this_src->lpDD->rectDesktop.left) ||
                        (bd.rSrc.top    < this_src->lpDD->rectDesktop.top)  ||
                        (bd.rSrc.right  > this_src->lpDD->rectDesktop.right)||
                        (bd.rSrc.bottom > this_src->lpDD->rectDesktop.bottom) )
                    {
                        DPF_ERR( "Blt Source dimension doesn't fit on Desktop" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDRECT;
                    }
                    if( OverlapsDevices( this_src_lcl, (LPRECT) &bd.rSrc ) )
                    {
                        sbd.helonly = gdiblt = TRUE;
                    }
                }
                else
                {
                    if( (int)bd.rSrc.left < 0 ||
                        (int)bd.rSrc.top < 0  ||
                        (DWORD)bd.rSrc.bottom > (DWORD)this_src->wHeight ||
                        (DWORD)bd.rSrc.right > (DWORD)this_src->wWidth )
                    {
                        DPF_ERR( "Invalid Blt Source dimensions" );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_INVALIDRECT;
                    }

                }

                /*
                 * verify stretching...
                 *
                 */
                if( sbd.src_height != sbd.dest_height || sbd.src_width != sbd.dest_width )
                {
                    HRESULT ddrval;

                    ddrval = checkBltStretching( lpbc, &sbd );

                    if( ddrval != DD_OK )
                    {
                        DPF_ERR( "Failed checkBltStretching" );
                        LEAVE_BOTH_NOBUSY();
                        return ddrval;
                    }
                    stretch_blt  = TRUE;
                }
            }
        }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            DPF_ERR( "Exception encountered validating parameters" );
            LEAVE_BOTH_NOBUSY();
            return DDERR_INVALIDPARAMS;
        }

    /*
     * now shovel the data...
     */
    TRY
        {
            /*
             * final bits of blt data
             */
            bd.lpDDDestSurface = this_dest_lcl;
            bd.lpDDSrcSurface = this_src_lcl;
            bd.dwFlags = dwFlags;

    /*
     * Set up for a HAL or a HEL call
     */
            if( pdrv_lcl->lpDDCB->HALDDSurface.Blt == NULL )
            {
                sbd.helonly = TRUE;
            }
            if( sbd.helonly && sbd.halonly )
            {
                DPF_ERR( "BLT not supported in software or hardware" );
                LEAVE_BOTH_NOBUSY();
                return DDERR_NOBLTHW;
            }

            // Did the mode change since ENTER_DDRAW?
#ifdef WINNT
            if ( DdQueryDisplaySettingsUniqueness() != uDisplaySettingsUnique )
            {
                // mode changed, don't do the blt
                DPF_ERR( "Mode changed between ENTER_DDRAW and HAL call" );
                LEAVE_BOTH_NOBUSY()
                    return DDERR_SURFACELOST;
            }
            if( !sbd.helonly )
            {
                if (this_src_lcl && !this_src_lcl->hDDSurface 
                    && !CompleteCreateSysmemSurface(this_src_lcl))
                {
                    DPF_ERR("Can't blt from SYSTEM surface w/o Kernel Object");
                    LEAVE_BOTH_NOBUSY()
                    return DDERR_GENERIC;
                }
                if (!this_dest_lcl->hDDSurface 
                    && !CompleteCreateSysmemSurface(this_dest_lcl))
                {
                    DPF_ERR("Can't blt to SYSTEM surface w/o Kernel Object");
                    LEAVE_BOTH_NOBUSY()
                    return DDERR_GENERIC;
                }
            }
#endif

            /*
     * Some drivers (like S3) do stuff in their BeginAccess call
     * that screws up stuff that they did in their DDHAL Lock Call.
     *
     * Exclusion needs to happen BEFORE the lock call to prevent this.
     *
     */
#if defined(WIN95)
            if( this_dest_lcl->lpDDClipper != NULL )
            {
                /*
                 * exclude the mouse cursor.
         *
         * we only need to do this for the windows display driver
         *
         * we only need to do this if we are blting to or from the
         * primary surface.
         *
         * we only do this in the clipping case, we figure if the
         * app cares enough to not scribble all over other windows
         * he also cares enough to not to wipe out the cursor.
         *
         * we only need to do this if the driver is using a
         * software cursor.
             *
             * NOTE
             *  we should check and only do this on the primary?
             *  we should make sure the clipper is window based?
             *  we should check for the source being the primary?
         *
         */
                if ( (pdrv->dwFlags & DDRAWI_DISPLAYDRV) && pdrv->dwPDevice &&
                     !(*pdrv->lpwPDeviceFlags & HARDWARECURSOR) &&
                     (this_dest->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) )
                {
                    if ( lpDDDestSurface == lpDDSrcSurface )
                    {
                        RECTL rcl;
                        UnionRect((RECT*)&rcl, (RECT*)&bd.rDest, (RECT*)&bd.rSrc);
                        DD16_Exclude(pdrv->dwPDevice, &rcl);
                    }
                    else
                    {
                        DD16_Exclude(pdrv->dwPDevice, &bd.rDest);
                    }
                }
            }
#endif

            if( !sbd.helonly ) // must not be HEL call
            {
                DPF( 4, "Hardware Blt");
                sbd.bltfn = pdrv_lcl->lpDDCB->HALDDSurface.Blt;
                bd.Blt = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.Blt;

                /*
                 * Take pagelocks if required
                 */
                dest_lock_taken = FALSE;
                src_lock_taken = FALSE;

                dest_pagelock_taken = FALSE;
                src_pagelock_taken = FALSE;

                if ( lpbc->bHALSeesSysmem )
                {
                    /*
                     * If the HAL requires page locks...
                     */
                    if ( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_NOPAGELOCKREQUIRED ) )
                    {
                        HRESULT hr;
                        /*
                         * ...then setup to take them if they're not already pagelocked.
                         */
                        if ( ( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY &&
                               this_dest_lcl->lpSurfMore->dwPageLockCount == 0 ) )
                        {
                            hr = InternalPageLock( this_dest_lcl, pdrv_lcl );
                            if (FAILED(hr))
                            {
                                LEAVE_BOTH_NOBUSY()
                                    return hr;
                            }
                            else
                            {
                                dest_pagelock_taken=TRUE;
                            }
                        }

                        if ( this_src_lcl && ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY &&
                                               this_src_lcl->lpSurfMore->dwPageLockCount == 0 ))
                        {
                            hr = InternalPageLock( this_src_lcl, pdrv_lcl );
                            if (FAILED(hr))
                            {
                                if (dest_pagelock_taken)
                                    InternalPageUnlock( this_dest_lcl, pdrv_lcl );

                                LEAVE_BOTH_NOBUSY()
                                    return hr;
                            }
                            else
                            {
                                src_pagelock_taken=TRUE;
                            }
                        }
                    }
                }
            }

            /*
     * Blt the unclipped case
     */
            if( this_dest_lcl->lpDDClipper == NULL )
            {
                bd.IsClipped = FALSE;   // no clipping

                // if hel only, check and take locks on video mem surfaces.
                if( sbd.helonly )
                {
                    sbd.bltfn = pdrv_lcl->lpDDCB->HELDDSurface.Blt;
                    /*
                     * take locks on vram surfaces
                     */
                    if( !(this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                        ( !gdiblt || !( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) ) )
                    {
                        while( 1 )
                        {
                            ddrval = InternalLock( this_dest_lcl, &dest_bits , NULL, dwDestLockFlags );
                            if( ddrval == DD_OK )
                            {
                                GET_LPDDRAWSURFACE_GBL_MORE(this_dest)->fpNTAlias = (FLATPTR) dest_bits;
                                break;
                            }
                            if( ddrval == DDERR_WASSTILLDRAWING )
                            {
                                continue;
                            }
                            DONE_EXCLUDE();
                            (*pdflags) &= ~BUSY;
                            LEAVE_BOTH();
                            return ddrval;
                        }
                        dest_lock_taken = TRUE;
                    }
                    else
                    {
                        /*
                         * If this surface was involved in a hardware op, we need to
                         * probe the driver to see if it's done. NOTE this assumes
                         * that only one driver can be responsible for a system memory
                         * operation. See comment with WaitForDriverToFinishWithSurface.
                         */
                        if( this_dest->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
                        {
                            WaitForDriverToFinishWithSurface(pdrv_lcl, this_dest_lcl );
                        }
                        dest_lock_taken = FALSE;
                    }

                    if( ( this_src != NULL) && (lpDDSrcSurface != lpDDDestSurface) &&
                        ( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) == 0) )
                    {
                        while( 1 )
                        {
                            ddrval = InternalLock( this_src_lcl, &src_bits, NULL, dwSourceLockFlags );
                            if( ddrval == DD_OK )
                            {
                                GET_LPDDRAWSURFACE_GBL_MORE(this_src)->fpNTAlias = (FLATPTR) src_bits;
                                break;
                            }
                            if( ddrval == DDERR_WASSTILLDRAWING )
                            {
                                continue;
                            }
                            if( dest_lock_taken )
                            {
                                InternalUnlock( this_dest_lcl,NULL,NULL,0 );
                                dest_lock_taken=FALSE;
                            }
                            DONE_EXCLUDE();
                            (*pdflags) &= ~BUSY;
                            LEAVE_BOTH();
                            return ddrval;
                        }
                        src_lock_taken = TRUE;
                    }
                    else
                    {
                        /*
                         * If this surface was involved in a hardware op, we need to
                         * probe the driver to see if it's done. NOTE this assumes
                         * that only one driver can be responsible for a system memory
                         * operation. See comment with WaitForDriverToFinishWithSurface.
                         */
                        if( this_src && ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
                            && (this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED) )
                        {
                            WaitForDriverToFinishWithSurface(pdrv_lcl, this_src_lcl );
                        }

                        src_lock_taken = FALSE;
                    }
                }

                /*
                 * Add a rect to the region list if this is a managed surface
                 */
                if(IsD3DManaged(this_dest_lcl))
                {
                    LPREGIONLIST lpRegionList = this_dest_lcl->lpSurfMore->lpRegionList;
                    if(lpDestRect)
                    {
                        if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                        {
                            lpRegionList->rect[(lpRegionList->rdh.nCount)++] = bd.rDest;
                            lpRegionList->rdh.nRgnSize += sizeof(RECT);
                            if(bd.rDest.left < lpRegionList->rdh.rcBound.left)
                                lpRegionList->rdh.rcBound.left = bd.rDest.left;
                            if(bd.rDest.right > lpRegionList->rdh.rcBound.right)
                                lpRegionList->rdh.rcBound.right = bd.rDest.right;
                            if(bd.rDest.top < lpRegionList->rdh.rcBound.top)
                                lpRegionList->rdh.rcBound.top = bd.rDest.top;
                            if(bd.rDest.bottom > lpRegionList->rdh.rcBound.bottom)
                                lpRegionList->rdh.rcBound.bottom = bd.rDest.bottom;
                        }
                    }
                    else
                    {
                        /* Mark everything dirty */
                        lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
                    }
                }

            try_again:
                if( sbd.helonly )
                {
                    // Release busy now or GDI blt will fail
                    DONE_BUSY();
                }

                if (bd.dwFlags & DDBLT_PRESENTATION)
                {
                    bd.dwFlags |= DDBLT_LAST_PRESENTATION;
                }

                DOHALCALL_NOWIN16( Blt, sbd.bltfn, bd, rc, sbd.helonly );
#ifdef WINNT
                if (rc == DDHAL_DRIVER_HANDLED && bd.ddRVal == DDERR_VISRGNCHANGED)
                {
                    DPF(5,"Resetting VisRgn for surface %x", this_dest_lcl);
                    DdResetVisrgn(this_dest_lcl, (HWND)0);
                    goto try_again;
                }
#endif
                if ( rc == DDHAL_DRIVER_HANDLED )
                {
                    if ( (dwFlags & DDBLT_WAIT) &&
                         bd.ddRVal == DDERR_WASSTILLDRAWING )
                    {
                        DPF(4, "Waiting.....");
                        goto try_again;
                    }
                    /*
                     * Note that the !helonly here is pretty much an assert.
                     * Thought it safer to actually test it, since that is actually what we mean.
                     */
                    if( !sbd.helonly && lpbc->bHALSeesSysmem && (bd.ddRVal == DD_OK) )
                    {
                        DPF(5,B,"Tagging surface %08x",this_dest);
                        if (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                            this_dest->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPDEST;
                        if (this_src)
                        {
                            DPF(5,B,"Tagging surface %08x",this_src);
                            if (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                                this_src->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPSOURCE;
                        }
                    }
                }
            }
            else
            {
                /*
                 * Blt when the destination is clipped
                 */
                DWORD       cnt;
                DWORD       total;
                LPRECT      prect;
                DWORD       size;
                LPRGNDATA       prd=(LPRGNDATA)0;
                int         x_offset;
                int         y_offset;
                DWORD       scale_x;
                DWORD       scale_y;
                RECT        rSurfDst;

        // Keep a flag to indicate whether we need to free 'prd' or not
                BOOL        fMustFreeRegion = FALSE;
                // Use a stack buffer for most clipping cases
                BYTE        buffer[sizeof(RGNDATAHEADER) + NUM_RECTS_IN_REGIONLIST * sizeof(RECTL)];

                bd.rOrigSrc = bd.rSrc;
                bd.rOrigDest = bd.rDest;

#ifdef WINNT
                // For NT, we need to deal with a clip-list change
                // at many different points of the BLT
            get_clipping_info:
                if ( fMustFreeRegion )
                {
                    MemFree( prd );
                    prd = NULL;
                    fMustFreeRegion = FALSE;
                }
#endif

                bd.IsClipped = TRUE;    // yes, we are clipping

        // Call the internal GetClipList which avoids the checking
                DDASSERT( !fMustFreeRegion );
                prd = (LPRGNDATA)&buffer[0];
                size = sizeof(buffer);

                ddrval = InternalGetClipList(
                    (LPDIRECTDRAWCLIPPER) this_dest_lcl->lpSurfMore->lpDDIClipper,
                    (LPRECT)&bd.rOrigDest, prd, &size, pdrv );

                // Fatal error?
                if( ddrval != DD_OK && ddrval != DDERR_REGIONTOOSMALL )
                {
                    DPF_ERR( "GetClipList FAILED" );
                    DONE_LOCKS();
                    DONE_EXCLUDE();
                    if (dest_pagelock_taken)
                        InternalPageUnlock( this_dest_lcl, pdrv_lcl );
                    if (src_pagelock_taken)
                        InternalPageUnlock( this_src_lcl, pdrv_lcl );
                    LEAVE_BOTH_NOBUSY();
                    return ddrval;
                }

                if ( size <= sizeof(RGNDATA) )
                {
                    DPF( 4, "Totally clipped" );
                    rc = DDHAL_DRIVER_HANDLED;
                    bd.ddRVal = DD_OK;
                    goto null_clip_rgn;
                }

                // If the clip region is larger than our stack buffer,
                // then allocate a buffer
                if ( size > sizeof(buffer) )
                {
                    DDASSERT( !fMustFreeRegion );
                    prd = MemAlloc( size );
                    if( prd == NULL )
                    {
                        DONE_LOCKS();
                        DONE_EXCLUDE();
                        if (dest_pagelock_taken)
                            InternalPageUnlock( this_dest_lcl, pdrv_lcl );
                        if (src_pagelock_taken)
                            InternalPageUnlock( this_src_lcl, pdrv_lcl );
                        LEAVE_BOTH_NOBUSY();
                        return DDERR_OUTOFMEMORY;
                    }
                    fMustFreeRegion = TRUE;
                    ddrval = InternalGetClipList(
                        (LPDIRECTDRAWCLIPPER) this_dest_lcl->lpSurfMore->lpDDIClipper,
                        (LPRECT)&bd.rOrigDest, prd, &size, pdrv );
                    if( ddrval != DD_OK )
                    {
#ifdef WINNT
                        if( ddrval == DDERR_REGIONTOOSMALL )
                        {
                            // the visrgn changed between the first and second calls to GetClipList.
                            // try again.
                            DDASSERT( fMustFreeRegion );
                            MemFree( prd );
                            prd = NULL;
                            fMustFreeRegion = FALSE;

                            goto get_clipping_info;
                        }
#else
                        // Region can't change size on Win95! We took a lock!
                        DDASSERT( ddrval != DDERR_REGIONTOOSMALL );
#endif

                        DPF_ERR( "GetClipList FAILED" );
                        DDASSERT( fMustFreeRegion );
                        MemFree( prd );
                        DONE_LOCKS();
                        DONE_EXCLUDE();
                        if (dest_pagelock_taken)
                            InternalPageUnlock( this_dest_lcl, pdrv_lcl );
                        if (src_pagelock_taken)
                            InternalPageUnlock( this_src_lcl, pdrv_lcl );
                        LEAVE_BOTH_NOBUSY();
                        return ddrval;
                    }
                }

                // Clip region to surface dimensions
                MAKE_SURF_RECT( this_dest, this_dest_lcl, rSurfDst );

                // Clip the regiondata the we have down to
                // the surface that we care about. Prevents
                // memory trashing.
                if( !gdiblt )
                {
                    ClipRgnToRect( &rSurfDst, prd );
                }

                total = prd->rdh.nCount;
                DPF( 5, "total vis rects = %ld", total );
                prect = (LPRECT) &prd->Buffer[0];
                rc = DDHAL_DRIVER_HANDLED;
                bd.ddRVal = DD_OK;

            // if hel only, check and take locks on video mem surfaces.
                if( sbd.helonly )
                {
                    sbd.bltfn = pdrv_lcl->lpDDCB->HELDDSurface.Blt;

                    /*
                     * take locks on vram surfaces
                     */
                    if( !(this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                        ( !gdiblt || !( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) ) )
                    {
                        while( 1 )
                        {
                            DPF(5,"Locking dest: %x", this_dest_lcl);
#ifdef WINNT
                            /*
                             * On Win2K, locking the entire primary is expensive as it often causes GDI 
                             * to needlessly rebuild it's sprites.  Hence, we will only lock the rect
                             * that we actually care about.
                             */
                            if( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
                            {
                                ddrval = InternalLock( this_dest_lcl, &dest_bits, (LPRECT)&bd.rDest, 
                                    DDLOCK_FAILONVISRGNCHANGED | dwDestLockFlags );
                                if( ddrval == DD_OK )
                                {
                                    subrect_lock_taken = TRUE;
                                    subrect_lock_rect.left = bd.rDest.left;
                                    subrect_lock_rect.right = bd.rDest.right;
                                    subrect_lock_rect.top = bd.rDest.top;
                                    subrect_lock_rect.bottom = bd.rDest.bottom;
                                }
                            }
                            else
                            {
#endif                               
                            ddrval = InternalLock( this_dest_lcl, &dest_bits , NULL, DDLOCK_FAILONVISRGNCHANGED | dwDestLockFlags );
#ifdef WINNT
                            }
                            if (ddrval == DDERR_VISRGNCHANGED)
                            {
                                DPF(5,"Resetting VisRgn for surface %x", this_dest_lcl);
                                DdResetVisrgn(this_dest_lcl, (HWND)0);
                                DONE_LOCKS(); //should do nothing... here for ortho
                                goto get_clipping_info;
                            }
#endif
                            if( ddrval == DD_OK )
                            {
                                GET_LPDDRAWSURFACE_GBL_MORE(this_dest)->fpNTAlias = (FLATPTR) dest_bits;
                                break;
                            }
                            if( ddrval == DDERR_WASSTILLDRAWING )
                            {
                                continue;
                            }

                            if( fMustFreeRegion )
                                MemFree( prd );

                            DONE_LOCKS();
                            DONE_EXCLUDE();
                            (*pdflags) &= ~BUSY;
                            LEAVE_BOTH();
                            return ddrval;
                        }
                        dest_lock_taken = TRUE;
                    }
                    else
                    {
                        /*
                         * If this surface was involved in a hardware op, we need to
                         * probe the driver to see if it's done. NOTE this assumes
                         * that only one driver can be responsible for a system memory
                         * operation. See comment with WaitForDriverToFinishWithSurface.
                         */
                        if( (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                            (this_dest->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED) )
                        {
                            WaitForDriverToFinishWithSurface(pdrv_lcl, this_dest_lcl );
                        }

                        dest_lock_taken = FALSE;
                    }

                    if( ( this_src != NULL) && (lpDDSrcSurface != lpDDDestSurface) &&
                        ( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) == 0) )
                    {
                        while( 1 )
                        {
                            DPF(5,"Locking src: %x", this_src_lcl);
                            ddrval = InternalLock( this_src_lcl, &src_bits , NULL, DDLOCK_FAILONVISRGNCHANGED | dwSourceLockFlags );
#ifdef WINNT
                            if (ddrval == DDERR_VISRGNCHANGED)
                            {
                                DPF(5,"Resetting VisRgn for surface %x", this_dest_lcl);
                                DdResetVisrgn(this_dest_lcl, (HWND)0);
                                DONE_LOCKS();
                                goto get_clipping_info;
                            }
#endif
                            if( ddrval == DD_OK )
                            {
                                GET_LPDDRAWSURFACE_GBL_MORE(this_src)->fpNTAlias = (FLATPTR) src_bits;
                                break;
                            }
                            if( ddrval == DDERR_WASSTILLDRAWING )
                            {
                                continue;
                            }
                            if( fMustFreeRegion )
                                MemFree( prd );
                            DONE_LOCKS();
                            DONE_EXCLUDE();
                            (*pdflags) &= ~BUSY;
                            LEAVE_BOTH();
                            return ddrval;
                        }
                        src_lock_taken = TRUE;
                    }
                    else
                    {
                        /*
                         * If this surface was involved in a hardware op, we need to
                         * probe the driver to see if it's done. NOTE this assumes
                         * that only one driver can be responsible for a system memory
                         * operation. See comment with WaitForDriverToFinishWithSurface.
                         */
                        if( this_src && (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                            (this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED) )
                        {
                            WaitForDriverToFinishWithSurface(pdrv_lcl, this_src_lcl );
                        }

                        src_lock_taken = FALSE;
                    }
                }

                /*
         * See if the driver wants to do the clipping
         */
                if( (stretch_blt && (*(lpbc->dwCaps) & DDCAPS_CANCLIPSTRETCHED)) ||
                    (!stretch_blt && (*(lpbc->dwCaps) & DDCAPS_CANCLIP)) )
                {
                    // The driver will do the clipping
                    bd.dwRectCnt = total;
                    bd.prDestRects = prect;

                    if(IsD3DManaged(this_dest_lcl))
                    {
                        /* We don't want to deal with this mess, so mark everything dirty */
                        this_dest_lcl->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
                    }

                    /*
         * pass the whole mess off to the driver
                 */

                drvclip_try_again:
                    if( sbd.helonly )
                    {
                        // Release busy now or GDI blt will fail
                        DONE_BUSY();
                    }

                    if (bd.dwFlags & DDBLT_PRESENTATION)
                    {
                        bd.dwFlags |= DDBLT_LAST_PRESENTATION;
                    }

#ifdef WINNT
                    if (subrect_lock_taken)
                    {
                        // If we took a subrect lock on the primary, we need
                        // to adjust the dest rect so the HEL will draw it
                        // in the right spot.  We couldn't do it before because
                        // the above stretch code reuqires the corfrect rect.
                        bd.rDest.right -= subrect_lock_rect.left;
                        bd.rDest.left -= subrect_lock_rect.left;
                        bd.rDest.bottom -= subrect_lock_rect.top;
                        bd.rDest.top -= subrect_lock_rect.top;
                    }
#endif

                    DOHALCALL_NOWIN16( Blt, sbd.bltfn, bd, rc, sbd.helonly );

#ifdef WINNT
                    if (subrect_lock_taken)
                    {
                        // Adjust it back so we don't screw anything up.
                        bd.rDest.right += subrect_lock_rect.left;
                        bd.rDest.left += subrect_lock_rect.left;
                        bd.rDest.bottom += subrect_lock_rect.top;
                        bd.rDest.top += subrect_lock_rect.top;
                    }
#endif

                    if( rc == DDHAL_DRIVER_HANDLED )
                    {
#ifdef WINNT
                        if (bd.ddRVal == DDERR_VISRGNCHANGED)
                        {
                            DONE_LOCKS();
                            DPF(5,"Resetting VisRgn for surface %x", this_dest_lcl);
                            DdResetVisrgn(this_dest_lcl, (HWND)0);
                            goto get_clipping_info;
                        }
#endif
                        if ( (dwFlags & DDBLT_WAIT) &&
                             bd.ddRVal == DDERR_WASSTILLDRAWING )
                        {
                            DPF(4, "Waiting.....");
                            goto drvclip_try_again;
                        }
                        /*
                         * Only mark the surface as in use by the hardware if we didn't wait for it
                         * to finish and it succeeded. Don't mark it if it's HEL, since
                         * the HEL will never be asynchronous.
                         */
                        if( !sbd.helonly && lpbc->bHALSeesSysmem && (bd.ddRVal == DD_OK) )
                        {
                            DPF(5,B,"Tagging surface %08x",this_dest);
                            if (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                                this_dest->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPDEST;
                            if (this_src)
                            {
                                DPF(5,B,"Tagging surface %08x",this_src);
                                if (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                                    this_src->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPSOURCE;
                            }
                        }
                    }
                }
                else
                {
                    // We will do the clipping
                    bd.dwRectCnt =1;
                    bd.prDestRects = (LPVOID)&(bd.rDest);

                    // precalculate a couple of variables
                    if( !stretch_blt )
                    {
                        x_offset = bd.rSrc.left - bd.rDest.left;
                        y_offset = bd.rSrc.top - bd.rDest.top;
                    }
                    else
                    {
                        // scale_x and scale_y are fixed point variables scaled
                        // 16.16 (16 integer bits and 16 fractional bits)
                        scale_x = ((bd.rSrc.right - bd.rSrc.left) << 16) /
                            (bd.rDest.right - bd.rDest.left);
                        scale_y = ((bd.rSrc.bottom - bd.rSrc.top) << 16) /
                            (bd.rDest.bottom - bd.rDest.top);
                    }

                    /*
         * traverse the visible rect list and send each piece to
         * the driver to blit.
         */
                    for( cnt=0;cnt<total;cnt++ )
                    {
                        /*
                         * find out where on the src rect we need to get
                         * the data from.
             */
                        if( !stretch_blt )
                        {
                            // no stretch
                            // one-to-one mapping from source to destination
                            bd.rDest.left = prect->left;
                            bd.rDest.right = prect->right;
                            bd.rDest.top = prect->top;
                            bd.rDest.bottom = prect->bottom;
                            bd.rSrc.left = bd.rDest.left + x_offset;
                            bd.rSrc.right = bd.rDest.right + x_offset;
                            bd.rSrc.top = bd.rDest.top + y_offset;
                            bd.rSrc.bottom = bd.rDest.bottom + y_offset;
                        }
                        else
                        {
                            // stretching
                            // linear mapping from source to destination
                            bd.rDest.left = prect->left;
                            bd.rDest.right = prect->right;
                            bd.rDest.top = prect->top;
                            bd.rDest.bottom = prect->bottom;

            // calculate the source rect which transforms to the
            // dest rect
                            XformRect( (RECT *)&(bd.rOrigSrc), (RECT *)&(bd.rOrigDest), (RECT *)prect,
                                       (RECT *)&(bd.rSrc), scale_x, scale_y );
                        }

                        /*
                        * Add a rect to the region list if this is a managed surface
                        */
                        if(IsD3DManaged(this_dest_lcl))
                        {
                            LPREGIONLIST lpRegionList = this_dest_lcl->lpSurfMore->lpRegionList;
                            if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                            {
                                lpRegionList->rect[(lpRegionList->rdh.nCount)++] = bd.rDest;
                                lpRegionList->rdh.nRgnSize += sizeof(RECT);
                                if(bd.rDest.left < lpRegionList->rdh.rcBound.left)
                                    lpRegionList->rdh.rcBound.left = bd.rDest.left;
                                if(bd.rDest.right > lpRegionList->rdh.rcBound.right)
                                    lpRegionList->rdh.rcBound.right = bd.rDest.right;
                                if(bd.rDest.top < lpRegionList->rdh.rcBound.top)
                                    lpRegionList->rdh.rcBound.top = bd.rDest.top;
                                if(bd.rDest.bottom > lpRegionList->rdh.rcBound.bottom)
                                    lpRegionList->rdh.rcBound.bottom = bd.rDest.bottom;
                            }
                        }

                        /*
             * blt this little piece
             */
                    clip_try_again:
                        if( sbd.helonly )
                        {
                            // Release busy now or GDI blt will fail
                            DONE_BUSY();
                        }

                        // If mirror Blt, we must fix up source rect here!
                        if (bd.dwFlags & DDBLT_DDFX)
                        {
                            int temp;

                            if (bd.bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT)
                            {
                                temp = bd.rSrc.left;
                                bd.rSrc.left = bd.rOrigSrc.left + bd.rOrigSrc.right - bd.rSrc.right;
                                bd.rSrc.right = bd.rOrigSrc.left + bd.rOrigSrc.right - temp;
                            }

                            if (bd.bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)
                            {
                                temp = bd.rSrc.top;
                                bd.rSrc.top = bd.rOrigSrc.top + bd.rOrigSrc.bottom - bd.rSrc.bottom;
                                bd.rSrc.bottom = bd.rOrigSrc.top + bd.rOrigSrc.bottom - temp;
                            }
                        }

                        if (bd.dwFlags & DDBLT_PRESENTATION)
                        {
                            if (cnt == total-1)
                            {
                                bd.dwFlags |= DDBLT_LAST_PRESENTATION;
                            }
                        }

#ifdef WINNT
                        if (subrect_lock_taken)
                        {
                            // Adjust the dest rect so the HEL will draw to the 
                            // right place.
                            bd.rDest.right -= subrect_lock_rect.left;
                            bd.rDest.left -= subrect_lock_rect.left;
                            bd.rDest.bottom -= subrect_lock_rect.top;
                            bd.rDest.top -= subrect_lock_rect.top;
                        }
#endif

                        DOHALCALL_NOWIN16( Blt, sbd.bltfn, bd, rc, sbd.helonly );

#ifdef WINNT
                        if (subrect_lock_taken)
                        {
                            // Adjust it back so we don't screw anything up.
                            bd.rDest.right += subrect_lock_rect.left;
                            bd.rDest.left += subrect_lock_rect.left;
                            bd.rDest.bottom += subrect_lock_rect.top;
                            bd.rDest.top += subrect_lock_rect.top;
                        }
#endif

                        if( rc == DDHAL_DRIVER_HANDLED )
                        {
#ifdef WINNT
                            if (bd.ddRVal == DDERR_VISRGNCHANGED)
                            {
                                DONE_LOCKS();
                                DPF(5,"Resetting VisRgn for surface %x", this_dest_lcl);
                                DdResetVisrgn(this_dest_lcl, (HWND)0);
                                /*
                                * restore original source rect if vis region
                                * changed, for mirrored/clipped cases
                                */
                                bd.rSrc=bd.rOrigSrc;
                                bd.rDest=bd.rOrigDest;
                                goto get_clipping_info;
                            }
#endif
                            /*
                             * NOTE: If clipping has introduced more than
                             * one rectangle we behave as if DDBLT_WAIT
                             * was specified on all rectangles after the
                             * first. This is necessary as the first
                             * rectangle will probably cause the accelerator
                             * to be busy. Hence, the attempt to blit the
                             * second rectangle will fail with
                             * DDERR_WASSTILLDRAWING. If we pass this to
                             * the application (rather than busy waiting)
                             * the application is likely to retry the blit
                             * (which will fail on the second rectangle again)
                             * and we have an application sitting in an
                             * infinite loop).
                             */
                            if ( ( (dwFlags & DDBLT_WAIT) || (cnt > 0) ) &&
                                 bd.ddRVal == DDERR_WASSTILLDRAWING )
                            {
                                DPF(4, "Waiting.....");
                                goto clip_try_again;
                            }

                            if( bd.ddRVal != DD_OK )
                            {
                                break;
                            }
                            /*
                             * Only mark the surface as in use by the hardware if we didn't wait for it
                             * to finish and it succeeded. Only mark surfaces if it's not the HEL
                             * because the HEL is never async.
                             */
                            if( !sbd.helonly && lpbc->bHALSeesSysmem )
                            {
                                DPF(5,B,"Tagging surface %08x",this_dest);
                                if (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                                    this_dest->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPDEST;
                                if (this_src)
                                {
                                    DPF(5,B,"Tagging surface %08x",this_src);
                                    if (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                                        this_src->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPSOURCE;
                                }
                            }
                        }

                        /*
             * next clipping rect
             */
                        prect++;
                    }
                }
                if( fMustFreeRegion )
                    MemFree( prd );

            null_clip_rgn:
                ;
            }

            DONE_LOCKS();

    /*
     * Exclusion needs to happen after unlock call
     */
            DONE_EXCLUDE();

            if( rc != DDHAL_DRIVER_HANDLED )
            {
                /*
                 * did the driver run out of hardware color key resources?
         */
                if( (rc == DDHAL_DRIVER_NOCKEYHW) && (dwFlags & DDBLT_KEYSRCOVERRIDE) )
                {
                    ddrval = ChangeToSoftwareColorKey( this_src_int, FALSE );
                    if( ddrval == DD_OK )
                    {
                        sbd.halonly = FALSE;
                        sbd.helonly = FALSE;
                        if (src_pagelock_taken)
                        {
                            src_pagelock_taken = FALSE;
                            InternalPageUnlock(this_src_lcl, pdrv_lcl);
                        }
                        if (dest_pagelock_taken)
                        {
                            dest_pagelock_taken = FALSE;
                            InternalPageUnlock(this_dest_lcl, pdrv_lcl);
                        }

                        goto RESTART_BLT;
                    }
                    else
                    {
                        bd.ddRVal = DDERR_NOCOLORKEYHW;
                    }
                }
                else
                {
                    bd.ddRVal = DDERR_UNSUPPORTED;
                }
            }
            DONE_BUSY();

        /*
         * Maintain old behaviour for old drivers (which do not export the
         * GetSysmemBltStatus HAL call) and just spin until they're done.
         * Any alternative could exercise new code paths in the driver
         * (e.g. reentered for a DMA operation)
         */
            if ( lpbc->bHALSeesSysmem &&
                 (NULL == pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus || dest_pagelock_taken || src_pagelock_taken)
                )
            {
                if( this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
                {
                    /*
                     * Wait on the destination surface only
                     */
                    DDASSERT(this_src && this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
                    while (DDERR_WASSTILLDRAWING == InternalGetBltStatus(pdrv_lcl, this_dest_lcl, DDGBS_ISBLTDONE))
                        ;
                    this_src_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                    this_dest_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                }
                /*
                 * Unpagelock if we took the pagelocks
                 */
                if (dest_pagelock_taken)
                    InternalPageUnlock(this_dest_lcl, pdrv_lcl);
                if (src_pagelock_taken)
                    InternalPageUnlock(this_src_lcl, pdrv_lcl);
            }

            if(IsD3DManaged(this_dest_lcl))
                MarkDirty(this_dest_lcl);

            LEAVE_BOTH();

            return bd.ddRVal;
        }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            DPF_ERR( "Exception encountered doing blt" );
            DONE_LOCKS();
            DONE_EXCLUDE();
            DONE_BUSY();

            /*
             * Maintain old behaviour for old drivers (which do not export the
             * GetSysmemBltStatus HAL call) and just spin until they're done.
             * Any alternative could exercise new code paths in the driver
             * (e.g. reentered for a DMA operation)
             */
            if ( lpbc->bHALSeesSysmem &&
                 (NULL == pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus || dest_pagelock_taken || src_pagelock_taken)
                )
            {
                if( this_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
                {
                    /*
                     * Wait on the destination surface only
                     */
                    DDASSERT(this_src && this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
                    while (DDERR_WASSTILLDRAWING == InternalGetBltStatus(pdrv_lcl, this_dest_lcl, DDGBS_ISBLTDONE))
                        ;
                    this_src_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                    this_dest_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                }
                /*
                 * Unpagelock if we took the pagelocks
                 */
                if (dest_pagelock_taken)
                    InternalPageUnlock(this_dest_lcl, pdrv_lcl);
                if (src_pagelock_taken)
                    InternalPageUnlock(this_src_lcl, pdrv_lcl);
            }

            LEAVE_BOTH();
            return DDERR_EXCEPTION;
        }

} /* DD_Surface_Blt */

#undef DPF_MODNAME
#define DPF_MODNAME     "BltBatch"

/*
 * DD_Surface_BltBatch
 *
 * BitBlt a whole pile of surfaces
 */
HRESULT DDAPI DD_Surface_BltBatch(
                LPDIRECTDRAWSURFACE lpDDDestSurface,
                LPDDBLTBATCH lpDDBltBatch,
                DWORD dwCount,
                DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_LCL   this_src_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL   this_dest_lcl;
    LPDDRAWI_DDRAWSURFACE_INT   this_src_int;
    LPDDRAWI_DDRAWSURFACE_INT   this_dest_int;
    HRESULT                     ddrval;
    int                         i;

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_BltBatch");

    /*
     * validate surface ptrs
     */
    this_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDDestSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( this_dest_int ) )
    {
        DPF_ERR( "Invalid dest specified") ;
        LEAVE_BOTH();
        return DDERR_INVALIDOBJECT;
    }
    this_dest_lcl = this_dest_int->lpLcl;

    if( SURFACE_LOST( this_dest_lcl ) )
    {
        DPF( 1, "Dest lost") ;
        LEAVE_BOTH();
        return DDERR_SURFACELOST;
    }

    if( this_dest_lcl->lpGbl->dwUsageCount > 0 )
    {
        DPF( 1, "Dest surface %08lx is still locked", this_dest_int );
        LEAVE_BOTH();
        return DDERR_SURFACEBUSY;
    }
    /*
     * validate BltBatch ptr
     */
    if( !VALID_DDBLTBATCH_PTR( lpDDBltBatch ) )
    {
        DPF( 1, "Invalid Blt batch ptr" );
        LEAVE_BOTH();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * validate blt batch params
     */
    for( i=0;i<(int)dwCount;i++ )
    {
        /*
         * validate dest rect
         */
        if( lpDDBltBatch[i].lprDest != NULL )
        {
            if( !VALID_RECT_PTR(lpDDBltBatch[i].lprDest) )
            {
                DPF( 1, "dest rectangle invalid, entry %d", i );
                LEAVE_BOTH();
                return DDERR_INVALIDRECT;
            }
        }

        /*
         * validate source surface
         */
        this_src_int = (LPDDRAWI_DDRAWSURFACE_INT)lpDDBltBatch[i].lpDDSSrc;
        if( this_src_int != NULL )
        {
            if( !VALID_DIRECTDRAWSURFACE_PTR( this_src_int ) )
            {
                DPF( 1, "Invalid source specified, entry %d", i );
                LEAVE_BOTH();
                return DDERR_INVALIDOBJECT;
            }
            this_src_lcl = this_src_int->lpLcl;
            if( SURFACE_LOST( this_src_lcl ) )
            {
                DPF( 1, "Src lost, entry %d", i) ;
                LEAVE_BOTH();
                return DDERR_SURFACELOST;
            }
            if( this_src_lcl->lpGbl->dwUsageCount > 0 )
            {
                DPF( 2, "Source surface %08lx is still locked, entry %d", this_src_int, i );
                LEAVE_BOTH();
                return DDERR_SURFACEBUSY;
            }

            if (this_src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
            {
                DPF_ERR( "It is an optimized surface" );
                LEAVE_DDRAW();
                return DDERR_ISOPTIMIZEDSURFACE;
            }
        }

        if (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

        /*
         * validate src rect
         */
        if( lpDDBltBatch[i].lprSrc != NULL )
        {
            if( !VALID_RECT_PTR(lpDDBltBatch[i].lprSrc) )
            {
                DPF( 1, "src rectangle invalid, entry %d", i );
                LEAVE_BOTH();
                return DDERR_INVALIDRECT;
            }
        }

        /*
         * validate bltfx ptr
         */
        if( lpDDBltBatch[i].lpDDBltFx != NULL )
        {
            if( !VALID_DDBLTFX_PTR( lpDDBltBatch[i].lpDDBltFx ) )
            {
                DPF( 1, "Invalid BLTFX specified, entry %d", i );
                LEAVE_BOTH();
                return DDERR_INVALIDPARAMS;
            }
        }
        else
        {
            if( lpDDBltBatch[i].dwFlags
                        & ( DDBLT_ALPHASRCCONSTOVERRIDE |
                            DDBLT_ALPHADESTCONSTOVERRIDE |
                            DDBLT_ALPHASRCSURFACEOVERRIDE |
                            DDBLT_ALPHADESTSURFACEOVERRIDE |
                            DDBLT_COLORFILL |
                            DDBLT_DDFX |
                            DDBLT_DDROPS |
                            DDBLT_DEPTHFILL |
                            DDBLT_KEYDESTOVERRIDE |
                            DDBLT_KEYSRCOVERRIDE |
                            DDBLT_ROP |
                            DDBLT_ROTATIONANGLE |
                            DDBLT_ZBUFFERDESTCONSTOVERRIDE |
                            DDBLT_ZBUFFERDESTOVERRIDE |
                            DDBLT_ZBUFFERSRCCONSTOVERRIDE |
                            DDBLT_ZBUFFERSRCOVERRIDE ) )
            {
                DPF( 1, "BltFX required but not specified, entry %d", i );
                LEAVE_BOTH();
                return DDERR_INVALIDPARAMS;
            }
        }

    }

    ddrval = DDERR_UNSUPPORTED;

    for( i=0;i<(int)dwCount;i++ )
    {
        #if 0
        while( 1 )
        {
            ddrval = doBlt( this_dest_lcl,
                    lpDDBltBatch[i].lprDest,
                    lpDDBltBatch[i].lpDDSSrc,
                    lpDDBltBatch[i].lprSrc,
                    lpDDBltBatch[i].dwFlags,
                    lpDDBltBatch[i].lpDDBltFX );
            if( ddrval != DDERR_WASSTILLDRAWING )
            {
                break;
            }
        }
        #endif
        if( ddrval != DD_OK )
        {
            break;
        }
    }

    LEAVE_BOTH();
    return ddrval;

} /* BltBatch */

/*
 * XformRect
 *
 * Transform a clipped rect in destination space to the corresponding clipped
 * rect in src space. So, if we're stretching from src to dest, this yields
 * the unstretched clipping rect in src space.
 *
 *  PARAMETERS:
 *      prcSrc - unclipped rect in the source space
 *      prcDest - unclipped rect in the destination space
 *      prcClippedDest - the rect we want to transform
 *      prcClippedSrc - the resulting rect in the source space.  return value.
 *      scale_x - 16.16 fixed point src/dest width ratio
 *      scale_y  - 16.16 fixed point src/dest height ratio
 *
 *  DESCRIPTION:
 *      Given an rect in source space and a rect in destination space, and a
 *      clipped rectangle in the destination space (prcClippedDest), return
 *      the rectangle in the source space (prcClippedSrc) that maps to
 *      prcClippedDest.
 *
 *      Use 16.16 fixed point math for more accuracy. (Shift left, do math,
 *      shift back (w/ round))
 *
 *  RETURNS:
 *      DD_OK always.  prcClippedSrc is the mapped rectangle.
 *
 */
HRESULT XformRect(RECT * prcSrc, RECT * prcDest, RECT * prcClippedDest,
                  RECT * prcClippedSrc, DWORD scale_x, DWORD scale_y)
{
    /*
     * This first calculation is done with fixed point arithmetic (16.16).
     * The result is converted to (32.0) below. Scale back into source space
     */
    prcClippedSrc->left = (prcClippedDest->left - prcDest->left) * scale_x;
    prcClippedSrc->right = (prcClippedDest->right - prcDest->left) * scale_x;
    prcClippedSrc->top = (prcClippedDest->top - prcDest->top) * scale_y;
    prcClippedSrc->bottom = (prcClippedDest->bottom - prcDest->top) * scale_y;

    /*
     * now round (adding 0x8000 rounds) and translate (offset by the
     * src offset)
     */
    prcClippedSrc->left = (((DWORD)prcClippedSrc->left + 0x8000) >> 16) + prcSrc->left;
    prcClippedSrc->right = (((DWORD)prcClippedSrc->right + 0x8000) >> 16) + prcSrc->left;
    prcClippedSrc->top = (((DWORD)prcClippedSrc->top + 0x8000) >> 16) + prcSrc->top;
    prcClippedSrc->bottom = (((DWORD)prcClippedSrc->bottom + 0x8000) >> 16) + prcSrc->top;

    /*
     * Check for zero-sized source rect dimensions and bump if necessary
     */
    if (prcClippedSrc->left == prcClippedSrc->right)
    {
        if (prcClippedSrc->right == prcSrc->right)
        {
            (prcClippedSrc->left)--;
        }
        else
        {
            (prcClippedSrc->right)++;
        }

    }
    if (prcClippedSrc->top == prcClippedSrc->bottom)
    {
        if (prcClippedSrc->bottom == prcSrc->bottom)
        {
            (prcClippedSrc->top)--;
        }
        else
        {
            (prcClippedSrc->bottom)++;
        }

    }

    return DD_OK;

} /* XformRect */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddsckey.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsckey.c
 *  Content:	DirectDraw Surface color key support
 *		SetColorKey, GetColorKey
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   02-feb-95	craige	split out of ddsurf.c
 *   21-feb-95	craige	created CheckColorKey
 *   27-feb-95	craige 	new sync. macros
 *   15-mar-95	craige	HEL work
 *   19-mar-95	craige	use HRESULTs
 *   26-mar-95	craige	support for driver wide colorkey
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-may-95	craige	use driver-level csects only
 *   23-may-95	craige	call HAL for SetColorKey
 *   16-jun-95	craige	new surface structure
 *   25-jun-95	craige	pay attention to DDCKEY_COLORSPACE; allow NULL ckey;
 *   			one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns
 *   01-jul-95	craige	don't allow ckeys for overlays unless supported
 *   03-jul-95	craige	YEEHAW: new driver struct; SEH
 *   09-jul-95	craige	handle the display driver failing setcolorkey
 *   31-jul-95	craige	validate flags
 *   12-aug-95	craige	call HEL SetColorKey when surface is in system memory
 *   09-dec-95  colinmc added execute buffer support
 *   02-jan-96	kylej	handle new interface structs
 *   12-feb-96  colinmc Surface lost flag moved from global to local object
 *   21-apr-96  colinmc Bug 18057: SetColorKey fails set on system surfaces
 *                      if no emulation present
 *   12-mar-97	smac	Bug 1746: Removed redundant checks in SetColorKey
 *   12-mar-97	smac	Bug 1971: Return failure if HAL fails or sometimes
 *			if the HAL doesn't handle the call.
 *
 ***************************************************************************/
#include "ddrawpr.h"

#define DPF_MODNAME "CheckColorKey"

/*
 * CheckColorKey
 *
 * validate that a requested color key is OK
 */
HRESULT CheckColorKey(
		DWORD dwFlags,
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		LPDDCOLORKEY lpDDColorKey,
		DWORD *psflags,
		BOOL halonly,
		BOOL helonly )
{
    DWORD		ckcaps;
    BOOL		fail;
    BOOL		color_space;

    ckcaps = pdrv->ddBothCaps.dwCKeyCaps;
    fail = FALSE;

    *psflags = 0;

    /*
     * check if is a color space or not
     */
    if( lpDDColorKey->dwColorSpaceLowValue != lpDDColorKey->dwColorSpaceHighValue )
    {
	color_space = TRUE;
    }
    else
    {
	color_space = FALSE;
    }

    /*
     * Overlay dest. key
     */
    if( dwFlags & DDCKEY_DESTOVERLAY )
    {
	if( dwFlags & (DDCKEY_DESTBLT|
		       DDCKEY_SRCOVERLAY|
		       DDCKEY_SRCBLT) )
        {
	    DPF_ERR( "Invalid Flags with DESTOVERLAY" );
	    return DDERR_INVALIDPARAMS;
	}

	#if 0
	/*
	 * see if we can do this on a per surface/per driver basis
	 */
	if( !isdriver )
	{
	    if( !(ckcaps & DDCKEYCAPS_SRCOVERLAYPERSURFACE) )
	    {
		if( ckcaps & DDCKEYCAPS_SRCOVERLAYDRIVERWIDE)
		{
		    return DDERR_COLORKEYDRIVERWIDE;
		}
		return DDERR_UNSUPPORTED;
	    }
	}
	else
	{
	    if( !(ckcaps & DDCKEYCAPS_SRCOVERLAYDRIVERWIDE) )
	    {
		return DDERR_UNSUPPORTED;
	    }
	}
	#endif

	/*
	 * can we do this kind of color key?
	 */
	if( !color_space )
	{
	    if( !(ckcaps & DDCKEYCAPS_DESTOVERLAY ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_DESTOVERLAY );
		if( fail )
		{
		    DPF_ERR( "DESTOVERLAY not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}
	else
	{
	    if( !(ckcaps & DDCKEYCAPS_DESTOVERLAYCLRSPACE ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_DESTOVERLAYCLRSPACE );
		if( fail )
		{
		    DPF_ERR( "DESTOVERLAYCOLORSPACE not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}

	/*
	 * is this hardware or software supported?
	 */
	if( halonly )
	{
	    *psflags |= DDRAWISURF_HW_CKEYDESTOVERLAY;
	}
	else if( helonly )
	{
	    *psflags |= DDRAWISURF_SW_CKEYDESTOVERLAY;
	}
    /*
     * Blt dest. key
     */
    }
    else if( dwFlags & DDCKEY_DESTBLT )
    {
	if( dwFlags & (DDCKEY_SRCOVERLAY|
		       DDCKEY_SRCBLT) )
        {
	    DPF_ERR( "Invalid Flags with DESTBLT" );
	    return DDERR_INVALIDPARAMS;
	}

	/*
	 * can we do the requested color key?
	 */
	if( !color_space )
	{
	    if( !(ckcaps & DDCKEYCAPS_DESTBLT ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_DESTBLT );
		if( fail )
		{
		    DPF_ERR( "DESTBLT not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}
	else
	{
	    if( !(ckcaps & DDCKEYCAPS_DESTBLTCLRSPACE ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_DESTBLTCLRSPACE );
		if( fail )
		{
		    DPF_ERR( "DESTBLTCOLORSPACE not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}

	/*
	 * is this hardware or software supported?
	 */
	if( halonly )
	{
	    *psflags |= DDRAWISURF_HW_CKEYDESTBLT;
	}
	else if( helonly )
	{
	    *psflags |= DDRAWISURF_SW_CKEYDESTBLT;
	}
    /*
     * Overlay src. key
     */
    }
    else if( dwFlags & DDCKEY_SRCOVERLAY )
    {
	if( dwFlags & DDCKEY_SRCBLT )
	{
	    DPF_ERR( "Invalid Flags with SRCOVERLAY" );
	    return DDERR_INVALIDPARAMS;
	}

	/*
	 * see if we can do this on a per surface/per driver basis
	 */
	#if 0
	if( !(ckcaps & DDCKEYCAPS_SRCOVERLAYPERSURFACE) )
	{
	    if( ckcaps & DDCKEYCAPS_SRCOVERLAYDRIVERWIDE)
	    {
		return DDERR_COLORKEYDRIVERWIDE;
	    }
	    return DDERR_UNSUPPORTED;
	}
	#endif

	/*
	 * make sure we can do this kind of color key
	 */
	if( !color_space )
	{
	    if( !(ckcaps & DDCKEYCAPS_SRCOVERLAY ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_SRCOVERLAY );
		if( fail )
		{
		    DPF_ERR( "SRCOVERLAY not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}
	else
	{
	    if( !(ckcaps & DDCKEYCAPS_SRCOVERLAYCLRSPACE ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_SRCOVERLAYCLRSPACE );
		if( fail )
		{
		    DPF_ERR( "SRCOVERLAYCOLORSPACE not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}

	/*
	 * is this hardware or software supported?
	 */
	if( halonly )
	{
	    *psflags |= DDRAWISURF_HW_CKEYSRCOVERLAY;
	}
	else if( helonly )
	{
	    *psflags |= DDRAWISURF_SW_CKEYSRCOVERLAY;
	}
    /*
     * Blt src. key
     */
    }
    else if( dwFlags & DDCKEY_SRCBLT )
    {
	/*
	 * can we do the requested color key?
	 */
	if( !color_space )
	{
	    if( !(ckcaps & DDCKEYCAPS_SRCBLT ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_SRCBLT );
		if( fail )
		{
		    DPF_ERR( "SRCBLT not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}
	else
	{
	    if( !(ckcaps & DDCKEYCAPS_SRCBLTCLRSPACE ) )
	    {
		GETFAILCODE( pdrv->ddCaps.dwCKeyCaps,
			     pdrv->ddHELCaps.dwCKeyCaps,
			     DDCKEYCAPS_SRCBLTCLRSPACE );
		if( fail )
		{
		    DPF_ERR( "SRCBLTCOLORSPACE not supported" );
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	}

	/*
	 * is this hardware or software supported?
	 */
	if( halonly )
	{
	    *psflags |= DDRAWISURF_HW_CKEYSRCBLT;
	}
	else if( helonly )
	{
	    *psflags |= DDRAWISURF_SW_CKEYSRCBLT;
	}
    /*
     * bad flags
     */
    }
    else
    {
	DPF_ERR( "Invalid Flags" );
	return DDERR_INVALIDPARAMS;
    }
    return DD_OK;

} /* CheckColorKey */

#undef DPF_MODNAME
#define DPF_MODNAME "GetColorKey"

/*
 * DD_Surface_GetColorKey
 *
 * get the color key associated with this surface
 */
HRESULT DDAPI DD_Surface_GetColorKey(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags,
		LPDDCOLORKEY lpDDColorKey )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    DWORD			ckcaps;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetColorKey");

    TRY
    {
	/*
	 * validate parms
	 */
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

        /*
         * We know z-buffers and execute buffers aren't going to have
         * color keys.
         */
        if( this_lcl->ddsCaps.dwCaps & ( DDSCAPS_ZBUFFER | DDSCAPS_EXECUTEBUFFER ) )
        {
            DPF_ERR( "Surface does not have color key" );
            LEAVE_DDRAW();
            return DDERR_NOCOLORKEY;
        }

	if( dwFlags & ~DDCKEY_VALID )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( !VALID_DDCOLORKEY_PTR( lpDDColorKey ) )
	{
	    DPF_ERR( "Invalid colorkey ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	/*
	 * do we even support a color key
	 */
	if( !(this->lpDD->ddCaps.dwCaps & DDCAPS_COLORKEY) &&
	    !(this->lpDD->ddHELCaps.dwCaps & DDCAPS_COLORKEY) )
	{
	    LEAVE_DDRAW();
	    return DDERR_NOCOLORKEYHW;
	}

	ckcaps = this->lpDD->ddCaps.dwCKeyCaps;

	/*
	 * get key for DESTOVERLAY
	 */
	if( dwFlags & DDCKEY_DESTOVERLAY )
	{
	    if( dwFlags & (DDCKEY_DESTBLT|
			   DDCKEY_SRCOVERLAY|
			   DDCKEY_SRCBLT) )
	    {
		DPF_ERR( "Invalid Flags with DESTOVERLAY" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    //ACKACK: destoverlay can be set on non-overlay surfaces!
	    /* GEE: I ramble about this below as well...
	     * seems to me we have an inconsitency here...
	     * I am too tired to see if it is a real bug or just
	     * a weirdness.
	     */
	    #if 0
	    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) )
	    {
		DPF_ERR( "DESTOVERLAY specified for a non-overlay surface" );
		LEAVE_DDRAW();
		return DDERR_INVALIDOBJECT;
	    }
	    #endif
	    #if 0
	    if( !(ckcaps & DDCKEYCAPS_DESTOVERLAYPERSURFACE) )
	    {
		if( ckcaps & DDCKEYCAPS_DESTOVERLAYDRIVERWIDE)
		{
		    LEAVE_DDRAW();
		    return DDERR_COLORKEYDRIVERWIDE;
		}
		LEAVE_DDRAW();
		return DDERR_UNSUPPORTED;
	    }
	    #endif
	    if( !(this_lcl->dwFlags & DDRAWISURF_HASCKEYDESTOVERLAY) )
	    {
		LEAVE_DDRAW();
		return DDERR_NOCOLORKEY;
	    }
	    *lpDDColorKey = this_lcl->ddckCKDestOverlay;
	/*
	 * get key for DESTBLT
	 */
	}
	else if( dwFlags & DDCKEY_DESTBLT )
	{
	    if( dwFlags & (DDCKEY_SRCOVERLAY|
			   DDCKEY_SRCBLT) )
	    {
		DPF_ERR( "Invalid Flags with DESTBLT" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    if( !(this_lcl->dwFlags & DDRAWISURF_HASCKEYDESTBLT) )
	    {
		LEAVE_DDRAW();
		return DDERR_NOCOLORKEY;
	    }
	    *lpDDColorKey = this_lcl->ddckCKDestBlt;
	/*
	 * get key for SRCOVERLAY
	 */
	}
	else if( dwFlags & DDCKEY_SRCOVERLAY )
	{
	    if( dwFlags & DDCKEY_SRCBLT )
	    {
		DPF_ERR( "Invalid Flags with SRCOVERLAY" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) )
	    {
		DPF_ERR( "SRCOVERLAY specified for a non-overlay surface" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    #if 0
	    if( !(ckcaps & DDCKEYCAPS_SRCOVERLAYPERSURFACE) )
	    {
		if( ckcaps & DDCKEYCAPS_SRCOVERLAYDRIVERWIDE)
		{
		    LEAVE_DDRAW();
		    return DDERR_COLORKEYDRIVERWIDE;
		}
		LEAVE_DDRAW();
		return DDERR_UNSUPPORTED;
	    }
	    #endif
	    if( !(this_lcl->dwFlags & DDRAWISURF_HASCKEYSRCOVERLAY) )
	    {
		LEAVE_DDRAW();
		return DDERR_NOCOLORKEY;
	    }
	    *lpDDColorKey = this_lcl->ddckCKSrcOverlay;
	/*
	 * get key for SRCBLT
	 */
	}
	else if( dwFlags & DDCKEY_SRCBLT )
	{
	    if( !(this_lcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) )
	    {
		LEAVE_DDRAW();
		return DDERR_NOCOLORKEY;
	    }
	    *lpDDColorKey = this_lcl->ddckCKSrcBlt;

	}
	else
	{
	    DPF_ERR( "Invalid Flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetColorKey */

/*
 * ChangeToSoftwareColorKey
 */
HRESULT ChangeToSoftwareColorKey(
		LPDDRAWI_DDRAWSURFACE_INT this_int,
		BOOL use_full_lock )
{
    HRESULT	ddrval;

    ddrval = MoveToSystemMemory( this_int, TRUE, use_full_lock );
    if( ddrval != DD_OK )
    {
	return ddrval;
    }
    this_int->lpLcl->dwFlags &= ~DDRAWISURF_HW_CKEYSRCOVERLAY;
    this_int->lpLcl->dwFlags |= DDRAWISURF_SW_CKEYSRCOVERLAY;
    return DD_OK;

} /* ChangeToSoftwareColorKey */

#undef DPF_MODNAME
#define DPF_MODNAME "SetColorKey"

/*
 * DD_Surface_SetColorKey
 *
 * set the color key associated with this surface
 */
HRESULT DDAPI DD_Surface_SetColorKey(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags,
		LPDDCOLORKEY lpDDColorKey )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    HRESULT			ddrval;
    DWORD			sflags = 0;
    BOOL			halonly;
    BOOL			helonly;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDHALSURFCB_SETCOLORKEY	sckhalfn;
    LPDDHALSURFCB_SETCOLORKEY	sckfn;
    DDHAL_SETCOLORKEYDATA	sckd;
    DWORD			rc;
    DDCOLORKEY			ddck;
    DDCOLORKEY			ddckOldSrcBlt;
    DDCOLORKEY			ddckOldDestBlt;
    DDCOLORKEY			ddckOldSrcOverlay;
    DDCOLORKEY			ddckOldDestOverlay;
    DWORD			oldflags;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetColorKey");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

        /*
         * No color keys on z-buffers or execute buffers.
         */
        if( this_lcl->ddsCaps.dwCaps & ( DDSCAPS_ZBUFFER | DDSCAPS_EXECUTEBUFFER ) )
        {
            DPF_ERR( "Invalid surface type: can't set color key" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

        //
        // New interfaces don't let mipmap sublevels have colorkeys
        //
        if ((!LOWERTHANSURFACE7(this_int)) && 
            (this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL))
        {
            DPF_ERR( "Cannot set colorkey for mipmap sublevels" );
            LEAVE_DDRAW();
            return DDERR_NOTONMIPMAPSUBLEVEL;
        }

	if( dwFlags & ~DDCKEY_VALID )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( lpDDColorKey != NULL )
	{
	    if( !VALID_DDCOLORKEY_PTR( lpDDColorKey ) )
	    {
		DPF_ERR( "Invalid colorkey ptr" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}

	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

	helonly = FALSE;
	halonly = FALSE;

	/*
	 * is surface in system memory?
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
	{
	    halonly = FALSE;
	    helonly = TRUE;
	}

	/*
	 * do we even support a color key?
	 */
	if( !(pdrv->ddBothCaps.dwCaps & DDCAPS_COLORKEY) )
        {
            if( pdrv->ddCaps.dwCaps & DDCAPS_COLORKEY )
	    {
		halonly = TRUE;
	    }
	    else if( pdrv->ddHELCaps.dwCaps & DDCAPS_COLORKEY )
	    {
		helonly = TRUE;
	    }
	    else
	    {
		LEAVE_DDRAW();
		return DDERR_UNSUPPORTED;
	    }
	}

	if( helonly && halonly )
	{
            #pragma message( REMIND( "Need to overhaul SetColorKey for DX3!" ) )
            /*
	     * NOTE: This is a temporary fix to keep certain ISVs happy
	     * until we can overhaul SetColorKey completely. The problem
	     * is that we don't look at the drivers S->S, S->V and V->S
	     * caps when deciding whether to call the HEL or the HAL for
	     * color key sets. This is not terminal for most cards as it
	     * will simply mean falling back on the HEL when we shouldn't.
	     * However, for a certain class for cards (those which are
	     * not display drivers) which have no emulation this will
	     * result in SetColorKey failing. To keep them happy we
	     * will just spot this situation and force a HAL call.
	     *
	     * 1) This is a temporary fix.
	     * 2) The H/W must support the same colorkey operations for
	     *    its system memory blits as it does for its video
	     *    memory ones or things will go wrong.
	     */
	    if( ( !( pdrv->ddHELCaps.dwCaps & DDCAPS_COLORKEY ) ) &&
                ( pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM ) )
	    {
	        helonly = FALSE;
	    }
	    else
	    {
	        DPF_ERR( "Not supported in hardware or software!" );
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
	}

	/*
	 * Restore these if a failure occurs
	 */
   	oldflags = this_lcl->dwFlags;
	ddckOldSrcBlt = this_lcl->ddckCKSrcBlt;
	ddckOldDestBlt = this_lcl->ddckCKDestBlt;
	ddckOldSrcOverlay = this_lcl->ddckCKSrcOverlay;
	ddckOldDestOverlay = this_lcl->ddckCKDestOverlay;

	/*
	 * color key specified?
	 */
	if( lpDDColorKey != NULL )
	{
	    /*
	     * check for color space
	     */
	    ddck = *lpDDColorKey;

	    if( !(dwFlags & DDCKEY_COLORSPACE) )
	    {
		ddck.dwColorSpaceHighValue = ddck.dwColorSpaceLowValue;
	    }
	    lpDDColorKey = &ddck;

	    /*
	     * check the color key
	     */
	    ddrval = CheckColorKey( dwFlags, pdrv, lpDDColorKey, &sflags,
				    halonly, helonly );

	    if( ddrval != DD_OK )
	    {
		DPF_ERR( "Failed CheckColorKey" );
		LEAVE_DDRAW();
		return ddrval;
	    }
	}

	/*
	 * Overlay dest. key
	 */
	if( dwFlags & DDCKEY_DESTOVERLAY )
	{
	    if( !(pdrv->ddCaps.dwCaps & DDCAPS_OVERLAY) )
	    {
		DPF_ERR( "Can't do overlays" );
		LEAVE_DDRAW();
		return DDERR_NOOVERLAYHW;
	    }
	    /* GEE: in GetColorKey we say that DestColorKey can
	     * be set for non overlay surfaces.  Here we require
	     * overlay data in order to SetColorKey (DestColorKey)
	     * I understand why this is the case... are their any
	     * implications to HASOVERLAYDATA other than bigger
	     * structure... if not then we are okay?
	     * would it not be more consistent to move DestColorKey
	     * into local surface structure and not have it be part
	     * of the optional data.
	     */
	    if( !(this_lcl->dwFlags & DDRAWISURF_HASOVERLAYDATA) )
	    {
		DPF_ERR( "Invalid surface for overlay color key" );
		LEAVE_DDRAW();
		return DDERR_NOTAOVERLAYSURFACE;
	    }
	    if( lpDDColorKey == NULL )
	    {
		this_lcl->dwFlags &= ~DDRAWISURF_HASCKEYDESTOVERLAY;
	    }
	    else
	    {
		this_lcl->ddckCKDestOverlay = *lpDDColorKey;
		this_lcl->dwFlags |= DDRAWISURF_HASCKEYDESTOVERLAY;
	    }
	/*
	 * Blt dest. key
	 */
	}
	else if( dwFlags & DDCKEY_DESTBLT )
	{
	    if( lpDDColorKey == NULL )
	    {
		this_lcl->dwFlags &= ~DDRAWISURF_HASCKEYDESTBLT;
	    }
	    else
	    {
		this_lcl->ddckCKDestBlt = *lpDDColorKey;
		this_lcl->dwFlags |= DDRAWISURF_HASCKEYDESTBLT;
	    }
	/*
	 * Overlay src. key
	 */
	}
	else if( dwFlags & DDCKEY_SRCOVERLAY )
	{
	    #if 0  // Talisman overlay sprite might not use overlay surface!
	    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) )
	    {
		DPF_ERR( "SRCOVERLAY specified for a non-overlay surface" );
		LEAVE_DDRAW();
		return DDERR_NOTAOVERLAYSURFACE;
	    }
	    #endif
	    if( lpDDColorKey == NULL )
	    {
		this_lcl->dwFlags &= ~DDRAWISURF_HASCKEYSRCOVERLAY;
	    }
	    else
	    {
		this_lcl->ddckCKSrcOverlay = *lpDDColorKey;
		this_lcl->dwFlags |= DDRAWISURF_HASCKEYSRCOVERLAY;
	    }
	/*
	 * Blt src. key
	 */
	}
	else if( dwFlags & DDCKEY_SRCBLT )
	{
	    if( lpDDColorKey == NULL )
	    {
		this_lcl->dwFlags &= ~DDRAWISURF_HASCKEYSRCBLT;
	    }
	    else
	    {
		this_lcl->ddckCKSrcBlt = *lpDDColorKey;
		this_lcl->dwFlags |= DDRAWISURF_HASCKEYSRCBLT;
	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * add in extra flags
     */
    this_lcl->dwFlags |= sflags;

    /*
     * notify the HAL/HEL
     */
    if( helonly )     // Color key valid only in emulation?
    {
        sckfn = pdrv_lcl->lpDDCB->HELDDSurface.SetColorKey;
        sckhalfn = sckfn;
    }
    else
    {
        sckfn = pdrv_lcl->lpDDCB->HALDDSurface.SetColorKey;
        sckhalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.SetColorKey;
    }

    /*
     * This next part is a hack, but it should be safe.  It is legal for
     * them to pass a NULL lpDDColorKey, meaning that they want to stop
     * colorkeying.  The only problem is that there's no way to pass this
     * into the HAL since we always pass them a colorkey structure.
     * Therefore, we will not call the HAL/HEL when this is the case. The
     * only problem w/ this is an overlay surface will need to know this now,
     * so we will call UpdateOverlay in that case.
     */
    if( lpDDColorKey == NULL )
    {
	if( dwFlags & ( DDCKEY_DESTOVERLAY | DDCKEY_SRCOVERLAY ) )
	{
	    if( dwFlags & DDCKEY_DESTOVERLAY )
	    {
		this_lcl->lpSurfMore->dwOverlayFlags &= ~(DDOVER_KEYDEST|DDOVER_KEYDESTOVERRIDE);
	    }
	    else
	    {
		this_lcl->lpSurfMore->dwOverlayFlags &= ~(DDOVER_KEYSRC|DDOVER_KEYSRCOVERRIDE);
	    }
	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE )
	    {
		if( ( this_lcl->lpSurfMore->dwOverlayFlags & DDOVER_DDFX ) &&
		    ( this_lcl->lpSurfMore->lpddOverlayFX != NULL ) )
		{
		    DD_Surface_UpdateOverlay(
			(LPDIRECTDRAWSURFACE) this_int,
			&(this_lcl->rcOverlaySrc),
			(LPDIRECTDRAWSURFACE) this_lcl->lpSurfaceOverlaying,
			&(this_lcl->rcOverlayDest),
			this_lcl->lpSurfMore->dwOverlayFlags,
			this_lcl->lpSurfMore->lpddOverlayFX );
		}
		else
		{
		    DD_Surface_UpdateOverlay(
			(LPDIRECTDRAWSURFACE) this_int,
			&(this_lcl->rcOverlaySrc),
			(LPDIRECTDRAWSURFACE) this_lcl->lpSurfaceOverlaying,
			&(this_lcl->rcOverlayDest),
			this_lcl->lpSurfMore->dwOverlayFlags,
			NULL );
		}
	    }
	}

	LEAVE_DDRAW();
	return DD_OK;
    }

    ddrval = DD_OK;
    if( sckhalfn != NULL )
    {
	sckd.SetColorKey = sckhalfn;
	sckd.lpDD = pdrv;
	sckd.lpDDSurface = this_lcl;
	sckd.ckNew = *lpDDColorKey;
	sckd.dwFlags = dwFlags;
	DOHALCALL( SetColorKey, sckfn, sckd, rc, helonly );
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( sckd.ddRVal != DD_OK )
	    {
		DPF_ERR( "HAL/HEL call failed" );
		ddrval = sckd.ddRVal;
	    }
	}
	else if( rc == DDHAL_DRIVER_NOCKEYHW )
	{
	    if( dwFlags & DDCKEY_SRCBLT )
	    {
		ddrval = ChangeToSoftwareColorKey( this_int, TRUE );
		if( ddrval != DD_OK )
		{
		    DPF_ERR( "hardware resources are out & can't move to system memory" );
		    ddrval = DDERR_NOCOLORKEYHW;
		}
	    }
	    else
	    {
		ddrval = DDERR_UNSUPPORTED;
	    }
	}
    }
    else
    {
	/*
	 * This is really only a problem when setting an overlay colorkey
	 * and the overlay is already coloerkeying; otherwise, the
	 * colorkey is set in the LCL and will be used the next time
	 * the overlay or blt is called.
	 */
	if( dwFlags & DDCKEY_SRCOVERLAY )
	{
	    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE ) &&
	     	( this_lcl->lpSurfMore->dwOverlayFlags &
		( DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE ) ) )
	    {
		ddrval = DDERR_UNSUPPORTED;
	    }
	}

	/*
	 * NOTE: We'd like to do the same for dest overlay, but:
	 * 1) We don't see much usefulness in it since apps probably
	 *    will not be changing the dest colorkey on the fly.
	 * 2) Since dest colorkeying is used a lot, changing the behavior
	 *    might break someone.
	 * smac and jeffno 3/11/97
	 */
    }

    /*
     * Restore old values if a failure occurs
     */
    if( ddrval != DD_OK )
    {
   	this_lcl->dwFlags = oldflags;
	this_lcl->ddckCKSrcBlt = ddckOldSrcBlt;
	this_lcl->ddckCKDestBlt = ddckOldDestBlt;
	this_lcl->ddckCKSrcOverlay = ddckOldSrcOverlay;
	this_lcl->ddckCKDestOverlay = ddckOldDestOverlay;
    }

    LEAVE_DDRAW();
    return ddrval;

} /* DD_Surface_SetColorKey */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddrefrsh.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddrefrsh.c
 *  Content:	DirectDraw Refresh Rate support
 *
 *              On Win98, we don't have detailed information regarding what
 *              refresh rates the montor supports.  We can get some information
 *              from the monitor (EDID data), but we cannot absolutely rely on
 *              it, so we require that the user manually verify each refresh 
 *              rate before we allow it to be used.
 *		
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   02-apr-99	smac	Created it
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "edid.h"

#undef DPF_MODNAME
#define DPF_MODNAME "Refresh"

#ifdef WIN95

static WORD SupportedRefreshRates[] = {60, 75, 85, 100, 120};
#define NUM_SUPPORTED_REFRESH_RATES ( sizeof( SupportedRefreshRates ) / sizeof( WORD ) )


/*
 * GetEDIDData
 */
HRESULT GetEDIDData( LPDDRAWI_DIRECTDRAW_GBL pddd, VESA_EDID * pEDIDData )
{
    memset( pEDIDData, 0, sizeof( VESA_EDID ) );
    if( DD16_GetMonitorEDIDData( pddd->cDriverName, (LPVOID)pEDIDData) )
    {
        return DD_OK;
    }

    if( !( pddd->dwFlags & DDRAWI_DISPLAYDRV ) )
    {
        // HACK: Use primary display EDID data for passthrough devices
        if( DD16_GetMonitorEDIDData( g_szPrimaryDisplay, (LPVOID)pEDIDData) )
        {
            return DD_OK;
        }
    }

    return DDERR_UNSUPPORTED;
}


/*
 * CheckEdidBandiwdth
 *
 * Takes a resoltion/refrsh rate and calculates the bandwidth required for 
 * this, and then updates lpHighestRefresh and lpHighestBandwidth to keep
 * track of the highest refresh rate and badnwidth info that we've encountered.
 */
void CheckEdidBandwidth( DWORD dwWidth, DWORD dwHeight, DWORD dwRefreshRate,
                         LPDWORD lpHighestRefresh, LPDWORD lpHighestBandwidth )
{
    DWORD dwBandwidth;

    dwBandwidth = dwWidth * dwHeight * dwRefreshRate;
    if( dwBandwidth > *lpHighestBandwidth )
    {
        *lpHighestBandwidth = dwBandwidth;
    }
    if( dwRefreshRate > *lpHighestRefresh )
    {
        *lpHighestRefresh = dwRefreshRate;
    }
}
         

/*
 * StdTimeXRES
 */
int StdTimeXRES(WORD StdTime)
{
    if (StdTime == 0 || StdTime == 0x0101)
        return 0;
    else
        return ((StdTime & veStdTime_HorzResMask) + 31) * 8;
}


/*
 * StdTimeYRES
 */
int StdTimeYRES(WORD StdTime)
{
    if (StdTime == 0 || StdTime == 0x0101)
        return 0;

    switch (StdTime & veStdTime_AspectRatioMask)
    {
        case veStdTime_AspectRatio1to1:  return StdTimeXRES(StdTime);
        case veStdTime_AspectRatio4to3:  return StdTimeXRES(StdTime) * 3 / 4;
        case veStdTime_AspectRatio5to4:  return StdTimeXRES(StdTime) * 4 / 5;
        case veStdTime_AspectRatio16to9: return StdTimeXRES(StdTime) * 9 / 16;
    }
    return 0;
}


/*
 * StdTimeRATE
 */
int StdTimeRATE(WORD StdTime)
{
    if (StdTime == 0 || StdTime == 0x0101)
        return 0;
    else
        return ((StdTime & veStdTime_RefreshRateMask) >> 8) + 60;
}


__inline UINT DetTimeXRES(BYTE *DetTime)
{
    return (UINT)DetTime[2] + (((UINT)DetTime[4] & 0xF0) << 4);
}

__inline UINT DetTimeYRES(BYTE *DetTime)
{
    return (UINT)DetTime[5] + (((UINT)DetTime[7] & 0xF0) << 4);
}

__inline UINT DetTimeXBLANK(BYTE *DetTime)
{
    return (UINT)DetTime[3] + (((UINT)DetTime[4] & 0x0F) << 4);
}

__inline UINT DetTimeYBLANK(BYTE *DetTime)
{
    return (UINT)DetTime[6] + (((UINT)DetTime[7] & 0x0F) << 0);
}

int DetTimeRATE(BYTE *DetTime)
{
    ULONG clk;
    ULONG x;
    ULONG y;

    clk = *(WORD*)DetTime;
    x = DetTimeXRES(DetTime) + DetTimeXBLANK(DetTime);
    y = DetTimeYRES(DetTime) + DetTimeYBLANK(DetTime);

    if (clk == 0 || x == 0 || y == 0)
        return 0;

    return (int)((clk * 10000) / (x * y));
}


/*
 * GetDetailedTime
 */
void GetDetailedTime(BYTE *DetTime, LPDWORD lpHighestRefresh, LPDWORD lpHighestBandwidth )
{
    char ach[14];
    int i;
    DWORD dw;

    dw = *(DWORD *)DetTime;

    if( dw == 0xFD000000 )       // Monitor limits
    {
        if( (DWORD)(DetTime[6]) > *lpHighestRefresh )
        {
            *lpHighestRefresh = (DWORD)(DetTime[6]);
        }
    }
    else if (dw == 0xFA000000)       // more standard timings
    {
        WORD * StdTime = (WORD *)&DetTime[5];

        CheckEdidBandwidth( StdTimeXRES( StdTime[0] ),
            StdTimeYRES( StdTime[0] ),
            StdTimeRATE( StdTime[0] ),
            lpHighestRefresh, lpHighestBandwidth );
        CheckEdidBandwidth( StdTimeXRES( StdTime[1] ),
            StdTimeYRES( StdTime[1] ),
            StdTimeRATE( StdTime[1] ),
            lpHighestRefresh, lpHighestBandwidth );
        CheckEdidBandwidth( StdTimeXRES( StdTime[2] ),
            StdTimeYRES( StdTime[2] ),
            StdTimeRATE( StdTime[2] ),
            lpHighestRefresh, lpHighestBandwidth );
        CheckEdidBandwidth( StdTimeXRES( StdTime[3] ),
            StdTimeYRES( StdTime[3] ),
            StdTimeRATE( StdTime[3] ),
            lpHighestRefresh, lpHighestBandwidth );
        CheckEdidBandwidth( StdTimeXRES( StdTime[4] ),
            StdTimeYRES( StdTime[4] ),
            StdTimeRATE( StdTime[4] ),
            lpHighestRefresh, lpHighestBandwidth );
        CheckEdidBandwidth( StdTimeXRES( StdTime[5] ),
            StdTimeYRES( StdTime[5] ),
            StdTimeRATE( StdTime[5] ),
            lpHighestRefresh, lpHighestBandwidth );
    }
    else if( ( dw != 0xFF000000 ) &&      // Serial number
             ( dw != 0xFE000000 ) &&      // Monitor String
             ( dw != 0xFC000000 ) &&      // Monitor Name
             ( dw != 0xFB000000 ) &&      // ColorPoint data
             ( DetTimeRATE( DetTime) ) )
    {
        CheckEdidBandwidth( DetTimeXRES( DetTime ),
            DetTimeYRES( DetTime ),
            DetTimeRATE( DetTime ),
            lpHighestRefresh, lpHighestBandwidth );
    }
}


/*
 * EvaluateMonitor
 *
 * Determines the amount of bandwidth that the monitor can handle.
 */
void EvaluateMonitor( VESA_EDID *lpEdidData, DWORD *lpHighestRefresh, DWORD *lpHighestBandwidth )
{
    BYTE chk;
    int i;

    *lpHighestRefresh = 0;
    *lpHighestBandwidth = 0;

    /*
     * Do some sanity checking to make sure that the EDID data looks sane
     */

    for( chk = i = 0; i < 128; i++)
    {
        chk += ((BYTE *)lpEdidData)[i];
    }
    if (chk != 0)
    {
        // Bad checksum
        return;
    }

    /*
     * First get the bandwidth from the established timings
     */
    if( lpEdidData->veEstTime1 & veEstTime1_720x400x70Hz)
    {
        CheckEdidBandwidth( 720, 400, 70, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime1 & veEstTime1_720x400x88Hz)
    {
        CheckEdidBandwidth( 720, 400, 88, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime1 & veEstTime1_640x480x60Hz)
    {
        CheckEdidBandwidth( 640, 480, 60, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime1 & veEstTime1_640x480x67Hz)
    {
        CheckEdidBandwidth( 640, 480, 67, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime1 & veEstTime1_640x480x72Hz)
    {
        CheckEdidBandwidth( 640, 480, 72, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime1 & veEstTime1_640x480x75Hz)
    {
        CheckEdidBandwidth( 640, 480, 75, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime1 & veEstTime1_800x600x60Hz)
    {
        CheckEdidBandwidth( 800, 600, 60, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime2 & veEstTime2_800x600x72Hz)
    {
        CheckEdidBandwidth( 800, 600, 72, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime2 & veEstTime2_800x600x75Hz)
    {
        CheckEdidBandwidth( 800, 600, 75, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime2 & veEstTime2_1024x768x60Hz)
    {
        CheckEdidBandwidth( 1024, 768, 60, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime2 & veEstTime2_1024x768x70Hz)
    {
        CheckEdidBandwidth( 1024, 768, 70, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime2 & veEstTime2_1024x768x75Hz)
    {
        CheckEdidBandwidth( 1024, 768, 75, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime2 & veEstTime2_1280x1024x75Hz)
    {
        CheckEdidBandwidth( 1280, 1024, 75, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime3 & veEstTime3_1152x870x75Hz)
    {
        CheckEdidBandwidth( 1152, 870, 75, lpHighestRefresh, lpHighestBandwidth );
    }

    /*
     * Now get the bandwidth from the standard timings
     */
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID1 ),
        StdTimeYRES( lpEdidData->veStdTimeID1 ),
        StdTimeRATE( lpEdidData->veStdTimeID1 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID2 ),
        StdTimeYRES( lpEdidData->veStdTimeID2 ),
        StdTimeRATE( lpEdidData->veStdTimeID2 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID3 ),
        StdTimeYRES( lpEdidData->veStdTimeID3 ),
        StdTimeRATE( lpEdidData->veStdTimeID3 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID4 ),
        StdTimeYRES( lpEdidData->veStdTimeID4 ),
        StdTimeRATE( lpEdidData->veStdTimeID4 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID5 ),
        StdTimeYRES( lpEdidData->veStdTimeID5 ),
        StdTimeRATE( lpEdidData->veStdTimeID5 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID6 ),
        StdTimeYRES( lpEdidData->veStdTimeID6 ),
        StdTimeRATE( lpEdidData->veStdTimeID6 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID7 ),
        StdTimeYRES( lpEdidData->veStdTimeID7 ),
        StdTimeRATE( lpEdidData->veStdTimeID7 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID8 ),
        StdTimeYRES( lpEdidData->veStdTimeID8 ),
        StdTimeRATE( lpEdidData->veStdTimeID8 ),
        lpHighestRefresh, lpHighestBandwidth );

    /*
     * Now get the detailed timing information
     */
    GetDetailedTime( lpEdidData->veDetailTime1, lpHighestRefresh, lpHighestBandwidth );
    GetDetailedTime( lpEdidData->veDetailTime2, lpHighestRefresh, lpHighestBandwidth );
    GetDetailedTime( lpEdidData->veDetailTime3, lpHighestRefresh, lpHighestBandwidth );
    GetDetailedTime( lpEdidData->veDetailTime4, lpHighestRefresh, lpHighestBandwidth );
}


//=============================================================================
//
// Function Description:
//
//   Finds an item in a registry-based most recently used (MRU) list, and
//   either retrieves the contents of that item, or updates (add if it doesn't
//   exist) the item.
//
// Arguments:
//
//   [IN/OUT] item - Contains at least the unique portion of the item to
//                   search for [IN/OUT]. If writing the item, should contain
//                   the entire item [IN].
//   [IN] writeItem - Set to TRUE if updating/adding an item to the MRU list.
//
// Return Value:
//
//   TRUE - If writeItem is TRUE, then the item was written to the registry.
//          Otherwise the item was found and its contents stored in findItem.
//   FALSE - Failure; no more information available.
//
// Created:
//
//   04/08/1999 johnstep
//
//=============================================================================

//-----------------------------------------------------------------------------
// Define global MRU list values here, for simplicity:
//
//   gMruRegKey - Registry key where MRU list is stored
//   gMruRegOrderValue - Name of MRU list order value
//   gMruBaseChar - Base index into MRU list
//   gMruMaxChar - Maximum index into MRU list
//   gMruItemSize - Size of findItem.
//   gMruUniqueOffset - Offset of unique portion of item. This unique portion
//                      is what will be used to compare items.
//   gMruUniqueSize - Size of unique portion of item.
//-----------------------------------------------------------------------------

static const CHAR *gMruRegKey =
    REGSTR_PATH_DDRAW "\\" REGSTR_KEY_RECENTMONITORS;
static const CHAR *gMruRegOrderValue = REGSTR_VAL_DDRAW_MONITORSORDER;
#define gMruBaseChar '0'
#define gMruMaxChar '9'
#define gMruItemSize sizeof (DDMONITORINFO)
#define gMruUniqueOffset 0
#define gMruUniqueSize offsetof(DDMONITORINFO, Mode640x480)

BOOL
MruList(
    VOID *item,
    const BOOL writeItem
    )
{
    BOOL success = FALSE;
    HKEY hkey;

    // Create or open the root key, with permission to query and set values;
    // only continue if successful:
    
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, gMruRegKey,
        0, NULL, 0, KEY_QUERY_VALUE | KEY_SET_VALUE,
        NULL, &hkey, NULL) == ERROR_SUCCESS)
    {
        CHAR mruOrder[gMruMaxChar - gMruBaseChar + 2];
        DWORD type;
        DWORD count = sizeof mruOrder;
        UINT i;

        {
            CHAR temp[sizeof mruOrder];

            // If we read the order value successfully, copy the valid chars
            // into mruOrder, removing duplicates:
        
            if (RegQueryValueEx(hkey, gMruRegOrderValue, NULL, &type,
                (BYTE *) temp, &count) == ERROR_SUCCESS)
            {
                UINT j = 0;

                for (--count, i = 0; i < count; i++)
                {
                    if ((temp[i] >= gMruBaseChar) &&
                        (temp[i] <= gMruMaxChar))
                    {
                        UINT k;

                        for (k = 0; k < j; k++)
                        {
                            if (mruOrder[k] == temp[i])
                            {
                                break;
                            }
                        }
                        if (k == j)
                        {
                            mruOrder[j++] = temp[i];
                        }
                    }
                }
                count = j;
            }
            else
            {
                count = 0;
            }
        }

        // Only continue if we found at least one valid value in the order
        // list, or if we're writing the item:
        
        if ((count > 0) || writeItem)
        {
            CHAR regValue[2];
            BYTE regItem[gMruItemSize];

            regValue[1] = '\0';

            // Search for the item in the MRU list:
            
            for (i = 0; i < count; i++)
            {
                DWORD size = sizeof regItem;

                regValue[0] = mruOrder[i];

                if ((RegQueryValueEx(hkey, regValue, NULL, &type,
                    (BYTE *) &regItem, &size) == ERROR_SUCCESS) &&
                    (size == sizeof regItem))
                {
                    if (memcmp(
                        (BYTE *) &regItem + gMruUniqueOffset,
                        (BYTE *) item + gMruUniqueOffset,
                        gMruUniqueSize) == 0)
                    {
                        break;
                    }
                }
            }

            // Keep going if we found the item or in any case if we need to
            // write the item:
            
            if ((i < count) || writeItem)
            {
                UINT j;

                // If we didn't find the item, then we must be writing, so
                // adjust the index appropriately. If the list is already
                // full, we just use the last item (LRU item), otherwise, add
                // a new item:
                
                if (i == count)
                {
                    if (count == (gMruMaxChar - gMruBaseChar + 1))
                    {
                        i--;
                    }
                    else
                    {
                        // Adding a new item; search for the lowest unused
                        // valid char:

                        for (mruOrder[i] = gMruBaseChar;
                             mruOrder[i] < gMruMaxChar;
                             mruOrder[i]++)
                        {
                            for (j = 0; j < i; j++)
                            {
                                if (mruOrder[j] == mruOrder[i])
                                {
                                    break;
                                }
                            }
                            if (j == i)
                            {
                                break;
                            }
                        }
                        count++;
                    }
                }
            
                // Update the MRU order list if necessary. We update if we
                // found or are adding an item after the first, or if this is
                // the first item in the list:
                
                if (i > 0 || (count == 1))
                {
                    // Bubble found item to head of order list:

                    for (j = i; j > 0; j--)
                    {
                        CHAR temp = mruOrder[j];
                        mruOrder[j] = mruOrder[j - 1];
                        mruOrder[j - 1] = temp;
                    }

                    // Write the order list:
                    
                    mruOrder[count] = '\0';
                    RegSetValueEx(hkey, gMruRegOrderValue, 0,
                        REG_SZ, (BYTE *) mruOrder, count + 1);
                }

                // If we want to write the item, do it now. We will always
                // write to the first item in the order list. If not writing,
                // copy what was read from the registry into item:
                
                if (writeItem)
                {
                    regValue[0] = mruOrder[0];
                    if (RegSetValueEx(hkey, regValue, 0,
                        REG_BINARY, (BYTE *) item, sizeof regItem) ==
                        ERROR_SUCCESS)
                    {
                        success = TRUE;
                    }
                }
                else
                {
                    memcpy(
                        (BYTE *) item + gMruUniqueOffset,
                        regItem + gMruUniqueOffset,
                        sizeof regItem);

                    success = TRUE;
                }
            }
        }

        // Always close the registry key when finished:
        
        RegCloseKey(hkey);
    }

    return success;
}

//-----------------------------------------------------------------------------


/*
 * DDSaveMonitorInfo
 * 
 * Writes the monitor info to the registry.
 */
HRESULT DDSaveMonitorInfo( LPDDRAWI_DIRECTDRAW_INT lpDD_int )
{
    return MruList( (VOID *) lpDD_int->lpLcl->lpGbl->lpMonitorInfo, TRUE ) ?
        DD_OK : DDERR_GENERIC;
}


__inline IsValidRefreshRate( DWORD dwWidth, DWORD dwHeight, int refreshRate,
                             DWORD dwHighestBandwidth )
{
    return
        ( ( refreshRate >= 0 ) &&
        ( ( dwWidth * dwHeight * (DWORD) refreshRate ) <= dwHighestBandwidth ) );
}


/*
 * DDGetMonitorInfo
 * 
 * Reads the monitor info from the registry and verifies that it still applies.
 */
HRESULT DDGetMonitorInfo( 
                LPDDRAWI_DIRECTDRAW_INT lpDD_int )
{
    LPDDMONITORINFO pInfo;
    static DDDEVICEIDENTIFIER DeviceIdentifier;
    HRESULT hr;

    if( ( lpDD_int->lpVtbl == &dd7Callbacks ) &&
        ( lpDD_int->lpLcl->lpGbl->lpMonitorInfo == NULL ) )
    {
        VESA_EDID EDIDData;
        DWORD dwHighestRefresh;
        DWORD dwHighestBandwidth;
        HKEY hKey;
        BOOL bGotLastMonitor = FALSE;

        hr = GetEDIDData( lpDD_int->lpLcl->lpGbl, &EDIDData );
        if( hr != DD_OK )
        {
            // There is no EDID data
            return DDERR_GENERIC;
        }
        EvaluateMonitor( &EDIDData, &dwHighestRefresh, &dwHighestBandwidth );

        hr = DD_GetDeviceIdentifier( (LPDIRECTDRAW) lpDD_int, &DeviceIdentifier, 0 );
        if( hr != DD_OK )
        {
            // Failed to get device identifier for monitor info
            return hr;
        }

        pInfo = (LPDDMONITORINFO) MemAlloc( sizeof( DDMONITORINFO ) );
        if( pInfo == NULL )
        {
            // Out of memory allocating monitor info structure
            return DDERR_OUTOFMEMORY;
        }

        pInfo->Manufacturer = *(WORD *)&EDIDData.veManufactID[0];
        pInfo->Product = *(WORD *)&EDIDData.veProductCode[0];
        pInfo->SerialNumber = EDIDData.veSerialNbr;
        pInfo->DeviceIdentifier = DeviceIdentifier.guidDeviceIdentifier;

        // Read monitor information from registry, if available. We need to
        // compare this to the EDID data to see if the monitor or adapter
        // changed and verify the selected refresh rates are sane:
    
        if( MruList( (VOID *) pInfo, FALSE ) )
        {
            // Validate modes here against EDID data:

            if( !IsValidRefreshRate( 640, 480,
                pInfo->Mode640x480, dwHighestBandwidth ) )
            {
                pInfo->Mode640x480 = -1;
            }
    
            if( !IsValidRefreshRate( 800, 600,
                pInfo->Mode800x600, dwHighestBandwidth ) )
            {
                pInfo->Mode800x600 = -1;
            }
    
            if( !IsValidRefreshRate( 1024, 768,
                pInfo->Mode1024x768, dwHighestBandwidth ) )
            {
                pInfo->Mode1024x768 = -1;
            }
    
            if( !IsValidRefreshRate( 1280, 1024,
                pInfo->Mode1280x1024, dwHighestBandwidth ) )
            {
                pInfo->Mode1280x1024 = -1;
            }
    
            if( !IsValidRefreshRate( 1600, 1200,
                pInfo->Mode1600x1200, dwHighestBandwidth ) )
            {
                pInfo->Mode1600x1200 = -1;
            }
    
            bGotLastMonitor = TRUE;
        }
    
        if( !bGotLastMonitor )
        {
            pInfo->Mode640x480 = -1;
            pInfo->Mode800x600 = -1;
            pInfo->Mode1024x768 = -1;
            pInfo->Mode1280x1024 = -1;
            pInfo->Mode1600x1200 = -1;
        }

        pInfo->ModeReserved1 = -1;
        pInfo->ModeReserved2 = -1;
        pInfo->ModeReserved3 = -1;

        lpDD_int->lpLcl->lpGbl->lpMonitorInfo = pInfo;
    }
    return DD_OK;
}


/*
 * ExpandModeTable
 * 
 * On Win9X, drivers can specify their maximum refresh rate for each mode, 
 * allowing DDraw to add modes for each refresh rate that we care about.
 * This allows drivers to add refresh rate easily without having to 
 * maintain huge tables.  This also allows us to avoid regressions by allowing
 * us to only enumerate these refresh rates on newer interfaces.
 */
HRESULT ExpandModeTable( LPDDRAWI_DIRECTDRAW_GBL pddd )
{
    DWORD i;
    DWORD j;
    DWORD iNumModes = 0;
    LPDDHALMODEINFO pNewModeTable;
    DWORD iModeIndex;
    WORD wMaxRefresh;

    /*
     * Count the number of entries that we'll need
     */
    if( pddd->lpModeInfo != NULL )
    {
        for( i = 0; i < pddd->dwNumModes;  i++ )
        {
            iNumModes++;
            if( pddd->lpModeInfo[i].wFlags & DDMODEINFO_MAXREFRESH )
            {
                for( j = 0; j < NUM_SUPPORTED_REFRESH_RATES; j++ )
                {
                    if( SupportedRefreshRates[j] <= pddd->lpModeInfo[i].wRefreshRate )
                    {
                        iNumModes++;
                    }
                }
            }
        }

        if( iNumModes > pddd->dwNumModes )
        {
            /*
             * We do have to add modes and allocate a new table
             */
            pNewModeTable = (LPDDHALMODEINFO) MemAlloc( sizeof( DDHALMODEINFO ) * iNumModes );
            if( pNewModeTable == NULL )
            {
                /*
                 * Instead of failing here, we'll just clear all of the MAXREFRESHRATE
                 * flags and set the rate to 0.
                 */
                for( i = 0; i < pddd->dwNumModes; i++ )
                {
                    if( pddd->lpModeInfo[i].wFlags & DDMODEINFO_MAXREFRESH )
                    {
                        pddd->lpModeInfo[i].wFlags &= ~DDMODEINFO_MAXREFRESH;
                        pddd->lpModeInfo[i].wRefreshRate = 0;
                    }
                }
            }
            else
            {
                memcpy( pNewModeTable, pddd->lpModeInfo, pddd->dwNumModes * sizeof( DDHALMODEINFO ) );

                /*
                 * Now add the new refresh rates
                 */
                iModeIndex = pddd->dwNumModes;
                for( i = 0; i < pddd->dwNumModes; i++ )
                {
                    if( pddd->lpModeInfo[i].wFlags & DDMODEINFO_MAXREFRESH )
                    {
                        pNewModeTable[i].wFlags &= ~DDMODEINFO_MAXREFRESH;
                        wMaxRefresh = pNewModeTable[i].wRefreshRate;
                        pNewModeTable[i].wRefreshRate = 0;

                        for( j = 0; j < NUM_SUPPORTED_REFRESH_RATES; j++ )
                        {
                            if( SupportedRefreshRates[j] <= wMaxRefresh )
                            {
                                memcpy( &(pNewModeTable[iModeIndex]), &(pNewModeTable[i]), sizeof( DDHALMODEINFO ) );
                                pNewModeTable[iModeIndex].wFlags |= DDMODEINFO_DX7ONLY;
                                pNewModeTable[iModeIndex++].wRefreshRate = SupportedRefreshRates[j];
                            }
                        }
                    }
                }

                MemFree( pddd->lpModeInfo );
                pddd->lpModeInfo = pNewModeTable;
                pddd->dwNumModes = iModeIndex;
            }
        }
    }

    return DD_OK;
}


/*
 * CanMonitorHandleRefreshRate
 * 
 * Has the specified refresh rate been tested and verified that it works?
 */
BOOL CanMonitorHandleRefreshRate( LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD dwWidth, DWORD dwHeight, int wRefresh )
{
    if( wRefresh == 0 )
    {
        return TRUE;
    }

    if( pddd->lpMonitorInfo == NULL )
    {
        return FALSE;
    }

    /*
     * If we are setting this mode because we are testing it, then we should
     * allow it so the user can verify whether it worked or not.
     */
    if( pddd->dwFlags & DDRAWI_TESTINGMODES )
    {
        return TRUE;
    }

    if( ( dwWidth <= 640 ) && ( dwHeight <= 480 ) )
    {
        if( pddd->lpMonitorInfo->Mode640x480 >= wRefresh )
        {
            return TRUE;
        }
    }

    if( ( dwWidth <= 800 ) && ( dwHeight <= 600 ) )
    {
        if( pddd->lpMonitorInfo->Mode800x600 >= wRefresh )
        {
            return TRUE;
        }
    }

    if( ( dwWidth <= 1024 ) && ( dwHeight <= 768 ) )
    {
        if( pddd->lpMonitorInfo->Mode1024x768 >= wRefresh )
        {
            return TRUE;
        }
    }

    if( ( dwWidth <= 1280 ) && ( dwHeight <= 1024 ) )
    {
        if( pddd->lpMonitorInfo->Mode1280x1024 >= wRefresh )
        {
            return TRUE;
        }
    }

    if( ( dwWidth <= 1600 ) && ( dwHeight <= 1200 ) )
    {
        if( pddd->lpMonitorInfo->Mode1600x1200 >= wRefresh )
        {
            return TRUE;
        }
    }

    return FALSE;
}


/*
 * IsModeTested
 *
 * Determines if we already have data for the requested mode.
 */
BOOL IsModeTested( LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD dwWidth, DWORD dwHeight )
{
    if( pddd->lpMonitorInfo == NULL )
    {
        return FALSE;
    }

    if( ( dwWidth <= 640 ) && ( dwHeight <= 480 ) )
    {
        if( pddd->lpMonitorInfo->Mode640x480 != -1 )
        {
            return TRUE;
        }
    }

    else if( ( dwWidth <= 800 ) && ( dwHeight <= 600 ) )
    {
        if( pddd->lpMonitorInfo->Mode800x600 != -1 )
        {
            return TRUE;
        }
    }

    else if( ( dwWidth <= 1024 ) && ( dwHeight <= 768 ) )
    {
        if( pddd->lpMonitorInfo->Mode1024x768 != -1 )
        {
            return TRUE;
        }
    }

    else if( ( dwWidth <= 1280 ) && ( dwHeight <= 1024 ) )
    {
        if( pddd->lpMonitorInfo->Mode1280x1024 != -1 )
        {
            return TRUE;
        }
    }

    else if( ( dwWidth <= 1600 ) && ( dwHeight <= 1200 ) )
    {
        if( pddd->lpMonitorInfo->Mode1600x1200 != -1 )
        {
            return TRUE;
        }
    }

    return FALSE;
}


/*
 * UpdateMonitorInfo
 */
void UpdateMonitorInfo( LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD dwWidth, DWORD dwHeight, int iRefreshRate )
{
    if( pddd->lpMonitorInfo == NULL )
    {
        return;
    }

    if( ( dwWidth <= 640 ) && ( dwHeight <= 480 ) )
    {
        pddd->lpMonitorInfo->Mode640x480 = iRefreshRate;
    }

    else if( ( dwWidth <= 800 ) && ( dwHeight <= 600 ) )
    {
        pddd->lpMonitorInfo->Mode800x600 = iRefreshRate;
    }

    else if( ( dwWidth <= 1024 ) && ( dwHeight <= 768 ) )
    {
        pddd->lpMonitorInfo->Mode1024x768 = iRefreshRate;
    }

    else if( ( dwWidth <= 1280 ) && ( dwHeight <= 1024 ) )
    {
        pddd->lpMonitorInfo->Mode1280x1024 = iRefreshRate;
    }

    else if( ( dwWidth <= 1600 ) && ( dwHeight <= 1200 ) )
    {
        pddd->lpMonitorInfo->Mode1600x1200 = iRefreshRate;
    }
}


/*
 * GetModeToTest
 */
HRESULT GetModeToTest( DWORD dwInWidth, DWORD dwInHeight, 
                       LPDWORD lpdwOutWidth, LPDWORD lpdwOutHeight )
{
    if( ( dwInWidth <= 640 ) && ( dwInHeight <= 480 ) )
    {
        *lpdwOutWidth = 640;
        *lpdwOutHeight = 480;
    }

    else if( ( dwInWidth <= 800 ) && ( dwInHeight <= 600 ) )
    {
        *lpdwOutWidth = 800;
        *lpdwOutHeight = 600;
    }

    else if( ( dwInWidth <= 1024 ) && ( dwInHeight <= 768 ) )
    {
        *lpdwOutWidth = 1024;
        *lpdwOutHeight = 768;
    }

    else if( ( dwInWidth <= 1280 ) && ( dwInHeight <= 1024 ) )
    {
        *lpdwOutWidth = 1280;
        *lpdwOutHeight = 1024;
    }

    else if( ( dwInWidth <= 1600 ) && ( dwInHeight <= 1200 ) )
    {
        *lpdwOutWidth = 1600;
        *lpdwOutHeight = 1200;
    }
    else
    {
        return DDERR_GENERIC;
    }

    return DD_OK;
}


/*
 * GuestimateRefreshRate
 */
int GuestimateRefreshRate( LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD dwWidth, DWORD dwHeight,
                           DWORD dwHighestRefresh, DWORD dwHighestBandwidth )
{
    int i;
    DWORD dwBandwidth;

    if( ( pddd->lpMonitorInfo == NULL ) ||
        ( dwHighestRefresh == 0 ) )
    {
        return 0;
    }

    // Sanity check to see if the monitor can handle the resolution

    if( !MonitorCanHandleMode( pddd, dwWidth, dwHeight, 0 ) )
    {
        return 0;
    }

    // If the monitor did not return any refresh rates higher than 60,
    // something is up so we'd better stick to it.

    if( dwHighestRefresh == 60 )
    {
        return 60;
    }

    // Likwise, we will only go after the 100+ refresh rates if the monitor
    // enumerated a refresh rate of at least 85hz.  This may be an unnecesary
    // restiction, but it seems safe.

    for( i = NUM_SUPPORTED_REFRESH_RATES - 1; i >= 0; i-- )
    {
        if( ( SupportedRefreshRates[i] <= 85 ) ||
            ( dwHighestRefresh >= 85 ) )
        {
            dwBandwidth = dwWidth * dwHeight * SupportedRefreshRates[i];
            if( dwBandwidth <= dwHighestBandwidth )
            {
                return SupportedRefreshRates[i];
            }
        }
    }

    return 0;
}


/*
 * SetTheMode
 */
HRESULT SetTheMode( LPDIRECTDRAW7 lpDD, LPMODETESTCONTEXT pContext )
{
    HRESULT hr;
    DWORD dwBPP;

    /*
     * We set an internal flag indicating that we are running a mode test.
     * This lets CanMonitorHandleRefreshRate know that the requested mode
     * should be used, even though it hasb't successfully been tested yet.
     */
    ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpGbl->dwFlags |= DDRAWI_TESTINGMODES;

    //
    // There might be a case in which we decided that the lowest BPP the driver
    // could do for this mode was, say, 8bpp. But that didn't take into consideration
    // what rates the driver said it could do. E.g. if the driver (for whatever 
    // reason) doesn't advertise 8bpp at 60Hz, but DOES advertise 16bpp at 60Hz
    // then we can go ahead and use the 16bpp mode. We are here to test monitor
    // bandwidth, not the DAC. The monitor's bandwidth is entirely determined
    // by the spatial resolution and refresh rate. If we bump the driver to 
    // a higher BPP (one that it says it can do), then we are still testing 
    // the correct monitor setup.
    // We do this in a really dumb way: just keep cranking up from the lowest BPP
    // (which is in the context mode list) in steps of 8 until we succeed the
    // mode change, or exceed 32bpp.
    //
    dwBPP = pContext->lpModeList[pContext->dwCurrentMode].dwBPP;
    do
    {
        hr = DD_SetDisplayMode2( (LPDIRECTDRAW)lpDD,
                pContext->lpModeList[pContext->dwCurrentMode].dwWidth,
                pContext->lpModeList[pContext->dwCurrentMode].dwHeight,
                dwBPP,
                pContext->lpModeList[pContext->dwCurrentMode].dwRefreshRate,
                DDSDM_STANDARDVGAMODE );

        dwBPP += 8;
    } while(FAILED(hr) && (dwBPP <= 32) );

    ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpGbl->dwFlags &= ~DDRAWI_TESTINGMODES;

    return hr;
}


/*
 * SetupNextTest
 */
void SetupNextTest( LPDIRECTDRAW7 lpDD, LPMODETESTCONTEXT pContext )
{
    int i;
    
    /*
     * Drop back to the next refrsh rate if there is one, otherwise
     * move on to the next mode.
     */
    for( i = NUM_SUPPORTED_REFRESH_RATES - 1; i >= 0; i-- )
    {
        if( SupportedRefreshRates[i] < 
            pContext->lpModeList[pContext->dwCurrentMode].dwRefreshRate )
        {
            pContext->lpModeList[pContext->dwCurrentMode].dwRefreshRate =
                SupportedRefreshRates[i];
            break;
        }
    }
    if( i < 0 )
    {
        // We've tried everything in this mode, so move on

        UpdateMonitorInfo( ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpGbl, 
            pContext->lpModeList[pContext->dwCurrentMode].dwWidth,
            pContext->lpModeList[pContext->dwCurrentMode].dwHeight,
            0 );

        pContext->dwCurrentMode++;
    }
}


/*
 * RunNextTest
 */
HRESULT RunNextTest( LPDIRECTDRAW7 lpDD, LPMODETESTCONTEXT pContext )
{
    HRESULT hr;
    LPDDRAWI_DIRECTDRAW_GBL pddd;

    do
    {
        if( pContext->dwCurrentMode >= pContext->dwNumModes )
        {
            // Restore the mode if we've changed it

            pddd = ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpGbl;
            if( pContext->dwOrigModeIndex != pddd->dwModeIndex )
            {
                DD_SetDisplayMode2( (LPDIRECTDRAW)lpDD,
                    pddd->lpModeInfo[pContext->dwOrigModeIndex].dwWidth,
                    pddd->lpModeInfo[pContext->dwOrigModeIndex].dwHeight,
                    pddd->lpModeInfo[pContext->dwOrigModeIndex].dwBPP,
                    pddd->lpModeInfo[pContext->dwOrigModeIndex].wRefreshRate,
                    0 );
            }

            DDSaveMonitorInfo( (LPDDRAWI_DIRECTDRAW_INT)lpDD );

            MemFree( pContext->lpModeList );
            MemFree( pContext );
            ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpModeTestContext = NULL;

            return DDERR_TESTFINISHED;
        }
        hr = SetTheMode( lpDD, pContext );
        if( hr != DD_OK )
        {
            SetupNextTest( lpDD, pContext );
        }
    } while( ( hr != DD_OK ) && (hr != DDERR_TESTFINISHED ) );

    if( hr != DDERR_TESTFINISHED )
    {
        pContext->dwTimeStamp =  GetTickCount();
    }

    return hr;
}


#endif

/*
 * DD_StartModeTest
 *
 * Indicates that the app wants to start testing a mode (or modes).
 */
HRESULT DDAPI DD_StartModeTest( LPDIRECTDRAW7 lpDD, LPSIZE lpModesToTest, DWORD dwNumEntries, DWORD dwFlags )
{
#ifdef WIN95
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    BOOL                        excl_exists;
    BOOL                        is_excl;
    LPMODETESTCONTEXT           pContext;
    DWORD                       i;
    DWORD                       j;
    HRESULT                     hr;
    DWORD                       dwRefreshRate;
    DWORD                       dwModeWidth;
    DWORD                       dwModeHeight;
    VESA_EDID                   EDIDData;
    DWORD                       dwHighestRefresh;
    DWORD                       dwHighestBandwidth;

    ENTER_DDRAW();
#endif


    DPF(2,A,"ENTERAPI: DD_StartModeTest");

#ifdef WINNT

    return DDERR_TESTFINISHED;

#else
    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( this->lpMonitorInfo == NULL )
        {
            // There is no monitor info
            LEAVE_DDRAW();
            return DDERR_NOMONITORINFORMATION;
        }

        if( this_lcl->lpModeTestContext != NULL )
        {
            DPF_ERR( "Mode test already running" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }        

        if( dwFlags & ~DDSMT_VALID )
        {
            DPF_ERR( "Invalid Flags specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( ( dwFlags & DDSMT_ISTESTREQUIRED ) &&
            ( lpModesToTest == NULL ) )
        {
            DPF_ERR( "No modes specified to test" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        CheckExclusiveMode( this_lcl, &excl_exists, &is_excl, FALSE, NULL, FALSE);
        if( lpModesToTest != NULL )
        {
            if ( ( dwNumEntries == 0 ) ||
                 ( !VALID_BYTE_ARRAY( lpModesToTest, sizeof( SIZE ) * dwNumEntries ) ) )
            {
                DPF_ERR( "Invalid mode list specified" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
    
            /*
             * The app must own exclusive mode to test the modes
             */
            if ( !is_excl ||  !(this->dwFlags & DDRAWI_FULLSCREEN) )
            {
                DPF_ERR( "Must be in full-screen exclusive mode to test the modes" );
                LEAVE_DDRAW();
                return DDERR_NOEXCLUSIVEMODE;
            }
        }
        else
        {
            /*
             * There must not be another app running which owns exclusive mode
             */
            if( !excl_exists || is_excl )
            {
                this->lpMonitorInfo->Mode640x480 = -1;
                this->lpMonitorInfo->Mode800x600 = -1;
                this->lpMonitorInfo->Mode1024x768 = -1;
                this->lpMonitorInfo->Mode1280x1024 = -1;
                this->lpMonitorInfo->Mode1600x1200 = -1;
                this->lpMonitorInfo->ModeReserved1 = -1;
                this->lpMonitorInfo->ModeReserved2 = -1;
                this->lpMonitorInfo->ModeReserved3 = -1;
                
                hr = DDSaveMonitorInfo( this_int );
                LEAVE_DDRAW();
                return hr;
            }
            else
            {
                DPF_ERR( "Cannot reset monitor info; another app owns exclusive mode" );
                LEAVE_DDRAW();
                return DDERR_NOEXCLUSIVEMODE;
            }

        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * Get and evaluate the EDID data
     */
    hr = GetEDIDData( this, &EDIDData );
    if( hr != DD_OK )
    {
        // There is no EDID data
        LEAVE_DDRAW();
        return DDERR_NOMONITORINFORMATION;
    }
    EvaluateMonitor( &EDIDData, &dwHighestRefresh, &dwHighestBandwidth );

    for( i = 0; i < this->dwNumModes; i++ )
    {
        if( this->lpModeInfo[i].wRefreshRate > 0 )
        {
            break;
        }
    }
    if( i == this->dwNumModes )
    {
        // The driver does not enumerate display mode refresh rates.
        LEAVE_DDRAW();
        return DDERR_NODRIVERSUPPORT;
    }
    
    /*
     * Allocate a context for ourselves
     */
    pContext = (LPMODETESTCONTEXT) MemAlloc( sizeof( MODETESTCONTEXT ) );
    if( pContext == NULL )
    {
        DPF_ERR( "Insufficient memory" );
        LEAVE_DDRAW();
        return DDERR_OUTOFMEMORY;
    }
    pContext->dwNumModes = 0;
    pContext->dwCurrentMode = 0;
    pContext->lpModeList = (LPMODETESTDATA) MemAlloc( sizeof( MODETESTDATA ) * dwNumEntries );
    if( pContext->lpModeList == NULL )
    {
        MemFree( pContext );
        LEAVE_DDRAW();
        return DDERR_OUTOFMEMORY;
    }
    this_lcl->lpModeTestContext = pContext;
    
    /*
     * Guestimate which refresh rates we should try for each mode in the list
     * based on the EDID data
     */
    for( i = 0; i < dwNumEntries; i++ )
    {
        DWORD dwLowestBPP = 0xFFFFFFFF;
        /*
         * Verify that the driver understands the resolution
         */
        for( j = 0; j < this->dwNumModes; j++ )
        {
            if( ( this->lpModeInfo[j].dwHeight == (DWORD) lpModesToTest[i].cy ) &&
                ( this->lpModeInfo[j].dwWidth == (DWORD) lpModesToTest[i].cx ) )
            {
                if( this->lpModeInfo[j].dwBPP < dwLowestBPP )
                {
                    dwLowestBPP = this->lpModeInfo[j].dwBPP;
                }
            }
        }
        if( dwLowestBPP == 0xFFFFFFFF )
        {
            /*
             * The driver doesn't undestand this mode, so the app is dumb 
             * for not enumerating the modes first.
             */
            MemFree( pContext->lpModeList );
            MemFree( pContext );
            this_lcl->lpModeTestContext = NULL;
            DPF_ERR( "Invalid mode specified in mode list" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * Get the actual mode to test.  For example, the app may want
         * to test 320x240, 640x400, and 640x480, but we treat all of these
         * modes the same so we only have to do a single test.
         */
        hr = GetModeToTest( lpModesToTest[i].cx, 
            lpModesToTest[i].cy,
            &dwModeWidth,
            &dwModeHeight );
        if( hr != DD_OK )
        {
            // They are testing a mode higher the 1600x1200
            continue;
        }
        for( j = 0; j < pContext->dwNumModes; j++ )
        {
            if( ( pContext->lpModeList[j].dwWidth == dwModeWidth ) &&
                ( pContext->lpModeList[j].dwHeight == dwModeHeight ) )
            {
                break;
            }
        }
        if( j < pContext->dwNumModes )
        {
            // Duplicate mode
            continue;
        }

        if( !IsModeTested( this, dwModeWidth, dwModeHeight ) )
        {
            dwRefreshRate = GuestimateRefreshRate( this, dwModeWidth, dwModeHeight, 
                dwHighestRefresh, dwHighestBandwidth );
        
            pContext->lpModeList[pContext->dwNumModes].dwWidth = dwModeWidth;
            pContext->lpModeList[pContext->dwNumModes].dwHeight = dwModeHeight;
            pContext->lpModeList[pContext->dwNumModes].dwBPP = dwLowestBPP;
            pContext->lpModeList[pContext->dwNumModes].dwRefreshRate = dwRefreshRate;
            pContext->dwNumModes++;
        }
    }

    /*
     * After all of that, do we still have any modes that need testing?  
     * If not, we can stop now
     */
    if( dwFlags & DDSMT_ISTESTREQUIRED )
    {
        hr = ( pContext->dwNumModes > 0 ) ? DDERR_NEWMODE : DDERR_TESTFINISHED;
        MemFree( pContext->lpModeList );
        MemFree( pContext );
        this_lcl->lpModeTestContext = NULL;
    }
    else
    {
        pContext->dwOrigModeIndex = this->dwModeIndex;
        hr = RunNextTest( lpDD, pContext );
    }

    LEAVE_DDRAW();
    return hr;
#endif
} 


/*
 * DD_EvaluateMode
 *
 * Called at high frequency while the mode test is being performed.  If the user has indicated
 * that a mode succeeded or failed, we move on to the next moe in the test; otherwise, we will 
 * simply check the 15 second timeout value and fail the mode when we hit it..
 */
HRESULT DDAPI DD_EvaluateMode( LPDIRECTDRAW7 lpDD, DWORD dwFlags, DWORD *pSecondsUntilTimeout)
{
#ifdef WIN95
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    BOOL                        excl_exists;
    BOOL                        is_excl;
    LPMODETESTCONTEXT           pContext;
    DWORD                       i;
    DWORD                       j;
    HRESULT                     hr = DD_OK;
    DWORD                       dwTick;

    ENTER_DDRAW();
#endif

    DPF(2,A,"ENTERAPI: DD_EvaluateMode");

#ifdef WINNT

    return DDERR_INVALIDPARAMS;

#else
    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( this->lpMonitorInfo == NULL )
        {
            // There is no monitor info so we should not be here
            LEAVE_DDRAW();
            return DDERR_NOMONITORINFORMATION;
        }
        
    	pContext = this_lcl->lpModeTestContext;
        if( NULL == pContext )
    	{
            DPF_ERR( "Must call StartModeTest before EvaulateMode" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
    	}

        if( ( NULL != pSecondsUntilTimeout ) && 
            !VALID_BYTE_ARRAY( pSecondsUntilTimeout, sizeof( DWORD ) ) )
    	{
            DPF_ERR( "Invalid pointer to timeout counter" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
    	}

        if( dwFlags & ~DDEM_VALID )
        {
            DPF_ERR( "Invalid Flags specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( ( dwFlags & DDEM_MODEPASSED ) &&
            ( dwFlags & DDEM_MODEFAILED ) )
        {
            DPF_ERR( "Invalid Flags specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * If we lost exclusive mode, we should stop the test now
         */
        CheckExclusiveMode( this_lcl, &excl_exists, &is_excl, FALSE, NULL, FALSE);
        if (!is_excl ||  !(this->dwFlags & DDRAWI_FULLSCREEN) )
        {
            DPF_ERR( "Exclusive mode lost" );
            MemFree( pContext->lpModeList );
            MemFree( pContext );
            this_lcl->lpModeTestContext = NULL;
            LEAVE_DDRAW();
            return DDERR_TESTFINISHED;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    if( dwFlags & DDEM_MODEPASSED )
    {
        // The current data is good, so save it

        UpdateMonitorInfo( this, 
            pContext->lpModeList[pContext->dwCurrentMode].dwWidth,
            pContext->lpModeList[pContext->dwCurrentMode].dwHeight,
            pContext->lpModeList[pContext->dwCurrentMode].dwRefreshRate );
            
        // Move on to the next test, if there is one
        
        pContext->dwCurrentMode++;
        hr = RunNextTest( lpDD, pContext );
        if( hr == DD_OK )
        {
            hr = DDERR_NEWMODE;
        }
    }
    else
    {
        // Has our timeout expired?

        dwTick = GetTickCount();
        if( dwTick - pContext->dwTimeStamp > 15000 )
        {
            dwFlags |= DDEM_MODEFAILED;
        }

        if( dwFlags & DDEM_MODEFAILED )
        {
            // Drop down to the next refresh rate or the next mode

            SetupNextTest( lpDD, pContext );
            hr = RunNextTest( lpDD, pContext );
            if( hr == DD_OK )
            {
                hr = DDERR_NEWMODE;
            }

            dwTick = GetTickCount();
        }
    }

    if( pSecondsUntilTimeout != NULL )
    {
        if( hr == DDERR_TESTFINISHED )
        {
            *pSecondsUntilTimeout = 0;
        }
        else
        {
            *pSecondsUntilTimeout = 15 - ( ( dwTick - pContext->dwTimeStamp) / 1000 );
        }
    }

    LEAVE_DDRAW();        
    return hr;
#endif
}


//
// This function is designed to allow DX7 apps to see some modes that would otherwise be
// incorrectly masked by the mode enumeration thing.
//
// If a driver exposes a list of modes with full-on refresh rates in EVERY entry in the mode table,
// then we will enum exactly NONE of them to the app, since any rate with a rate cannot be enumerated
// until the mode test has run. Apps that don't run the mode test will see NO modes at all.
//
// The s3 savage 4 is a case in point: it fills in the refresh rate for the current display mode,
// (and no other mode) and doesn't dupe the entry to one with a zero refresh rate.
//
// What we do is: every time we find an instance of a mode (size, bitdepth, masks) that has no 
// zero-rate entry, we append a zero-rate entry to the end of the mode list.
//

//No need to massage on winNT
#ifdef WIN95
void MassageModeTable(LPDDRAWI_DIRECTDRAW_GBL pddd)
{
    DWORD iMode, iCheckZero;
    if( pddd->lpModeInfo != NULL )
    {
RestartLoop:
        for( iMode = 0; iMode < pddd->dwNumModes;  iMode++ )
        {
            if (pddd->lpModeInfo[iMode].wRefreshRate != 0)
            {
                // Found a mode with non-zero rate. Check to see if the mode is also represented
                // by a zero-rate entry. If it is not, then append such an entry
                for( iCheckZero = 0; iCheckZero < pddd->dwNumModes;  iCheckZero++ )
                {
                    if( (pddd->lpModeInfo[iCheckZero].dwWidth    == pddd->lpModeInfo[iMode].dwWidth) &&
                        (pddd->lpModeInfo[iCheckZero].dwHeight   == pddd->lpModeInfo[iMode].dwHeight) &&
                        (pddd->lpModeInfo[iCheckZero].dwBPP      == pddd->lpModeInfo[iMode].dwBPP) &&
                        (pddd->lpModeInfo[iCheckZero].dwRBitMask == pddd->lpModeInfo[iMode].dwRBitMask) &&
                        (pddd->lpModeInfo[iCheckZero].dwGBitMask == pddd->lpModeInfo[iMode].dwGBitMask) &&
                        (pddd->lpModeInfo[iCheckZero].dwBBitMask == pddd->lpModeInfo[iMode].dwBBitMask))
                    {
                        // found a matching mode, in terms of size and depth.
                        // If the refresh rate is zero, then we can break out and go on to the next iMode
                        if (pddd->lpModeInfo[iCheckZero].wRefreshRate == 0)
                        {
                            goto NextMode;
                        }
                    }
                }
                // If we got here, then there was no entry in the mode list for this size+depth
                // that had a zero refresh rate. Append one now.
                // Note how expanding the mode list like this means that if the driver (as it typically
                // will) offers several rates for a given mode, we'll expand the table on the first
                // hit of that mode, but then the expanded table will satisfy us for every subsequent
                // rate of that mode (i.e. now there WILL be a zero-rated entry for that mode (since
                // we just added it)).
                {
                    LPDDHALMODEINFO pmi;

                    pmi = (LPDDHALMODEINFO) MemAlloc(sizeof(*pmi) * (pddd->dwNumModes+1));
                    if (pmi == NULL)
                    {
                        //oh just give up....
                        return;
                    }

                    memcpy(pmi, pddd->lpModeInfo, sizeof(*pmi)*pddd->dwNumModes );
                    MemFree(pddd->lpModeInfo);
                    pddd->lpModeInfo = pmi;

                    // Now put the zero-rated mode in there
                    memcpy( &pddd->lpModeInfo[pddd->dwNumModes], &pddd->lpModeInfo[iMode], sizeof(*pmi));
                    pddd->lpModeInfo[pddd->dwNumModes].wRefreshRate = 0;
                    pddd->lpModeInfo[pddd->dwNumModes].wFlags |= DDMODEINFO_DX7ONLY;

                    pddd->dwNumModes++;

                    //Now we have to restart the whole loop because we changed the lpModeInfo pointer:
                    goto RestartLoop;
                }
            }
NextMode:;
        }
    }
}
#endif //WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddsatch.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsatch.c
 *  Content: 	DirectDraw attached surface support.
 *		AddAttachedSurface, DeleteAttachedSurface,
 *		EnumAttachedSurfaces, GetAttachedSurface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   14-jan-95	craige	initial implementation
 *   22-jan-95	craige	made 32-bit + ongoing work
 *   31-jan-95	craige	and even more ongoing work...
 *   27-feb-95	craige 	new sync. macros
 *   03-mar-95	craige	GetAttachedSurface code
 *   19-mar-95	craige	use HRESULTs
 *   23-mar-95	craige	expanded functionality
 *   01-apr-95	craige	happy fun joy updated header file
 *   12-apr-95	craige	proper csect call order
 *   06-may-95	craige	use driver-level csects only
 *   11-jun-95	craige	comment out fliplist code
 *   13-jun-95	kylej	added flippable chain side-effects for
 *			AddAttachedSurface and DeleteAttachedSurface
 *			added DeleteOneLink, added a cleanup parameter to
 *                      DeleteOneAttachment
 *   16-jun-95	craige	removed fpVidMemOrig
 *   17-jun-95	craige	new surface structure
 *   20-jun-95  kylej   prevent detachments of implicit attachments
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns
 *   04-jul-95	craige	YEEHAW: new driver struct; SEH
 *   31-jul-95	craige	validate flags
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consistency with Direct3D
 *   07-dec-95  colinmc added mip-map support
 *   18-dec-95  colinmc added ability to add system memory z-buffer as
 *                      attachement to video memory surface.
 *   18-dec-95  colinmc additional caps bit checking in GetAttachedSurface
 *   02-jan-96	kylej	handle new interface structs
 *   12-feb-96  colinmc surface lost flag moved from global to local object
 *   20-mar-96  colinmc Bug 13634: Unidirectional attached surfaces can
 *                      cause infinite loop on cleanup
 *   12-may-96  colinmc Bug 22401: Missing return from DeleteOneAttachment
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *
 ***************************************************************************/
#include "ddrawpr.h"

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateMipMapCount"

/*
 * UpdateMipMapCount
 *
 * When we add or remove levels from a mip-map the mip-map count changes for
 * those levels left in the original chain (as the mip-map count gives the
 * number of levels in the chain). Hence we need to recompute the mip-map
 * level count when a mip-map is added or removed from a chain.
 */
void UpdateMipMapCount( LPDDRAWI_DDRAWSURFACE_INT psurf_int )
{
    LPDDRAWI_DDRAWSURFACE_INT pparentsurf_int;
    DWORD                     dwLevels;

    /*
     * Find the top most level mip-map in the chain.
     */
    pparentsurf_int = psurf_int;
    while( pparentsurf_int != NULL )
    {
	psurf_int = pparentsurf_int;
	pparentsurf_int = FindParentMipMap( psurf_int );
    }
    pparentsurf_int = psurf_int;

    /*
     * We have the top most level in the mip-map chain. Lowe count
     * the levels in the chain.
     */
    dwLevels = 0UL;
    while( psurf_int != NULL )
    {
	dwLevels++;
	psurf_int = FindAttachedMipMap( psurf_int );
    }

    /*
     * Now update all the levels with their new mip-map count.
     */
    psurf_int = pparentsurf_int;
    while( psurf_int != NULL )
    {
	psurf_int->lpLcl->lpSurfMore->dwMipMapCount = dwLevels;
	dwLevels--;
	psurf_int = FindAttachedMipMap( psurf_int );
    }

    DDASSERT( dwLevels == 0UL );
} /* UpdateMipMapCount */

/*
 * AddAttachedSurface
 *
 * Add an attached surface to another.
 * Assumes that all parameters coming in are VALID!
 */
HRESULT AddAttachedSurface( LPDDRAWI_DDRAWSURFACE_INT psurf_from_int,
			    LPDDRAWI_DDRAWSURFACE_INT psurf_to_int,
			    BOOL implicit )
{
    LPATTACHLIST		pal_from;
    LPATTACHLIST		pal_to;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf_from;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_from_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf_to;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_to_lcl;

    psurf_from_lcl = psurf_from_int->lpLcl;
    psurf_from = psurf_from_lcl->lpGbl;
    psurf_to_lcl = psurf_to_int->lpLcl;
    psurf_to = psurf_to_lcl->lpGbl;

    /*
     * allocate attachment structures
     */
    pal_from = MemAlloc( sizeof( ATTACHLIST ) );
    if( pal_from == NULL )
    {
	return DDERR_OUTOFMEMORY;
    }
    pal_to = MemAlloc( sizeof( ATTACHLIST ) );
    if( pal_to == NULL )
    {
	MemFree( pal_from );
	return DDERR_OUTOFMEMORY;
    }

#ifdef WINNT
    /*
     * let the kernel know about the attachment
     * ...only if the driver isn't emulated
     */
    if ( psurf_from_lcl->lpSurfMore->lpDD_lcl->lpGbl->hDD )
    {
        if ( !DdAttachSurface(psurf_from_lcl, psurf_to_lcl) )
        {
            /*
             * ATTENTION
             * Hack o rama for NT5 b1. The kernel will fail this attach for the primary chain if
             * it ends up in system memory due to an out of vidmem. The kernel doesn't like
             * the user-mode address '0xffbadbad'. Wonder why?
             * For now, we'll just carry on regardless.
             */
            DPF(0,"DdAttachSurface failed!");
            //MemFree( pal_from );
            //MemFree( pal_to );
            //return DDERR_OUTOFMEMORY;
        }
    }
#endif

    /*
     * mark as implicit if created as part of an initial complex structure
     */
    if( implicit )
    {
	pal_from->dwFlags |= DDAL_IMPLICIT;
	pal_to->dwFlags |= DDAL_IMPLICIT;
    }
    else
    {
	//  The surface being attached to holds a reference count on the surface
	//  attached from if the attachment is not implicit.
	DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)psurf_to_int );
	DPF(3, "Attachment ADDREF %08lx", psurf_to_int);
    }

    /*
     * connect the surfaces
     */
    pal_from->lpIAttached = psurf_to_int;
    pal_from->lpAttached = psurf_to_lcl;
    pal_from->lpLink = psurf_from_lcl->lpAttachList;
    psurf_from_lcl->lpAttachList = pal_from;
    psurf_from_lcl->dwFlags |= DDRAWISURF_ATTACHED;

    pal_to->lpIAttached = psurf_from_int;
    pal_to->lpAttached = psurf_from_lcl;
    pal_to->lpLink = psurf_to_lcl->lpAttachListFrom;
    psurf_to_lcl->lpAttachListFrom = pal_to;
    psurf_to_lcl->dwFlags |= DDRAWISURF_ATTACHED_FROM;

    return DD_OK;
} /* AddAttachedSurface */

#undef DPF_MODNAME
#define DPF_MODNAME "AddAttachedSurface"

BOOL isImplicitAttachment( LPDDRAWI_DDRAWSURFACE_INT this_int,
		           LPDDRAWI_DDRAWSURFACE_INT pattsurf_int)
{
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL	pattsurf_lcl;
    LPATTACHLIST		curr;

    this_lcl = this_int->lpLcl;
    pattsurf_lcl = pattsurf_int->lpLcl;

    /*
     * see if specified surface is attached
     */
    curr = this_lcl->lpAttachList;
    while( curr != NULL )
    {
	if( curr->lpIAttached == pattsurf_int )
	{
	    break;
	}
	curr = curr->lpLink;
    }

    if( (curr != NULL) && (curr->dwFlags & DDAL_IMPLICIT) )
	return TRUE;

    return FALSE;
}


/*
 * DD_Surface_AddAttachedSurface
 */
HRESULT DDAPI DD_Surface_AddAttachedSurface(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDIRECTDRAWSURFACE lpDDAttachedSurface )
{
    LPDDRAWI_DDRAWSURFACE_INT       this_int;
    LPDDRAWI_DDRAWSURFACE_LCL       this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT       this_attached_int;
    LPDDRAWI_DDRAWSURFACE_LCL       this_attached_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL       this;
    LPDDRAWI_DDRAWSURFACE_GBL       this_attached;
    DWORD                           rc;
    LPATTACHLIST                    pal;
    LPATTACHLIST                    pal_next;
    LPDDHALSURFCB_ADDATTACHEDSURFACE    aasfn;
    LPDDHALSURFCB_ADDATTACHEDSURFACE    aashalfn;
    DDHAL_ADDATTACHEDSURFACEDATA        aasd;
    DWORD                           caps;
    DWORD                           hitcaps;
    LPDDRAWI_DIRECTDRAW_LCL         pdrv_lcl;
    BOOL                            emulation;
    BOOL                            was_implicit;
    BOOL                            has_excl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_AddAttachedSurface");

    /*
     * validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        this_attached_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDAttachedSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_attached_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_attached_lcl = this_attached_int->lpLcl;
        this = this_lcl->lpGbl;
        this_attached = this_attached_lcl->lpGbl;
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;

        //
        // For DX7, we will DISALLOW any attachment that doesn't involve a z buffer.
        // The exact rule is: exactly one of the two surfaces must be a Z buffer, AND
        // exactly one of the two surfaces must NOT be a Z buffer.
        //
        if (!LOWERTHANSURFACE7(this_int))
        {
            DWORD dwBothCaps;

            dwBothCaps = this_lcl->ddsCaps.dwCaps ^ this_attached_lcl->ddsCaps.dwCaps;
            if (0 == (dwBothCaps & DDSCAPS_ZBUFFER) )
            {
                DPF(0,"You can only attach Z buffers in DX7. No other surface type can be attached.");
                DPF(0,"Mipmaps, flipping chains and cube maps must be created by ONE call to CreateSurface.");
                LEAVE_DDRAW();
                return DDERR_CANNOTATTACHSURFACE;
            }
        }

        /*
         * Can't attach execute buffers to anything.
         *
         * !!! NOTE; Look into this. Would there be any value
         * in being able to attach execute buffers to each other.
         * Batch system to video memory transfer perhaps?
         */
        if( ( this_lcl->ddsCaps.dwCaps | this_attached_lcl->ddsCaps.dwCaps ) & DDSCAPS_EXECUTEBUFFER )
        {
            DPF_ERR( "Invalid surface types: can't attach surface" );
            LEAVE_DDRAW();
            return DDERR_CANNOTATTACHSURFACE;
        }

        /*
         * Cubemaps can't be attached. period
         */
        if( (( this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP ) && (0==(this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER)) ) )
        {
            DPF_ERR( "Can only attach zbuffers to cubemap surfaces" );
            LEAVE_DDRAW();
            return DDERR_CANNOTATTACHSURFACE;
        }

        //
        // If it is an Optimized surface, then continue only if:
        // 1) The current and the attached surface are non-empty
        // 2) Both are texture & mipmap
        // 3) Both have the same optimization caps
        //
        // For now, if the current surface is optimized, quit
        if ((this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED) ||
            (this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
        {
                DPF_ERR( "Cannot attach to an optimized surface" );
                LEAVE_DDRAW();
                return DDERR_CANNOTATTACHSURFACE;
        }

        /*
         * Can't attach a backbuffer to a non-exclusive or non-fullscreen primary
         */
        CheckExclusiveMode(this_lcl->lpSurfMore->lpDD_lcl, NULL , &has_excl, FALSE, 
            NULL, FALSE);
        if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
            && ( (!has_excl)
                 || !(this->lpDD->dwFlags & DDRAWI_FULLSCREEN) ) )
        {
            DPF_ERR( "Must be in full-screen exclusive mode to create a flipping primary surface" );
            LEAVE_DDRAW();
            return DDERR_NOEXCLUSIVEMODE;
        }

        /*
         * same surface?
         */
        if( this_lcl == this_attached_lcl )
        {
            DPF_ERR( "Can't attach surface to itself" );
            LEAVE_DDRAW();
            return DDERR_CANNOTATTACHSURFACE;
        }

        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
        if( SURFACE_LOST( this_attached_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        /*
         * are the surfaces already attached?
         */
        pal = this_lcl->lpAttachList;
        while( pal != NULL )
        {
            if( pal->lpIAttached == this_attached_int )
            {
                DPF_ERR( "Surface already attached" );
                LEAVE_DDRAW();
                return DDERR_SURFACEALREADYATTACHED;
            }
            pal = pal->lpLink;
        }

        /*
         * BEHAVIOUR CHANGE FOR DX5
         *
         * We do not allow attaching surfaces created with different
         * DirectDraw objects.
         */
        if (this_lcl->lpSurfMore->lpDD_lcl->lpGbl != this_attached_lcl->lpSurfMore->lpDD_lcl->lpGbl)
        {
            /*
             * Don't check if either device isn't a display driver (i.e. 3dfx)
             * since that's a back-compat hole.
             */
            if ( (this->lpDD->dwFlags & DDRAWI_DISPLAYDRV) &&
                 (this_attached->lpDD->dwFlags & DDRAWI_DISPLAYDRV) )
            {
                DPF_ERR("Can't attach surfaces between different direct draw devices");
                LEAVE_DDRAW();
                return DDERR_DEVICEDOESNTOWNSURFACE;
            }
        }

        /*
         * Do sizes match?
         */
        if( ( ( this_lcl->ddsCaps.dwCaps & this_attached_lcl->ddsCaps.dwCaps ) & ( DDSCAPS_TEXTURE | DDSCAPS_MIPMAP ) ) ==
            ( DDSCAPS_TEXTURE | DDSCAPS_MIPMAP ) )
        {
            /*
             * If attaching a mip-map we ensure that the child is no bigger than the
             * parent. We don't insist on strict power of 2 smaller as a mip-map
             * may have missing levels.
             */
            if( ( this->wWidth  < this_attached->wWidth  ) ||
                ( this->wHeight < this_attached->wHeight ) )
            {
                DPF_ERR( "Attached mip-map must be no larger than parent map" );
                    LEAVE_DDRAW();
                    return DDERR_CANNOTATTACHSURFACE;
                }
            }
            else
            {
                if( !(!(this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) &&
                      (this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)) &&
                    !((this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) &&
                      !(this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)) )
                {
                    if( (this->wHeight != this_attached->wHeight) ||
                        (this->wWidth != this_attached->wWidth) )
                    {
                        DPF_ERR( "Can't attach surfaces of differing sizes" );
                        LEAVE_DDRAW();
                        return DDERR_CANNOTATTACHSURFACE;
                    }
                }
            }

        /*
         * don't allow multiple of the same type of surface to be attached to a surface
         */
        caps = this_attached_lcl->ddsCaps.dwCaps & (DDSCAPS_TEXTURE|DDSCAPS_MIPMAP|
                                                    DDSCAPS_ALPHA|DDSCAPS_ZBUFFER);
        if( caps )
        {
            pal = this_lcl->lpAttachList;
            while( pal != NULL )
            {
                hitcaps = pal->lpAttached->ddsCaps.dwCaps & caps;
                if( hitcaps )
                {
                    /*
                     * Horrible special case. We can attach more than one texture
                     * to a surface as long as one of them is a mip-map and the other
                     * isn't.
                     */
                    if( !( hitcaps & DDSCAPS_TEXTURE ) ||
                        !( ( pal->lpAttached->ddsCaps.dwCaps ^ caps ) & DDSCAPS_MIPMAP ) )
                    {
                        DPF_ERR( "Can't attach 2 or more of the same type of surface to one surface" );
                        LEAVE_DDRAW();
                        return DDERR_CANNOTATTACHSURFACE;
                    }
                }
                pal_next = pal->lpLink;
                pal = pal_next;
            }
        }

        /*
         * If the attached surface could be part of a flippable chain with the
         * original surface but it is already flippable, we cannot attach it.
         * (It would create a non-simple flipping chain).
         */
        if( ( this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP ) &&
            CanBeFlippable( this_lcl, this_attached_lcl ) )
        {
            DPF_ERR( "Can't attach a flippable surface to another flippable surface of the same type");
            LEAVE_DDRAW();
            return DDERR_CANNOTATTACHSURFACE;
        }

        /*
         * Don't allow an emulated surface to be attached to a non-emulated
         * surface.
         */
        if( ( (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
              !(this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)) ||
            (!(this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
             (this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) ) )
        {
            /*
             * Special case: We allow s system memory z-buffer to be attached to
             * a video memory surface. This to keep the software rendering people
             * happy. They want to use a video memory surface as rendering target
             * so they get the benefit from page flipping but they don't want to
             * have a z-buffer in VRAM as they have to read from it and thats
             * slooowwww... Its also really useful to have the z-buffer as an
             * attachment. So just to be nice...
             *
             * !!! NOTE: This means that we are going to invoke the
             * AddAttachedSurface HAL member with one system and one video
             * memory surface. What are the impliciations of this.
             */
            if( !( ( this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER ) &&
                   ( this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) ) )
            {
                DPF_ERR( "Can't attach an emulated surface to a non-emulated surface.");
                LEAVE_DDRAW();
                return DDERR_CANNOTATTACHSURFACE;
            }
        }

        /*
         * Check to see if both surfaces are emulated or not
         */
        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
        {
            aasfn = pdrv_lcl->lpDDCB->HELDDSurface.AddAttachedSurface;
            aashalfn = aasfn;
            emulation = TRUE;
        }
        else
        {
            aashalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.AddAttachedSurface;
            aasfn = pdrv_lcl->lpDDCB->HALDDSurface.AddAttachedSurface;
            emulation = FALSE;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * ask driver if it is OK to attach these surfaces
     */
    if( aashalfn != NULL)
    {
        aasd.AddAttachedSurface = aashalfn;
        aasd.lpDD = pdrv_lcl->lpGbl;
        aasd.lpDDSurface = this_lcl;
        aasd.lpSurfAttached = this_attached_lcl;
        DOHALCALL( AddAttachedSurface, aasfn, aasd, rc, emulation );
        if( rc == DDHAL_DRIVER_HANDLED )
        {
            if( aasd.ddRVal != DD_OK )
            {
                LEAVE_DDRAW();
                return aasd.ddRVal;
            }
        }
    }

    // Check to see if we need to add this surface to a flippable chain
    // or if we need to form a new flippable chain.  If the attached
    // surface is already part of a flippable chain, we will attach it but
    // we won't try to form another flippable chain.
    if( !CanBeFlippable( this_lcl, this_attached_lcl ) ||
        ( this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP ) )
    {
        // no flippable chain can be formed.
        // go ahead and attach the surface
        AddAttachedSurface( this_int, this_attached_int, FALSE );
        DPF( 2, "Attached surface, no flippable chain formed" );

        if( this_attached_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
        {
            // This is a mip-map chain. We have added new levels so
            // we need to update the mip-map level count on each
            // level
            DPF( 2, "Updating mip-map level count" );
            UpdateMipMapCount( this_int );
        }
    }
    else
    {
        // These surfaces can be combined to form a flippable chain.
        // Check to see if this surface is already flippable
        if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP ) )
        {
            // neither surface is flippable.
            // attach the surfaces to form a two-member flippable chain
            rc = AddAttachedSurface( this_int, this_attached_int, FALSE );
            if( rc == DD_OK )
            {
                // We are performing this attachment for the app even though it
                // wasn't explicitly requested so make it implicit.
                rc = AddAttachedSurface( this_attached_int, this_int, TRUE );
            }
            if( rc != DD_OK )
            {
                DPF_ERR( "Unable to attach surface, AddAttachedSurface failed.");
                LEAVE_DDRAW();
                return DDERR_CANNOTATTACHSURFACE;
            }

            // now decide which will be front and which will be back
            if( this_lcl->ddsCaps.dwCaps & DDSCAPS_BACKBUFFER )
            {
                // make attached surface the front buffer
                this_attached_lcl->ddsCaps.dwCaps |= DDSCAPS_FRONTBUFFER;
                this_attached_lcl->dwBackBufferCount = 1;
            }
            else
            {
                // make attached surface the back buffer
                this_attached_lcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
                this_lcl->ddsCaps.dwCaps |= DDSCAPS_FRONTBUFFER;
                this_lcl->dwBackBufferCount = 1;
            }
            this_lcl->ddsCaps.dwCaps |= DDSCAPS_FLIP;
            this_attached_lcl->ddsCaps.dwCaps |= DDSCAPS_FLIP;
            DPF( 2, "Attached surface, two surface flippable chain formed" );
        }
        else
        {
            // this_attached will be made part of the flippable chain
            // add this_attached to the flippable chain that the current
            // surface is already part of.  Find the next surface in the
            // chain after the current surface.
            LPDDRAWI_DDRAWSURFACE_INT   next_int;
            LPDDRAWI_DDRAWSURFACE_LCL   next_lcl;
            LPDDRAWI_DDRAWSURFACE_GBL   next;
            LPDDRAWI_DDRAWSURFACE_INT   front_int;
            LPDDRAWI_DDRAWSURFACE_LCL   front_lcl;
            LPDDRAWI_DDRAWSURFACE_GBL   front;
            LPDDRAWI_DDRAWSURFACE_INT   current_int;
            LPDDRAWI_DDRAWSURFACE_LCL   current_lcl;
            LPDDRAWI_DDRAWSURFACE_GBL   current;

            front_int = NULL;
            next_int = FindAttachedFlip( this_int );
            // traverse the flippable chain to find the front buffer
            for(current_int = next_int;
                current_int != NULL;
                current_int = FindAttachedFlip( current_int ) )
            {
                current_lcl = current_int->lpLcl;
                current = current_lcl->lpGbl;
                if( current_lcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER )
                {
                    front_int = current_int;
                    break;
                }
            }
            if( ( next_int == NULL ) || ( front_int == NULL ) )
            {
                DPF_ERR( "Invalid flippable chain, surface not attached" );
                LEAVE_DDRAW();
                return DDERR_CANNOTATTACHSURFACE;
            }
            front_lcl = front_int->lpLcl;
            front = front_lcl->lpGbl;
            next_lcl = next_int->lpLcl;
            next = next_lcl->lpGbl;

            // get rid of any previous front or backbuffer caps.  They will
            // be restored when this surface is again removed from the chain.
            this_attached_lcl->ddsCaps.dwCaps &=
                ~( DDSCAPS_FRONTBUFFER | DDSCAPS_BACKBUFFER );

            // Find out where the new surface fits in the chain
            // if the surface we are attaching to is the back buffer or
            // a plain surface, then the attached surface is
            // a plain surface.  If the surface we are attaching
            // to is a frontbuffer then the attached surface becomes a
            // backbuffer and the previous backbuffer becomes a plain
            // surface.
            if( this_lcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER )
            {
                // this_attached becomes the backbuffer.  The previous
                // backbuffer becomes a plain offscreen surface
                this_attached_lcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
                next_lcl->ddsCaps.dwCaps &= ~DDSCAPS_BACKBUFFER;
            }
            this_attached_lcl->ddsCaps.dwCaps |= DDSCAPS_FLIP;
            front_lcl->dwBackBufferCount++;

            // detach the next surface from the current surface and then
            // insert the attached surface.
            was_implicit = isImplicitAttachment( this_int, next_int );
            /*
             * AddRef next_int so that it doesn't go away when we temporarily
             * disconnect it.
         */
            DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)next_int );
            rc = DeleteOneAttachment( this_int, next_int, FALSE, DOA_DELETEIMPLICIT );
            if( rc == DD_OK )
            {
                rc = AddAttachedSurface( this_int, this_attached_int, FALSE );
                if( rc == DD_OK )
                {
                    // if the attachment of next_int to this_int was implicit, make
                    // the attachment of next_int to this_attached_int implicit.
                    rc = AddAttachedSurface( this_attached_int, next_int, was_implicit );
                }
            }
            DD_Surface_Release( (LPDIRECTDRAWSURFACE)next_int );
            if( rc != DD_OK )
            {
                DPF_ERR( "Unable to attach surface, AddAttachedSurface failed.");
                LEAVE_DDRAW();
                return DDERR_CANNOTATTACHSURFACE;
            }
            DPF( 2, "Attached surface, flippable chain lengthened" );
        }
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_AddAttachedSurface */


#undef DPF_MODNAME
#define DPF_MODNAME "DeleteAttachedSurfaces"

/*
 * DeleteOneAttachment
 *
 * delete a single attachment from  surface.
 * performs flippable chain cleanup if the cleanup parameter is TRUE
 * ASSUMES DRIVER LOCK IS TAKEN!
 *
 * If delete_implicit is TRUE then DeleteOneAttachment will break
 * implicit attachments. Otherwise, it is an error to call this
 * function to delete an implicit attachment.
 */
HRESULT DeleteOneAttachment( LPDDRAWI_DDRAWSURFACE_INT this_int,
		             LPDDRAWI_DDRAWSURFACE_INT pattsurf_int,
                             BOOL cleanup,
			     BOOL delete_implicit )
{
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	pattsurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	pattsurf;
    LPATTACHLIST		curr;
    LPATTACHLIST		last;
    BOOL			addrefed_pattsurf = FALSE;
    BOOL			addrefed_this = FALSE;
    BOOL			addrefed_next = FALSE;
    HRESULT			rc;
    LPDDRAWI_DDRAWSURFACE_INT	next_int;

    DPF( 4, "DeleteOneAttachment: %08lx,%08lx", this_int, pattsurf_int );

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;
    pattsurf_lcl = pattsurf_int->lpLcl;
    pattsurf = pattsurf_lcl->lpGbl;
    if( pattsurf_lcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
    {
        if (dwHelperPid != GetCurrentProcessId())
        {
            if(pattsurf_lcl->lpSurfMore->lpDD_lcl->pD3DIUnknown)
                pattsurf_lcl->lpSurfMore->lpDD_lcl->pFlushD3DDevices2(pattsurf_lcl);
        }
    }

    /*
     * see if specified surface is attached
     */
    curr = this_lcl->lpAttachList;
    last = NULL;
    while( curr != NULL )
    {
	if( curr->lpIAttached == pattsurf_int )
	{
	    break;
	}
	last = curr;
	curr = curr->lpLink;
    }
    if( curr == NULL )
    {
	return DDERR_SURFACENOTATTACHED;
    }

    // don't allow implicitly created attachments to be detached.
    if( ( curr->dwFlags & DDAL_IMPLICIT ) && ( !delete_implicit ) )
    {
	DPF_ERR( "Cannot delete an implicit attachment" );
	return DDERR_CANNOTDETACHSURFACE;
    }

    if( cleanup )
    {
	LPDDRAWI_DDRAWSURFACE_INT	next_next_int;
        LPDDRAWI_DDRAWSURFACE_LCL	next_lcl;
        LPDDRAWI_DDRAWSURFACE_GBL	next;
	LPDDRAWI_DDRAWSURFACE_INT	front_int;
        LPDDRAWI_DDRAWSURFACE_LCL	front_lcl;
        LPDDRAWI_DDRAWSURFACE_GBL	front;
	LPDDRAWI_DDRAWSURFACE_INT	current_int;
	LPDDRAWI_DDRAWSURFACE_LCL	current_lcl;
	LPDDRAWI_DDRAWSURFACE_INT	prev_int;
	BOOL				was_implicit;

	front_int = NULL;
	next_int = FindAttachedFlip( this_int );
	// if next is not equal to pattsurf then this link is not part
	// of a flippable chain.  No other cleanup is necessary.
	if( next_int == pattsurf_int )
	{
	    // find the front buffer in the chain
	    next_int = FindAttachedFlip( pattsurf_int );
	    for(current_int = next_int;
               (current_int != NULL);
	       (current_int = FindAttachedFlip( current_int ) ) )
	    {
		current_lcl = current_int->lpLcl;
		if( current_lcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER )
		{
		    front_int = current_int;
		    front = front_int->lpLcl->lpGbl;
		}
		if( current_int == pattsurf_int )
		{
		    break;
		}
	        prev_int = current_int;
	    }
	    // if the frontbuffer was not found, don't do any cleanup
	    if( ( next_int != NULL ) && ( front_int != NULL ) )
	    {
		next_lcl = next_int->lpLcl;
		next = next_lcl->lpGbl;
		front_lcl = front_int->lpLcl;
		front_lcl->dwBackBufferCount--;
	        if( front_lcl->dwBackBufferCount == 0 )
	        {
		    // this detachment will destroy the flippable chain
		    next_lcl->ddsCaps.dwCaps &=
		        ~(DDSCAPS_FLIP | DDSCAPS_FRONTBUFFER | DDSCAPS_BACKBUFFER );
		    // restore BACKBUFFER CAP if it was originally created that way
		    if( next_lcl->dwFlags & DDRAWISURF_BACKBUFFER )
		    {
		        next_lcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
		    }
		    // restore FRONTBUFFER CAP if it was originally created that way
		    if( next_lcl->dwFlags & DDRAWISURF_FRONTBUFFER )
		    {
		        next_lcl->ddsCaps.dwCaps |= DDSCAPS_FRONTBUFFER;
		    }
		    addrefed_pattsurf = TRUE;
		    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)pattsurf_int );
		    addrefed_this = TRUE;
		    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)this_int );
		    // remove one of the links
		    DeleteOneLink( pattsurf_int, this_int );
	        }
	        else
		{
		    // create a link from the previous surface to the
		    // next surface, bypassing pattsurf
		    was_implicit = isImplicitAttachment( this_int, pattsurf_int );
		    AddAttachedSurface( prev_int, next_int, was_implicit );

		    addrefed_pattsurf = TRUE;
		    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)pattsurf_int );
		    addrefed_this = TRUE;
		    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)this_int );
		    addrefed_next = TRUE;
		    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)next_int );
		    // delete the link from pattsurf to next
		    DeleteOneLink( pattsurf_int, next_int );
		    // pattsurf will now be completely removed from the
		    // flippable chain once the final link is deleted.

		    // this detachment will reduce the flippable chain by one
		    // If pattsurf was a backbuffer, make the next surface
		    // in the chain a backbuffer.
		    if( pattsurf_lcl->ddsCaps.dwCaps & DDSCAPS_BACKBUFFER )
		    {
			next_lcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
		    }
		    // If pattsurf was a frontbuffer, make the next surface
		    // in the chain a frontbuffer, and the next surface a
		    // backbuffer.
		    else if( pattsurf_lcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER )
		    {
		        next_lcl->ddsCaps.dwCaps &= ~DDSCAPS_BACKBUFFER;
			next_lcl->ddsCaps.dwCaps |= DDSCAPS_FRONTBUFFER;
			next_lcl->dwBackBufferCount = front_lcl->dwBackBufferCount;
			next_next_int = FindAttachedFlip( next_int );
			if( next_next_int != NULL)
			{
			    next_next_int->lpLcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
			}
			front_lcl->dwBackBufferCount = 0;
		    }
		}
		// reset the flags on the detached surface to indicate
		// that it is no longer part of a flippable chain.
		pattsurf_lcl->ddsCaps.dwCaps &=
		    ~(DDSCAPS_FLIP | DDSCAPS_FRONTBUFFER | DDSCAPS_BACKBUFFER );
		// restore BACKBUFFER CAP if it was originally created that way
		if( pattsurf_lcl->dwFlags & DDRAWISURF_BACKBUFFER )
		{
		    pattsurf_lcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
		}
		// restore FRONTBUFFER CAP if it was originally created that way
		if( pattsurf_lcl->dwFlags & DDRAWISURF_FRONTBUFFER )
		{
		    pattsurf_lcl->ddsCaps.dwCaps |= DDSCAPS_FRONTBUFFER;
		}
	    }
	}
    }

    /*
     * delete the attached surface
     */
    rc = DeleteOneLink( this_int, pattsurf_int );


    if( addrefed_pattsurf )
	DD_Surface_Release( (LPDIRECTDRAWSURFACE)pattsurf_int);
    if( addrefed_this )
	DD_Surface_Release( (LPDIRECTDRAWSURFACE)this_int );
    if( addrefed_next )
	DD_Surface_Release( (LPDIRECTDRAWSURFACE)next_int );

    return rc;

} /* DeleteOneAttachment */

/*
 * DeleteOneLink
 *
 * delete a single attachment from  surface.
 * ASSUMES DRIVER LOCK IS TAKEN!
 */
HRESULT DeleteOneLink( LPDDRAWI_DDRAWSURFACE_INT this_int,
		       LPDDRAWI_DDRAWSURFACE_INT pattsurf_int )
{
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	pattsurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	pattsurf;
    LPATTACHLIST		curr;
    LPATTACHLIST		last;

    DPF( 4, "DeleteOneLink: %08lx,%08lx", this_int, pattsurf_int );

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;
    pattsurf_lcl = pattsurf_int->lpLcl;
    pattsurf = pattsurf_lcl->lpGbl;

    /*
     * see if specified surface is attached
     */
    curr = this_lcl->lpAttachList;
    last = NULL;
    while( curr != NULL )
    {
	if( curr->lpIAttached == pattsurf_int )
	{
	    break;
	}
	last = curr;
	curr = curr->lpLink;
    }
    if( curr == NULL )
    {
	return DDERR_SURFACENOTATTACHED;
    }

#ifdef WINNT
    /*
     * let the kernel know
     * ...only if there's a kernel ddraw object.
     */
    if ( this_lcl->lpSurfMore->lpDD_lcl->lpGbl->hDD )
    {
        DdUnattachSurface( this_lcl, pattsurf_lcl );
    }
#endif

    /*
     * delete the attached from link
     */
    if( last == NULL )
    {
        this_lcl->lpAttachList = curr->lpLink;
    }
    else
    {
        last->lpLink = curr->lpLink;
    }
    MemFree( curr );

    /*
     * remove the attached to link
     */
    curr = pattsurf_lcl->lpAttachListFrom;
    last = NULL;
    while( curr != NULL )
    {
	if( curr->lpIAttached == this_int )
	{
	    break;
	}
	last = curr;
	curr = curr->lpLink;
    }
    if( curr == NULL )
    {
	return DDERR_SURFACENOTATTACHED;
    }


    /*
     * delete the attached to link
     */
    if( last == NULL )
    {
	pattsurf_lcl->lpAttachListFrom = curr->lpLink;
    }
    else
    {
	last->lpLink = curr->lpLink;
    }

    if( !(curr->dwFlags & DDAL_IMPLICIT))
    {
	DD_Surface_Release( (LPDIRECTDRAWSURFACE)pattsurf_int );
    }

    MemFree( curr );

    return DD_OK;

} /* DeleteOneLink */

/*
 * DD_Surface_DeleteAttachedSurfaces
 */
HRESULT DDAPI DD_Surface_DeleteAttachedSurfaces(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags,
		LPDIRECTDRAWSURFACE lpDDAttachedSurface )
{
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_INT	pattsurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	pattsurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	pattsurf;
    LPATTACHLIST		curr;
    LPATTACHLIST		next;
    HRESULT			ddrval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_DeleteAttachedSurfaces");

    TRY
    {
	/*
	 * validate parameters
	 */
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	pattsurf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDAttachedSurface;
	if( pattsurf_int != NULL )
	{
	    if( !VALID_DIRECTDRAWSURFACE_PTR( pattsurf_int ) )
	    {
		LEAVE_DDRAW();
		return DDERR_INVALIDOBJECT;
	    }
	    pattsurf_lcl = pattsurf_int->lpLcl;
	    pattsurf = pattsurf_lcl->lpGbl;
	    if( SURFACE_LOST( pattsurf_lcl ) )
	    {
		LEAVE_DDRAW();
		return DDERR_SURFACELOST;
	    }
	}
	else
	{
	    pattsurf_lcl = NULL;
	    pattsurf = NULL;
	}

        //
        // If it is an Optimized surface, then continue only if:
        // 1) The current and the attached surface are non-empty
        // 2) Both are texture & mipmap
        // 3) Both have the same optimization caps
        //
        // For now, if the current surface is optimized, quit
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	/*
	 * delete a single attachment
	 */
	if( pattsurf != NULL )
	{
	    ddrval = DeleteOneAttachment( this_int, pattsurf_int, TRUE, DOA_DONTDELETEIMPLICIT );
	    if( ddrval != DD_OK )
	    {
		LEAVE_DDRAW();
		return ddrval;
	    }
	}
	/*
	 * delete all attachments
	 */
	else
	{
	    curr = this_lcl->lpAttachList;
	    while( curr != NULL )
	    {
		next = curr->lpLink;
		ddrval = DeleteOneAttachment( this_int, curr->lpIAttached, TRUE, DOA_DONTDELETEIMPLICIT );
		if( ddrval != DD_OK )
		{
		    LEAVE_DDRAW();
		    return ddrval;
		}
		curr = next;
	    }
	}

	/*
	 * If the surface whose attachments were removed is a mip-map then
	 * it may have lost mip-map levels. Therefore we need to update its
	 * level count.
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
	    UpdateMipMapCount( this_int );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_DeleteAttachedSurfaces */

/*
 * DeleteAttachedSurfaceLists
 *
 * Delete all attached surface lists from a surface
 * Assumes that all parameters coming in are VALID!
 */
void DeleteAttachedSurfaceLists( LPDDRAWI_DDRAWSURFACE_LCL psurf_lcl )
{
    LPATTACHLIST	curr;
    LPATTACHLIST	next;

    curr = psurf_lcl->lpAttachList;
    while( curr != NULL )
    {
	next = curr->lpLink;
	MemFree( curr );
	curr = next;
    }
    curr = psurf_lcl->lpAttachListFrom;
    while( curr != NULL )
    {
	next = curr->lpLink;
	MemFree( curr );
	curr = next;
    }

    psurf_lcl->lpAttachList = NULL;
    psurf_lcl->lpAttachListFrom = NULL;

} /* DeleteAttachedSurfaceLists */

/*
 * DD_Surface_EnumAttachedSurfaces
 */
HRESULT DDAPI DD_Surface_EnumAttachedSurfaces(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPVOID lpContext,
		LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback )
{
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPATTACHLIST		pal;
    DDSURFACEDESC2		dsd;
    DWORD			rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_EnumAttachedSurfaces");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALIDEX_CODE_PTR( lpEnumSurfacesCallback ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	/*
	 * take driver lock just in case callback comes into us
	 */
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * run the attached list, calling the user's fn each time
     */
    pal = this_lcl->lpAttachList;
    while( pal != NULL )
    {
        LPDIRECTDRAWSURFACE4 intReturned = (LPDIRECTDRAWSURFACE4) pal->lpIAttached;

	FillDDSurfaceDesc2( pal->lpAttached, &dsd );
        if (LOWERTHANSURFACE4(this_int))
        {
            dsd.dwSize = sizeof(DDSURFACEDESC);
	    DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) pal->lpIAttached , & IID_IDirectDrawSurface, (void**) &intReturned );
        }
	else if (this_int->lpVtbl == &ddSurface4Callbacks)
	{
	    DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) pal->lpIAttached , & IID_IDirectDrawSurface4, (void**) &intReturned );
	}
        else
        {
	    DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) pal->lpIAttached , & IID_IDirectDrawSurface7, (void**) &intReturned );
        }

	rc = lpEnumSurfacesCallback( (LPDIRECTDRAWSURFACE) intReturned, (LPDDSURFACEDESC) &dsd, lpContext );
	if( rc == 0 )
	{
	    break;
	}
	pal = pal->lpLink;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_EnumAttachedSurfaces */



HRESULT DDAPI Internal_GetAttachedSurface(
    REFIID riid,
    LPDIRECTDRAWSURFACE4 lpDDSurface,
    LPDDSCAPS2 lpDDSCaps,
    LPVOID *lplpDDAttachedSurface)
{
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;

    LPATTACHLIST        pal;
    DWORD           caps;
    DWORD           testcaps;
    DWORD           ucaps;
    DWORD           caps2;
    DWORD           testcaps2;
    DWORD           ucaps2;
    DWORD           caps3;
    DWORD           testcaps3;
    DWORD           ucaps3;
    DWORD           caps4;
    DWORD           testcaps4;
    DWORD           ucaps4;
    BOOL            ok;

    this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;
    *lplpDDAttachedSurface = NULL;
    pdrv = this->lpDD;

    /*
     * look for the surface
     */
    pal = this_lcl->lpAttachList;
    testcaps = lpDDSCaps->dwCaps;
    testcaps2 = lpDDSCaps->dwCaps2;
    testcaps3 = lpDDSCaps->dwCaps3;
    testcaps4 = lpDDSCaps->dwCaps4;
    while( pal != NULL )
    {
        ok = TRUE;
        caps = pal->lpAttached->ddsCaps.dwCaps;
        caps2 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2;
        caps3 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps3;
        caps4 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps4;
        ucaps = caps & testcaps;
        ucaps2 = caps2 & testcaps2;
        ucaps3 = caps3 & testcaps3;
        ucaps4 = caps4 & testcaps4;
        if( ucaps | ucaps2 | ucaps3 | ucaps4 )
        {
            /*
             * there are caps in common, make sure that the caps to test
             * were all there
             */
            if( (ucaps & testcaps) == testcaps &&
                (ucaps2 & testcaps2) == testcaps2 &&
                (ucaps3 & testcaps3) == testcaps3 &&
                (ucaps4 & testcaps4) == testcaps4   )
            {
            }
            else
            {
                ok = FALSE;
            }
        }
        else
        {
            ok = FALSE;
        }


        if( ok )
        {
            /*
             * QI for the appropriate Surface interface and return it
             */
            DD_Surface_QueryInterface(
                (LPDIRECTDRAWSURFACE) pal->lpIAttached,
                riid,
                lplpDDAttachedSurface);

            // DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) pal->lpIAttached );
            // *lplpDDAttachedSurface = (LPDIRECTDRAWSURFACE) pal->lpIAttached;

            return DD_OK;
        }
        pal = pal->lpLink;
    }
    return DDERR_NOTFOUND;

} /* Internal_GetAttachedSurface */

HRESULT WINAPI DDGetAttachedSurfaceLcl(
    LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
    LPDDSCAPS2 lpDDSCaps,
    LPDDRAWI_DDRAWSURFACE_LCL *lplpDDAttachedSurfaceLcl)
{
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    LPDDRAWI_DDRAWSURFACE_GBL   this;

    LPATTACHLIST        pal;
    DWORD           caps;
    DWORD           testcaps;
    DWORD           ucaps;
    DWORD           caps2;
    DWORD           testcaps2;
    DWORD           ucaps2;
    DWORD           caps3;
    DWORD           testcaps3;
    DWORD           ucaps3;
    DWORD           caps4;
    DWORD           testcaps4;
    DWORD           ucaps4;
    BOOL            ok;

    this = this_lcl->lpGbl;
    *lplpDDAttachedSurfaceLcl = NULL;
    pdrv = this->lpDD;

    /*
     * look for the surface
     */
    pal = this_lcl->lpAttachList;
    testcaps = lpDDSCaps->dwCaps;
    testcaps2 = lpDDSCaps->dwCaps2;
    testcaps3 = lpDDSCaps->dwCaps3;
    testcaps4 = lpDDSCaps->dwCaps4;
    while( pal != NULL )
    {
        ok = TRUE;
        caps = pal->lpAttached->ddsCaps.dwCaps;
        caps2 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2;
        caps3 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps3;
        caps4 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps4;
        ucaps = caps & testcaps;
        ucaps2 = caps2 & testcaps2;
        ucaps3 = caps3 & testcaps3;
        ucaps4 = caps4 & testcaps4;
        if( ucaps | ucaps2 | ucaps3 | ucaps4 )
        {
            /*
             * there are caps in common, make sure that the caps to test
             * were all there
             */
            if( (ucaps & testcaps) == testcaps &&
                (ucaps2 & testcaps2) == testcaps2 &&
                (ucaps3 & testcaps3) == testcaps3 &&
                (ucaps4 & testcaps4) == testcaps4   )
            {
            }
            else
            {
                ok = FALSE;
            }
        }
        else
        {
            ok = FALSE;
        }


        if( ok )
        {
            *lplpDDAttachedSurfaceLcl = pal->lpAttached;
            return DD_OK;
        }
        pal = pal->lpLink;
    }
    return DDERR_NOTFOUND;

} /* DDGetAttachedSurfaceLcl */

/*
 * DD_Surface_GetAttachedSurface
 *
 * Search for an attached surface with a cap set.   The caps specified
 * all have to be in the caps of the surface (but the surface can have
 * additional caps)
 */
HRESULT DDAPI DD_Surface_GetAttachedSurface(
        LPDIRECTDRAWSURFACE lpDDSurface,
        LPDDSCAPS lpDDSCaps,
        LPDIRECTDRAWSURFACE FAR * lplpDDAttachedSurface)
{
    HRESULT  hr;
    DDSCAPS2 ddscaps2 = {0,0,0,0};
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetAttachedSurface");

    TRY
    {
        /*
         * Have to duplicate all error checks which come before the lpDDSCaps
         * checks because
         * otherwise we might pass different error returns to the app in error
         * conditions.
         */
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
        if( !VALID_DDSCAPS_PTR( lpDDSCaps ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        ddscaps2.dwCaps = lpDDSCaps->dwCaps;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Invalid DDSCAPS pointer" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    hr = Internal_GetAttachedSurface(
        &IID_IDirectDrawSurface,
        (LPDIRECTDRAWSURFACE4)lpDDSurface,
        &ddscaps2,
        (LPVOID *)lplpDDAttachedSurface
        );

    LEAVE_DDRAW();
    return hr;
}

/*
 * IDirectDrawSurface4::GetAttachedSurface
 */
HRESULT DDAPI DD_Surface_GetAttachedSurface4(
    LPDIRECTDRAWSURFACE4 lpDDSurface,
    LPDDSCAPS2 lpDDSCaps,
    LPDIRECTDRAWSURFACE4 FAR * lplpDDAttachedSurface)
{
    HRESULT  hr;
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    DDSCAPS2    ddsCaps2;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetAttachedSurface4");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
        if( !VALID_DDSCAPS2_PTR( lpDDSCaps ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( lpDDSCaps->dwCaps & ~DDSCAPS_VALID )
        {
            DPF_ERR( "Invalid caps specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDCAPS;
        }
        if( !VALID_PTR_PTR( lplpDDAttachedSurface ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *lplpDDAttachedSurface = NULL;
        ddsCaps2 = *lpDDSCaps;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    DDASSERT(this_int->lpVtbl == &ddSurface4Callbacks);

    /*
     * mistake in DX6: Internal_GetAttachedSurface never tested the extended caps.
     * To avoid regression in DX7, we have to make IGAS respond the same now that it does
     * test the extended caps. We do this by copying the app's caps and zeroing out the
     * extended ones. 
     */
    ddsCaps2.dwCaps2 = ddsCaps2.dwCaps3 = ddsCaps2.dwCaps4 = 0;
    hr = Internal_GetAttachedSurface(
        &IID_IDirectDrawSurface4,
        lpDDSurface,
        &ddsCaps2,
        (LPVOID *)lplpDDAttachedSurface
        );

    LEAVE_DDRAW();
    return hr;

} /* DD_Surface_GetAttachedSurface4 */

/*
 * IDirectDrawSurface7::GetAttachedSurface
 */
HRESULT DDAPI DD_Surface_GetAttachedSurface7(
    LPDIRECTDRAWSURFACE7 lpDDSurface,
    LPDDSCAPS2 lpDDSCaps,
    LPDIRECTDRAWSURFACE7 FAR * lplpDDAttachedSurface)
{
    HRESULT  hr;
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetAttachedSurface7");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
        if( !VALID_DDSCAPS2_PTR( lpDDSCaps ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( lpDDSCaps->dwCaps & ~DDSCAPS_VALID )
        {
            DPF_ERR( "Invalid caps specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDCAPS;
        }
        if( !VALID_PTR_PTR( lplpDDAttachedSurface ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *lplpDDAttachedSurface = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    DDASSERT(this_int->lpVtbl == &ddSurface7Callbacks);

    hr = Internal_GetAttachedSurface(
        &IID_IDirectDrawSurface7,
        (LPDIRECTDRAWSURFACE4)lpDDSurface,
        lpDDSCaps,
        (LPVOID *)lplpDDAttachedSurface
        );

    LEAVE_DDRAW();
    return hr;

} /* DD_Surface_GetAttachedSurface7 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddsblto.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsblto.c
 *  Content:	DirectDraw surface object blt order suport
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27-jan-95	craige	split out of ddsurf.c
 *   31-jan-95	craige	and even more ongoing work...
 *   27-feb-95	craige 	new sync. macros
 *   08-mar-95	craige	new API: AddSurfaceDependency
 *   19-mar-95	craige	use HRESULTs
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-may-95	craige	use driver-level csects only
 *   16-jun-95	craige	new surface structure
 *   21-jun-95	craige	tweaks for new surface structs
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	commented out
 *
 ***************************************************************************/
#include "ddrawpr.h"

#ifdef COMPOSITION
/*
 * DD_SurfaceComposition_GetCompositionOrder
 */
HRESULT DDAPI DD_SurfaceComposition_GetCompositionOrder(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface,
		LPDWORD lpdwCompositionOrder )
{
    LPDDRAWI_DDRAWSURFACE_LCL		thisx;
    LPDDRAWI_DDRAWSURFACE_GBL		this;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_GetCompositionOrder");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    if( !VALID_DWORD_PTR( lpdwCompositionOrder ) )
    {
	return DDERR_INVALIDPARAMS;
    }
    this = thisx->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }

//    *lpdwCompositionOrder = this->dwCompositionOrder;

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_GetCompositionOrder */

/*
 * DD_SurfaceComposition_SetCompositionOrder
 */
HRESULT DDAPI DD_SurfaceComposition_SetCompositionOrder(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface,
		DWORD dwCompositionOrder )
{
    LPDDRAWI_DDRAWSURFACE_LCL		thisx;
    LPDDRAWI_DDRAWSURFACE_GBL		this;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_SetCompositionOrder");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
//    this->dwCompositionOrder = dwCompositionOrder;
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_SetCompositionOrder */

/*
 * DD_SurfaceComposition_DeleteSurfaceDependency
 */
HRESULT DDAPI DD_SurfaceComposition_DeleteSurfaceDependency(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface,
		DWORD dwFlagsForNoGoodReason,
		LPDIRECTDRAWSURFACE lpDDSurface2 )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	this2x;
    LPDDRAWI_DDRAWSURFACE_GBL	this2;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_DeleteSurfaceDependency");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }

    this2x = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface2;
    if( !VALID_DIRECTDRAWSURFACE_PTR( this2x ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    this2 = this2x->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    if( SURFACE_LOST( this2x ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_DeleteSurfaceDependency */

/*
 * DD_SurfaceComposition_DestLock
 */
HRESULT DDAPI DD_SurfaceComposition_DestLock(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_DestLock");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_DestLock */

/*
 * DD_SurfaceComposition_DestUnlock
 */
HRESULT DDAPI DD_SurfaceComposition_DestUnlock(
	    LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_DestUnlock");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_DestUnlock */

/*
 * DD_SurfaceComposition_EnumSurfaceDependencies
 */
HRESULT DDAPI DD_SurfaceComposition_EnumSurfaceDependencies(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface,
		LPVOID lpContext,
		LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_EnumSurfaceDependencies");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    if( !VALID_CODE_PTR( lpEnumSurfacesCallback ) )
    {
	return DDERR_INVALIDPARAMS;
    }
    this = thisx->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_EnumSurfaceDependencies */

/*
 * DD_SurfaceComposition_SetSurfaceDependency
 */
HRESULT DDAPI DD_SurfaceComposition_SetSurfaceDependency(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface,
		LPDIRECTDRAWSURFACE lpDDSurface2 )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	this2x;
    LPDDRAWI_DDRAWSURFACE_GBL	this2;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_SetSurfaceDependency");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this2x = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface2;
    if( !VALID_DIRECTDRAWSURFACE_PTR( this2x ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    ENTER_DDRAW();
    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    this2 = this2x->lpGbl;
    if( SURFACE_LOST( this2x ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_SetSurfaceDependency */

/*
 * DD_SurfaceComposition_AddSurfaceDependency
 */
HRESULT DDAPI DD_SurfaceComposition_AddSurfaceDependency(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDSurface,
		LPDIRECTDRAWSURFACE lpDDSurfaceDep )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_LCL	this_depx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_GBL	this_dep;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_AddSurfaceDependency");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    this_depx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurfaceDep;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    if( !VALID_DIRECTDRAWSURFACE_PTR( this_depx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    this_dep = this_depx->lpGbl;
    ENTER_DDRAW();

    if( SURFACE_LOST( thisx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    if( SURFACE_LOST( this_depx ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_AddSurfaceDependency */

#undef DPF_MODNAME
#define DPF_MODNAME	"Compose"

/*
 * DD_SurfaceComposition_Compose
 */
HRESULT DDAPI DD_SurfaceComposition_Compose(
		LPDIRECTDRAWSURFACECOMPOSITION lpDDDestSurface,
		LPRECT lpDestRect,
		LPDIRECTDRAWSURFACE lpDDSrcSurface,
		LPRECT lpSrcRect,
		DWORD dwFlags,
		LPDDCOMPOSEFX lpDDComposeFX )
{
    LPDDRAWI_DIRECTDRAW		pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL	this_srcx;
    LPDDRAWI_DDRAWSURFACE_LCL	this_destx;
    LPDDRAWI_DDRAWSURFACE_GBL	this_src;
    LPDDRAWI_DDRAWSURFACE_GBL	this_dest;

    DPF(2,A,"ENTERAPI: DD_SurfaceComposition_Compose");

    this_destx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDDestSurface;
    this_srcx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSrcSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( this_destx ) )
    {
	DPF_ERR( "invalid dest specified") ;
	return DDERR_INVALIDOBJECT;
    }
    this_dest = this_destx->lpGbl;
    pdrv = this_dest->lpDD;
    ENTER_DDRAW();
    if( this_srcx != NULL )
    {
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_srcx ) )
	{
	    DPF_ERR( "Invalid source specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_src = this_srcx->lpGbl;
	if( SURFACE_LOST( this_srcx ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
    } 
    else
    {
	this_src = NULL;
    }

    LEAVE_DDRAW();

    return DDERR_UNSUPPORTED;

} /* DD_SurfaceComposition_Compose */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddsstrm.c ===
/*========================================================================== 
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsstrm.c
 *  Content: 	DirectDraw surface streaming methods
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   19-jun-95	craige	split out of ddsurf; fleshed out
 *   21-jun-95	craige	added lock/unlock; split out clipping
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *
 ***************************************************************************/
#include "ddrawpr.h"

#if 0
#undef DPF_MODNAME
#define DPF_MODNAME "SetNotificationCallback"

/*
 * DD_Surface_SetNotificationCallback
 */
HRESULT DDAPI DD_SurfaceStreaming_SetNotificationCallback(
		LPDIRECTDRAWSURFACESTREAMING lpDDSurface,
		DWORD dwFlags,
		LPSURFACESTREAMINGCALLBACK lpCallback )
{
    LPDDRAWI_DDRAWSURFACE_GBLSTREAMING	thiss;
    LPDDRAWI_DDRAWSURFACE_LCL		thisx;
    LPDDRAWI_DDRAWSURFACE_GBL		this;
    LPDDRAWI_DIRECTDRAW			pdrv;

    DPF(2,A,"ENTERAPI: DD_SurfaceStreaming_SetNotificationCallback");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    if( lpCallback != NULL )
    {
	if( !VALID_CODE_PTR( lpCallback ) )
	{
	    DPF_ERR( "Invalid Streaming callback ptr" );
	    return DDERR_INVALIDPARAMS;
	}
    }
    thiss = (LPDDRAWI_DDRAWSURFACE_GBLSTREAMING) thisx;
    this = thisx->lpGbl;
    pdrv = this->lpDD;
    ENTER_DDRAW();
    if( SURFACE_LOST( this ) )
    {
	LEAVE_DDRAW();
	return DDERR_SURFACELOST;
    }
    thiss->lpCallback = lpCallback;

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceStreaming_SetNotificationCallback */

/*
 * DD_SurfaceStreaming_Lock
 *
 * Allows streaming access to a surface.
 */
HRESULT DDAPI DD_SurfaceStreaming_Lock(
		LPDIRECTDRAWSURFACESTREAMING lpDDSurface,
		LPRECT lpDestRect,
		LPDDSURFACEDESC lpDDSurfaceDesc,
		DWORD dwFlagsForNoGoodReason,
		HANDLE hEvent )
{
    LPDDRAWI_DIRECTDRAW		pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    DPF(2,A,"ENTERAPI: DD_SurfaceStreaming_Lock");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    if( SURFACE_LOST( this ) )
    {
	return DDERR_SURFACELOST;
    }
    if( !VALID_DDSURFACEDESC_PTR( lpDDSurfaceDesc ) )
    {
	return DDERR_INVALIDPARAMS;
    }
    pdrv = this->lpDD;
    ENTER_DDRAW();

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceStreaming_Lock */

#undef DPF_MODNAME
#define DPF_MODNAME	"Unlock"

/*
 * DD_SurfaceStreaming_Unlock
 *
 * Done accessing a streaming surface.
 */
HRESULT DDAPI DD_SurfaceStreaming_Unlock(
		LPDIRECTDRAWSURFACESTREAMING lpDDSurface,
		LPVOID lpSurfaceData )
{
    LPDDRAWI_DDRAWSURFACE_LCL	thisx;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW		pdrv;

    DPF(2,A,"ENTERAPI: DD_SurfaceStreaming_Unlock");

    thisx = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
    if( !VALID_DIRECTDRAWSURFACE_PTR( thisx ) )
    {
	return DDERR_INVALIDOBJECT;
    }
    this = thisx->lpGbl;
    if( SURFACE_LOST( this ) )
    {
	return DDERR_SURFACELOST;
    }

    /*
     * take driver lock
     */
    pdrv = this->lpDD;
    ENTER_DDRAW();

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_SurfaceStreaming_Unlock */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddstream.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddstream.cpp
 *  Content:	DirectDraw surface file I/O
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   30-sep-97  jeffno  Original implementation
 *
 ***************************************************************************/

extern "C"
{
    #include "ddrawpr.h"
}

#include <ImgUtil.H>
#include "decoder.h"

/*
 * This routine takes a source surface freshly loaded from some file, and transfers
 * the bits to some target surface. Palette will be transferred also, if set.
 * dwFlags are as defined for CreateSurfaceFromFile.
 */
HRESULT TransferBitsToTarget(
    LPDIRECTDRAWSURFACE lpDDSource,
    LPDIRECTDRAWSURFACE4 lpDDSTarget,
    LPDDSURFACEDESC2 pDDSD,
    DWORD dwFlags)
{
    HRESULT                 hr =DD_OK;
    DDSURFACEDESC           ddsd;
    RECT                    rDest;
    LPDIRECTDRAWSURFACE4    lpDDSource4;

    /*
     * We need to transfer a palette to the target surface if required.
     * Don't do it if the app doesn't want a palette. Don't do it if there's
     * no palette in the working surface.
     */
    if ( (dwFlags & DDLS_IGNOREPALETTE) == 0)
    {
        LPDIRECTDRAWPALETTE pPal = NULL;
        hr = lpDDSource->GetPalette(&pPal);
        if (SUCCEEDED(hr))
        {
            /*
             * If the target surface isn't palettized, this will fail.
             * That's OK.
             */
            lpDDSTarget->SetPalette((LPDIRECTDRAWPALETTE2)pPal);
            pPal->Release();
        }
    }

    /*
     * If we aren't stretching or we're maintaining aspect ratio, then there's the possibility
     * of some of the target surface's pixels not being filled. Fill them with
     * phys color zero.
     * I threw in bilinear as well, because the current definition samples the target
     * even when full stretch.
     */
    if ( (dwFlags & (DDLS_MAINTAINASPECTRATIO|DDLS_BILINEARFILTER)) || ((dwFlags & DDLS_STRETCHTOFIT)==0) )
    {
        DDBLTFX ddbltfx;
        ddbltfx.dwSize = sizeof(ddbltfx);
        ddbltfx.dwFillColor = 0;
        /*
         * Ignore the error code. The nicest thing is to keep going anyway
         */
        lpDDSTarget->Blt(NULL,NULL,NULL,DDBLT_COLORFILL,&ddbltfx);
    }

    /*
     * Note that we always shrink the image to fit if necessary.
     * We never take the smaller subrect of the source when the passed-in
     * size is smaller than the image
     */

    /*
     * Set dest rect to the size of the image
     * Calling a v1 surface, so better pass proper size.
     */
    ddsd.dwSize =sizeof(DDSURFACEDESC);
    hr = lpDDSource->GetSurfaceDesc((LPDDSURFACEDESC)&ddsd);
    DDASSERT(SUCCEEDED(hr));
    SetRect(&rDest,0,0,ddsd.dwWidth,ddsd.dwHeight);

    if (dwFlags & DDLS_STRETCHTOFIT)
    {
        /*
         * Override the dest rect to the size passed in
         */
        SetRect(&rDest,0,0,pDDSD->dwWidth,pDDSD->dwHeight);
        if (dwFlags & DDLS_MAINTAINASPECTRATIO)
        {
            /*
             * Back off if necessary to maintain aspect ratio.
             * This calculates the dest width we need to maintain AR
             */
            DWORD dwProperWidth = ddsd.dwWidth*pDDSD->dwHeight/ddsd.dwHeight;
            if (dwProperWidth > pDDSD->dwWidth)
            {
                SetRect(&rDest,0,0,pDDSD->dwWidth,ddsd.dwHeight*pDDSD->dwWidth/ddsd.dwWidth);
            }
            else if (dwProperWidth < pDDSD->dwWidth)
            {
                SetRect(&rDest,0,0,dwProperWidth,pDDSD->dwHeight);
            }
        }

        DDASSERT(rDest.right <= (int) pDDSD->dwWidth);
        DDASSERT(rDest.bottom <= (int) pDDSD->dwHeight);
    }
    else
    {
        /*
         * If we're shrinking, we'll just stretch anyway. The alternative is to take
         * a smaller central subrect of the source image. That seems kinda useless.
         */
        if (pDDSD)
        {
            if (pDDSD->dwWidth < ddsd.dwWidth)
            {
                rDest.left=0;
                rDest.right = pDDSD->dwWidth;
            }
            if (pDDSD->dwHeight < ddsd.dwHeight)
            {
                rDest.top=0;
                rDest.bottom = pDDSD->dwHeight;
            }
        }
    }

    /*
     * Add space above/below to center the image in the dest
     */
    if (dwFlags & DDLS_CENTER)
    {
        OffsetRect(&rDest, (pDDSD->dwWidth - rDest.right)/2, (pDDSD->dwHeight - rDest.bottom)/2);
    }

    hr = lpDDSource->QueryInterface(IID_IDirectDrawSurface4, (void**) &lpDDSource4);
    if (SUCCEEDED(hr))
    {
        hr = lpDDSTarget->AlphaBlt(
            &rDest,
            lpDDSource4,
            NULL,
            ((dwFlags & DDLS_BILINEARFILTER)?DDABLT_BILINEARFILTER:0)|DDABLT_WAIT,
            NULL);
        if (FAILED(hr))
        {
            /*
             * ATTENTION: Sort of. At the moment, AlphaBlt refuses to blt to a palette-indexed surface.
             * We'll just try blt as a backup
             */
            hr = lpDDSTarget->Blt(
                &rDest,
                lpDDSource4,
                NULL,
                DDBLT_WAIT,
                NULL);
        }

        if (FAILED(hr))
        {
            DPF_ERR("Could not blt from temporary surface to target surface!");
        }

        lpDDSource4->Release();
    }
    return hr;
}

HRESULT CreateOrLoadSurfaceFromStream( LPDIRECTDRAW4 lpDD, IStream *pSource, LPDDSURFACEDESC2 pDDSD, DWORD dwFlags, LPDIRECTDRAWSURFACE4 * ppSurface, IUnknown * pUnkOuter)
{

    LPDDRAWI_DIRECTDRAW_INT		this_int;
    // validate arguments
    TRY
    {
        if( !VALID_PTR_PTR(ppSurface ) )
        {
            DPF_ERR("You must supply a valid surface pointer");
            return DDERR_INVALIDPARAMS;
        }

        *ppSurface = NULL;

	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
            DPF_ERR("Bad DirectDraw pointer");
	    return DDERR_INVALIDOBJECT;
	}

        if( !pSource )
        {
            DPF_ERR("You must supply a valid stream pointer");
            return DDERR_INVALIDPARAMS;
        }

        /*
         * Validate flags
         */
        if (dwFlags & ~DDLS_VALID)
        {
            DPF_ERR("Invalid flags");
            return DDERR_INVALIDPARAMS;
        }

        if (dwFlags & ~DDLS_VALID)
        {
            DPF_ERR("Invalid flags");
            return DDERR_INVALIDPARAMS;
        }

        //ATTENTION: DDLS_MERGEPALETTE isn't implemented. Implement it when the palette 2 interface goes in.
        if ( (dwFlags & (DDLS_IGNOREPALETTE|DDLS_MERGEPALETTE)) == (DDLS_IGNOREPALETTE|DDLS_MERGEPALETTE) )
        {
            DPF_ERR("Can only specify one of DDLS_IGNOREPALETTE or DDLS_MERGEPALETTE");
            return DDERR_INVALIDPARAMS;
        }

        if ( (dwFlags & DDLS_STRETCHTOFIT) || (dwFlags & DDLS_CENTER) )
        {
            if (!pDDSD)
            {
                DPF_ERR("Can't specify DDLS_STRETCHTOFIT or DDLS_CENTER without a DDSURFACEDESC2 with valid dwWidth and dwHeight");
                return DDERR_INVALIDPARAMS;
            }
            if ( ( (pDDSD->dwFlags & (DDSD_WIDTH|DDSD_HEIGHT)) == 0) || !pDDSD->dwWidth || !pDDSD->dwHeight )
            {
                DPF_ERR("Can't specify DDLS_STRETCHTOFIT or DDLS_CENTER without a DDSURFACEDESC2 with valid dwWidth and dwHeight");
                return DDERR_INVALIDPARAMS;
            }
        }

        if (! (dwFlags & DDLS_STRETCHTOFIT) )
        {
            if (dwFlags & (DDLS_BILINEARFILTER|DDLS_MAINTAINASPECTRATIO))
            {
                DPF_ERR("DDLS_STRETCHTOFIT required for DDLS_BILINEARFILTER or DDLS_MAINTAINASPECTRATIO");
                return DDERR_INVALIDPARAMS;
            }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	return DDERR_INVALIDPARAMS;
    }



    HRESULT hr = DD_OK;
    FILTERINFO ImgInfo;
    CImageDecodeEventSink EventSink;

    ZeroMemory(&ImgInfo, sizeof(ImgInfo));
    /*
     * Default to device's bit depth
     * This is no longer necessary. We always create a staging surface in the filter's
     * desired format.
     */
    //ImgInfo._colorMode = this_int->lpLcl->lpGbl->vmiData.ddpfDisplay.dwRGBBitCount;

    EventSink.Init(&ImgInfo);
    typedef HRESULT (*funcptr)(IStream*, IMapMIMEToCLSID*, IImageDecodeEventSink*);
    funcptr pfnDecodeImage;
    //EventSink->AddRef();
    EventSink.SetDDraw( lpDD );

    HINSTANCE hLibInst = LoadLibrary( "ImgUtil.dll" );
    if( hLibInst )
    {
        pfnDecodeImage = (funcptr) GetProcAddress(hLibInst, "DecodeImage");
        if( pfnDecodeImage )
        {
            hr = (*pfnDecodeImage)( pSource, NULL, (IImageDecodeEventSink *)&EventSink );
        }
        else
        {
            DPF_ERR( "GetProcAddress failure for DecodeImage in ImgUtil.dll" );
            hr = DDERR_UNSUPPORTED;
        }
        FreeLibrary( hLibInst );
    }
    else
    {
        DPF_ERR( "LoadLibrary failure on ImgUtil.dll" );
        hr = DDERR_UNSUPPORTED;
    }

    if( SUCCEEDED( hr ) )
    {
        LPDIRECTDRAWSURFACE lpDDS = EventSink.m_pFilter->m_pDDrawSurface;

        if (lpDDS)
        {
            DDSURFACEDESC2  ddsd;
            DDSURFACEDESC ddsdWorking;

            ZeroMemory(&ddsdWorking,sizeof(ddsdWorking));
            ddsdWorking.dwSize = sizeof(ddsdWorking);

            ZeroMemory(&ddsd,sizeof(ddsd));
            ddsd.dwSize = sizeof(ddsd);

            /*
             * The decode succeeded, so now marshal the bits into the requested surface type
             */
            if (pDDSD)
            {
                /*
                 * App cares about at least some of the parameters of the target surface.
                 * We'll take what they give us and potentially fill in some more.
                 */
                ddsd = *pDDSD;
            }

            /*
             * We may need some data from the original loaded surface.
             * Ignore the return code. It's better just to carry on.
             */
            hr = lpDDS->GetSurfaceDesc(&ddsdWorking);

            if ( (ddsd.dwFlags & (DDSD_WIDTH|DDSD_HEIGHT)) == 0 )
            {
                /*
                 * App doesn't care what size the surface is, so we'll setup
                 * the size for them.
                 */
                ddsd.dwFlags |= DDSD_WIDTH|DDSD_HEIGHT;
                ddsd.dwWidth = ddsdWorking.dwWidth;
                ddsd.dwHeight = ddsdWorking.dwHeight;
            }

            if ( (ddsd.dwFlags & DDSD_CAPS) == 0)
            {
                /*
                 * App doesn't care about surface caps. We'll give them offscreen plain
                 */
                ddsd.dwFlags |= DDSD_CAPS;
                ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
                ddsd.ddsCaps.dwCaps2 = 0;
                ddsd.ddsCaps.dwCaps3 = 0;
                ddsd.ddsCaps.dwCaps4 = 0;
            }

            if ( (ddsd.dwFlags & DDSD_PIXELFORMAT) == 0)
            {
                /*
                 * If the app didn't specify a pixel format, then we will return
                 * the original pixel format as decoded by the decode filter.
                 * This should be a close approximation of the format of the original
                 * file. Note that this stipulation could mean that the CreateSurface
                 * will dump the surface in sysmem. It's good for our routine to
                 * have the same semantics as CreateSurface.
                 */
                ddsd.dwFlags |= DDSD_PIXELFORMAT;
                ddsd.ddpfPixelFormat = ddsdWorking.ddpfPixelFormat;
            }

            /*
             * Could we avoid creating a target surface and doing the blt altogether?
             * It wouldn't really buy much. If the app didn't specify a memory type, then
             * we probe to see if we can create a vidmem version by calling createsurface.
             * If we get a vidmem back, then we copy the bits and use it. If we get a sysmem
             * back then we could optimize that case by not doing the blt to get the
             * data into the target surface and returning the working surface directly.
             * One tiny disadvantage would be that the target surface would be explicit
             * sysmem, whereas the normal createsurface semantics would make that surface
             * an implicit sysmem surface.
             */

            /*
             * We don't do the create surface if a surface is passed in (as denoted
             * by *ppSurface being non-null)
             */
            if(SUCCEEDED(hr) && (NULL == (*ppSurface)) )
            {
                hr = lpDD->CreateSurface(&ddsd, ppSurface, pUnkOuter);
            }

            /*
             * Now blt the working surface to whatever the target was supposed to be...
             * Note this routine may transfer a reference to a palette as well.
             */
            if(SUCCEEDED(hr))
            {
                hr = TransferBitsToTarget(lpDDS, *ppSurface, pDDSD, dwFlags);
            }
            else
            {
                DPF_ERR("Create surface failed!");
            }
        }
        else
        {
            /*
             * Decode returned a NULL ddraw surface, even tho DecodeImage returned ok
             */
            hr = DDERR_INVALIDSTREAM;
        }
    }

//    pEventSink->Release();

    return hr;
} /* DD_CreateSurfaceFromFile */

extern "C" HRESULT DDAPI DD_CreateSurfaceFromStream(
    LPDIRECTDRAW4 lpDD,
    IStream *pSource,
    LPDDSURFACEDESC2 pDDSD,
    DWORD dwFlags,
    LPDIRECTDRAWSURFACE4 * ppSurface,
    IUnknown * pUnkOuter)
{
    *ppSurface = 0;
    return CreateOrLoadSurfaceFromStream(lpDD, pSource, pDDSD, dwFlags, ppSurface, pUnkOuter);
}

extern "C" HRESULT DDAPI DD_CreateSurfaceFromFile( LPDIRECTDRAW4 lpDD, BSTR DisplayName, LPDDSURFACEDESC2 pDDSD, DWORD dwFlags, LPDIRECTDRAWSURFACE4 * ppSurface, IUnknown * pUnkOuter)
{
    lpDD;
    pDDSD;
    pUnkOuter;

    // validate arguments
    if( !DisplayName || !ppSurface )
    {
        DPF_ERR("You must supply a valid filename and surface pointer");
        return E_POINTER;
    }

    if (FAILED(CoInitialize(NULL)))
    {
        DPF_ERR("Failed CoInitialize");
        return DDERR_UNSUPPORTED;
    }

    IMoniker *pmk;
    IBindCtx *pbctx;
    IStream *pStream;
    HRESULT hr = CreateURLMoniker(NULL, DisplayName, &pmk);
    if( SUCCEEDED( hr ) )
    {
        hr = CreateBindCtx(0, &pbctx);
        if( SUCCEEDED( hr ) )
        {
	    hr = pmk->BindToStorage(pbctx, NULL, IID_IStream, (void **)&pStream);
            if( SUCCEEDED( hr ) )
            {
                hr = DD_CreateSurfaceFromStream( lpDD, pStream, pDDSD, dwFlags, ppSurface ,pUnkOuter );
                pStream->Release();
            }
            else
            {
                DPF_ERR("Could not BindToStorage");
                if (hr == INET_E_UNKNOWN_PROTOCOL)
                    DPF_ERR("Fully qualified path name is required");
                if (hr == INET_E_RESOURCE_NOT_FOUND)
                    DPF_ERR("Resource not found. Fully qualified path name is required");
            }
            pbctx->Release();
        }
        else
        {
            DPF_ERR("Could not CreateBindCtx");
        }
        pmk->Release();
    }
    else
    {
        DPF_ERR("Could not CreateURLMoniker");
    }
        

    return hr;

    return DD_OK;
}

/*
 * Persistence interfaces
 * These methods read and write streams of the following form:
 *
 *   Element	                        Description
 *   -------------------------------------------------------------------------------------------------
 *   Type           Name
 *
 *   GUID           tag	                GUID_DirectDrawSurfaceStream. Tags the stream as a surface stream
 *   DWORD          dwWidth	        Width in pixels of the image data
 *   DWORD          dwHeight	        Height in pixels of the image data
 *   DDPIXELFORMAT  Format              Format of image data
 *   DWORD          dwPaletteCaps       Palette caps. Zero if no palette.
 *   PALETTESTREAM  PaletteData         This field is only present if the dwPaletteCaps field is non-zero
 *   GUID           CompressionFormat   This field is only present if one of the DDPF_OPT flags is specified in Format
 *   DWORD          dwDataSize	        Number of bytes that follow
 *   BYTE[]         SurfaceData	        dwDataSize bytes of surface data
 *   PRIVATEDATA    PrivateSurfaceData	
 *
 *
 *   The PALETTESTREAM stream element has the following format:
 *
 *   Element	                        Description
 *   -------------------------------------------------------------------------------------------------
 *   Type           Name
 *   GUID           tag	                GUID_DirectDrawPaletteeStream. Tags the stream as a palette stream
 *   DWORD          dwPaletteFlags      Palette flags made up of DDPCAPS bits.
 *   PALETTEENTRY[] PaletteEntries      The number of palette entries specified by the flags in dwPaletteFlags.
 *   PRIVATEDATA    PrivatePaletteData  Private palette data.
 *
 *
 *   The PRIVATEDATA stream element has the following format:
 *
 *   Element	                    Description
 *   -------------------------------------------------------------------------------------------------
 *   Type       Name
 *
 *   DWORD dwPrivateDataCount	    The number of private data blocks which follow
 *     GUID GUIDTag	            Tag for this block of private data, as specified by IDDS4:SetClientData
 *     DWORD dwPrivateSize	    Number of bytes of private data in this block
 *     BYTE[] PrivateData	    dwPrivateSize bytes of private data
 *
 * Note private data that are of pointer type (i.e. point to a user-allocated data block) will
 * NOT be saved by these methods.
 *
 */

template<class Object> HRESULT InternalReadPrivateData(
    IStream * pStrm,
    Object * lpObject)
{
    HRESULT ddrval;
    DWORD   dwCount;

    ddrval = pStrm->Read((void*) & dwCount, sizeof(DWORD), NULL);
    if (FAILED(ddrval))
    {
        DPF_ERR("Stream read failed on private data count");
        return ddrval;
    }

    for(;dwCount;dwCount--)
    {
        GUID  guid;
        DWORD cbData;
        LPVOID pData;

        ddrval = pStrm->Read((void*) & guid, sizeof(guid), NULL);
        if (FAILED(ddrval))
        {
            DPF_ERR("Stream read failed on private data GUID");
            return ddrval;
        }

        ddrval = pStrm->Read((void*) & cbData, sizeof(cbData), NULL);
        if (FAILED(ddrval))
        {
            DPF_ERR("Stream read failed on private data GUID");
            return ddrval;
        }

        pData = MemAlloc(cbData);
        if (pData)
        {
            ddrval = pStrm->Read((void*) pData, cbData, NULL);
            if (FAILED(ddrval))
            {
                DPF_ERR("Stream read failed on private data GUID");
                return ddrval;
            }

            ddrval = lpObject->SetPrivateData(guid, pData, cbData, 0);

            MemFree(pData);

            if (FAILED(ddrval))
            {
                DPF_ERR("Could not set private data");
                return ddrval;
            }
        }
        else
        {
            DPF_ERR("Couln't alloc enough space for private data");
            ddrval = DDERR_OUTOFMEMORY;
            return ddrval;
        }
    }
    return ddrval;
}

HRESULT myWriteClassStm(IStream * pStrm, LPGUID pGUID)
{
    return pStrm->Write(pGUID, sizeof(*pGUID),NULL);
}

HRESULT myReadClassStm(IStream * pStrm, LPGUID pGUID)
{
    return pStrm->Read(pGUID, sizeof(*pGUID),NULL);
}

/*
 * Be sure to call ENTER_DDRAW before and LEAVE_DDRAW after
 * calling this function!
 */
HRESULT InternalWritePrivateData(
    IStream * pStrm,
    LPPRIVATEDATANODE pPrivateDataHead)
{
    HRESULT ddrval;
    DWORD dwCount = 0;
    LPPRIVATEDATANODE pPrivateData = pPrivateDataHead;

    while(1)
    {
        while(pPrivateData)
        {
            if (pPrivateData->dwFlags == 0)
            {
                dwCount++;
            }
            pPrivateData = pPrivateData->pNext;
        }

        ddrval = pStrm->Write((void*) & dwCount, sizeof(dwCount), NULL);
        if (FAILED(ddrval))
        {
            DPF_ERR("Stream write failed on count of private data");
            break;
        }

        pPrivateData = pPrivateDataHead;
        while(pPrivateData)
        {
            if (pPrivateData->dwFlags == 0)
            {
                ddrval = myWriteClassStm(pStrm, &(pPrivateData->guid));
                if (SUCCEEDED(ddrval))
                {
                    ddrval = pStrm->Write((void*) &(pPrivateData->cbData), sizeof(DWORD), NULL);
                    if (SUCCEEDED(ddrval))
                    {
                        ddrval = pStrm->Write((void*) pPrivateData->pData, pPrivateData->cbData, NULL);
                        if (FAILED(ddrval))
                            break;
                    }
                    else
                        break;
                }
                else
                    break;
            }
            pPrivateData = pPrivateData->pNext;
        }

        break;
    }

    return ddrval;
}

extern "C" HRESULT DDAPI DD_Surface_Persist_GetClassID(LPDIRECTDRAWSURFACE lpDDS, CLSID * pClassID)
{
    TRY
    {
        memcpy(pClassID, & GUID_DirectDrawSurfaceStream, sizeof(*pClassID));
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered copying GUID" );
	return DDERR_INVALIDPARAMS;
    }
    return DD_OK;
}

extern "C" HRESULT DDAPI DD_Surface_PStream_IsDirty(LPDIRECTDRAWSURFACE lpDDS)
{
    LPDDRAWI_DDRAWSURFACE_INT	        this_int;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE	this_more;

    ENTER_DDRAW();

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDS;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

        this_more = GET_LPDDRAWSURFACE_GBL_MORE(this_int->lpLcl->lpGbl);

        if ( (this_more->dwSaveStamp == 0 ) ||
             (this_more->dwContentsStamp != this_more->dwSaveStamp) )
        {
	    LEAVE_DDRAW();
	    return S_OK;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered checking dirty" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return S_FALSE;
}

extern "C" HRESULT DDAPI DD_Surface_PStream_Load(LPDIRECTDRAWSURFACE lpDDS, IStream * pStrm)
{
    DDSURFACEDESC2              ddsd;
    HRESULT                     ddrval;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDIRECTDRAWSURFACE4        lpDDS1 = NULL;

    if (!VALID_PTR(pStrm,sizeof(*pStrm)))
    {
        DPF_ERR("Bad stream pointer");
        return DDERR_INVALIDPARAMS;
    }

    this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDS;
    if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
    {
	return DDERR_INVALIDOBJECT;
    }

    /*
     * DO THE QI for DDOPTSURF HERE
     * and appropriate loading
     */

    ddrval = lpDDS->QueryInterface(IID_IDirectDrawSurface4, (void**) & lpDDS1);
    if (SUCCEEDED(ddrval))
    {
        ZeroMemory(&ddsd,sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);

        ddrval = lpDDS1->Lock(NULL, &ddsd,DDLOCK_WAIT,NULL);

        if (SUCCEEDED(ddrval))
        {
            if (ddsd.ddpfPixelFormat.dwFlags & (DDPF_FOURCC) )
            {
                DPF_ERR("The surface isn't streamable. Bad pixel format");
                ddrval = DDERR_INVALIDPIXELFORMAT;
            }
            else
            {
                while(SUCCEEDED(ddrval)) //a fake try-except while
                {
                    DWORD y;
                    DWORD dwStreamWidth,dwStreamHeight;
                    DWORD dwPalCaps;
                    DDPIXELFORMAT ddpfStream;
                    CLSID clsid;

                    /*
                     * First attempt to read stream format GUID
                     */
                    ddrval = myReadClassStm(pStrm, & clsid);

                    //don't bother to check return code, since the following test will fail in that case
                    if (!IsEqualGUID(clsid,  GUID_DirectDrawSurfaceStream))
                    {
                        DPF_ERR("The stream does not contain a directdraw surface stream");
                        ddrval = DDERR_INVALIDSTREAM;
                        break;
                    }

                    /*
                     * Get image format from stream
                     */
                    ddrval = pStrm->Read((void*) & dwStreamWidth, sizeof(dwStreamWidth), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream read failed on width");
                        break;
                    }

                    ddrval = pStrm->Read((void*) & dwStreamHeight, sizeof(dwStreamHeight), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream read failed on height");
                        break;
                    }

                    ddrval = pStrm->Read((void*) & ddpfStream, sizeof(ddpfStream), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream read failed on pixel format");
                        break;
                    }

                    if (!doPixelFormatsMatch(&ddpfStream, &ddsd.ddpfPixelFormat))
                    {
                        DPF_ERR("Stream pixel format does not match that of surface!");
                        break;
                    }

                    ddrval = pStrm->Read((void*) & dwPalCaps, sizeof(dwPalCaps), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream read failed on palette caps");
                        break;
                    }


                    /*
                     * If a palette exists, then either create one or grab the palette from the surface
                     * and try to stream its data in too.
                     */
                    if (dwPalCaps)
                    {
                        LPDIRECTDRAWPALETTE2 lpDDPal;
                        ddrval = lpDDS1->GetPalette(& lpDDPal);
                        if (ddrval == DDERR_NOPALETTEATTACHED)
                        {
                            PALETTEENTRY pe[256]; //just a dummy
                            ddrval = DD_CreatePalette(
                                (IDirectDraw*)(this_int->lpLcl->lpGbl) ,
                                dwPalCaps,
                                pe,
                                (LPDIRECTDRAWPALETTE*)&lpDDPal,
                                NULL);
                            if (FAILED(ddrval))
                            {
                                DPF_ERR("Failed to create palette for surface ");
                                break;
                            }
                            ddrval = lpDDS1->SetPalette(lpDDPal);
                            if (FAILED(ddrval))
                            {
                                lpDDPal->Release();
                                DPF_ERR("Could not set palette into surface ");
                                break;
                            }
                        }

                        if (SUCCEEDED(ddrval))
                        {
                            /*
                             * Stream palette from stream
                             */
                            ddrval = DD_Palette_PStream_Load( (LPDIRECTDRAWPALETTE) lpDDPal,pStrm);
                            lpDDPal->Release();

                            if (FAILED(ddrval))
                            {
                                break;
                            }
                        }

                    }

                    /*
                     * Here we check for DDPF_OPT... and load a compression GUID if necessary
                    if (ddpfStream.dwFlags & (DDPF_OPTCOMPRESSED|DDPF_OPTREORDERED) )
                    {
                        ddrval = myReadClassStm(pStrm, & clsid);

                    }
                    else
                    //Surface is not compressed, so lock and read....
                     */

                    /*
                     * And finally read the data
                     */
                    for (y=0;y<ddsd.dwHeight;y++)
                    {
                        ddrval = pStrm->Read((void*) ((DWORD) ddsd.lpSurface + y*ddsd.lPitch),
                            (ddsd.dwWidth * ddsd.ddpfPixelFormat.dwRGBBitCount / 8),
                            NULL);

                        if (FAILED(ddrval))
                        {
                            DPF_ERR("Stream read failed");
                            break;
                        }
                    }

                    /*
                     * Read private data
                     */
                    ddrval = InternalReadPrivateData(pStrm, lpDDS1);
                    break;
                }
            } // OK pixel format
            lpDDS1->Unlock(NULL);
        }//lock succeeded
        else
        {
            DPF_ERR("Could not lock surface");
        }

        lpDDS1->Release();
    }// QIed for ddsurf ok
    else
    {
        DPF_ERR("Bad surface object... can't QI itself for IDirectDrawSurface...");
    }

    return ddrval;
}

extern "C" HRESULT DDAPI DD_Surface_PStream_Save(LPDIRECTDRAWSURFACE lpDDS, IStream * pStrm, BOOL bClearDirty)
{
    DDSURFACEDESC2              ddsd;
    HRESULT                     ddrval;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDIRECTDRAWSURFACE4        lpDDS1 = NULL;

    if (!VALID_PTR(pStrm,sizeof(*pStrm)))
    {
        DPF_ERR("Bad stream pointer");
        return DDERR_INVALIDPARAMS;
    }

    this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDS;
    if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
    {
	return DDERR_INVALIDOBJECT;
    }

    /*
     * DO THE QI for DDOPTSURF HERE
     */

    ddrval = lpDDS->QueryInterface(IID_IDirectDrawSurface4, (void**) & lpDDS1);
    if (SUCCEEDED(ddrval))
    {
        ZeroMemory(&ddsd,sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);

        ddrval = lpDDS1->Lock(NULL,&ddsd,DDLOCK_WAIT,NULL);

        if (SUCCEEDED(ddrval))
        {
            if (ddsd.ddpfPixelFormat.dwFlags & (DDPF_FOURCC) )
            {
                DPF_ERR("The surface isn't streamable. Bad pixel format");
                ddrval = DDERR_INVALIDPIXELFORMAT;
            }
            else
            {
                while(SUCCEEDED(ddrval)) //a fake try-except while
                {
                    LPDIRECTDRAWPALETTE2 lpDDPal;
                    DWORD y,dwWritten;

                    /*
                     * First attempt to read stream format GUID
                     */
                    ddrval = myWriteClassStm(pStrm, (LPGUID) & GUID_DirectDrawSurfaceStream);

                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Failed to write stream ID ");
                        ddrval = DDERR_INVALIDSTREAM;
                        break;
                    }

                    /*
                     * Get image format from stream
                     */
                    ddrval = pStrm->Write((void*) & ddsd.dwWidth, sizeof(DWORD), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream write failed on width");
                        break;
                    }

                    ddrval = pStrm->Write((void*) & ddsd.dwHeight, sizeof(DWORD), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream write failed on Height");
                        break;
                    }

                    ddrval = pStrm->Write((void*) & ddsd.ddpfPixelFormat, sizeof(ddsd.ddpfPixelFormat), NULL);
                    if (FAILED(ddrval))
                    {
                        DPF_ERR("Stream write failed on width");
                        break;
                    }

                    /*
                     * If a palette exists, then write it out
                     */
                    ddrval = lpDDS1->GetPalette(&lpDDPal);
                    if (SUCCEEDED(ddrval))
                    {
                        ddrval = lpDDPal->GetCaps(&dwWritten);
                        if (SUCCEEDED(ddrval))
                        {
                            ddrval = pStrm->Write((void*) & dwWritten, sizeof(dwWritten), NULL);
                            if (FAILED(ddrval))
                            {
                                DPF_ERR("Stream write failed on palette caps");
                                break;
                            }

                            /*
                             * Stream palette from stream
                             */
                            ddrval = DD_Palette_PStream_Save((LPDIRECTDRAWPALETTE)lpDDPal,pStrm,bClearDirty);
                            if (FAILED(ddrval))
                            {
                                lpDDPal->Release();
                                break;
                            }
                        }
                        else
                        {
                            DPF_ERR("Could not get palette caps");
                            lpDDPal->Release();
                            break;
                        }

                        lpDDPal->Release();

                    }
                    else
                    {
                        dwWritten = 0;

                        ddrval = pStrm->Write((void*) & dwWritten, sizeof(dwWritten),NULL);
                        if (FAILED(ddrval))
                        {
                            DPF_ERR("Stream write failed on palette caps");
                            break;
                        }
                    }
                    /*
                     * Here we check for DDPF_OPT... and load a compression GUID if necessary
                    if (ddpfStream.dwFlags & (DDPF_OPTCOMPRESSED|DDPF_OPTREORDERED) )
                    {
                        ddrval = myReadClassStm(pStrm, & clsid);

                    }
                    else
                    //Surface is not compressed, so lock and read....
                     */

                    /*
                     * And finally write the data
                     */
                    for (y=0;y<ddsd.dwHeight;y++)
                    {
                        ddrval = pStrm->Write((void*) ((DWORD) ddsd.lpSurface + y*ddsd.lPitch),
                            (ddsd.dwWidth * ddsd.ddpfPixelFormat.dwRGBBitCount / 8),
                            NULL);

                        if (FAILED(ddrval))
                        {
                            DPF_ERR("Stream write failed");
                            break;
                        }
                    }

                    /*
                     * Write out private data
                     */
                    ENTER_DDRAW();
		    ddrval = InternalWritePrivateData(pStrm,
			this_int->lpLcl->lpSurfMore->pPrivateDataHead);
		    LEAVE_DDRAW();
                    break;
                }
            } // OK pixel format
            lpDDS1->Unlock(NULL);
        }//lock succeeded
        else
        {
            DPF_ERR("Could not lock surface");
        }

        lpDDS1->Release();
    }// QIed for ddsurf ok
    else
    {
        DPF_ERR("Bad surface object... can't QI itself for IDirectDrawSurface...");
    }

    if (SUCCEEDED(ddrval) && bClearDirty)
    {
        ENTER_DDRAW();
        GET_LPDDRAWSURFACE_GBL_MORE(this_int->lpLcl->lpGbl)->dwSaveStamp =
        GET_LPDDRAWSURFACE_GBL_MORE(this_int->lpLcl->lpGbl)->dwContentsStamp ;
        LEAVE_DDRAW();
    }

    return ddrval;
}

/*
 * How to calculate the size of a streamable object without really trying.
 * You make a dummy IStream interface with only one valid method: Write.
 * When Write is called you count the bytes and return OK. As long as the
 * client (i.e. our surface and palette IPersistStream interfaces) call
 * nothing but Write, it should work. Since the total is part of the fake
 * stream object which is on the stack, this is thread-safe too.
 */

LPVOID CheatStreamCallbacks[3+11];
typedef struct
{
    LPVOID  * lpVtbl;
    DWORD dwTotal;
} SUPERCHEATSTREAM;

HRESULT __stdcall SuperMegaCheater(SUPERCHEATSTREAM * pCheater, LPVOID pBuffer, ULONG dwSize, ULONG * pWritten)
{
    pCheater->dwTotal += dwSize;
    return S_OK;
}

extern "C" HRESULT DDAPI DD_PStream_GetSizeMax(IPersistStream * lpSurfOrPalette, ULARGE_INTEGER * pMax)
{
    HRESULT                     ddrval = DD_OK;
    SUPERCHEATSTREAM            SuperCheat;

    if (!VALID_PTR(pMax,sizeof(ULARGE_INTEGER)))
    {
        DPF_ERR("Bad stream pointer");
        return DDERR_INVALIDPARAMS;
    }


    SuperCheat.lpVtbl =  CheatStreamCallbacks;
    CheatStreamCallbacks[4] = (LPVOID)SuperMegaCheater;
    SuperCheat.dwTotal = 0;

    lpSurfOrPalette->Save((IStream*) & SuperCheat, FALSE);

    pMax->LowPart = SuperCheat.dwTotal;
    pMax->HighPart = 0;

    return S_OK;
}

extern "C" HRESULT DDAPI DD_Palette_PStream_IsDirty(LPDIRECTDRAWPALETTE lpDDP)
{
    LPDDRAWI_DDRAWPALETTE_INT	    this_int;
    LPDDRAWI_DDRAWPALETTE_GBL	    this_gbl;

    ENTER_DDRAW();

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDP;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

        this_gbl = this_int->lpLcl->lpGbl;

        if ( (this_gbl->dwSaveStamp == 0 ) ||
             (this_gbl->dwContentsStamp != this_gbl->dwSaveStamp) )
        {
	    LEAVE_DDRAW();
	    return S_OK;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered checking dirty" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return S_FALSE;
}

extern "C" HRESULT DDAPI DD_Palette_Persist_GetClassID(LPDIRECTDRAWPALETTE lpDDP, CLSID * pClassID)
{
    TRY
    {
        memcpy(pClassID, & GUID_DirectDrawPaletteStream, sizeof(*pClassID));
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered copying GUID" );
	return DDERR_INVALIDPARAMS;
    }
    return DD_OK;
}

extern "C" HRESULT DDAPI DD_Palette_PStream_Load(LPDIRECTDRAWPALETTE lpStream, IStream * pStrm)
{
    PALETTEENTRY                pe[256];
    HRESULT                     ddrval;
    DWORD                       dwCaps, dwStreamCaps;
    DWORD                       dwSize;
    DWORD                       dwNumEntries;
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    GUID                        g;
    LPDIRECTDRAWPALETTE2        lpDDP;

    this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpStream;
    if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
    {
	return DDERR_INVALIDOBJECT;
    }

    ddrval = lpStream->QueryInterface( IID_IDirectDrawPalette2, (void**)& lpDDP);
    if (FAILED(ddrval))
    {
        DPF_ERR("Couldn't QI stream for palette");
        return ddrval;
    }

    ddrval = lpDDP->GetCaps(&dwCaps);
    if (SUCCEEDED(ddrval))
    {
        dwNumEntries = FLAGS_TO_SIZE(SIZE_PCAPS_TO_FLAGS(dwCaps));
        dwSize = dwNumEntries;
        if ((dwCaps & DDPCAPS_8BITENTRIES) == 0)
        {
            //the color table is really palettee entries
            dwSize *=sizeof(PALETTEENTRY);
        }
        //if it weren 8 bit entries, then dwSize would already be the size of the color table

        ddrval = pStrm->Read((LPVOID) &g, sizeof(GUID_DirectDrawPaletteStream),NULL);
        if (SUCCEEDED(ddrval))
        {
            if (IsEqualGUID(g, GUID_DirectDrawPaletteStream))
            {
                ddrval = pStrm->Read((LPVOID) &dwStreamCaps, sizeof(DWORD),NULL);

                if (SUCCEEDED(ddrval))
                {
                    if (dwCaps == dwStreamCaps)
                    {

                        ddrval = pStrm->Read((LPVOID) pe, dwSize,NULL);
                        if (SUCCEEDED(ddrval))
                        {
                            ddrval = lpDDP->SetEntries(0,0,dwNumEntries,pe);
                            if (SUCCEEDED(ddrval))
                            {
				/*
				 * Read private data
				 */
				ddrval = InternalReadPrivateData(pStrm, lpDDP);
				if (FAILED(ddrval))
                                {
                                    DPF_ERR("Couldn't read private data");
                                }
                            }
                            else
                            {
                                DPF_ERR("Couldn't set palette entries");
                            }
                        }
                        else
                        {
                            DPF_ERR("Couldn't read palette entries");
                        }
                    }
                    else
                    {
                        DPF_ERR("Palette stream caps don't match palette object's caps");
                        ddrval = DDERR_INVALIDSTREAM;
                    }
                }
                else
                {
                    DPF_ERR("Couldn't read palette caps");
                }
            }
            else
            {
                DPF_ERR("Stream doesn't contain a ddraw palette stream tag");
                ddrval = DDERR_INVALIDSTREAM;
            }
        }
        else
        {
            DPF_ERR("Couldn't read palette stream tag");
        }
    }
    else
    {
        DPF_ERR("Couldn't get palette caps");
    }
    lpDDP->Release();

    return ddrval;
}

extern "C" HRESULT DDAPI DD_Palette_PStream_Save(LPDIRECTDRAWPALETTE lpStream, IStream * pStrm, BOOL bClearDirty)
{
    PALETTEENTRY                pe[256];
    HRESULT                     ddrval;
    DWORD                       dwCaps;
    DWORD                       dwSize;
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDIRECTDRAWPALETTE         lpDDP;

    this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpStream;
    if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
    {
	return DDERR_INVALIDOBJECT;
    }

    ddrval = lpStream->QueryInterface(IID_IDirectDrawPalette, (void**) &lpDDP);
    if (FAILED(ddrval))
    {
        DPF_ERR("Couldn't QI stream for palette");
        return ddrval;
    }

    ddrval = lpDDP->GetCaps(&dwCaps);
    if (SUCCEEDED(ddrval))
    {
        dwSize = FLAGS_TO_SIZE(SIZE_PCAPS_TO_FLAGS(dwCaps));
        ddrval = lpDDP->GetEntries(0,0,dwSize,pe);
        if (SUCCEEDED(ddrval))
        {
            if ((dwCaps & DDPCAPS_8BITENTRIES) == 0)
            {
                //the color table is really palettee entries
                dwSize *=sizeof(PALETTEENTRY);
            }
            //if it weren 8 bit entries, then dwSize would already be the size of the color table

            ddrval = pStrm->Write((LPVOID) &GUID_DirectDrawPaletteStream, sizeof(GUID_DirectDrawPaletteStream),NULL);
            if (SUCCEEDED(ddrval))
            {
                ddrval = pStrm->Write((LPVOID) &dwCaps, sizeof(DWORD),NULL);

                if (SUCCEEDED(ddrval))
                {
                    ddrval = pStrm->Write((LPVOID) pe, dwSize,NULL);
                    if (SUCCEEDED(ddrval))
                    {
			ENTER_DDRAW();
			ddrval = InternalWritePrivateData(pStrm,
			    this_int->lpLcl->pPrivateDataHead);
			LEAVE_DDRAW();

                        if (SUCCEEDED(ddrval))
                        {
                            if (bClearDirty)
                            {
                                ENTER_DDRAW();
                                (this_int->lpLcl->lpGbl)->dwSaveStamp = (this_int->lpLcl->lpGbl)->dwContentsStamp ;
                                LEAVE_DDRAW();
                            }
                        }
                        else
                        {
                            DPF_ERR("Couldn't write palette private data");
                        }
                    }
                    else
                    {
                        DPF_ERR("Couldn't write palette entries");
                    }
                }
                else
                {
                    DPF_ERR("Couldn't write palette caps");
                }
            }
            else
            {
                DPF_ERR("Couldn't write palette stream tag");
            }
        }
        else
        {
            DPF_ERR("COuldn't get palette entries");
        }
    }
    else
    {
        DPF_ERR("Couldn't get palette caps");
    }
    lpDDP->Release();

    return ddrval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddsover.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddsover.c
 *  Content:	DirectDraw Surface overlay support:
 *		UpdateOverlay
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27-jan-95	craige	split out of ddsurf.c, enhanced
 *   31-jan-95	craige	and even more ongoing work...
 *   03-feb-95	craige	performance tuning, ongoing work
 *   27-feb-95	craige	new sync. macros
 *   08-mar-95	craige	new APIs: GetOverlayPosition, GetOverlayZOrder
 *			SetOverlayZOrder, SetOverlayPosition
 *   19-mar-95	craige	use HRESULTs
 *   01-apr-95	craige	happy fun joy updated header file
 *   03-apr-95	craige	made update overlay work again
 *   06-may-95	craige	use driver-level csects only
 *   14-may-95	craige	cleaned out obsolete junk
 *   15-may-95	kylej	deleted GetOverlayZOrder, SetOverlayZOrder,
 *			InsertOverlayZOrder.  Added UpdateOverlayZOrder
 *			and EnumOverlayZOrders.
 *   17-jun-95	craige	new surface structure
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns; tweaks in UpdateOverlay;
 *			verify stretching; disabled alpha
 *   30-jun-95	craige	small bug fixes; verify rectangle alignment
 *   04-jul-95	craige	YEEHAW: new driver struct; SEH
 *   10-jul-95	craige	support Get/SetOverlayPosition
 *   10-jul-95  kylej   mirroring caps and flags
 *   13-jul-95	craige	changed Get/SetOverlayPosition to use LONG
 *   31-jul-95	craige	validate flags
 *   19-aug-95 davidmay don't check rectangles when hiding overlay
 *   10-dec-95  colinmc added execute buffer support
 *   02-jan-96	kylej	handle new interface structs
 *   12-feb-96  colinmc surface lost flag moved from global to local object
 *   23-apr-96	kylej	use dwMinOverlayStretch and dwMaxOverlayStretch
 *			validate that entire dest rect is in overlayed surface
 *   29-jan-97	smac	Removed old ring 0 code
 *   03-mar-97	smac	Added kernel mode interface
 *   19-nov-98 jvanaken Overlays with alpha blending
 *
 ***************************************************************************/
#include "ddrawpr.h"

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateOverlay"

/*
 * checkOverlayStretching
 *
 * check and see if we can stretch or not
 */
HRESULT checkOverlayStretching(
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		DWORD dest_height,
		DWORD dest_width,
		DWORD src_height,
		DWORD src_width,
		DWORD src_caps,
		BOOL emulate )
{
    DWORD		caps;
    DWORD		basecaps;
    BOOL		fail;
    DWORD		dwMinStretch;
    DWORD		dwMaxStretch;

    fail = FALSE;

    if( emulate )
    {
	basecaps = pdrv->ddHELCaps.dwCaps;
	caps = pdrv->ddHELCaps.dwFXCaps;
	if( src_caps & DDSCAPS_LIVEVIDEO )
	{
	    dwMinStretch = pdrv->ddHELCaps.dwMinLiveVideoStretch;
	    dwMaxStretch = pdrv->ddHELCaps.dwMaxLiveVideoStretch;
	}
	else if( src_caps & DDSCAPS_HWCODEC )
	{
	    dwMinStretch = pdrv->ddHELCaps.dwMinHwCodecStretch;
	    dwMaxStretch = pdrv->ddHELCaps.dwMaxHwCodecStretch;
	}
	else
	{
	    dwMinStretch = pdrv->ddHELCaps.dwMinOverlayStretch;
	    dwMaxStretch = pdrv->ddHELCaps.dwMaxOverlayStretch;
	}
    }
    else
    {
	basecaps = pdrv->ddCaps.dwCaps;
	caps = pdrv->ddCaps.dwFXCaps;
	if( src_caps & DDSCAPS_LIVEVIDEO )
	{
	    dwMinStretch = pdrv->ddCaps.dwMinLiveVideoStretch;
	    dwMaxStretch = pdrv->ddCaps.dwMaxLiveVideoStretch;
	}
	else if( src_caps & DDSCAPS_HWCODEC )
	{
	    dwMinStretch = pdrv->ddCaps.dwMinHwCodecStretch;
	    dwMaxStretch = pdrv->ddCaps.dwMaxHwCodecStretch;
	}
	else
	{
	    dwMinStretch = pdrv->ddCaps.dwMinOverlayStretch;
	    dwMaxStretch = pdrv->ddCaps.dwMaxOverlayStretch;
	}
    }

    /*
     * Check against dwMinOverlayStretch
     */
    if( src_width*dwMinStretch > dest_width*1000 )
    {
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Check against dwMaxOverlayStretch
     */
    if( (dwMaxStretch != 0) && (src_width*dwMaxStretch < dest_width*1000) )
    {
	return DDERR_INVALIDPARAMS;
    }


    if( (src_height == dest_height) && (src_width == dest_width) )
    {
	// not stretching.
	return DD_OK;
    }

    /*
     * If we are here, we must be trying to stretch.
     * can we even stretch at all?
     */
    if( !(basecaps & DDCAPS_OVERLAYSTRETCH))
    {
	return DDERR_NOSTRETCHHW;
    }

    /*
     * verify height
     */
    if( src_height != dest_height )
    {
	if( src_height > dest_height )
	{
	    /*
	     * can we shrink Y arbitrarily?
	     */
	    if( !(caps & DDFXCAPS_OVERLAYSHRINKY) )
	    {
		/*
		 * see if this is a non-integer shrink
		 */
		if( (src_height % dest_height) != 0 )
		{
		    return DDERR_NOSTRETCHHW;
		/*
		 * see if we can integer shrink
		 */
		}
		else if( !(caps & DDFXCAPS_OVERLAYSHRINKYN) )
		{
		    return DDERR_NOSTRETCHHW;
		}
	    }
	}
	else
	{
	    if( !(caps & DDFXCAPS_OVERLAYSTRETCHY) )
	    {
		/*
		 * see if this is a non-integer stretch
		 */
		if( (dest_height % src_height) != 0 )
		{
		    return DDERR_NOSTRETCHHW;
		/*
		 * see if we can integer stretch
		 */
		}
		else if( !(caps & DDFXCAPS_OVERLAYSTRETCHYN) )
		{
		    return DDERR_NOSTRETCHHW;
		}
	    }
	}
    }

    /*
     * verify width
     */
    if( src_width != dest_width )
    {
	if( src_width > dest_width )
	{
	    if( !(caps & DDFXCAPS_OVERLAYSHRINKX) )
	    {
		/*
		 * see if this is a non-integer shrink
		 */
		if( (src_width % dest_width) != 0 )
		{
		    return DDERR_NOSTRETCHHW;
		/*
		 * see if we can integer shrink
		 */
		}
		else if( !(caps & DDFXCAPS_OVERLAYSHRINKXN) )
		{
		    return DDERR_NOSTRETCHHW;
		}
	    }
	}
	else
	{
	    if( !(caps & DDFXCAPS_OVERLAYSTRETCHX) )
	    {
		/*
		 * see if this is a non-integer stretch
		 */
		if( (dest_width % src_width) != 0 )
		{
		    return DDERR_NOSTRETCHHW;
		}
		if( !(caps & DDFXCAPS_OVERLAYSTRETCHXN) )
		{
		    return DDERR_NOSTRETCHHW;
		}
	    }
	}
    }

    return DD_OK;

} /* checkOverlayStretching */

/*
 * checkOverlayFlags
 */
static HRESULT checkOverlayFlags(
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		LPDWORD lpdwFlags,
		LPDDRAWI_DDRAWSURFACE_INT this_src_int,
		LPDDRAWI_DDRAWSURFACE_LCL this_dest_lcl,
		LPDDHAL_UPDATEOVERLAYDATA puod,
		LPDDOVERLAYFX lpDDOverlayFX,
		BOOL emulate )
{
    LPDDRAWI_DDRAWSURFACE_LCL this_src_lcl;
    DWORD		basecaps;
    DWORD		baseckeycaps;
    DWORD		dwFlags;

    this_src_lcl = this_src_int->lpLcl;
    dwFlags= * lpdwFlags;

    if( emulate )
    {
	basecaps = pdrv->ddHELCaps.dwCaps;
	baseckeycaps = pdrv->ddHELCaps.dwCKeyCaps;
    }
    else
    {
	basecaps = pdrv->ddCaps.dwCaps;
	baseckeycaps = pdrv->ddCaps.dwCKeyCaps;
    }

    /*
     * Handle auto-flipping
     */
    if( dwFlags & DDOVER_AUTOFLIP )
    {
	DWORD rc;

	rc = IsValidAutoFlipSurface( this_src_int );
	if( rc == IVAS_NOAUTOFLIPPING )
	{
	    DPF_ERR( "AUTOFLIPPING not valid" );
	    return DDERR_INVALIDPARAMS;
	}
	else if( rc == IVAS_SOFTWAREAUTOFLIPPING )
	{
	    /*
	     * Software autoflipping only
	     */
	    this_src_lcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SOFTWAREAUTOFLIP;
	}
    }

    /*
     * Handle bob
     */
    if( dwFlags & DDOVER_BOB )
    {
	/*
	 * Fail if bob caps not specified
	 */
	if( dwFlags & DDOVER_INTERLEAVED )
	{
	    if( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_CANBOBINTERLEAVED ) )
	    {
	    	DPF_ERR( "Device doesn't support DDOVER_BOB while interleaved!" );
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    if( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED ) )
	    {
	    	DPF_ERR( "Device doesn't support DDOVER_BOB!" );
		return DDERR_INVALIDPARAMS;
	    }
	}

	/*
	 * Is the surface fed by a video port?
	 */
	if( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT ) &&
	    ( this_src_lcl->lpSurfMore->lpVideoPort != NULL ) )
	{
	    /*
	     * Yes - fail (at least for DX5) if they are bobbing and not
	     * autofliiping.  This is because this support is broken in DX5.
	     */
	    if( !( dwFlags & ( DDOVER_AUTOFLIP | DDOVER_INTERLEAVED ) ) )
	    {
	    	DPF_ERR( "DDOVER_BOB specified without autoflip or interleaved!" );
		return DDERR_INVALIDPARAMS;
	    }
	    if( MustSoftwareBob( this_src_int ) )
	    {
		dwFlags &= ~DDOVER_BOBHARDWARE;
	    }
	    else
	    {
		dwFlags |= DDOVER_BOBHARDWARE;
	    }
	}
	else
	{
	    /*
	     * Don't allow non-VPE clients to use bob unless the
	     * driver can handle it.
	     */
	    if( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_CANFLIPODDEVEN ) )
	    {
		DPF_ERR( "Device does not support DDCAPS2_CANFLIPODDEVEN" );
		return DDERR_INVALIDPARAMS;
	    }
	    if( dwFlags & DDOVER_BOBHARDWARE )
	    {
		DPF_ERR( "DDOVER_BOBHARDWARE only valid when used with a video port" );
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
    else if( dwFlags & DDOVER_BOBHARDWARE )
    {
	DPF_ERR( "DDOVER_BOBHARDWARE specified w/o DDOVER_BOB" );
	return DDERR_INVALIDPARAMS;
    }

    /*
     * ALPHA DISABLED FOR REV 1
     */
    #pragma message( REMIND( "Alpha disabled for rev 1" ) )
    #ifdef USE_ALPHA
    /*
     * verify alpha
     */
    if( dwFlags & DDOVER_ANYALPHA )
    {
	/*
	 * dest
	 */
	if( dwFlags & DDOVER_ALPHADEST )
	{
	    if( dwFlags & (DDOVER_ALPHASRC |
			     DDOVER_ALPHADESTCONSTOVERRIDE |
			     DDOVER_ALPHADESTSURFACEOVERRIDE) )
	    {
		DPF_ERR( "ALPHADEST and other alpha sources specified" );
		return DDERR_INVALIDPARAMS;
	    }
	    psurf_lcl = FindAttached( this_dest_lcl, DDSCAPS_ALPHA );
	    if( psurf_lcl == NULL )
	    {
		DPF_ERR( "ALPHADEST requires an attached alpha to the dest" );
		return DDERR_INVALIDPARAMS;
	    }
	    psurf = psurf_lcl->lpGbl;
	    dwFlags &= ~DDOVER_ALPHADEST;
	    dwFlags |= DDOVER_ALPHADESTSURFACEOVERRIDE;
	    puod->overlayFX.lpDDSAlphaDest = (LPDIRECTDRAWSURFACE) psurf;
	}
	else if( dwFlags & DDOVER_ALPHADESTCONSTOVERRIDE )
	{
	    if( dwFlags & ( DDOVER_ALPHADESTSURFACEOVERRIDE) )
	    {
		DPF_ERR( "ALPHADESTCONSTOVERRIDE and other alpha sources specified" );
		return DDERR_INVALIDPARAMS;
	    }
	    puod->overlayFX.dwConstAlphaDestBitDepth =
			    lpDDOverlayFX->dwConstAlphaDestBitDepth;
	    puod->overlayFX.dwConstAlphaDest = lpDDOverlayFX->dwConstAlphaDest;
	}
	else if( dwFlags & DDOVER_ALPHADESTSURFACEOVERRIDE )
	{
	    psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDOverlayFX->lpDDSAlphaDest;
	    if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_lcl ) )
	    {
		DPF_ERR( "ALPHASURFACEOVERRIDE requires surface ptr" );
		return DDERR_INVALIDPARAMS;
	    }
	    psurf = psurf_lcl->lpGbl;
	    if( SURFACE_LOST( psurf_lcl ) )
	    {
		return DDERR_SURFACELOST;
	    }
	    puod->overlayFX.lpDDSAlphaDest = (LPDIRECTDRAWSURFACE) psurf;
	}

	/*
	 * source
	 */
	if( dwFlags & DDOVER_ALPHASRC )
	{
	    if( dwFlags & (DDOVER_ALPHASRC |
			     DDOVER_ALPHASRCCONSTOVERRIDE |
			     DDOVER_ALPHASRCSURFACEOVERRIDE) )
	    {
		DPF_ERR( "ALPHASRC and other alpha sources specified" );
		return DDERR_INVALIDPARAMS;
	    }
	    psurf_lcl = FindAttached( this_dest_lcl, DDSCAPS_ALPHA );
	    if( psurf_lcl == NULL )
	    {
		DPF_ERR( "ALPHASRC requires an attached alpha to the dest" );
		return DDERR_INVALIDPARAMS;
	    }
	    psurf = psurf_lcl->lpGbl;
	    dwFlags &= ~DDOVER_ALPHASRC;
	    dwFlags |= DDOVER_ALPHASRCSURFACEOVERRIDE;
	    puod->overlayFX.lpDDSAlphaSrc = (LPDIRECTDRAWSURFACE) psurf;
	}
	else if( dwFlags & DDOVER_ALPHASRCCONSTOVERRIDE )
	{
	    if( dwFlags & ( DDOVER_ALPHASRCSURFACEOVERRIDE) )
	    {
		DPF_ERR( "ALPHASRCCONSTOVERRIDE and other alpha sources specified" );
		return DDERR_INVALIDPARAMS;
	    }
	    puod->overlayFX.dwConstAlphaSrcBitDepth =
			    lpDDOverlayFX->dwConstAlphaSrcBitDepth;
	    puod->overlayFX.dwConstAlphaSrc = lpDDOverlayFX->dwConstAlphaSrc;
	}
	else if( dwFlags & DDOVER_ALPHASRCSURFACEOVERRIDE )
	{
	    psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDOverlayFX->lpDDSAlphaSrc;
	    if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_lcl ) )
	    {
		DPF_ERR( "ALPHASURFACEOVERRIDE requires surface ptr" );
		return DDERR_INVALIDPARAMS;
	    }
	    psurf = psurf_lcl->lpGbl;
	    if( SURFACE_LOST( psurf_lcl ) )
	    {
		return DDERR_SURFACELOST;
	    }
	    puod->overlayFX.lpDDSAlphaSrc = (LPDIRECTDRAWSURFACE) psurf;
	}
    }
    #endif

    /*
     * verify color key overrides
     */
    if( dwFlags & (DDOVER_KEYSRCOVERRIDE|DDOVER_KEYDESTOVERRIDE) )
    {
	if( !(basecaps & DDCAPS_COLORKEY) )
	{
	    DPF_ERR( "KEYOVERRIDE specified, colorkey not supported" );
	    return DDERR_NOCOLORKEYHW;
	}
	if( dwFlags & DDOVER_KEYSRCOVERRIDE )
	{
	    if( !(baseckeycaps & DDCKEYCAPS_SRCOVERLAY) )
	    {
		DPF_ERR( "KEYSRCOVERRIDE specified, not supported" );
		return DDERR_NOCOLORKEYHW;
	    }
	    puod->overlayFX.dckSrcColorkey = lpDDOverlayFX->dckSrcColorkey;
	}
	if( dwFlags & DDOVER_KEYDESTOVERRIDE )
	{
	    if( !(baseckeycaps & DDCKEYCAPS_DESTOVERLAY) )
	    {
		DPF_ERR( "KEYDESTOVERRIDE specified, not supported" );
		return DDERR_NOCOLORKEYHW;
	    }
	    puod->overlayFX.dckDestColorkey = lpDDOverlayFX->dckDestColorkey;
	}
    }

    /*
     * verify src color key
     */
    if( dwFlags & DDOVER_KEYSRC )
    {
	if( dwFlags & DDOVER_KEYSRCOVERRIDE )
	{
	    DPF_ERR( "KEYSRC specified with KEYSRCOVERRIDE" );
	    return DDERR_INVALIDPARAMS;
	}
	if( !(this_src_lcl->dwFlags & DDRAWISURF_HASCKEYSRCOVERLAY) )
	{
	    DPF_ERR( "KEYSRC specified, but no color key" );
	    return DDERR_INVALIDPARAMS;
	}
	puod->overlayFX.dckSrcColorkey = this_src_lcl->ddckCKSrcOverlay;
	dwFlags &= ~DDOVER_KEYSRC;
	dwFlags |= DDOVER_KEYSRCOVERRIDE;
    }

    /*
     * verify dest color key
     */
    if( dwFlags & DDOVER_KEYDEST )
    {
	if( dwFlags & DDOVER_KEYDESTOVERRIDE )
	{
	    DPF_ERR( "KEYDEST specified with KEYDESTOVERRIDE" );
	    return DDERR_INVALIDPARAMS;
	}
	if( !(this_dest_lcl->dwFlags & DDRAWISURF_HASCKEYDESTOVERLAY) )
	{
	    DPF_ERR( "KEYDEST specified, but no color key" );
	    return DDERR_INVALIDPARAMS;
	}
	puod->overlayFX.dckDestColorkey = this_dest_lcl->ddckCKDestOverlay;
	dwFlags &= ~DDOVER_KEYDEST;
	dwFlags |= DDOVER_KEYDESTOVERRIDE;
    }

    *lpdwFlags = dwFlags;
    return DD_OK;

} /* checkOverlayFlags */

/*
 * flags we need to call checkOverlayFlags for
 */
#define FLAGS_TO_CHECK \
    (DDOVER_KEYSRCOVERRIDE| DDOVER_KEYDESTOVERRIDE | \
     DDOVER_KEYSRC | DDOVER_KEYDEST | DDOVER_OVERRIDEBOBWEAVE | \
     DDOVER_AUTOFLIP | DDOVER_BOB )


/*
 * Return a pointer to the DDPIXELFORMAT structure that
 * describes the specified surface's pixel format.
 */
static DWORD getPixelFormatFlags(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    if (surf_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
	// surface contains explicitly defined pixel format
	return surf_lcl->lpGbl->ddpfSurface.dwFlags;
    }

    // surface's pixel format is implicit -- same as primary's
    return surf_lcl->lpSurfMore->lpDD_lcl->lpGbl->vmiData.ddpfDisplay.dwFlags;

}  /* getPixelFormatFlags */

#if 0
/*
 * checkOverlayAlpha -- See if we can do specified alpha-blending operation.
 */
static HRESULT checkOverlayAlpha(
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		LPDWORD lpdwFlags,
		LPDDRAWI_DDRAWSURFACE_LCL src_surf_lcl,
                LPDDHAL_UPDATEOVERLAYDATA puod,
		LPDDOVERLAYFX lpDDOverlayFX,
		BOOL emulate )
{
    DDARGB argb = { 255, 255, 255, 255 };
    DWORD fxcaps = 0;
    DWORD alphacaps = 0;
    DWORD pfflags = getPixelFormatFlags(src_surf_lcl);
    DWORD dwFlags = *lpdwFlags;

    if( emulate )
    {
        fxcaps = pdrv->ddHELCaps.dwFXCaps;
        if (pdrv->lpddHELMoreCaps)
        {
            alphacaps = pdrv->lpddHELMoreCaps->dwAlphaCaps;
        }
    }
    else
    {
        fxcaps = pdrv->ddCaps.dwFXCaps;
        if (pdrv->lpddMoreCaps)
        {
            alphacaps = pdrv->lpddMoreCaps->dwAlphaCaps;
        }
    }
	
    // Is any type of alpha blending required for this overlay?
    if (!(pfflags & DDPF_ALPHAPIXELS) && !(dwFlags & DDOVER_ARGBSCALEFACTORS))
    {
        return DD_OK;	 // no alpha blending is needed
    }

    // Yes, verify that the driver supports alpha blending.
    if (!(fxcaps & DDFXCAPS_OVERLAYALPHA))
    {
        DPF_ERR("Driver can't do alpha blending on overlays");
        return DDERR_NOALPHAHW;
    }

    // Is dest color keying also enabled for this overlay?
    if ((dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE)) &&
        !(alphacaps &DDALPHACAPS_OVERLAYALPHAANDKEYDEST))
    {
        DPF_ERR("Driver can't do alpha blending and dest color key on same overlay");
        return DDERR_UNSUPPORTED;
    }

    // Get ARGB scaling factors from DDOVERLAYFX structure.
    *(LPDWORD)&argb = ~0;    // default = ARGB scaling disabled (all ones)
    if (dwFlags & DDOVER_ARGBSCALEFACTORS)
    {
        if( !(*lpdwFlags & DDOVER_DDFX) )
        {
            DPF_ERR("Must specify DDOVER_DDFX with DDOVER_ARGBSCALEFACTORS");
            return DDERR_INVALIDPARAMS;
        }
        argb = lpDDOverlayFX->ddargbScaleFactors;   // ARGB scaling enabled
    }

    // Does the source surface have an alpha channel?
    if (pfflags & DDPF_ALPHAPIXELS)
    {
        /*
         * Yes, verify that the driver can handle an alpha channel.
         * (This check is a bit redundant since the driver has already blessed
         * the format of this overlay surface by allowing it to be created.)
         */ 
        if (!(alphacaps & DDALPHACAPS_OVERLAYALPHAPIXELS))
        {
            DPF_ERR("Driver can't handle source surface's alpha channel");
            return DDERR_NOALPHAHW;
        }

        // Ignore source color key flags if source has alpha channel.
        if (dwFlags & (DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE))
        {
            *lpdwFlags &= ~(DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE);
        }

        /*
         * Are we asking the driver to handle both ARGB scaling and
         * an alpha channel when it can't do both at the same time?
         */
        if (*(LPDWORD)&argb != ~0 &&
            !(alphacaps & DDALPHACAPS_OVERLAYALPHAANDARGBSCALING))
        {
            if (!(dwFlags & DDOVER_DEGRADEARGBSCALING))
            {
                DPF_ERR("Driver can't handle alpha channel and ARGB scaling at same time");
                return DDERR_INVALIDPARAMS;
            }
            // We're allowed to degrade ARGB scaling, so turn it off.
            *(LPDWORD)&argb = ~0;
        }

        /*
         * Are color components in pixel format premultiplied by the
         * alpha component or not?  In either case, verify that the
         * driver supports the specified alpha format.
         */
        if (pfflags & DDPF_ALPHAPREMULT)
        {
            // Source pixel format uses premultiplied alpha.
            if (!(alphacaps & DDALPHACAPS_OVERLAYPREMULT))
            {
                DPF_ERR("No driver support for premultiplied alpha");
                return DDERR_NOALPHAHW;
            }
        }
        else
        {
            // Source pixel format uses NON-premultiplied alpha.
            if (!(alphacaps & DDALPHACAPS_OVERLAYNONPREMULT))
            {
                DPF_ERR("No driver support for non-premultiplied alpha");
                return DDERR_NOALPHAHW;
            }

            /*
             * We allow only one-factor ARGB scaling with a source surface
             * that has a non-premultiplied alpha pixel format.
             * The following code enforces this rule.
             */
            if (*(LPDWORD)&argb != ~0)
            {
                // ARGB scaling is enabled.  Check for one-factor scaling.
                DWORD val = 0x01010101UL*argb.alpha;

                if (*(LPDWORD)&argb != val)
                {
                    // Uh-oh.  This is NOT one-factor ARGB scaling.
                    if (!(dwFlags & DDABLT_DEGRADEARGBSCALING))
                    {
                        DPF_ERR("Can't do 2- or 4-mult ARGB scaling if source has non-premultiplied alpha");
                        return DDERR_INVALIDPARAMS;
                    }
                    // We're allowed to degrade to one-factor scaling.
                    *(LPDWORD)&argb = val;
                }
            }
        }
    }

    // Is ARGB scaling is enabled?
    if (*(LPDWORD)&argb != ~0UL)
    {
        // Yes, ARGB scaling is enabled.  Is DEGRADESCALEFACTORS flag set?
        if (dwFlags & DDOVER_DEGRADEARGBSCALING)
        {
            /*
             * Yes, if necessary, we are permitted to degrade the ARGB
             * scaling factors to values the driver can handle.
             */
            if (!(alphacaps & (DDALPHACAPS_OVERLAYARGBSCALE1F |
                DDALPHACAPS_OVERLAYARGBSCALE2F |
                DDALPHACAPS_OVERLAYARGBSCALE4F)))
            {
                /*
                 * Driver can't do any kind of ARGB scaling at all, so just
                 * disable ARGB scaling by setting all four factors to 255.
                 */
                *(LPDWORD)&argb = ~0UL;
            }
            else if (!(alphacaps & (DDALPHACAPS_OVERLAYARGBSCALE2F |
                DDALPHACAPS_OVERLAYARGBSCALE4F)))
            {
                /*
                 * The driver can do only one-factor ARGB scaling, so set the
                 * three color factors to the same value as the alpha factor.
                 */
                *(LPDWORD)&argb = 0x01010101UL*argb.alpha;
            }
            else if (!(alphacaps & DDALPHACAPS_OVERLAYARGBSCALE4F))
            {
                /*
                 * Driver can do only 2-factor ARGB scaling, so make sure
                 * all three color factors are set to the same value.
                 */
                if ((argb.red != argb.green) || (argb.red != argb.blue))
                {
                    /*
                     * Set all three color factors to value "fact", which is the
                     * weighted average of their specified values (Fr,Fg,Fb):
                     *     fact = .299*Fr + .587*Fg + .114*Fb
                     */
                    DWORD fact = 19595UL*argb.red + 38470UL*argb.green +
                        7471UL*argb.blue;

                    argb.red =
                    argb.green =
                    argb.blue = (BYTE)(fact >> 16);
                }
	    }
            /*
             * Does driver use saturated arithmetic to do alpha blending?
             */
            if (!(alphacaps & DDALPHACAPS_OVERLAYSATURATE))
            {
                /*
                 * The driver can't do saturated arithmetic, so ensure that none
                 * of the color factors exceeds the value of the alpha factor.
                 */
                if (argb.red > argb.alpha)
                {
                    argb.red = argb.alpha;
                }
                if (argb.green > argb.alpha)
                {
                    argb.green = argb.alpha;
                }
                if (argb.blue > argb.alpha)
                {
                    argb.blue = argb.alpha;
                }
            }
        }
        else    
        {
            /*
             * We are not permitted to degrade the ARGB scaling factors, so if
             * the driver can't handle them as specified, the call must fail.
             * We permit a color factor to be larger than the alpha factor
             * only if the hardware uses saturated arithmetic.  (Otherwise, we
             * would risk integer overflow when we calculate the color values.)
             */
            if (!(alphacaps & DDALPHACAPS_OVERLAYSATURATE) &&
                ((argb.red > argb.alpha) || (argb.green > argb.alpha) ||
                (argb.blue > argb.alpha)))
            {
                DPF_ERR("Driver can't handle specified ARGB scaling factors");
                return DDERR_NOALPHAHW;
            }

            // Can the driver handle any ARGB scaling at all?
            if (!(alphacaps & (DDALPHACAPS_OVERLAYARGBSCALE1F |
                DDALPHACAPS_OVERLAYARGBSCALE2F |
                DDALPHACAPS_OVERLAYARGBSCALE4F)))
            {
                DPF_ERR("Driver can't handle any ARGB scaling at all");
                return DDERR_NOALPHAHW;
            }

            if ((argb.red != argb.green) || (argb.red != argb.blue))
            {
                /*
                 * Driver must be capable of doing 4-factor ARGB scaling.
                 */
                if (!(alphacaps & DDALPHACAPS_OVERLAYARGBSCALE4F))
                {
                    DPF_ERR("Driver can't handle 4-factor ARGB scaling");
                    return DDERR_NOALPHAHW;
                }
            }
            else if (argb.red != argb.alpha)
            {
                /*
                 * Driver must be capable of doing 2-factor ARGB scaling.
                 */
                if (!(alphacaps & (DDALPHACAPS_OVERLAYARGBSCALE2F |
                    DDALPHACAPS_OVERLAYARGBSCALE4F)))
                {
                    DPF_ERR("Driver can't handle 2-factor ARGB scaling");
                    return DDERR_NOALPHAHW;
                }
            }
        }
    }
    // Save any modifications made to values of ARGB scaling factors.
    puod->overlayFX.ddargbScaleFactors = argb;
    return DD_OK;

}  /* checkOverlayAlpha */
#endif

/*
 * checkOverlayEmulation
 */
__inline HRESULT checkOverlayEmulation(
	LPDDRAWI_DIRECTDRAW_GBL pdrv,
	LPDDRAWI_DDRAWSURFACE_LCL this_src_lcl,
	LPDDRAWI_DDRAWSURFACE_LCL this_dest_lcl,
	LPBOOL pemulation )
{
    /*
     * check if emulated or hardware
     */
    if( (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) ||
	(this_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
    {
	if( !(pdrv->ddHELCaps.dwCaps & DDCAPS_OVERLAY) )
	{
	    DPF_ERR( "can't emulate overlays" );
	    return DDERR_UNSUPPORTED;
	}
	*pemulation = TRUE;
    }
    /*
     * hardware overlays
     */
    else
    {
	if( !(pdrv->ddCaps.dwCaps & DDCAPS_OVERLAY) )
	{
	    DPF_ERR( "no hardware overlay support" );
	    return DDERR_NOOVERLAYHW;
	}
	*pemulation = FALSE;
    }
    return DD_OK;

} /* checkOverlayEmulation */

#ifdef WIN95
/*
 * WillCauseOverlayArtifacts
 *
 * There is a latency between the time Update overlay is called and all of
 * the kernel mode surfaces structures are updated.  If UpdateOverlay
 * updates the src pointer and an autoflip occurs before the kernel surface
 * data gets updated, it will cause a very visble jump.  This function tries
 * to determine when this is the case so we can work around it by temporarily
 * disabling the video.
 */
BOOL WillCauseOverlayArtifacts( LPDDRAWI_DDRAWSURFACE_LCL this_src_lcl,
		LPDDHAL_UPDATEOVERLAYDATA lpHALData )
{
    if( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE ) &&
        !( lpHALData->dwFlags & DDOVER_HIDE ) &&
        ( ( lpHALData->rSrc.left != this_src_lcl->rcOverlaySrc.left ) ||
        ( lpHALData->rSrc.top != this_src_lcl->rcOverlaySrc.top ) ) )
    {
        return TRUE;
    }
    return FALSE;
}
#endif

/*
 * DD_Surface_UpdateOverlay
 */
HRESULT DDAPI DD_Surface_UpdateOverlay(
		LPDIRECTDRAWSURFACE lpDDSrcSurface,
		LPRECT lpSrcRect,
		LPDIRECTDRAWSURFACE lpDDDestSurface,
		LPRECT lpDestRect,
		DWORD dwFlags,
		LPDDOVERLAYFX lpDDOverlayFX )
{
    DWORD			rc;
    DDHAL_UPDATEOVERLAYDATA	uod;
    LPDDRAWI_DDRAWSURFACE_INT	this_src_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_src_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this_src;
    LPDDRAWI_DDRAWSURFACE_INT	this_dest_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_dest_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this_dest;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    RECT			rsrc;
    RECT			rdest;
    BOOL			emulation;
    DWORD			dest_width;
    DWORD			dest_height;
    DWORD			src_width;
    DWORD			src_height;
    LPDDHALSURFCB_UPDATEOVERLAY uohalfn;
    LPDDHALSURFCB_UPDATEOVERLAY uofn;
    HRESULT			ddrval;
    #ifdef WIN95
        BOOL			bAutoflipDisabled;
    #endif

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_UpdateOverlay");

    /*
     * validate parameters
     */
    TRY
    {
	this_src_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSrcSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_src_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_src_lcl = this_src_int->lpLcl;
	this_src = this_src_lcl->lpGbl;
	if( SURFACE_LOST( this_src_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
	this_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDDestSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_dest_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_dest_lcl = this_dest_int->lpLcl;
	this_dest = this_dest_lcl->lpGbl;
	if( SURFACE_LOST( this_dest_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

        //
        // For now, if either  surface is optimized, quit
        //
        if ((this_src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED) ||
            (this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( dwFlags & ~DDOVER_VALID )
	{
	    DPF_ERR( "invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( lpDestRect != NULL )
	{
	    if( !VALID_RECT_PTR( lpDestRect ) )
	    {
		DPF_ERR( "invalid dest rect" );
		LEAVE_DDRAW();
		return DDERR_INVALIDRECT;
	    }
	}

	if( lpSrcRect != NULL )
	{
	    if( !VALID_RECT_PTR( lpSrcRect ) )
	    {
		DPF_ERR( "invalid src rect" );
		LEAVE_DDRAW();
		return DDERR_INVALIDRECT;
	    }
	}
	if( lpDDOverlayFX != NULL )
	{
	    if( !VALID_DDOVERLAYFX_PTR( lpDDOverlayFX ) )
	    {
		DPF_ERR( "invalid overlayfx" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    if( dwFlags & DDOVER_DDFX )
	    {
		DPF_ERR( "DDOVER_DDFX requires valid DDOverlayFX structure" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}

	pdrv_lcl = this_dest_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

	/*
	 * make sure the source surface is an overlay surface
	 */
	if( !(this_src_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) )
	{
	    DPF_ERR( "Source is not an overlay surface" );
	    LEAVE_DDRAW();
	    return DDERR_NOTAOVERLAYSURFACE;
	}

        /*
         * make sure the destination is not an execute buffer
         */
        if( this_dest_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            DPF_ERR( "Invalid surface type: cannot overlay" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

        /*
         * Make sure that both surfaces belong to the same device.
         */
        if (this_src_lcl->lpSurfMore->lpDD_lcl->lpGbl != this_dest_lcl->lpSurfMore->lpDD_lcl->lpGbl)
        {
            DPF_ERR("Source and Destination surface must belong to the same device");
	    LEAVE_DDRAW();
	    return DDERR_DEVICEDOESNTOWNSURFACE;
        }

	/*
	 * check if emulated or not
	 */
	ddrval = checkOverlayEmulation( pdrv, this_src_lcl, this_dest_lcl, &emulation );
	if( ddrval != DD_OK )
	{
	    LEAVE_DDRAW();
	    return ddrval;
	}
#ifdef TOOMUCHOVERLAYVALIDATION
	/*
	 * check if showing/hiding
	 */
	if( dwFlags & DDOVER_SHOW )
	{
	    if( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE )
	    {
		DPF_ERR( "Overlay already shown" );
		LEAVE_DDRAW();
		return DDERR_GENERIC;
	    }
	}
	else if ( dwFlags & DDOVER_HIDE )
	{
	    if( !(this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE) )
	    {
		DPF_ERR( "Overlay already hidden" );
		LEAVE_DDRAW();
		return DDERR_GENERIC;
	    }
	}
#endif

	/*
	 * set new rectangles if needed
	 */
	if( lpDestRect == NULL )
	{
	    MAKE_SURF_RECT( this_dest, this_dest_lcl, rdest );
	    lpDestRect = &rdest;
	}
	if( lpSrcRect == NULL )
	{
	    MAKE_SURF_RECT( this_src, this_src_lcl, rsrc );
	    lpSrcRect = &rsrc;
	}

	/*
	 * Check if ring 0 interface is overriding what the client
	 * tells us to do
	 */
	#ifdef WIN95
	    if( !( dwFlags & DDOVER_HIDE) )
	    {
	        OverrideOverlay( this_src_int, &dwFlags );
	    }
	#endif

	/*
	 * validate the rectangle dimensions
	 */
	dest_height = lpDestRect->bottom - lpDestRect->top;
	dest_width = lpDestRect->right - lpDestRect->left;
	if( ((int)dest_height <= 0) || ((int)dest_width <= 0) ||
	    ((int)lpDestRect->top < 0) || ((int)lpDestRect->left < 0) ||
	    ((DWORD) lpDestRect->bottom > (DWORD) this_dest->wHeight) ||
	    ((DWORD) lpDestRect->right > (DWORD) this_dest->wWidth) )
	{
	    DPF_ERR( "Invalid destination rect dimensions" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDRECT;
	}

	src_height = lpSrcRect->bottom - lpSrcRect->top;
	src_width = lpSrcRect->right - lpSrcRect->left;
	if( ((int)src_height <= 0) || ((int)src_width <= 0) ||
	    ((int)lpSrcRect->top < 0) || ((int)lpSrcRect->left < 0) ||
	    ((DWORD) lpSrcRect->bottom > (DWORD) this_src->wHeight) ||
	    ((DWORD) lpSrcRect->right > (DWORD) this_src->wWidth) )
	{
	    DPF_ERR( "Invalid source rect dimensions" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDRECT;
	}

	/*
	 * validate alignment
	 */
	if( !emulation )
	{
	    if( pdrv->ddCaps.dwCaps & (DDCAPS_ALIGNBOUNDARYDEST |
					DDCAPS_ALIGNSIZEDEST |
					DDCAPS_ALIGNBOUNDARYSRC |
					DDCAPS_ALIGNSIZESRC) )
	    {
		if( pdrv->ddCaps.dwCaps & DDCAPS_ALIGNBOUNDARYDEST )
		{
		    #if 0
		    /* GEE: I don't believe this code should be here
		     * only test alignment on width on height
		     */
		    if( (lpDestRect->top % pdrv->ddCaps.dwAlignBoundaryDest) != 0 )
		    {
			DPF_ERR( "Destination top is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_YALIGN;
		    }
		    #endif
		    if( (lpDestRect->left % pdrv->ddCaps.dwAlignBoundaryDest) != 0 )
		    {
			DPF_ERR( "Destination left is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_XALIGN;
		    }
		}

		if( pdrv->ddCaps.dwCaps & DDCAPS_ALIGNBOUNDARYSRC )
		{
		    #if 0
		    /* GEE: I don't believe this code should be here
		     * only test alignment on width on height
		     */
		    if( (lpSrcRect->top % pdrv->ddCaps.dwAlignBoundarySrc) != 0 )
		    {
			DPF_ERR( "Source top is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_YALIGN;
		    }
		    #endif
		    if( (lpSrcRect->left % pdrv->ddCaps.dwAlignBoundarySrc) != 0 )
		    {
			DPF_ERR( "Source left is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_XALIGN;
		    }
		}

		if( pdrv->ddCaps.dwCaps & DDCAPS_ALIGNSIZEDEST )
		{
		    if( (dest_width % pdrv->ddCaps.dwAlignSizeDest) != 0 )
		    {
			DPF_ERR( "Destination width is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_XALIGN;
		    }
		    #if 0
		    /* GEE: I don't believe this code should be here
		     * only test alignment for x axis
		     */
		    if( (dest_height % pdrv->ddCaps.dwAlignSizeDest) != 0 )
		    {
			DPF_ERR( "Destination height is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_HEIGHTALIGN;
		    }
		    #endif
		}

		if( pdrv->ddCaps.dwCaps & DDCAPS_ALIGNSIZESRC )
		{
		    if( (src_width % pdrv->ddCaps.dwAlignSizeSrc) != 0 )
		    {
			DPF_ERR( "Source width is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_XALIGN;
		    }
		    #if 0
		    /* GEE: I don't believe this code should be here
		     * only test alignment for x axis
		     */
		    if( (src_height % pdrv->ddCaps.dwAlignSizeSrc) != 0 )
		    {
			DPF_ERR( "Source height is not aligned correctly" );
			LEAVE_DDRAW();
			return DDERR_HEIGHTALIGN;
		    }
		    #endif
		}
	    }
	}

	/*
	 * validate if stretching
	 */
	if( !( dwFlags & DDOVER_HIDE) )
	{
	    ddrval = checkOverlayStretching( pdrv,
					     dest_height,
					     dest_width,
					     src_height,
					     src_width,
					     this_src_lcl->ddsCaps.dwCaps,
					     emulation );
	    if( ddrval != DD_OK )
	    {
		LEAVE_DDRAW();
		return ddrval;
	    }
	}

	/*
	 * If the surface has recieved data from a video port, we will
	 * set/clear the DDOVER_INTERLEAVED flag accordingly.  This
	 * makes life a little easier on the HAL.
	 */
	if( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT ) &&
	    ( this_src_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_VPORTDATA ) )
	{
	    if( this_src_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_VPORTINTERLEAVED )
	    {
		dwFlags |= DDOVER_INTERLEAVED;
	    }
	    else
	    {
		dwFlags &= ~DDOVER_INTERLEAVED;
	    }
	}

#if 0
	/*
	 * If any kind of alpha blending is requested, make sure the specified
	 * alpha parameters are correct and that the driver supports alpha blending.
	 * If source has alpha channel, this call clears source color-key flags.
	 */
        ddrval = checkOverlayAlpha( pdrv,
				    &dwFlags,
				    this_src_lcl,
				    &uod,
				    lpDDOverlayFX,
				    emulation );
        if( ddrval != DD_OK )
	{
	    LEAVE_DDRAW();
	    return ddrval;
	}
#endif
	/*
	 * any flags at all? if not, blow the whole thing off...
	 */
	uod.overlayFX.dwSize = sizeof( DDOVERLAYFX );
	if( dwFlags & FLAGS_TO_CHECK )
	{
	    ddrval = checkOverlayFlags( pdrv,
					&dwFlags,
					this_src_int,
					this_dest_lcl,
					&uod,
					lpDDOverlayFX,
					emulation );
	    if( ddrval != DD_OK )
	    {
		LEAVE_DDRAW();
		return ddrval;
	    }
	}

	// check for overlay mirroring capability
	if( dwFlags & DDOVER_DDFX )
	{
	    if( lpDDOverlayFX->dwDDFX & DDOVERFX_MIRRORLEFTRIGHT )
	    {
		if( !( pdrv->ddBothCaps.dwFXCaps & DDFXCAPS_OVERLAYMIRRORLEFTRIGHT ) )
		{
		    if( pdrv->ddHELCaps.dwFXCaps & DDFXCAPS_OVERLAYMIRRORLEFTRIGHT )
		    {
			emulation = TRUE;
		    }
		}
	    }
	    if( lpDDOverlayFX->dwDDFX & DDOVERFX_MIRRORUPDOWN )
	    {
		if( !( pdrv->ddBothCaps.dwFXCaps & DDFXCAPS_OVERLAYMIRRORUPDOWN ) )
		{
		    if( pdrv->ddHELCaps.dwFXCaps & DDFXCAPS_OVERLAYMIRRORUPDOWN )
		    {
			emulation = TRUE;
		    }
		}
	    }
	    uod.overlayFX.dwDDFX = lpDDOverlayFX->dwDDFX;
            // deinterlacing is a hint - if not supported by hardware, mask it off
            if ( lpDDOverlayFX->dwDDFX & DDOVERFX_DEINTERLACE )
            {
                if ( !( pdrv->ddCaps.dwFXCaps & DDFXCAPS_OVERLAYDEINTERLACE ) )
                {
                    uod.overlayFX.dwDDFX &= ~DDOVERFX_DEINTERLACE;
                }
            }
	}


	/*
	 * pick fns to use
	 */
	if( emulation )
	{
	    uofn = pdrv_lcl->lpDDCB->HELDDSurface.UpdateOverlay;
	    uohalfn = uofn;
	}
	else
	{
	    uofn = pdrv_lcl->lpDDCB->HALDDSurface.UpdateOverlay;
	    uohalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.UpdateOverlay;
	}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * call the driver
     */
    #ifdef WIN95
        bAutoflipDisabled = FALSE;
    #endif
    if( uohalfn != NULL )
    {
        BOOL    original_visible;

        // Set the visible flag according to the show and hide bits
        // If the HAL call fails, restore the visible bit to its original
        // state.  The HEL uses the DDSCAPS_VISIBLE bit to determine
        // whether or not to display the overlay.
        if( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE )
        {
            original_visible = TRUE;
        }
        else
        {
            original_visible = FALSE;
        }
	if( dwFlags & DDOVER_SHOW )
	{
	    this_src_lcl->ddsCaps.dwCaps |= DDSCAPS_VISIBLE;
	}
	else if ( dwFlags & DDOVER_HIDE )
	{
	    this_src_lcl->ddsCaps.dwCaps &= ~DDSCAPS_VISIBLE;
	}


	uod.UpdateOverlay = uohalfn;
	uod.lpDD = pdrv;
	uod.lpDDSrcSurface = this_src_lcl;
	uod.lpDDDestSurface = this_dest_lcl;
	uod.rDest = *(LPRECTL) lpDestRect;
	uod.rSrc = *(LPRECTL) lpSrcRect;
	uod.dwFlags = dwFlags;
	if( this_src->dwGlobalFlags & DDRAWISURFGBL_SOFTWAREAUTOFLIP )
	{
	    uod.dwFlags &= ~( DDOVER_AUTOFLIP | DDOVER_BOBHARDWARE );
	    #ifdef WIN95
	        if( WillCauseOverlayArtifacts( this_src_lcl, &uod ) )
	        {
		    // Eliminate artifacts by temporarily freezing the video
		    EnableAutoflip( GetVideoPortFromSurface( this_src_int ), FALSE );
		    bAutoflipDisabled = TRUE;
	        }
	    #endif
	}

        /*
         * Don't call the HAL if we're in a DOS box (the busy bit will be set),
         * but we also cant fail or this might cause a regression.
         */
#ifdef WIN95
        if( ( *(pdrv->lpwPDeviceFlags) & BUSY ) &&
            ( pdrv->dwSurfaceLockCount == 0) )      // Don't fail if it's busy due to a lock
        {
            rc = DDHAL_DRIVER_HANDLED;
            uod.ddRVal = DD_OK;
        }
        else
#endif
        {
#ifndef WINNT
            // Hack to work around s3 driver bug: it crushes the dest surface's
            // dwReserved1 with the src pointer!!!
            UINT_PTR dwTemp = uod.lpDDDestSurface->lpGbl->dwReserved1;
#endif
            DOHALCALL( UpdateOverlay, uofn, uod, rc, emulation );
#ifndef WINNT
            // Note the STB video rage 2 driver trashes uod.lpDDDestSurface and
            // uod.lpDDSrcSurface pointers, so we must check the driver name first.
            if (((*(LPWORD)(&pdrv->dd32BitDriverData.szName)) == ((WORD)'S' + (((WORD)'3')<<8))) &&
	        (uod.lpDDDestSurface->lpGbl->dwReserved1 != dwTemp) &&
                (uod.lpDDDestSurface->lpGbl->dwReserved1 == (UINT_PTR)uod.lpDDSrcSurface))
            {
                uod.lpDDDestSurface->lpGbl->dwReserved1 = dwTemp;
            }
#endif
        }

	/*
	 * If it failed due to hardware autoflipping or bobbing interleaved
	 * data using a video port, try again w/o
	 */
	if( ( rc == DDHAL_DRIVER_HANDLED ) &&
	    ( uod.ddRVal != DD_OK ) && ( ( uod.dwFlags & DDOVER_AUTOFLIP ) ||
	    ( uod.dwFlags & DDOVER_BOBHARDWARE ) ) &&
	    CanSoftwareAutoflip( GetVideoPortFromSurface( this_src_int ) ) )
	{
	    uod.dwFlags &= ~( DDOVER_AUTOFLIP | DDOVER_BOBHARDWARE );
	    DOHALCALL( UpdateOverlay, uofn, uod, rc, emulation );
	    if( ( rc == DDHAL_DRIVER_HANDLED ) &&
	    	( uod.ddRVal == DD_OK ) )
	    {
		if( dwFlags & DDOVER_AUTOFLIP )
		{
		    this_src_lcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SOFTWAREAUTOFLIP;
		    RequireSoftwareAutoflip( this_src_int );
		}
		if( dwFlags & DDOVER_BOBHARDWARE )
		{
		    RequireSoftwareBob( this_src_int );
		}
	    }
	}

        // if the HAL call failed, restore the visible bit
        if( ( rc != DDHAL_DRIVER_HANDLED ) || ( uod.ddRVal != DD_OK ) )
        {
            if( original_visible )
            {
	        this_src_lcl->ddsCaps.dwCaps |= DDSCAPS_VISIBLE;
            }
            else
            {
                this_src_lcl->ddsCaps.dwCaps &= ~DDSCAPS_VISIBLE;
            }
        }

	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( uod.ddRVal == DD_OK )
	    {
    		LPDDRAWI_DDRAWSURFACE_INT surf_first;
    		LPDDRAWI_DDRAWSURFACE_INT surf_temp;

		/*
		 * Store this info for later use.  If the surface is part
		 * of a chain, store this data for each of the surfaces in
		 * the chain.
		 */
    		surf_first = surf_temp = this_src_int;
    		do
    		{
                    surf_temp->lpLcl->lOverlayX = uod.rDest.left;
                    surf_temp->lpLcl->lOverlayY = uod.rDest.top;
		    surf_temp->lpLcl->rcOverlayDest.left   = uod.rDest.left;
		    surf_temp->lpLcl->rcOverlayDest.top    = uod.rDest.top;
		    surf_temp->lpLcl->rcOverlayDest.right  = uod.rDest.right;
		    surf_temp->lpLcl->rcOverlayDest.bottom = uod.rDest.bottom;
		    surf_temp->lpLcl->rcOverlaySrc.left   = uod.rSrc.left;
		    surf_temp->lpLcl->rcOverlaySrc.top    = uod.rSrc.top;
		    surf_temp->lpLcl->rcOverlaySrc.right  = uod.rSrc.right;
		    surf_temp->lpLcl->rcOverlaySrc.bottom = uod.rSrc.bottom;
		    surf_temp->lpLcl->lpSurfMore->dwOverlayFlags = dwFlags;
		    if( dwFlags & DDOVER_DDFX )
		    {
			if( surf_temp->lpLcl->lpSurfMore->lpddOverlayFX == NULL )
			{
			    surf_temp->lpLcl->lpSurfMore->lpddOverlayFX =
				(LPDDOVERLAYFX) MemAlloc( sizeof( DDOVERLAYFX ) );
			}
			if( surf_temp->lpLcl->lpSurfMore->lpddOverlayFX != NULL )
			{
			    memcpy( surf_temp->lpLcl->lpSurfMore->lpddOverlayFX,
				lpDDOverlayFX, sizeof( DDOVERLAYFX) );
			}
		    }
		    #ifdef WIN95
		        UpdateKernelSurface( surf_temp->lpLcl );
		    #endif
    		    surf_temp = FindAttachedFlip( surf_temp );
    		} while( ( surf_temp != NULL ) && ( surf_temp->lpLcl != surf_first->lpLcl ) );

		/*
		 * update refcnt if this is a new surface we are overlaying
		 */
		if( this_src_lcl->lpSurfaceOverlaying != this_dest_int )
		{
		    if(this_src_lcl->lpSurfaceOverlaying != NULL)
		    {
			/*
			 * This overlay was previously overlaying another surface.
			 */
			DD_Surface_Release(
			    (LPDIRECTDRAWSURFACE)(this_src_lcl->lpSurfaceOverlaying) );
		    }
		    this_src_lcl->lpSurfaceOverlaying = this_dest_int;

		    /*
		     * addref overlayed surface so that it won't be destroyed until
		     * all surfaces which overlay it are destroyed.
		     */
		    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) this_dest_int );
		}
	    }
	    #ifdef WIN95
	        if( bAutoflipDisabled )
	        {
		    EnableAutoflip( GetVideoPortFromSurface( this_src_int ), TRUE );
	        }
	    #endif
	    LEAVE_DDRAW();
	    return uod.ddRVal;
	}
	#ifdef WIN95
	    if( bAutoflipDisabled )
	    {
	        EnableAutoflip( GetVideoPortFromSurface( this_src_int ), TRUE );
	    }
	#endif
    }
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_Surface_UpdateOverlay */


#undef DPF_MODNAME
#define DPF_MODNAME "GetOverlayPosition"

/*
 * DD_Surface_GetOverlayPosition
 */
HRESULT DDAPI DD_Surface_GetOverlayPosition(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPLONG lplXPos,
		LPLONG lplYPos)
{
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetOverlayPosition");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( !VALID_DWORD_PTR( lplXPos ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*lplXPos = 0;
        if( !VALID_DWORD_PTR( lplYPos ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        *lplYPos = 0;
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
	pdrv = this->lpDD;

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) )
	{
	    DPF_ERR( "Surface is not an overlay surface" );
	    LEAVE_DDRAW();
	    return DDERR_NOTAOVERLAYSURFACE;
	}
	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE) )
	{
	    DPF_ERR( "Overlay surface is not visible" );
	    LEAVE_DDRAW();
	    return DDERR_OVERLAYNOTVISIBLE;
	}

	if( this_lcl->lpSurfaceOverlaying == NULL )
	{
	    DPF_ERR( "Overlay not activated" );
	    LEAVE_DDRAW();
	    return DDERR_NOOVERLAYDEST;
	}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    *lplXPos = this_lcl->lOverlayX;
    *lplYPos = this_lcl->lOverlayY;

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetOverlayPosition */

#undef DPF_MODNAME
#define DPF_MODNAME "SetOverlayPosition"

/*
 * DD_Surface_SetOverlayPosition
 */
HRESULT DDAPI DD_Surface_SetOverlayPosition(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LONG lXPos,
		LONG lYPos)
{
    LPDDRAWI_DIRECTDRAW_LCL		pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL		pdrv;
    LPDDRAWI_DDRAWSURFACE_INT		psurfover_int;
    LPDDRAWI_DDRAWSURFACE_LCL		psurfover_lcl;
    LPDDRAWI_DDRAWSURFACE_INT		this_int;
    LPDDRAWI_DDRAWSURFACE_LCL		this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL		this;
    BOOL				emulation;
    LPDDHALSURFCB_SETOVERLAYPOSITION	sophalfn;
    LPDDHALSURFCB_SETOVERLAYPOSITION	sopfn;
    DDHAL_SETOVERLAYPOSITIONDATA	sopd;
    HRESULT				ddrval;
    DWORD				rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetOverlayPosition");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) )
	{
	    DPF_ERR( "Surface is not an overlay surface" );
	    LEAVE_DDRAW();
	    return DDERR_NOTAOVERLAYSURFACE;
	}

	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE) )
	{
	    DPF_ERR( "Overlay surface is not visible" );
	    LEAVE_DDRAW();
	    return DDERR_OVERLAYNOTVISIBLE;
	}

	psurfover_int = this_lcl->lpSurfaceOverlaying;
	if( psurfover_int == NULL )
	{
	    DPF_ERR( "Overlay not activated" );
	    LEAVE_DDRAW();
	    return DDERR_NOOVERLAYDEST;
	}

	psurfover_lcl = psurfover_int->lpLcl;
	if( (lYPos > (LONG) psurfover_lcl->lpGbl->wHeight -
            (this_lcl->rcOverlayDest.bottom - this_lcl->rcOverlayDest.top)) ||
	    (lXPos > (LONG) psurfover_lcl->lpGbl->wWidth -
            (this_lcl->rcOverlayDest.right - this_lcl->rcOverlayDest.left) ) ||
	    (lYPos < 0) ||
	    (lXPos < 0) )
	{
	    DPF_ERR( "Invalid overlay position" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPOSITION;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * check if emulated or not
     */
    ddrval = checkOverlayEmulation( pdrv, this_lcl, psurfover_lcl, &emulation );
    if( ddrval != DD_OK )
    {
	LEAVE_DDRAW();
	return ddrval;
    }

    /*
     * pick fns to use
     */
    if( emulation )
    {
	sopfn = pdrv_lcl->lpDDCB->HELDDSurface.SetOverlayPosition;
	sophalfn = sopfn;
    }
    else
    {
	sopfn = pdrv_lcl->lpDDCB->HALDDSurface.SetOverlayPosition;
	sophalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.SetOverlayPosition;
    }

    /*
     * call the driver
     */
    if( sophalfn != NULL )
    {
	sopd.SetOverlayPosition = sophalfn;
	sopd.lpDD = pdrv;
	sopd.lpDDSrcSurface = this_lcl;
	sopd.lpDDDestSurface = psurfover_lcl;
	sopd.lXPos = lXPos;
	sopd.lYPos = lYPos;

        /*
         * Don't call the HAL if we're in a DOS box (the busy bit will be set),
         * but we also cant fail or this might cause a regression.
         */
#if WIN95
        if( *(pdrv->lpwPDeviceFlags) & BUSY )
        {
            rc = DDHAL_DRIVER_HANDLED;
            sopd.ddRVal = DD_OK;
        }
        else
#endif
        {
            DOHALCALL( SetOverlayPosition, sopfn, sopd, rc, emulation );
        }

	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    LEAVE_DDRAW();
	    if( sopd.ddRVal == DD_OK )
	    {
		this_lcl->lOverlayX = lXPos;
		this_lcl->lOverlayY = lYPos;
                this_lcl->rcOverlayDest.right =
                    ( this_lcl->rcOverlayDest.right -
                    this_lcl->rcOverlayDest.left ) + lXPos;
                this_lcl->rcOverlayDest.left = lXPos;
                this_lcl->rcOverlayDest.bottom =
                    ( this_lcl->rcOverlayDest.bottom -
                    this_lcl->rcOverlayDest.top ) + lYPos;
                this_lcl->rcOverlayDest.top = lYPos;
	    }
	    return sopd.ddRVal;
	}
    }

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_Surface_SetOverlayPosition */

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateOverlayZOrder"

/*
 * DD_Surface_UpdateOverlayZOrder
 */
HRESULT DDAPI DD_Surface_UpdateOverlayZOrder(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags,
		LPDIRECTDRAWSURFACE lpDDSReference)
{
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_INT	psurf_ref_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_ref_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf_ref;
    LPDBLNODE			pdbnNode;
    LPDBLNODE			pdbnRef;
    DWORD			ddrval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_UpdateOverlayZOrder");

    /*
     * validate parameters
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	pdrv = this->lpDD;

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) )
	{
	    DPF_ERR( "Surface is not an overlay surface" );
	    LEAVE_DDRAW();
	    return DDERR_NOTAOVERLAYSURFACE;
	}

	switch(dwFlags)
	{
	case DDOVERZ_SENDTOFRONT:
	    pdbnNode = &(this_lcl->dbnOverlayNode);
	    // the reference node is the root
	    pdbnRef  = &(this->lpDD->dbnOverlayRoot);
	    // Delete surface from current position
	    pdbnNode->prev->next = pdbnNode->next;
	    pdbnNode->next->prev = pdbnNode->prev;
	    // insert this node after the root node
	    pdbnNode->next = pdbnRef->next;
	    pdbnNode->prev = pdbnRef;
	    pdbnRef->next = pdbnNode;
	    pdbnNode->next->prev = pdbnNode;
	    break;

	case DDOVERZ_SENDTOBACK:
	    pdbnNode = &(this_lcl->dbnOverlayNode);
	    // the reference node is the root
	    pdbnRef = &(this->lpDD->dbnOverlayRoot);
	    // Delete surface from current position
	    pdbnNode->prev->next = pdbnNode->next;
	    pdbnNode->next->prev = pdbnNode->prev;
	    // insert this node before the root node
	    pdbnNode->next = pdbnRef;
	    pdbnNode->prev = pdbnRef->prev;
	    pdbnRef->prev = pdbnNode;
	    pdbnNode->prev->next = pdbnNode;
	    break;

	case DDOVERZ_MOVEFORWARD:
	    pdbnNode = &(this_lcl->dbnOverlayNode);
	    // the reference node is the previous node
	    pdbnRef = pdbnNode->prev;
	    if(pdbnRef != &(this->lpDD->dbnOverlayRoot)) // node already first?
	    {
		// move node forward one position by inserting before ref node
		// Delete surface from current position
		pdbnNode->prev->next = pdbnNode->next;
		pdbnNode->next->prev = pdbnNode->prev;
		// insert this node before the ref node
		pdbnNode->next = pdbnRef;
		pdbnNode->prev = pdbnRef->prev;
		pdbnRef->prev = pdbnNode;
		pdbnNode->prev->next = pdbnNode;
	    }
	    break;

	case DDOVERZ_MOVEBACKWARD:
	    pdbnNode = &(this_lcl->dbnOverlayNode);
	    // the reference node is the next node
	    pdbnRef = pdbnNode->next;
	    if(pdbnRef != &(this->lpDD->dbnOverlayRoot)) // node already last?
	    {
		// move node backward one position by inserting after ref node
		// Delete surface from current position
		pdbnNode->prev->next = pdbnNode->next;
		pdbnNode->next->prev = pdbnNode->prev;
		// insert this node after the reference node
		pdbnNode->next = pdbnRef->next;
		pdbnNode->prev = pdbnRef;
		pdbnRef->next = pdbnNode;
		pdbnNode->next->prev = pdbnNode;
	    }
	    break;

	case DDOVERZ_INSERTINBACKOF:
	case DDOVERZ_INSERTINFRONTOF:
	    psurf_ref_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSReference;
	    if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_ref_int ) )
	    {
		DPF_ERR( "Invalid reference surface ptr" );
		LEAVE_DDRAW();
		return DDERR_INVALIDOBJECT;
	    }
	    psurf_ref_lcl = psurf_ref_int->lpLcl;
	    psurf_ref = psurf_ref_lcl->lpGbl;
	    if( !(psurf_ref_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) )
	    {
		DPF_ERR( "reference surface is not an overlay" );
		LEAVE_DDRAW();
		return DDERR_NOTAOVERLAYSURFACE;
	    }
	    if (this_lcl->lpSurfMore->lpDD_lcl->lpGbl != psurf_ref_lcl->lpSurfMore->lpDD_lcl->lpGbl)
	    {
		DPF_ERR("Surfaces must belong to the same device");
		LEAVE_DDRAW();
		return DDERR_DEVICEDOESNTOWNSURFACE;
	    }

	    // Search for the reference surface in the Z Order list
	    pdbnNode = &(this->lpDD->dbnOverlayRoot); // pdbnNode points to root
	    for(pdbnRef=pdbnNode->next;
		pdbnRef != pdbnNode;
		pdbnRef = pdbnRef->next )
	    {
                if( pdbnRef->object == psurf_ref_lcl )
		{
		    break;
		}
	    }
	    if(pdbnRef == pdbnNode) // didn't find the reference node
	    {
		DPF_ERR( "Reference Surface not in Z Order list" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }

	    pdbnNode = &(this_lcl->dbnOverlayNode); // pdbnNode points to this node
	    // Delete this surface from its current position
	    pdbnNode->prev->next = pdbnNode->next;
	    pdbnNode->next->prev = pdbnNode->prev;
	    if(dwFlags == DDOVERZ_INSERTINFRONTOF)
	    {
		// insert this node before the ref node
		pdbnNode->next = pdbnRef;
		pdbnNode->prev = pdbnRef->prev;
		pdbnRef->prev = pdbnNode;
		pdbnNode->prev->next = pdbnNode;
	    }
	    else
	    {
		// insert this node after the ref node
		pdbnNode->next = pdbnRef->next;
		pdbnNode->prev = pdbnRef;
		pdbnRef->next = pdbnNode;
		pdbnNode->next->prev = pdbnNode;
	    }
	    break;

	default:
	    DPF_ERR( "Invalid dwFlags in UpdateOverlayZOrder" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * If this surface is overlaying an emulated surface, we must notify
     * the HEL that it needs to eventually update the part of the surface
     * touched by this overlay.
     */
    ddrval = DD_OK;
    if( this_lcl->lpSurfaceOverlaying != NULL )
    {
	/*
	 * We have a pointer to the surface being overlayed, check to
	 * see if it is being emulated.
	 */
	if( this_lcl->lpSurfaceOverlaying->lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
	{
	    /*
	     * Mark the destination region of this overlay as dirty.
	     */
	    DD_Surface_AddOverlayDirtyRect(
		(LPDIRECTDRAWSURFACE)(this_lcl->lpSurfaceOverlaying),
		&(this_lcl->rcOverlayDest) );
	}

	/*
	 * If the overlay is on, call down to the HAL
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE )
	{
	    if( ( this_lcl->lpSurfMore->dwOverlayFlags & DDOVER_DDFX ) &&
		( this_lcl->lpSurfMore->lpddOverlayFX != NULL ) )
	    {
		ddrval = DD_Surface_UpdateOverlay(
		    (LPDIRECTDRAWSURFACE) this_int,
		    &(this_lcl->rcOverlaySrc),
		    (LPDIRECTDRAWSURFACE) this_lcl->lpSurfaceOverlaying,
		    &(this_lcl->rcOverlayDest),
		    this_lcl->lpSurfMore->dwOverlayFlags,
		    this_lcl->lpSurfMore->lpddOverlayFX );
	    }
	    else
	    {
		ddrval = DD_Surface_UpdateOverlay(
		    (LPDIRECTDRAWSURFACE) this_int,
		    &(this_lcl->rcOverlaySrc),
		    (LPDIRECTDRAWSURFACE) this_lcl->lpSurfaceOverlaying,
		    &(this_lcl->rcOverlayDest),
		    this_lcl->lpSurfMore->dwOverlayFlags,
		    NULL );
	    }
	}
    }


    LEAVE_DDRAW();
    return ddrval;

} /* DD_Surface_UpdateOverlayZOrder */

#undef DPF_MODNAME
#define DPF_MODNAME "EnumOverlayZOrders"

/*
 * DD_Surface_EnumOverlayZOrders
 */
HRESULT DDAPI DD_Surface_EnumOverlayZOrders(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags,
		LPVOID lpContext,
		LPDDENUMSURFACESCALLBACK lpfnCallback)
{
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDBLNODE			pRoot;
    LPDBLNODE			pdbn;
    DDSURFACEDESC2		ddsd;
    DWORD			rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_EnumOverlayZOrders");

    /*
     * validate parameters
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;

	if( !VALIDEX_CODE_PTR( lpfnCallback ) )
	{
	    DPF_ERR( "Invalid callback routine" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;

	pRoot = &(pdrv->dbnOverlayRoot);	// save address of root node
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    //
    // If the current surface is optimized, quit
    //
    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
        DPF_ERR( "It is an optimized surface" );
        LEAVE_DDRAW();
        return DDERR_ISOPTIMIZEDSURFACE;
    }

    if( dwFlags == DDENUMOVERLAYZ_FRONTTOBACK )
    {
	pdbn = pRoot->next;
	while(pdbn != pRoot)
	{
            LPDIRECTDRAWSURFACE7 intReturned = (LPDIRECTDRAWSURFACE7) pdbn->object_int;

	    FillDDSurfaceDesc2( pdbn->object, &ddsd );
            if (LOWERTHANSURFACE4(this_int))
            {
                ddsd.dwSize = sizeof(DDSURFACEDESC);
	        DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) intReturned, & IID_IDirectDrawSurface, (void**) & intReturned );
            }
	    else if (this_int->lpVtbl == &ddSurface4Callbacks)
            {
	        DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) intReturned, & IID_IDirectDrawSurface4, (void**) & intReturned );
            }
            else
            {
	        DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) intReturned, & IID_IDirectDrawSurface7, (void**) & intReturned );
            }

	    rc = lpfnCallback( (LPDIRECTDRAWSURFACE)intReturned, (LPDDSURFACEDESC) &ddsd, lpContext );
	    if( rc == 0)
	    {
		break;
	    }
	    pdbn = pdbn->next;
	}
    }
    else if( dwFlags == DDENUMOVERLAYZ_BACKTOFRONT )
    {
	pdbn = pRoot->prev;
	while(pdbn != pRoot)
	{
            LPDIRECTDRAWSURFACE7 intReturned = (LPDIRECTDRAWSURFACE7) pdbn->object_int;

	    FillDDSurfaceDesc2( pdbn->object, &ddsd );
            if (LOWERTHANSURFACE4(this_int))
            {
                ddsd.dwSize = sizeof(DDSURFACEDESC);
	        DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) intReturned, & IID_IDirectDrawSurface, (void**) & intReturned );
            }
	    else if (this_int->lpVtbl == &ddSurface4Callbacks)
            {
	        DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) intReturned, & IID_IDirectDrawSurface4, (void**) & intReturned );
            }
            else
            {
	        DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) intReturned, & IID_IDirectDrawSurface7, (void**) & intReturned );
            }

	    rc = lpfnCallback( (LPDIRECTDRAWSURFACE)intReturned, (LPDDSURFACEDESC) &ddsd, lpContext );
	    if( rc == 0)
	    {
		break;
	    }
	    pdbn = pdbn->prev;
	}
    }
    else
    {
	DPF_ERR( "Invalid dwFlags in EnumOverlayZOrders" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_EnumOverlayZOrders */

#undef DPF_MODNAME
#define DPF_MODNAME "AddOverlayDirtyRect"

/*
 * DD_Surface_AddOverlayDirtyRect
 */
HRESULT DDAPI DD_Surface_AddOverlayDirtyRect(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPRECT lpRect )
{
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    DDHAL_UPDATEOVERLAYDATA	uod;
    DWORD			rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_AddOverlayDirtyRect");

    /*
     * validate parameters
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;

        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            DPF_ERR( "Invalid surface type: does not support overlays" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

	if( !VALID_RECT_PTR( lpRect ) )
	{
	    DPF_ERR( "invalid Rect" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	this = this_lcl->lpGbl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;

	/*
	 * make sure rectangle is OK
	 */
	if( (lpRect->left < 0) ||
	    (lpRect->top < 0)  ||
	    (lpRect->left > lpRect->right) ||
	    (lpRect->top > lpRect->bottom) ||
	    (lpRect->bottom > (int) (DWORD) this->wHeight) ||
	    (lpRect->right > (int) (DWORD) this->wWidth) )
	{
	    DPF_ERR( "invalid Rect" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    //
    // If the current surface is optimized, quit
    //
    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
        DPF_ERR( "It is an optimized surface" );
        LEAVE_DDRAW();
        return DDERR_ISOPTIMIZEDSURFACE;
    }

    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
    {
	// If this surface is not emulated, there is nothing to be done.
	LEAVE_DDRAW();
	return DD_OK;
    }
    else
    {
	if( pdrv_lcl->lpDDCB->HELDDSurface.UpdateOverlay == NULL )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}

	uod.overlayFX.dwSize = sizeof( DDOVERLAYFX );
	uod.lpDD = this->lpDD;
	uod.lpDDDestSurface = this_lcl;
	uod.rDest = *(LPRECTL) lpRect;
	uod.lpDDSrcSurface = this_lcl;
	uod.rSrc = *(LPRECTL) lpRect;
	uod.dwFlags = DDOVER_ADDDIRTYRECT;
	rc = pdrv_lcl->lpDDCB->HELDDSurface.UpdateOverlay( &uod );

	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( uod.ddRVal == DD_OK )
	    {
		DPF( 2, "Added dirty rect to surface = %08lx", this );
	    }
	    LEAVE_DDRAW();
	    return uod.ddRVal;
	}
	else
	{
            LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }

} /* DD_Surface_AddOverlayDirtyRect */

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateOverlayDisplay"

/*
 * DD_Surface_UpdateOverlayDisplay
 */
HRESULT DDAPI DD_Surface_UpdateOverlayDisplay(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags )
{
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    DDHAL_UPDATEOVERLAYDATA	uod;
    DWORD			rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_UpdateOverlayDisplay");

    /*
     * validate parameters
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
    	this_lcl = this_int->lpLcl;

	if( dwFlags & ~(DDOVER_REFRESHDIRTYRECTS | DDOVER_REFRESHALL) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	this = this_lcl->lpGbl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;

        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            DPF_ERR( "Invalid surface type: does not support overlays" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
	{
	    // If this surface is not emulated, there is nothing to be done.
	    LEAVE_DDRAW();
	    return DD_OK;
	}

	if( pdrv_lcl->lpDDCB->HELDDSurface.UpdateOverlay == NULL )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}

	uod.overlayFX.dwSize = sizeof( DDOVERLAYFX );
	uod.lpDD = this->lpDD;
	uod.lpDDDestSurface = this_lcl;
	MAKE_SURF_RECT( this, this_lcl, uod.rDest );
	uod.lpDDSrcSurface = this_lcl;
	MAKE_SURF_RECT( this, this_lcl, uod.rSrc );
	uod.dwFlags = dwFlags;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * invoke the HEL
     */
    rc = pdrv_lcl->lpDDCB->HELDDSurface.UpdateOverlay( &uod );

    if( rc == DDHAL_DRIVER_HANDLED )
    {
	if( uod.ddRVal == DD_OK )
	{
	    DPF( 2, "Refreshed overlayed surface = %08lx", this );
	}
	LEAVE_DDRAW();
	return uod.ddRVal;
    }

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_Surface_UpdateOverlayDisplay */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddsprite.c ===
/*==========================================================================
 *								
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddsprite.c
 *  Content:	DirectDraw Surface support for sprite display lists:
 *		SetSpriteDisplayList
 *  History:
 *   Date	By	Reason
 *   ====	==	======	
 *  03-nov-97 jvanaken  Original version
 *
 ***************************************************************************/

#include "ddrawpr.h"

// function from ddraw module ddclip.c
extern HRESULT InternalGetClipList(LPDIRECTDRAWCLIPPER,
				   LPRECT,
				   LPRGNDATA,
				   LPDWORD,
				   LPDDRAWI_DIRECTDRAW_GBL);

#define _DDHAL_SetSpriteDisplayList  NULL

/*
 * Masks for distinguishing driver's blit caps from driver's overlay caps.
 */
#define DDFXCAPS_BLTBITS  \
	(DDFXCAPS_BLTALPHA|DDFXCAPS_BLTFILTER|DDFXCAPS_BLTTRANSFORM)

#define DDFXCAPS_OVERLAYBITS  \
	(DDFXCAPS_OVERLAYALPHA|DDFXCAPS_OVERLAYFILTER|DDFXCAPS_OVERLAYTRANSFORM)

#define DDCKEYCAPS_BLTBITS (DDCKEYCAPS_SRCBLT|DDCKEYCAPS_DESTBLT)

#define DDCKEYCAPS_OVERLAYBITS (DDCKEYCAPS_SRCOVERLAY|DDCKEYCAPS_DESTOVERLAY)

#define DDALPHACAPS_BLTBITS  \
	(DDALPHACAPS_BLTSATURATE|DDALPHACAPS_BLTPREMULT|  \
	 DDALPHACAPS_BLTNONPREMULT|DDALPHACAPS_BLTRGBASCALE1F|	\
	 DDALPHACAPS_BLTRGBASCALE2F|DDALPHACAPS_BLTRGBASCALE4F)

#define DDALPHACAPS_OVERLAYBITS  \
	(DDALPHACAPS_OVERLAYSATURATE|DDALPHACAPS_OVERLAYPREMULT|   \
	 DDALPHACAPS_OVERLAYNONPREMULT|DDALPHACAPS_OVERLAYRGBASCALE1F|	 \
	 DDALPHACAPS_OVERLAYRGBASCALE2F|DDALPHACAPS_OVERLAYRGBASCALE4F)

#define DDFILTCAPS_BLTBITS  \
	(DDFILTCAPS_BLTBILINEARFILTER|DDFILTCAPS_BLTBLURFILTER|	  \
	 DDFILTCAPS_BLTFLATFILTER)

#define DDFILTCAPS_OVERLAYBITS  \
	(DDFILTCAPS_OVERLAYBILINEARFILTER|DDFILTCAPS_OVERLAYBLURFILTER|	 \
	 DDFILTCAPS_OVERLAYFLATFILTER)

#define DDTFRMCAPS_BLTBITS  (DDTFRMCAPS_BLTAFFINETRANSFORM)

#define DDTFRMCAPS_OVERLAYBITS  (DDTFRMCAPS_OVERLAYAFFINETRANSFORM)


#undef DPF_MODNAME
#define DPF_MODNAME "SetSpriteDisplayList"

/*
 * Driver capabilities for handling current sprite
 */
typedef struct
{
    // caps for hardware driver
    //DWORD	dwCaps;
    DWORD	dwCKeyCaps;
    DWORD	dwFXCaps;
    DWORD	dwAlphaCaps;
    DWORD	dwFilterCaps;
    DWORD	dwTransformCaps;

    // caps for HEL
    //DWORD	dwHELCaps;
    DWORD	dwHELCKeyCaps;
    DWORD	dwHELFXCaps;
    DWORD	dwHELAlphaCaps;
    DWORD	dwHELFilterCaps;
    DWORD	dwHELTransformCaps;

    // surface caps
    DWORD	dwDestSurfCaps;
    DWORD	dwSrcSurfCaps;

    // minification limit
    DWORD	dwMinifyLimit;
    DWORD	dwHELMinifyLimit;

    BOOL	bNoHAL;   // TRUE disqualifies hardware driver
    BOOL	bNoHEL;   // TRUE disqualifies HEL

    // TRUE=overlay sprite, FALSE=blitted sprite
    BOOL	bOverlay;

} SPRITE_CAPS, *LPSPRITE_CAPS;


/*
 * The master sprite display list consists of some number of sublists.
 * Each sublist contains all the overlay sprites that are displayed
 * within a particular window.  Only the first member of the variable-
 * size sprite[] array appears explicitly in the structure definition
 * below, but dwSize takes into account the ENTIRE sprite[] array.
 * The pRgn member points to the dynamically allocated buffer that
 * contains the clipping region.
 */
typedef struct _SPRITESUBLIST
{
    DWORD dwSize;                    // size of this sublist (in bytes)
    LPDIRECTDRAWSURFACE pPrimary;    // primary surface
    LPDIRECTDRAWCLIPPER pClipper;    // clipper for window (NULL = full screen)
    DWORD dwProcessId;               // process ID (in case pClipper is NULL)
    LPRGNDATA pRgn;                  // pointer to clipping region data
    DWORD dwCount;                   // number of sprites in sublist
    DDSPRITEI sprite[1];  // array of sprites (first member)
} SPRITESUBLIST, *LPSPRITESUBLIST;

/*
 * Buffer used to hold temporary sprite display list passed to driver.
 * Only the first member of the variable-size pSprites[] array appears
 * explicitly in the structure definition below, but the dwSize value
 * takes into account the ENTIRE pSprite[] array.
 */
typedef struct _BUFFER
{
    DWORD dwSize;                            // size of this buffer (in bytes)
    DDHAL_SETSPRITEDISPLAYLISTDATA HalData;  // HAL data for sprite display list
    LPDDSPRITEI pSprite[1]; 	     // array of pointers to sprites
} BUFFER, *LPBUFFER;	

/*
 * Master sprite display list -- Contains copies of the overlay-sprite
 * display lists for all windows that currently display overlay sprites.
 * Only the first member of the variable-size spriteSubList[] array
 * appears explicitly in the structure definition below.  Each sublist
 * contains all the overlay sprites displayed within a particular window.
 */
#define MAXNUMSPRITESUBLISTS (16)

typedef struct _MASTERSPRITELIST
{
    //DWORD dwSize;                    // size of master list (in bytes)
    LPDDRAWI_DIRECTDRAW_GBL pdrv;  // global DDraw object
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;  // primary surface (local object)
    RECT rcPrimary;                    // rectangle = entire primary surface
    DWORD dwFlags;                     // latest caller's DDSSDL_WAIT flag
#ifdef WIN95
    DWORD dwModeCreatedIn;	       // valid only in this video mode
#else
    DISPLAYMODEINFO dmiCreated;        // valid only in this video mode
#endif
    LPBUFFER pBuffer;		       // buffer storage
    DWORD dwNumSubLists;	       // number of sprite sublists
    LPSPRITESUBLIST pSubList[MAXNUMSPRITESUBLISTS];  // array of sublists (fixed size)
} MASTERSPRITELIST, *LPMASTERSPRITELIST;


/*
 * Return the dwFlags member from the DDPIXELFORMAT structure
 * that describes the specified surface's pixel format.
 */
static DWORD getPixelFormatFlags(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    LPDDPIXELFORMAT pDDPF;

    if (surf_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
	// surface contains explicitly defined pixel format
	pDDPF = &surf_lcl->lpGbl->ddpfSurface;
    }
    else
    {
	// surface's pixel format is implicit -- same as primary's
	pDDPF = &surf_lcl->lpSurfMore->lpDD_lcl->lpGbl->vmiData.ddpfDisplay;
    }
    return pDDPF->dwFlags;

}  /* getPixelFormatFlags */


/*
 * Initialize SPRITE_CAPS structure according to whether source and
 * dest surfaces are in system or video (local or nonlocal) memory.
 */
static void initSpriteCaps(LPSPRITE_CAPS pcaps, LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    DDASSERT(pcaps != NULL);

    if (pcaps->bOverlay)
    {
	// Get minification limits for overlays.
	pcaps->dwMinifyLimit = pdrv->lpddMoreCaps->dwOverlayAffineMinifyLimit;
    	pcaps->dwHELMinifyLimit = pdrv->lpddHELMoreCaps->dwOverlayAffineMinifyLimit;
    }
    else
    {
	// Get minification limits for blits.
	pcaps->dwMinifyLimit = pdrv->lpddMoreCaps->dwBltAffineMinifyLimit;
    	pcaps->dwHELMinifyLimit = pdrv->lpddHELMoreCaps->dwBltAffineMinifyLimit;
    }

    if (pcaps->dwSrcSurfCaps & DDSCAPS_NONLOCALVIDMEM &&
	  pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS)
    {
        /*
	 * A driver that specifies nonlocal video-memory caps that differ
	 * from its local video-memory caps is automatically disqualified
	 * because the currently specified nonlocal vidmem caps do not
	 * include alpha, filter, or transform caps.  Should we fix this?
	 */
	pcaps->bNoHAL = TRUE;
    }

    if ((pcaps->dwSrcSurfCaps | pcaps->dwDestSurfCaps) & DDSCAPS_SYSTEMMEMORY &&
	    !(pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM))
    {
	pcaps->bNoHAL = TRUE;	// H/W driver can't blit to/from system memory
    }

    if (pcaps->dwSrcSurfCaps & pcaps->dwDestSurfCaps & DDSCAPS_VIDEOMEMORY)
    {
	//pcaps->dwCaps =   pdrv->ddCaps.dwCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    pcaps->dwAlphaCaps  = pdrv->lpddMoreCaps->dwAlphaCaps;
	    pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwFilterCaps;
	    pcaps->dwTransformCaps = pdrv->lpddMoreCaps->dwTransformCaps;
	}
	
	//pcaps->dwHELCaps =   pdrv->ddHELCaps.dwCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    pcaps->dwHELAlphaCaps  = pdrv->lpddHELMoreCaps->dwAlphaCaps;
	    pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwFilterCaps;
	    pcaps->dwHELTransformCaps = pdrv->lpddHELMoreCaps->dwTransformCaps;
	}
    }
    else if (pcaps->dwSrcSurfCaps & DDSCAPS_SYSTEMMEMORY &&
		pcaps->dwDestSurfCaps & DDSCAPS_VIDEOMEMORY)
    {
	//pcaps->dwCaps =   pdrv->ddCaps.dwSVBCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwSVBCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwSVBFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    pcaps->dwAlphaCaps  = pdrv->lpddMoreCaps->dwSVBAlphaCaps;
	    pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwSVBFilterCaps;
	    pcaps->dwTransformCaps = pdrv->lpddMoreCaps->dwSVBTransformCaps;
	}
	
	//pcaps->dwHELCaps =   pdrv->ddHELCaps.dwSVBCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwSVBCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwSVBFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    pcaps->dwHELAlphaCaps  = pdrv->lpddHELMoreCaps->dwSVBAlphaCaps;
	    pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwSVBFilterCaps;
	    pcaps->dwHELTransformCaps = pdrv->lpddHELMoreCaps->dwSVBTransformCaps;
	}
    }
    else if (pcaps->dwSrcSurfCaps & DDSCAPS_VIDEOMEMORY &&
		    pcaps->dwDestSurfCaps & DDSCAPS_SYSTEMMEMORY)
    {
	//pcaps->dwCaps =   pdrv->ddCaps.dwVSBCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwVSBCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwVSBFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    pcaps->dwAlphaCaps  = pdrv->lpddMoreCaps->dwVSBAlphaCaps;
	    pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwVSBFilterCaps;
	    pcaps->dwTransformCaps = pdrv->lpddMoreCaps->dwVSBTransformCaps;
	}
	
	//pcaps->dwHELCaps =   pdrv->ddHELCaps.dwVSBCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwVSBCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwVSBFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    pcaps->dwHELAlphaCaps  = pdrv->lpddHELMoreCaps->dwVSBAlphaCaps;
	    pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwVSBFilterCaps;
	    pcaps->dwHELTransformCaps = pdrv->lpddHELMoreCaps->dwVSBTransformCaps;
	}
    }
    else if (pcaps->dwSrcSurfCaps & pcaps->dwDestSurfCaps & DDSCAPS_SYSTEMMEMORY)
    {
	//pcaps->dwCaps =   pdrv->ddCaps.dwSSBCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwSSBCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwSSBFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    pcaps->dwAlphaCaps  = pdrv->lpddMoreCaps->dwSSBAlphaCaps;
	    pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwSSBFilterCaps;
	    pcaps->dwTransformCaps = pdrv->lpddMoreCaps->dwSSBTransformCaps;
	}
	
	//pcaps->dwHELCaps =   pdrv->ddHELCaps.dwSSBCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwSSBCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwSSBFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    pcaps->dwHELAlphaCaps  = pdrv->lpddHELMoreCaps->dwSSBAlphaCaps;
	    pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwSSBFilterCaps;
	    pcaps->dwHELTransformCaps = pdrv->lpddHELMoreCaps->dwSSBTransformCaps;
	}
    }

    if (pcaps->bOverlay)
    {
	// Isolate overlay bits by masking off all blit-related bits.
	//pcaps->dwCaps        &= DDCAPS_OVERLAYBITS;
	pcaps->dwCKeyCaps      &= DDCKEYCAPS_OVERLAYBITS;
	pcaps->dwFXCaps        &= DDFXCAPS_OVERLAYBITS;
	pcaps->dwAlphaCaps     &= DDALPHACAPS_OVERLAYBITS;
	pcaps->dwFilterCaps    &= DDFILTCAPS_OVERLAYBITS;
	pcaps->dwTransformCaps &= DDTFRMCAPS_OVERLAYBITS;
	
	//pcaps->dwHELCaps        &= DDCAPS_OVERLAYBITS;
	pcaps->dwHELCKeyCaps      &= DDCKEYCAPS_OVERLAYBITS;
	pcaps->dwHELFXCaps        &= DDFXCAPS_OVERLAYBITS;
	pcaps->dwHELAlphaCaps     &= DDALPHACAPS_OVERLAYBITS;
	pcaps->dwHELFilterCaps    &= DDFILTCAPS_OVERLAYBITS;
	pcaps->dwHELTransformCaps &= DDTFRMCAPS_OVERLAYBITS;
    }
    else
    {
	// Isolate blit bits by masking off all overlay-related bits.
	//pcaps->dwCaps        &= DDCAPS_BLTBITS;
	pcaps->dwCKeyCaps      &= DDCKEYCAPS_BLTBITS;
	pcaps->dwFXCaps        &= DDFXCAPS_BLTBITS;
	pcaps->dwAlphaCaps     &= DDALPHACAPS_BLTBITS;
	pcaps->dwFilterCaps    &= DDFILTCAPS_BLTBITS;
	pcaps->dwTransformCaps &= DDTFRMCAPS_BLTBITS;
	
	//pcaps->dwHELCaps        &= DDCAPS_BLTBITS;
	pcaps->dwHELCKeyCaps      &= DDCKEYCAPS_BLTBITS;
	pcaps->dwHELFXCaps        &= DDFXCAPS_BLTBITS;
	pcaps->dwHELAlphaCaps     &= DDALPHACAPS_BLTBITS;
	pcaps->dwHELFilterCaps    &= DDFILTCAPS_BLTBITS;
	pcaps->dwHELTransformCaps &= DDTFRMCAPS_BLTBITS;
    }
}  /* initSpriteCaps */


/*
 * Verify that affine transform does not exceed driver's minification
 * limit.  Arg pdrv is a pointer to the global DirectDraw object.  Arg
 * lpDDSpriteFX points to a DDSPRITEFX structure containing 4x4 matrix.
 * Arg overlay is TRUE for overlay sprites, and FALSE for blitted
 * sprites.  Arg emulation is TRUE if the overlay is to be emulated.
 * Returns DD_OK if specified affine transform is within limits.
 */
static void checkMinification(LPDDSPRITEFX lpDDSpriteFX,
			      LPSPRITE_CAPS pcaps)
{
    int i;

    for (i = 0; i < 2; ++i)
    {
	FLOAT a00, a01, a10, a11, det, amax;
	DWORD minlim;

	/*
	 * Get driver's minification limit.
	 */
	if (i == 0)
	{
	    // Get hardware driver's minification limit.
	    minlim = pcaps->dwMinifyLimit;

	    if (pcaps->bNoHAL || minlim == 0)   // minlim = 0 means no limit
	    {
    		continue;
	    }
	}
	else
	{
	    // Get HEL's minification limit.
	    minlim = pcaps->dwHELMinifyLimit;

	    if (pcaps->bNoHEL || minlim == 0)
	    {
    		continue;
	    }
	}

	/*
	 * Check transformation matrix against driver's minification limit.
	 */
	a00 = lpDDSpriteFX->fTransform[0][0];
	a01 = lpDDSpriteFX->fTransform[0][1];
	a10 = lpDDSpriteFX->fTransform[1][0];
	a11 = lpDDSpriteFX->fTransform[1][1];
	// Calculate determinant of Jacobian.
	det = a00*a11 - a10*a01;
	// Get absolute values of the 4 Jacobian coefficients.
	if (a00 < 0)   // could have used fabs() here
	    a00 = -a00;
	if (a01 < 0)
	    a01 = -a01;
	if (a10 < 0)
	    a10 = -a10;
	if (a11 < 0)
	    a11 = -a11;
	if (det < 0)
	    det = -det;
	// Find biggest coefficient in Jacobian.
	amax = a00;
	if (a01 > amax)
	    amax = a01;
	if (a10 > amax)
	    amax = a10;
	if (a11 > amax)
	    amax = a11;
	// Test the minification level against the driver's limit.
	if (1000*amax >= det*minlim)
	{
	    // Affine transform exceeds driver's minification limit.
	    if (i == 0)
	    {
    		pcaps->bNoHAL = TRUE;	 // disqualify hardware driver
	    }
	    else
	    {
    		pcaps->bNoHEL = TRUE;	 // disqualify HEL
	    }
	}
    }
}  /* checkMinification */


/*
 * Validate the DDSPRITE structure.  Arg pSprite is a pointer to a
 * DDSPRITE structure.  Arg pdrv is a pointer to the dest surface's
 * DirectDraw object.  Arg dest_lcl is a pointer to the destination
 * surface.  Arg pcaps is a pointer to a structure containing the
 * driver's capabilities.  Returns DD_OK if successful.
 */
static HRESULT validateSprite(LPDDSPRITE pSprite,
			      LPDDRAWI_DIRECTDRAW_GBL pdrv,
			      LPDDRAWI_DDRAWSURFACE_LCL surf_dest_lcl,
			      LPSPRITE_CAPS pcaps,
			      DWORD dwDDPFDestFlags)
{
    LPDDRAWI_DDRAWSURFACE_INT	surf_src_int;
    LPDDRAWI_DDRAWSURFACE_LCL	surf_src_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	surf_src;
    DWORD	dwDDPFSrcFlags;
    LPRECT      prSrc;
    LPRECT      prDest;
    DWORD	dest_width  = 0;
    DWORD	dest_height = 0;
    DWORD	src_width   = 0;
    DWORD	src_height  = 0;

    DDASSERT(!(pcaps->bNoHAL && pcaps->bNoHEL));

    /*
     * Validate the DDSPRITE pointer.  (A caller that does not use the
     * embedded DDSPRITEFX structure must still alloc space for it.)
     */
    if (IsBadWritePtr((LPVOID)pSprite, (UINT)sizeof(DDSPRITE)))
    {
	DPF_ERR("Bad pointer to DDSPRITE structure...");
	return DDERR_INVALIDPARAMS;
    }

    /*
     * If the caller doesn't use the embedded DDSPRITEFX struct,
     * we'll fill it in ourselves before passing it to the driver.
     */
    if (!(pSprite->dwFlags & DDSPRITE_DDSPRITEFX))
    {
	if (pSprite->dwFlags & (DDSPRITE_KEYDESTOVERRIDE | DDSPRITE_KEYSRCOVERRIDE))
	{
	    DPF_ERR("Illegal to set color-key override if DDSPRITEFX is invalid");
	    return DDERR_INVALIDPARAMS;
	}

	pSprite->ddSpriteFX.dwSize = sizeof(DDSPRITEFX);
	pSprite->ddSpriteFX.dwDDFX = 0;
	pSprite->dwFlags |= DDSPRITE_DDSPRITEFX;
    }

    /*
     * Validate the source surface for the sprite.
     */
    surf_src_int = (LPDDRAWI_DDRAWSURFACE_INT)pSprite->lpDDSSrc;

    if (!VALID_DIRECTDRAWSURFACE_PTR(surf_src_int))
    {
	DPF_ERR("Invalid source surface pointer...");
	return DDERR_INVALIDOBJECT;
    }

    surf_src_lcl = surf_src_int->lpLcl;
    surf_src = surf_src_lcl->lpGbl;

    if (SURFACE_LOST(surf_src_lcl))
    {
	DPF_ERR("Lost source surface...");
	return DDERR_SURFACELOST;
    }

    /*
     * We cannot use source and destination surfaces that were
     * created with different DirectDraw objects.
     */
    if (surf_src->lpDD != pdrv
	    && surf_src->lpDD->dwFlags & DDRAWI_DISPLAYDRV &&
		pdrv->dwFlags & DDRAWI_DISPLAYDRV)
    {
	DPF_ERR("Source and dest surfaces must have same DirectDraw device...");
	LEAVE_BOTH();
	return DDERR_DEVICEDOESNTOWNSURFACE;
    }

    /*
     * Validate destination rectangle.
     */
    prDest = &pSprite->rcDest;

    if (pSprite->dwFlags & DDSPRITE_RECTDEST)
    {
	// Validate destination rectangle specified in rcDest member.
	dest_height = prDest->bottom - prDest->top;
	dest_width = prDest->right - prDest->left;
	if ((int)dest_height <= 0 || (int)dest_width <= 0)
	{
	    DPF_ERR("Invalid destination rectangle...");
	    return DDERR_INVALIDRECT;
	}
	if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_AFFINETRANSFORM)
	{
	    DPF_ERR("Illegal to specify both dest rect and affine transform...");
	    return DDERR_INVALIDPARAMS;
	}
    }
    else if (!(pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_AFFINETRANSFORM))
    {
	/*
	 * The implicit destination is the entire dest surface.  Substitute
	 * an explicit destination rectangle that covers the dest surface.
         */
	MAKE_SURF_RECT(surf_dest_lcl->lpGbl, surf_dest_lcl, pSprite->rcDest);
        pSprite->dwFlags |= DDSPRITE_RECTDEST;
    }

    /*
     * Validate source rectangle.
     */
    prSrc = &pSprite->rcSrc;

    if (pSprite->dwFlags & DDSPRITE_RECTSRC)
    {
	// Validate source rectangle specified in rcSrc member.
	src_height = prSrc->bottom - prSrc->top;
	src_width = prSrc->right - prSrc->left;
	if (((int)src_height <= 0) || ((int)src_width <= 0) ||
	    ((int)prSrc->top < 0) || ((int)prSrc->left < 0) ||
	    ((DWORD) prSrc->bottom > (DWORD) surf_src->wHeight) ||
	    ((DWORD) prSrc->right > (DWORD) surf_src->wWidth))
	{
	    DPF_ERR("Invalid source rectangle...");
	    return DDERR_INVALIDRECT;
	}
    }
    else
    {
	/*
	 * The implicit source rect is the entire dest surface.  Substitute
	 * an explicit source rectangle that covers the source surface.
         */
	MAKE_SURF_RECT(surf_src, surf_src_lcl, pSprite->rcSrc);
        pSprite->dwFlags |= DDSPRITE_RECTSRC;
    }

    /*
     * Validate memory alignment of source and dest rectangles.
     */
    if (pdrv->ddCaps.dwCaps & (DDCAPS_ALIGNBOUNDARYDEST | DDCAPS_ALIGNSIZEDEST |
			       DDCAPS_ALIGNBOUNDARYSRC | DDCAPS_ALIGNSIZESRC))
    {
	if (pdrv->ddCaps.dwCaps & DDCAPS_ALIGNBOUNDARYDEST &&
	    (prDest->left % pdrv->ddCaps.dwAlignBoundaryDest) != 0)
	{
	    DPF_ERR("Destination left misaligned...");
	    return DDERR_XALIGN;
	}
	if (pdrv->ddCaps.dwCaps & DDCAPS_ALIGNBOUNDARYSRC &&
	    (prSrc->left % pdrv->ddCaps.dwAlignBoundarySrc) != 0)
	{
	    DPF_ERR("Source left misaligned...");
	    return DDERR_XALIGN;
	}

	if (pdrv->ddCaps.dwCaps & DDCAPS_ALIGNSIZEDEST &&
	    (dest_width % pdrv->ddCaps.dwAlignSizeDest) != 0)
	{
	    DPF_ERR("Destination width misaligned...");
	    return DDERR_XALIGN;
	}

	if (pdrv->ddCaps.dwCaps & DDCAPS_ALIGNSIZESRC  &&
	    (src_width % pdrv->ddCaps.dwAlignSizeSrc) != 0)
	{
	    DPF_ERR("Source width misaligned...");
	    return DDERR_XALIGN;
	}
    }

    /*
     * Are the source surface's caps the same as those of the previous sprite?
     */
    if ((surf_src_lcl->ddsCaps.dwCaps ^ pcaps->dwSrcSurfCaps) &
	    (DDSCAPS_SYSTEMMEMORY | DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM))
    {
	/*
	 * This source surface's memory type differs from that of the
	 * previous source surface, so we need to get a new set of caps.
	 */
	pcaps->dwSrcSurfCaps = surf_src_lcl->ddsCaps.dwCaps;
	initSpriteCaps(pcaps, pdrv);
    }

    /*
     * Get pixel-format flags for source surface.
     */
    dwDDPFSrcFlags = getPixelFormatFlags(surf_src_lcl);

    /*
     * If the source surface is palette-indexed, make sure a palette
     * is attached to it.
     */
    if (dwDDPFSrcFlags & (DDPF_PALETTEINDEXED1 | DDPF_PALETTEINDEXED2 |
			  DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8) &&
	    (surf_src_lcl->lpDDPalette == NULL ||
	     surf_src_lcl->lpDDPalette->lpLcl->lpGbl->lpColorTable == NULL))
    {
	DPF_ERR( "No palette associated with palette-indexed surface..." );
	LEAVE_BOTH();
	return DDERR_NOPALETTEATTACHED;
    }

    /*
     * Is any color keying required for this sprite?
     */
    if (pSprite->dwFlags & (DDSPRITE_KEYSRC  | DDSPRITE_KEYSRCOVERRIDE |
			    DDSPRITE_KEYDEST | DDSPRITE_KEYDESTOVERRIDE))
    {
	/*
	 * Validate source color-key flag.
	 */
	if (pSprite->dwFlags & (DDSPRITE_KEYSRC | DDSPRITE_KEYSRCOVERRIDE))
	{
	    if (!(pcaps->dwCKeyCaps & (DDCKEYCAPS_SRCBLT | DDCKEYCAPS_SRCOVERLAY)))
	    {
		pcaps->bNoHAL = TRUE;    // disqualify hardware driver
	    }
	    if (!(pcaps->dwHELCKeyCaps & (DDCKEYCAPS_SRCBLT | DDCKEYCAPS_SRCOVERLAY)))
	    {
		pcaps->bNoHEL = TRUE;    // disqualify HEL
	    }
	    if (dwDDPFSrcFlags & DDPF_ALPHAPIXELS)
	    {
		DPF_ERR("KEYSRC* illegal with source alpha channel...");
		return DDERR_INVALIDPARAMS;
	    }
	    if (pSprite->dwFlags & DDSPRITE_KEYSRC)
	    {
		if (!(!pcaps->bOverlay && surf_src_lcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT ||
		       pcaps->bOverlay && surf_src_lcl->dwFlags & DDRAWISURF_HASCKEYSRCOVERLAY))
		{
		    DPF_ERR("KEYSRC specified, but no color key...");
		    return DDERR_INVALIDPARAMS;
		}
		if (pSprite->dwFlags & DDSPRITE_KEYSRCOVERRIDE)
		{
		    DPF_ERR("Illegal to specify both KEYSRC and KEYSRCOVERRIDE...");
		    return DDERR_INVALIDPARAMS;
		}
		// Copy color key value from surface into DDSPRITEFX struct.
		pSprite->ddSpriteFX.ddckSrcColorkey = (pcaps->bOverlay) ?
						       surf_src_lcl->ddckCKSrcOverlay :
						       surf_src_lcl->ddckCKSrcBlt;
		// Turn off KEYSRC, turn on KEYSRCOVERRIDE.
		pSprite->dwFlags ^= DDSPRITE_KEYSRC | DDSPRITE_KEYSRCOVERRIDE;
	    }
	}

	/*
	 * Validate destination color-key flag.
	 */
	if (pSprite->dwFlags & (DDSPRITE_KEYDEST | DDSPRITE_KEYDESTOVERRIDE))
	{
	    if (!(pcaps->dwCKeyCaps & (DDCKEYCAPS_DESTBLT | DDCKEYCAPS_DESTOVERLAY)))
	    {
		pcaps->bNoHAL = TRUE;    // disqualify hardware driver
	    }
	    if (!(pcaps->dwHELCKeyCaps & (DDCKEYCAPS_DESTBLT | DDCKEYCAPS_DESTOVERLAY)))
	    {
		pcaps->bNoHEL = TRUE;    // disqualify HEL
	    }
	    if (dwDDPFDestFlags & DDPF_ALPHAPIXELS)
	    {
		DPF_ERR("KEYDEST* illegal with dest alpha channel...");
		return DDERR_INVALIDPARAMS;
	    }
	    if (pSprite->dwFlags & DDSPRITE_KEYDEST)
	    {
		if (!(!pcaps->bOverlay && surf_dest_lcl->dwFlags & DDRAWISURF_HASCKEYDESTBLT ||
		       pcaps->bOverlay && surf_dest_lcl->dwFlags & DDRAWISURF_HASCKEYDESTOVERLAY))
		{
		    DPF_ERR("KEYDEST specified, but no color key...");
		    return DDERR_INVALIDPARAMS;
		}
		if (pSprite->dwFlags & DDSPRITE_KEYDESTOVERRIDE)
		{
		    DPF_ERR("Illegal to specify both KEYDEST and KEYDESTOVERRIDE...");
		    return DDERR_INVALIDPARAMS;
		}
		// Copy color key value from surface into DDSPRITEFX struct.
		pSprite->ddSpriteFX.ddckDestColorkey = (pcaps->bOverlay) ?
							surf_src_lcl->ddckCKDestOverlay :
							surf_src_lcl->ddckCKDestBlt;
		// Turn off KEYDEST, turn on KEYDESTOVERRIDE.
		pSprite->dwFlags ^= DDSPRITE_KEYDEST | DDSPRITE_KEYDESTOVERRIDE;
	    }
	}

	if (pcaps->bNoHAL && pcaps->bNoHEL)
	{
	    DPF_ERR("No driver support for specified color-key operation");
	    return DDERR_UNSUPPORTED;
	}
    }

    /*
     * Assume hardware unable to handle sprite in system memory.
     * (Will this assumption remain true for future hardware?)
     */
    if (pcaps->bOverlay)
    {
	if (pcaps->dwSrcSurfCaps & DDSCAPS_SYSTEMMEMORY)
	{
	    pcaps->bNoHAL = TRUE;    // can't use hardware

	    if (pcaps->bNoHEL)    // but can we still emulate?
	    {
		// Nope, we can't emulate either, so fail the call.
		DPF_ERR("Driver can't handle sprite in system memory");
		return DDERR_UNSUPPORTED;
	    }
	}
    }
	
    /*
     * We do not allow blits or overlays with an optimized surface.
     */
    if (pcaps->dwSrcSurfCaps & DDSCAPS_OPTIMIZED)
    {
	DPF_ERR("Can't do blits or overlays with optimized surfaces...") ;
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Validate dwSize field in embedded DDSPRITEFX structure.
     */
    if (pSprite->ddSpriteFX.dwSize != sizeof(DDSPRITEFX))
    {
	DPF_ERR("Invalid dwSize value in DDSPRITEFX structure...");
	return DDERR_INVALIDPARAMS;
    }

    /*
     * If the RGBA scaling factors are effectively disabled by all being
     * set to 255 (all ones), just clear the RGBASCALING flag.
     */
    if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_RGBASCALING &&
    	    *(LPDWORD)&pSprite->ddSpriteFX.ddrgbaScaleFactors == ~0UL)
    {
	pSprite->ddSpriteFX.dwDDFX &= ~DDSPRITEFX_RGBASCALING;
    }

    /*
     * Is any kind of alpha blending required for this sprite?
     */
    if (dwDDPFSrcFlags & DDPF_ALPHAPIXELS ||
            !(pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_DEGRADERGBASCALING) &&
	    pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_RGBASCALING)
    {
    	/*
	 * Yes, this sprite requires some form of alpha blending.
	 * Does the driver support any kind of alpha blending at all?
	 */
	if (!(pcaps->dwFXCaps & (DDFXCAPS_BLTALPHA | DDFXCAPS_OVERLAYALPHA)))
	{
	    pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	}
	if (!(pcaps->dwHELFXCaps & (DDFXCAPS_BLTALPHA | DDFXCAPS_OVERLAYALPHA)))
	{
	    pcaps->bNoHEL = TRUE;   // disqualify HEL
	}

	if (pcaps->bNoHAL && pcaps->bNoHEL)
	{
	    DPF_ERR("Driver can't do any kind of alpha blending at all...");
	    return DDERR_UNSUPPORTED;
	}

	/*
	 * Does source surface have an alpha channel?
	 */
	if (dwDDPFSrcFlags & DDPF_ALPHAPIXELS)
	{
	    /*
	     * Can the driver handle this surface's alpha-channel format?
	     */
	    if (dwDDPFSrcFlags & DDPF_ALPHAPREMULT)
	    {
		// The source is in premultiplied-alpha format.
		if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTPREMULT |
					    DDALPHACAPS_OVERLAYPREMULT)))
		{
		    pcaps->bNoHAL = TRUE;	// disqualify hardware driver
		}
		if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTPREMULT |
					       DDALPHACAPS_OVERLAYPREMULT)))
		{
		    pcaps->bNoHEL = TRUE;	// disqualify HEL
		}
	    }
	    else
	    {
		// The source is in NON-premultiplied-alpha format.
		if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTNONPREMULT |
					    DDALPHACAPS_OVERLAYNONPREMULT)))
		{
		    pcaps->bNoHAL = TRUE;	// disqualify hardware driver
		}
		if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTNONPREMULT |
					       DDALPHACAPS_OVERLAYNONPREMULT)))
		{
		    pcaps->bNoHEL = TRUE;	// disqualify HEL
		}
	    }
	    if (pcaps->bNoHAL && pcaps->bNoHEL)
	    {
		DPF_ERR("Driver can't handle alpha channel in source surface...");
		return DDERR_NOALPHAHW;
	    }
	}

	/*
	 * Does the destination surface have an alpha channel?
	 */
	if (dwDDPFDestFlags & DDPF_ALPHAPIXELS)
	{
	    /*
	     * Verify that destination surface has a premultiplied-
	     * alpha pixel format.  Non-premultiplied alpha won't do.
	     */
	    if (!(dwDDPFDestFlags & DDPF_ALPHAPREMULT))
	    {
		DPF_ERR("Illegal to use non-premultiplied alpha in dest surface...");
		return DDERR_INVALIDPARAMS;
	    }
	    /*
	     * Can the driver handle this surface's alpha-channel format?
	     */
	    if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTPREMULT |
					DDALPHACAPS_OVERLAYPREMULT)))
	    {
		pcaps->bNoHAL = TRUE;	// disqualify hardware driver
	    }
	    if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTPREMULT |
					   DDALPHACAPS_OVERLAYPREMULT)))
	    {
		pcaps->bNoHEL = TRUE;	// disqualify HEL
	    }
	    if (pcaps->bNoHAL && pcaps->bNoHEL)
	    {
		DPF_ERR("Driver can't handle alpha channel in dest surface...");
		return DDERR_NOALPHAHW;
	    }
	}

	/*
	 * Are the RGBA scaling factors enabled for this sprite?
	 */
        if (!(pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_DEGRADERGBASCALING) &&
		*(LPDWORD)&pSprite->ddSpriteFX.ddrgbaScaleFactors != ~0UL)
	{
	    DDRGBA val = pSprite->ddSpriteFX.ddrgbaScaleFactors;

	    /*
	     * Yes, RGBA scaling is enabled.  Does driver support it?
	     */
	    if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTRGBASCALE1F | DDALPHACAPS_OVERLAYRGBASCALE1F |
					DDALPHACAPS_BLTRGBASCALE2F | DDALPHACAPS_OVERLAYRGBASCALE2F |
					DDALPHACAPS_BLTRGBASCALE4F | DDALPHACAPS_OVERLAYRGBASCALE4F)))
	    {
		pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	    }
	    if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTRGBASCALE1F | DDALPHACAPS_OVERLAYRGBASCALE1F |
					   DDALPHACAPS_BLTRGBASCALE2F | DDALPHACAPS_OVERLAYRGBASCALE2F |
					   DDALPHACAPS_BLTRGBASCALE4F | DDALPHACAPS_OVERLAYRGBASCALE4F)))
	    {
		pcaps->bNoHEL = TRUE;   // disqualify HEL
	    }
	    if (pcaps->bNoHAL && pcaps->bNoHEL)
	    {
		DPF_ERR("Driver can't do any kind of RGBA scaling at all...");
		return DDERR_UNSUPPORTED;
	    }

	    if (val.red > val.alpha || val.green > val.alpha || val.blue > val.alpha)
	    {
		
		if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTSATURATE |
					    DDALPHACAPS_OVERLAYSATURATE)))
		{
		    pcaps->bNoHAL = TRUE;   // disqualify hardware driver
		}
		if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTSATURATE |
					       DDALPHACAPS_OVERLAYSATURATE)))
		{
		    pcaps->bNoHEL = TRUE;   // disqualify HEL
		}
	    }
	    if (val.red != val.green || val.red != val.blue)
	    {
		if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTRGBASCALE4F |
					    DDALPHACAPS_OVERLAYRGBASCALE4F)))
		{
		    pcaps->bNoHAL = TRUE;   // disqualify hardware driver
		}
		if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTRGBASCALE4F |
					       DDALPHACAPS_OVERLAYRGBASCALE4F)))
		{
		    pcaps->bNoHEL = TRUE;   // disqualify HEL
		}
	    } else if (*(LPDWORD)&val != val.alpha*0x01010101UL)
	    {
		if (!(pcaps->dwAlphaCaps & (DDALPHACAPS_BLTRGBASCALE2F |
					    DDALPHACAPS_OVERLAYRGBASCALE2F)))
		{
		    pcaps->bNoHAL = TRUE;   // disqualify hardware driver
		}
		if (!(pcaps->dwHELAlphaCaps & (DDALPHACAPS_BLTRGBASCALE2F |
					       DDALPHACAPS_OVERLAYRGBASCALE2F)))
		{
		    pcaps->bNoHEL = TRUE;   // disqualify HEL
		}
	    }
	    if (pcaps->bNoHAL && pcaps->bNoHEL)
	    {
		DPF_ERR("Driver can't handle specified RGBA scaling factors...");
		return DDERR_UNSUPPORTED;
	    }
	}
    }

    /*
     * Is any kind of filtering required for this sprite?
     */
    if (!(pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_DEGRADEFILTER) &&
	    pSprite->ddSpriteFX.dwDDFX & (DDSPRITEFX_BILINEARFILTER |
					 DDSPRITEFX_BLURFILTER |
					 DDSPRITEFX_FLATFILTER))
    {
	/*
	 * The bilinear-, blur-, and flat-filtering options are mutually
	 * exclusive.  Make sure only one of these flags is set.
	 */
	DWORD fflags = pSprite->ddSpriteFX.dwDDFX & (DDSPRITEFX_BILINEARFILTER |
						       DDSPRITEFX_BLURFILTER |
						       DDSPRITEFX_FLATFILTER);
	if (fflags & (fflags - 1))
	{
    	    DPF_ERR("Two mutually exclusive filtering options were both specified");
	    return DDERR_INVALIDPARAMS;
	}

	/*
	 * Yes, this sprite requires some form of filtering.
	 * Does the driver support any kind of filtering at all?
	 */
	if (!(pcaps->dwFXCaps & (DDFXCAPS_BLTFILTER | DDFXCAPS_OVERLAYFILTER)))
	{
	    pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	}
	if (!(pcaps->dwHELFXCaps & (DDFXCAPS_BLTFILTER | DDFXCAPS_OVERLAYFILTER)))
	{
	    pcaps->bNoHEL = TRUE;   // disqualify HEL
	}
	
	if (pcaps->bNoHAL && pcaps->bNoHEL)
	{
	    DPF_ERR("Driver can't do any kind of filtering at all");
	    return DDERR_UNSUPPORTED;
	}

	if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_BILINEARFILTER)
	{
	    if (!(pcaps->dwFilterCaps & (DDFILTCAPS_BLTBILINEARFILTER |
					 DDFILTCAPS_OVERLAYBILINEARFILTER)))
	    {
		pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	    }
	    if (!(pcaps->dwHELFilterCaps & (DDFILTCAPS_BLTBILINEARFILTER |
					    DDFILTCAPS_OVERLAYBILINEARFILTER)))
	    {
		pcaps->bNoHEL = TRUE;   // disqualify HEL
	    }
	}
	if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_BLURFILTER)
	{
	    if (!(pcaps->dwFilterCaps & (DDFILTCAPS_BLTBLURFILTER |
					 DDFILTCAPS_OVERLAYBLURFILTER)))
	    {
		pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	    }
	    if (!(pcaps->dwHELFilterCaps & (DDFILTCAPS_BLTBLURFILTER |
					    DDFILTCAPS_OVERLAYBLURFILTER)))
	    {
		pcaps->bNoHEL = TRUE;   // disqualify HEL
	    }
	}
	if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_FLATFILTER)
	{
	    if (!(pcaps->dwFilterCaps & (DDFILTCAPS_BLTFLATFILTER |
					 DDFILTCAPS_OVERLAYFLATFILTER)))
	    {
		pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	    }
	    if (!(pcaps->dwHELFilterCaps & (DDFILTCAPS_BLTFLATFILTER |
					    DDFILTCAPS_OVERLAYFLATFILTER)))
	    {
		pcaps->bNoHEL = TRUE;   // disqualify HEL
	    }
	}
	if (pcaps->bNoHAL && pcaps->bNoHEL)
	{
	    DPF_ERR("Driver can't do specified filtering operation...");
	    return DDERR_UNSUPPORTED;
	}
    }

    /*
     * Can the driver handle the specified affine transformation?
     */
    if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_AFFINETRANSFORM)
    {
    	/*
	 * Can the driver do any affine transformations at all?
	 */
	if (!pcaps->bNoHAL &&
		(!(pcaps->dwFXCaps & (DDFXCAPS_BLTTRANSFORM | DDFXCAPS_OVERLAYTRANSFORM)) ||
    		!(pcaps->dwTransformCaps & (DDTFRMCAPS_BLTAFFINETRANSFORM |
					    DDTFRMCAPS_OVERLAYAFFINETRANSFORM))))
	{
            pcaps->bNoHAL = TRUE;   // disqualify hardware driver
	}
	if (!pcaps->bNoHEL &&
		(!(pcaps->dwHELFXCaps & (DDFXCAPS_BLTTRANSFORM | DDFXCAPS_OVERLAYTRANSFORM)) ||
    		!(pcaps->dwHELTransformCaps & (DDTFRMCAPS_BLTAFFINETRANSFORM |
					       DDTFRMCAPS_OVERLAYAFFINETRANSFORM))))
	{
            pcaps->bNoHEL = TRUE;   // disqualify HEL
	}

	if (pcaps->bNoHAL && pcaps->bNoHEL)
	{
	    DPF_ERR("Driver can't do any affine transformations...");
	    return DDERR_UNSUPPORTED;
	}

	/*
	 * Check affine transformation against driver's minification limits.
	 */
	checkMinification(&pSprite->ddSpriteFX, pcaps);

	if (pcaps->bNoHAL && pcaps->bNoHEL)
	{
	    DPF_ERR("Affine transform exceeds driver's minification limit...");
	    return DDERR_INVALIDPARAMS;
	}
    }

    /*
     * If necessary, degrade specified filtering and RGBA-scaling operations
     * to operations that the driver is capable of handling.
     */
    if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_DEGRADEFILTER)
    {
	DWORD caps;
	DWORD ddfx = pSprite->ddSpriteFX.dwDDFX;   // sprite FX flags

	// driver's FX caps
	caps = (pcaps->bNoHAL) ? pcaps->dwHELFXCaps : pcaps->dwFXCaps;

	if (!(caps && (DDFXCAPS_BLTFILTER | DDFXCAPS_OVERLAYFILTER)))
	{
	    // Driver can't do any kind of filtering, so just disable it.
	    ddfx &= ~(DDSPRITEFX_BILINEARFILTER | DDSPRITEFX_BLURFILTER |
		       DDSPRITEFX_FLATFILTER | DDSPRITEFX_DEGRADEFILTER);
	}
	else
	{
	    // Get driver's filter caps.
	    caps = (pcaps->bNoHAL) ? pcaps->dwHELFilterCaps : pcaps->dwFilterCaps;

	    // If blur filter is specified, can driver handle it?
	    if (ddfx & DDSPRITEFX_BLURFILTER &&
		    !(caps & (DDFILTCAPS_BLTBLURFILTER |
			      DDFILTCAPS_OVERLAYBLURFILTER)))
	    {
		// Degrade blur filter to bilinear filter.
		ddfx &= ~DDSPRITEFX_BLURFILTER;
		ddfx |= DDSPRITEFX_BILINEARFILTER;
	    }
	    // If flat filter is specified, can driver handle it?
	    if (ddfx & DDSPRITEFX_FLATFILTER &&
		    !(caps & (DDFILTCAPS_BLTFLATFILTER |
			      DDFILTCAPS_OVERLAYFLATFILTER)))
	    {
		// Degrade flat filter to bilinear filter.
		ddfx &= ~DDSPRITEFX_FLATFILTER;
		ddfx |= DDSPRITEFX_BILINEARFILTER;
	    }
	    // If bilinear filter is specified, can driver handle it?
	    if (ddfx & DDSPRITEFX_BILINEARFILTER &&
		    !(caps & (DDFILTCAPS_BLTBILINEARFILTER |
			      DDFILTCAPS_OVERLAYBILINEARFILTER)))
	    {
		// Degrade bilinear filtering to no filtering.
		ddfx &= ~DDSPRITEFX_BILINEARFILTER;
	    }
	}
	pSprite->ddSpriteFX.dwDDFX = ddfx & ~DDSPRITEFX_DEGRADEFILTER;
    }

    /*
     * If necessary, degrade specified RGBA scaling factors to values
     * that the driver is capable of handling.
     */
    if (pSprite->ddSpriteFX.dwDDFX & DDSPRITEFX_DEGRADERGBASCALING &&
	    *(LPDWORD)&pSprite->ddSpriteFX.ddrgbaScaleFactors != ~0UL)
    {
	DDRGBA val = pSprite->ddSpriteFX.ddrgbaScaleFactors;
	DWORD caps;

	// driver's alpha caps
	caps = (pcaps->bNoHAL) ? pcaps->dwHELAlphaCaps : pcaps->dwAlphaCaps;

	/*
	 * We permit the RGB scaling factors to exceed the alpha scaling
	 * factor only if the driver can do saturated alpha arithmetic to
	 * prevent the destination color components from overflowing.
	 */
	if ((val.red > val.alpha || val.green > val.alpha || val.blue > val.alpha) &&
		!(caps & (DDALPHACAPS_BLTSATURATE | DDALPHACAPS_OVERLAYSATURATE)))
	{
	    // Driver can't handle saturated arithmetic during alpha blending.
	    if (val.red > val.alpha)
	    {
		val.red = val.alpha;      // clamp red to alpha value
	    }
	    if (val.green > val.alpha)
	    {
		val.green = val.alpha;    // clamp green to alpha value
	    }
	    if (val.blue > val.alpha)
	    {
		val.blue = val.alpha;     // clamp blue to alpha value
	    }
	}
	/*
	 * Can driver perform 1-, 2-, or 4-factor RGBA scaling?
	 */
	if (!(caps & (DDALPHACAPS_BLTRGBASCALE1F | DDALPHACAPS_OVERLAYRGBASCALE1F |
		      DDALPHACAPS_BLTRGBASCALE2F | DDALPHACAPS_OVERLAYRGBASCALE2F |
		      DDALPHACAPS_BLTRGBASCALE4F | DDALPHACAPS_OVERLAYRGBASCALE4F)))
	{
	    // Driver can't do any kind of RGBA scaling at all.
	    *(LPDWORD)&val = ~0UL;	   // disable RGBA scaling altogether
	}
	else if (*(LPDWORD)&val != val.alpha*0x01010101UL &&
		!(caps & (DDALPHACAPS_BLTRGBASCALE2F | DDALPHACAPS_OVERLAYRGBASCALE2F |
			  DDALPHACAPS_BLTRGBASCALE4F | DDALPHACAPS_OVERLAYRGBASCALE4F)))
	{
	    // Driver can handle only 1-factor RGBA scaling.
	    *(LPDWORD)&val = val.alpha*0x01010101UL;   // set RGB factors = alpha factor
	}
	else if ((val.red != val.green || val.red != val.blue) &&
		!(caps & (DDALPHACAPS_BLTRGBASCALE4F | DDALPHACAPS_OVERLAYRGBASCALE4F)))
	{
	    /*
	     * Degrade the specified 4-factor RGBA-scaling operation to a 2-factor
	     * RGBA scaling operation that the driver can handle.  Set all three
	     * color factors to weighted average M of the specified color factors
	     * (Mr,Mg,Mb):  M = .299*Mr + .587*Mg + .114*Mb
	     */
	    DWORD M = 19595UL*val.red + 38470UL*val.green + 7471UL*val.blue;

	    val.red = val.green = val.blue = (BYTE)(M >> 16);
	}
	pSprite->ddSpriteFX.ddrgbaScaleFactors = val;
	pSprite->ddSpriteFX.dwDDFX &= ~DDSPRITEFX_DEGRADERGBASCALING;
    }

    /*
     * If the embedded DDSPRITEFX structure is unused, clear DDSPRITEFX flag.
     */
    if (!(pSprite->dwFlags & (DDSPRITE_KEYDESTOVERRIDE | DDSPRITE_KEYSRCOVERRIDE)) &&
    	    pSprite->ddSpriteFX.dwDDFX == 0)
    {
	pSprite->dwFlags &= ~DDSPRITE_DDSPRITEFX;
    }

    DDASSERT(!(pcaps->bNoHAL && pcaps->bNoHEL));

    return DD_OK;

}  /* validateSprite */


/*
 * Obtain clipping region for a destination surface and its attached
 * clipper.  (In the case of overlay sprites in the master sprite
 * list, though, pClipper points to the clipper that WAS attached to
 * the destination surface at the time of the SetSpriteDisplayList
 * call; it may no longer be if an app manages multiple windows.)
 * If pClipper is NULL, just use the whole dest surf as the clip rect.
 * A NULL return value always means DDERR_OUTOFMEMORY.
 */
static LPRGNDATA GetRgnData(LPDIRECTDRAWCLIPPER pClipper, LPRECT prcDestSurf,
			    LPDDRAWI_DIRECTDRAW_GBL pdrv, LPRGNDATA pRgn)
{
    DWORD rgnSize;

    /*
     * How big a buffer will we need to contain the clipping region?
     */
    if (pClipper == NULL)
    {
        /*
         * The destination surface has (or HAD) no attached clipper,
	 * so the effective clip region is a single rectangle the width
	 * and height of the primary surface.  Calculate the size of
	 * the region buffer we'll need.
         */
	rgnSize = sizeof(RGNDATAHEADER) + sizeof(RECT);
    }
    else
    {
	/*
         * The dest surface has (or HAD) an attached clipper.  Get
	 * the clip list.  This first call to InternalGetClipList
	 * just gets the size of the region so we know how much
	 * storage to allocate for it.
         */
        HRESULT ddrval = InternalGetClipList(pClipper,
					     prcDestSurf,
					     NULL,  // we just want rgnSize
					     &rgnSize,
					     pdrv);

	DDASSERT(ddrval == DD_OK);    // the call above should never fail
    }

    /*
     * Now we know how big a region buffer we'll need.  Did the caller
     * pass in a region buffer?  If so, is it the correct size?
     */
    if (pRgn != NULL)
    {
	/*
	 * The caller DID pass in a region buffer.  Before using it,
	 * let's make sure it's just the right size.
	 */
	DWORD bufSize = pRgn->rdh.dwSize + pRgn->rdh.nRgnSize;

	if (bufSize != rgnSize)
	{
	    // Can't use region buffer passed in by caller.
	    pRgn = NULL;
	}
    }

    /*
     * Now we know whether we'll have to alloc our own region buffer.
     */
    if (pRgn == NULL)
    {
	/*
	 * Yes, we must alloc our own region buffer.
	 */
	pRgn = (LPRGNDATA)MemAlloc(rgnSize);
	if (!pRgn)
	{
	    return NULL;    // error -- out of memory
	}
	// We'll fill in the following fields in case the caller
	// passes this same buffer to us again later.
	pRgn->rdh.dwSize = sizeof(RGNDATAHEADER);
	pRgn->rdh.nRgnSize = rgnSize - sizeof(RGNDATAHEADER);
    }

    /*
     * Okay, now we have a region buffer that's the right size.
     * Load the region data into the buffer.
     */
    if (pClipper == NULL)
    {
	// Set the single clip rect to cover the full dest surface.
	pRgn->rdh.nCount = 1;        // a single clip rect
	memcpy((LPRECT)&pRgn->Buffer, prcDestSurf, sizeof(RECT));
    }
    else
    {
        // This call actually retrieves the clip region info.
	HRESULT ddrval = InternalGetClipList(pClipper,
					     prcDestSurf,
					     pRgn,
					     &rgnSize,
					     pdrv);

	DDASSERT(ddrval == DD_OK);    // the call above should never fail
    }

    return (pRgn);    // return pointer to region info

}  /* GetRgnData */


/*
 * Validate the window handle associated with the specified clipper.
 * If the window handle is not valid, return FALSE.  Otherwise,
 * return TRUE.  Note that this function returns TRUE if either
 * pClipper is null or the associated window handle is null.
 */
static BOOL validClipperWindow(LPDIRECTDRAWCLIPPER pClipper)
{
    if (pClipper != NULL)
    {
        LPDDRAWI_DDRAWCLIPPER_INT pclip_int = (LPDDRAWI_DDRAWCLIPPER_INT)pClipper;
	LPDDRAWI_DDRAWCLIPPER_LCL pclip_lcl = pclip_int->lpLcl;
	LPDDRAWI_DDRAWCLIPPER_GBL pclip = pclip_lcl->lpGbl;
	HWND hWnd = (HWND)pclip->hWnd;

	if (hWnd != 0 && !IsWindow(hWnd))
	{
	    /*
	     * This window handle is no longer valid.
	     */
	    return FALSE;
	}
    }
    return TRUE;

}  /* validClipperWindow */


/*
 * Helper function for managing sublists within the master sprite
 * list.  If any sprites in the specified sublist have source surface
 * pointers that are null, remove those sprites and move the rest of
 * the sprite array downward to eliminate the gaps in the array.
 */
static DWORD scrunchSubList(LPSPRITESUBLIST pSubList)
{
    DWORD i, j;
    // Number of sprites in sublist
    DWORD dwNumSprites = pSubList->dwCount;
    // Pointer to first sprite in array of sprites
    LPDDSPRITEI pSprite = &pSubList->sprite[0];

    // Find first null surface in sprite array.
    for (i = 0; i < dwNumSprites; ++i)
    {
    	if (pSprite[i].lpDDSSrc == NULL)	  // null surface ptr?
	{
	    break;    // found first null surface in sprite array
	}
    }
    // Scrunch together remainder of sprite array to fill in gaps.
    for (j = i++; i < dwNumSprites; ++i)
    {
    	if (pSprite[i].lpDDSSrc != NULL)	  // valid surface ptr?
	{
    	    pSprite[j++] = pSprite[i];   // copy next valid sprite
	}
    }
    // Return number of sprites in scrunched array.
    return (pSubList->dwCount = j);

}  /* scrunchSubList */


/*
 * Helper function for managing master sprite list.  If any of the
 * sublist pointers in the master-sprite-list header are NULL,
 * remove those pointers and move the rest of the sublist-
 * pointer array downward to eliminate the gaps in the array.
 */
static DWORD scrunchMasterSpriteList(LPMASTERSPRITELIST pMaster)
{
    DWORD i, j;
    // Number of sublists in master sprite list
    DWORD dwNumSubLists = pMaster->dwNumSubLists;
    // Pointer to first pointer in array of sublist pointers
    LPSPRITESUBLIST *ppSubList = &pMaster->pSubList[0];

    // Find first null pointer in sublist-pointer array.
    for (i = 0; i < dwNumSubLists; ++i)
    {
    	if (ppSubList[i] == NULL)	  // null pointer?
	{
	    break;    // found first null pointer in array
	}
    }
    // Scrunch together remainder of sublist-pointer array to fill in gaps.
    for (j = i++; i < dwNumSubLists; ++i)
    {
    	if (ppSubList[i] != NULL)	  // valid pointer?
	{
    	    ppSubList[j++] = ppSubList[i];   // copy next valid pointer
	}
    }
    // Return number of sublist pointers in scrunched array.
    return (pMaster->dwNumSubLists = j);

}  /* scrunchMasterSpriteList */


/*
 * Helper function for managing master sprite list.  Mark all surface
 * and clipper objects that are referenced in the master sprite list.
 * When a marked surface or clipper object is released, the master
 * sprite list is immediately updated to eliminate invalid references.
 * The master sprite list contains pointers to surface and clipper
 * interface objects, but marks the surfaces and clippers by setting
 * flags in the local surface and global clipper objects.  Because
 * the master sprite list may contain multiple instances of the same
 * surface or clipper object, we mark and unmark all such objects in
 * unison to avoid errors.
 */
static void markSpriteObjects(LPMASTERSPRITELIST pMaster)
{
    DWORD i;

    if (pMaster == NULL)
    {
    	return;    // nothing to do -- bye!
    }

    /*
     * Set the DDRAWISURF/CLIP_INMASTERSPRITELIST flag in each local
     * surface object and global clipper object in the master sprite
     * list.  Each iteration marks the objects in one sublist.
     */
    for (i = 0; i < pMaster->dwNumSubLists; ++i)
    {
	LPDDRAWI_DDRAWSURFACE_INT surf_int;
	LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
	LPDDRAWI_DDRAWCLIPPER_INT pclip_int;
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDDSPRITEI sprite = &pSubList->sprite[0];
	DWORD dwNumSprites = pSubList->dwCount;
	DWORD j;

	/*
	 * Mark the primary surface object associated with this sublist.
	 */
	surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pSubList->pPrimary;
	surf_lcl = surf_int->lpLcl;
	surf_lcl->dwFlags |= DDRAWISURF_INMASTERSPRITELIST;

	/*
	 * If a clipper is associated with this sublist, mark it.
	 */
	pclip_int = (LPDDRAWI_DDRAWCLIPPER_INT)pSubList->pClipper;
	if (pclip_int != NULL)
	{
    	    LPDDRAWI_DDRAWCLIPPER_LCL pclip_lcl = pclip_int->lpLcl;
    	    LPDDRAWI_DDRAWCLIPPER_GBL pclip = pclip_lcl->lpGbl;

	    pclip->dwFlags |= DDRAWICLIP_INMASTERSPRITELIST;
	}

	/*
	 * Mark the source surface for each sprite in this sublist.
	 */
	for (j = 0; j < dwNumSprites; ++j)
	{
	    LPDDRAWI_DDRAWSURFACE_INT surf_int;
    	    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
	    LPDDSPRITEI pSprite = &sprite[j];

	    surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pSprite->lpDDSSrc;
	    surf_lcl = surf_int->lpLcl;
	    surf_lcl->dwFlags |= DDRAWISURF_INMASTERSPRITELIST;
	}
    }
}   /* markSpriteObjects */


/*
 * Helper function for managing master sprite list.
 * Mark all surfaces in the master sprite list as no longer
 * referenced by the master sprite list.
 */
static void unmarkSpriteObjects(LPMASTERSPRITELIST pMaster)
{
    DWORD i;

    if (pMaster == NULL)
    {
    	return;    // nothing to do -- bye!
    }

    /*
     * Clear the DDRAWISURF/CLIP_INMASTERSPRITELIST flag in each local
     * surface object and global clipper object in the master sprite
     * list.  Each iteration unmarks the objects in one sublist.
     */
    for (i = 0; i < pMaster->dwNumSubLists; ++i)
    {
	LPDDRAWI_DDRAWSURFACE_INT surf_int;
	LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
	LPDDRAWI_DDRAWCLIPPER_INT pclip_int;
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDDSPRITEI sprite = &pSubList->sprite[0];
	DWORD dwNumSprites = pSubList->dwCount;
	DWORD j;

	/*
	 * Unmark the primary surface object associated with this sublist.
	 */
	surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pSubList->pPrimary;
	surf_lcl = surf_int->lpLcl;
	surf_lcl->dwFlags &= ~DDRAWISURF_INMASTERSPRITELIST;

	/*
	 * If a clipper is associated with this sublist, unmark it.
	 */
	pclip_int = (LPDDRAWI_DDRAWCLIPPER_INT)pSubList->pClipper;
	if (pclip_int != NULL)
	{
    	    LPDDRAWI_DDRAWCLIPPER_LCL pclip_lcl = pclip_int->lpLcl;
    	    LPDDRAWI_DDRAWCLIPPER_GBL pclip = pclip_lcl->lpGbl;

	    pclip->dwFlags &= ~DDRAWICLIP_INMASTERSPRITELIST;
	}

	/*
	 * Mark all of the surfaces referenced in this sublist.
	 */
	for (j = 0; j < dwNumSprites; ++j)
	{
    	    LPDDRAWI_DDRAWSURFACE_INT surf_int;
    	    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
	    LPDDSPRITEI pSprite = &sprite[j];

	    surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pSprite->lpDDSSrc;
	    surf_lcl = surf_int->lpLcl;
	    surf_lcl->dwFlags &= ~DDRAWISURF_INMASTERSPRITELIST;
	}
    }
}   /* unmarkSpriteObjects */


/*
 * Helper function for managing master sprite list.  This function
 * frees the master sprite list for the specified DirectDraw object.
 */
void FreeMasterSpriteList(LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    DWORD i;
    LPMASTERSPRITELIST pMaster = (LPMASTERSPRITELIST)(pdrv->lpMasterSpriteList);

    if (pMaster == NULL)
    {
    	return;
    }
    /*
     * Clear flags in surface and clipper objects that indicate
     * that these objects are referenced in master sprite list.
     */
    unmarkSpriteObjects(pMaster);
    /*
     * Free all the individual sublists within the master sprite list.
     */
    for (i = 0; i < pMaster->dwNumSubLists; ++i)
    {
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];

	MemFree(pSubList->pRgn);   // Free clip region buffer
	MemFree(pSubList);	   // Free the sublist itself
    }
    MemFree(pMaster->pBuffer);	   // Free temp display list buffer
    MemFree(pMaster);		   // Free master sprite list header

    pdrv->lpMasterSpriteList = NULL;

}  /* FreeMasterSpriteList */


/*
 * This is a helper function for updateMasterSpriteList().  It builds
 * a temporary display list that contains all the sprites currently in
 * the master sprite display list.  This is the display list that we
 * will pass to the driver upon return from updateMasterSpriteList().
 */
static DDHAL_SETSPRITEDISPLAYLISTDATA *buildTempDisplayList(
					    LPMASTERSPRITELIST pMaster)
{
    DWORD size;
    LPBUFFER pbuf;
    LPDDSPRITEI *ppSprite;
    DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData;
    DWORD dwNumSubLists = pMaster->dwNumSubLists;   // number of sublists
    DWORD dwNumSprites = 0;
    DWORD i;

    /*
     * Update the clipping region for the sprites within each sublist.
     * In general, each sublist has a different clipping region.  If
     * a sublist has a clipper and that clipper has an hWnd, the clip
     * region may have changed since the last time we were called.
     */
    for (i = 0; i < dwNumSubLists; ++i)
    {
	DWORD j;
	LPRGNDATA pRgn;
	DWORD dwRectCnt;
	LPRECT pRect;
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDDSPRITEI sprite = &(pSubList->sprite[0]);
	DWORD dwCount = pSubList->dwCount;   // number of sprites in sublist

	/*
	 * Get clipping region for window this sprite display list is in.
	 */
	pRgn = GetRgnData(pSubList->pClipper, &pMaster->rcPrimary,
					pMaster->pdrv, pSubList->pRgn);
	if (pRgn == NULL)
	{
    	    return (NULL);    // error -- out of memory
	}
	if (pRgn != pSubList->pRgn)
	{
	    /*
	     * GetRgnData() allocated a new region buffer instead of using
	     * the old buffer.  We need to free the old buffer ourselves.
	     */
	    MemFree(pSubList->pRgn);
	}
	pSubList->pRgn = pRgn;	  // save ptr to region buffer
	/*
	 * All sprites in the sublist share the same clipping region.
	 */
        dwRectCnt = pRgn->rdh.nCount;   // number of rects in region
	pRect = (LPRECT)&pRgn->Buffer;  // list of clip rects

	for (j = 0; j < dwCount; ++j)
	{
    	    sprite[j].dwRectCnt = dwRectCnt;
	    sprite[j].lpRect = pRect;
	}
	/*
	 * Add the sprites in this sublist to our running tally of
	 * the total number of sprites in the master sprite list.
	 */
	dwNumSprites += dwCount;
    }

    /*
     * If we can, we'll build our temporary sprite display list in the
     * existing buffer (pMaster->pBuffer).  But if it doesn't exist or
     * is too big or too small, we'll have to allocate a new buffer.
     */
    size = sizeof(BUFFER) + (dwNumSprites-1)*sizeof(LPDDSPRITEI);
    pbuf = pMaster->pBuffer;   // try to re-use this buffer

    if (pbuf == NULL || pbuf->dwSize < size ||
		pbuf->dwSize > size + 8*sizeof(LPDDSPRITEI))
    {
	/*
	 * We have to allocate a new buffer.  First, free the old one.
	 */
	MemFree(pbuf);
	/*
	 * We'll alloc a slightly larger buffer than is absolutely
	 * necessary so that we'll have room to grow in.
	 */
        size += 4*sizeof(LPDDSPRITEI);    // add some padding
	pbuf = (LPBUFFER)MemAlloc(size);
	pMaster->pBuffer = pbuf;
	if (pbuf == NULL)
	{
	    return NULL;    // error -- out of memory
	}
	pbuf->dwSize = size;
    }
    /*
     * Initialize values in HAL data structure to be passed to driver.
     */
    pHalData = &(pbuf->HalData);
    pHalData->lpDD = pMaster->pdrv;
    pHalData->lpDDSurface = pMaster->surf_lcl;   // primary surface (local object)
    pHalData->lplpDDSprite = &(pbuf->pSprite[0]);
    pHalData->dwCount = dwNumSprites;
    pHalData->dwSize = sizeof(DDSPRITEI);
    pHalData->dwFlags =	pMaster->dwFlags;
    pHalData->lpDDTargetSurface = NULL;	  // can't flip shared surface
    pHalData->dwRectCnt = 0;
    pHalData->lpRect = NULL;   // each sprite has its own clip region
    pHalData->ddRVal = 0;
    //pHalData->SetSpriteDisplayList = NULL;    // no thunk (32-bit callback)
    /*
     * Load the sprite-pointer array with the pointers to
     * all the sprites contained in the various sublists.
     */
    ppSprite = &pbuf->pSprite[0];

    for (i = 0; i < dwNumSubLists; ++i)
    {
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDDSPRITEI sprite = &pSubList->sprite[0];
	DWORD dwCount = pSubList->dwCount;   // number of sprites in sublist i
	DWORD j;

	for (j = 0; j < dwCount; ++j)
	{
    	    /*
	     * Copy address of next sprite into pointer array.
	     */
	    *ppSprite++ = &sprite[j];
	}
    }
    return (&pbuf->HalData);    // return temp sprite display list

}  /* buildTempDisplayList */


/*
 * Global function for managing master sprite list.  This function
 * is called by CurrentProcessCleanup to remove from the master
 * sprite list all references to a process that is being terminated.
 * The function also checks for lost surfaces in the master sprite
 * list.  If any changes are made to the master sprite list, the
 * driver is told to display those changes immediately.
 */
void ProcessSpriteCleanup(LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid)
{
    LPMASTERSPRITELIST pMaster = (LPMASTERSPRITELIST)pdrv->lpMasterSpriteList;
    LPDIRECTDRAWSURFACE pPrimary;
    DWORD dwNumSubLists;
    BOOL bDeleteSubList = FALSE;
    BOOL bChangesMade = FALSE;
    DWORD i;

    if (pMaster == NULL)
    {
    	return;    // master sprite list does not exist
    }

    pPrimary = pMaster->pSubList[0]->pPrimary;
    dwNumSubLists = pMaster->dwNumSubLists;

    /*
     * Before making changes to the master sprite list, we first
     * unmark all clipper and surface objects in the list.  After
     * the changes are completed, we will again mark the objects
     * that are referenced in the revised master sprite list.
     */
    unmarkSpriteObjects(pMaster);

    /*
     * Each sublist of the master sprite list contains all the sprites
     * that are to appear within a particular window of a shared primary.
     * Associated with each sublist is the process ID for the window.
     * Compare this process ID with argument pid.  If they match,
     * delete the sublist from the master sprite list.
     */
    for (i = 0; i < dwNumSubLists; ++i)
    {
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDIRECTDRAWSURFACE pPrimary = pSubList->pPrimary;
	LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pPrimary;
	LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = surf_int->lpLcl;

	/*
	 * Is process associated with this sublist being terminated?
	 * (We also check for lost surfaces and delete any we find.)
	 */
	if (pSubList->dwProcessId != pid &&
				    validClipperWindow(pSubList->pClipper) &&
				    !SURFACE_LOST(surf_lcl))
	{
	    DWORD dwNumSprites = pSubList->dwCount;
	    LPDDSPRITEI sprite = &pSubList->sprite[0];
	    BOOL bDeleteSprite = FALSE;
	    DWORD j;

	    /*
	     * No, the process for this sublist is NOT being terminated.
	     * Check if the source surfaces for any sprites are lost.
	     */
	    for (j = 0; j < dwNumSprites; ++j)
	    {
    		LPDIRECTDRAWSURFACE pSrcSurf = sprite[j].lpDDSSrc;
		LPDDRAWI_DDRAWSURFACE_INT surf_src_int = (LPDDRAWI_DDRAWSURFACE_INT)pSrcSurf;
		LPDDRAWI_DDRAWSURFACE_LCL surf_src_lcl = surf_src_int->lpLcl;

		if (SURFACE_LOST(surf_src_lcl))
		{
		    /*
		     * This surface is lost, so delete the reference.
		     */
		    sprite[j].lpDDSSrc = NULL;   // mark surface as null
		    bDeleteSprite = TRUE;    // remember sprite array needs fix-up
		}
	    }
	    /*
	     * If the source-surface pointer for any sprite in the sublist
	     * was set to null, remove the sprite from the sublist by moving
	     * the rest of the sprite array downward to fill the gap.
	     */
	    if (bDeleteSprite == TRUE)
	    {
		dwNumSprites = scrunchSubList(pSubList);
		bChangesMade = TRUE;   // remember change to master sprite list
	    }
	    if (dwNumSprites != 0)
	    {
		/*
		 * The sublist still contains sprites, so don't delete it.
		 */
		continue;   // go to next sublist
	    }
	}
	/*
	 * Delete the sublist.  The reason is that (1) the process that
	 * owns the sublist is being terminated, or (2) the sublist is
	 * associated with an invalid window, or (3) the source surface
	 * for every sprite in the sublist is a lost surface.
	 */
	MemFree(pSubList->pRgn);
	MemFree(pSubList);
	pMaster->pSubList[i] = NULL;	// mark sublist as null
	bDeleteSubList = TRUE;	   // remember we deleted sublist
    }
    /*
     * If the sublist pointer for any sublist in the master sprite
     * list was set to null, remove the null from the pointer array by
     * moving the rest of the pointer array downward to fill the gap.
     */
    if (bDeleteSubList)
    {
	dwNumSubLists = scrunchMasterSpriteList(pMaster);
	bChangesMade = TRUE;
    }
    /*
     * If any changes have been made to the master sprite list, tell
     * the driver to make the changes visible on the screen.
     */
    if (bChangesMade)
    {
	DWORD rc;
	LPDDHAL_SETSPRITEDISPLAYLIST pfn;
	DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData;
	LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pPrimary;
	LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = surf_int->lpLcl;
        LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl = surf_lcl->lpSurfMore->lpDD_lcl;

	/*
	 * Build a temporary display list that contains all the sprites
	 * in the revised master sprite list.
	 */
	pMaster->surf_lcl = surf_lcl;	  // used by buildTempDisplayList
#if 0
	pMaster->dwFlags = DDSSDL_BLTSPRITES;	// debug !!
#else
	pMaster->dwFlags = DDSSDL_OVERLAYSPRITES;   // used by buildTempDisplayList
#endif
	pHalData = buildTempDisplayList(pMaster);
	/*
	 * Pass the temp display list to the driver.
	 */
#if 0
	pfn = pdrv_lcl->lpDDCB->HELDDMiscellaneous2.SetSpriteDisplayList;  // debug !!
#else
	pfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous2.SetSpriteDisplayList;
#endif
        DOHALCALL(SetSpriteDisplayList, pfn, *pHalData, rc, 0);
    }

    if (dwNumSubLists == 0)
    {
	/*
	 * We deleted ALL the sublists from the master sprite list,
	 * so now we need to delete the master sprite list too.
	 */
	FreeMasterSpriteList(pdrv);
	return;
    }
    markSpriteObjects(pMaster);

}   /* ProcessSpriteCleanup */


/*
 * Global function for managing master sprite list.  This function is
 * called by InternalSurfaceRelease to remove all references in the
 * master sprite list to a surface interface object that is being
 * released.  The function also checks for lost surfaces in the
 * master sprite list.  If any changes are made to the master sprite
 * list, the driver is told to display those changes immediately.
 */
void RemoveSpriteSurface(LPDDRAWI_DIRECTDRAW_GBL pdrv,
			 LPDDRAWI_DDRAWSURFACE_INT surf_int)
{
    LPMASTERSPRITELIST pMaster = (LPMASTERSPRITELIST)pdrv->lpMasterSpriteList;
    LPDIRECTDRAWSURFACE pSurface = (LPDIRECTDRAWSURFACE)surf_int;
    LPDIRECTDRAWSURFACE pPrimary = pMaster->pSubList[0]->pPrimary;
    DWORD dwNumSubLists = pMaster->dwNumSubLists;
    BOOL bDeleteSubList = FALSE;
    BOOL bChangesMade = FALSE;
    DWORD i;

    DDASSERT(pMaster != NULL);	  // error -- surface shouldn't be marked!

    /*
     * Before making changes to the master sprite list, we first
     * unmark all clipper and surface objects in the list.  After
     * the changes are completed, we will again mark the objects
     * that are referenced in the revised master sprite list.
     */
    unmarkSpriteObjects(pMaster);

    /*
     * Each sublist of the master sprite list contains all the sprites
     * that are to appear within a particular window of a shared primary.
     * Stored with each sublist is the primary surface object for the
     * window, and also the source surface objects for each sprite in the
     * sublist.  These surfaces are checked against pSurface and if a
     * match is found, the surface reference is deleted from the sublist.
     */
    for (i = 0; i < dwNumSubLists; ++i)
    {
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDIRECTDRAWSURFACE pDestSurf = pSubList->pPrimary;
	LPDDRAWI_DDRAWSURFACE_INT surf_dest_int = (LPDDRAWI_DDRAWSURFACE_INT)pDestSurf;
	LPDDRAWI_DDRAWSURFACE_LCL surf_dest_lcl = surf_dest_int->lpLcl;

	/*
	 * If this sublist's primary surface object is being released, delete
	 * the sublist.  We also check for lost surfaces and delete any we find.
	 */
	if (pDestSurf != pSurface && validClipperWindow(pSubList->pClipper) &&
				    !SURFACE_LOST(surf_dest_lcl))
	{
	    DWORD dwNumSprites = pSubList->dwCount;
	    LPDDSPRITEI sprite = &pSubList->sprite[0];
	    BOOL bDeleteSprite = FALSE;
	    DWORD j;

	    /*
	     * No, the primary surface object for this sublist is NOT
	     * being released, but perhaps the source surface for one
	     * or more of the sprites in this sublist is being released.
	     */
	    for (j = 0; j < dwNumSprites; ++j)
	    {
    		LPDIRECTDRAWSURFACE pSrcSurf = sprite[j].lpDDSSrc;
		LPDDRAWI_DDRAWSURFACE_INT surf_src_int = (LPDDRAWI_DDRAWSURFACE_INT)pSrcSurf;
		LPDDRAWI_DDRAWSURFACE_LCL surf_src_lcl = surf_src_int->lpLcl;

		if (pSrcSurf == pSurface || SURFACE_LOST(surf_src_lcl))
		{
		    /*
		     * This surface either is being released or is lost.
		     * In either case, we delete the reference.
		     */
		    sprite[j].lpDDSSrc = NULL;   // mark surface as null
		    bDeleteSprite = TRUE;    // remember sprite array needs fix-up
		}
	    }
	    /*
	     * If the source-surface pointer for any sprite in the sublist
	     * was set to null, remove the sprite from the sublist by moving
	     * the rest of the sprite array downward to fill the gap.
	     */
	    if (bDeleteSprite == TRUE)
	    {
		dwNumSprites = scrunchSubList(pSubList);
		bChangesMade = TRUE;   // remember change to master sprite list
	    }
	    if (dwNumSprites != 0)
	    {
		/*
		 * The sublist still contains sprites, so don't delete it.
		 */
		continue;   // go to next sublist
	    }
	}
	/*
	 * Delete the sublist.  The reason is that (1) the primary surface
	 * object for the sublist is being released, or (2) the sublist is
	 * associated with an invalid window, or (3) the source surface
	 * for every sprite in the sublist is either being released or is
	 * a lost surface.
	 */
	MemFree(pSubList->pRgn);
	MemFree(pSubList);
	pMaster->pSubList[i] = NULL;	// mark sublist as null
	bDeleteSubList = TRUE;	   // remember we deleted sublist
    }
    /*
     * If the sublist pointer for any sublist in the master sprite
     * list was set to null, remove the null from the pointer array by
     * moving the rest of the pointer array downward to fill the gap.
     */
    if (bDeleteSubList)
    {
	dwNumSubLists = scrunchMasterSpriteList(pMaster);
	bChangesMade = TRUE;
    }
    /*
     * If any changes have been made to the master sprite list, tell
     * the driver to make the changes visible on the screen.
     */
    if (bChangesMade)
    {
	DWORD rc;
	LPDDHAL_SETSPRITEDISPLAYLIST pfn;
	DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData;
	LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pPrimary;
	LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = surf_int->lpLcl;
        LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl = surf_lcl->lpSurfMore->lpDD_lcl;

	/*
	 * Build a temporary display list that contains all the sprites
	 * in the revised master sprite list.
	 */
	pMaster->surf_lcl = surf_lcl;	 // used by buildTempDisplayList
#if 0
	pMaster->dwFlags = DDSSDL_BLTSPRITES;	// debug !!
#else
	pMaster->dwFlags = DDSSDL_OVERLAYSPRITES;   // used by buildTempDisplayList
#endif
	pHalData = buildTempDisplayList(pMaster);
	/*
	 * Pass the temp display list to the driver.
	 */
#if 0
	pfn = pdrv_lcl->lpDDCB->HELDDMiscellaneous2.SetSpriteDisplayList;  // debug !!
#else
	pfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous2.SetSpriteDisplayList;
#endif
        DOHALCALL(SetSpriteDisplayList, pfn, *pHalData, rc, 0);
    }

    if (dwNumSubLists == 0)
    {
	/*
	 * We deleted ALL the sublists from the master sprite list,
	 * so now we need to delete the master sprite list too.
	 */
	FreeMasterSpriteList(pdrv);
	return;
    }
    markSpriteObjects(pMaster);

}   /* RemoveSpriteSurface */


/*
 * Global function for managing master sprite list.  This function is
 * called by InternalClipperRelease to remove all references in the
 * master sprite list to a clipper object that is being released.
 * The function also checks for lost surfaces in the master sprite
 * list.  If any changes are made to the master sprite list, the
 * driver is told to display those changes immediately.
 */
void RemoveSpriteClipper(LPDDRAWI_DIRECTDRAW_GBL pdrv,
			 LPDDRAWI_DDRAWCLIPPER_INT pclip_int)
{
    LPMASTERSPRITELIST pMaster = (LPMASTERSPRITELIST)pdrv->lpMasterSpriteList;
    LPDIRECTDRAWSURFACE pPrimary = pMaster->pSubList[0]->pPrimary;
    LPDIRECTDRAWCLIPPER pClipper = (LPDIRECTDRAWCLIPPER)pclip_int;
    DWORD dwNumSubLists = pMaster->dwNumSubLists;
    BOOL bDeleteSubList = FALSE;
    BOOL bChangesMade = FALSE;
    DWORD i;

    DDASSERT(pMaster != NULL);	  // error -- surface shouldn't be marked!

    /*
     * Before making changes to the master sprite list, we first
     * unmark all clipper and surface objects in the list.  After
     * the changes are completed, we will again mark the objects
     * that are referenced in the revised master sprite list.
     */
    unmarkSpriteObjects(pMaster);

    /*
     * Each sublist of the master sprite list contains all the sprites
     * that are to appear within a particular window of a shared primary.
     * Each sublist has a clipper (which may be NULL) to specify the
     * window's clip region.  Each sublist's clipper pointer is compared
     * with the specified pClipper pointer.  If a match is found, the
     * sublist and its clipper are removed from the master sprite list.
     */
    for (i = 0; i < dwNumSubLists; ++i)
    {
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];
	LPDIRECTDRAWSURFACE pDestSurf = pSubList->pPrimary;
	LPDDRAWI_DDRAWSURFACE_INT surf_dest_int = (LPDDRAWI_DDRAWSURFACE_INT)pDestSurf;
	LPDDRAWI_DDRAWSURFACE_LCL surf_dest_lcl = surf_dest_int->lpLcl;

	/*
	 * If clipper object for this sublist is being released, delete it.
	 * (We also check for lost surfaces and delete any we find.)
	 */
	if (pSubList->pClipper != pClipper &&
				    validClipperWindow(pSubList->pClipper) &&
				    !SURFACE_LOST(surf_dest_lcl))
	{
	    DWORD dwNumSprites = pSubList->dwCount;
	    LPDDSPRITEI sprite = &pSubList->sprite[0];
	    BOOL bDeleteSprite = FALSE;
	    DWORD j;

	    /*
	     * No, the clipper for this sublist is NOT being released.
	     * Check if the source surfaces for any sprites are lost.
	     */
	    for (j = 0; j < dwNumSprites; ++j)
	    {
    		LPDIRECTDRAWSURFACE pSrcSurf = sprite[j].lpDDSSrc;
		LPDDRAWI_DDRAWSURFACE_INT surf_src_int = (LPDDRAWI_DDRAWSURFACE_INT)pSrcSurf;
		LPDDRAWI_DDRAWSURFACE_LCL surf_src_lcl = surf_src_int->lpLcl;

		if (SURFACE_LOST(surf_src_lcl))
		{
		    /*
		     * This surface is lost, so delete the reference.
		     */
		    sprite[j].lpDDSSrc = NULL;   // mark surface as null
		    bDeleteSprite = TRUE;    // remember sprite array needs fix-up
		}
	    }
	    /*
	     * If the source-surface pointer for any sprite in the sublist
	     * was set to null, remove the sprite from the sublist by moving
	     * the rest of the sprite array downward to fill the gap.
	     */
	    if (bDeleteSprite == TRUE)
	    {
		dwNumSprites = scrunchSubList(pSubList);
		bChangesMade = TRUE;   // remember change to master sprite list
	    }
	    if (dwNumSprites != 0)
	    {
		/*
		 * The sublist still contains sprites, so don't delete it.
		 */
		continue;   // go to next sublist
	    }
	}
	/*
	 * Delete the sublist.  The reason is that (1) the clipper for the
	 * sublist is being released, (2) the sublist is associated with an
	 * invalid window, or (3) the source surface for every sprite in
	 * the sublist is a lost surface.
	 */
	MemFree(pSubList->pRgn);
	MemFree(pSubList);
	pMaster->pSubList[i] = NULL;	// mark sublist as null
	bDeleteSubList = TRUE;	   // remember we deleted sublist
    }
    /*
     * If the sublist pointer for any sublist in the master sprite
     * list was set to null, remove the null from the pointer array by
     * moving the rest of the pointer array downward to fill the gap.
     */
    if (bDeleteSubList)
    {
	dwNumSubLists = scrunchMasterSpriteList(pMaster);
	bChangesMade = TRUE;
    }
    /*
     * If any changes have been made to the master sprite list, tell
     * the driver to make the changes visible on the screen.
     */
    if (bChangesMade)
    {
	DWORD rc;
	LPDDHAL_SETSPRITEDISPLAYLIST pfn;
	DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData;
	LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pPrimary;
	LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = surf_int->lpLcl;
        LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl = surf_lcl->lpSurfMore->lpDD_lcl;

	/*
	 * Build a temporary display list that contains all the sprites
	 * in the revised master sprite list.
	 */
	pMaster->surf_lcl = surf_lcl;	 // used by buildTempDisplayList
#if 0
	pMaster->dwFlags = DDSSDL_BLTSPRITES;	// debug !!
#else
	pMaster->dwFlags = DDSSDL_OVERLAYSPRITES;   // used by buildTempDisplayList
#endif
	pHalData = buildTempDisplayList(pMaster);
	/*
	 * Pass the temp display list to the driver.
	 */
#if 0
	pfn = pdrv_lcl->lpDDCB->HELDDMiscellaneous2.SetSpriteDisplayList;  // debug !!
#else
	pfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous2.SetSpriteDisplayList;
#endif
        DOHALCALL(SetSpriteDisplayList, pfn, *pHalData, rc, 0);
    }

    if (dwNumSubLists == 0)
    {
	/*
	 * We deleted ALL the sublists from the master sprite list,
	 * so now we need to delete the master sprite list too.
	 */
	FreeMasterSpriteList(pdrv);
	return;
    }
    markSpriteObjects(pMaster);

}   /* RemoveSpriteClipper */


/*
 * Helper function for managing master sprite list.  Check each sprite
 * to see if its surface has been lost.  Also check each sublist to
 * see if its window still exists.  Sprites with lost surfaces are
 * deleted from the master sprite list.  Also, sublists with defunct
 * windows are deleted.  Before calling this function, call
 * unmarkSpriteObjects().
 */
static void removeLostSpriteSurfaces(LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    DWORD i;
    DWORD dwNumSubLists;
    LPMASTERSPRITELIST pMaster = pdrv->lpMasterSpriteList;
    BOOL bDeleteSubList = FALSE;

    if (pMaster == NULL)
    {
    	return;    // nothing to do -- bye!
    }

    dwNumSubLists = pMaster->dwNumSubLists;
    DDASSERT(dwNumSubLists != 0);

    /*
     * Each iteration checks all the sprites in one sublist
     * to see if their source surfaces have been lost.
     */
    for (i = 0; i < dwNumSubLists; ++i)
    {
	LPSPRITESUBLIST pSubList = pMaster->pSubList[i];

	/*
	 * Verify that clipper for this sublist has a valid window handle.
	 */
	if (validClipperWindow(pSubList->pClipper))
	{
	    LPDDSPRITEI sprite = &pSubList->sprite[0];
	    DWORD dwNumSprites = pSubList->dwCount;
	    BOOL bDeleteSprite = FALSE;
	    DWORD j;

	    DDASSERT(dwNumSprites != 0);

	    /*
	     * Yes, clipper's window handle is valid.  Now check to see if
	     * any of the sprites in the sublist have lost source surfaces.
	     */
	    for (j = 0; j < dwNumSprites; ++j)
	    {
		LPDIRECTDRAWSURFACE pSrcSurf = sprite[j].lpDDSSrc;
		LPDDRAWI_DDRAWSURFACE_INT surf_src_int = (LPDDRAWI_DDRAWSURFACE_INT)pSrcSurf;
		LPDDRAWI_DDRAWSURFACE_LCL surf_src_lcl = surf_src_int->lpLcl;

		if (SURFACE_LOST(surf_src_lcl))    // is this surface lost?
		{
		    sprite[j].lpDDSSrc = NULL;   // yes, set surface ptr to null
		    bDeleteSprite = TRUE;	 // remember sublist needs fix-up
		}
	    }
	    /*
	     * If the source-surface pointer for any sprite in the sublist
	     * was set to null, remove the sprite from the sublist by moving
	     * the rest of the sprite array downward to fill the gap.
	     */
	    if (bDeleteSprite == TRUE)
	    {
		dwNumSprites = scrunchSubList(pSubList);
	    }
	    if (dwNumSprites != 0)
	    {
		/*
		 * The sublist still contains sprites, so don't delete it.
		 */
		continue;   // go to next sublist
	    }
	}
	/*
	 * Delete the sublist.  The reason is either that the window
	 * handle associated with this sublist's clipper is not valid,
	 * or that all the sprites in the sublist have been deleted.
	 */
	MemFree(pSubList->pRgn);
	MemFree(pSubList);
	pMaster->pSubList[i] = NULL;	// mark sublist as null
	bDeleteSubList = TRUE;	   // remember we deleted sublist
	
    }
    /*
     * If the sublist pointer for any sublist in the master sprite
     * list was set to null, remove the null from the pointer array by
     * moving the rest of the pointer array downward to fill the gap.
     */
    if (bDeleteSubList)
    {
	scrunchMasterSpriteList(pMaster);

	if (pMaster->dwNumSubLists == 0)
	{
    	    FreeMasterSpriteList(pdrv);    // delete master sprite list
	}
    }
}   /* removeLostSpriteSurfaces */


/*
 * This is a helper function for updateMasterSpriteList().  It alloc's
 * a sublist and copies the new sprite display list into the sublist.
 * If pSubList already points to a buffer that is large enough, the new
 * sublist will be created in this buffer.  Otherwise, a new buffer
 * will be alloc'd (but the old buffer isn't freed -- that's left up to
 * the caller).  Arg pHalData points to the sprite display list from
 * the app.  The return value is a pointer to the new sublist.
 */
static LPSPRITESUBLIST createSpriteSubList(LPSPRITESUBLIST pSubList,
				    DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData,
				    LPDIRECTDRAWSURFACE pPrimary)
{
    LPDDSPRITEI *ppSprite;
    LPDDSPRITEI sprite;
    // pointers to local and global surface objects
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = pHalData->lpDDSurface;
    LPDDRAWI_DDRAWSURFACE_GBL surf = surf_lcl->lpGbl;
    // number of sprites in new display list:
    DWORD dwNumSprites = pHalData->dwCount;
    // size (in bytes) of new sublist:
    DWORD size = sizeof(SPRITESUBLIST) +
			    (dwNumSprites-1)*sizeof(DDSPRITEI);

    DDASSERT(dwNumSprites != 0);	

    /*
     * If old sublist buffer is null or too small or too big,
     * allocate a new sublist buffer that's the correct size.
     */
    if (pSubList == NULL || pSubList->dwSize < size ||
		pSubList->dwSize > size + 8*sizeof(DDSPRITEI))
    {
	/*
	 * Allocate a new sublist that's just a tad larger than
	 * necessary so that we have a little room to grow in.
	 */
	size += 4*sizeof(DDSPRITEI);	   // add some padding
	pSubList = (LPSPRITESUBLIST)MemAlloc(size);
	if (pSubList == NULL)
	{
	    return NULL;    // error -- out of memory
	}
	pSubList->dwSize = size;    // remember how big buffer is
    }
    /*
     * Initialize sublist buffer.
     */
    pSubList->pPrimary = pPrimary;    // primary surface (interface object)
    pSubList->pClipper = (LPDIRECTDRAWCLIPPER)surf_lcl->lpSurfMore->lpDDIClipper;
    pSubList->dwProcessId = GETCURRPID();
    pSubList->dwCount = dwNumSprites;    // number of sprites in sublist
    pSubList->pRgn = NULL;
    /*
     * To keep things simple, the master sprite display list always stores
     * sprites in front-to-back order, regardless of how callers order them.
     * The loop below copies the sprites into a contiguous array of sprites.
     */
    sprite = &pSubList->sprite[0];             // array of sprites
    ppSprite = pHalData->lplpDDSprite;   // array of sprite pointers

    if (pHalData->dwFlags & DDSSDL_BACKTOFRONT)
    {
	int i, j;

	// Reverse original back-to-front ordering of sprites.
	for (i = 0, j = (int)dwNumSprites-1; j >= 0; ++i, --j)
	{
    	    memcpy(&sprite[i], ppSprite[j], sizeof(DDSPRITEI));
	}
    }
    else
    {
	int i;

	// Preserve original front-to-back ordering of sprites.
	for (i = 0; i < (int)dwNumSprites; ++i)
	{
    	    memcpy(&sprite[i], ppSprite[i], sizeof(DDSPRITEI));
	}
    }
    return (pSubList);    // return completed sublist

}  /* createSpriteSubList */


/*
 * This routine adds a new display list to the master sprite display list,
 * which keeps track of all overlay sprites currently displayed on the shared
 * primary.  Don't call it if (1) the sprites are blitted or (2) the primary
 * is not shared.  The update replaces the display list for the affected
 * window, but leaves the display lists for all other windows unchanged.
 * Arg surf_lcl points to the primary.  Input arg **ppHalData is the HAL
 * callback struct that specifies the new display list.  If the original
 * sprite display list in **ppHalData can be used in place of a master
 * display list without zapping sprites in other windows.  Otherwise, the
 * routine sets *ppHalData to point to a master sprite list that contains
 * the overlay sprites for all windows.
 */
static HRESULT updateMasterSpriteList(LPDIRECTDRAWSURFACE pPrimary,
				      DDHAL_SETSPRITEDISPLAYLISTDATA **ppHalData)
{
    DWORD i;
    LPDIRECTDRAWCLIPPER pClipper;
    DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData;
    LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)pPrimary;
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = surf_int->lpLcl;
    LPDDRAWI_DDRAWSURFACE_MORE surf_more = surf_lcl->lpSurfMore;
    LPDDRAWI_DIRECTDRAW_GBL pdrv = surf_more->lpDD_lcl->lpGbl;
    DWORD dwProcessId;
    LPMASTERSPRITELIST pMaster;
    LPSPRITESUBLIST pSubList;
    DWORD dwNumSprites = (*ppHalData)->dwCount;   // number of sprites in display list

    /*
     * Get pointer to master sprite list.
     */
    pMaster = (LPMASTERSPRITELIST)pdrv->lpMasterSpriteList;

    if (pMaster != NULL)
    {
	/*
	 * A master sprite list already exists.
	 */
#ifdef WIN95
	if (pMaster->dwModeCreatedIn != pdrv->dwModeIndex)   // current mode index
#else
        if (!EQUAL_DISPLAYMODE(pMaster->dmiCreated, pdrv->dmiCurrent))
#endif
	{
	    /*
	     * The master sprite list was created in a different video mode
	     * and is therefore no longer valid.  We rely on the mini-vdd
	     * driver remembering to turn off all overlay sprites when a
	     * mode change occurs, so they should already be turned off.
	     * All we do here is to update our internal data structures.
	     */
	    FreeMasterSpriteList(pdrv);
	    pMaster = NULL;
	}
	else
	{
	    /*
	     * Between calls to SetSpriteDisplayList, all surface and clipper
	     * objects in the master sprite list are marked so that we will be
	     * notified if any of these objects are released, invalidating our
	     * references to them.  We now unmark all surface/clipper objects
	     * in the master sprite list so we can update the references.
	     */
	    unmarkSpriteObjects(pMaster);
	    /*
	     * Remove any references to lost surfaces from master sprite list.
	     */
	    removeLostSpriteSurfaces(pdrv);	  // can delete master sprite list
	    /*
	     * Just in case the call above deleted the master sprite list...
	     */
	    pMaster = (LPMASTERSPRITELIST)pdrv->lpMasterSpriteList;
	}
    }

    /*
     * Has the master sprite list been created yet?
     */
    if (pMaster == NULL)
    {
	LPDDRAWI_DDRAWSURFACE_GBL surf = surf_lcl->lpGbl;

	/*
	 * No, the master sprite list has not been created.
	 */
	if (dwNumSprites == 0)
	{
	    /*
	     * The new display list is empty, so don't bother
	     * to create the master sprite list.
	     */
	    return (DD_OK);   // nothing to do -- bye!
	}
	/*
	 * The new display list is not empty, so we will now
	 * create the master sprite list and copy the new display
	 * list into the initial sublist of the master sprite list.
	 */
	pMaster = (LPMASTERSPRITELIST)MemAlloc(sizeof(MASTERSPRITELIST));
	if (pMaster == NULL)
	{
    	    return (DDERR_OUTOFMEMORY);    // error -- out of memory
	}
	/*
	 * Initialize the values in the master list header structure.
	 */
	pMaster->pdrv = pdrv;
	pMaster->surf_lcl = surf_lcl;	 // primary surface (local object)
	SetRect(&pMaster->rcPrimary, 0, 0, surf->wWidth, surf->wHeight);
	pMaster->dwFlags = (*ppHalData)->dwFlags & (DDSSDL_WAIT |
#if 0
						    DDSSDL_BLTSPRITES);	   // debug!!
#else
						    DDSSDL_OVERLAYSPRITES);
#endif
#ifdef WIN95
        pMaster->dwModeCreatedIn = pdrv->dwModeIndex;   // current mode index
#else
        pMaster->dmiCreated = pdrv->dmiCurrent;
#endif
	pMaster->pBuffer = NULL;
	/*
	 * Copy the new sprite display list into the initial sublist.
	 */
	pMaster->dwNumSubLists = 1;
	pMaster->pSubList[0] = createSpriteSubList(NULL, *ppHalData, pPrimary);
	if (pMaster->pSubList[0] == NULL)
	{
    	    MemFree(pMaster);
	    return (DDERR_OUTOFMEMORY);
	}
	/*
	 * Mark all the surface and clipper objects that are
	 * referenced in the new master sprite list.
         */
	markSpriteObjects(pMaster);
	/*
	 * We've succeeded in creating a master sprite list.  Load the
	 * pointer to the master list into the global DirectDraw object.
	 */
        pdrv->lpMasterSpriteList = (LPVOID)pMaster;

	return (DD_OK);    // new master sprite list completed
    }
    /*
     * The master sprite list was created previously.  There are
     * three possibilities at this point (#1 is most likely):
     *  1) We're REPLACING a sublist in the master sprite list.
     *     In this case, the new display list contains one or
     *     more sprites and the pClipper and ProcessId of the new
     *     display list will match those stored in a sublist.
     *  2) We're ADDING a new sublist to the master sprite list.
     *     In this case, the new display list contains one or
     *     more sprites but the pClipper and ProcessId of the
     *     new display list don't match those of any sublist.
     *  3) We're DELETING a sublist from the master sprite list.
     *     In this case, the new display list is empty (sprite
     *     count = 0) and the pClipper and ProcessId of the new
     *     display list match those stored with a sublist.
     */
    pClipper = (LPDIRECTDRAWCLIPPER)(surf_more->lpDDIClipper);
    dwProcessId = GETCURRPID();
    pMaster->surf_lcl = surf_lcl;   // primary surface (local object)
    pMaster->dwFlags = (*ppHalData)->dwFlags & (DDSSDL_WAIT |
#if 0
						DDSSDL_BLTSPRITES);   // debug !!
#else
						DDSSDL_OVERLAYSPRITES);
#endif
    for (i = 0; i < pMaster->dwNumSubLists; ++i)
    {
	/*
	 * Look for a sublist with a pointer to the same clipper object.
	 * To handle the case pClipper = NULL, we compare process IDs also.
	 */
	if (pMaster->pSubList[i]->pClipper == pClipper &&
			pMaster->pSubList[i]->dwProcessId == dwProcessId)
	{
	    break;    // found a sublist with matching pClipper and dwProcessId
	}
    }
    if (i == pMaster->dwNumSubLists)
    {
	/*
	 * The pClipper and Process ID of the new display list don't
	 * match those of any of the current sublists.  This means
	 * that a new window has begun displaying overlay sprites.
	 */
	if (dwNumSprites == 0)
	{
	    /*
	     * The new display list is empty, so don't bother adding
	     * a new (empty) sublist to the master sprite list.
	     */
	    markSpriteObjects(pMaster);
	    return (DD_OK);    // nothing to do -- bye!
	}
	/*
	 * Add a new sublist to the master sprite list and copy the
	 * new display list into the new sublist.
	 */
	pSubList = createSpriteSubList(NULL, *ppHalData, pPrimary);
	if (pSubList == NULL)
	{
    	    return (DDERR_OUTOFMEMORY);    // error -- out of memory
	}
	if (i != MAXNUMSPRITESUBLISTS)
	{
	    /*
	     * Add the new sublist to the master sprite list.
	     */
	    pMaster->dwNumSubLists++;
            pMaster->pSubList[i] = pSubList;
	}
	else
	{
	    /*
	     * Oops.  The master sprite list already contains the maximum
	     * number of sublists.  I guess I'll just delete one of the
	     * other sublists so I can add the new sublist.  (If anybody
	     * complains loud enough, we can get rid of the fixed limit.)
	     */
	    MemFree(pMaster->pSubList[i-1]);
            pMaster->pSubList[i-1] = pSubList;
	}
    }
    else
    {
	/*
	 * We've found an existing sublist that matches the new display list's
	 * pClipper and ProcessId (the sublist contains the old display list
	 * for the window in which the new display list is to appear).
	 */
	if (dwNumSprites != 0)
	{
	    /*
	     * Since the new display list is not empty, we will copy it
	     * into the sublist that contains the old display list for
	     * the same window, overwriting the old display list.
	     */
	    pSubList = createSpriteSubList(pMaster->pSubList[i],
					    *ppHalData, pPrimary);
	    if (pSubList == NULL)
	    {
		/*
		 * An allocation error has occurred.  (Note:  The original
		 * value of pMaster->pSubList[i] has not been altered.)
		 */
		return (DDERR_OUTOFMEMORY);    // error -- out of memory
	    }
	    if (pSubList != pMaster->pSubList[i])
	    {
    		/*
		 * The createSpriteSubList call had to allocate a new
		 * sublist, so now we need to free the old one.
		 */
		MemFree(pMaster->pSubList[i]);
                pMaster->pSubList[i] = pSubList;
	    }
	    if (pMaster->dwNumSubLists == 1)
	    {
		/*
		 * Only one window is displaying overlay sprites, so the
		 * new display list contains the same sprites as the master
		 * sprite list.  Don't bother to construct a temp display
		 * list to contain all the sprites in the master sprite list.
		 */
		return (DD_OK);
	    }
	}
	else
	{
	    /*
	     * The new display list is empty.  In this case, we just delete
	     * the sublist containing the old display list for the same window.
	     * This will leave a hole in the array of sublist pointers that we
	     * fill by moving all the higher members in the array down by one.
	     */
	    MemFree(pMaster->pSubList[i]);    // free sublist
	    if (pMaster->dwNumSubLists == 1)
	    {
		/*
		 * We have just deleted the only sublist, so the master sprite
		 * list is now empty.  Free the master sprite list and return.
		 */
		FreeMasterSpriteList(pdrv);
		return (DD_OK);
	    }
	    // Delete the sublist from the master sprite list.
	    pMaster->pSubList[i] = NULL;
	    scrunchMasterSpriteList(pMaster);
	}
    }
    /*
     * We have finished updating the master sprite list.  Mark all
     * surface and clipper objects referenced in the master sprite list.
     */
    markSpriteObjects(pMaster);
    /*
     * The final step is to build a temporary display list that
     * contains all the sprites in the master sprite list.
     * The caller can then pass this display list to the driver.
     */
    pHalData = buildTempDisplayList(pMaster);
    if (!pHalData)
    {
	return (DDERR_OUTOFMEMORY);    // error -- out of memory
    }
    *ppHalData = pHalData;   // update caller's display-list pointer
    return (DD_OK);

}  /* updateMasterSpriteList */


/*
 * IDirectDrawSurface4::SetSpriteDisplayList -- API call
 */
HRESULT DDAPI DD_Surface_SetSpriteDisplayList(
		    LPDIRECTDRAWSURFACE lpDDDestSurface,
		    LPDDSPRITE *lplpDDSprite,
		    DWORD dwCount,
		    DWORD dwSize,
		    LPDIRECTDRAWSURFACE lpDDTargetSurface,
		    DWORD dwFlags)
{

    /*
     * Fixed-size buffer for containing clip region data
     */
    struct
    {
	RGNDATAHEADER rdh;
	RECT clipRect[6];
    } myRgnBuffer;

    DWORD	rc;
    DDHAL_SETSPRITEDISPLAYLISTDATA ssdld;
    DDHAL_SETSPRITEDISPLAYLISTDATA *pHalData;
    LPDDHAL_SETSPRITEDISPLAYLIST   pfn;
    LPDDRAWI_DDRAWSURFACE_INT	   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	   this;
    LPDDRAWI_DDRAWSURFACE_INT	   targ_int;
    LPDDRAWI_DDRAWSURFACE_LCL	   targ_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	   targ;
    LPDDRAWI_DIRECTDRAW_LCL        pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	   pdrv;
    LPDIRECTDRAWCLIPPER 	   pClipper;
    DWORD 	dwDDPFDestFlags;
    SPRITE_CAPS	caps;
    LPRGNDATA 	pRgn;
    RECT 	rcDestSurf;
    DWORD 	ifirst;
    int		i;

    DDASSERT(sizeof(DDRGBA)==sizeof(DWORD));  // we rely on this
    DDASSERT(sizeof(DDSPRITEI)==sizeof(DDSPRITE));  // and this

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_SetSpriteDisplayList");

    /*
     * Validate parameters
     */
    TRY
    {
	/*
	 * Validate destination surface.
	 */
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDDestSurface;

	if (!VALID_DIRECTDRAWSURFACE_PTR(this_int))
	{
	    DPF_ERR("Invalid dest surface");
	    LEAVE_BOTH();
	    return DDERR_INVALIDOBJECT;
	}

	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	/*
	 * Check for lost dest surface.
	 */
	if (SURFACE_LOST(this_lcl))
	{
	    DPF_ERR("Dest surface lost");
	    LEAVE_BOTH();
	    return DDERR_SURFACELOST;
	}

#if 0
	if (!dwCount)		
	{
            lplpDDSprite = NULL;   // necessary?
	}
#endif

	/*
	 * Perform initial validation of arguments.
	 */
	if (dwCount && !lplpDDSprite ||	   // if count nonzero, is ptr valid?
	    dwSize != sizeof(DDSPRITE) ||	   // structure size ok?
	    dwFlags & ~DDSSDL_VALID ||			   // any bogus flag bits set?
	    dwFlags & DDSSDL_PAGEFLIP && dwFlags & DDSSDL_BLTSPRITES ||  // no flip if blt
	    !(dwFlags & (DDSSDL_OVERLAYSPRITES | DDSSDL_BLTSPRITES)) ||	 // neither flag set?
	    !(~dwFlags & (DDSSDL_OVERLAYSPRITES | DDSSDL_BLTSPRITES)))   // both flags set?
	{
	    DPF_ERR("Invalid arguments") ;
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}

	/*
         * The dest surface is not allowed to be palette-indexed.
	 */
        dwDDPFDestFlags = getPixelFormatFlags(this_lcl);

	if (dwDDPFDestFlags & (DDPF_PALETTEINDEXED1 | DDPF_PALETTEINDEXED2 |
			       DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8))
	{
	    DPF_ERR( "Dest surface must not be palette-indexed" );
	    LEAVE_BOTH();
	    return DDERR_INVALIDSURFACETYPE;
	}

	pdrv = this->lpDD;			   	
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;

	/*
	 * Is device busy?
	 */
	if (*(pdrv->lpwPDeviceFlags) & BUSY)
	{
	    DPF(2, "BUSY");
	    LEAVE_BOTH();
	    return DDERR_SURFACEBUSY;
	}

	/*
	 * Determine whether the sprites are to be overlayed or blitted.
	 */
	caps.bOverlay = !(dwFlags & DDSSDL_BLTSPRITES);

	if (caps.bOverlay)
	{
	    /*
	     * Dest surface for overlay sprite must be primary surface.
	     */
	    if (!(this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
	    {
		DPF_ERR("Dest is not primary surface");
		LEAVE_BOTH();
		return DDERR_INVALIDPARAMS;    // not primary surface
	    }
	}
	else
	{
	    /*
	     * We do not allow blitting to an optimized surface.
	     */
	    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
	    {
		DPF_ERR("Can't blt optimized surfaces") ;
		LEAVE_BOTH();
		return DDERR_INVALIDPARAMS;
	    }
	}

	/*
	 * Will this call flip the primary surface?
	 */
	if (!(dwFlags & DDSSDL_PAGEFLIP))
	{
	    // no flip
	    targ_lcl = NULL;
	}
	else
	{
            LPDDRAWI_DDRAWSURFACE_INT next_int;
            LPDDRAWI_DDRAWSURFACE_GBL_MORE targmore;

	    /*
	     * Yes, a page flip is requested.  Make sure the destination
	     * surface is a front buffer and is flippable.
	     */
	    if (~this_lcl->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_FLIP))
	    {
		DPF_ERR("Dest surface is not flippable");
		LEAVE_BOTH();
		return DDERR_NOTFLIPPABLE;
	    }
	    if (this->dwUsageCount > 0)
	    {
		DPF_ERR("Can't flip locked surface");
		LEAVE_BOTH();
		return DDERR_SURFACEBUSY;
	    }
	    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE &&
					pdrv->lpExclusiveOwner != pdrv_lcl)
	    {
		DPF_ERR("Can't flip without exclusive access");
		LEAVE_BOTH();
		return DDERR_NOEXCLUSIVEMODE;
	    }
	    /*
	     * Get backbuffer surface attached to dest surface.
	     */
	    next_int = FindAttachedFlip(this_int);

	    if (next_int == NULL)
	    {
		DPF_ERR("No backbuffer surface to flip to");
		LEAVE_BOTH();
		return DDERR_NOTFLIPPABLE;
	    }
	    /*
	     * Validate flip override surface, if one is specified.
	     */
            targ_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDTargetSurface;

	    if (targ_int != NULL)
	    {
		if (!VALID_DIRECTDRAWSURFACE_PTR(targ_int))
		{
		    DPF_ERR("Invalid flip override surface");
		    LEAVE_BOTH();
		    return DDERR_INVALIDOBJECT;
		}
	
		targ_lcl = targ_int->lpLcl;
		targ = targ_lcl->lpGbl;

		/*
		 * Verify that the flip override surface is part of the destination
		 * surface's flipping chain.  Note that next_int already points to
		 * the first buffer in the flipping chain.
		 */
		while (next_int != this_int && next_int->lpLcl != targ_lcl)
		{
                    next_int = FindAttachedFlip(this_int);
		}

                if (next_int == this_int)
		{
		    // failed to find override surface in flipping chain
		    DPF_ERR("Flip override surface not part of flipping chain");
		    LEAVE_BOTH();
		    return DDERR_NOTFLIPPABLE;
		}
	    }
	    else
	    {
		/*
		 * No flip override surface is specified so use
		 * next backbuffer as target flip surface.
		 */
		targ_int = next_int;
		targ_lcl = targ_int->lpLcl;
		targ = targ_lcl->lpGbl;
	    }

            /*
	     * Make sure target flip surface is not lost or busy.
	     */
	    if (SURFACE_LOST(targ_lcl))
	    {
		DPF_ERR("Can't flip -- backbuffer surface is lost");
		LEAVE_BOTH();
		return DDERR_SURFACELOST;
	    }

            targmore = GET_LPDDRAWSURFACE_GBL_MORE(targ);
#if 0
	    if (targmore->hKernelSurface != 0)
	    {
		DPF_ERR("Can't flip -- kernel mode is using surface");
		LEAVE_BOTH();
		return DDERR_SURFACEBUSY;
	    }
#endif
	    /*
	     * Make sure front and back buffers are in same memory.
	     */
	    if ((this_lcl->ddsCaps.dwCaps & (DDSCAPS_SYSTEMMEMORY |
					       DDSCAPS_VIDEOMEMORY)) !=
                 (targ_lcl->ddsCaps.dwCaps & (DDSCAPS_SYSTEMMEMORY |
					       DDSCAPS_VIDEOMEMORY)))
	    {
		DPF_ERR("Can't flip between system/video memory surfaces");
		LEAVE_BOTH();
		return DDERR_INVALIDPARAMS;
	    }
	}  /* page flip */

	/*
	 * Validate display list pointer lplpSpriteDisplayList.
	 */
	if ( IsBadWritePtr((LPVOID)lplpDDSprite,
			    (UINT)dwCount*sizeof(LPDDSPRITE)) )
	{
	    DPF_ERR("Bad pointer to sprite display list");
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}

	/*
	 * Initialize structure containing caps bits for sprites.
	 */
	memset(&caps, 0, sizeof(SPRITE_CAPS));	
	caps.dwDestSurfCaps = this_lcl->ddsCaps.dwCaps;   // dest surface caps
	caps.bOverlay = dwFlags & DDSSDL_OVERLAYSPRITES;   // TRUE if overlay sprites

	/*
	 * Initialize status variables bNoHEL and bNoHAL.  If bNoHEL is
	 * TRUE, this disqualifies the HEL from handling the driver call.
	 * If bNoHAL is TRUE, this disqualifies the hardware driver.
	 */
	caps.bNoHEL = dwFlags & (DDSSDL_HARDWAREONLY | DDSSDL_OVERLAYSPRITES);
	caps.bNoHAL = FALSE;

	/*
	 * A driver that specifies nonlocal video-memory caps that differ
	 * from its local video-memory caps is automatically disqualified
	 * because the currently specified nonlocal vidmem caps do not
	 * include alpha, filter, or transform caps.  Should we fix this?
	 */
        if (caps.dwDestSurfCaps & DDSCAPS_NONLOCALVIDMEM  &&
	    pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS)
	{
	    caps.bNoHAL = TRUE;
	}

	/*
	 * The assumption here is that the display list can be handled by
	 * the display hardware only if the dest surface and all the
	 * sprites are in video memory.  If one or more surfaces are in
	 * system memory, emulation is the only option.  We check the
	 * dest surface just below.  Later, we'll check each sprite in
	 * the list.  (Will this assumption still be valid in the future?)
	 */
	if (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
	{
	    caps.bNoHAL = TRUE;

	    if (caps.bNoHEL)
	    {
		DPF_ERR("Hardware can't show sprites on dest surface in system memory");
		LEAVE_BOTH();
		return DDERR_UNSUPPORTED;
	    }
	}

	DDASSERT(!(caps.bNoHEL && caps.bNoHAL));

	/*
	 * Each iteration of the for-loop below validates the DDSPRITE
	 * structure for the next sprite in the display list.
	 */
	for (i = 0; i < (int)dwCount; ++i)
	{
	    HRESULT ddrval = validateSprite(lplpDDSprite[i],
					    pdrv,
					    this_lcl,
					    &caps,
					    dwDDPFDestFlags);

	    if (ddrval != DD_OK)
	    {
		DPF(1, "...failed at sprite display list index = %d", i);
		LEAVE_BOTH();
		return ddrval;
	    }
	}

	DDASSERT(!(caps.bNoHEL && caps.bNoHAL));

	/*
	 * Will the sprites be blitted?  If so, they will alter dest surface.
	 */
	if (dwFlags & DDSSDL_BLTSPRITES)
	{
	    /*
	     *  Remove any cached run-length-encoded data for the source surface.
	     */
	    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
	    {
		extern void FreeRleData(LPDDRAWI_DDRAWSURFACE_LCL);  //in fasthel.c

		FreeRleData(this_lcl);
	    }

	    BUMP_SURFACE_STAMP(this);
	}
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
	DPF_ERR("Exception encountered validating parameters");
	LEAVE_BOTH();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Determine clipping region for destination surface.
     */
    // GetRgnData() call needs clipper and width/height of dest surface.
    pClipper = (LPDIRECTDRAWCLIPPER)this_lcl->lpSurfMore->lpDDIClipper;
    SetRect(&rcDestSurf, 0, 0, this->wWidth, this->wHeight);
    // We'll pass in a region buffer for GetRgnData() to use.
    myRgnBuffer.rdh.dwSize = sizeof(RGNDATAHEADER);
    myRgnBuffer.rdh.nRgnSize = sizeof(myRgnBuffer) - sizeof(RGNDATAHEADER);
    pRgn = GetRgnData(pClipper, &rcDestSurf, pdrv, (LPRGNDATA)&myRgnBuffer);
    if (pRgn == NULL)
    {
	DPF_ERR("Can't alloc memory for clipping region");
	LEAVE_BOTH();
	return DDERR_OUTOFMEMORY;
    }

    /*
     * Set up the HAL callback data for the sprite display list.  This
     * data structure will be passed directly to the driver either if
     * the sprites are blitted or if no other window or clipping region
     * contains overlay sprites.  Otherwise, the driver will receive a
     * temporary display list constructed by updateMasterSpriteList()
     * that contains all the overlay sprites in the master sprite list.
     */
    //ssdld.SetSpriteDisplayList = pfn;    // debug aid only -- no thunk
    ssdld.lpDD = pdrv;
    ssdld.lpDDSurface = this_lcl;
    ssdld.lplpDDSprite = (LPDDSPRITEI*)lplpDDSprite;
    ssdld.dwCount = dwCount;
    ssdld.dwSize = dwSize;
    ssdld.dwFlags = dwFlags & ~DDSSDL_WAIT;
    ssdld.dwRectCnt = pRgn->rdh.nCount;    // number of clip rects in region
    ssdld.lpRect = (LPRECT)&pRgn->Buffer;  // array of clip rects
    ssdld.lpDDTargetSurface = targ_lcl;

    /*
     * The "master sprite list" keeps track of the overlay sprites in all
     * the windows on a shared primary surface.  (It also keeps track of
     * the overlay sprites in all the clip regions of a full-screen app.)
     * The master sprite list keeps a record of the active overlay sprites
     * in each window (or clip region), as identified by its clipper object.
     * Whenever any window updates its overlay sprites, the update is first
     * recorded in the master sprite list.  Next, a temporary display list
     * containing all the overlay sprites in the master sprite list is passed
     * to the driver.  That way, the driver itself never has to keep track of
     * more than one overlay-sprite display list at a time.  The alternative
     * would be for the driver itself to keep track of the overlay sprites
     * for each window.  We have chosen to keep the driver code simple by
     * moving this bookkeeping into the DirectDraw runtime.
     */
    pHalData = &ssdld;
#if 0
    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)  // debug only !!
#else
    if (dwFlags & DDSSDL_OVERLAYSPRITES)
#endif
    {
	/*
	 * The new display list specifies overlay sprites, so we
	 * need to update the master sprite list.
	 */
	HRESULT ddrval = updateMasterSpriteList(lpDDDestSurface, &pHalData);

	if (ddrval != DD_OK)
	{
	    DPF_ERR( "Failed to update master sprite list" );
	    LEAVE_BOTH();
	    return ddrval;
	}
    }

    TRY
    {
	/*
	 * Given the choice, we would prefer to use the hardware driver
	 * rather than software emulation to process this display list.
	 */
	if (!caps.bNoHAL)
	{
	    /*
	     * Yes, we can use the hardware.  Get pointer to HAL callback.
	     */
	    pfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous2.SetSpriteDisplayList;

	    if (!pfn)
	    {
		caps.bNoHAL = TRUE;    // no hardware driver is available
	    }
	    else
	    {
		/*
		 * Tell the driver to begin processing the sprite display
		 * list.  We may have to wait if the driver is still busy
		 * with a previously requested drawing operation.
		 */
		do
		{
		    DOHALCALL_NOWIN16(SetSpriteDisplayList, pfn, *pHalData, rc, 0);  // caps.bNoHAL);
		    #ifdef WINNT
			DDASSERT(! (rc == DDHAL_DRIVER_HANDLED && pHalData->ddRVal == DDERR_VISRGNCHANGED));
		    #endif
	
		    if (rc != DDHAL_DRIVER_HANDLED || pHalData->ddRVal != DDERR_WASSTILLDRAWING)
		    {
			break;    // driver's finished for better or worse...
		    }
		    DPF(4, "Waiting...");
	
		} while (dwFlags & DDSSDL_WAIT);

		if (rc != DDHAL_DRIVER_HANDLED || pHalData->ddRVal == DDERR_UNSUPPORTED)
		{
		    caps.bNoHAL = TRUE;  // hardware driver couldn't handle callback
		}
		else if (pHalData->ddRVal != DD_OK)
		{
		    /*
		     * We want to just return with this error code instead
		     * of asking the HEL to process the display list.
		     */
		    caps.bNoHEL = TRUE;	 // disqualify HEL routine
		}
	    }
	}

	/*
	 * If the hardware was unable to handle the display list, we may
	 * have to let the HEL process it for us.
	 */
	if (caps.bNoHAL && !caps.bNoHEL)
	{
	    /*
	     * Have to use HEL support.  Get pointer to HEL emulation routine.
	     */
	    pfn = pdrv_lcl->lpDDCB->HELDDMiscellaneous2.SetSpriteDisplayList;

	    DDASSERT(pfn != NULL);

	    DOHALCALL_NOWIN16(SetSpriteDisplayList, pfn, *pHalData, rc, 0);  // caps.bNoHAL);
	}
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
	DPF_ERR("Exception encountered during sprite rendering");
	LEAVE_BOTH();
	return DDERR_EXCEPTION;
    }

    /*
     * If the previous GetRgnData() call had to dynamically alloc
     * a region buffer, we need to remember to free it now.
     */
    if (pRgn != (LPRGNDATA)&myRgnBuffer)
    {
    	MemFree(pRgn);
    }

    // Was there any driver support at all for this call?
    if (caps.bNoHAL && caps.bNoHEL)
    {
	DPF_ERR("No driver support for this call");
	LEAVE_BOTH();
	return DDERR_UNSUPPORTED;
    }

    // Did driver handle callback?
    if (rc != DDHAL_DRIVER_HANDLED)
    {
	DPF_ERR("Driver wouldn't handle callback");
	LEAVE_BOTH();
	return DDERR_UNSUPPORTED;
    }

    // Return now if driver handled callback without error.
    if (pHalData->ddRVal == DD_OK || pHalData->ddRVal == DDERR_WASSTILLDRAWING)
    {
    	LEAVE_BOTH();
	return pHalData->ddRVal;
    }

    /*
     * An error prevented the driver from showing all the sprites
     * in the list.  Which sprites did get shown?
     */
    if (pHalData->dwCount == dwCount)
    {
	// None of the sprites got shown
	DPF(1, "Driver failed to show any sprites in display list");
	LEAVE_BOTH();
	return pHalData->ddRVal;
    }
    DPF(1, "Driver failed sprite at disp list index #%d", pHalData->dwCount);

    DDASSERT(pHalData->dwCount < dwCount);

    if (pHalData->dwFlags & DDSSDL_BACKTOFRONT)
    {
	// Driver showed sprites from (dwCount-1) down to (pHalData->dwCount+1).
	ifirst = dwCount - 1;    // driver started at last sprite in list
    }
    else
    {
	// Driver showed sprites from 0 up to (pHalData->dwCount-1).
	ifirst = 0;   // driver started at first sprite in list
    }
    DPF(1, "Driver started with sprite at disp list index #%d", ifirst);

    LEAVE_BOTH();

    return pHalData->ddRVal;

}  /* DD_Surface_SetSpriteDisplayList */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddsurf.c ===
/*==========================================================================
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsurf.c
 *  Content: 	DirectDraw engine surface support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   25-dec-94	craige	initial implementation
 *   13-jan-95	craige	re-worked to updated spec + ongoing work
 *   21-jan-95	craige	made 32-bit + ongoing work
 *   31-jan-95	craige	and even more ongoing work...
 *   06-feb-95	craige	performance tuning, ongoing work
 *   27-feb-95	craige 	new sync. macros
 *   07-mar-95	craige	keep track of flippable surfaces
 *   11-mar-95	craige	palette stuff, keep track of process surface usage
 *   15-mar-95	craige 	HEL
 *   19-mar-95	craige	use HRESULTs
 *   20-mar-95	craige	allow NULL rect to disable cliplist
 *   31-mar-95	craige	don't allow hWnd to be updated if in exclusive mode
 *			and requesting process isn't the holder
 *   01-apr-95	craige	happy fun joy updated header file
 *   12-apr-95	craige	proper call order for csects
 *   15-apr-95	craige	flags for GetFlipStatus, added GetBltStatus
 *   16-apr-95	craige	flip between two specific surfaces was broken
 *   06-may-95	craige	use driver-level csects only
 *   23-may-95	craige	no longer use MapLS_Pool
 *   24-may-95	craige	added Restore
 *   28-may-95	craige	cleaned up HAL: added GetBltStatus; GetFlipStatus
 *   04-jun-95	craige	flesh out Restore; check for SURFACE_LOST inside csect;
 *			added IsLost
 *   11-jun-95	craige	prevent restoration of primary if different mode
 *   12-jun-95	craige	new process list stuff
 *   13-jun-95  kylej   moved FindAttachedFlip to misc.c
 *   17-jun-95	craige	new surface structure
 *   19-jun-95	craige	split out surface notification methods
 *   20-jun-95	craige	go get current clip list if user didn't specify one
 *   24-jun-95  kylej   added MoveToSystemMemory
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   27-jun-95	craige	don't let surfaces be restored if the mode is different
 *   28-jun-95	craige	fixed flip for overlays; ENTER_DDRAW at start of fns
 *   30-jun-95	kylej	only allow flip in exclusive mode, only allow surface
 *			restore in same video mode it was created, force
 *			primary to match existing primaries upon restore if
 *                      not exclusive, added GetProcessPrimary,
 *			InvalidateAllPrimarySurfaces, FindGlobalPrimary,
 *                      and MatchPrimary
 *   30-jun-95	craige	use DDRAWI_HASPIXELFORMAT/HASOVERLAYDATA
 *   01-jul-95	craige	allow flip always - just fail creation of flipping
 *   04-jul-95	craige	YEEHAW: new driver struct; SEH; redid Primary fns;
 *			fixes to MoveToSystemMemory; fixes to
 *			InvalidateAllPrimarySurfaces
 *   05-jul-95	craige	added Initialize
 *   07-jul-95	craige	added test for BUSY
 *   08-jul-95	craige	return DD_OK from Restore if surface is not lost;
 *			added InvalidateAllSurfaces
 *   09-jul-95	craige	Restore needs to reset pitch to aligned width before
 *			asking driver to reallocate; make MoveToSystemMemory
 *			recreate without VRAM so Restore can restore to sysmem
 *   11-jul-95	craige	GetDC fixes: no GetDC(NULL); need flag to check if
 *			DC has been allocated
 *   15-jul-95	craige	fixed flipping to move heap along with ptr
 *   15-jul-95  ericeng SetCompression if0 out, obsolete
 *   20-jul-95  toddla  fixed MoveToSystemMemory for 16bpp
 *   01-aug-95	craige	hold win16 lock at start of Flip
 *   04-aug-95	craige	have MoveToSystemMemory use InternalLock/Unlock
 *   10-aug-95  toddla  added DDFLIP_WAIT flag, but it is not turned on
 *   12-aug-95	craige	added use_full_lock in MoveToSystemMemory
 *   13-aug-95	craige	turned on DDFLIP_WAIT
 *   26-aug-95	craige	bug 717
 *   05-sep-95	craige	bug 894: don't invalidate SYSMEMREQUESTED surfaces
 *   10-sep-95	craige	bug 828: random vidmem heap free
 *   22-sep-95	craige	bug 1268,1269:  getbltstatus/getflipstatus flags wrong
 *   09-dec-95  colinmc added execute buffer support
 *   17-dec-95  colinmc added shared back and z-buffer support
 *   02-jan-96	kylej	handle new interface structs
 *   26-jan-96  jeffno	NT kernel conversation. NT Get/Release DC, flip GDI flag
 *   09-feb-96  colinmc surface invalid flag moved from the global to local
 *                      surface object
 *   17-feb-96  colinmc removed execute buffer size limitation
 *   26-feb-96  jeffno  GetDC for emulated offscreen now returns a new dc
 *   13-mar-96	kylej	Added DD_Surface_GetDDInterface
 *   17-mar-96  colinmc Bug 13124: flippable mip-maps
 *   14-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *                      surface
 *   26-mar-96  jeffno  Handle mode changes before flip (NT)
 *   05-sep-96	craige	added code to display frame rate to debug monitor
 *   05-jul-96  colinmc Work Item: Remove requirement on taking Win16 lock
 *                      for VRAM surfaces (not primary)
 *   07-oct-96	ketand	Change PageLock/Unlock to cache Physical Addresses
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   19-nov-96  colinmc Bug 4987: Fixed problems with Flip on the
 *                      IDirectDrawSurface2 interface
 *   10-jan-97  jeffno  Flip the primary chain flags so that GDI<==>Primary
 *                      after a ctrl-alt-del on NT.
 *   12-jan-97  colinmc More Win16 lock work
 *   18-jan-97  colinmc AGP support
 *   31-jan-97  colinmc Bug 5457: Fixed aliased locking (no Win16 lock)
 *                      problem with playing multiple AMovie clips at once.
 *   22-feb-97  colinmc Enabled OWNDC support for explicit system memory
 *                      surfaces
 *   03-mar-97  smac    Added kernel mode interface
 *   04-mar-97  smac    Bug 1987: Fixed bug flipping overlays when the
 *			surface didn't own the hardware
 *   08-mar-97  colinmc Added function to let surface pointer be overridden
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   24-mar-97  jeffno  Optimized Surfaces
 *   30-sep-97  jeffno  IDirectDraw4
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   11-nov-97 jvanaken New API call "Resize"
 *   18-dec-97 jvanaken SetSurfDesc will free client-alloc'd surface memory.
 *   25-may-00  RichGr  IA64: Change debug output to use %p format specifier
 *                      instead of %x for 32/64-bit pointers.
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
#endif
#define DPF_MODNAME	"GetCaps"

/* Shorter name makes flip code a little easier to understand */
#define GBLMORE(lpGbl) GET_LPDDRAWSURFACE_GBL_MORE(lpGbl)

/*
 * DD_Surface_GetCaps
 */
HRESULT DDAPI DD_Surface_GetCaps(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDDSCAPS lpDDSCaps )
{
    DDSCAPS2 ddscaps2 = {0,0,0,0};
    HRESULT  hr;

    DPF(2,A,"ENTERAPI: DD_Surface_GetCaps");

    hr = DD_Surface_GetCaps4(lpDDSurface, & ddscaps2 );
    if (hr == DD_OK)
    {
        TRY
        {
            lpDDSCaps->dwCaps = ddscaps2.dwCaps;
        }
        EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
	    DPF_ERR( "Invalid DDSCAPS pointer" );
	    return DDERR_INVALIDPARAMS;
        }
    }
    return hr;
}

HRESULT DDAPI DD_Surface_GetCaps4(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDDSCAPS2 lpDDSCaps )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetCaps4");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	if( !VALID_DDSCAPS2_PTR( lpDDSCaps ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	lpDDSCaps->dwCaps = this_lcl->ddsCaps.dwCaps;
	lpDDSCaps->ddsCapsEx = this_lcl->lpSurfMore->ddsCapsEx;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetCaps */

#undef DPF_MODNAME
#define DPF_MODNAME "GetFlipStatus"

/*
 * DD_Surface_GetFlipStatus
 */
HRESULT DDAPI DD_Surface_GetFlipStatus(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDHALSURFCB_GETFLIPSTATUS	gfshalfn;
    LPDDHALSURFCB_GETFLIPSTATUS	gfsfn;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetFlipStatus");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	if( dwFlags & ~DDGFS_VALID )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwFlags )
	{
	    if( (dwFlags & (DDGFS_CANFLIP|DDGFS_ISFLIPDONE)) ==
		    (DDGFS_CANFLIP|DDGFS_ISFLIPDONE) )
	    {
		DPF_ERR( "Invalid flags" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    DPF_ERR( "Invalid flags - no flag specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            DPF_ERR( "Invalid surface type: can't get flip status" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	#ifdef USE_ALIAS
	    if( pdrv->dwBusyDueToAliasedLock > 0 )
	    {
		/*
		 * Aliased locks (the ones that don't take the Win16 lock) don't
		 * set the busy bit either (it can't or USER get's very confused).
		 * However, we must prevent blits happening via DirectDraw as
		 * otherwise we get into the old host talking to VRAM while
		 * blitter does at the same time. Bad. So fail if there is an
		 * outstanding aliased lock just as if the BUST bit had been
		 * set.
		 */
		DPF_ERR( "Graphics adapter is busy (due to a DirectDraw lock)" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */

	/*
	 * device busy?
	 */
	if( *(pdrv->lpwPDeviceFlags) & BUSY )
	{
            DPF( 0, "BUSY" );
	    LEAVE_DDRAW()
	    return DDERR_SURFACEBUSY;
	}

	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
	{
	    LEAVE_DDRAW()
	    return DD_OK;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * ask the driver to get the current flip status
     */
    gfsfn = pdrv_lcl->lpDDCB->HALDDSurface.GetFlipStatus;
    gfshalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.GetFlipStatus;
    if( gfshalfn != NULL )
    {
	DDHAL_GETFLIPSTATUSDATA		gfsd;
	DWORD				rc;

    	gfsd.GetFlipStatus = gfshalfn;
	gfsd.lpDD = pdrv;
	gfsd.dwFlags = dwFlags;
	gfsd.lpDDSurface = this_lcl;
	DOHALCALL( GetFlipStatus, gfsfn, gfsd, rc, FALSE );
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    LEAVE_DDRAW();
	    return gfsd.ddRVal;
	}
    }

    LEAVE_DDRAW();
    // if you have to ask the hel, it's already done
    return DD_OK;

} /* DD_Surface_GetFlipStatus */

#undef DPF_MODNAME
#define DPF_MODNAME "InternalGetBltStatus"
HRESULT InternalGetBltStatus(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_LCL this_lcl , DWORD dwFlags )
{
    DDHAL_GETBLTSTATUSDATA		gbsd;
    LPDDHALSURFCB_GETBLTSTATUS 	        gbsfn;
    /*
     * Ask the driver to get the current blt status
     *
     */
    if ( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
    {
        gbsfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus;
        gbsd.GetBltStatus = pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus;
    }
    else
    {
        gbsfn = pdrv_lcl->lpDDCB->HALDDSurface.GetBltStatus;
        gbsd.GetBltStatus = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.GetBltStatus;
    }

    if( gbsd.GetBltStatus != NULL )
    {
	DWORD				rc;

	gbsd.lpDD = pdrv_lcl->lpGbl;
	gbsd.dwFlags = dwFlags;
	gbsd.lpDDSurface = this_lcl;
	DOHALCALL( GetBltStatus, gbsfn, gbsd, rc, FALSE );
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    return gbsd.ddRVal;
	}
    }

    return DD_OK;
}
#undef DPF_MODNAME
#define DPF_MODNAME "GetBltStatus"

/*
 * DD_Surface_GetBltStatus
 */
HRESULT DDAPI DD_Surface_GetBltStatus(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT                     ddrval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetBltStatus");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( dwFlags & ~DDGBS_VALID )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwFlags )
	{
	    if( (dwFlags & (DDGBS_CANBLT|DDGBS_ISBLTDONE)) ==
		    (DDGBS_CANBLT|DDGBS_ISBLTDONE) )
	    {
		DPF_ERR( "Invalid flags" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    DPF_ERR( "Invalid flags - no flag specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	this = this_lcl->lpGbl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	#ifdef USE_ALIAS
	    if( pdrv->dwBusyDueToAliasedLock > 0 )
	    {
		/*
		 * Aliased locks (the ones that don't take the Win16 lock) don't
		 * set the busy bit either (it can't or USER get's very confused).
		 * However, we must prevent blits happening via DirectDraw as
		 * otherwise we get into the old host talking to VRAM while
		 * blitter does at the same time. Bad. So fail if there is an
		 * outstanding aliased lock just as if the BUST bit had been
		 * set.
		 */
		DPF_ERR( "Graphics adapter is busy (due to a DirectDraw lock)" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */

	/*
	 * device busy?
	 */
	if( *(pdrv->lpwPDeviceFlags) & BUSY )
	{
	    DPF( 0, "BUSY" );
	    LEAVE_DDRAW()
	    return DDERR_SURFACEBUSY;
	}

	// If DDCAPS_CANBLTSYSMEM is set, we have to let the driver tell us
	// whether a system memory surface is currently being blitted
	if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) &&
	    !( pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM ) )
	{
	    LEAVE_DDRAW()
	    return DD_OK;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    //
    // If the current surface is optimized, quit
    //
    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
        DPF_ERR( "It is an optimized surface" );
        LEAVE_DDRAW();
        return DDERR_ISOPTIMIZEDSURFACE;
    }

    ddrval = InternalGetBltStatus( pdrv_lcl, this_lcl, dwFlags );

    LEAVE_DDRAW();
    return ddrval;

} /* DD_Surface_GetBltStatus */

#if 0
/*
 * DD_Surface_Flush
 */
HRESULT DDAPI DD_Surface_Flush(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Flush");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_Flush */
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "Flip"

/*
 * FlipMipMapChain
 *
 * Flip a chain of mip-map surfaces.
 */
static HRESULT FlipMipMapChain( LPDIRECTDRAWSURFACE lpDDSurface,
			        LPDIRECTDRAWSURFACE lpDDSurfaceDest,
				DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_INT	next_int;
    LPDDRAWI_DDRAWSURFACE_LCL	next_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	next;
    LPDDRAWI_DDRAWSURFACE_INT	attached_int;
    FLATPTR			vidmem;
    LPVMEMHEAP			vidmemheap;
    ULONG_PTR			reserved;
    DWORD                       gdi_flag;
    ULONG_PTR                   handle;
    BOOL                        toplevel;
    int                         destindex;
    int                         thisindex;
    BOOL                        destfound;
    #ifdef USE_ALIAS
	FLATPTR                     aliasvidmem;
	FLATPTR                     aliasofvidmem;
    #endif /* USE_ALIAS */
    FLATPTR                     physicalvidmem;
    ULONG_PTR                   driverreserved;

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

	/*
	 * We validate each level of the mip-map before we do any
	 * flipping. This is in an effort to prevent half flipped
	 * surfaces.
	 */
	toplevel = TRUE;
	do
	{
	    /*
	     * At this point this_int points to the front buffer
	     * of a flippable chain of surface for this level of
	     * the mip-map.
	     */

	    /*
	     * Invalid source surface?
	     */
	    if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	    {
		DPF_ERR( "Invalid front buffer for flip" );
		return DDERR_INVALIDOBJECT;
	    }
	    this_lcl = this_int->lpLcl;
	    this = this_lcl->lpGbl;

	    /*
	     * Source surface lost?
	     */
	    if( SURFACE_LOST( this_lcl ) )
	    {
		DPF_ERR( "Can't flip - front buffer is lost" );
		return DDERR_SURFACELOST;
	    }

	    /*
	     * Source surface flippable?
	     */
	    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER) )
	    {
		DPF_ERR( "Can't flip - first surface is not a front buffer" );
		return DDERR_NOTFLIPPABLE;
	    }
	    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP) )
	    {
		DPF_ERR( "Surface is not flippable" );
		return DDERR_NOTFLIPPABLE;
	    }

	    /*
	     * Source surface locked?
	     */
	    if( this->dwUsageCount > 0 )
	    {
		DPF_ERR( "Can't flip - surface is locked" );
		return DDERR_SURFACEBUSY;
	    }

	    /*
	     * Validate destination surfaces of flip.
	     */
	    next_int = FindAttachedFlip( this_int );
	    if( next_int == NULL )
	    {
		DPF_ERR( "Can't flip - no surface to flip to" );
		return DDERR_NOTFLIPPABLE;
	    }

	    /*
	     * If this is the top level of the mip-map and a destination
	     * surface has been provided then we need to find out which
	     * buffer (by index) the supplied destination is so that we
	     * can flip to the matching buffers in the lower-level maps.
	     */
	    if( NULL != lpDDSurfaceDest )
	    {
		thisindex = 0;
		destfound = FALSE;
		if( toplevel )
		    destindex = -1;
	    }

	    do
	    {
		/*
		 * If a destination surface has been supplied then is this
		 * it?
		 */
		if( NULL != lpDDSurfaceDest )
		{
		    if( toplevel )
		    {
			/*
			 * As we may have multiple interfaces pointing to the same
			 * object we need to compare objects not interface pointers
			 */
			if( next_int->lpLcl == ( (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurfaceDest )->lpLcl )
			{
			    destindex = thisindex;
			    destfound = TRUE;
			}
		    }
		    else
		    {
			if( thisindex == destindex )
			{
			    destfound = TRUE;
			}
		    }
		}

		/*
		 * Invalid destination surface?
		 */
		if( !VALID_DIRECTDRAWSURFACE_PTR( next_int ) )
		{
		    DPF_ERR( "Can't flip - invalid back buffer" );
		    return DDERR_INVALIDOBJECT;
		}
		next_lcl = next_int->lpLcl;
		next = next_lcl->lpGbl;

		/*
		 * Destination surface lost?
		 */
		if( SURFACE_LOST( next_lcl ) )
		{
		    DPF_ERR( "Can't flip - back buffer is lost" );
		    return DDERR_SURFACELOST;
		}

		/*
		 * Destination surface locked?
		 */
		if( next->dwUsageCount > 0 )
		{
		    DPF_ERR( "Can't flip - back buffer is locked" );
		    return DDERR_SURFACEBUSY;
		}

		/*
		 * Ensure that both source and destination surfaces reside
		 * in the same kind of memory.
		 */
		if( ( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) &&
		      ( next_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY  ) ) ||
		    ( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY  ) &&
		      ( next_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) ) )
		{
		    DPF_ERR( "Can't flip between system/video memory surfaces" );
		    return DDERR_INVALIDPARAMS;
		}

		/*
		 * Next destination surface.
		 */
		next_int = FindAttachedFlip( next_int );
		thisindex++;

	    } while( next_int->lpLcl != this_int->lpLcl );

	    /*
	     * If a destination was supplied did we find it?
	     */
	    if( ( NULL != lpDDSurfaceDest ) && !destfound )
	    {
		/*
		 * Could not find the destination.
		 */
		DPF_ERR( "Can't flip - destination surface not found in flippable chain" );
		return DDERR_NOTFLIPPABLE;
	    }
	    DDASSERT( destindex != -1 );

	    /*
	     * Next mip-map level.
	     */
	    this_int = FindAttachedMipMap( this_int );
	    toplevel = FALSE;

	} while( this_int != NULL );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Now actually flip each level of the mip-map.
     */
    this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
    do
    {
	/*
	 * Process one level of the mip-map.
	 */

	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	/*
	 * Find the first destination surface of the flip.
	 */
	next_int = FindAttachedFlip( this_int );
	if( NULL != lpDDSurfaceDest )
	{
	    /*
	     * If an override destination has been provided find the
	     * appropriate back destination surface.
	     */
	    for( thisindex = 0; thisindex < destindex; thisindex++ )
		next_int = FindAttachedFlip( next_int );
	}

	DDASSERT( NULL != next_int );
	next_lcl = next_int->lpLcl;

	/*
	 * save the old values
	 */
	vidmem = next_lcl->lpGbl->fpVidMem;
	#ifdef USE_ALIAS
	    aliasvidmem = GBLMORE(next_lcl->lpGbl)->fpAliasedVidMem;
	    aliasofvidmem = GBLMORE(next_lcl->lpGbl)->fpAliasOfVidMem;
	#endif /* USE_ALIAS */
	physicalvidmem = GBLMORE(next_lcl->lpGbl)->fpPhysicalVidMem;
	driverreserved = GBLMORE(next_lcl->lpGbl)->dwDriverReserved;
	vidmemheap = next_lcl->lpGbl->lpVidMemHeap;
	reserved = next_lcl->lpGbl->dwReserved1;
	gdi_flag = next_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
	handle = next_lcl->hDDSurface;

	/*
	 * If a destination override was provided then find that destination surface
	 * and flip to it explicitly.
	 */
	if( NULL != lpDDSurfaceDest )
	{
	    next_lcl->lpGbl->lpVidMemHeap = this->lpVidMemHeap;
	    next_lcl->lpGbl->fpVidMem = this->fpVidMem;
	    #ifdef USE_ALIAS
		GBLMORE(next_lcl->lpGbl)->fpAliasedVidMem = GBLMORE(this)->fpAliasedVidMem;
		GBLMORE(next_lcl->lpGbl)->fpAliasOfVidMem = GBLMORE(this)->fpAliasOfVidMem;
	    #endif /* USE_ALIAS */
	    GBLMORE(next_lcl->lpGbl)->fpPhysicalVidMem = GBLMORE(this)->fpPhysicalVidMem;
	    GBLMORE(next_lcl->lpGbl)->dwDriverReserved = GBLMORE(this)->dwDriverReserved;
	    next_lcl->lpGbl->dwReserved1 = this->dwReserved1;
	    next_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
	    next_lcl->lpGbl->dwGlobalFlags |= this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
	    next_lcl->hDDSurface = this_lcl->hDDSurface;
	}
	else
	{
	    do
	    {
		/*
		 * Remaining buffers in the chain (including copying the source surface's
		 * data.
		 */
		attached_int = FindAttachedFlip( next_int );
		next_lcl->lpGbl->fpVidMem = attached_int->lpLcl->lpGbl->fpVidMem;
		#ifdef USE_ALIAS
		    GBLMORE(next_lcl->lpGbl)->fpAliasedVidMem = GBLMORE(attached_int->lpLcl->lpGbl)->fpAliasedVidMem;
		    GBLMORE(next_lcl->lpGbl)->fpAliasOfVidMem = GBLMORE(attached_int->lpLcl->lpGbl)->fpAliasOfVidMem;
		#endif /* USE_ALIAS */
		GBLMORE(next_lcl->lpGbl)->fpPhysicalVidMem = GBLMORE(attached_int->lpLcl->lpGbl)->fpPhysicalVidMem;
		GBLMORE(next_lcl->lpGbl)->dwDriverReserved = GBLMORE(attached_int->lpLcl->lpGbl)->dwDriverReserved;
		next_lcl->lpGbl->lpVidMemHeap = attached_int->lpLcl->lpGbl->lpVidMemHeap;
		next_lcl->lpGbl->dwReserved1 = attached_int->lpLcl->lpGbl->dwReserved1;
		next_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
		next_lcl->lpGbl->dwGlobalFlags |= attached_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
		next_lcl->hDDSurface = attached_int->lpLcl->hDDSurface;
		next_int = attached_int;
		next_lcl = next_int->lpLcl;

		/*
		 * NOTE: We must compare objects not interfaces (there may be many
		 * different interfaces pointing to the same objects) to prevent a
		 * infinite loop.
		 */
	    } while( next_int->lpLcl != this_int->lpLcl );
	}

	this->fpVidMem = vidmem;
	#ifdef USE_ALIAS
	    GBLMORE(this)->fpAliasedVidMem = aliasvidmem;
	    GBLMORE(this)->fpAliasOfVidMem = aliasofvidmem;
	#endif /* USE_ALIAS */
	GBLMORE(this)->fpPhysicalVidMem = physicalvidmem;
	GBLMORE(this)->dwDriverReserved = driverreserved;
	this->lpVidMemHeap = vidmemheap;
	this->dwReserved1 = reserved;
	this->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
	this->dwGlobalFlags |= gdi_flag;
	this_lcl->hDDSurface = handle;

	/*
	 * Next level of the mip-map.
	 */
	this_int = FindAttachedMipMap( this_int );

    } while( this_int != NULL );

    return DD_OK;

} /* FlipMipMapChain */

DWORD dwLastFrameRate = 0;
/*
 * updateFrameRate
 */
static void updateFrameRate( void )
{
    static DWORD		dwFlipCnt;
    static DWORD		dwFlipTime=0xffffffff;

    /*
     * work out the frame rate if required...
     */

    if( dwFlipTime == 0xffffffff )
    {
	dwFlipTime = GetTickCount();
    }

    dwFlipCnt++;
    if( dwFlipCnt >= 120 )
    {
	DWORD	time2;
	DWORD	fps;
	char	buff[256];
	time2 = GetTickCount() - dwFlipTime;
	fps = (dwFlipCnt*10000)/time2;
	wsprintf( buff, "FPS = %ld.%01ld\r\n", fps/10, fps % 10 );
        dwLastFrameRate = fps;

	/*
	 * OINK32 whines about OutputDebugString, so hide it...
	 */
	{
	    HANDLE	h;
	    h = LoadLibrary( "KERNEL32.DLL" );
	    if( h != NULL )
	    {
	        VOID (WINAPI *lpOutputDebugStringA)(LPCSTR) = (LPVOID)
                    GetProcAddress( h, "OutputDebugStringA" );
	        if( lpOutputDebugStringA != NULL )
	        {
	            lpOutputDebugStringA( buff );
	        }
		FreeLibrary( h );
	    }
	}
	dwFlipTime = GetTickCount();
	dwFlipCnt = 0;
    }

} /* updateFrameRate */

/*
 * DD_Surface_Flip
 *
 * Page flip to the next surface.   Only valid for surfaces which are
 * flippable.
 */
#undef DPF_MODNAME
#define DPF_MODNAME	"Flip"
HRESULT DDAPI DD_Surface_Flip(
		LPDIRECTDRAWSURFACE lpDDSurface,
                LPDIRECTDRAWSURFACE lpDDSurfaceDest,
                DWORD               dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	this_dest_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_dest_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	next_int;
    LPDDRAWI_DDRAWSURFACE_LCL	next_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	next_save_int;
    LPDDRAWI_DDRAWSURFACE_INT	attached_int;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_GBL	this_dest;
    DWORD			rc;
    


    BOOL			found_dest;
    DDHAL_FLIPTOGDISURFACEDATA  ftgsd;
    LPDDHAL_FLIPTOGDISURFACE    ftgshalfn;
    LPDDHAL_FLIPTOGDISURFACE	ftgsfn;
    DDHAL_FLIPDATA		fd;
    LPDDHALSURFCB_FLIP		fhalfn;
    LPDDHALSURFCB_FLIP		ffn;
    BOOL			emulation;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    DWORD                       caps;
    DWORD                       caps2;
    DWORD			dwNumSkipped;
    DWORD			dwCnt;

    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
	BOOL			bStereo;

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_Flip");
    /* DPF_ENTERAPI(lpDDSurface); */
    // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF(3,A,"   Dest surface: 0x%p, flags: 0x%08x", lpDDSurfaceDest, dwFlags);

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_BOTH();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	this_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurfaceDest;
	if( this_dest_int != NULL )
	{
	    if( !VALID_DIRECTDRAWSURFACE_PTR( this_dest_int ) )
	    {
		LEAVE_BOTH();
		return DDERR_INVALIDOBJECT;
	    }
	    this_dest_lcl = this_dest_int->lpLcl;
	    this_dest = this_dest_lcl->lpGbl;
	}
	else
	{
	    this_dest_lcl = NULL;
	    this_dest = NULL;
        }

        if( dwFlags & ~DDFLIP_VALID )
	    {
	        DPF_ERR( "Invalid flags") ;
	        LEAVE_BOTH();
	        return DDERR_INVALIDPARAMS;
	    }

        if (!LOWERTHANSURFACE7(this_int))
        {
            if (dwFlags & DDFLIP_DONOTWAIT)
            {
                dwFlags &= ~DDFLIP_WAIT;
            }
            else
            {
                dwFlags |= DDFLIP_WAIT;
            }
        }

	if( ( dwFlags & ( DDFLIP_EVEN | DDFLIP_ODD ) ) &&
	    !( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) )
	{
	    DPF_ERR( "Invalid flags") ;
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}

        if ( (dwFlags & DDFLIP_NOVSYNC) && (dwFlags & DDFLIP_INTERVALMASK) )
        {
            DPF_ERR( "Flip: DDFLIP_NOVSYNC and DDFLIP_INTERVALn are mutually exclusive") ;
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
        }

	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;
#ifdef WIN95
        if( !( pdrv_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_SCREENSAVER ) ||
            !( pdrv_lcl->dwLocalFlags & DDRAWILCL_POWEREDDOWN ) )
        {
#endif
            if( SURFACE_LOST( this_lcl ) )
            {
                LEAVE_BOTH();
                return DDERR_SURFACELOST;
            }
            if( this_dest != NULL )
            {
                if( SURFACE_LOST( this_dest_lcl ) )
                {
                    LEAVE_BOTH();
                    return DDERR_SURFACELOST;
                }
	    }
#ifdef WIN95
	}
#endif

	/*
	 * device busy?
	 */

	#ifdef USE_ALIAS
	    if( pdrv->dwBusyDueToAliasedLock > 0 )
	    {
		/*
		 * Aliased locks (the ones that don't take the Win16 lock) don't
		 * set the busy bit either (it can't or USER get's very confused).
		 * However, we must prevent blits happening via DirectDraw as
		 * otherwise we get into the old host talking to VRAM while
		 * blitter does at the same time. Bad. So fail if there is an
		 * outstanding aliased lock just as if the BUST bit had been
		 * set.
		 */
		DPF_ERR( "Graphics adapter is busy (due to a DirectDraw lock)" );
		LEAVE_BOTH();
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */

	if( *(pdrv->lpwPDeviceFlags) & BUSY )
	{
            DPF( 0, "BUSY - Flip" );
	    LEAVE_BOTH()
	    return DDERR_SURFACEBUSY;
	}

	/*
	 * make sure that it's OK to flip this surface
	 */

    // DX7Stereo
    if(dwFlags & DDFLIP_STEREO)
	{
        if (!(this_lcl->dwFlags & DDRAWISURF_STEREOSURFACELEFT))
        {
	        DPF_ERR( "Invalid DDFLIP_STEREO flag on non stereo flipping chain") ;
	        LEAVE_BOTH();
	        return DDERR_INVALIDPARAMS;
        } 
	}

	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER) )
	{
            DPF_ERR("Can't flip because surface is not a front buffer");
	    LEAVE_BOTH();
	    return DDERR_NOTFLIPPABLE;		// ACKACK: real error??
	}
	if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP) )
	{
            DPF_ERR("Can't flip because surface is not a DDSCAPS_FLIP surface");
	    LEAVE_BOTH();
	    return DDERR_NOTFLIPPABLE;		// ACKACK: real error??
	}
	if( this->dwUsageCount > 0 )
        {
            DPF_ERR( "Can't flip because surface is locked" );
            LEAVE_BOTH();
            return DDERR_SURFACEBUSY;
	}
        if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) &&
            (pdrv->lpExclusiveOwner != pdrv_lcl ) )
	{
	    DPF_ERR( "Can't flip without exclusive access." );
	    LEAVE_BOTH();
	    return DDERR_NOEXCLUSIVEMODE;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_BOTH();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Mip-map chain? In which case take special action.
     */
    if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) &&
        (0==(this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)) )
    {
	rc = FlipMipMapChain( lpDDSurface, lpDDSurfaceDest, dwFlags );
	LEAVE_BOTH();
	return rc;
    }

    /*
     * If this is the primary and the driver had previously flipped
     * to display the GDI surface then we are now flipping away from
     * the GDI surface so we need to let the driver know.
     */
    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) &&
	( pdrv->dwFlags & DDRAWI_FLIPPEDTOGDI ) )
    {
	/*
	 * Notify the driver that we are about to flip away from the
	 * GDI surface.
	 *
	 * NOTE: This is a HAL only call - it means nothing to
	 * the HEL.
	 *
	 * NOTE: If the driver handles this call then we do not
	 * attempt to do the actual flip. This is to support cards
	 * which do not have GDI surfaces. If the driver does not
	 * handle the call we will continue on and do the flip.
	 */
	ftgsfn    = pdrv_lcl->lpDDCB->HALDD.FlipToGDISurface;
	ftgshalfn = pdrv_lcl->lpDDCB->cbDDCallbacks.FlipToGDISurface;
	if( NULL != ftgshalfn )
	{
	    ftgsd.FlipToGDISurface = ftgshalfn;
	    ftgsd.lpDD             = pdrv;
	    ftgsd.dwToGDI          = FALSE;
	    ftgsd.dwReserved       = 0UL;
	    DOHALCALL( FlipToGDISurface, ftgsfn, ftgsd, rc, FALSE );
	    if( DDHAL_DRIVER_HANDLED == rc )
	    {
		if( !FAILED( ftgsd.ddRVal ) )
		{
		    /*
		     * Driver is no longer flipped to the GDI surface.
		     */
		    pdrv->dwFlags &= ~DDRAWI_FLIPPEDTOGDI;
		    DPF( 4, "Driver handled the flip away from the GDI surface" );
		    LEAVE_BOTH();
		    return ftgsd.ddRVal;
		}
		else
		{
		    DPF_ERR( "Driver failed the flip away from the GDI surface" );
		    LEAVE_BOTH();
		    return ftgsd.ddRVal;
		}
	    }
	}
    }

    /*
     * make sure no surfaces are in use
     */
    found_dest = FALSE;
    if( ( lpDDSurface == lpDDSurfaceDest ) &&
        ( dwFlags & (DDFLIP_EVEN | DDFLIP_ODD) ) )
    {
        next_save_int = next_int = this_int;
        dwCnt = dwNumSkipped = 0;
    }
    else
    {
        next_save_int = next_int = FindAttachedFlip( this_int );
        dwCnt = dwNumSkipped = 1;
    }
    if( next_int == NULL )
    {
        DPF_ERR("Can't flip: No attached flippable surface");
	LEAVE_BOTH();
	return DDERR_NOTFLIPPABLE;		// ACKACK: real error?
    }

    do
    {
	if( SURFACE_LOST( next_int->lpLcl ) )
	{
	    DPF_ERR( "Can't flip - back buffer is lost" );
	    LEAVE_BOTH();
	    return DDERR_SURFACELOST;
	}

	if( next_int->lpLcl->lpGbl->dwUsageCount != 0 )
	{
            /*
             * Previously we didn't allow Flips to suceed if any of the surfaces
             * are lost, but DShow really wants to be able to do this so now we'll
             * allow it as long as we aren't going to rotate the memory pointers, etc.
             * for the locked surface.
             */
            if( ( this_dest_lcl == NULL ) ||
                ( this_dest_lcl == next_int->lpLcl ) ||
                ( this_lcl == next_int->lpLcl ) )
            {
	        LEAVE_BOTH();
                return DDERR_SURFACEBUSY;
            }
	}

	/*
	 * Do not allow flipping if any of the surfaces are used in kernel
	 * mode because we don't want the pointers to rotate.
	 */
    	lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( next_int->lpLcl->lpGbl );
    	if( lpSurfGblMore->hKernelSurface != 0 )
	{
	    DPF_ERR( "Can't flip - kernel mode is using surface" );
	    LEAVE_BOTH();
            return DDERR_SURFACEBUSY;
	}

	/*
	 * NOTE: Do NOT compare interface pointers here as we may
	 * well have multiple interfaces to the same surface object (i.e.,
	 * V1, V2, V3 etc.). Compare against the LOCAL object. This is the
	 * real object being handled.
	 */
	if( ( NULL != this_dest_int ) && ( this_dest_int->lpLcl == next_int->lpLcl ) )
	{
	    dwNumSkipped = dwCnt;
	    found_dest = TRUE;
	}
	dwCnt++;
	next_int = FindAttachedFlip( next_int );
    } while( next_int->lpLcl != this_int->lpLcl );

    /*
     * see if we can use the specified destination
     */
    if( this_dest_int != NULL )
    {
	if( !found_dest )
	{
	    DPF_ERR( "Destination not part of flipping chain!" );
	    LEAVE_BOTH();
	    return DDERR_NOTFLIPPABLE;		// ACKACK: real error?
	}
	next_save_int = this_dest_int;
    }

    /*
     * found the linked surface we want to flip to
     */
    next_int = next_save_int;

    /*
     * don't allow two destinations to be different (in case of a mixed chain)
     */
    next_lcl = next_int->lpLcl;
    if( ((next_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
         (this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) ||
    	((next_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
         (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)) )
    {
	DPF_ERR( "Can't flip between video/system memory surfaces" );
	LEAVE_BOTH();
	return DDERR_INVALIDPARAMS;
    }

//    DPF(9," flip (%d) Source Kernel handle is %08x, dest is %08x",__LINE__,this_lcl->hDDSurface,next_lcl->hDDSurface);
//    DPF(9," flip source vidmem is %08x, dest is %08x",this->fpVidMem,next_lcl->lpGbl->fpVidMem);
    /*
     * is this an emulation surface or driver surface?
     */
    if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
    {
	ffn = pdrv_lcl->lpDDCB->HELDDSurface.Flip;
    	fhalfn = ffn;
	emulation = TRUE;
	caps = pdrv->ddHELCaps.dwCaps;
	caps2 = pdrv->ddHELCaps.dwCaps2;
    }
    else
    {
	ffn = pdrv_lcl->lpDDCB->HALDDSurface.Flip;
    	fhalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.Flip;
	emulation = FALSE;
	caps = pdrv->ddCaps.dwCaps;
	caps2 = pdrv->ddCaps.dwCaps2;
    }

    /*
     * If the surface is fed by a video port, also flip the video port
     */
    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) && dwNumSkipped )
    {
	rc = FlipVideoPortSurface( this_int, dwNumSkipped );
	if( rc != DD_OK )
	{
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}
    }

#ifdef WINNT
    /*
     * If ~ 50 seconds have passed (assuming a 10Hz flip rate)
     * and this is a primary surface, then make a magic call to 
     * disable screen savers.
     * This isn't needed on 9x since we make a SPI call on that OS
     * to disable screen savers.
     * We don't do this if the app is itself a screen-saver, since
     * that would also disable the power-down.
     */
    if( !( pdrv_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_SCREENSAVER ))
    {
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
        {
            static DWORD dwMagicTime = 0;
            dwMagicTime++;
            if (dwMagicTime > (50*10) )
            {
                DWORD dw=60*15;
                dwMagicTime = 0;
                SystemParametersInfo(SPI_GETSCREENSAVETIMEOUT,0,&dw,0);
                SystemParametersInfo(SPI_SETSCREENSAVETIMEOUT,dw,0,0);
            }
        }
    }
#endif

    /*
     * Driver should be told its cache is invalid if the surface was flipped
     */
    BUMP_SURFACE_STAMP(this);
    BUMP_SURFACE_STAMP(next_lcl->lpGbl);

    /*
     * ask the driver to flip to the new surface if we are flipping
     * a primary surface (or if we are flipping an overlay surface and
     * the driver supports overlays.)
     */
    
    bStereo = (BOOL) (this_lcl->dwFlags & DDRAWISURF_STEREOSURFACELEFT);

    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) ||
        ( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) &&
	  ( caps & DDCAPS_OVERLAY ) &&
	  ( this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE ) ) )
    {
	if( fhalfn != NULL )
	{
    	    fd.Flip = fhalfn;
	    fd.lpDD = pdrv;
            fd.dwFlags = (dwFlags & ~DDFLIP_WAIT);
	    fd.lpSurfCurr = this_lcl;
	    fd.lpSurfTarg = next_lcl;

            // DX7Stereo
	    fd.lpSurfCurrLeft = NULL;
	    fd.lpSurfTargLeft = NULL;

            if (bStereo &&
                fd.dwFlags & DDFLIP_STEREO )
            {
                LPDDRAWI_DDRAWSURFACE_INT temp_this_int;
                LPDDRAWI_DDRAWSURFACE_INT temp_next_int;
                temp_this_int = FindAttachedSurfaceLeft(this_int);
                temp_next_int = FindAttachedSurfaceLeft(next_int);
                // oops, error
                if (temp_this_int!=NULL && temp_next_int!=NULL)
                {
                    fd.lpSurfCurrLeft = temp_this_int->lpLcl;
                    fd.lpSurfTargLeft = temp_next_int->lpLcl;

                }

                if (fd.lpSurfCurrLeft==NULL || fd.lpSurfTargLeft==NULL)
                {
                    fd.lpSurfCurrLeft = NULL;
                    fd.lpSurfTargLeft = NULL;

                    fd.dwFlags &= ~DDFLIP_STEREO;
                }

            }
            if (DDRAW_REGFLAGS_FLIPNONVSYNC & dwRegFlags)
            {
                fd.dwFlags &= ~DDFLIP_INTERVALMASK;
                fd.dwFlags |= DDFLIP_NOVSYNC;
            }
            if (caps2 & DDCAPS2_FLIPINTERVAL)
            {
                //if the user didn't specify a flip interval, give the driver 'one'
                //Also, make the interval consistent with FLIPNOVSYNC: if FLIPNOVSYNC is set,
                //then we should keep the interval set to 0.
                if ( ((fd.dwFlags & DDFLIP_INTERVALMASK) == 0) && ((dwFlags & DDFLIP_NOVSYNC)==0) )
                {
                    fd.dwFlags |= DDFLIP_INTERVAL1;
                }
            }
            else
            {
                //don't let old drivers see the flip intervals
                fd.dwFlags &= ~DDFLIP_INTERVALMASK;
            }

            //don't let old drivers see novsync
            if ( (caps2 & DDCAPS2_FLIPNOVSYNC) == 0 )
            {
                fd.dwFlags &= ~DDFLIP_NOVSYNC;
            }

try_again:
            DOHALCALL_NOWIN16( Flip, ffn, fd, rc, emulation );
	    if( rc == DDHAL_DRIVER_HANDLED )
            {
                if( fd.ddRVal != DD_OK )
                {
                    if( (dwFlags & DDFLIP_WAIT) && fd.ddRVal == DDERR_WASSTILLDRAWING )
                    {
                        DPF(4,"Waiting.....");
                        goto try_again;
                    }
		    LEAVE_BOTH();
		    return fd.ddRVal;
                }

                /*
                 * emulation, does not need the pointers rotated we are done
                 *
                 * NOTE we should do this with a special return code or
                 * even a rester cap, but for now this is as good as any.
                 */
                if( emulation )
                {
		    LEAVE_WIN16LOCK();
		    if( dwRegFlags & DDRAW_REGFLAGS_SHOWFRAMERATE )
		    {
			updateFrameRate();
		    }
		    LEAVE_DDRAW();
                    return DD_OK;
                }
	    }
	}
        else
        {
	    LEAVE_BOTH();
	    return DDERR_NOFLIPHW;
        }
    }

    /*
     * save the old values
     */

    if( dwNumSkipped )
    {
    	#ifdef USE_ALIAS
	FLATPTR                     aliasvidmem;
	FLATPTR                     aliasofvidmem;
	#endif /* USE_ALIAS */
	FLATPTR			    vidmem;
	LPVMEMHEAP		    vidmemheap;
	FLATPTR                     physicalvidmem;
	ULONG_PTR                   driverreserved;
	ULONG_PTR		reserved;
	DWORD                       gdi_flag;
	ULONG_PTR                   handle;
	// same stack for left surface if we rotate stereo buffers
        #ifdef USE_ALIAS
	FLATPTR                     leftaliasvidmem;
	FLATPTR                     leftaliasofvidmem;
	#endif /* USE_ALIAS */
	FLATPTR			    leftvidmem;
	LPVMEMHEAP			leftvidmemheap;
	FLATPTR                     leftphysicalvidmem;
	ULONG_PTR                   leftdriverreserved;
	DWORD                       leftgdi_flag;
	ULONG_PTR			leftreserved;
	ULONG_PTR                   lefthandle;

    DWORD                       dwSurfaceHandle;
    DWORD                       dwLeftSurfaceHandle;


	LPDDRAWI_DDRAWSURFACE_INT	next_left_int;
	LPDDRAWI_DDRAWSURFACE_LCL	next_left_lcl;



        DPF(4,"Flip:rotating pointers etc");
        vidmem = next_lcl->lpGbl->fpVidMem;
        #ifdef USE_ALIAS  
	    aliasvidmem = GBLMORE(next_lcl->lpGbl)->fpAliasedVidMem;
	    aliasofvidmem = GBLMORE(next_lcl->lpGbl)->fpAliasOfVidMem;
        #endif /* USE_ALIAS */
        physicalvidmem = GBLMORE(next_lcl->lpGbl)->fpPhysicalVidMem;
        driverreserved = GBLMORE(next_lcl->lpGbl)->dwDriverReserved;
        vidmemheap = next_lcl->lpGbl->lpVidMemHeap;
        reserved = next_lcl->lpGbl->dwReserved1;
        gdi_flag = next_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
        handle = next_lcl->hDDSurface;
        dwSurfaceHandle = next_lcl->lpSurfMore->dwSurfaceHandle;
	// DX7Stereo: save also left buffers
	if (bStereo)		
	{

		DPF(4,"Flip:rotating also stereo pointers etc");
		
		next_left_int = FindAttachedSurfaceLeft(next_int);
		if (next_left_int!=NULL)
		{
			next_left_lcl = next_left_int->lpLcl;
                        

                        leftvidmem = next_left_lcl->lpGbl->fpVidMem;
                        #ifdef USE_ALIAS
                        leftaliasvidmem = GBLMORE(next_left_lcl->lpGbl)->fpAliasedVidMem;
                        leftaliasofvidmem = GBLMORE(next_left_lcl->lpGbl)->fpAliasOfVidMem;
                        #endif /* USE_ALIAS */
                        leftphysicalvidmem = GBLMORE(next_left_lcl->lpGbl)->fpPhysicalVidMem;
                        leftdriverreserved = GBLMORE(next_left_lcl->lpGbl)->dwDriverReserved;
                        leftvidmemheap = next_left_lcl->lpGbl->lpVidMemHeap;
                        leftreserved = next_left_lcl->lpGbl->dwReserved1;
                        leftgdi_flag = next_left_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
                        lefthandle = next_left_lcl->hDDSurface;
                        dwLeftSurfaceHandle = next_left_lcl->lpSurfMore->dwSurfaceHandle;

		} else
		{
			DPF(0,"Flip:rotating stereo pointers failed, dest. left surfaces invalid");
			bStereo=FALSE;
		}
	}

        /*
         * set the new primary surface pointer
         */
        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
        {
	    pdrv->vmiData.fpPrimary = vidmem;
        }

        /*
         * rotate the memory pointers
         */
        if( this_dest_lcl != NULL )
        {
	    next_lcl->lpGbl->lpVidMemHeap = this->lpVidMemHeap;
	    next_lcl->lpGbl->fpVidMem = this->fpVidMem;
	    #ifdef USE_ALIAS
	        GBLMORE(next_lcl->lpGbl)->fpAliasedVidMem = GBLMORE(this)->fpAliasedVidMem;
	        GBLMORE(next_lcl->lpGbl)->fpAliasOfVidMem = GBLMORE(this)->fpAliasOfVidMem;
	    #endif /* USE_ALIAS */
	    GBLMORE(next_lcl->lpGbl)->fpPhysicalVidMem = GBLMORE(this)->fpPhysicalVidMem;
	    GBLMORE(next_lcl->lpGbl)->dwDriverReserved = GBLMORE(this)->dwDriverReserved;
	    next_lcl->lpGbl->dwReserved1 = this->dwReserved1;
            next_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
            next_lcl->lpGbl->dwGlobalFlags |= this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
            next_lcl->hDDSurface = this_lcl->hDDSurface;
            next_lcl->lpSurfMore->dwSurfaceHandle = this_lcl->lpSurfMore->dwSurfaceHandle;

            if (this_lcl->lpSurfMore->dwSurfaceHandle)
            {
                // Since the SurfaceHandle was updated, update the mapping array
                SURFACEHANDLELIST(pdrv_lcl).dwList[this_lcl->lpSurfMore->dwSurfaceHandle].lpSurface = next_lcl;
            }
            if (bStereo)
            {
        	LPDDRAWI_DDRAWSURFACE_INT	this_left_int;
	        LPDDRAWI_DDRAWSURFACE_LCL	this_left_lcl;

                this_left_int = FindAttachedSurfaceLeft(this_int);
                this_left_lcl = this_left_int->lpLcl;

	        next_left_lcl->lpGbl->lpVidMemHeap = this_left_lcl->lpGbl->lpVidMemHeap;
	        next_left_lcl->lpGbl->fpVidMem = this_left_lcl->lpGbl->fpVidMem;
	        #ifdef USE_ALIAS
	        GBLMORE(next_left_lcl->lpGbl)->fpAliasedVidMem = GBLMORE(this_left_lcl->lpGbl)->fpAliasedVidMem;
	        GBLMORE(next_left_lcl->lpGbl)->fpAliasOfVidMem = GBLMORE(this_left_lcl->lpGbl)->fpAliasOfVidMem;
	        #endif /* USE_ALIAS */
	        GBLMORE(next_left_lcl->lpGbl)->fpPhysicalVidMem = GBLMORE(this_left_lcl->lpGbl)->fpPhysicalVidMem;
	        GBLMORE(next_left_lcl->lpGbl)->dwDriverReserved = GBLMORE(this_left_lcl->lpGbl)->dwDriverReserved;
                next_left_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
                next_left_lcl->lpGbl->dwGlobalFlags |= this_left_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
	        next_left_lcl->lpGbl->dwReserved1 = this_left_lcl->lpGbl->dwReserved1;
                next_left_lcl->hDDSurface = this_left_lcl->hDDSurface;                    
                next_left_lcl->lpSurfMore->dwSurfaceHandle = this_left_lcl->lpSurfMore->dwSurfaceHandle;
                if (this_left_lcl->lpSurfMore->dwSurfaceHandle)
                {
                    // Since the SurfaceHandle was updated, update the mapping array
                    SURFACEHANDLELIST(pdrv_lcl).dwList[this_left_lcl->lpSurfMore->dwSurfaceHandle].lpSurface = next_left_lcl;
                }
            }

        }
        else
        {
	    do
	    {
	        attached_int = FindAttachedFlip( next_int );
	        next_lcl = next_int->lpLcl;
	        next_lcl->lpGbl->lpVidMemHeap = attached_int->lpLcl->lpGbl->lpVidMemHeap;
	        next_lcl->lpGbl->fpVidMem = attached_int->lpLcl->lpGbl->fpVidMem;
	        #ifdef USE_ALIAS
		    GBLMORE(next_lcl->lpGbl)->fpAliasedVidMem = GBLMORE(attached_int->lpLcl->lpGbl)->fpAliasedVidMem;
		    GBLMORE(next_lcl->lpGbl)->fpAliasOfVidMem = GBLMORE(attached_int->lpLcl->lpGbl)->fpAliasOfVidMem;
	        #endif /* USE_ALIAS */
	        GBLMORE(next_lcl->lpGbl)->fpPhysicalVidMem = GBLMORE(attached_int->lpLcl->lpGbl)->fpPhysicalVidMem;
	        GBLMORE(next_lcl->lpGbl)->dwDriverReserved = GBLMORE(attached_int->lpLcl->lpGbl)->dwDriverReserved;
	        next_lcl->lpGbl->dwReserved1 = attached_int->lpLcl->lpGbl->dwReserved1;
                next_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
                next_lcl->lpGbl->dwGlobalFlags |= attached_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
                next_lcl->hDDSurface = attached_int->lpLcl->hDDSurface;
                next_lcl->lpSurfMore->dwSurfaceHandle = attached_int->lpLcl->lpSurfMore->dwSurfaceHandle;
                if (attached_int->lpLcl->lpSurfMore->dwSurfaceHandle)
                {
                    // Since the SurfaceHandle was updated, update the mapping array
                    SURFACEHANDLELIST(pdrv_lcl).dwList[attached_int->lpLcl->lpSurfMore->dwSurfaceHandle].lpSurface = next_lcl;
                }
                if (bStereo)
                {
             	        LPDDRAWI_DDRAWSURFACE_INT	attached_left_int;
	                LPDDRAWI_DDRAWSURFACE_LCL	attached_left_lcl;

                        attached_left_int = FindAttachedSurfaceLeft(attached_int);
                        next_left_int = FindAttachedSurfaceLeft(next_int);
                        if (attached_left_int!=NULL && next_left_int!=NULL)
                        {
                                attached_left_lcl=attached_left_int->lpLcl;
                                next_left_lcl=next_left_int->lpLcl;

	                        next_left_lcl->lpGbl->lpVidMemHeap = attached_left_int->lpLcl->lpGbl->lpVidMemHeap;
	                        next_left_lcl->lpGbl->fpVidMem = attached_left_int->lpLcl->lpGbl->fpVidMem;
	                        #ifdef USE_ALIAS
		                GBLMORE(next_left_lcl->lpGbl)->fpAliasedVidMem = GBLMORE(attached_left_int->lpLcl->lpGbl)->fpAliasedVidMem;
		                GBLMORE(next_left_lcl->lpGbl)->fpAliasOfVidMem = GBLMORE(attached_left_int->lpLcl->lpGbl)->fpAliasOfVidMem;
	                        #endif /* USE_ALIAS */
	                        GBLMORE(next_left_lcl->lpGbl)->fpPhysicalVidMem = GBLMORE(attached_left_int->lpLcl->lpGbl)->fpPhysicalVidMem;
	                        GBLMORE(next_left_lcl->lpGbl)->dwDriverReserved = GBLMORE(attached_left_int->lpLcl->lpGbl)->dwDriverReserved;
	                        next_left_lcl->lpGbl->dwReserved1 = attached_left_int->lpLcl->lpGbl->dwReserved1;
                                next_left_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
                                next_left_lcl->lpGbl->dwGlobalFlags |= attached_left_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
                                next_left_lcl->hDDSurface = attached_left_int->lpLcl->hDDSurface;
                                next_left_lcl->lpSurfMore->dwSurfaceHandle = attached_left_int->lpLcl->lpSurfMore->dwSurfaceHandle;
                                if (attached_left_int->lpLcl->lpSurfMore->dwSurfaceHandle)
                                {
                                    // Since the SurfaceHandle was updated, update the mapping array
                                    SURFACEHANDLELIST(pdrv_lcl).dwList[attached_left_int->lpLcl->lpSurfMore->dwSurfaceHandle].lpSurface = 
                                        next_left_lcl;
                                }
                        } else
                        {
                                DPF(0,"Flip:left surface pointers corrupted");
                                bStereo=FALSE;
                        }
                }

	        next_int = attached_int;
	        /*
	         * NOTE: Again, do NOT compare against interface pointers. We may
	         * have multiple interfaces to a single surface object leading to
	         * an infinite loop. Compare against the LOCAL object not the
	         * interface pointers.
	         */
	    } while( next_int->lpLcl != this_int->lpLcl );
        }
        this->fpVidMem = vidmem;
        #ifdef USE_ALIAS
	    GBLMORE(this)->fpAliasedVidMem = aliasvidmem;
	    GBLMORE(this)->fpAliasOfVidMem = aliasofvidmem;
        #endif /* USE_ALIAS */
        GBLMORE(this)->fpPhysicalVidMem = physicalvidmem;
        GBLMORE(this)->dwDriverReserved = driverreserved;
        this->lpVidMemHeap = vidmemheap;
        this->dwReserved1 = reserved;
        this->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
        this->dwGlobalFlags |= gdi_flag;
        this_lcl->hDDSurface = handle;
        this_lcl->lpSurfMore->dwSurfaceHandle=dwSurfaceHandle;

        if (dwSurfaceHandle)
        {
            // Since the SurfaceHandle was updated, update the mapping array
            SURFACEHANDLELIST(pdrv_lcl).dwList[dwSurfaceHandle].lpSurface = this_lcl;
        }
        if (bStereo)
        {
              	LPDDRAWI_DDRAWSURFACE_INT	this_left_int;
	        LPDDRAWI_DDRAWSURFACE_LCL	this_left_lcl;

                this_left_int = FindAttachedSurfaceLeft(this_int);
                if (this_left_int!=NULL)
                {
                        this_left_lcl = this_left_int->lpLcl;
                
                        this_left_lcl->lpGbl->fpVidMem = leftvidmem;
                        #ifdef USE_ALIAS
	                GBLMORE(this_left_lcl->lpGbl)->fpAliasedVidMem = leftaliasvidmem;
	                GBLMORE(this_left_lcl->lpGbl)->fpAliasOfVidMem = leftaliasofvidmem;
                        #endif /* USE_ALIAS */
                        GBLMORE(this_left_lcl->lpGbl)->fpPhysicalVidMem = leftphysicalvidmem;
                        GBLMORE(this_left_lcl->lpGbl)->dwDriverReserved = leftdriverreserved;
                        this_left_lcl->lpGbl->lpVidMemHeap = leftvidmemheap;
                        this_left_lcl->lpGbl->dwReserved1 = leftreserved;
                        this_left_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
                        this_left_lcl->lpGbl->dwGlobalFlags |= leftgdi_flag;
                        this_left_lcl->hDDSurface = lefthandle;
                        this_left_lcl->lpSurfMore->dwSurfaceHandle=dwLeftSurfaceHandle;
                        if (dwLeftSurfaceHandle)
                        {
                            // Since the SurfaceHandle was updated, update the mapping array
                            SURFACEHANDLELIST(pdrv_lcl).dwList[dwLeftSurfaceHandle].lpSurface = this_left_lcl;
                        }
                }
        }        
    }
    if ((GetCurrentProcessId() == GETCURRPID()) &&
        (pdrv_lcl->pSurfaceFlipNotify))
    {
        DDASSERT(pdrv_lcl->pD3DIUnknown != NULL);
        pdrv_lcl->pSurfaceFlipNotify(pdrv_lcl->pD3DIUnknown);
    }

    /*
     * If the driver was flipped to the GDI surface and we just flipped the
     * primary chain then we are no longer showing the GDI surface.
     */
    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) &&
	( pdrv->dwFlags & DDRAWI_FLIPPEDTOGDI ) )
    {
	pdrv->dwFlags &= ~DDRAWI_FLIPPEDTOGDI;
    }

    LEAVE_WIN16LOCK();
    if( dwRegFlags & DDRAW_REGFLAGS_SHOWFRAMERATE )
    {
	updateFrameRate();
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_Flip */

#undef DPF_MODNAME
#define DPF_MODNAME "GetPixelFormat"

/*
 * DD_Surface_GetPixelFormat
 */
HRESULT DDAPI DD_Surface_GetPixelFormat(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDDPIXELFORMAT lpDDPixelFormat )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDPIXELFORMAT		pddpf;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetPixelFormat");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_DDPIXELFORMAT_PTR( lpDDPixelFormat ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        /*
         * Execute buffers don't have a pixel format.
         */
        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            DPF_ERR( "Invalid surface type: can't get pixel format" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }
	this = this_lcl->lpGbl;
	GET_PIXEL_FORMAT( this_lcl, this, pddpf );
	*lpDDPixelFormat = *pddpf;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetPixelFormat */

#if 0
/* GEE: removed this, obsolete */
/*
 * DD_Surface_SetCompression
 */
HRESULT DDAPI DD_Surface_SetCompression(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDDPIXELFORMAT lpDDPixelFormat )
{
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetCompression");

    TRY
    {
	this_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	if( !VALID_DDPIXELFORMAT_PTR( lpDDPixelFormat ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_Surface_SetCompression */
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "GetSurfaceDesc"

/*
 * DD_Surface_GetSurfaceDesc
 */
HRESULT DDAPI DD_Surface_GetSurfaceDesc(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDDSURFACEDESC lpDDSurfaceDesc )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetSurfaceDesc");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_DDSURFACEDESC_PTR( lpDDSurfaceDesc ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;

	FillDDSurfaceDesc( this_lcl, lpDDSurfaceDesc );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetSurfaceDesc */

/*
 * DD_Surface_GetSurfaceDesc4
 */
HRESULT DDAPI DD_Surface_GetSurfaceDesc4(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDDSURFACEDESC2 lpDDSurfaceDesc )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetSurfaceDesc4");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
            DPF_ERR("Bad IDirectDrawSurfaceX pointer");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_DDSURFACEDESC2_PTR( lpDDSurfaceDesc ) )
	{
            DPF_ERR("Bad DDSURFACEDESC pointer");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;

	FillDDSurfaceDesc2( this_lcl, lpDDSurfaceDesc );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetSurfaceDesc4 */


#ifdef WIN95

#undef DPF_MODNAME
#define DPF_MODNAME "InternalGetDC"

/*
 * BIsValidDCFormat
 *
 * We should only try to get a DC on a format that GDI undersatnds
 */
BOOL bIsValidDCFormat( LPDDPIXELFORMAT lpPf )
{
    //
    // Must be an RGB format
    //
    if( !(lpPf->dwFlags & DDPF_RGB ) )
    {
        return FALSE;
    }

    //
    // Assume that 1, 4, and 8bpp surfaces are OK
    //
    if( ( lpPf->dwRGBBitCount == 8 ) ||
        ( lpPf->dwRGBBitCount == 4 ) ||
        ( lpPf->dwRGBBitCount == 1 ) )
    {
        return TRUE;
    }

    //
    // If it's 16bpp, it must be 5:5:5 or 5:6:5
    //
    if( lpPf->dwRGBBitCount == 16 )
    {
        if( ( lpPf->dwRBitMask == 0xf800 ) &&
            ( lpPf->dwGBitMask == 0x07e0 ) &&
            ( lpPf->dwBBitMask == 0x001f ) )
        {
            // 5:6:5
            return TRUE;
        }
        else if( ( lpPf->dwRBitMask == 0x7c00 ) &&
            ( lpPf->dwGBitMask == 0x03e0 ) &&
            ( lpPf->dwBBitMask == 0x001f ) )
        {
            // 5:5:5
            return TRUE;
        }
    }
    else if( ( lpPf->dwRGBBitCount == 24 ) ||
        ( lpPf->dwRGBBitCount == 32 ) )
    {
        if( ( lpPf->dwBBitMask == 0x0000FF ) &&
            ( lpPf->dwGBitMask == 0x00FF00 ) &&
            ( lpPf->dwRBitMask == 0xFF0000 ) )
        {
            // 8:8:8 
            return TRUE;
        }
    }

    return FALSE;
}


/*
 * InternalGetDC
 *
 * This is the Windows 95 version of this function. The code paths are so radically
 * different that we have broken this stuff out into two different functions.
 *
 * This functions assumes the DDRAW critical section is already held.
 *
 * This function will not return the OWNDC for an OWNDC surface. It always allocates
 * a new DC.
 */
HRESULT InternalGetDC( LPDDRAWI_DDRAWSURFACE_INT this_int, HDC FAR* lphdc, BOOL bWin16Lock)
{
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT			ddrval;
    HRESULT			tmprval;
    DDSURFACEDESC		ddsd;
    LPVOID			pbits;
    DWORD   dwLockFlags = bWin16Lock ? DDLOCK_TAKE_WIN16 : 0;
    DDASSERT( NULL != this_int );
    DDASSERT( NULL != lphdc );

    this_lcl = this_int->lpLcl;
    DDASSERT( NULL != this_lcl );

    this = this_lcl->lpGbl;
    DDASSERT( NULL != this );

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    DDASSERT( NULL != pdrv_lcl );

    pdrv = pdrv_lcl->lpGbl;
    DDASSERT( NULL != pdrv );

    *lphdc = NULL;

    /* Get a pointer to the bits of the surface */
    ddrval = InternalLock( this_lcl, &pbits, NULL , DDLOCK_WAIT | dwLockFlags );

    if( ddrval == DD_OK )
    {
        LPDDRAWI_DDRAWPALETTE_INT ppal;

	DPF( 4,"GetDC: Lock succeeded." );

        ddsd.dwSize = sizeof(ddsd);
        FillDDSurfaceDesc( this_lcl, &ddsd );
        ddsd.lpSurface = pbits;

        ppal = this_lcl->lpDDPalette;

        if( ( NULL != ppal ) && !( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
            *lphdc = DD16_GetDC( (HDC)pdrv_lcl->hDC, &ddsd, ppal->lpLcl->lpGbl->lpColorTable );
        else
            *lphdc = DD16_GetDC( (HDC)pdrv_lcl->hDC, &ddsd, NULL );

        if( NULL == *lphdc )
        {
	    tmprval = InternalUnlock( this_lcl, NULL, NULL, dwLockFlags );
	    DDASSERT( !FAILED(tmprval) );
            DPF_ERR( "Could not obtain DC" );
            ddrval = DDERR_CANTCREATEDC;
        }
        else
        {
	    ddrval = InternalAssociateDC( *lphdc, this_lcl );
	    if( FAILED( ddrval ) )
	    {
		DPF_ERR( "Could not associate DC" );
                DD16_ReleaseDC( *lphdc );
		tmprval = InternalUnlock( this_lcl, NULL, NULL, dwLockFlags );
		DDASSERT( !FAILED(tmprval) );
		*lphdc = NULL;
	    }
	    else
	    {
		this_lcl->dwFlags |= DDRAWISURF_HASDC;

		/*
		 * Currenlty OWNDC is only valid for EXPLICIT system
		 * memory surfaces so we don't need to hold the lock
		 * (cause the surface can't be lost).
		 *
		 * This is an OWNDC surface so we don't hold a lock
		 * for the duration. Unlock the surface now.
		 */
		if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC )
		{
		    tmprval = InternalUnlock( this_lcl, NULL, NULL, dwLockFlags );
		    DDASSERT( !FAILED(tmprval) );
		}
	    }
        }
    } //if InternalLock succeeded
    // We could not lock the primary surface.  This is because the
    // primary is already locked (and we should wait until it is
    // unlocked) or we have no ddraw support AND no DCI support in
    // the driver (in which case the HEL has created the primary
    // and we will NEVER be able to lock it. In this case, we are
    // on an emulated primary and the lock failed with
    // DDERR_GENERIC.
    else if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) &&
	     ( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )   &&
	     ( ddrval != DD_OK ) )
    {
	#ifdef GETDC_NULL
	    DPF( 4, "GetDC: Returning GetDC(NULL).");
	    *lphdc = GetDC( NULL );
	#else
	    DPF( 4, "GetDC: Returning device DC.");
	    DDASSERT( GetObjectType( (HDC)pdrv_lcl->hDC ) == OBJ_DC );
	    *lphdc = (HDC)pdrv_lcl->hDC;
	#endif

	if( NULL != *lphdc )
        {
	    ddrval = InternalAssociateDC( *lphdc, this_lcl );
	    if( FAILED( ddrval ) )
	    {
                DPF_ERR( "Could not associate DC" );
		#ifdef GETDC_NULL
		    ReleaseDC( NULL, *lphdc );
		#endif
		*lphdc = NULL;
	    }
	    else
	    {
		// signal to ourselves that we gave a DC without
		// locking.
		this_lcl->dwFlags |= ( DDRAWISURF_GETDCNULL | DDRAWISURF_HASDC );

		if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
		{
		    this->dwUsageCount++;
		    CHANGE_GLOBAL_CNT( pdrv, this, 1 );
		}
	    }
	}
	else
	{
            DPF_ERR( "Could not obtain DC" );
	    ddrval = DDERR_CANTCREATEDC;
	}
    }
    else
    {
        /*
         * InternalLock failed, and the surface wasn't an emulated primary
         */
        DPF_ERR( "Could not obtain DC" );
	ddrval = DDERR_CANTCREATEDC;
    }

    /*
     * If we managed to get a DC and we are an OWNDC surface then stash the HDC away
     * for future reference.
     */
    if( ( !FAILED(ddrval) ) && ( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
    {
	DDASSERT( NULL != *lphdc );
	DDASSERT( 0UL  == this_lcl->hDC );

	this_lcl->hDC = (DWORD)*lphdc;
    }

    return ddrval;
} /* InternalGetDC */

#undef DPF_MODNAME
#define DPF_MODNAME "InternalReleaseDC"

/*
 * InternalReleaseDC - Windows 95 version
 *
 * Assumes the DirectDraw critical section is already held
 */
HRESULT InternalReleaseDC( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, HDC hdc, BOOL bWin16Lock )
{
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT                     ddrval;

    #ifdef WINNT
       GdiFlush();
    #endif

    DDASSERT( NULL != this_lcl );
    DDASSERT( NULL != hdc );

    this = this_lcl->lpGbl;
    DDASSERT( NULL != this );

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    DDASSERT( NULL != pdrv_lcl );

    pdrv = pdrv_lcl->lpGbl;
    DDASSERT( NULL != pdrv );

    ddrval = DD_OK;

    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) &&
	( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )   &&
	( this_lcl->dwFlags & DDRAWISURF_GETDCNULL ) )
    {
	DPF( 4, "ReleaseDC: ReleaseDC(NULL)" );

	if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
	{
	    this->dwUsageCount--;
	    CHANGE_GLOBAL_CNT( pdrv, this, -1 );
	}
	#ifdef GETDC_NULL
	    /*
	     * Only actually free the HDC if we are running in the
	     * application's context and not DDHELP's (if we are
	     * running on DDHELP's the HDC is already gone)
	     */
	    if( GetCurrentProcessId() == GETCURRPID() )
		ReleaseDC( NULL, hdc );
	#endif
	this_lcl->dwFlags &= ~DDRAWISURF_GETDCNULL;
    }
    else
    {
	DPF( 4, "ReleaseDC: DD16_ReleaseDC()");

	/*
	 * Free the thing to give DDraw16 a chance
	 * to clean up what it's messed with. We can do this on
	 * the helper thread because DCs that are created by
	 * DD16_GetDC are 'alive' until DDRAW16 gets unloaded.
	 * However, they are dangerous because they point to data
	 * that might have been freed by the current app.
	 */
	DD16_ReleaseDC( hdc );

	/*
	 * Only unlock if its not an OWNDC surface as OWNDC surfaces
	 * don't hold the lock while the HDC is out.
	 */
	if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
	{
	    ddrval = InternalUnlock( this_lcl, NULL, NULL, bWin16Lock ? DDLOCK_TAKE_WIN16 : 0);
	    DDASSERT( !FAILED( ddrval ) );
	}
    }

    this_lcl->dwFlags &= ~DDRAWISURF_HASDC;

    // Remove this DC from our list
    InternalRemoveDCFromList( hdc, this_lcl );

    /*
     * If this is an OWNDC surface then remove it from the HDC cache
     * in the local object.
     */
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC )
	this_lcl->hDC = 0UL;

    return ddrval;
} /* InternalReleaseDC */

#else /* WIN95 */

#undef DPF_MODNAME
#define DPF_MODNAME "InternalGetDC"

/*
 * InternalGetDC - WinNT version
 *
 * This is the Windows NT version of this function. The code paths are so radically
 * different that we have broken this stuff out into two different functions.
 *
 * This functions assumes the DDRAW mutex is already held.
 *
 * This function will not return the OWNDC for an OWNDC surface. It always allocates
 * a new DC.
 */
HRESULT InternalGetDC( LPDDRAWI_DDRAWSURFACE_INT this_int, HDC FAR* lphDC )
{
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT                     ddrval;

    DDASSERT( NULL != this_int );
    DDASSERT( NULL != lphDC );

    this_lcl = this_int->lpLcl;
    DDASSERT( NULL != this_lcl );

    this = this_lcl->lpGbl;
    DDASSERT( NULL != this );

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    DDASSERT( NULL != pdrv_lcl );

    pdrv = pdrv_lcl->lpGbl;
    DDASSERT( NULL != pdrv );

    *lphDC = NULL;

    ddrval = DD_OK;
    FlushD3DStates(this_lcl);
#if COLLECTSTATS
    if(this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
        ++this_lcl->lpSurfMore->lpDD_lcl->dwNumTexGetDCs;
#endif

    if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) &&
        (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
    {
        #ifdef GETDC_NULL
            DPF( 4, "GetDC(NULL)" );
            *lphDC = GetDC( NULL );
        #else
            DPF( 4, "GetDC: Returning device DC." );
            DDASSERT( GetObjectType( (HDC)this_lcl->lpSurfMore->lpDD_lcl->hDC ) == OBJ_DC );
            if (this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRTYDC)
            {
                HDC hdc;

                /*
                 * We need to destroy and recreate the device DC because a ChangeDisplaySettings
                 * will have messed up the vis rgn associated with that DC. We need to create
                 * the new DC before we destroy the old one just in case the destroy caused an
                 * unload of the driver
                 */
                hdc = DD_CreateDC( this_lcl->lpSurfMore->lpDD_lcl->lpGbl->cDriverName );
                DeleteDC((HDC) this_lcl->lpSurfMore->lpDD_lcl->hDC);
                this_lcl->lpSurfMore->lpDD_lcl->hDC = (ULONG_PTR) hdc;

                if( this_lcl->lpDDPalette )
                {
                    SelectPalette(hdc, (HPALETTE) this_lcl->lpDDPalette->lpLcl->lpGbl->dwReserved1, FALSE);
                    RealizePalette(hdc);
                }
	        this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags &= ~DDRAWILCL_DIRTYDC;
            }
            *lphDC = (HDC)this_lcl->lpSurfMore->lpDD_lcl->hDC;
        #endif
    }
    else
    {
        LPDDRAWI_DDRAWPALETTE_INT ppal;

        DPF( 4, "DdGetDC" );

        ppal = this_lcl->lpDDPalette;
        if (this_lcl->hDDSurface || CompleteCreateSysmemSurface(this_lcl))
        {
            if( ( NULL != ppal ) && !( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
                *lphDC = DdGetDC( this_lcl, ppal->lpLcl->lpGbl->lpColorTable );
            else
                *lphDC = DdGetDC( this_lcl, NULL );
        }
    }

    if( NULL == *lphDC )
    {
        DPF_ERR( "Could not obtain DC" );
        ddrval = DDERR_CANTCREATEDC;
    }
    else
    {
        ddrval = InternalAssociateDC( *lphDC, this_lcl );
	if( FAILED( ddrval ) )
	{
            DPF_ERR( "Could not associate DC" );
            if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) &&
                (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
            {
	        #ifdef GETDC_NULL
		    ReleaseDC( NULL, *lphDC );
                #endif
            }
            else
            {
                DdReleaseDC( this_lcl );
            }

            *lphDC = NULL;
	}
	else
	{
            this_lcl->dwFlags |= DDRAWISURF_HASDC;

	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC )
	    {
		/*
		 * OWNDC surfaces don't hold a lock while the HDC is available.
		 */

		/*
		 * If this is an OWNDC surface then we need to stash the HDC
		 * away in the surface for future reference.
		 */
                DDASSERT( this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED );
                DDASSERT( 0UL == this_lcl->hDC );

                this_lcl->hDC = (ULONG_PTR) *lphDC;
            }
	    else
	    {
		/*
		 * On NT we don't lock the surface to take the HDC. However, we
		 * want the semantics on both NT and 95 (where the lock is taken)
		 * to be the same so we* bump the usage counts and hold the mutex.
		 */
		this->dwUsageCount++;
		CHANGE_GLOBAL_CNT( pdrv, this, 1 );
		ENTER_DDRAW();
	    }
	}
    }

    // Remove any cached RLE stuff for the surface
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
    {
        extern void FreeRleData(LPDDRAWI_DDRAWSURFACE_LCL psurf);
        FreeRleData( this_lcl );
    }

    if(IsD3DManaged(this_lcl))
    {
        /* Mark everything dirty */
        MarkDirty(this_lcl);
        this_lcl->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
    }
    return ddrval;
} /* InternalGetDC */

#undef DPF_MODNAME
#define DPF_MODNAME "InternalReleaseDC"

/*
 * InternalReleaseDC - Windows NT version
 *
 * Assumes the DirectDraw mutex is already held
 *
 * This function
 */
HRESULT InternalReleaseDC( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, HDC hdc )
{
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT                     ddrval;

    DDASSERT( NULL != this_lcl );
    DDASSERT( NULL != hdc );

    this = this_lcl->lpGbl;
    DDASSERT( NULL != this );

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    DDASSERT( NULL != pdrv_lcl );

    pdrv = pdrv_lcl->lpGbl;
    DDASSERT( NULL != pdrv );

    ddrval = DD_OK;
    /*
     * Since this function already marks the surface as not having a DC even if
     * a failure is encountered destroying the DC, we always reduce the surface's
     * usage count.
     * This usage count decrement is done because we didn't call InternalLock on the
     * GetDC, so we don't call InternalUnlock here, but we still mucked with the flags
     * to ensure that ddraw.dll didn't hand out a lock while someone had a DC.
     *
     * NOTE: If this is an OWNDC surface we never even spoofed the lock so don't unspoof
     * now.
     */
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC )
    {
        DDASSERT( this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED );
        DDASSERT( 0UL != this_lcl->hDC );

        this_lcl->hDC = 0UL;
    }
    else
    {
	/*
	 * Undo the pseudo-lock we took to make NT behave like '95.
	 * The LEAVE_DDRAW may appear strange but we know we already
	 * have another reference to the mutex when we call this function.
	 */
	this->dwUsageCount--;
	CHANGE_GLOBAL_CNT( pdrv, this, -1 );
	LEAVE_DDRAW();
    }

    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) &&
        ( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
    {
        #ifdef GETDC_NULL
            DPF( 4, "NT emulation releasing primary DC" );
            ReleaseDC( NULL, hdc );
        #endif
    }
    else
    {
	if( !DdReleaseDC( this_lcl ) )
	{
	    DPF( 0, "DDreleaseDC fails!" );
	    ddrval = DDERR_GENERIC;
	}
    }

    this_lcl->dwFlags &= ~DDRAWISURF_HASDC;

    // Remove this DC from our list
    InternalRemoveDCFromList( hdc, this_lcl );

    return ddrval;
}

#endif /* WIN95 */

#undef DPF_MODNAME
#define DPF_MODNAME "DD_Surface_GetDC"

/*
 * DD_Surface_GetDC
 */
HRESULT DDAPI DD_Surface_GetDC(
		LPDIRECTDRAWSURFACE lpDDSurface,
		HDC FAR *lphDC )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT                     ddrval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetDC");
    /* DPF_ENTERAPI(lpDDSurface); */
    // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF(3,A,"   lphDC = 0x%p", lphDC);

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_HDC_PTR( lphDC ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER ||
            this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED )
        {
            DPF_ERR( "Invalid surface type: can't get DC" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
            DPF(3,A,"Returning DDERR_SURFACELOST");
	    return DDERR_SURFACELOST;
	}
	// DC already returned for this surface? We don't need to
	// check this if the surface is OWNDC. If so then we can
	// hand out (the same) HDC as many times as we like.
	if(  ( this_lcl->dwFlags & DDRAWISURF_HASDC ) &&
	    !( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
	{
	    DPF_ERR( "Can only return one DC per surface" );
	    LEAVE_DDRAW();
	    return DDERR_DCALREADYCREATED;
	}

        // default value is null:
	*lphDC = (HDC) 0;

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

        //
        // Fail if GDI doesn't understand the format
        //
        #ifdef WIN95
            if (!LOWERTHANDDRAW7( this_lcl->lpSurfMore->lpDD_int ) )
            {
                LPDDPIXELFORMAT lpPf;
            
                GET_PIXEL_FORMAT( this_lcl, this, lpPf );
                if( !bIsValidDCFormat( lpPf ) )
                {
                    DPF_ERR( "DCs cannot be used with this surface format" );
                    LEAVE_DDRAW();
                    return DDERR_INVALIDPIXELFORMAT;
                }
            }
        #endif
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * If this is an OWNDC surface and we currently have an HDC
     * then just use that.
     */
    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) &&
	( 0UL != this_lcl->hDC ) )
    {
	/*
	 * We currently only support OWNDC for explicit system
	 * memory surfaces.
	 */
	DDASSERT( this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED );

	*lphDC = (HDC)this_lcl->hDC;

	LEAVE_DDRAW();
	return DD_OK;
    }

    ddrval = InternalGetDC( this_int, lphDC
#ifdef WIN95
        , TRUE
#endif  //WIN95
        );

    LEAVE_DDRAW();
    return ddrval;
} /* DD_Surface_GetDC */

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseDC"

/*
 * DD_Surface_ReleaseDC
 *
 * NOTE: This function does not actually release the HDC for an OWNDC surface.
 * The HDC is only toasted when the surface is finally destroyed.
 */
HRESULT DDAPI DD_Surface_ReleaseDC(
		LPDIRECTDRAWSURFACE lpDDSurface,
                HDC hdc )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT                     ddrval;
    BOOL			bFound;
    DCINFO			*pdcinfo;
    DCINFO			*pdcinfoPrev = NULL;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_ReleaseDC");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
        #ifdef WIN95
            if( SURFACE_LOST( this_lcl ) )
            {
                LEAVE_DDRAW();
	        return DDERR_SURFACELOST;
            }
        #endif
	if( !(this_lcl->dwFlags & DDRAWISURF_HASDC) )
	{
	    DPF_ERR( "No DC allocated" );
	    LEAVE_DDRAW();
	    return DDERR_NODC;
	}

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	/*
	 * Check for an invalid DC. Prior to DX5, we didn't check so it was
	 * possible to 1) release an DC that we didn't create and 2) release a
	 * DC that wasn't associated with the surface, causing things to get
	 * messed up.
	 */
	bFound = FALSE;
	for( pdcinfo = g_pdcinfoHead; pdcinfo != NULL;
	    pdcinfoPrev = pdcinfo, pdcinfo = pdcinfo->pdcinfoNext )
	{
	    DDASSERT( pdcinfo->pdds_lcl != NULL );

	    if( hdc == pdcinfo->hdc )
	    {
		bFound = TRUE;
		if( this_lcl != pdcinfo->pdds_lcl )
		{
		    bFound = FALSE;
		}
		break;
	    }
	}
	if( !bFound )
	{
	    if( ( this_int->lpVtbl == &ddSurfaceCallbacks ) ||
		( this_int->lpVtbl == &ddSurface2Callbacks ) )
	    {
		DPF_ERR( "********************************************************************" );
		DPF_ERR( "* Invalid DC specified in ReleaseDC - not associate with the surface" );
		DPF_ERR( "********************************************************************" );
	    }
	    else
	    {
		DPF_ERR( "Invalid DC specified in ReleaseDC" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * If this is an OWNDC surface then just check to make sure we
     * were given back the correct HDC and return.
     */
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC )
    {
	DDASSERT( this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED );

	if( hdc != (HDC)this_lcl->hDC )
	{
	    DPF_ERR( "ReleaseDC called with wrong HDC for OWNDC surface" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	LEAVE_DDRAW();
	return DD_OK;
    }

    ddrval = InternalReleaseDC( this_lcl, hdc
#ifdef WIN95
        , TRUE
#endif  //WIN95
        );

    BUMP_SURFACE_STAMP(this);

    LEAVE_DDRAW();
    return ddrval;
} /* DD_Surface_ReleaseDC */

#undef DPF_MODNAME
#define DPF_MODNAME "IsLost"

/*
 * DD_Surface_IsLost
 */
HRESULT DDAPI DD_Surface_IsLost( LPDIRECTDRAWSURFACE lpDDSurface )
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_IsLost");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        pdrv = this->lpDD;
        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
        if (this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE)
        {
            LEAVE_DDRAW();
            return DDERR_NOTLOADED;
        }
#if 0 //Old code
        if (this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE)
        {
            LEAVE_DDRAW();
            return DDERR_NOTLOADED;
        }
#endif //0
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_IsLost */

#undef DPF_MODNAME
#define DPF_MODNAME "Initialize"

/*
 * DD_Surface_Initialize
 */
HRESULT DDAPI DD_Surface_Initialize(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDIRECTDRAW lpDD,
		LPDDSURFACEDESC lpDDSurfaceDesc )
{
    DPF(2,A,"ENTERAPI: DD_Surface_Initialize");

    DPF_ERR( "DirectDrawSurface: Already initialized." );
    return DDERR_ALREADYINITIALIZED;

} /* DD_Surface_Initialize */

HRESULT AtomicRestoreSurface(LPDDRAWI_DDRAWSURFACE_INT this_int)
{
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    DDHAL_CREATESURFACEDATA	csd;
    LPDDHAL_CREATESURFACE	csfn;
    LPDDHAL_CREATESURFACE	cshalfn;
    DWORD			rc;
    HRESULT			ddrval = DD_OK;
    UINT			bpp;
    LONG			pitch;
    BOOL			do_alloc=TRUE;
    BOOL                        emulation = FALSE;
    DWORD                       scnt;
    DDSURFACEDESC2              ddsd2;

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;
    #ifdef WINNT
	// Update DDraw handle in driver GBL object.
	pdrv->hDD = pdrv_lcl->hDD;
    #endif //WINNT

    DDASSERT( SURFACE_LOST( this_lcl ) );

#ifndef WINNT
    if( this_lcl->dwModeCreatedIn != pdrv->dwModeIndex )
#else
    if (!EQUAL_DISPLAYMODE(this_lcl->lpSurfMore->dmiCreated, pdrv->dmiCurrent))
#endif
    {
	DPF_ERR( "Surface was not created in the current mode" );
	return DDERR_WRONGMODE;
    }

    if(this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        emulation = TRUE;
    }

    #ifdef WINNT
        if (this->dwGlobalFlags & DDRAWISURFGBL_NOTIFYWHENUNLOCKED)
        {
            if (--dwNumLockedWhenModeSwitched == 0)
            {
                NotifyDriverOfFreeAliasedLocks();
            }
            this->dwGlobalFlags &= ~DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
        }
    #endif

    if( emulation )
    {
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
	{
	    csfn = pdrv_lcl->lpDDCB->HELDDExeBuf.CreateExecuteBuffer;
	}
	else
	{
	    csfn = pdrv_lcl->lpDDCB->HELDD.CreateSurface;
	}
	cshalfn = csfn;
    }
    else
    {
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
	{
	    csfn = pdrv_lcl->lpDDCB->HALDDExeBuf.CreateExecuteBuffer;
	    cshalfn = pdrv_lcl->lpDDCB->cbDDExeBufCallbacks.CreateExecuteBuffer;
	}
	else
	{
	    csfn = pdrv_lcl->lpDDCB->HALDD.CreateSurface;
	    cshalfn = pdrv_lcl->lpDDCB->cbDDCallbacks.CreateSurface;
	}
    }

    csd.CreateSurface = cshalfn;
    csd.lpDD = pdrv;
    if (this_lcl->dwFlags & DDRAWISURF_IMPLICITROOT)
    {
        //
        // This is a complex surface, so we recorded the createsurface data
        // at CS time.
        //
        DDASSERT(this_lcl->lpSurfMore->pCreatedDDSurfaceDesc2);
        DDASSERT(this_lcl->lpSurfMore->slist);
        DDASSERT(this_lcl->lpSurfMore->cSurfaces);
        csd.lpDDSurfaceDesc = (LPDDSURFACEDESC) this_lcl->lpSurfMore->pCreatedDDSurfaceDesc2;
        csd.lplpSList = this_lcl->lpSurfMore->slist;
        csd.dwSCnt = this_lcl->lpSurfMore->cSurfaces;
        //
        // we record the surfacedesc for any complex surface except pure mipmaps
        //
        if ((this_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) &&
            ((this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP)==0) )
        {
            DDASSERT(0 == this_lcl->lpSurfMore->pCreatedDDSurfaceDesc2);
	    FillDDSurfaceDesc2( this_lcl, &ddsd2 );
            csd.lpDDSurfaceDesc = (LPDDSURFACEDESC) &ddsd2;
        }
    }
    else
    {
        //
        // this is a single non-complex surface.
        // Setup the createsurface data structure to reflect it
        //
	FillDDSurfaceDesc2( this_lcl, &ddsd2 );
        csd.lpDDSurfaceDesc = (LPDDSURFACEDESC) &ddsd2;
        csd.lplpSList = &this_lcl;
        csd.dwSCnt = 1;
    }


    //
    // Note, those surfaces for whom MEMFREE (i.e. the GDI surface) is not set also pass through
    // this code path and are passed to the driver's createsurface
    // This is different from the process for non-dx7 drivers.
    // The non-dx7 driver restore path actually has a bug: the alias for the GDI surface
    // is not restored. 
    //
    for( scnt=0; scnt<csd.dwSCnt; scnt++ )
    {
	if (csd.lplpSList[scnt]->lpGbl->fpVidMem != 0xFFBADBAD)
	    csd.lplpSList[scnt]->lpGbl->fpVidMem = 0;

        if( !( csd.lplpSList[scnt]->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER ) )
        {
	    if( csd.lplpSList[scnt]->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	    {
	        bpp = csd.lplpSList[scnt]->lpGbl->ddpfSurface.dwRGBBitCount;
	    }
	    else
	    {
	        bpp = pdrv->vmiData.ddpfDisplay.dwRGBBitCount;
	    }
	    pitch = (LONG) ComputePitch( pdrv, csd.lplpSList[scnt]->ddsCaps.dwCaps,
    					    (DWORD) csd.lplpSList[scnt]->lpGbl->wWidth, bpp );
	    csd.lplpSList[scnt]->lpGbl->lPitch = pitch;
        } 
    }

#ifdef    WIN95
    /* Copy the VXD handle from the per process local structure to global.
     * This handle will be used by DDHAL32_VidMemAlloc(), rather than creating
     * a new one using GetDXVxdHandle(). The assumptions here are:
     * 1) Only one process can enter createSurface(), 2) Deferred calls to
     * DDHAL32_VidMemAlloc() will result in the slow path, ie getting
     * the VXD handle using GetDXVxdHandle().
     * (snene 2/23/98)
     */
    pdrv->hDDVxd = pdrv_lcl->hDDVxd;
#endif /* WIN95 */

    /*
     * NOTE: Different HAL entry points for execute buffers and
     * conventional surfaces.
     */
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
	DOHALCALL( CreateExecuteBuffer, csfn, csd, rc, emulation );
    }
    else
    {
        DOHALCALL( CreateSurface, csfn, csd, rc, emulation );
    }

#ifdef    WIN95
    /* Restore the handle to INVALID_HANDLE_VALUE so that non-createSurface()
     * calls using DDHAL32_VidMemAlloc() or deferred calls (possibly from other
     * processes) will correctly recreate the handle using GetDXVxdHandle().
     * (snene 2/23/98)
     */
    pdrv->hDDVxd = (DWORD)INVALID_HANDLE_VALUE;
#endif /* WIN95 */

    if( rc == DDHAL_DRIVER_HANDLED )
    {
	if( csd.ddRVal != DD_OK )
	{
	    #ifdef DEBUG
		if( emulation )
		{
                    DPF( 1, "Restore: Emulation won't let surface be created, rc=%08lx (%ld)",
				csd.ddRVal, LOWORD( csd.ddRVal ) );
		}
		else
		{
		    DPF( 1, "Restore: Driver won't let surface be created, rc=%08lx (%ld)",
				csd.ddRVal, LOWORD( csd.ddRVal ) );
		}
	    #endif

	    return csd.ddRVal;
	}
    }

    /*
     * now, allocate any unallocated surfaces
     */
    ddrval = AllocSurfaceMem( pdrv_lcl, csd.lplpSList, csd.dwSCnt );
    if( ddrval != DD_OK )
    {
	return ddrval;
    }

    for( scnt=0; scnt<csd.dwSCnt; scnt++ )
    {
	LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

	csd.lplpSList[scnt]->dwFlags   &= ~DDRAWISURF_INVALID;
	csd.lplpSList[scnt]->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;

#ifdef USE_ALIAS
        /*
         * If this device has heap aliases then precompute the pointer
         * alias for the video memory returned at creation time. This
         * is by far the most likely pointer we are going to be handing
         * out at lock time so we are going to make lock a lot faster
         * by precomputing this then at lock time all we need to do is
         * compare the pointer we got from the driver with fpVidMem. If
         * they are equal then we can just return this cached pointer.
         */
	lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE( csd.lplpSList[scnt]->lpGbl );
	if( csd.lplpSList[scnt]->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
        {
	    lpGblMore->fpAliasedVidMem = GetAliasedVidMem( pdrv_lcl, csd.lplpSList[scnt],
							   csd.lplpSList[scnt]->lpGbl->fpVidMem );
            // If we succeeded in getting an alias, cache it for future use. Also store the original
            // fpVidMem to compare with before using the cached pointer to make sure the cached value
            // is still valid
            if (lpGblMore->fpAliasedVidMem)
                lpGblMore->fpAliasOfVidMem = csd.lplpSList[scnt]->lpGbl->fpVidMem;
            else
                lpGblMore->fpAliasOfVidMem = 0;
        }
	else
        {
	    lpGblMore->fpAliasedVidMem = 0UL;
            lpGblMore->fpAliasOfVidMem = 0UL;
        }
#endif /* USE_ALIAS */

#ifdef WIN95
        if (csd.lplpSList[scnt]->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_PERSISTENTCONTENTS)
        {
            ddrval = RestoreSurfaceContents(csd.lplpSList[scnt]);
        }
#endif

        /*
         * If a D3D texture managed surface is being restored,
         * then we need to mark the corresponding system memory
         * surface dirty, so that it is automatically refreshed
         * prior to rendering.
         */
        if (SUCCEEDED(ddrval))
        {
            if(!IsD3DManaged(csd.lplpSList[scnt]) && csd.lplpSList[scnt]->lpSurfMore->lpRegionList)
            {
                MarkDirty(csd.lplpSList[scnt]);
                csd.lplpSList[scnt]->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
            }
        }
    }

    if (
#ifdef  WINNT
        // on NT side, we still call CreateSurfaceEx if HW driver isn't called
        emulation && this_lcl->hDDSurface &&
#endif  //WINNT
        TRUE
       )
    {
        DDASSERT( pdrv_lcl == this_lcl->lpSurfMore->lpDD_lcl);
        createsurfaceEx(this_lcl);
    }

    // If D3D Vertex Buffer, notify D3D
    if ( (this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
         (this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
         (this_lcl->lpGbl->dwUsageCount > 0) &&
         (GetCurrentProcessId() == GETCURRPID()) &&
         (this_lcl->lpSurfMore->lpDD_lcl->pBreakVBLock) && 
         (this_lcl->lpSurfMore->lpVB) )
    {
        {
            this_lcl->lpSurfMore->lpDD_lcl->pBreakVBLock(this_lcl->lpSurfMore->lpVB);
        }
    }

    return ddrval;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Restore"

/*
 * restoreSurface
 *
 * restore the vidmem of one surface
 */
static HRESULT restoreSurface( LPDDRAWI_DDRAWSURFACE_INT this_int )
{
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	slistx[1];
    LPDDRAWI_DDRAWSURFACE_GBL	slist[1];
    DDHAL_CREATESURFACEDATA	csd;
    LPDDHAL_CREATESURFACE	csfn;
    LPDDHAL_CREATESURFACE	cshalfn;
    DDSURFACEDESC2		ddsd;
    DWORD			rc;
    HRESULT			ddrval;
    UINT			bpp;
    LONG			pitch = 0;
    BOOL			do_alloc=TRUE;

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;
    #ifdef WINNT
	// Update DDraw handle in driver GBL object.
	pdrv->hDD = pdrv_lcl->hDD;
    #endif //WINNT

    /*
     * If we made it to here the local surface should be marked invalid.
     */
    DDASSERT( SURFACE_LOST( this_lcl ) );

#ifndef WINNT
    if( this_lcl->dwModeCreatedIn != pdrv->dwModeIndex )
#else
    if (!EQUAL_DISPLAYMODE(this_lcl->lpSurfMore->dmiCreated, pdrv->dmiCurrent))
#endif
    {
	DPF_ERR( "Surface was not created in the current mode" );
	return DDERR_WRONGMODE;
    }

    #ifdef WINNT
        if (this->dwGlobalFlags & DDRAWISURFGBL_NOTIFYWHENUNLOCKED)
        {
            if (--dwNumLockedWhenModeSwitched == 0)
            {
                NotifyDriverOfFreeAliasedLocks();
            }
            this->dwGlobalFlags &= ~DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
        }
    #endif

    DPF(5,"RestoreSurface. GDI Flag is %d, MemFree flag is %d, Primary flag is %d",
        this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE,
        this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE,
        this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE
       );
    /*
     * Two cases where we don't want to allocate any memory:
     * -optimized surfaces
     * -surfaces for which was just marked as invalid.
     * If this is an optimized surface, Restore is basically a noop
     * since memory is allocated at optimize time, not restore time.
     */
    if(( (!(this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE))
#ifdef WINNT
        /*
         * We need to call CreateSurface HAL callback on NT
         */
            && (((this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) == 0)
    	    || (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
#endif
            ) || (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED) )
    {
	this_lcl->dwFlags &= ~DDRAWISURF_INVALID;
	ddrval = DD_OK;
        do_alloc = FALSE;
    }
    else
    {
	slistx[0] = this_lcl;
	slist[0] = this;

	if (this->fpVidMem != 0xFFBADBAD)
	    this->fpVidMem = 0;

        // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF( 4, "Restoring 0x%p", this_lcl );

	/*
	 * Execute buffers are handled very differently
	 * from ordinary surfaces. They have no width and
	 * height and store a linear size instead of a pitch.
	 * Note, the linear size includes any alignment
	 * requirements (added by ComputePitch on surface
	 * creation) so we do not recompute the pitch at this
	 * point. The surface structure as it stands is all we
	 * need.
	 */
	if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER ) )
	{
	    if( this_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	    {
		bpp = this->ddpfSurface.dwRGBBitCount;
	    }
	    else
	    {
		bpp = pdrv->vmiData.ddpfDisplay.dwRGBBitCount;
	    }
	    pitch = (LONG) ComputePitch( pdrv, this_lcl->ddsCaps.dwCaps,
    					    (DWORD) this->wWidth, bpp );
	    this->lPitch = pitch;
	}
	/*
	 * first, give the driver an opportunity to create it...
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
	{
	    cshalfn = pdrv_lcl->lpDDCB->cbDDExeBufCallbacks.CreateExecuteBuffer;
	    csfn    = pdrv_lcl->lpDDCB->HALDDExeBuf.CreateExecuteBuffer;
	}
	else
	{
	    cshalfn = pdrv_lcl->lpDDCB->cbDDCallbacks.CreateSurface;
	    csfn    = pdrv_lcl->lpDDCB->HALDD.CreateSurface;
	}
	if( cshalfn != NULL )
	{
            DPF(4,"HAL CreateSurface to be called");
	    /*
	     * construct a new surface description
	     */
	    FillDDSurfaceDesc2( this_lcl, &ddsd );

	    /*
	     * call the driver
	     */
    	    csd.CreateSurface = cshalfn;
	    csd.lpDD = pdrv;
	    csd.lpDDSurfaceDesc = (LPDDSURFACEDESC)&ddsd;
	    csd.lplpSList = slistx;
	    csd.dwSCnt = 1;

	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
	    {
		DOHALCALL( CreateExecuteBuffer, csfn, csd, rc, FALSE );
	    }
	    else
	    {
		DOHALCALL( CreateSurface, csfn, csd, rc, FALSE );
	    }
	    if( rc == DDHAL_DRIVER_HANDLED )
	    {
		if( csd.ddRVal != DD_OK )
		{
		    do_alloc = FALSE;
		    ddrval = csd.ddRVal;
		}
            }
	}
        /*
         * On NT, we will hit this code path for the GDI surface.
         * We could probably just not do the alloc, but to avoid hard-to-test code paths
         * I'll let the AllocSurfaceMem trivially allocate for the GDI surface.
         */
	if( do_alloc )
	{
	    /*
	     * allocate the memory now...
	     */
	    ddrval = AllocSurfaceMem( pdrv_lcl, slistx, 1 );
	    if( ddrval != DD_OK )
	    {
		this->lPitch = pitch;
                DPF(2,"Moving to system memory");
		ddrval = MoveToSystemMemory( this_int, FALSE, TRUE );
	    }
	    if( ddrval == DD_OK )
	    {
		this_lcl->dwFlags   &= ~DDRAWISURF_INVALID;
		this->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
	    }
	}
    }

#ifdef USE_ALIAS
    {
	LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

	lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE( this );
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
        {
	    lpGblMore->fpAliasedVidMem = GetAliasedVidMem( pdrv_lcl, this_lcl, this_lcl->lpGbl->fpVidMem );
            // If we succeeded in getting an alias, cache it for future use. Also store the original
            // fpVidMem to compare with before using the cached pointer to make sure the cached value
            // is still valid
            if (lpGblMore->fpAliasedVidMem)
                lpGblMore->fpAliasOfVidMem = this_lcl->lpGbl->fpVidMem;
            else
                lpGblMore->fpAliasOfVidMem = 0;
        }
	else
        {
	    lpGblMore->fpAliasedVidMem = 0UL;
            lpGblMore->fpAliasOfVidMem = 0UL;
        }
    }
#endif /* USE_ALIAS */


#ifdef WIN95
    if (SUCCEEDED(ddrval) && (this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_PERSISTENTCONTENTS))
    {
        ddrval = RestoreSurfaceContents(this_lcl);
    }
#endif

    /*
     * If a D3D texture managed surface is being restored,
     * then we need to mark the corresponding system memory
     * surface dirty, so that it is automatically refreshed
     * prior to rendering.
     */
    if(!IsD3DManaged(this_lcl) && this_lcl->lpSurfMore->lpRegionList)
    {
        MarkDirty(this_lcl);
        this_lcl->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
    }

    return ddrval;

} /* restoreSurface */

/*
 * restoreAttachments
 *
 * restore all attachments to a surface
 */
static HRESULT restoreAttachments( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    LPATTACHLIST		pattachlist;
    LPDDRAWI_DDRAWSURFACE_INT	curr_int;
    LPDDRAWI_DDRAWSURFACE_LCL	curr_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	curr;
    HRESULT			ddrval;

    pattachlist = this_lcl->lpAttachList;
    while( pattachlist != NULL )
    {
	curr_int = pattachlist->lpIAttached;

	curr_lcl = curr_int->lpLcl;
    	curr = curr_lcl->lpGbl;
	if( curr_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE )
	{
	    ddrval = restoreSurface( curr_int );
	    if( ddrval != DD_OK )
	    {
		DPF( 2, "restoreSurface failed: %08lx (%ld)", ddrval, LOWORD( ddrval ) );
		return ddrval;
	    }
	    ddrval = restoreAttachments( curr_lcl );
	    if( ddrval != DD_OK )
	    {
		DPF( 2, "restoreAttachents failed: %08lx (%ld)", ddrval, LOWORD( ddrval ) );
		return ddrval;
	    }
	}
    pattachlist = pattachlist->lpLink;
    }
    return DD_OK;

} /* restoreAttachments */

/*
 * DD_Surface_Restore
 *
 * Restore an invalidated surface
 */
#undef  DPF_MODNAME
#define DPF_MODNAME "DD_Surface_Restore"
HRESULT DDAPI DD_Surface_Restore( LPDIRECTDRAWSURFACE lpDDSurface )
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    HRESULT         ddrval;
    BOOL                        has_excl;
    BOOL                        excl_exists;
    DDSURFACEDESC2              ddsd;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Restore");
    /* DPF_ENTERAPI(lpDDSurface); */

    /*
     * validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            DPF_ERR( "Invalid surface pointer" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
        pdrv = pdrv_lcl->lpGbl;
        if( (this_lcl->dwFlags & DDRAWISURF_ISFREE) )
        {
            LEAVE_DDRAW();
            DPF_APIRETURNS( DDERR_INVALIDOBJECT);
            return DDERR_INVALIDOBJECT;
        }
        #ifdef WIN95
            if( ( pdrv_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_SCREENSAVER ) &&
                ( pdrv_lcl->dwLocalFlags & DDRAWILCL_POWEREDDOWN ) )
            {
                LEAVE_DDRAW();
                return DDERR_SURFACELOST;
            }
        #endif
        if( !SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            DPF(2,"Returning DD_OK since not lost");
            return DD_OK;;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_INVALIDPARAMS);
        return DDERR_INVALIDPARAMS;
    }

    // For now, disallow it for optimized surfaces
    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
    }

    /*
     * don't allow restoration of implicit surfaces
     */
    if( (this_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE) )
    {
        DPF_ERR( "Can't restore implicitly created surfaces" );
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_IMPLICITLYCREATED);
        return DDERR_IMPLICITLYCREATED;
    }

    /*
     * make sure we are in the same mode the surface was created in
     */
#ifdef WIN95
    if( pdrv->dwModeIndex != this_lcl->dwModeCreatedIn )
#else
    if (!EQUAL_DISPLAYMODE(this_lcl->lpSurfMore->dmiCreated, pdrv->dmiCurrent))
#endif
    {
        DPF(1, "Cannot restore surface, not in original mode");
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_WRONGMODE);
        return DDERR_WRONGMODE;
    }

    /*
     * If the device has an exclusive owner, we must not restore any surface
     * in the device's video memory unless we are the device's exclusive owner.
     * DDERR_WRONGMODE is returned to avoid regression problems by mimicking
     * Restore() behavior in the case in which the device's exclusive owner has
     * changed to a mode that's different from the one the surface was created in.
     *
     * We also handle the case where an exclusive mode app tries to restore
     * surfaces while no one has exclusive mode (for example, when the app is
     * minimized). The restore would commonly fail due to the app running in a
     * different display mode from the current display mode. However, if the
     * is running in the same display mode, we would previously allow the
     * restore to succeed. As mentioned above, we'll return DDERR_WRONGMODE,
     * to avoid regression problems, even though DDERR_NOEXCLUSIVEMODE would
     * make more sense.
     */
    CheckExclusiveMode(this_lcl->lpSurfMore->lpDD_lcl, &excl_exists , &has_excl, FALSE, 
        NULL, FALSE);

    if((excl_exists && !has_excl) ||
       (!excl_exists && (pdrv_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE)))
    {
        DPF_ERR("Another app has assumed exclusive ownership of device");
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_WRONGMODE);
        return DDERR_WRONGMODE;
    }

    /*
     * make sure we are not in the middle of a mode change, in which case
     * DirectDraw is confused about the mode it is in
     */
    if( pdrv->dwFlags & DDRAWI_CHANGINGMODE )
    {
        /*
         * We really should fail this altogether since we are only
         * asking for trouble, but we fear that regression risk might
         * be worse, so we only fail this for a surface 3 interface.
         * In the cases we do not fail, we handle the Blt case by not
         * doing anything, but we're still vulnerable to Lock and GetDC.
         */
        if( !( ( this_int->lpVtbl == &ddSurfaceCallbacks ) ||
               ( this_int->lpVtbl == &ddSurface2Callbacks ) ) )
        {
            DPF_ERR("Cannot restore surface, in the middle of a mode change");
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_WRONGMODE);
            return DDERR_WRONGMODE;
        }
        else
        {
            /*
             * Always output a message here.  This serves two purposes:
             * 1) Let us no why a stress failure occured,
             * 2) Inform developers why they are seeing bugs.
             */
            OutputDebugString( "WARNING: Restoring surface during a mode change!\n" );
        }
    }

    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
    {
        /*
         * are we the process with exclusive mode?
         */
        if( excl_exists && !has_excl )
        {
            DPF_ERR( "Cannot restore primary surface, not exclusive owner" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_NOEXCLUSIVEMODE);
            return DDERR_NOEXCLUSIVEMODE;
        }
        else if( !excl_exists )
        {
            /*
             * no exclusive mode
             */
            FillDDSurfaceDesc2( this_lcl, &ddsd );
            if( !MatchPrimary( pdrv, &ddsd ) )
            {
                DPF_ERR( "Can't restore primary, incompatible with current primary" );
                LEAVE_DDRAW();
                DPF_APIRETURNS(DDERR_INCOMPATIBLEPRIMARY);
                return DDERR_INCOMPATIBLEPRIMARY;
            }
        }
        /*
     * otherwise, it is OK to restore primary
     */

#ifdef WINNT
        /*
             * Ctrl-Alt-Del on NT gives us no notice and so no FlipToGDISurface has been done.
             * This means that the DDSCAPS_PRIMARY and DDRAWISURFGBL_ISGDISURFACE tags may
             * not be on the same surface object (which is what FlipToGDISurface does).
             * The NT user-side code expects that DDSCAPS_PRIMARY means DDRAWISURFGBL_ISGDISURFACE
             * which it normally would, and should (i.e. GDI's surface should be the visible surface
             * immediately before a switch back to a fullscreen app.)
             * We force this situation here by running the attachment list for a primary and
             * finding the GDI surface, then doing a surface-object-only flip (i.e. exchange
             * these two objects' MEMFREE status, dwReserved and Kernel handle fields.
             * I shall be extra paranoid and only attempt this if the primary doesn't have
             * IS_GDISURFACE set. It should be safe to assume that the only way the GDI and
             * PRIMARY flags got mismatched is via a flip that wasn't undone.
             * This situation should never happen for an emulated primary (since Flip drops
             * out early before doing the flag rotation).
             */
        if ( !( this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE ) )
        {
            /*
             * Run the attachments looking for the surface with the GDI flag
             */
            LPDDRAWI_DDRAWSURFACE_INT   curr_int;

            DDASSERT( (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) == 0);
            DDASSERT(this_lcl->lpAttachList);

            curr_int = FindAttachedFlip(this_int);
            while( curr_int->lpLcl != this_lcl )
            {
                if( curr_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE )
                {
                    /*
                     * Found the GDI tagged surface
                     */
                    break;
                }
                DDASSERT(curr_int->lpLcl->lpAttachList);
                curr_int = FindAttachedFlip(curr_int);
            }
            if (curr_int->lpLcl != this_lcl)
            {
                /*
                 * curr_lcl != this_lcl means we found an attached surface with GDI set,
                 * so pseudo-flip them.
                 */
                DWORD                       memfreeflag;
		ULONG_PTR                   reserved,handle;
                LPDDRAWI_DDRAWSURFACE_GBL   curr_gbl = curr_int->lpLcl->lpGbl;

                DDASSERT(0 == curr_gbl->fpVidMem);
                DDASSERT(NULL == curr_gbl->lpVidMemHeap);

                    /*
                     * The primary (this) needs to get the GDI flag set, and the other
                     * (the old GDI surface) needs to get GDI reset.
                     */
                curr_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_ISGDISURFACE;
                this->dwGlobalFlags |= DDRAWISURFGBL_ISGDISURFACE;

                    /*
                     * The two surfaces must trade their MEMFREE status.
                     */
                memfreeflag = curr_gbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE;
                curr_gbl->dwGlobalFlags = (curr_gbl->dwGlobalFlags & ~DDRAWISURFGBL_MEMFREE)
                    | (this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE);
                this->dwGlobalFlags = (this->dwGlobalFlags & ~DDRAWISURFGBL_MEMFREE)
                    | memfreeflag;

                    /*
                     * Swap reserved field and kernel handle
                     */
                reserved = curr_gbl->dwReserved1;
                curr_gbl->dwReserved1 = this->dwReserved1;
                this->dwReserved1 = reserved;

                handle = curr_int->lpLcl->hDDSurface;
                curr_int->lpLcl->hDDSurface = this_lcl->hDDSurface;
                this_lcl->hDDSurface = handle;
            }
        }
#endif

    } /* if primary surface */

    if (NULL == pdrv->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx) 
    {
        //
        // Non DX7 driver gets piece-meal restore
        //
        /*
         * restore this surface
         */
        ddrval = restoreSurface( this_int );
        if( ddrval != DD_OK )
        {
            DPF( 1, "restoreSurface failed, rc=%08lx (%ld)", ddrval, LOWORD( ddrval ) );
            LEAVE_DDRAW();
            DPF_APIRETURNS(ddrval);
            return ddrval;
        }

        /*
         * restore all surfaces in an implicit chain
         */
        if( this_lcl->dwFlags & DDRAWISURF_IMPLICITROOT )
        {
            ddrval = restoreAttachments( this_lcl );
        }
    }
    else
    {
        //
        // DX7 driver gets atomic restore
        //
        ddrval = AtomicRestoreSurface(this_int);
    }

    LEAVE_DDRAW();
    DPF_APIRETURNS(ddrval);
    return ddrval;

} /* DD_Surface_Restore */

/*
 * MoveToSystemMemory
 *
 * if possible, deallocate the video memory associated with this surface
 * and allocate system memory instead.	This is useful for drivers which have
 * hardware flip and video memory capability but no blt capability.  By
 * moving the offscreen surfaces to system memory, we reduce the lock overhead
 * and also reduce the bus bandwidth requirements.
 *
 * This function assumes the DRIVER LOCK HAS BEEN TAKEN.
 */
HRESULT MoveToSystemMemory(
		LPDDRAWI_DDRAWSURFACE_INT this_int,
		BOOL hasvram,
		BOOL use_full_lock )
{
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    ULONG_PTR			newreserved;
    ULONG_PTR                   newreserved_lcl;
//    LPVOID	                newvidmemheap;
    LONG	                newpitch;
    FLATPTR	                newvidmem;
    DWORD                       newddscaps;
    ULONG_PTR                   newhddsurface;
    ULONG_PTR           	savereserved;
    ULONG_PTR                   savereserved_lcl;
    LPVOID	                savevidmemheap;
    LONG	                savepitch;
    FLATPTR	                savevidmem;
    DWORD                       saveddscaps;
    ULONG_PTR                   savehddsurface;
    DDHAL_CREATESURFACEDATA	csd;
    DWORD			rc;
    DDSURFACEDESC2		ddsd;
    LPDDRAWI_DDRAWSURFACE_LCL	slistx;
    LPBYTE                      lpvidmem;
    LPBYTE                      lpsysmem;
    DWORD			bytecount;
    DWORD                       line;
    HRESULT			ddrval;
    LPVOID			pbits;
    WORD                        wHeight;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;


    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;

    //
    // We don't move to system memory on DX7 drivers, since this process doesn't
    // inform them of the new sysmem surface
    //
    if (NULL != pdrv->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx)
    {
        //this error code never percolates up to apps.
        return DDERR_GENERIC;
    }

    #ifdef WINNT
    {
	// Update DDraw handle in driver GBL object.
	pdrv->hDD = pdrv_lcl->hDD;
    }
    #endif //WINNT

    if(hasvram && SURFACE_LOST( this_lcl ) )
    {
	return DDERR_SURFACELOST;
    }

    if( ( this_lcl->lpAttachList != NULL ) ||
	( this_lcl->lpAttachListFrom != NULL ) ||
	( this->dwUsageCount != 0 ) ||
	( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) ||
	( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) ||
        ( this_lcl->dwFlags & (DDRAWISURF_HASPIXELFORMAT|DDRAWISURF_PARTOFPRIMARYCHAIN) ) )
    {
	/*
	 * can't move it to system memory
	 */
        // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF( 2, "Unable to move surface 0x%p to system memory", this_int );
	#ifdef DEBUG
	    if( this_lcl->lpAttachList != NULL )
	    {
		DPF( 4, "AttachList is non-NULL" );
	    }
	    if( this_lcl->lpAttachListFrom != NULL )
	    {
		DPF( 4, "AttachListFrom is non-NULL" );
	    }
	    if( this->dwUsageCount != 0 )
	    {
		DPF( 4, "dwusageCount=%ld", this->dwUsageCount );
	    }
	    if( this_lcl->dwFlags & DDRAWISURF_PARTOFPRIMARYCHAIN )
	    {
		DPF( 4, "part of the primary chain" );
	    }
	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
	    {
		DPF( 4, "Is a hardware overlay" );
	    }
	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
	    {
		DPF( 4, "Is already in system memory" );
	    }
	    if( this_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	    {
		DPF( 4, "Has a different pixel format" );
	    }
	#endif
	return DDERR_GENERIC;
    }

    /*
     * save the current state just in case the HEL
     * CreateSurface call fails.
     */
    savevidmem = this->fpVidMem;
    savevidmemheap = this->lpVidMemHeap;
    savereserved = this->dwReserved1;
    savereserved_lcl= this_lcl->dwReserved1;
    savepitch = this->lPitch;
    saveddscaps = this_lcl->ddsCaps.dwCaps;
    savehddsurface = this_lcl->hDDSurface;

    /*
     * lock the vram
     */
    if( hasvram )
    {
	while( 1 )
	{
	    if( use_full_lock )
	    {
		ddsd.dwSize = sizeof( ddsd );
		ddrval = DD_Surface_Lock(
				(LPDIRECTDRAWSURFACE) this_int,
				NULL,
				(LPDDSURFACEDESC)&ddsd,
				0,
				NULL );
		if( ddrval == DD_OK )
		{
		    pbits = ddsd.lpSurface;
		}
	    }
	    else
	    {
		ddrval = InternalLock( this_lcl, &pbits, NULL, 0 );
	    }
	    if( ddrval == DDERR_WASSTILLDRAWING )
	    {
		continue;
	    }
	    break;
	}
	if( ddrval != DD_OK )
	{
	    DPF( 0, "*** MoveToSystemMemory: Lock failed! rc = %08lx", ddrval );
	    return ddrval;
	}
    }

    /*
     * mark this object as system memory.  NT needs this done before the
     * CreateSurface HEL call, otherwise it gets confused about whether
     * it's supposed to be a video memory or system memory surface.
     */
    this_lcl->ddsCaps.dwCaps &= ~(DDSCAPS_VIDEOMEMORY|DDSCAPS_NONLOCALVIDMEM|DDSCAPS_LOCALVIDMEM);
    this_lcl->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

    /*
     * set up for a call to the HEL
     */
    FillDDSurfaceDesc2( this_lcl, &ddsd );
    slistx = this_lcl;
    csd.lpDD = this->lpDD;
    csd.lpDDSurfaceDesc = (LPDDSURFACEDESC)&ddsd;
    csd.lplpSList = &slistx;
    csd.dwSCnt = 1;
    rc = this_lcl->lpSurfMore->lpDD_lcl->lpDDCB->HELDD.CreateSurface( &csd );
    if( (rc == DDHAL_DRIVER_NOTHANDLED) || (csd.ddRVal != DD_OK) )
    {
	this->fpVidMem = savevidmem;
	this->lpVidMemHeap = savevidmemheap;
	this->lPitch = savepitch;
	this->dwReserved1 = savereserved;
        this_lcl->dwReserved1 = savereserved_lcl;
        this_lcl->ddsCaps.dwCaps = saveddscaps;
        this_lcl->hDDSurface = savehddsurface;
	if( hasvram )
	{
	    if( use_full_lock )
	    {
		DD_Surface_Unlock( (LPDIRECTDRAWSURFACE) this_int, NULL );
	    }
	    else
	    {
		InternalUnlock( this_lcl, NULL, NULL, 0 );
	    }
	}
	DPF( 0, "*** MoveToSystemMemory: HEL CreateSurface failed! rc = %08lx", csd.ddRVal );
	return csd.ddRVal;
    }

    /*
     * copy the bits from vidmem to systemmem
     */
    if( hasvram )
    {
        lpvidmem = (LPBYTE)pbits;
        lpsysmem = (LPBYTE)this_lcl->lpGbl->fpVidMem;
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
	{
	    bytecount = this->dwLinearSize;
	    wHeight   = 1;
	}
	else
	{
	    bytecount = this->wWidth * ddsd.ddpfPixelFormat.dwRGBBitCount / 8;
	    wHeight   = this->wHeight;
	}

        TRY
        {
            for( line=0; line<wHeight; line++)
	    {
	        memcpy( lpsysmem, lpvidmem, bytecount );
	        lpvidmem += savepitch;
	        lpsysmem += this->lPitch;
            }
        }
        EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
	    DPF_ERR( "Exception encountered moving from video to system memory" );
	    this->fpVidMem = savevidmem;
	    this->lpVidMemHeap = savevidmemheap;
	    this->lPitch = savepitch;
	    this->dwReserved1 = savereserved;
            this_lcl->dwReserved1 = savereserved_lcl;
            this_lcl->ddsCaps.dwCaps = saveddscaps;
            this_lcl->hDDSurface = savehddsurface;
	    if( hasvram )
	    {
	        if( use_full_lock )
	        {
		    DD_Surface_Unlock( (LPDIRECTDRAWSURFACE) this_int, NULL );
	        }
	        else
	        {
		    InternalUnlock( this_lcl, NULL, NULL, 0 );
	        }
	    }
	    return DDERR_EXCEPTION;
        }

    }

    /*
     * it worked, temporarily reset values and unlock surface
     */
    if( hasvram )
    {
	newvidmem = this->fpVidMem;
//	newvidmemheap = this->lpVidMemHeap; THIS IS NOT SET BY THE HEL
	newreserved = this->dwReserved1;
        newreserved_lcl = this_lcl->dwReserved1;
	newpitch = this->lPitch;
        newddscaps = this_lcl->ddsCaps.dwCaps;
        newhddsurface = this_lcl->hDDSurface;

	this->fpVidMem = savevidmem;
	this->lpVidMemHeap = savevidmemheap;
	this->lPitch = savepitch;
	this->dwReserved1 = savereserved;
        this_lcl->dwReserved1 = savereserved_lcl;
        this_lcl->ddsCaps.dwCaps = saveddscaps;
        this_lcl->hDDSurface = savehddsurface;

	if( use_full_lock )
	{
	    DD_Surface_Unlock( (LPDIRECTDRAWSURFACE) this_int, NULL );
	}
	else
	{
	    InternalUnlock( this_lcl, NULL, NULL, 0 );
	}

	// Free the video memory, allow the driver to destroy the surface
	DestroySurface( this_lcl );
	// We just freed the memory but system memory surfaces never have
	// this flag set so unset it.
	this_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;

	this->fpVidMem = newvidmem;
//	this->lpVidMemHeap = newvidmemheap;
	this->lpVidMemHeap = NULL;		// should be NULL after HEL
	this->lPitch = newpitch;
	this->dwReserved1 = newreserved;
        this_lcl->dwReserved1 = newreserved_lcl;
        this_lcl->ddsCaps.dwCaps = newddscaps;
        this_lcl->hDDSurface = newhddsurface;
    }


    /*
     * the hel needs to know we touched the memory
     */
    if( use_full_lock )
    {
	DD_Surface_Lock( (LPDIRECTDRAWSURFACE) this_int, NULL,
					(LPDDSURFACEDESC)&ddsd, 0, NULL );
	DD_Surface_Unlock( (LPDIRECTDRAWSURFACE) this_int, NULL );
    }
    else
    {
	InternalLock( this_lcl, &pbits, NULL, 0 );
	InternalUnlock( this_lcl, NULL, NULL, 0 );
    }

    // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF( 2, "Moved surface 0x%p to system memory", this_int );
    return DD_OK;

} /* MoveToSystemMemory */


/*
 * invalidateSurface
 *
 * invalidate one surface
 */
void invalidateSurface( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    if( !SURFACE_LOST( this_lcl ) )
    {
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
	{
	    #ifdef USE_ALIAS
		/*
		 * If the surface is locked then break the locks now.
		 * When a broken lock is finally unlocked by the API the
		 * driver is not called. So we get Create->Lock->Destroy
		 * rather than Create->Lock->Destroy->Unlock. Thus, drivers
		 * must be able to cope with Destroy undo any pending locks
		 * at the driver level but they should be able to cope with
		 * this as it could happen even before the alias changes.
		 */
                if(!(this_lcl->dwFlags & DDRAWISURF_DRIVERMANAGED) ||
                    (this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST))
                {
		    if( this_lcl->lpGbl->dwUsageCount > 0)
		    {
                        // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		        DPF( 4, "Breaking locks held on the surface 0x%p", this_lcl );
		        BreakSurfaceLocks( this_lcl->lpGbl );
                    }
                }
	    #endif /* USE_ALIAS */
            if (!(this_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_SYSMEMEXECUTEBUFFER))
            {
                if((this_lcl->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
                    !(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST))
                {
                    LooseManagedSurface( this_lcl );
                    return;
                }
                else
                    DestroySurface( this_lcl );
            }
	}
	if( (!(this_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED) ||
	     (this_lcl->dwFlags & DDRAWISURF_PARTOFPRIMARYCHAIN) )  &&
            (!(this_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_SYSMEMEXECUTEBUFFER)) ) 
	{
	    this_lcl->dwFlags |= DDRAWISURF_INVALID;
	    BUMP_SURFACE_STAMP(this_lcl->lpGbl);
	}
    }
} /* invalidateSurface */

/*
 * invalidateAttachments
 *
 * invalidate all attachments to a surface
 */
static void invalidateAttachments( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    LPATTACHLIST		pattachlist;
    LPDDRAWI_DDRAWSURFACE_INT	curr_int;

    pattachlist = this_lcl->lpAttachList;
    while( pattachlist != NULL )
    {
	curr_int = pattachlist->lpIAttached;

	if( curr_int->lpLcl->dwFlags & DDRAWISURF_IMPLICITCREATE )
	{
	    invalidateSurface( curr_int->lpLcl );
	    invalidateAttachments( curr_int->lpLcl );
	}
	pattachlist = pattachlist->lpLink;
    }

} /* invalidateAttachments */

/*
 * InvalidateAllPrimarySurfaces
 *
 * Traverses the driver object list and sets the invalid bit on all primary
 * surfaces.
 */
void InvalidateAllPrimarySurfaces( LPDDRAWI_DIRECTDRAW_GBL this )
{
    LPDDRAWI_DIRECTDRAW_LCL     curr_lcl;

    DPF(4, "******** invalidating all primary surfaces");

    /*
     * traverse the driver object list and invalidate all primaries for
     * the specificed driver
     */
    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	if( curr_lcl->lpGbl == this )
	{
	    if( curr_lcl->lpPrimary != NULL )
	    {
		invalidateSurface( curr_lcl->lpPrimary->lpLcl );
		invalidateAttachments( curr_lcl->lpPrimary->lpLcl );
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }

} /* InvalidateAllPrimarySurfaces */

#undef DPF_MODNAME
#define DPF_MODNAME "InvalidateAllSurfaces"

/*
 * We define the page lock IOCTLs here so that we don't have to include ddvxd.h.
 * These must match the corresponding entries in ddvxd.h
 */
#define DDVXD_IOCTL_MEMPAGELOCK             28
#define DDVXD_IOCTL_MEMPAGEUNLOCK           29

/*
 * InvalidateAllSurfaces
 */
void InvalidateAllSurfaces( LPDDRAWI_DIRECTDRAW_GBL this, HANDLE hDDVxd, BOOL fRebuildAliases )
{
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   pTempLcl;

#pragma message( REMIND( "Failure conditions on InvalidateAllSurfaces need to be considered" ) )

#ifdef WIN95
    BackupAllSurfaces(this);
    CleanupD3D8(this, FALSE, 0);
#endif

    DPF(4, "******** invalidating all surfaces");

    #ifdef USE_ALIAS
	/*
	 * As surface memory is about to be destroyed we need to ensure that
	 * anyone with outstanding locks is talking to dummy memory rather
	 * than real video memory
	 *
	 * NOTE: Not a lot we can do on failure here.
	 */
	if( ( NULL != this->phaiHeapAliases ) && ( this->phaiHeapAliases->dwRefCnt > 1UL ) )
	{
            DDASSERT( INVALID_HANDLE_VALUE != hDDVxd );
            if( FAILED( MapHeapAliasesToDummyMem( hDDVxd, this->phaiHeapAliases ) ) )
	    {
                // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		DPF( 0, "Could not map heap aliases for driver object 0x%p", this );
		DDASSERT( FALSE );
	    }

	    if( fRebuildAliases )
	    {
                ReleaseHeapAliases( hDDVxd, this->phaiHeapAliases );
		this->phaiHeapAliases = NULL;
                if( FAILED( CreateHeapAliases( hDDVxd, this ) ) )
		{
                    // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		    DPF( 0, "Could not create the heap aliases for driver object 0x%p", this );
		    DDASSERT( FALSE );
		    /*
		     * Not much we can do if anything goes wrong so simply fail over to needing
		     * to hold the Win16 lock.
		     */
		    this->dwFlags |= DDRAWI_NEEDSWIN16FORVRAMLOCK;
		}
	    }
	}
    #endif /* USE_ALIAS */

    psurf_int = this->dsList;

    while( psurf_int != NULL )
    {
        pTempLcl = psurf_int->lpLcl;
	psurf_int = psurf_int->lpLink;
	invalidateSurface( pTempLcl );
    }

} /* InvalidateAllSurfaces */

/*
 * FindGlobalPrimary
 *
 * Traverses the driver object list and looks for a primary surface (it doesn't
 * matter if it is invalid).  If it finds one, it returns a pointer to the
 * global portion of that surface.  If it doesn't, it returns NULL
 */
LPDDRAWI_DDRAWSURFACE_GBL FindGlobalPrimary( LPDDRAWI_DIRECTDRAW_GBL this )
{
    LPDDRAWI_DIRECTDRAW_LCL	curr_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;

    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	if( curr_lcl->lpGbl == this )
	{
	    psurf_int = curr_lcl->lpPrimary;
	    if( psurf_int && !SURFACE_LOST( psurf_int->lpLcl ) )
	    {
		return psurf_int->lpLcl->lpGbl;
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }

    return NULL;

} /* FindGlobalPrimary */

#ifdef SHAREDZ
/*
 * FindGlobalZBuffer
 *
 * Traverses the driver object list and looks for a global shared Z. If it
 * finds one, it returns a pointer to the global portion of that surface.
 * If it doesn't, it returns NULL.
 *
 * NOTE: This function will return a shared Z buffer even if it has been lost.
 * However, it will only return a shared Z buffer if it was created in the
 * current mode. The idea being that there is one shared Z-buffer per mode
 * and we will only return the shared Z-buffer for the current mode.
 */
LPDDRAWI_DDRAWSURFACE_GBL FindGlobalZBuffer( LPDDRAWI_DIRECTDRAW_GBL this )
{
    LPDDRAWI_DIRECTDRAW_LCL	curr_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;

    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	if( curr_lcl->lpGbl == this )
	{
	    psurf_lcl = curr_lcl->lpSharedZ;
	    if( psurf_lcl && ( psurf_lcl->dwModeCreatedIn == this->dwModeIndex ) )
	    {
		return psurf_lcl->lpGbl;
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }

    return NULL;

} /* FindGlobalZBuffer */

/*
 * FindGlobalBackBuffer
 *
 * Traverses the driver object list and looks for a global shared back-buffer.
 * If it finds one, it returns a pointer to the global portion of that surface.
 * If it doesn't, it returns NULL.
 *
 * NOTE: This function will return a shared back buffer even if it has been lost.
 * However, it will only return a shared back buffer if it was created in the
 * current mode. The idea being that there is one shared back-buffer per mode and
 * we will only return the shared back-buffer for the current mode.
 */
LPDDRAWI_DDRAWSURFACE_GBL FindGlobalBackBuffer( LPDDRAWI_DIRECTDRAW_GBL this )
{
    LPDDRAWI_DIRECTDRAW_LCL	curr_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;

    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	if( curr_lcl->lpGbl == this )
	{
	    psurf_lcl = curr_lcl->lpSharedBack;
	    if( psurf_lcl && ( psurf_lcl->dwModeCreatedIn == this->dwModeIndex ) )
	    {
		return psurf_lcl->lpGbl;
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }

    return NULL;

} /* FindGlobalBackBuffer */
#endif

/*
 * MatchPrimary
 *
 * Traverses the driver object list and looks for valid primary surfaces.  If
 * a valid primary surface is found, it attempts to verify that the
 * surface described by lpDDSD is compatible with the existing primary.  If
 * it is, the process continues until all valid primary surfaces have been
 * checked.  If a primary surface is not compatible, lpDDSD is modified to
 * show a surface description which would have succeeded and FALSE is returned.
 */
BOOL MatchPrimary( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDSURFACEDESC2 lpDDSD )
{
    /*
     * right now, the only requirement for two primary surfaces to be
     * compatible is that they must both be allocated in video memory or in
     * system memory.  Traverse the driver object list until a valid primary
     * surface is found.  If a surface is found, verify that it is compatible
     * with the requested surface.  If no valid primary surface is found,
     * return TRUE.
     */
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	curr_lcl;

    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	/*
	 * is this object pointing to the same driver data?
	 */
	if( curr_lcl->lpGbl == pdrv )
	{
	    psurf_int = curr_lcl->lpPrimary;
	    if( psurf_int && !SURFACE_LOST( psurf_int->lpLcl ) )
	    {
		psurf_lcl = psurf_int->lpLcl;
		if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
		    (lpDDSD->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) )
		{
		    lpDDSD->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
		    lpDDSD->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
		    return FALSE;
		}
		if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
		    (lpDDSD->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
		{
		    lpDDSD->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
		    lpDDSD->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
		    return FALSE;
		}
		break;
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }
    return TRUE;

} /* MatchPrimary */

#ifdef SHAREDZ
/*
 * MatchSharedZBuffer
 *
 * Traverses the driver object list and looks for valid shared Z buffers.  If
 * a valid shared Z buffer is found, it attempts to verify that the
 * surface described by lpDDSD is compatible with the existing shared Z buffer.
 * If it is, the process continues until all valid shared Z buffers have been
 * checked.  If a shared Z buffer is not compatible, lpDDSD is modified to
 * show a surface description which would have succeeded and FALSE is returned.
 */
BOOL MatchSharedZBuffer( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDSURFACEDESC lpDDSD )
{
    /*
     * Currently we allow one shared Z-buffer per mode. So we don't care if we
     * don't match against any other shared Z-buffers in different modes. We
     * only need to match against shared Z-buffers created in the current mode.
     *
     * If we do come across another shared Z-buffer in the same mode then we
     * check to ensure that its in the same type of memory (SYSTEM or VIDEO)
     * and that the requested depths match.
     */
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf;
    LPDDRAWI_DIRECTDRAW_LCL	curr_lcl;
    LPDDPIXELFORMAT             lpddpf;

    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	/*
	 * is this object pointing to the same driver data?
	 */
	if( curr_lcl->lpGbl == pdrv )
	{
	    psurf_lcl = curr_lcl->lpSharedZ;
	    if( psurf_lcl && ( psurf_lcl->dwModeCreatedIn == pdrv->dwModeIndex ) )
	    {
		if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
		    (lpDDSD->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) )
		{
		    lpDDSD->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
		    lpDDSD->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
		    return FALSE;
		}
		if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
		    (lpDDSD->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
		{
		    lpDDSD->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
		    lpDDSD->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
		    return FALSE;
		}

                psurf = psurf_lcl->lpGbl;
                /*
                 * !!! NOTE: For when I finally get round to putting
                 * asserts in the code.
                 * ASSERT( psurf != NULL );
                 */
                GET_PIXEL_FORMAT( psurf_lcl, psurf, lpddpf );
                /*
                 * ASSERT( lpddpf != NULL );
                 * ASSERT( lpddpf->dwFlags & DDPF_ZBUFFER );
                 */
                if( lpddpf->dwZBufferBitDepth != lpDDSD->dwZBufferBitDepth )
                {
                    lpDDSD->dwZBufferBitDepth = lpddpf->dwZBufferBitDepth;
                    return FALSE;
                }
		break;
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }
    return TRUE;

} /* MatchSharedZBuffer */

/*
 * MatchSharedBackBuffer
 *
 * Traverses the driver object list and looks for valid shared back buffers.  If
 * a valid shared back buffer is found, it attempts to verify that the
 * surface described by lpDDSD is compatible with the existing shared back buffer.
 * If it is, the process continues until all valid shared back buffers have been
 * checked.  If a shared back buffer is not compatible, lpDDSD is modified to
 * show a surface description which would have succeeded and FALSE is returned.
 */
BOOL MatchSharedBackBuffer( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDSURFACEDESC lpDDSD )
{
    /*
     * Currently we allow one shared back-buffer per mode. So we don't care if we
     * don't match against any other shared back-buffers in different modes. We
     * only need to match against shared back-buffers created in the current mode.
     *
     * If we do come across another shared back-buffer in the same mode then we
     * check to ensure that its in the same type of memory (SYSTEM or VIDEO)
     * and that its pixel format matches.
     */
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf;
    LPDDRAWI_DIRECTDRAW_LCL	curr_lcl;
    LPDDPIXELFORMAT             lpddpf1;
    LPDDPIXELFORMAT             lpddpf2;

    if( lpDDSD->dwFlags & DDSD_PIXELFORMAT )
        lpddpf2 = &lpDDSD->ddpfPixelFormat;
    else
        lpddpf2 = &pdrv->vmiData.ddpfDisplay;

    curr_lcl = lpDriverLocalList;
    while( curr_lcl != NULL )
    {
	/*
	 * is this object pointing to the same driver data?
	 */
	if( curr_lcl->lpGbl == pdrv )
	{
	    psurf_lcl = curr_lcl->lpSharedBack;
	    if( psurf_lcl && ( psurf_lcl->dwModeCreatedIn == pdrv->dwModeIndex ) )
	    {
		if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
		    (lpDDSD->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) )
		{
		    lpDDSD->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
		    lpDDSD->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
		    return FALSE;
		}
		if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
		    (lpDDSD->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
		{
		    lpDDSD->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
		    lpDDSD->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
		    return FALSE;
		}

                psurf = psurf_lcl->lpGbl;
                /*
                 * !!! NOTE: For when I finally get round to putting
                 * asserts in the code.
                 * ASSERT( psurf != NULL );
                 */
                GET_PIXEL_FORMAT( psurf_lcl, psurf, lpddpf1 );

                /*
                 * ASSERT( lpddpf1 != NULL );
                 */
                if( IsDifferentPixelFormat( lpddpf1, lpddpf2 ) )
                {
                    lpDDSD->dwFlags |= DDSD_PIXELFORMAT;
                    memcpy( &lpDDSD->ddpfPixelFormat, lpddpf1, sizeof( DDPIXELFORMAT ) );
                    return FALSE;
                }
		break;
	    }
	}
	curr_lcl = curr_lcl->lpLink;
    }
    return TRUE;

} /* MatchSharedBackBuffer */
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "PageLock"

/*
 * DD_Surface_PageLock
 *
 * Prevents a system memory surface from being paged out.
 */
HRESULT DDAPI DD_Surface_PageLock(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT			hr;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_PageLock");
    /* DPF_ENTERAPI(lpDDSurface); */

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

        if( dwFlags & ~DDPAGELOCK_VALID )
	{
	    DPF_ERR( "Invalid flags") ;
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

    // Don't pagelock video memory or emulated primary surface
    if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) &&
	!(this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
    {
	hr = InternalPageLock(this_lcl, pdrv_lcl);
    }
    else
    {
	// Succeed but don't do anything if surface has video memory
	// or if this is the emulated primary surface
	hr = DD_OK;
    }

    LEAVE_DDRAW();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "PageUnlock"

/*
 * DD_Surface_PageUnlock
 */
HRESULT DDAPI DD_Surface_PageUnlock(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    HRESULT			hr;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_PageUnlock");

    /* DPF_ENTERAPI(lpDDSurface); */

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

        if( dwFlags & ~DDPAGEUNLOCK_VALID )
	{
	    DPF_ERR( "Invalid flags") ;
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    //
    // For now, if the current surface is optimized, quit
    //
    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
        DPF_ERR( "It is an optimized surface" );
        LEAVE_DDRAW();
        return DDERR_ISOPTIMIZEDSURFACE;
    }

    // Don't pageunlock video memory or emulated primary surface
    if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) &&
	!(this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
    {
	hr = InternalPageUnlock(this_lcl, pdrv_lcl);
    }
    else
    {
	// Succeed but don't do anything if surface has video memory
	// or if this is the emulated primary surface
	hr = DD_OK;
    }

    LEAVE_DDRAW();
    return hr;
}

/*
 * InternalPageLock
 *
 * Assumes driver lock is taken
 */

HRESULT InternalPageLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
			  LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    BOOL    rc;
    DWORD   cbReturned;
    DWORD   dwReturn;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE(this_lcl->lpGbl);

    struct _PLin
    {
	LPVOID	pMem;
	DWORD	cbBuffer;
	DWORD	dwFlags;
	LPDWORD pdwTable;
	LPDWORD	ppTable;
    } PLin;

#ifndef WINNT
    // If we're already locked; then just increment the count
    if( this_lcl->lpSurfMore->dwPageLockCount )
    {
        this_lcl->lpSurfMore->dwPageLockCount++;
	return DD_OK;
    }

    // Sanity Check
    DDASSERT( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY );
    DDASSERT( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) );

    // Initialize Parameters to pass to VXD
    PLin.pMem = (LPVOID)this_lcl->lpGbl->fpVidMem;
    DDASSERT( PLin.pMem );
    PLin.cbBuffer = this_lcl->lpSurfMore->dwBytesAllocated;
    DDASSERT( PLin.cbBuffer );
    PLin.dwFlags = 0;

    PLin.pdwTable = &lpSurfGblMore->dwPhysicalPageTable;
    PLin.ppTable = (LPDWORD) &lpSurfGblMore->pPageTable;

    DDASSERT( pdrv_lcl->hDDVxd );
    rc = DeviceIoControl( (HANDLE)(pdrv_lcl->hDDVxd),
        DDVXD_IOCTL_MEMPAGELOCK,
	&PLin,
	sizeof( PLin ),
	&dwReturn,
	sizeof( dwReturn ),
	&cbReturned,
	NULL );

    if( !rc )
    {
	lpSurfGblMore->dwPhysicalPageTable = 0;
	lpSurfGblMore->pPageTable = 0;
	lpSurfGblMore->cPages = 0;
	return DDERR_CANTPAGELOCK;
    }
    DDASSERT( cbReturned == sizeof(dwReturn));
    DDASSERT( *PLin.pdwTable && *PLin.ppTable );
    DDASSERT( lpSurfGblMore->dwPhysicalPageTable && lpSurfGblMore->pPageTable );

    // Massage Table
    {
	unsigned i;
	DWORD *rgdwPhysical = lpSurfGblMore->pPageTable;

	// Compute the number of pages
	DWORD cPages = (((DWORD)PLin.pMem & 0xFFF) + 0xFFF + PLin.cbBuffer)/4096;

	// Set the number of pages
	lpSurfGblMore->cPages = cPages;

	// Mask out the page-table flags
	for( i = 0; i < cPages; i++ )
	{
	    // Check that the page is present, user-accessible, and read/write
	    DDASSERT( rgdwPhysical[i] & 0x7 );
	    // Clear out the low bits
	    rgdwPhysical[i] &= 0xFFFFF000;
	}
	// Fix the first entry to point to the starting address
	rgdwPhysical[0] |= ((DWORD)PLin.pMem & 0xFFF);
    }

    this_lcl->lpSurfMore->dwPageLockCount++;
    DDASSERT( this_lcl->lpSurfMore->dwPageLockCount == 1 );

    // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF( 5, "Page Locked %d bytes at 0x%p (count=%d)", PLin.cbBuffer, PLin.pMem,
	this_lcl->lpSurfMore->dwPageLockCount );

#endif

    return DD_OK;
}

HRESULT InternalPageUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
			    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    BOOL    rc;
    DWORD   cbReturned;
    DWORD   dwReturn;
    struct _PLin
    {
	LPVOID	pMem;
	DWORD	cbBuffer;
	DWORD	dwFlags;
	LPDWORD pTable;
    } PLin;

#ifndef WINNT

    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE(this_lcl->lpGbl);

    DDASSERT( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY );
    DDASSERT( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) );

    if( this_lcl->lpSurfMore->dwPageLockCount <= 0 )
    {
	return DDERR_NOTPAGELOCKED;
    }

    // If we're already locked more than once; then just decrement the count
    if( this_lcl->lpSurfMore->dwPageLockCount > 1 )
    {
        this_lcl->lpSurfMore->dwPageLockCount--;
	return DD_OK;
    }

    /*
     * If it's a system memory surface, better wait for any pending DMA operations
     * to finish.
     */
    if( this_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
    {
        WaitForDriverToFinishWithSurface( pdrv_lcl, this_lcl );
    }

    PLin.pMem = (LPVOID)this_lcl->lpGbl->fpVidMem;
    DDASSERT( PLin.pMem );
    PLin.cbBuffer = this_lcl->lpSurfMore->dwBytesAllocated;
    DDASSERT( PLin.cbBuffer );
    PLin.dwFlags = 0;
    PLin.pTable = lpSurfGblMore->pPageTable;

    DDASSERT( pdrv_lcl->hDDVxd );
    rc = DeviceIoControl((HANDLE)(pdrv_lcl->hDDVxd),
        DDVXD_IOCTL_MEMPAGEUNLOCK,
	&PLin,
	sizeof( PLin ),
	&dwReturn,
	sizeof( dwReturn ),
	&cbReturned,
	NULL);

    if( !rc )
	return DDERR_CANTPAGEUNLOCK;
    DDASSERT( cbReturned == sizeof(dwReturn) );

    this_lcl->lpSurfMore->dwPageLockCount--;

    DDASSERT( this_lcl->lpSurfMore->dwPageLockCount == 0 );

    lpSurfGblMore->dwPhysicalPageTable = 0;
    lpSurfGblMore->pPageTable = 0;
    lpSurfGblMore->cPages = 0;

    // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF(5, "Page Unlocked %d bytes at 0x%p (count=%d)", PLin.cbBuffer, PLin.pMem,
	this_lcl->lpSurfMore->dwPageLockCount);

    // Increment a timestamp counter; this will help
    // a driver determine if the physical addresses have
    // changed between the time that they have cached it
    // and the time of the Blt/Render call
    lpSurfGblMore->cPageUnlocks++;

#endif

    return DD_OK;
}

HRESULT DDAPI DD_Surface_GetDDInterface(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPVOID FAR *lplpDD )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DIRECTDRAW_INT	pdrv_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetDDInterface");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	if( !VALID_PTR_PTR( lplpDD ) )
	{
	    DPF_ERR( "Invalid DirectDraw Interface ptr ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	pdrv_int = this_int->lpLcl->lpSurfMore->lpDD_int;
	*lplpDD = pdrv_int;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    // Addref the interface before giving it back to the app
    DD_AddRef( (LPDIRECTDRAW)pdrv_int );

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetDDInterface */

HRESULT InternalAssociateDC(
	HDC hdc,
	LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl )
{
    DCINFO *pdcinfo;

    DDASSERT( hdc != NULL );
    DDASSERT( pdds_lcl != NULL );

    pdcinfo = (DCINFO *)MemAlloc( sizeof( DCINFO ) );
    if( pdcinfo == NULL )
    {
	return DDERR_OUTOFMEMORY;
    }

    // initialize element
    pdcinfo->hdc = hdc;
    pdcinfo->pdds_lcl = pdds_lcl;

    // Add element to front of list
    pdcinfo->pdcinfoNext = g_pdcinfoHead;
    g_pdcinfoHead = pdcinfo;

    return DD_OK;
}

HRESULT InternalRemoveDCFromList(
	HDC hdc,
	LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl )
{
    // We may or may not have an hdc passed in.
    // However, this lets us do an error check for
    // some bad parameter cases.
    DCINFO *pdcinfo;
    DCINFO *pdcinfoPrev = NULL;

    DDASSERT( pdds_lcl != NULL );
    for( pdcinfo = g_pdcinfoHead; pdcinfo != NULL;
	    pdcinfoPrev = pdcinfo, pdcinfo = pdcinfo->pdcinfoNext )
    {
	DDASSERT( pdcinfo->pdds_lcl != NULL );

	if( pdds_lcl == pdcinfo->pdds_lcl || hdc == pdcinfo->hdc )
	{
	    // Check that punk & hdc are in synch -or-
	    // we didn't have an hdc passed in..
	    DDASSERT( hdc == NULL || (pdds_lcl == pdcinfo->pdds_lcl && hdc == pdcinfo->hdc) );

	    // Release this DC. We do this because it is dangerous
	    // to leave it around for windows to use because it points
	    // surface that we have just freed.
            //
            // However, don't release DCs that were created with the
            // GetDC flag since that is automatically cleaned up by
            // Windows. (Moreover, it wasn't allocated by DD16 who'll
            // get confused.)
	    if( hdc == NULL && !(pdds_lcl->dwFlags & DDRAWISURF_GETDCNULL) )
	    {
		DDASSERT( pdcinfo->hdc != NULL );
                // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		DPF( 1, "Releasing Leaked DC = 0x%p", pdcinfo->hdc );
#ifdef WIN95
		    DD16_ReleaseDC( pdcinfo->hdc );
#else
                    if( ( pdds_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY ) ||
                        !( pdds_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
                    {
	                DdReleaseDC( pdds_lcl );
                    }
#endif
            }

	    // Remove this dcinfo from the list.
	    if( pdcinfoPrev == NULL )
		g_pdcinfoHead = pdcinfo->pdcinfoNext;
	    else
		pdcinfoPrev->pdcinfoNext = pdcinfo->pdcinfoNext;

	    // Free this DcInfo
	    MemFree( pdcinfo );

	    return DD_OK;
	}
	// Not us? Then just sanity check the object we did find
	DDASSERT( pdcinfo->pdds_lcl->dwFlags & DDRAWISURF_HASDC );
    }

    DPF_ERR( "DC/Surface association not found?" );
    DDASSERT( 0 );
    return DDERR_NOTFOUND;
}

HRESULT InternalGetSurfaceFromDC(
	HDC hdc,
	LPDIRECTDRAWSURFACE *ppdds,
	HDC *phdcDriver,
        LPVOID pCallbacks)
{
    HRESULT ddrval = DDERR_INVALIDPARAMS;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: GetSurfaceFromDC");

    TRY
    {
	DCINFO *pdcinfo;

	if( !VALID_PTR_PTR( ppdds ) )
	{
	    DPF_ERR( "Invalid IDirectDrawSurface Interface ptr ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	// Default value
	*ppdds = NULL;
	*phdcDriver = NULL;

	ddrval = DDERR_GENERIC;

	for ( pdcinfo = g_pdcinfoHead; pdcinfo != NULL; pdcinfo = pdcinfo->pdcinfoNext )
	{
	    if( pdcinfo->hdc == hdc )
	    {
		DDASSERT( pdcinfo->pdds_lcl != NULL );
		DDASSERT( pdcinfo->pdds_lcl->dwFlags & DDRAWISURF_HASDC );
		*ppdds = (LPVOID)getDDSInterface( pdcinfo->pdds_lcl->lpGbl->lpDD,
			pdcinfo->pdds_lcl, pCallbacks );

		if( *ppdds == NULL )
		{
		    DPF_ERR( "GetSurfaceFromDC couldn't allocate interface" );
		    ddrval = DDERR_OUTOFMEMORY;
		}
		else
		{
		    *phdcDriver = (HDC)pdcinfo->pdds_lcl->lpSurfMore->lpDD_lcl->hDC;
    		    DD_Surface_AddRef( *ppdds );
		    ddrval = DD_OK;
		}
		LEAVE_DDRAW();
		return ddrval;
	    }
	}
	DPF( 1, "GetSurfaceFromDC didn't find HDC" );
	ddrval = DDERR_NOTFOUND;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	#ifdef DEBUG
	if (ddrval == DDERR_INVALIDPARAMS)
	    DPF_ERR( "Exception encountered validating parameters" );
	else
	{
	    DPF_ERR( "Unexpected error during GetSurfaceFromDC" );
	    DDASSERT( 0 );
	}
	#endif
    }

    LEAVE_DDRAW();
    return ddrval;
}

HRESULT EXTERN_DDAPI DD_GetSurfaceFromDC( LPDIRECTDRAW lpDD, HDC hdc, LPDIRECTDRAWSURFACE * pDDS)
{
    HDC     hdcTemp;
    lpDD;

    DPF(2,A,"ENTERAPI: DD_GetSurfaceFromDC");

    if (LOWERTHANDDRAW7( ((LPDDRAWI_DIRECTDRAW_INT)lpDD)) )
        return InternalGetSurfaceFromDC(hdc, pDDS, &hdcTemp, &ddSurfaceCallbacks);

    return InternalGetSurfaceFromDC(hdc, pDDS, &hdcTemp, &ddSurface7Callbacks);

}

HRESULT EXTERN_DDAPI GetSurfaceFromDC(
	HDC hdc,
	LPDIRECTDRAWSURFACE *ppdds,
	HDC *phdcDriver )
{
    return InternalGetSurfaceFromDC(hdc, ppdds, phdcDriver, (LPVOID) &ddSurfaceCallbacks );
}

#ifdef WIN95

void InitColorTable( RGBQUAD *rgColors, LPPALETTEENTRY lpPalette )
{
    int i;

    for( i = 0; i < 256; i++ )
    {
	rgColors[i].rgbBlue = lpPalette[i].peBlue;
	rgColors[i].rgbGreen = lpPalette[i].peGreen;
	rgColors[i].rgbRed = lpPalette[i].peRed;
	rgColors[i].rgbReserved = 0;
    }
    return;
}
// This function walks the list of outstanding DCs and figures out
// if the DC's colortable needs to be updated. It may be called in two ways:
//
// surface+pal -> this means that pal was attached to a surface
// just a surface -> this means that a palette was removed from a surface
void UpdateOutstandingDC( LPDDRAWI_DDRAWSURFACE_LCL psurf_lcl, LPDDRAWI_DDRAWPALETTE_GBL ppal_gbl )
{
    BOOL		fColorsInited = FALSE;
    RGBQUAD		rgColors[256];
    PALETTEENTRY	rgPalEntry[256];
    LPDDPIXELFORMAT	pddpf;
    DCINFO		*pdcinfo;
    LPDDPIXELFORMAT	pddpf_curr;

    DDASSERT( psurf_lcl );

    // Quick check to see if there are any DCs outstanding
    // If not, then we don't have to do all this work
    if( g_pdcinfoHead == NULL )
	return;

    GET_PIXEL_FORMAT( psurf_lcl, psurf_lcl->lpGbl, pddpf );

    // Ignore non-8bit surfaces
    if( !(pddpf->dwFlags & DDPF_PALETTEINDEXED8) )
	return;

    if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) )
    {
        // Primary?
	// If it is, then we need to find all the outstanding
	// DCs that are sharing the palette; and update them
	for ( pdcinfo = g_pdcinfoHead; pdcinfo != NULL; pdcinfo = pdcinfo->pdcinfoNext )
	{
	    DDASSERT( pdcinfo->pdds_lcl != NULL );
	    DDASSERT( pdcinfo->pdds_lcl->dwFlags & DDRAWISURF_HASDC );

	    GET_PIXEL_FORMAT( pdcinfo->pdds_lcl, pdcinfo->pdds_lcl->lpGbl, pddpf_curr );

	    // Ignore non palette-indexed 8-bit surfaces
	    if( !(pddpf_curr->dwFlags & DDPF_PALETTEINDEXED8) )
		continue;

	    // Ignore DCs handed out by other direct draw interfaces
	    if( pdcinfo->pdds_lcl->lpGbl->lpDD != psurf_lcl->lpGbl->lpDD )
		continue;

	    // Ignore surfaces that have their own palettes
	    // (except for our surface that is..)
	    if( pdcinfo->pdds_lcl->lpDDPalette != NULL &&
		pdcinfo->pdds_lcl != psurf_lcl )
		continue;

	    // We don't need to touch palettes that are of the
	    // DCNULL kind (it's already been updated
	    // because the DC isn't one of the ones we cooked ourselves)
	    if( pdcinfo->pdds_lcl->dwFlags & DDRAWISURF_GETDCNULL )
		continue;

	    // Ok, this DC needs updating
            // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF( 3, "Updating colortable for HDC(0x%p)", pdcinfo->hdc );

	    // Have we init'ed our colors?
	    if( !fColorsInited )
	    {
		if( ppal_gbl && ppal_gbl->dwFlags & DDRAWIPAL_EXCLUSIVE )
		{
		    // If we're exclusive then use our colors as is
		    InitColorTable( rgColors, ppal_gbl->lpColorTable );
		}
		else
		{
		    // Else, use the colors from current system palette
		    int n = GetSystemPaletteEntries( (HDC)psurf_lcl->lpSurfMore->lpDD_lcl->hDC,
			    0, 256, rgPalEntry );
		    DDASSERT( n == 256 );
		    InitColorTable( rgColors, rgPalEntry );
		}
    		fColorsInited = TRUE;
	    }
	    // Set the colors into the DC, this will have the
	    // extra effect of resetting any cached translation tables
	    // so GDI won't use a wrong one inadvertently.
	    DPF(5, "Dib Color Table entry #50 == 0x%x", rgColors[50]);
	    SetDIBColorTable( pdcinfo->hdc, 0, 256, rgColors);
	}
    }
    else
    {
	// Ordinary surface? Then find it in our list
	for ( pdcinfo = g_pdcinfoHead; pdcinfo != NULL; pdcinfo = pdcinfo->pdcinfoNext )
	{
	    DDASSERT( pdcinfo->pdds_lcl != NULL );
	    DDASSERT( pdcinfo->pdds_lcl->dwFlags & DDRAWISURF_HASDC );

	    // Ignored surfaces that have different global objects
	    if( pdcinfo->pdds_lcl->lpGbl != psurf_lcl->lpGbl )
		continue;

	    // Ignore non palette-indexed 8-bit surfaces
	    GET_PIXEL_FORMAT( pdcinfo->pdds_lcl, pdcinfo->pdds_lcl->lpGbl, pddpf_curr );
	    if( !(pddpf_curr->dwFlags & DDPF_PALETTEINDEXED8) )
		continue;

	    // Ok, this DC needs updating
            // 5/25/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF( 3, "Updating colortable for non-primary HDC(0x%p)", pdcinfo->hdc );

	    if( !fColorsInited )
	    {
		if( ppal_gbl )
		{
		    // New color table for this offscreen surface?
		    // Use them directly
	    	    InitColorTable( rgColors, ppal_gbl->lpColorTable );
		    fColorsInited = TRUE;
		}
		else
		{
		    int n;

		    // Someone is removing a palette from an offscreen surface?
		    // Then if the primary is at 8bpp, then we should
		    // steal the colors from it.
		    LPDDRAWI_DDRAWSURFACE_INT lpPrimary = pdcinfo->pdds_lcl->lpSurfMore->lpDD_lcl->lpPrimary;
		    if( lpPrimary )
		    {
			// Check that the primary is 8bpp. If it is not,
			// then we leave this surface alone.
			GET_PIXEL_FORMAT( lpPrimary->lpLcl, lpPrimary->lpLcl->lpGbl, pddpf_curr );

			if( !(pddpf_curr->dwFlags & DDPF_PALETTEINDEXED8) )
			    return;
		    }
		    else
		    {
			// There is no primary surface attached to this
			// DDraw. So we have no where useful to get colors from
			// so return.
			return;
		    }

		    DDASSERT( lpPrimary != NULL );
		    DDASSERT( pddpf_curr->dwFlags & DDPF_PALETTEINDEXED8 );

		    // Else, use the colors from current system palette
		    n = GetSystemPaletteEntries( (HDC)lpPrimary->lpLcl->lpSurfMore->lpDD_lcl->hDC,
			    0, 256, rgPalEntry );
		    DDASSERT( n == 256 );
		    InitColorTable( rgColors, rgPalEntry );

		}
	    }

	    // Set the colors into the DC, this will have the
	    // extra effect of reseting any cached translation tables
	    // so GDI won't use a wrong one inadvertantly.
	    DPF(5, "Dib Color Table entry #50 == 0x%x", rgColors[50]);
	    SetDIBColorTable( pdcinfo->hdc, 0, 256, rgColors);
	}
    }

    return;
}

// This function handles the case when the entries of a
// palette have changed. We need to search for all the surfaces
// that may be affected and do something. However, we only

void UpdateDCOnPaletteChanges( LPDDRAWI_DDRAWPALETTE_GBL ppal_gbl )
{
    DCINFO		*pdcinfo;
    DDASSERT( ppal_gbl != NULL );

    // Quick check to see if there are any DCs outstanding
    // If not, then we don't have to do all this work
    if( g_pdcinfoHead == NULL )
	return;

    // Is this palette attached to our primary?
    // We have to do this explicitly without regard to the outstanding
    // DC list because the primary itself may have no outstanding DCs
    // but offscreen surfaces may be logically 'sharing' the primary's palette
    if( ppal_gbl->lpDD_lcl->lpPrimary &&
	ppal_gbl->lpDD_lcl->lpPrimary->lpLcl->lpDDPalette &&
	ppal_gbl->lpDD_lcl->lpPrimary->lpLcl->lpDDPalette->lpLcl->lpGbl == ppal_gbl )
    {
	// Update the palette for DCs associated with this primary
	UpdateOutstandingDC( ppal_gbl->lpDD_lcl->lpPrimary->lpLcl, ppal_gbl );
    }

    // We walk all outstanding DCs looking for
    // surfaces that are DIRECTLY affected this set entries.
    for ( pdcinfo = g_pdcinfoHead; pdcinfo != NULL; pdcinfo = pdcinfo->pdcinfoNext )
    {
	DDASSERT( pdcinfo->pdds_lcl != NULL );
	DDASSERT( pdcinfo->pdds_lcl->dwFlags & DDRAWISURF_HASDC );

	// Ignore surfaces that don't have a palette;
	// (If a surface doesn't have a palette, then that means
	// it's using the palette from the primary. We handle that case
	// above when we deal with the primary.)
	if( pdcinfo->pdds_lcl->lpDDPalette == NULL )
	    continue;

	// Ignore surfaces that aren't connected to us
	if( pdcinfo->pdds_lcl->lpDDPalette->lpLcl->lpGbl != ppal_gbl )
	    continue;

	// Ignore the primary that we already updated above
	if( ppal_gbl->lpDD_lcl->lpPrimary &&
	    ppal_gbl->lpDD_lcl->lpPrimary->lpLcl == pdcinfo->pdds_lcl )
	    continue;

	UpdateOutstandingDC( pdcinfo->pdds_lcl, ppal_gbl );
    }

    return;
}
#endif /* WIN95 */

#undef DPF_MODNAME
#define DPF_MODNAME "GetTopLevel"

LPDDRAWI_DDRAWSURFACE_LCL GetTopLevel(LPDDRAWI_DDRAWSURFACE_LCL lpLcl)
{
    // loop to find the top level surface of a mipmap chain
    for(; (lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL) != 0; 
        lpLcl = lpLcl->lpAttachListFrom->lpAttached);

    // if the top level surface is a cubemap face
    if((lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) != 0)
        // then we need to return the top level surface of the cubemap
        // The assumption here is that a cubemap is only one level deep
        // and a cubemap subface is attached from ONLY a cubemap top level face
        if(lpLcl->lpAttachListFrom != NULL)
            lpLcl = lpLcl->lpAttachListFrom->lpAttached;

    return lpLcl;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DD_Surface_SetSurfaceDesc"

/*
 * NOTE: There is a significant amount of code in this function that
 * deals with video memory surfaces yet you will notice a check explicitly
 * failing this function for surfaces which are not explicit system
 * memory. This is deliberate. The intention is to mutate this function
 * to work with video memory surfaces over time. The code is in place
 * to start this process however unresolved issues remain.
 */

HRESULT DDAPI DD_Surface_SetSurfaceDesc(
		LPDIRECTDRAWSURFACE3 lpDDSurface,
		LPDDSURFACEDESC      lpddsd,
		DWORD                dwFlags )
{
    DDSURFACEDESC2 ddsd2 = {sizeof(ddsd2)};

    DPF(2,A,"ENTERAPI: DD_Surface_SetSurfaceDesc");

    ZeroMemory(&ddsd2,sizeof(ddsd2));

    TRY
    {
	if( !VALID_DIRECTDRAWSURFACE_PTR( ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface) ) )
	{
	    DPF_ERR( "Invalid surface description passed" );
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
	    return DDERR_INVALIDOBJECT;
	}

	if( 0UL != dwFlags )
	{
	    DPF_ERR( "No flags are currently specified - 0 must be passed" );
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	    return DDERR_INVALIDPARAMS;
	}

	if( !VALID_DDSURFACEDESC_PTR( lpddsd ) )
	{
	    DPF_ERR( "Invalid surface description. Did you set the dwSize member?" );
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	    return DDERR_INVALIDPARAMS;
	}

        memcpy(&ddsd2,lpddsd,sizeof(*lpddsd));
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters: Bad LPDDSURFACEDESC" );
        DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	return DDERR_INVALIDPARAMS;
    }

    ddsd2.dwSize = sizeof(ddsd2);

    return DD_Surface_SetSurfaceDesc4(lpDDSurface, &ddsd2, dwFlags);
}

HRESULT DDAPI DD_Surface_SetSurfaceDesc4(
		LPDIRECTDRAWSURFACE3 lpDDSurface,
		LPDDSURFACEDESC2      lpddsd,
		DWORD                dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DIRECTDRAW_INT	pdrv_int;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    BOOL                        emulation;
    DWORD                       dwDummyFlags;
    HRESULT                     ddres;
    DDSURFACEDESC2              ddsd;
    DDHAL_CANCREATESURFACEDATA	ccsd;
    LPDDHAL_CANCREATESURFACE	ccsfn;
    LPDDHAL_CANCREATESURFACE	ccshalfn;
    WORD                        wOldWidth;
    WORD                        wOldHeight;
    LONG                        lOldPitch;
    DDPIXELFORMAT               ddpfOldPixelFormat;
    BOOL                        bIsCompressedTexture = FALSE;
    WORD                        realwidth;
    WORD                        realheight;
    DWORD                       realsurfsize;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetSurfaceDesc4");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface description passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );
	this = this_lcl->lpGbl;
	DDASSERT( NULL != this );
	pdrv_int = this_lcl->lpSurfMore->lpDD_int;
	DDASSERT( NULL != pdrv_int );
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	DDASSERT( NULL != pdrv_lcl );
	pdrv = pdrv_lcl->lpGbl;
	DDASSERT( NULL != pdrv );

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( 0UL != dwFlags )
	{
	    DPF_ERR( "No flags are currently specified - 0 must be passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( !VALID_DDSURFACEDESC2_PTR( lpddsd ) )
	{
	    DPF_ERR( "Surface description is invalid" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( SURFACE_LOST( this_lcl ) )
	{
	    DPF_ERR( "Could not set surface pointer - surface is lost" );
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	if( this->dwUsageCount > 0UL )
	{
	    DPF_ERR( "Could not set surface pointer - surface is locked" );
	    LEAVE_DDRAW();
	    return DDERR_SURFACEBUSY;
	}

	/*
	 * Currently we don't allow anything but explicit system memory surfaces to
	 * have thier surface description (and pointer modified).
	 */
	#pragma message( REMIND( "Look into making SetSurfaceDesc work for video memory" ) )
	if( !( this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED ) )
	{
	    DPF_ERR( "Could not set surface pointer - surface is not explicit system memory" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDSURFACETYPE;
	}
	DDASSERT( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY );

	if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE     ) ||
	    ( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACELEFT ) ||
	    ( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY            ) ||
	    ( this_lcl->ddsCaps.dwCaps & DDSCAPS_ALLOCONLOAD        ) ||
            ( this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE  ) ||
            ( this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_D3DTEXTUREMANAGE  ))
	{
	    DPF_ERR( "Could not set surface pointer - surface is primary, overlay or device specific" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDSURFACETYPE;
	}

	/*
	 * Don't mess with anything that is part of the primary chain. That could get
	 * very nasty (destroying the primary surface pointer and replacing it with
	 * some app. specific garbage).
	 */
	if( this_lcl->dwFlags & DDRAWISURF_PARTOFPRIMARYCHAIN )
	{
	    DPF_ERR( "Cannot set surface pointer - surface is part of the primary chain" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDSURFACETYPE;
	}

	if( lpddsd->dwFlags & ~( DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH |
				 DDSD_LPSURFACE | DDSD_PIXELFORMAT ) )
	{
	    DPF_ERR( "Can only specify caps, width, height, pitch, surface ptr and pixel format" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( ( lpddsd->dwFlags & DDSD_WIDTH ) && ( 0UL == lpddsd->dwWidth ) )
	{
	    DPF_ERR( "Invalid surface width specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( ( lpddsd->dwFlags & DDSD_HEIGHT ) && ( 0UL == lpddsd->dwHeight ) )
	{
	    DPF_ERR( "Invalid surface height specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( ( lpddsd->dwFlags & DDSD_PITCH ) && (( lpddsd->lPitch <= 0L ) || (lpddsd->lPitch % 4)) )
	{
	    DPF_ERR( "Invalid surface pitch specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( lpddsd->dwFlags & DDSD_PIXELFORMAT )
	{
	    if( !( this_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT ) )
	    {
		/*
		 * This is very cheesy but the alternative is pretty nasty.
		 * Reallocting the global object with a pixel format if it
		 * does not already have one.
		 */
		DPF_ERR( "Cannot change the pixel format of a surface which does not have one" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }

	    if( !VALID_DDPIXELFORMAT_PTR( ( &(this->ddpfSurface) ) ) )
	    {
		DPF_ERR( "Specifed pixel format is invalid" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}

	if( ( ( lpddsd->dwFlags & DDSD_WIDTH ) && !( lpddsd->dwFlags & DDSD_PITCH ) ) ||
	    ( ( lpddsd->dwFlags & DDSD_PITCH ) && !( lpddsd->dwFlags & DDSD_WIDTH ) ) )
	{
	    DPF_ERR( "If width or pitch is specified then both width AND pitch must be specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( !( lpddsd->dwFlags & DDSD_LPSURFACE ) )
	{
	    DPF_ERR( "Must specify a surface memory pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( NULL == lpddsd->lpSurface )
	{
	    DPF_ERR( "Surface memory pointer can't be NULL" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

        if( lpddsd->dwFlags & DDSD_CAPS )
	{
	    if( lpddsd->ddsCaps.dwCaps != 0 )
	    {
		DPF_ERR( "Illegal to set ddsCaps.dwCaps bits in surface desc" );
		LEAVE_DDRAW();
		return DDERR_INVALIDCAPS;
	    }

#if 0 // DDSCAPS2_LOCALALLOC, DDSCAPS2_COTASKMEM and DDRAWISURFGBL_DDFREESCLIENTMEM are gone
	    if( lpddsd->ddsCaps.dwCaps2 & ~(DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM) )
	    {
		DPF_ERR( "The only legal DDSCAPS2 flags are LOCALALLOC and COTASKMEM" );
		LEAVE_DDRAW();
		return DDERR_INVALIDCAPS;
	    }

	    if( !(~lpddsd->ddsCaps.dwCaps2 & (DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM)) )
	    {
		// Illegal to set LOCALALLOC and COTASKMEM flags simultaneously.
		DPF_ERR( "DDSCAPS2 flags LOCALALLOC and COTASKMEM are mutually exclusive" );
		LEAVE_DDRAW();
		return DDERR_INVALIDCAPS;
	    }
#endif // 0

	    if( lpddsd->ddsCaps.dwCaps3 != 0 )
	    {
		DPF_ERR( "Illegal to set ddsCaps.dwCaps3 bits in surface desc" );
		LEAVE_DDRAW();
		return DDERR_INVALIDCAPS;
	    }

	    if( lpddsd->ddsCaps.dwCaps4 != 0 )
	    {
		DPF_ERR( "Illegal to set ddsCaps.dwCaps4 bits in surface desc" );
		LEAVE_DDRAW();
		return DDERR_INVALIDCAPS;
	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Build a new surface description for the surface and fill in
     * the new width, height and pitch.
     */
    FillDDSurfaceDesc2( this_lcl, &ddsd );
    if( lpddsd->dwFlags & DDSD_WIDTH )
	ddsd.dwWidth   = lpddsd->dwWidth;
    if( lpddsd->dwFlags & DDSD_HEIGHT )
	ddsd.dwHeight  = lpddsd->dwHeight;
    if( lpddsd->dwFlags & DDSD_PITCH )
	ddsd.lPitch    = lpddsd->lPitch;
    if( lpddsd->dwFlags & DDSD_PIXELFORMAT )
	ddsd.ddpfPixelFormat = lpddsd->ddpfPixelFormat;

    emulation = ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY;

    /*
     * Validate that the new surface description makes some remote kind of
     * sense.
     */
    ddres = checkSurfaceDesc( &ddsd,
	                      pdrv,
			      &dwDummyFlags,
			      emulation,
			      this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED,
			      pdrv_int );
    if( FAILED( ddres ) )
    {
	DPF_ERR( "Invalid surface description passed" );
	LEAVE_DDRAW();
	return ddres;
    }

    /*
     * Ask the driver if it likes the look of this surface. We need to ask
     * the driver again (even though we already did it when the surface was
     * created) as the surface has changed size.
     */
    if( emulation )
    {
        if( ddsd.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
	    ccsfn = pdrv_lcl->lpDDCB->HELDDExeBuf.CanCreateExecuteBuffer;
        }
        else
        {
	    ccsfn = pdrv_lcl->lpDDCB->HELDD.CanCreateSurface;
        }
    	ccshalfn = ccsfn;
    }
    else
    {
        if( ddsd.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            ccsfn    = pdrv_lcl->lpDDCB->HALDDExeBuf.CanCreateExecuteBuffer;
    	    ccshalfn = pdrv_lcl->lpDDCB->cbDDExeBufCallbacks.CanCreateExecuteBuffer;
        }
        else
        {
            ccsfn    = pdrv_lcl->lpDDCB->HALDD.CanCreateSurface;
    	    ccshalfn = pdrv_lcl->lpDDCB->cbDDCallbacks.CanCreateSurface;
        }
    }

    if( ccshalfn != NULL )
    {
	BOOL    is_diff;
	HRESULT rc;

	if( ddsd.dwFlags & DDSD_PIXELFORMAT )
	{
	    is_diff = IsDifferentPixelFormat( &pdrv->vmiData.ddpfDisplay, &ddsd.ddpfPixelFormat );
	}
	else
	{
	    is_diff = FALSE;
	}
    	ccsd.CanCreateSurface        = ccshalfn;
	ccsd.lpDD                    = pdrv;
	ccsd.lpDDSurfaceDesc         = (LPDDSURFACEDESC)&ddsd;
	ccsd.bIsDifferentPixelFormat = is_diff;
        if( ddsd.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
	    DOHALCALL( CanCreateExecuteBuffer, ccsfn, ccsd, rc, emulation );
        }
        else
        {
	    DOHALCALL( CanCreateSurface, ccsfn, ccsd, rc, emulation );
        }
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( ccsd.ddRVal != DD_OK )
	    {
		DPF_ERR( "Driver says surface can't be created" );
		LEAVE_DDRAW();
		return ccsd.ddRVal;
	    }
	}
    }

    /*
     * Stash away the surface settings to we can put them back if anything
     * foes wrong.
     *
     * NOTE: We don't store away the heap or vid mem pointer if an error happens
     * after this point the surface ends up lost and will need to be restored.
     */
    wOldWidth  = this->wWidth;
    wOldHeight = this->wHeight;
    lOldPitch  = this->lPitch;
    if( this_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	ddpfOldPixelFormat = this->ddpfSurface;

    /* There could be pending TexBlts and stuff, so Sync with the token stream */
    FlushD3DStates( this_lcl );

    /*
     * The driver has okayed the creation so toast the existing surface memory.
     */
    DestroySurface( this_lcl );

    /*
     *  Remove any cached RLE stuff for source surface
     */
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
    {
	extern void FreeRleData(LPDDRAWI_DDRAWSURFACE_LCL);  //in junction.c

	FreeRleData( this_lcl );
    }

    /*
     * Now mutate the surface into its new form. Kind of spooky isn't it... a bit
     * like The Fly. Stash away the original settings in case we need to put them back
     * if something goes wrong.
     */
    if( lpddsd->dwFlags & DDSD_WIDTH )
	this->wWidth    = (WORD)lpddsd->dwWidth;
    if( lpddsd->dwFlags & DDSD_HEIGHT )
	this->wHeight   = (WORD)lpddsd->dwHeight;
    if( lpddsd->dwFlags & DDSD_PITCH )
	this->lPitch    = lpddsd->lPitch;
    if( lpddsd->dwFlags & DDSD_PIXELFORMAT )
    {
	this->ddpfSurface = lpddsd->ddpfPixelFormat;
	// Now that the pixel format may have changed, we need to reset the pixel-format
	// index that was previously cached by the HEL's AlphaBlt emulation routine.
	this_lcl->lpSurfMore->dwPFIndex = PFINDEX_UNINITIALIZED;
	// ATTENTION:  If pixel format has changed, are old color keys still valid?
    }
    this->lpVidMemHeap  = NULL;
    this->fpVidMem      = (FLATPTR)lpddsd->lpSurface;
#if 0 // DDRAWISURFGBL_DDFREESCLIENTMEM is gone
    this->dwGlobalFlags &= ~(DDRAWISURFGBL_MEMFREE | DDRAWISURFGBL_DDFREESCLIENTMEM);
#else
    this->dwGlobalFlags &= ~(DDRAWISURFGBL_MEMFREE);
#endif // 0
    this->dwGlobalFlags |= DDRAWISURFGBL_ISCLIENTMEM;
    this_lcl->dwFlags   &= ~DDRAWISURF_INVALID;
#if 0 // DDSCAPS2_LOCALALLOC, DDSCAPS2_COTASKMEM and DDRAWISURFGBL_DDFREESCLIENTMEM are gone
    this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~(DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM);

    if( lpddsd->dwFlags & DDSD_CAPS &&
            lpddsd->ddsCaps.dwCaps2 & (DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM) )
    {
	/*
	 * Remember that DirectDraw will be responsible for freeing the
	 * client-allocated surface memory when it's no longer needed.
	 */
	this->dwGlobalFlags |= DDRAWISURFGBL_DDFREESCLIENTMEM;

	this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 |=
			lpddsd->ddsCaps.dwCaps2 & (DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM);
    }
#endif // 0

    #ifdef USE_ALIAS
    {
	/*
	 * If this is a video memory surface then we need to recompute the alias offset of
	 * the surface for locking purposes.
	 */
	LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

	lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE( this );
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
        {
	    lpGblMore->fpAliasedVidMem = GetAliasedVidMem( pdrv_lcl, this_lcl, this_lcl->lpGbl->fpVidMem );
            // If we succeeded in getting an alias, cache it for future use. Also store the original
            // fpVidMem to compare with before using the cached pointer to make sure the cached value
            // is still valid
            if (lpGblMore->fpAliasedVidMem)
                lpGblMore->fpAliasOfVidMem = this_lcl->lpGbl->fpVidMem;
            else
                lpGblMore->fpAliasOfVidMem = 0;
        }
	else
        {
	    lpGblMore->fpAliasedVidMem = 0UL;
            lpGblMore->fpAliasOfVidMem = 0UL;
        }
    }
    #endif /* USE_ALIAS */

#if 0
    if( lpddsd->dwFlags & DDSD_LPSURFACE )
    {
#endif //0
        /*
         * Set the access counter to zero (which means ddraw has no information on the moment
         * to moment contents of the surface, so the driver should not cache).
         */
        GET_LPDDRAWSURFACE_GBL_MORE(this)->dwContentsStamp = 0;
#if 0
    }
    else
    {
        /*
         * Something probably changed
         */
        BUMP_SURFACE_STAMP(this);
    }
#endif //0

    #ifdef WINNT

    // The DDCreateSurfaceObject call fails when we
    // specify a FOURCC system memory surface with pitch = 0
    // and bits/pixel = 0.  We must ensure these parameters
    // are nonzero for the call.

    if ((this_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
        (this->ddpfSurface.dwFlags & DDPF_FOURCC) &&
        (GetDxtBlkSize(this->ddpfSurface.dwFourCC) != 0))
    {
        LONG blksize;
        WORD dx, dy;

        /*
         * This surface uses a FOURCC format that we understand.
         * Figure out how much memory we allocated for it.
         */
        blksize = GetDxtBlkSize(this->ddpfSurface.dwFourCC);
        DDASSERT(blksize != 0);

        DDASSERT(this->ddpfSurface.dwRGBBitCount == 0);
        DDASSERT(this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE);

        bIsCompressedTexture = TRUE;

        // Save the surface's real width and height so we can restore them.
        realwidth = this->wWidth;
        realheight = this->wHeight;
        realsurfsize = this->dwLinearSize;  // union with lPitch

        // The NT kernel won't let us create this surface unless we lie.
        // We have to make up a width, height, pitch, and pixel size
        // that GDI will accept as valid.
        dx = (WORD)((realwidth  + 3) >> 2);   // number of 4x4 blocks in a row
        dy = (WORD)((realheight + 3) >> 2);   // number of 4x4 blocks in a column

        this->wHeight = dy;                    // lie about height
        this->lPitch = dx*blksize;             // lie about pitch
        this->wWidth = (WORD)this->lPitch;   // lie about width
        this->ddpfSurface.dwRGBBitCount = 8;   // lie about pixel size

        // GDI will reserve lpsurf->wWidth*lpsurf->lPitch bytes of virtual
        // memory for the surface.  This had better be equal to the amount
        // of memory we actually allocated for the surface.  What a pain.
        DDASSERT(this_lcl->lpSurfMore->dwBytesAllocated ==
                                    (DWORD)this->wHeight*this->lPitch);
    }
    else if ((this->ddpfSurface.dwFourCC == MAKEFOURCC('U','Y','V','Y')) ||
             (this->ddpfSurface.dwFourCC == MAKEFOURCC('Y','U','Y','2')))
    {
        // These formats are really 8bpp; so we need to adjust
        // the bits-per-pixel parameter to make NT happy
        this->ddpfSurface.dwRGBBitCount = 16;
    }

    /*
     * We deleted the surface object above, so we must create a new
     * surface object before we return.  
     */
    if (!DdCreateSurfaceObject(this_lcl, FALSE))
    {
        if(!(DDSCAPS_SYSTEMMEMORY & this_lcl->ddsCaps.dwCaps))
        {
            DPF_ERR("GDI failed to create surface object!");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    if (bIsCompressedTexture)
    {
        // Restore the FOURCC surface's actual width, height, etc.
        this->wWidth = (WORD)realwidth;
        this->wHeight = (WORD)realheight;
        this->dwLinearSize = realsurfsize;
    }

    //(Fix for Manbug 40941)-->
    // The delete also killed any attachments the kernel may have to neighbouring surfaces.
    //If this is a mipmap, then we need to recreate the attachments now, before the CSEx
    //is called.
    //ISSUE: This fix doesn't address:
    //  -cubemaps or other more complex attachments
    //  -How do we guarantee the right linked list order in the kernel? We'll have
    //   to destroy all attachments, then re-attach them again. (The app in question runs
    //   the mipmap chain in the correct order to re-create attachments in the kernel's
    //   linked list in the right order.)

    // let the kernel know about the attachment only if the driver isn't emulated...
    if ( pdrv->hDD )
    {
        LPATTACHLIST		pal;

        // The current surface has been disassociated from the two
        // neighbouring levels. We need to repair two attachments:
        // the next highst level to this level, and then this level
        // to the next lowest level.
        pal = this_lcl->lpAttachList;

        if(pal) //while(pal) might be a better fix
        {
            DdAttachSurface( this_lcl, pal->lpAttached );
        }

        pal = this_lcl->lpAttachListFrom;

        if(pal) //while(pal) might be a better fix
        {
            DdAttachSurface( pal->lpAttached, this_lcl );
        }
    }
    //<--(End fix for Manbug 40941)

#endif //WINNT

    if(this_lcl->lpSurfMore->dwSurfaceHandle != 0)
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl = GetTopLevel(this_lcl);
        HRESULT HRet;
        DDASSERT( pdrv_lcl == lpLcl->lpSurfMore->lpDD_lcl);
        HRet = createsurfaceEx(lpLcl);
        if (DD_OK != HRet)
        {
            LEAVE_DDRAW();
            return HRet;
        }           
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DD_Surface_SetSurfaceDesc */


/*
 * GetNextMipMap
 */
LPDIRECTDRAWSURFACE GetNextMipMap(
    LPDIRECTDRAWSURFACE lpLevel)
{
    DDSCAPS                     ddsCaps;
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;
    LPATTACHLIST		pal;

    if (!lpLevel)
        return NULL;

    lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpLevel)->lpLcl;

    ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
    pal = lpLcl->lpAttachList;
    while( pal != NULL )
    {
        if ( ((pal->lpAttached->ddsCaps.dwCaps) & (DDSCAPS_TEXTURE | DDSCAPS_MIPMAP))
            == (DDSCAPS_TEXTURE | DDSCAPS_MIPMAP) )
        {
            /*
             * Got both the right caps
             */
            return (LPDIRECTDRAWSURFACE) pal->lpIAttached;
        }
        pal = pal->lpLink;
    }
    return NULL;
}

/*
 * LateAllocateSurfaceMem
 *
 * Called by the D3D to allocate memory for a compressed surface.
 * The input lpDDSurface must have certain state:
 * -DDSCAPS_VIDEOMEMORY or DDSCAPS_SYSTEMMEMORY are allowed.
 * -DDSCAPS_OPTIMIZED required.
 * -fpVidMem must be either DDHAL_PLEASEALLOC_BLOCKSIZE, DDHAL_PLEASEALLOC_NOMEMORY or DDHAL_PLEASEALLOC_LINEARSIZE
 *    -If BLOCKSIZE, the blocksizes must be filled,
 *    -If LINEARSIZE, the dwLinearSize must be filled.
 *    -If LINEARSIZE is specified. Only the linear heaps will be traversed.
 */
#undef DPF_MODNAME
#define DPF_MODNAME "LateAllocateSurfaceMem"
HRESULT DDAPI LateAllocateSurfaceMem(LPDIRECTDRAWSURFACE lpDDSurface, DWORD dwAllocationType, DWORD dwWidthOrSize, DWORD dwHeight)
{
    HRESULT                     ddrval;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
    LPDDRAWI_DDRAWSURFACE_LCL   surflist[1];
    LONG			lSurfacePitch;

    DPF(2,A,"ENTERAPI: LateAllocSurfaceMem");

    DDASSERT( lpDDSurface != 0 );
    DDASSERT((dwAllocationType == DDHAL_PLEASEALLOC_BLOCKSIZE) || (dwAllocationType == DDHAL_PLEASEALLOC_LINEARSIZE));

    psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
    psurf_lcl = psurf_int->lpLcl;
    psurf_gbl = psurf_lcl->lpGbl;

    /*
     * If driver has already filled in some memory for the surface then we'll just clean
     * up some state and return
     */
    if (psurf_gbl->fpVidMem)
    {
        DPF(4,V,"Driver has already allocated some space.");
        psurf_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
        psurf_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_LATEALLOCATELINEAR;
        if (dwAllocationType == DDHAL_PLEASEALLOC_LINEARSIZE)
        {
            psurf_gbl->dwGlobalFlags |= DDRAWISURFGBL_LATEALLOCATELINEAR;
        }
        return DD_OK;
    }

    /*
     * If the driver hasn't filled in itself, then we'd better have some sensible
     * input to decide what to do.
     */
    DDASSERT(dwWidthOrSize != 0);
    DDASSERT(dwAllocationType == DDHAL_PLEASEALLOC_LINEARSIZE || dwHeight != 0);

    /*
     * Assert some things that we don't want AllocSurfaceMem to see.
     */
    DDASSERT( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) == 0);
    DDASSERT( (psurf_gbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) == 0);

    if (dwAllocationType == DDHAL_PLEASEALLOC_BLOCKSIZE)
    {
        /*
         * Surface can be allocated in either rectangular or linear heaps.
         * (That's what the FALSE passed to AllocSurfaceMem means)
         */
        psurf_gbl->fpVidMem = (FLATPTR) DDHAL_PLEASEALLOC_BLOCKSIZE;
        psurf_gbl->dwBlockSizeX = dwWidthOrSize;
        psurf_gbl->dwBlockSizeY = dwHeight;
        if (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            surflist[0] = psurf_lcl;
            ddrval = AllocSurfaceMem(psurf_lcl->lpSurfMore->lpDD_lcl, surflist, 1 );
        }
        else
        {
            DWORD dwSurfaceSize;
            DDASSERT(psurf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
            ddrval = DDERR_OUTOFMEMORY;
            psurf_gbl->fpVidMem = (FLATPTR) HELAllocateSurfaceSysMem(
                                                        psurf_lcl,
                                                        psurf_gbl->dwBlockSizeX ,
                                                        psurf_gbl->dwBlockSizeY,
                                                        &dwSurfaceSize,
							&lSurfacePitch );
            /*
             * Clean up overloaded fields
             */
            psurf_gbl->lpRectList = NULL;
            psurf_gbl->lpVidMemHeap = NULL;
        }
        if (psurf_gbl->fpVidMem)
        {
            psurf_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
            ddrval = DD_OK;
        }
        else
        {
            DPF(0,"Out of memory in LateAllocateSurfaceMem");
        }
        return ddrval;
    }
    else if (dwAllocationType == DDHAL_PLEASEALLOC_LINEARSIZE)
    {
        DWORD dwSurfaceConsumption;

        if (0 == dwWidthOrSize)
        {
            /*
             * Bad driver!
             */
            DPF_ERR("Linear size set to 0 for a DDHAL_PLEASEALLOC_LINEARSIZE surface");
            return DDERR_INVALIDPARAMS;
        }
        dwSurfaceConsumption = dwWidthOrSize;
        psurf_gbl->dwGlobalFlags |= DDRAWISURFGBL_LATEALLOCATELINEAR;
        /*
         * Surface can only live in linear heaps.
         * (That's what the TRUE passed to AllocSurfaceMem means)
         */
        if (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            /*
             * Fool around with surface global data so that AllocSurfaceMem
             * will allocate the correct linear size.
             */
            psurf_gbl->dwLinearSize = dwWidthOrSize;
            psurf_gbl->wHeight = 1;
            psurf_gbl->fpVidMem = DDHAL_PLEASEALLOC_LINEARSIZE;
            surflist[0] = psurf_lcl;
            ddrval = AllocSurfaceMem(psurf_lcl->lpSurfMore->lpDD_lcl, surflist, 1 );
        }
        else
        {
            ddrval = DDERR_OUTOFMEMORY;
            DDASSERT(psurf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
            psurf_gbl->fpVidMem = (FLATPTR) HELAllocateSurfaceSysMem(
                                                        psurf_lcl,
                                                        dwWidthOrSize,
                                                        1 ,
                                                        &dwSurfaceConsumption,
							&lSurfacePitch );
            psurf_gbl->dwLinearSize = dwSurfaceConsumption;
            /*
             * Clean up overloaded fields
             */
            psurf_gbl->lpVidMemHeap = NULL;
            psurf_gbl->lpRectList = NULL;
        }
        if (psurf_gbl->fpVidMem)
        {
            psurf_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
            /*
             * The surface's size will be calculated using dwLinearSize
             */
            ddrval = DD_OK;
        }
        else
        {
            /*
             * Failed for some reason.
             */
            psurf_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_LATEALLOCATELINEAR;
            DPF(0,"Out of memory in LateAllocateSurfaceMem");
        }
        return ddrval;
    }
    else
        return DDERR_GENERIC;
}


#undef DPF_MODNAME
#define DPF_MODNAME "Resize"

#ifdef POSTPONED2
/*
 * DD_Surface_Resize
 */
HRESULT DDAPI DD_Surface_Resize(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags,
                DWORD dwWidth,
                DWORD dwHeight)
{
    DWORD	rc;
    LPDDHAL_RESIZE	pfn;
    DDHAL_RESIZEDATA	rszd;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this_gbl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv_gbl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Resize");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface;
        /*
         * Validate surface pointer.
         */
        if (!VALID_DIRECTDRAWSURFACE_PTR(this_int))
	{
    	    DPF_ERR("Invalid surface object");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

	this_lcl = this_int->lpLcl;    // internal local surface object
	this_gbl = this_lcl->lpGbl;    // internal global surface object

	/*
	 * If this surface is in the process of being freed, return immediately.
	 */
	if( this_lcl->dwFlags & DDRAWISURF_ISFREE )
	{
	    DPF(0, "Can't resize surface that's being freed" );
	    LEAVE_DDRAW();
	    return DDERR_GENERIC;
	}

	/*
	 * Avoid trying to resize an optimized surface.
	 */
	if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
	{
	    DPF_ERR( "Can't resize an optimized surface" );
	    LEAVE_DDRAW();
	    return DDERR_ISOPTIMIZEDSURFACE;
	}

	/*
	 * Avoid resizing a primary surface, a texture surface, a surface that is part of a
	 * flipping chain or any other complex surface, or a surface that is currently visible.
	 */
        if (this_lcl->ddsCaps.dwCaps & (DDSCAPS_COMPLEX | DDSCAPS_FLIP | DDSCAPS_VIDEOPORT |
					DDSCAPS_PRIMARYSURFACE | DDSCAPS_PRIMARYSURFACELEFT |
					DDSCAPS_TEXTURE | DDSCAPS_MIPMAP |	// redundant?
					DDSCAPS_EXECUTEBUFFER | DDSCAPS_VISIBLE))
        {
    	    DPF_ERR("Can't resize visible surface, texture surface, complex surface, or execute buffer");
            LEAVE_DDRAW();
	    return DDERR_INVALIDSURFACETYPE;
	}

	/*
	 * Avoid resizing an attached surface or a surface that has attached surfaces.
	 * (Note: Could have checked DDRAWISURF_ATTACHED and DDRAWISURF_ATTACHED_FROM
	 * bits in this_lcl->dwFlags, but these don't appear to be maintained properly.)
	 */
	if (this_lcl->lpAttachList != NULL || this_lcl->lpAttachListFrom != NULL)
	{
    	    DPF_ERR( "Can't resize surface that is attached or that has attached surfaces" );
            LEAVE_DDRAW();
	    return DDERR_INVALIDSURFACETYPE;
	}

	/*
	 * Avoid resizing a surface to which a D3D device is still attached.
	 */
	if (this_lcl->lpSurfMore->lpD3DDevIList != NULL)
        {
    	    DPF_ERR( "Can't resize a surface that a Direct3D device is still attached to" );
            LEAVE_DDRAW();
	    return DDERR_INVALIDSURFACETYPE;
	}

	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;	// internal local DD object
	pdrv_gbl = pdrv_lcl->lpGbl;			// internal global DD object
	#ifdef WINNT
            // Update DDraw handle in driver GBL object.
    	    pdrv_gbl->hDD = pdrv_lcl->hDD;
	#endif //WINNT

	/*
	 * Wait for driver to finish with any pending DMA operations
	 */
	if( this_gbl->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
	{
	    WaitForDriverToFinishWithSurface(pdrv_lcl, this_lcl);
	}

	/*
	 * Get pointer to driver's HAL callback Resize routine.
	 */
	if (this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
	{
	    /*
	     * Surface resides in video memory.  Use hardware driver callback.
	     */
	    pfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous2.Resize;
	}
	else
	{
	    /*
	     * Surface resides in system memory.  Use HEL emulation routine.
	     */
	    pfn = pdrv_lcl->lpDDCB->HELDDMiscellaneous2.Resize;
	}
	if (pfn == NULL)
	{
	    DPF_ERR("No driver support for Resize");
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR("Exception encountered validating parameters");
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Currently, no flags are defined for the Resize call.
     */
    if (dwFlags)
    {
	DPF_ERR( "dwFlags arg must be zero" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Validate width and height parameters.
     */
    if (dwWidth < 1 || dwHeight < 1)
    {
	DPF_ERR("Invalid surface width or height specified");
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Don't allow implicit surface to be resized.
     */
    if (this_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE)
    {
	DPF_ERR("Can't resize implicitly created surface");
	LEAVE_DDRAW();
	return DDERR_IMPLICITLYCREATED;
    }

    /*
     * Don't allow source surface for visible overlay sprite to be resized.
     */
    if (this_lcl->dwFlags & DDRAWISURF_INMASTERSPRITELIST)
    {
	DPF_ERR("Can't resize source surface for visible overlay sprite");
	LEAVE_DDRAW();
	return DDERR_INVALIDSURFACETYPE;
    }

    /*
     * Don't allow client-allocated surface memory to be resized.
     */
    if (this_gbl->dwGlobalFlags & DDRAWISURFGBL_ISCLIENTMEM)
    {
	DPF_ERR("Can't resize surface with client-allocated memory");
	LEAVE_DDRAW();
	return DDERR_INVALIDSURFACETYPE;
    }

    /*
     * Make sure we are in the same mode the surface was created in.
     */
#ifdef WIN95
    if (pdrv_gbl->dwModeIndex != this_lcl->dwModeCreatedIn)
#else
    if (!EQUAL_DISPLAYMODE(pdrv_gbl->dmiCurrent, this_lcl->lpSurfMore->dmiCreated))
#endif
    {
        DPF_ERR("Not in mode in which surface was created");
        LEAVE_DDRAW();
        return DDERR_WRONGMODE;
    }

    /*
     * Device busy?
     */
    if (*(pdrv_gbl->lpwPDeviceFlags) & BUSY)
    {
	DPF_ERR("Can't resize locked surface");
	LEAVE_DDRAW();
	return DDERR_SURFACEBUSY;
    }

    BUMP_SURFACE_STAMP(this_gbl);

    #ifdef WINNT
    /*
     * Once we delete the surface object, we are committed to
     * creating a new surface object before we return.  This is true
     * regardless of whether we succeed in resizing the surface.
     */
    if (!DdDeleteSurfaceObject(this_lcl))
    {
	/*
	 * Something is terribly wrong with GDI and/or DDraw!
	 */
	DPF_ERR("GDI failed to delete surface object!");
	LEAVE_DDRAW();
	return DDERR_GENERIC;
    }
    #endif //WINNT

    /*
     * Now call the driver to resize the surface for us.
     */
    rszd.lpDD = pdrv_gbl;
    rszd.lpDDSurface = this_lcl;
    rszd.dwFlags = dwFlags;
    rszd.dwWidth = dwWidth;
    rszd.dwHeight = dwHeight;
    rszd.ddRVal = 0;

    // The following definition allows DOHALCALL to be used
    // with thunkless, 32-bit callback.
    #define _DDHAL_Resize  NULL

    DOHALCALL(Resize, pfn, rszd, rc, 0);

    /*
     * If driver callback succeeded, DirectDraw is responsible for
     * updating the surface's width, height, etc.
     */
    if (rszd.ddRVal == DD_OK)
    {
        // Driver should have set these parameters itself:
	DDASSERT(this_gbl->fpVidMem != (FLATPTR)NULL);
	DDASSERT(this_lcl->lpSurfMore->dwBytesAllocated != 0);

	// Update surface parameters.
	this_gbl->wWidth  = (WORD)dwWidth;
	this_gbl->wHeight = (WORD)dwHeight;
        this_lcl->dwFlags &= ~DDRAWISURF_INVALID;
	this_gbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
    }

    #ifdef WINNT
    /*
     * We deleted the surface object above, so we must create a new
     * surface object before we return.  This is true regardless of
     * whether the driver call succeeded in resizing the surface.
     */
    if (!DdCreateSurfaceObject(this_lcl, FALSE))
    {
        if(!(DDSCAPS_SYSTEMMEMORY & this_lcl->ddsCaps.dwCaps))
        {
	    /*
	     * We hope this is rare and pathological condition because we
	     * just destroyed the surface object the client gave us.  Oops.
	     */
	    DPF_ERR("GDI failed to create surface object!");
	    rszd.ddRVal = DDERR_GENERIC;
        }
    }
    #endif //WINNT

    if (rc != DDHAL_DRIVER_HANDLED)
    {
	DPF_ERR("Driver wouldn't handle callback");
	LEAVE_DDRAW();
	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return rszd.ddRVal;

} /* DD_Surface_Resize */
#endif //POSTPONED2

#undef DPF_MODNAME
#define DPF_MODNAME "SetPriority"

HRESULT DDAPI DD_Surface_SetPriority(LPDIRECTDRAWSURFACE7 lpDDSurface, DWORD dwPriority)
{
    HRESULT                     rc;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;

#if DBG
    DPF(2,A,"ENTERAPI: DD_Surface_SetPriority");

    TRY
    {
#endif
	this_int = (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface;
#if DBG
        /*
         * Validate surface pointer.
         */
        if (!VALID_DIRECTDRAWSURFACE_PTR(this_int))
	{
    	    DPF_ERR("Invalid surface object");
	    return DDERR_INVALIDOBJECT;
	}
#endif
	this_lcl = this_int->lpLcl;    // internal local surface object
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;	// internal local DD object
#if DBG
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR("Exception encountered validating parameters");
	return DDERR_INVALIDPARAMS;
    }

    if(!IsToplevel(this_lcl))
    {
        DPF_ERR( "Cannot set priority on a mipmap sublevel or a cubemap subface" );
        return DDERR_INVALIDPARAMS;
    }

    if(this_lcl->lpSurfMore->lpTex == NULL)
    {
        DPF_ERR("SetPriority can only be called on a managed texture");
        return DDERR_INVALIDOBJECT;
    }

    if( pdrv_lcl->pD3DSetPriority == NULL )
    {
        DPF_ERR("D3D is not yet initialized or app didn't use DirectDrawCreateEx");
        return DDERR_D3DNOTINITIALIZED;
    }
#endif
    if(pdrv_lcl->dwLocalFlags & DDRAWILCL_MULTITHREADED)
    {
        ENTER_DDRAW();
        rc = pdrv_lcl->pD3DSetPriority(this_lcl->lpSurfMore->lpTex, dwPriority);
        LEAVE_DDRAW();
    }
    else
    {
        rc = pdrv_lcl->pD3DSetPriority(this_lcl->lpSurfMore->lpTex, dwPriority);
    }

    return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetPriority"

HRESULT DDAPI DD_Surface_GetPriority(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDWORD lpdwPriority)
{
    HRESULT                     rc;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetPriority");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface;
        /*
         * Validate surface pointer.
         */
        if (!VALID_DIRECTDRAWSURFACE_PTR(this_int))
	{
    	    DPF_ERR("Invalid surface object");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

        /*
         * Validate DWORD pointer.
         */
        if (!VALID_DWORD_PTR( lpdwPriority ))
        {
            DPF_ERR("Invalid DWORD pointer");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
        }

	this_lcl = this_int->lpLcl;    // internal local surface object
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;	// internal local DD object
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR("Exception encountered validating parameters");
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    if(!IsToplevel(this_lcl))
    {
        DPF_ERR( "Cannot get priority from a mipmap sublevel or a cubemap subface" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    if(this_lcl->lpSurfMore->lpTex == NULL)
    {
        DPF_ERR("GetPriority can only be called on a managed texture");
        LEAVE_DDRAW();
	return DDERR_INVALIDOBJECT;
    }

    if( pdrv_lcl->pD3DGetPriority == NULL )
    {
        DPF_ERR("D3D is not yet initialized or app didn't use DirectDrawCreateEx");
        LEAVE_DDRAW();
	return DDERR_D3DNOTINITIALIZED;
    }

    rc = pdrv_lcl->pD3DGetPriority(this_lcl->lpSurfMore->lpTex, lpdwPriority);

    LEAVE_DDRAW();

    return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SetLOD"

HRESULT DDAPI DD_Surface_SetLOD(LPDIRECTDRAWSURFACE7 lpDDSurface, DWORD dwLOD)
{
    HRESULT                     rc;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetLOD");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface;
        /*
         * Validate surface pointer.
         */
        if (!VALID_DIRECTDRAWSURFACE_PTR(this_int))
	{
    	    DPF_ERR("Invalid surface object");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

	this_lcl = this_int->lpLcl;    // internal local surface object
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;	// internal local DD object
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR("Exception encountered validating parameters");
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    if(!IsToplevel(this_lcl))
    {
        DPF_ERR( "Cannot set LOD on a mipmap sublevel or a cubemap subface" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    if(this_lcl->lpSurfMore->lpTex == NULL)
    {
        DPF_ERR("SetLOD can only be called on a managed texture");
        LEAVE_DDRAW();
	return DDERR_INVALIDOBJECT;
    }

    if( pdrv_lcl->pD3DSetLOD == NULL )
    {
        DPF_ERR("D3D is not yet initialized or app didn't use DirectDrawCreateEx");
        LEAVE_DDRAW();
	return DDERR_D3DNOTINITIALIZED;
    }

    rc = pdrv_lcl->pD3DSetLOD(this_lcl->lpSurfMore->lpTex, dwLOD);

    LEAVE_DDRAW();

    return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetLOD"

HRESULT DDAPI DD_Surface_GetLOD(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDWORD lpdwLOD)
{
    HRESULT                     rc;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetLOD");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface;
        /*
         * Validate surface pointer.
         */
        if (!VALID_DIRECTDRAWSURFACE_PTR(this_int))
	{
    	    DPF_ERR("Invalid surface object");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

        /*
         * Validate DWORD pointer.
         */
        if (!VALID_DWORD_PTR( lpdwLOD ))
        {
            DPF_ERR("Invalid DWORD pointer");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
        }

	this_lcl = this_int->lpLcl;    // internal local surface object
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;	// internal local DD object
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR("Exception encountered validating parameters");
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    if(!IsToplevel(this_lcl))
    {
        DPF_ERR( "Cannot get LOD from a mipmap sublevel or a cubemap subface" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    if(this_lcl->lpSurfMore->lpTex == NULL)
    {
        DPF_ERR("GetLOD can only be called on a managed texture");
        LEAVE_DDRAW();
	return DDERR_INVALIDOBJECT;
    }

    if( pdrv_lcl->pD3DGetLOD == NULL )
    {
        DPF_ERR("D3D is not yet initialized or app didn't use DirectDrawCreateEx");
        LEAVE_DDRAW();
	return DDERR_D3DNOTINITIALIZED;
    }

    rc = pdrv_lcl->pD3DGetLOD(this_lcl->lpSurfMore->lpTex, lpdwLOD);

    LEAVE_DDRAW();

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddvp.c ===
/*==========================================================================
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddvp.c
 *  Content: 	DirectDrawVideoPort
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   11-jun-96	scottm	created
 *   29-jan-97	smac	Various API changes and bug fixes
 *   31-jan-97  colinmc Bug 5457: Fixed problem with new aliased (no-Win16
 *                      lock) and multiple AMovie clips playing on old cards.
 *   03-mar-97  smac    Added kernel mode interface and fixed some bugs
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
    #include "ddkmmini.h"
    #include "ddkmapi.h"
#else
    #include "ddkmmini.h"
    #include "ddkmapip.h"
#endif
#define DPF_MODNAME "DirectDrawVideoPort"

#define MAX_VP_FORMATS		25
#define MAX_VIDEO_PORTS		10


DDPIXELFORMAT ddpfVPFormats[MAX_VP_FORMATS];
BOOL bInEnumCallback = FALSE;

HRESULT InternalUpdateVideo( LPDDRAWI_DDVIDEOPORT_INT, LPDDVIDEOPORTINFO );
HRESULT InternalStartVideo( LPDDRAWI_DDVIDEOPORT_INT, LPDDVIDEOPORTINFO );
LPDDPIXELFORMAT GetSurfaceFormat( LPDDRAWI_DDRAWSURFACE_LCL );
HRESULT CreateVideoPortNotify( LPDDRAWI_DDVIDEOPORT_INT, LPDIRECTDRAWVIDEOPORTNOTIFY *lplpVPNotify );


/*
 * This function 1) updates the surfaces in the chain so they know they
 * are no longer receiving video port data and 2) releases any implicitly
 * created kernel handles.
 */
VOID ReleaseVPESurfaces( LPDDRAWI_DDRAWSURFACE_INT surf_int, BOOL bRelease )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;

    DDASSERT( surf_int != NULL );
    surf_first = surf_int;
    do
    {
	if( bRelease &&
	    ( surf_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_IMPLICITHANDLE ) )
	{
	    InternalReleaseKernelSurfaceHandle( surf_int->lpLcl, FALSE );
	    surf_int->lpLcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_IMPLICITHANDLE;
	}
	surf_int->lpLcl->lpSurfMore->lpVideoPort = NULL;
    	surf_int = FindAttachedFlip( surf_int );
    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
}


/*
 * This function 1) updates the surfaces in the chain so they know they
 * are receiving video port data and 2) implicitly creates kernel handles
 * for each surface if one does not already exist so ring 0 can perform
 * software autoflipping or software bobbing.
 */
DWORD PrepareVPESurfaces( LPDDRAWI_DDRAWSURFACE_INT surf_int,
	LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, BOOL bAutoflipping )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    LPDDRAWI_DDRAWSURFACE_INT surf_first;
    ULONG_PTR dwHandle;
    DWORD ddRVal;

    DDASSERT( surf_int != NULL );
    surf_first = surf_int;
    do
    {
	/*
	 * Create a kernel handle if one doesn't already exist
	 */
	if( bAutoflipping )
	{
	    surf_int->lpLcl->lpSurfMore->lpVideoPort = lpVideoPort;
	}
    	lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( surf_int->lpLcl->lpGbl );
	if( ( lpSurfGblMore->hKernelSurface == 0 ) &&
	    !( lpVideoPort->dwFlags & DDRAWIVPORT_NOKERNELHANDLES ) )
	{
	    ddRVal = InternalCreateKernelSurfaceHandle( surf_int->lpLcl, &dwHandle );
	    if( ddRVal == DD_OK )
	    {
		surf_int->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_IMPLICITHANDLE;
	    }
	    else
	    {
		/*
		 * This is not a catastrophic failure, but it will stop us
		 * from software autoflipping.
		 */
		lpVideoPort->dwFlags |= DDRAWIVPORT_NOKERNELHANDLES;
	    }
	}
    	surf_int = FindAttachedFlip( surf_int );
    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );

    if( !bAutoflipping )
    {
	surf_first->lpLcl->lpSurfMore->lpVideoPort = lpVideoPort;
    }

    return DD_OK;
}


/*
 * GetVideoPortFromSurface
 *
 * Returns the video port associated with the surface.  The video
 * port can be anywhere in the surface list.
 */
LPDDRAWI_DDVIDEOPORT_LCL GetVideoPortFromSurface( LPDDRAWI_DDRAWSURFACE_INT surf_int )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;
    LPDDRAWI_DDVIDEOPORT_LCL lpVp;

    /*
     * Is it associated with video port?  If not explicitly, is another
     * surface in the chain explicitly associated?
     */
    lpVp = surf_int->lpLcl->lpSurfMore->lpVideoPort;
    if( lpVp == NULL )
    {
	surf_first = surf_int;
	do
	{
	    surf_int = FindAttachedFlip( surf_int );
	    if( surf_int != NULL )
	    {
	        lpVp = surf_int->lpLcl->lpSurfMore->lpVideoPort;
	    }
	}
	while( ( surf_int != NULL ) && ( lpVp == NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
    }

    return lpVp;
}


/*
 * Determines if the specified overlay surface can support autoflipping
 * Return:  0 = Not valid, 1 = software only, 2 = hardware autoflipping
 */
DWORD IsValidAutoFlipSurface( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int )
{
    LPDDRAWI_DDRAWSURFACE_INT lpFirstSurf;
    LPDDRAWI_DDRAWSURFACE_INT lpSurf;
    LPDDRAWI_DDVIDEOPORT_LCL lpVp;
    BOOL bFound;

    /*
     * Is it associated with video port?
     */
    lpVp = GetVideoPortFromSurface( lpSurface_int );
    if( lpVp == NULL )
    {
	return IVAS_NOAUTOFLIPPING;
    }

    /*
     * Is the video port autoflipping?  If not, then neither can the overlay.
     */
    if( !( lpVp->ddvpInfo.dwVPFlags & DDVP_AUTOFLIP ) )
    {
	return IVAS_NOAUTOFLIPPING;
    }

    /*
     * It's still possible that VBI is autoflipping, but not the regular
     * video (which applies to the overlay).
     */
    if( lpVp->dwNumAutoflip == 0 )
    {
	return IVAS_NOAUTOFLIPPING;
    }
    lpSurf = lpFirstSurf = lpVp->lpSurface;
    bFound = FALSE;
    if( lpFirstSurf != NULL )
    {
        do
        {
            if( lpSurf->lpLcl == lpSurface_int->lpLcl )
            {
                bFound = TRUE;
            }
            lpSurf = FindAttachedFlip( lpSurf );
        }  while( !bFound && ( lpSurf != NULL) && ( lpSurf->lpLcl != lpFirstSurf->lpLcl ) );
    }
    if( !bFound )
    {
	return IVAS_NOAUTOFLIPPING;
    }

    /*
     * If the video port is software autoflipping, then the overlay must
     * as well.
     */
    if( lpVp->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP )
    {
	return IVAS_SOFTWAREAUTOFLIPPING;
    }

    return IVAS_HARDWAREAUTOFLIPPING;
}


/*
 * Notifies the video port that the overlay will only allow software
 * autoflipping
 */
VOID RequireSoftwareAutoflip( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int )
{
    LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort;

    lpVideoPort = GetVideoPortFromSurface( lpSurface_int );
    if( lpVideoPort != NULL )
    {
    	lpVideoPort->dwFlags |= DDRAWIVPORT_SOFTWARE_AUTOFLIP;

	/*
	 * If they are already hardware autoflipping, make them switch
	 * to software.
	 */
	if( lpVideoPort->dwFlags & DDRAWIVPORT_ON )
	{
    	    LPDDRAWI_DDVIDEOPORT_INT lpVp_int;

	    /*
	     * The next function requires a DDVIDEOPORT_INT and all we
	     * have is a DDVIDEOPORT_LCL, so we need to search for it.
	     */
    	    lpVp_int = lpSurface_int->lpLcl->lpSurfMore->lpDD_lcl->lpGbl->dvpList;
    	    while( lpVp_int != NULL )
    	    {
		if( ( lpVp_int->lpLcl == lpVideoPort ) &&
		    !( lpVp_int->dwFlags & DDVPCREATE_NOTIFY ) )
		{
	    	    InternalUpdateVideo( lpVp_int,
	    		&( lpVp_int->lpLcl->ddvpInfo) );
		}
		lpVp_int = lpVp_int->lpLink;
	    }
	}
    }
}


/*
 * Determines if the overlay must be bobbed using software or whether
 * it should try software.
 */
BOOL MustSoftwareBob( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int )
{
    LPDDRAWI_DDVIDEOPORT_LCL lpVp;

    /*
     * Is it associated with video port?
     */
    lpVp = GetVideoPortFromSurface( lpSurface_int );
    if( lpVp == NULL )
    {
	return TRUE;
    }

    /*
     * If the video port is software autoflipping or software bobbing,
     * then the overlay must as well.
     */
    if( ( lpVp->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP ) ||
	( lpVp->dwFlags & DDRAWIVPORT_SOFTWARE_BOB ) )
    {
	return TRUE;
    }

    return FALSE;
}


/*
 * Notifies the video port that the overlay will only allow software
 * bobbing
 */
VOID RequireSoftwareBob( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int )
{
    LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort;

    lpVideoPort = GetVideoPortFromSurface( lpSurface_int );
    if( lpVideoPort != NULL )
    {
    	lpVideoPort->dwFlags |= DDRAWIVPORT_SOFTWARE_BOB;

	/*
	 * If they are already hardware autoflipping, make them switch
	 * to software.
	 */
	if( ( lpVideoPort->dwFlags & DDRAWIVPORT_ON ) &&
	    ( lpVideoPort->dwNumAutoflip > 0 ) &&
	    !( lpVideoPort->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP ) )
	{
    	    LPDDRAWI_DDVIDEOPORT_INT lpVp_int;

	    /*
	     * The next function requires a DDVIDEOPORT_INT and all we
	     * have is a DDVIDEOPORT_LCL, so we need to search for it.
	     */
    	    lpVp_int = lpSurface_int->lpLcl->lpSurfMore->lpDD_lcl->lpGbl->dvpList;
    	    while( lpVp_int != NULL )
    	    {
		if( ( lpVp_int->lpLcl == lpVideoPort ) &&
		    !( lpVp_int->dwFlags & DDVPCREATE_NOTIFY ) )
		{
	    	    InternalUpdateVideo( lpVp_int,
	    		&( lpVp_int->lpLcl->ddvpInfo) );
		}
		lpVp_int = lpVp_int->lpLink;
	    }
	}
    }
}


#ifdef WIN95
/*
 * OverrideOverlay
 *
 * Checks to see if there is a chance that the kernel mode interface
 * has changed the state from bob to weave or visa versa, or if it's
 * cahnged from hardware autoflipping to software autoflipping.  If the
 * chance exists, it calls down to ring 0 to get the state and if
 * it's changed, changes the overlay parameters accordingly.
 */
VOID OverrideOverlay( LPDDRAWI_DDRAWSURFACE_INT surf_int,
		      LPDWORD lpdwFlags )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    LPDDRAWI_DDRAWSURFACE_MORE lpSurfMore;
    LPDDRAWI_DDVIDEOPORT_LCL lpVp;
    DWORD dwStateFlags;

    /*
     * Ring 0 can change the state, so we need to call down to it.
     */
    lpSurfMore = surf_int->lpLcl->lpSurfMore;
    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( surf_int->lpLcl->lpGbl );
    if( lpSurfGblMore->hKernelSurface != 0 )
    {
	dwStateFlags = 0;
	GetKernelSurfaceState( surf_int->lpLcl, &dwStateFlags );
	if( dwStateFlags & DDSTATE_EXPLICITLY_SET )
	{
	    if( ( dwStateFlags & DDSTATE_BOB ) &&
		!( *lpdwFlags & DDOVER_BOB ) )
	    {
		// Switch from weave to bob
	    	*lpdwFlags |= DDOVER_BOB;
	    }
	    else if( ( dwStateFlags & DDSTATE_WEAVE ) &&
		( *lpdwFlags & DDOVER_BOB ) )
	    {
		// Switch from bob to weave
	    	*lpdwFlags &= ~DDOVER_BOB;
	    }
            else if( ( dwStateFlags & DDSTATE_SKIPEVENFIELDS ) &&
		( *lpdwFlags & DDOVER_BOB ) )
	    {
		// Switch from bob to weave
	    	*lpdwFlags &= ~DDOVER_BOB;
	    }
	}

	lpVp = GetVideoPortFromSurface( surf_int );
	if( ( dwStateFlags & DDSTATE_SOFTWARE_AUTOFLIP ) &&
	    ( lpVp != NULL ) &&
	    ( lpVp->ddvpInfo.dwVPFlags & DDVP_AUTOFLIP ) &&
	    !( lpVp->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP ) )
	{
	    RequireSoftwareAutoflip( surf_int );
	}
    }
}


/*
 * OverrideVideoPort
 *
 * Checks to see if there is a chance that the kernel mode interface
 * has changed the state from bob/weave to field skipping or visa versa.
 * If the chance exists, it calls down to ring 0 to get the state and if
 * it's changed, changes the overlay parameters accordingly.
 */
VOID OverrideVideoPort( LPDDRAWI_DDRAWSURFACE_INT surf_int,
		      LPDWORD lpdwFlags )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    LPDDRAWI_DDRAWSURFACE_MORE lpSurfMore;
    DWORD dwStateFlags;

    /*
     * Ring 0 can change the state, so we need to call down to it.
     */
    lpSurfMore = surf_int->lpLcl->lpSurfMore;
    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( surf_int->lpLcl->lpGbl );
    if( lpSurfGblMore->hKernelSurface != 0 )
    {
	dwStateFlags = 0;
	GetKernelSurfaceState( surf_int->lpLcl, &dwStateFlags );
	if( dwStateFlags & DDSTATE_EXPLICITLY_SET )
	{
            if( ( dwStateFlags & DDSTATE_SKIPEVENFIELDS ) &&
                !( *lpdwFlags & DDVP_SKIPODDFIELDS ) )
	    {
		// Switch from bob to weave
                *lpdwFlags &= ~DDVP_INTERLEAVE;
                *lpdwFlags |= DDVP_SKIPEVENFIELDS;
	    }
	}
    }
}
#endif


/*
 * UpdateInterleavedFlags
 *
 * We want to track whether the surface data came from a vidoe port or not
 * and if it did, was it interleaved.  This is important so we can
 * automatically set the DDOVER_INTERLEAVED flag while using the video port.
 */
VOID UpdateInterleavedFlags( LPDDRAWI_DDVIDEOPORT_LCL this_lcl, DWORD dwVPFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;
    LPDDRAWI_DDRAWSURFACE_INT surf_temp;

    /*
     * Since the interleaved flag is only used for calling UpdateOverlay,
     * we only need to handle this for the regular video.
     */
    surf_temp = this_lcl->lpSurface;
    if( surf_temp == NULL )
    {
	return;
    }

    /*
     * If autoflipping, update every surface in the chain.
     */
    if( ( dwVPFlags & DDVP_AUTOFLIP ) && ( this_lcl->dwNumAutoflip > 0 ) )
    {
	surf_first = surf_temp;
	do
	{
	    surf_temp->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_VPORTDATA;
	    if( dwVPFlags & DDVP_INTERLEAVE )
	    {
	    	surf_temp->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_VPORTINTERLEAVED;
	    }
	    else
	    {
	    	surf_temp->lpLcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_VPORTINTERLEAVED;
	    }
    	    surf_temp = FindAttachedFlip( surf_temp );
    	} while( ( surf_temp != NULL ) && ( surf_temp->lpLcl != surf_first->lpLcl ) );
    }
    else
    {
	surf_temp->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_VPORTDATA;
	if( dwVPFlags & DDVP_INTERLEAVE )
	{
	    surf_temp->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_VPORTINTERLEAVED;
	}
	else
	{
	    surf_temp->lpLcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_VPORTINTERLEAVED;
	}
    }
}


/*
 * InternalVideoPortFlip
 *
 * This fucntion acts differntly based on whether the flip is occurring
 * based on an overlay flip or whether an explicit flip was specified.
 */
HRESULT InternalVideoPortFlip( LPDDRAWI_DDVIDEOPORT_LCL this_lcl,
			       LPDDRAWI_DDRAWSURFACE_INT next_int,
			       BOOL bExplicit )
{
    LPDDRAWI_DDRAWSURFACE_LCL	next_lcl;
    LPDDHALVPORTCB_FLIP 	pfn;
    DDHAL_FLIPVPORTDATA		FlipData;
    DWORD rc;

    /*
     * surfaces must be in video memory
     */
    next_lcl = next_int->lpLcl;
    if( next_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
	if ( !( this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID].dwCaps &
	    DDVPCAPS_SYSTEMMEMORY ) )
    	{
	    DPF_ERR( "Surface must be in video memory" );
	    return DDERR_INVALIDPARAMS;
    	}
    	if( next_lcl->lpSurfMore->dwPageLockCount == 0 )
    	{
	    DPF_ERR( "Surface must be page locked" );
	    return DDERR_INVALIDPARAMS;
    	}
    }

    /*
     * surfaces must have the VIDEOPORT attribute
     */
    if( !( next_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT ) )
    {
	DPF_ERR( "Surface must have the DDSCAPS_VIDEOPORT attribute" );
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Tell the HAL to perform the flip
     */
    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.FlipVideoPort;
    if( pfn != NULL )
    {
    	FlipData.lpDD = this_lcl->lpDD;
    	FlipData.lpVideoPort = this_lcl;
    	FlipData.lpSurfCurr = this_lcl->lpSurface->lpLcl;
    	FlipData.lpSurfTarg = next_lcl;

	DOHALCALL( FlipVideoPort, pfn, FlipData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != FlipData.ddRVal )
	{
	    return FlipData.ddRVal;
	}
    }
    else
    {
	return DDERR_UNSUPPORTED;
    }

    /*
     * Update the surfaces so they know which one is connected to the
     * video port.
     */
    if( bExplicit )
    {
    	if( this_lcl->lpSurface != NULL )
    	{
    	    this_lcl->lpSurface->lpLcl->lpSurfMore->lpVideoPort = NULL;
    	}
    	next_int->lpLcl->lpSurfMore->lpVideoPort = this_lcl;

    	this_lcl->lpSurface = next_int;
    }
    UpdateInterleavedFlags( this_lcl, this_lcl->ddvpInfo.dwVPFlags );
    this_lcl->fpLastFlip = next_int->lpLcl->lpGbl->fpVidMem;

    return DD_OK;
}

/*
 * FlipVideoPortToN
 *
 * This flips the video port to the next N surface.  If N is 1, it flips it
 * to the next surface, etc.
 */
HRESULT FlipVideoPortToN( LPDDRAWI_DDVIDEOPORT_LCL this_lcl, DWORD dwSkipNum )
{
    LPDDRAWI_DDRAWSURFACE_INT	surf_int;
    DWORD i;

    /*
     * Get the target surface.  We can eliminate a lot of error checking
     * since this function is called from DD_Surface_Flip which already
     * performs the same error checking.
     */
    surf_int = this_lcl->lpSurface;
    for( i = 0; i < dwSkipNum; i++ )
    {
    	surf_int = FindAttachedFlip( surf_int );
    }

    if (surf_int == NULL)
    {
        // Better to do this instead of faulting.
        DPF_ERR("Couldn't find Nth flipping surface.");
        return DDERR_INVALIDPARAMS;
    }

    return InternalVideoPortFlip( this_lcl, surf_int, 0 );
}

/*
 * FlipVideoPortSurface
 *
 * Called when flipping a surface that is fed by a video port.  This searches
 * for each videoport associated with the surface and flips the video port.
 */
DWORD FlipVideoPortSurface( LPDDRAWI_DDRAWSURFACE_INT surf_int, DWORD dwNumSkipped )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;
    LPDDRAWI_DIRECTDRAW_GBL lpDD_Gbl;
    LPDDRAWI_DDVIDEOPORT_INT lpVp;
    LPDDRAWI_DDRAWSURFACE_INT lpSurface;
    BOOL bFound;
    DWORD rc;

    lpDD_Gbl = surf_int->lpLcl->lpSurfMore->lpDD_lcl->lpGbl;
    lpVp = lpDD_Gbl->dvpList;
    while( lpVp != NULL )
    {
    	bFound = FALSE;
	if( ( lpVp->lpLcl->lpSurface != NULL ) &&
	    !( lpVp->lpLcl->ddvpInfo.dwVPFlags & DDVP_AUTOFLIP ) &&
            !( lpVp->dwFlags & DDVPCREATE_NOTIFY ) )
	{
    	    surf_first = lpSurface = lpVp->lpLcl->lpSurface;
    	    do
    	    {
		if( lpSurface == surf_int )
	    	{
		    rc = FlipVideoPortToN( lpVp->lpLcl, dwNumSkipped );
		    bFound = TRUE;
	    	}
    		lpSurface = FindAttachedFlip( lpSurface );
    	    } while( ( lpSurface != NULL ) && ( lpSurface->lpLcl != surf_first->lpLcl ) );
	}
	lpVp = lpVp->lpLink;
    }
    return DD_OK;
}


/*
 * IndepenantVBIPossible
 *
 * Returns TRUE if the specified caps determine it is possible to manage the
 * VBI stream completely independant of the video stream.
 */
BOOL IndependantVBIPossible( LPDDVIDEOPORTCAPS lpCaps )
{
    if( ( lpCaps->dwCaps & ( DDVPCAPS_VBISURFACE|DDVPCAPS_OVERSAMPLEDVBI ) ) !=
	( DDVPCAPS_VBISURFACE | DDVPCAPS_OVERSAMPLEDVBI ) )
    {
	return FALSE;
    }
    if( ( lpCaps->dwFX & ( DDVPFX_VBINOSCALE | DDVPFX_IGNOREVBIXCROP |
	DDVPFX_VBINOINTERLEAVE ) ) != ( DDVPFX_VBINOSCALE |
	DDVPFX_IGNOREVBIXCROP | DDVPFX_VBINOINTERLEAVE ) )
    {
	return FALSE;
    }
    return TRUE;
}


/*
 * DDVPC_EnumVideoPorts
 */
HRESULT DDAPI DDVPC_EnumVideoPorts(
        LPDDVIDEOPORTCONTAINER lpDVP,
	DWORD dwReserved,
        LPDDVIDEOPORTCAPS lpCaps,
	LPVOID lpContext,
        LPDDENUMVIDEOCALLBACK lpEnumCallback )
{
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_LCL	this_lcl;
    LPDDVIDEOPORTCAPS		lpHALCaps;
    DWORD			rc;
    DWORD			dwMaxVideoPorts;
    DWORD			flags;
    DWORD			i;
    BOOL			bEnumThisOne;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDVPC_EnumVideoPorts");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * validate parameters
     */
    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDVP;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid video port container specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
	{
	    DPF_ERR( "Invalid callback routine" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( NULL == lpCaps )
	{
	    /*
	     * If a NULL description is defined, we will assume that they
	     * want to enum everything.
	     */
	    flags = 0;
	}
	else
	{
	    if( !VALID_DDVIDEOPORTCAPS_PTR( lpCaps ) )
	    {
	        DPF_ERR( "Invalid DDVIDEOPORTCAPS specified" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }

	    flags = lpCaps->dwFlags;

	    /*
	     * check height/width
	     */
	    if( ((flags & DDVPD_HEIGHT) && !(flags & DDVPD_WIDTH)) ||
		(!(flags & DDVPD_HEIGHT) && (flags & DDVPD_WIDTH)) )
	    {
		DPF_ERR( "Specify both height & width in video port desc" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }

    	    if( lpCaps->dwVideoPortID >= this_lcl->lpGbl->ddCaps.dwMaxVideoPorts )
    	    {
	        DPF_ERR( "Invalid video port ID specified" );
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
	}
    	if( NULL == this_lcl->lpGbl->lpDDVideoPortCaps )
	{
	    DPF_ERR( "Driver failed query for video port caps" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
	for( i = 0; i < this_lcl->lpGbl->ddCaps.dwMaxVideoPorts; i++ )
	{
    	    lpHALCaps = &(this_lcl->lpGbl->lpDDVideoPortCaps[i]);
    	    if( !VALID_DDVIDEOPORTCAPS_PTR( lpHALCaps ) )
    	    {
	        DPF_ERR( "Driver returned invalid DDVIDEOPORTCAPS" );
	    	LEAVE_DDRAW();
	    	return DDERR_UNSUPPORTED;
    	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Look at each video port and match it with the input description.
     */
    dwMaxVideoPorts = this_lcl->lpGbl->ddCaps.dwMaxVideoPorts;
    lpHALCaps = this_lcl->lpGbl->lpDDVideoPortCaps;
    for (i = 0; i < dwMaxVideoPorts; i++)
    {
	bEnumThisOne = TRUE;

	if( flags & DDVPD_WIDTH )
	{
	    if( lpCaps->dwMaxWidth > lpHALCaps->dwMaxWidth )
		bEnumThisOne = FALSE;
	}
	if( flags & DDVPD_HEIGHT )
	{
	    if( lpCaps->dwMaxHeight > lpHALCaps->dwMaxHeight )
		bEnumThisOne = FALSE;
	}
	if( flags & DDVPD_ID )
	{
	    if( lpCaps->dwVideoPortID != lpHALCaps->dwVideoPortID )
		bEnumThisOne = FALSE;
	}
	if( flags & DDVPD_CAPS )
	{
	    /*
	     * Simple check to make sure no caps were specified that are
	     * not returned by the HAL.
	     */
	    if ( (lpCaps->dwCaps & lpHALCaps->dwCaps) != lpCaps->dwCaps )
		bEnumThisOne = FALSE;
	}
	if( flags & DDVPD_FX )
	{
	    /*
	     * Simple check to make sure no FX were specified that are
	     * not returned by the HAL.
	     */
	    if ( (lpCaps->dwFX & lpHALCaps->dwFX) != lpCaps->dwFX )
		bEnumThisOne = FALSE;
	}

	if ( TRUE == bEnumThisOne )
	{
	    /*
	     * Don't trust the drivers to set this bit correctly (especially
	     * since we are adding it so late)
	     */
	    if( IndependantVBIPossible( lpHALCaps ) )
	    {
		lpHALCaps->dwCaps |= DDVPCAPS_VBIANDVIDEOINDEPENDENT;
	    }
	    else
	    {
		lpHALCaps->dwCaps &= ~DDVPCAPS_VBIANDVIDEOINDEPENDENT;
	    }

            /*
             * We added the dwNumPrefferedAutoflip for Memphis, so some
             * old drivers might not report this correctly.  For that reason,
             * we will attempt to fill in a valid value.
             */
            if( !( lpHALCaps->dwFlags & DDVPD_PREFERREDAUTOFLIP ) )
            {
                /*
                 * The driver did not set this, so we should force the
                 * value to 3.
                 */
                lpHALCaps->dwNumPreferredAutoflip = 3;
                lpHALCaps->dwFlags |= DDVPD_PREFERREDAUTOFLIP;
            }
            if( lpHALCaps->dwNumPreferredAutoflip > lpHALCaps->dwNumAutoFlipSurfaces )
            {
                lpHALCaps->dwNumPreferredAutoflip = lpHALCaps->dwNumAutoFlipSurfaces;
            }

	    bInEnumCallback = TRUE;
    	    rc = lpEnumCallback( lpHALCaps, lpContext );
	    bInEnumCallback = FALSE;
	    if( rc == 0 )
    	    {
    	        break;
    	    }
	}
	lpHALCaps++;
    }
    LEAVE_DDRAW();

    return DD_OK;

} /* DDVPC_EnumVideoPorts */


/*
 * DDVPC_GetVideoPortConnectInfo
 */
HRESULT DDAPI DDVPC_GetVideoPortConnectInfo(
        LPDDVIDEOPORTCONTAINER lpDVP,
        DWORD dwVideoPortID,
        LPDWORD lpdwNumEntries,
	LPDDVIDEOPORTCONNECT lpConnect )
{
    LPDDHALVPORTCB_GETVPORTCONNECT pfn;
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDVIDEOPORTCONNECT lpTemp;
    DDHAL_GETVPORTCONNECTDATA GetGuidData;
    DWORD rc;
    DWORD i;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDVPC_GetVideoPortConnectInfo");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDVP;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
            DPF_ERR ( "DDVPC_GetVideoPortConnectInfo: Invalid DirectDraw ptr");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	#ifdef WINNT
    	    // Update DDraw handle in driver GBL object.
	    this_lcl->lpGbl->hDD = this_lcl->hDD;
	#endif

    	if( dwVideoPortID >= this_lcl->lpGbl->ddCaps.dwMaxVideoPorts )
    	{
            DPF_ERR ( "DDVPC_GetVideoPortConnectInfo: invalid port ID");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( (lpdwNumEntries == NULL) || !VALID_BYTE_ARRAY( lpdwNumEntries, sizeof( LPVOID ) ) )
    	{
            DPF_ERR ( "DDVPC_GetVideoPortConnectInfo: numentries not valid");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( NULL != lpConnect )
    	{
	    if( 0 == *lpdwNumEntries )
    	    {
                DPF_ERR ( "DDVPC_GetVideoPortConnectInfo: numentries not valid");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	    if( !VALID_BYTE_ARRAY( lpConnect, *lpdwNumEntries * sizeof( DDVIDEOPORTCONNECT ) ) )
    	    {
                DPF_ERR ( "DDVPC_GetVideoPortConnectInfo: invalid array passed in");
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
      	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_int->lpLcl->lpDDCB->HALDDVideoPort.GetVideoPortConnectInfo;
    if( pfn != NULL )
    {
	/*
	 * Get the number of GUIDs
	 */
    	GetGuidData.lpDD = this_int->lpLcl;
    	GetGuidData.dwPortId = dwVideoPortID;
    	GetGuidData.lpConnect = NULL;

	DOHALCALL( GetVideoPortConnectInfo, pfn, GetGuidData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return GetGuidData.ddRVal;
	}
	else if( DD_OK != GetGuidData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetGuidData.ddRVal;
	}

	if( NULL == lpConnect )
	{
    	    *lpdwNumEntries = GetGuidData.dwNumEntries;
	}

	else
	{
	    /*
	     * Make sure we have enough room for GUIDs
	     */
	    if( GetGuidData.dwNumEntries > *lpdwNumEntries )
	    {
		lpTemp = (LPDDVIDEOPORTCONNECT) MemAlloc(
		    sizeof( DDVIDEOPORTCONNECT ) * GetGuidData.dwNumEntries );
    	        GetGuidData.lpConnect = lpTemp;
	    }
	    else
	    {
    	    	GetGuidData.lpConnect = lpConnect;
	    }

	    DOHALCALL( GetVideoPortConnectInfo, pfn, GetGuidData, rc, 0 );
	    if( DDHAL_DRIVER_HANDLED != rc )
	    {
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
	    else if( DD_OK != GetGuidData.ddRVal )
	    {
	        LEAVE_DDRAW();
	        return GetGuidData.ddRVal;
	    }

	    /*
	     * Make sure the reserved fields are set to 0
	     */
	    for( i = 0; i < *lpdwNumEntries; i++ )
	    {
		GetGuidData.lpConnect[i].dwReserved1 = 0;
	    }

	    if( GetGuidData.lpConnect != lpConnect )
	    {
		memcpy( lpConnect, lpTemp,
		    sizeof( DDVIDEOPORTCONNECT ) * *lpdwNumEntries );
		MemFree( lpTemp );
    		LEAVE_DDRAW();
		return DDERR_MOREDATA;
	    }
	    else
	    {
		*lpdwNumEntries = GetGuidData.dwNumEntries;
	    }
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DDVPC_GetVideoPortConnectInfo */

/*
 * DDVPC_QueryVideoPortStatus
 */
HRESULT DDAPI DDVPC_QueryVideoPortStatus(
        LPDDVIDEOPORTCONTAINER lpDVP,
        DWORD dwVideoPortID,
	LPDDVIDEOPORTSTATUS lpStatus )
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    LPDDRAWI_DDVIDEOPORT_INT lpVP_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDVPC_QueryVideoPortStatus");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDVP;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	this = this_lcl->lpGbl;
    	if( ( lpStatus == NULL ) || !VALID_DDVIDEOPORTSTATUS_PTR( lpStatus ) )
    	{
            DPF_ERR ( "DDVPC_QueryVideoPortStatus: Invalid DDVIDEOPORTSTATUS ptr");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
	memset( lpStatus, 0, sizeof( DDVIDEOPORTSTATUS ) );
	lpStatus->dwSize = sizeof( DDVIDEOPORTSTATUS );
	if( dwVideoPortID >= this->ddCaps.dwMaxVideoPorts )
	{
            DPF_ERR ( "DDVPC_QueryVideoPortStatus: Invalid Video Port ID specified");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Search the list of video ports to see if anybody's using this one
     */
    lpVP_int = this->dvpList;
    while( lpVP_int != NULL )
    {
	if( ( lpVP_int->lpLcl->ddvpDesc.dwVideoPortID == dwVideoPortID ) &&
            !( lpVP_int->dwFlags & DDVPCREATE_NOTIFY ) )
	{
	     /*
	      * One does exist - return info about it
	      */
	     lpStatus->bInUse = TRUE;
	     memcpy( &(lpStatus->VideoPortType),
		&(lpVP_int->lpLcl->ddvpDesc.VideoPortType),
		sizeof( DDVIDEOPORTCONNECT ) );
	     lpStatus->dwFlags |= lpVP_int->dwFlags;
	}
	lpVP_int = lpVP_int->lpLink;
    }
    if( ( lpStatus->dwFlags & DDVPCREATE_VBIONLY ) &&
	( lpStatus->dwFlags & DDVPCREATE_VIDEOONLY ) )
    {
	lpStatus->dwFlags = 0;
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DDVPC_QueryVideoPortStatus */


/*
 * InsertVideoPortInList
 */
VOID InsertVideoPortInList( LPDDRAWI_DIRECTDRAW_GBL lpGbl, LPDDRAWI_DDVIDEOPORT_INT lpNew )
{
    if( NULL == lpGbl->dvpList )
    {
	lpGbl->dvpList = lpNew;
    }
    else
    {
	LPDDRAWI_DDVIDEOPORT_INT lpTemp;

	lpTemp = lpGbl->dvpList;
	while( NULL != lpTemp->lpLink )
	{
	    lpTemp = lpTemp->lpLink;
	}
	lpTemp->lpLink = lpNew;
    }
}


/*
 * IncrementRefCounts
 *
 * Used to increment the reference count of all surfaces that could
 * receive data from the video port, insuring that a surface isn't released
 * while we are using it.
 */
VOID IncrementRefCounts( LPDDRAWI_DDRAWSURFACE_INT surf_int )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;

    surf_first = surf_int;
    do
    {
    	DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) surf_int );
    	surf_int = FindAttachedFlip( surf_int );
    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
}


/*
 * DecrementRefCounts
 *
 * Used to decrement the reference count of all surfaces that were previously
 * AddRefed because they were using the video port.
 */
VOID DecrementRefCounts( LPDDRAWI_DDRAWSURFACE_INT surf_int )
{
    LPDDRAWI_DDRAWSURFACE_INT *lpSurfList;
    LPDDRAWI_DDRAWSURFACE_INT surf_first;
    DWORD dwCnt;
    DWORD i;

    /*
     * We cannot simply walk the chain, releasing each surface as we go
     * because if the ref cnt goes to zero, the chain goes away and we
     * cannot get to the next surface becasue the current interface is
     * unusable.  For this reason, we cnt how many explicit surfaces are
     * in the chain, allocate a buffer to store all of them, and then
     * release them without walking the chain.
     *
     * We do not release the implicitly created surfaces since 1) DirectDraw
     * ignores this anyway and 2) they are immediately released when
     * releasing their explicit surface, so touching them can be dangerous.
     */
    dwCnt = 0;
    surf_first = surf_int;
    do
    {
    	if( !( surf_int->lpLcl->dwFlags & DDRAWISURF_IMPLICITCREATE ) )
	{
	    dwCnt++;
	}
    	surf_int = FindAttachedFlip( surf_int );
    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
    lpSurfList = (LPDDRAWI_DDRAWSURFACE_INT *) MemAlloc( dwCnt *
    	sizeof( surf_first ) );
    if( lpSurfList == NULL )
    {
	return;
    }

    /*
     * Now put the surfaces in the list
     */
    i = 0;
    surf_int = surf_first;
    do
    {
    	if( !( surf_int->lpLcl->dwFlags & DDRAWISURF_IMPLICITCREATE ) )
	{
	    lpSurfList[i++] = surf_int;
	}
    	surf_int = FindAttachedFlip( surf_int );
    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );

    /*
     * Now release them
     */
    for( i = 0; i < dwCnt; i++ )
    {
    	DD_Surface_Release( (LPDIRECTDRAWSURFACE) lpSurfList[i] );
    }
    MemFree( lpSurfList );
}


/*
 * MergeVPDescriptions
 *
 * This function takes two DDVIDEOPORTDESC structures (one for VBI and one
 * for video) and merges them into a single structure.  If only one is
 * passed, it does a memcpy.
 */
VOID MergeVPDescriptions( LPDDVIDEOPORTDESC lpOutDesc,
    LPDDVIDEOPORTDESC lpInDesc, LPDDRAWI_DDVIDEOPORT_INT lpOtherInt )
{
    memcpy( lpOutDesc, lpInDesc, sizeof( DDVIDEOPORTDESC ) );
    if( lpOtherInt != NULL )
    {
	if( lpOtherInt->dwFlags & DDVPCREATE_VIDEOONLY )
	{
	    lpOutDesc->dwFieldWidth = lpOtherInt->lpLcl->ddvpDesc.dwFieldWidth;
	}
	else
	{
	    lpOutDesc->dwVBIWidth = lpOtherInt->lpLcl->ddvpDesc.dwVBIWidth;
	}
	if( lpOtherInt->lpLcl->ddvpDesc.dwFieldHeight > lpOutDesc->dwFieldHeight )
	{
	    lpOutDesc->dwFieldHeight = lpOtherInt->lpLcl->ddvpDesc.dwFieldHeight;
	}
	if( lpOtherInt->lpLcl->ddvpDesc.dwMicrosecondsPerField >
	    lpOutDesc->dwMicrosecondsPerField )
	{
	    lpOutDesc->dwMicrosecondsPerField =
		lpOtherInt->lpLcl->ddvpDesc.dwMicrosecondsPerField;
	}
	if( lpOtherInt->lpLcl->ddvpDesc.dwMaxPixelsPerSecond >
	    lpOutDesc->dwMaxPixelsPerSecond )
	{
	    lpOutDesc->dwMaxPixelsPerSecond =
		lpOtherInt->lpLcl->ddvpDesc.dwMaxPixelsPerSecond;
	}
    }
}


/*
 * MergeVPInfo
 *
 * This function takes two DDVIDEOPORTINFO structures (one for VBI and one
 * for video) and merges them into a single structure.
 */
HRESULT MergeVPInfo( LPDDRAWI_DDVIDEOPORT_LCL lpVP, LPDDVIDEOPORTINFO lpVBIInfo,
    LPDDVIDEOPORTINFO lpVideoInfo, LPDDVIDEOPORTINFO lpOutInfo )
{
    /*
     * First, handle the case where only one interface is on.  Also, we
     * require that the following be true for VBI/Video-only video ports:
     * 1) They both must set the dwVBIHeight.
     * 2) Neither one can crop the area immediately adjacent to the other.
     */
    if( lpVBIInfo == NULL )
    {
        if( lpVideoInfo->dwVBIHeight == 0 )
	{
	    DPF_ERR( "Video-only video port failed to set dwVBIHeight" );
	    return DDERR_INVALIDPARAMS;
	}
	memcpy( lpOutInfo, lpVideoInfo, sizeof( DDVIDEOPORTINFO ) );

	if( lpVideoInfo->dwVPFlags & DDVP_CROP )
	{
	    if( lpVideoInfo->rCrop.top > (int) lpVideoInfo->dwVBIHeight )
	    {
		DPF_ERR( "rCrop.top > dwVBIHeight on video-only video port" );
		return DDERR_INVALIDPARAMS;
	    }
	    lpOutInfo->rCrop.top = lpVideoInfo->dwVBIHeight;
	}
	else
	{
	    lpOutInfo->dwVPFlags |= DDVP_CROP;
	    lpOutInfo->rCrop.top = lpVideoInfo->dwVBIHeight;
	    lpOutInfo->rCrop.left = 0;
	    lpOutInfo->rCrop.right = lpVP->lpVideoDesc->dwFieldWidth;
	    lpOutInfo->rCrop.bottom = lpVP->lpVideoDesc->dwFieldHeight;
	}
    }
    else if( lpVideoInfo == NULL )
    {
        if( lpVBIInfo->dwVBIHeight == 0 )
	{
	    DPF_ERR( "VBI-only video port failed to set dwVBIHeight" );
	    return DDERR_INVALIDPARAMS;
	}
	memcpy( lpOutInfo, lpVBIInfo, sizeof( DDVIDEOPORTINFO ) );

	if( lpVBIInfo->dwVPFlags & DDVP_CROP )
	{
	    if( lpVBIInfo->rCrop.bottom < (int) lpVBIInfo->dwVBIHeight )
	    {
		DPF_ERR( "rCrop.bottom < dwVBIHeight on VBI-only video port" );
		return DDERR_INVALIDPARAMS;
	    }
	    lpOutInfo->rCrop.bottom = lpVBIInfo->dwVBIHeight;
	}
	else
	{
	    lpOutInfo->dwVPFlags |= DDVP_CROP;
	    lpOutInfo->rCrop.top = 0;
	    lpOutInfo->rCrop.bottom = lpVBIInfo->dwVBIHeight;
	    lpOutInfo->rCrop.left = 0;
	    lpOutInfo->rCrop.right = lpVP->lpVBIDesc->dwVBIWidth;
	}
    }

    /*
     * Now handle the case where both are on and we have to truly merge them.
     */
    else
    {
	memset( lpOutInfo, 0, sizeof( DDVIDEOPORTINFO ) );
	lpOutInfo->dwSize = sizeof( DDVIDEOPORTINFO );
	lpOutInfo->dwOriginX = lpVideoInfo->dwOriginX;
	lpOutInfo->dwOriginY = lpVideoInfo->dwOriginY;
	lpOutInfo->dwVPFlags = lpVideoInfo->dwVPFlags | lpVBIInfo->dwVPFlags;
	lpOutInfo->dwVBIHeight = lpVBIInfo->dwVBIHeight;

	/*
	 * Fix up the cropping.
	 */
	if( lpOutInfo->dwVPFlags & DDVP_CROP )
	{
	    if( ( lpVBIInfo->dwVPFlags & DDVP_CROP ) &&
		( lpVBIInfo->rCrop.bottom < (int) lpVBIInfo->dwVBIHeight ) )
	    {
		DPF_ERR( "rCrop.bottom < dwVBIHeight on VBI-only video port" );
		return DDERR_INVALIDPARAMS;
	    }
	    if( ( lpVideoInfo->dwVPFlags & DDVP_CROP ) &&
		( lpVideoInfo->rCrop.top > (int) lpVideoInfo->dwVBIHeight ) )
	    {
		DPF_ERR( "rCrop.top > dwVBIHeight on video-only video port" );
		return DDERR_INVALIDPARAMS;
	    }
	    lpOutInfo->dwVPFlags |= DDVP_IGNOREVBIXCROP;
	    if( lpVBIInfo->dwVPFlags & DDVP_CROP )
	    {
		lpOutInfo->rCrop.top = lpVBIInfo->rCrop.top;
	    }
	    else
	    {
		lpOutInfo->rCrop.top = 0;
	    }
	    if( lpVideoInfo->dwVPFlags & DDVP_CROP )
	    {
		lpOutInfo->rCrop.bottom = lpVideoInfo->rCrop.bottom;
		lpOutInfo->rCrop.left = lpVideoInfo->rCrop.left;
		lpOutInfo->rCrop.right = lpVideoInfo->rCrop.right;
	    }
	    else
	    {
		lpOutInfo->rCrop.bottom = lpVP->lpVideoDesc->dwFieldHeight;
		lpOutInfo->rCrop.left = 0;
		lpOutInfo->rCrop.right = lpVP->lpVideoDesc->dwFieldWidth;
	    }
	}
	else if( lpVP->ddvpDesc.dwFieldHeight > lpVP->lpVideoDesc->dwFieldHeight )
	{
	    lpOutInfo->dwVPFlags |= DDVP_CROP;
	    lpOutInfo->rCrop.top = 0;
	    lpOutInfo->rCrop.bottom = lpVP->lpVideoDesc->dwFieldHeight;
	    lpOutInfo->rCrop.left = 0;
	    lpOutInfo->rCrop.right = lpVP->lpVideoDesc->dwFieldWidth;
	}

	/*
	 * Handle pre-scaling.  Assume that VBI video ports are not allowed
	 * to prescale.
	 */
	if( lpVBIInfo->dwVPFlags & DDVP_PRESCALE )
	{
	    DPF_ERR( "VBI-only video port set DDVP_PRESCALE" );
	    return DDERR_INVALIDPARAMS;
	}
	else if( lpVideoInfo->dwVPFlags & DDVP_PRESCALE )
	{
	    lpOutInfo->dwPrescaleWidth = lpVideoInfo->dwPrescaleWidth;
	    lpOutInfo->dwPrescaleHeight = lpVideoInfo->dwPrescaleHeight;
	}

	lpOutInfo->lpddpfInputFormat = lpVideoInfo->lpddpfInputFormat;
	lpOutInfo->lpddpfVBIInputFormat = lpVBIInfo->lpddpfVBIInputFormat;
	lpOutInfo->lpddpfVBIOutputFormat = lpVBIInfo->lpddpfVBIOutputFormat;
    }

    return DD_OK;
}


/*
 * DDVPC_CreateVideoPort
 */
HRESULT DDAPI DDVPC_CreateVideoPort(
	LPDDVIDEOPORTCONTAINER lpDVP,
	DWORD dwClientFlags,
        LPDDVIDEOPORTDESC lpDesc,
	LPDIRECTDRAWVIDEOPORT FAR *lplpDDVideoPort,
	IUnknown FAR *pUnkOuter )
{
    DDVIDEOPORTDESC ddTempDesc;
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    LPDDRAWI_DDVIDEOPORT_INT lpVPInt;
    LPDDRAWI_DDVIDEOPORT_INT lpEven;
    LPDDRAWI_DDVIDEOPORT_INT lpOdd;
    LPDDRAWI_DDVIDEOPORT_INT lpOtherInt = NULL;
    LPDDVIDEOPORTCAPS lpAvailCaps;
    LPDDHALVPORTCB_CANCREATEVIDEOPORT ccvppfn;
    LPDDHALVPORTCB_CREATEVIDEOPORT cvppfn;
    LPDDRAWI_DDVIDEOPORT_INT new_int;
    LPDDRAWI_DDVIDEOPORT_LCL new_lcl;
    DWORD dwAvailCaps;
    DWORD dwConnectFlags;
    DWORD rc;


    if( pUnkOuter != NULL )
    {
	return CLASS_E_NOAGGREGATION;
    }
    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDVPC_CreateVideoPort");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDVP;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	this = this_lcl->lpGbl;
	#ifdef WINNT
    	    // Update DDraw handle in driver GBL object.
	    this->hDD = this_lcl->hDD;
	#endif

	if( dwClientFlags & ~( DDVPCREATE_VBIONLY|DDVPCREATE_VIDEOONLY) )
	{
	    DPF_ERR( "Invalid flags specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwClientFlags == ( DDVPCREATE_VBIONLY | DDVPCREATE_VIDEOONLY ) )
	{
	    /*
	     * SPecifying boht flags is the same as specifying neither
	     */
	    dwClientFlags = 0;
	}
    	if( ( NULL == lpDesc ) || !VALID_DDVIDEOPORTDESC_PTR( lpDesc ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}

    	if( ( NULL == lplpDDVideoPort ) || !VALID_PTR_PTR( lplpDDVideoPort ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( NULL == this->lpDDVideoPortCaps )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    	if( lpDesc->dwVideoPortID >= this->ddCaps.dwMaxVideoPorts )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( lpDesc->VideoPortType.dwReserved1 != 0 ) ||
	    ( lpDesc->dwReserved1 != 0 ) ||
	    ( lpDesc->dwReserved2 != 0 ) ||
	    ( lpDesc->dwReserved3 != 0 ) )
	{
	    DPF_ERR( "Reserved field not set to zero" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    	lpAvailCaps = &(this->lpDDVideoPortCaps[lpDesc->dwVideoPortID]);
    	if( !VALID_DDVIDEOPORTCAPS_PTR( lpAvailCaps ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
    	}
	if( ( dwClientFlags & DDVPCREATE_VBIONLY ) &&
	    !IndependantVBIPossible( lpAvailCaps ) )
    	{
	    DPF_ERR( "DDVPCREATE_VBIONLY is not supported" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    if( this_lcl->dwProcessId != GetCurrentProcessId() )
    {
	DPF_ERR( "Process does not have access to object" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Is the requested video port available?
     */
    lpVPInt = this->dvpList;
    lpEven = lpOdd = NULL;
    while( NULL != lpVPInt )
    {
	if( ( lpVPInt->lpLcl->ddvpDesc.dwVideoPortID == lpDesc->dwVideoPortID ) &&
            !( lpVPInt->dwFlags & DDVPCREATE_NOTIFY ) )
	{
	    if( lpVPInt->lpLcl->ddvpDesc.VideoPortType.dwFlags &
	    	DDVPCONNECT_SHAREEVEN )
	    {
		lpEven = lpVPInt;
	    }
	    else if( lpVPInt->lpLcl->ddvpDesc.VideoPortType.dwFlags &
	    	DDVPCONNECT_SHAREODD )
	    {
		lpOdd = lpVPInt;
	    }
	    else if( !dwClientFlags || !(lpVPInt->dwFlags) ||
		( dwClientFlags & lpVPInt->dwFlags ) )
	    {
		lpEven = lpOdd = lpVPInt;
	    }
	    else
	    {
		/*
		 * Video has been opened for VBI/Video only use.  Remember
		 * the other interface because we will need it shortly.
		 */
		lpOtherInt = lpVPInt;
	    }
	}
	lpVPInt = lpVPInt->lpLink;
    }
    if( ( NULL != lpEven ) && ( NULL != lpOdd ) )
    {
	DPF_ERR( "video port already in use" );
	LEAVE_DDRAW();
	return DDERR_OUTOFCAPS;
    }

    /*
     * Get the caps of the specified video port
     */
    dwAvailCaps = lpAvailCaps->dwCaps;
    dwConnectFlags = lpDesc->VideoPortType.dwFlags;
    if( NULL != lpEven )
    {
	dwAvailCaps &= ~( DDVPCAPS_NONINTERLACED |
	    DDVPCAPS_SKIPEVENFIELDS | DDVPCAPS_SKIPODDFIELDS );
    	if( dwConnectFlags & DDVPCONNECT_SHAREEVEN )
	{
	    DPF_ERR( "Even field already used" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDCAPS;
	}
    }
    else if( NULL != lpOdd )
    {
	dwAvailCaps &= ~( DDVPCAPS_NONINTERLACED |
	    DDVPCAPS_SKIPEVENFIELDS | DDVPCAPS_SKIPODDFIELDS );
    	if( dwConnectFlags & DDVPCONNECT_SHAREODD )
	{
	    DPF_ERR( "Odd field already used" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDCAPS;
	}
    }
    else if( dwClientFlags )
    {
	dwAvailCaps &= ~( DDVPCAPS_SKIPEVENFIELDS | DDVPCAPS_SKIPODDFIELDS );
    }

    /*
     * Check for incompatible flags/caps
     */
    if( ( dwConnectFlags & DDVPCONNECT_INTERLACED ) &&
    	!( dwAvailCaps & DDVPCAPS_INTERLACED ) )
    {
	DPF_ERR( "DDVPCONNECT_INTERLACED not supported" );
	LEAVE_DDRAW();
	return DDERR_INVALIDCAPS;
    }
    if( !( dwConnectFlags & DDVPCONNECT_INTERLACED ) &&
    	!( dwAvailCaps & DDVPCAPS_NONINTERLACED ) )
    {
	DPF_ERR( "Non interlaced is not supported" );
	LEAVE_DDRAW();
	return DDERR_INVALIDCAPS;
    }
    if( ( dwConnectFlags &
    	(DDVPCONNECT_SHAREEVEN|DDVPCONNECT_SHAREODD) ) &&
    	!( dwAvailCaps & DDVPCAPS_SHAREABLE ) )
    {
	DPF_ERR( "DDVPCONNECT_SHAREEVEN/SHAREODD not supported" );
	LEAVE_DDRAW();
	return DDERR_INVALIDCAPS;
    }
    if( !( dwConnectFlags & DDVPCONNECT_INTERLACED ) )
    {
	if( dwConnectFlags & ( DDVPCONNECT_SHAREEVEN |
	    DDVPCONNECT_SHAREODD ) )
	{
	    DPF_ERR( "cap invalid with non-interlaced video" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDCAPS;
	}
    }
    if( ( dwConnectFlags & DDVPCONNECT_SHAREEVEN ) &&
    	( dwConnectFlags & DDVPCONNECT_SHAREODD ) )
    {
	DPF_ERR( "shareeven and share odd are mutually exclusive" );
	LEAVE_DDRAW();
	return DDERR_INVALIDCAPS;
    }
    if( ( ( NULL != lpEven ) && !( dwConnectFlags & DDVPCONNECT_SHAREODD ) ) ||
        ( ( NULL != lpOdd ) && !( dwConnectFlags & DDVPCONNECT_SHAREEVEN ) ) )
    {
	DPF_ERR( "specifed video port must be shared" );
	LEAVE_DDRAW();
	return DDERR_INVALIDCAPS;
    }

    if( lpAvailCaps->dwMaxWidth < lpDesc->dwFieldWidth )
    {
	DPF_ERR( "specified width is too large" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    if( lpAvailCaps->dwMaxHeight < lpDesc->dwFieldHeight )
    {
	DPF_ERR( "specified height is too large" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    if( lpDesc->dwMicrosecondsPerField == 0 )
    {
	DPF_ERR( "Microseconds/field not specified" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    if( lpDesc->dwMaxPixelsPerSecond == 0 )
    {
	DPF_ERR( "Max pixels per second not specified" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    if( NULL != lpEven )
    {
    	if( !( ( IsEqualIID( &(lpDesc->VideoPortType.guidTypeID),
		&(lpOdd->lpLcl->ddvpDesc.VideoPortType.guidTypeID) ) ) &&
	    ( lpDesc->VideoPortType.dwPortWidth ==
		lpOdd->lpLcl->ddvpDesc.VideoPortType.dwPortWidth ) &&
	    ( ( lpDesc->VideoPortType.dwFlags & lpOdd->lpLcl->ddvpDesc.VideoPortType.dwFlags )
	        == lpDesc->VideoPortType.dwFlags ) ) )
	{
	    DPF_ERR( "invalid GUID specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    else if( NULL != lpOdd )
    {
    	if( !( ( IsEqualIID( &(lpDesc->VideoPortType.guidTypeID),
		&(lpEven->lpLcl->ddvpDesc.VideoPortType.guidTypeID) ) ) &&
	    ( lpDesc->VideoPortType.dwPortWidth ==
		lpEven->lpLcl->ddvpDesc.VideoPortType.dwPortWidth ) &&
	    ( ( lpDesc->VideoPortType.dwFlags & lpEven->lpLcl->ddvpDesc.VideoPortType.dwFlags )
	        == lpDesc->VideoPortType.dwFlags ) ) )
	{
	    DPF_ERR( "invalid GUID specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    else if( NULL != lpOtherInt )
    {
	/*
	 * Since they are both sharing the exact same connection, fail
	 * unless the connections are identical.
	 */
	if( lpDesc->VideoPortType.dwPortWidth !=
	    lpOtherInt->lpLcl->ddvpDesc.VideoPortType.dwPortWidth )
	{
	    DPF_ERR( "connection info must match other interface" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( lpDesc->VideoPortType.dwFlags !=
	    lpOtherInt->lpLcl->ddvpDesc.VideoPortType.dwFlags )
	{
	    DPF_ERR( "connection info must match other interface" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( !IsEqualIID( &(lpDesc->VideoPortType.guidTypeID),
	    &(lpOtherInt->lpLcl->ddvpDesc.VideoPortType.guidTypeID) ) )
	{
	    DPF_ERR( "connection info must match other interface" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    else
    {
	LPDDVIDEOPORTCONNECT lpConnect;
	DWORD dwNumEntries;
	DWORD i;
	DWORD rc;

	/*
	 * Verify that the connection can be supported.
	 */
	rc = DDVPC_GetVideoPortConnectInfo( lpDVP,
	    lpDesc->dwVideoPortID, &dwNumEntries, NULL );
	if( rc != DD_OK )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	lpConnect = (LPDDVIDEOPORTCONNECT) MemAlloc(
	    sizeof( DDVIDEOPORTCONNECT ) * dwNumEntries );
	if( NULL == lpConnect )
	{
	    LEAVE_DDRAW();
	    return DDERR_OUTOFMEMORY;
	}
	rc = DDVPC_GetVideoPortConnectInfo( lpDVP,
	    lpDesc->dwVideoPortID, &dwNumEntries, lpConnect );
	if( rc != DD_OK )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	for (i = 0; i < dwNumEntries; i++)
	{
    	    if( ( IsEqualIID( &(lpDesc->VideoPortType.guidTypeID),
		    &(lpConnect[i].guidTypeID) ) ) &&
		( lpDesc->VideoPortType.dwPortWidth ==
		    lpConnect[i].dwPortWidth ) )
	    {
		break;
	    }
	}
	MemFree( lpConnect );
	if ( i == dwNumEntries )
	{
	    DPF_ERR( "invalid GUID specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }

    /*
     * Turn merge the description of the multiple interfaces into one.
     */
    MergeVPDescriptions( &ddTempDesc, lpDesc, lpOtherInt );

    /*
     * Things look good so far.  Lets call the HAL and see if they
     * can handle it.
     */
    ccvppfn = this_lcl->lpDDCB->HALDDVideoPort.CanCreateVideoPort;
    if( NULL != ccvppfn )
    {
	DDHAL_CANCREATEVPORTDATA CanCreateData;

    	CanCreateData.lpDD = this_lcl;
    	CanCreateData.lpDDVideoPortDesc = &ddTempDesc;

	DOHALCALL( CanCreateVideoPort, ccvppfn, CanCreateData, rc, 0 );
	if( ( DDHAL_DRIVER_HANDLED == rc ) &&  (DD_OK != CanCreateData.ddRVal ) )
	{
	    LEAVE_DDRAW();
	    return CanCreateData.ddRVal;
	}
    }

    /*
     * Allocate the sucker(s)
     */
    new_int = MemAlloc( sizeof( DDRAWI_DDVIDEOPORT_INT ) );
    if( NULL == new_int )
    {
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }
    new_int->lpVtbl = (LPVOID)&ddVideoPortCallbacks;
    new_int->dwFlags = dwClientFlags;

    if( lpOtherInt != NULL )
    {
	new_lcl = lpOtherInt->lpLcl;
    }
    else
    {
	new_lcl = MemAlloc( sizeof( DDRAWI_DDVIDEOPORT_LCL ) +
	    ( 2 * sizeof( DDPIXELFORMAT ) ) );
	if( NULL == new_lcl )
	{
	    LEAVE_DDRAW();
	    return DDERR_OUTOFMEMORY;
	}
	new_lcl->lpDD = this_lcl;
	new_lcl->lpSurface = NULL;
	new_lcl->lpVBISurface = NULL;
    }
    if( dwClientFlags & DDVPCREATE_VBIONLY )
    {
	new_lcl->dwVBIProcessID = GetCurrentProcessId();
    }
    else
    {
	new_lcl->dwProcessID = GetCurrentProcessId();
    }
    new_int->lpLcl = new_lcl;
    memcpy( &(new_lcl->ddvpDesc), &ddTempDesc, sizeof( DDVIDEOPORTDESC ));

    /*
     * If this is a VBI/VIDEOONLY interface, save the original description
     * for future use.
     */
    if( dwClientFlags & DDVPCREATE_VBIONLY )
    {
	new_lcl->lpVBIDesc = MemAlloc( sizeof( DDVIDEOPORTDESC ) );
	if( NULL == new_lcl->lpVBIDesc )
	{
	    LEAVE_DDRAW();
	    return DDERR_OUTOFMEMORY;
	}
	memcpy( new_lcl->lpVBIDesc, lpDesc, sizeof( DDVIDEOPORTDESC ));
    }
    else if( dwClientFlags & DDVPCREATE_VIDEOONLY )
    {
	new_lcl->lpVideoDesc = MemAlloc( sizeof( DDVIDEOPORTDESC ) );
	if( NULL == new_lcl->lpVideoDesc )
	{
	    LEAVE_DDRAW();
	    return DDERR_OUTOFMEMORY;
	}
	memcpy( new_lcl->lpVideoDesc, lpDesc, sizeof( DDVIDEOPORTDESC ));
    }

    /*
     * Notify the HAL that we created it
     */
    cvppfn = this_lcl->lpDDCB->HALDDVideoPort.CreateVideoPort;
    if( NULL != cvppfn )
    {
	DDHAL_CREATEVPORTDATA CreateData;

    	CreateData.lpDD = this_lcl;
    	CreateData.lpDDVideoPortDesc = &ddTempDesc;
    	CreateData.lpVideoPort = new_lcl;

	DOHALCALL( CreateVideoPort, cvppfn, CreateData, rc, 0 );
	if( ( DDHAL_DRIVER_HANDLED == rc ) &&  (DD_OK != CreateData.ddRVal ) )
	{
	    LEAVE_DDRAW();
	    return CreateData.ddRVal;
	}
    }
    InsertVideoPortInList( this, new_int );

    DD_VP_AddRef( (LPDIRECTDRAWVIDEOPORT )new_int );
    *lplpDDVideoPort = (LPDIRECTDRAWVIDEOPORT) new_int;

    /*
     * Notify  kernel mode of we created the video port
     */
    #ifdef WIN95
        if( lpOtherInt == NULL )
        {
	    UpdateKernelVideoPort( new_lcl, DDKMVP_CREATE );
        }
    #endif

    LEAVE_DDRAW();

    return DD_OK;
} /* DDVPC_CreateVideoPort */


/*
 * DD_VP_AddRef
 */
DWORD DDAPI DD_VP_AddRef( LPDIRECTDRAWVIDEOPORT lpDVP )
{
    LPDDRAWI_DDVIDEOPORT_INT	this_int;
    LPDDRAWI_DDVIDEOPORT_LCL	this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_AddRef");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return 0;
    }

    DPF( 5, "DD_VP_AddRef, pid=%08lx, obj=%08lx", GETCURRPID(), lpDVP );

    TRY
    {
	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * bump refcnt
     */
    this_lcl->dwRefCnt++;
    this_int->dwIntRefCnt++;

    LEAVE_DDRAW();

    return this_int->dwIntRefCnt;

} /* DD_VP_AddRef */


/*
 * DD_VP_QueryInterface
 */
HRESULT DDAPI DD_VP_QueryInterface(LPDIRECTDRAWVIDEOPORT lpDVP, REFIID riid, LPVOID FAR * ppvObj )
{
    LPDDRAWI_DDVIDEOPORT_INT		this_int;
    LPDDRAWI_DDVIDEOPORT_LCL		this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_QueryInterface");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid videoport pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF_ERR( "Invalid videoport interface pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*ppvObj = NULL;
	if( !VALIDEX_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * asking for IUnknown?
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
	IsEqualIID(riid, &IID_IDirectDrawVideoPort) )
    {
	/*
	 * Our IUnknown interface is the same as our V1
	 * interface.  We must always return the V1 interface
	 * if IUnknown is requested.
	 */
    	*ppvObj = (LPVOID) this_int;
	DD_VP_AddRef( *ppvObj );
	LEAVE_DDRAW();
	return DD_OK;
    }
    else if( IsEqualIID(riid, &IID_IDirectDrawVideoPortNotify) )
    {
        HRESULT ret;
        
        ret = CreateVideoPortNotify (this_int, (LPDIRECTDRAWVIDEOPORTNOTIFY*)ppvObj);
	LEAVE_DDRAW();
	return ret;
    }

    DPF_ERR( "IID not understood by DirectDraw" );

    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DD_VP_QueryInterface */


/*
 * DD_VP_Release
 */
DWORD DDAPI DD_VP_Release(LPDIRECTDRAWVIDEOPORT lpDVP )
{
    LPDDRAWI_DDVIDEOPORT_INT	this_int;
    LPDDRAWI_DDVIDEOPORT_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDHALVPORTCB_DESTROYVPORT pfn;
    DWORD 			dwIntRefCnt;
    DWORD			rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_Release");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return 0;
    }

    TRY
    {
	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid videoport pointer" );
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
	pdrv = this_lcl->lpDD->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * decrement the reference count.  if it hits zero, free the surface
     */
    this_lcl->dwRefCnt--;
    this_int->dwIntRefCnt--;

    DPF( 5, "DD_VP_Release, Reference Count: Local = %ld Int = %ld",
         this_lcl->dwRefCnt, this_int->dwIntRefCnt );

    /*
     * interface at zero?
     */
    dwIntRefCnt = this_int->dwIntRefCnt;
    if( dwIntRefCnt == 0 )
    {
	LPDDRAWI_DDVIDEOPORT_INT	curr_int;
	LPDDRAWI_DDVIDEOPORT_INT	last_int;

	/*
	 * remove videoport from list
	 */
	curr_int = pdrv->dvpList;
	last_int = NULL;
	while( curr_int != this_int )
	{
	    last_int = curr_int;
	    curr_int = curr_int->lpLink;
	    if( curr_int == NULL )
	    {
		DPF_ERR( "VideoPort not in list!" );
		LEAVE_DDRAW();
		return 0;
	    }
	}
	if( last_int == NULL )
	{
	    pdrv->dvpList = pdrv->dvpList->lpLink;
	}
	else
	{
	    last_int->lpLink = curr_int->lpLink;
	}

	/*
	 * Decrement the surface reference counts and clean things up
	 */
        if( !( this_int->dwFlags & DDVPCREATE_NOTIFY ) )
        {
	    DD_VP_StopVideo( (LPDIRECTDRAWVIDEOPORT) this_int );
            this_lcl->dwFlags &= ~DDRAWIVPORT_ON;
	    if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	    {
	        if( this_lcl->lpVBISurface != NULL )
	        {
		    DecrementRefCounts( this_lcl->lpVBISurface );
		    this_lcl->lpVBISurface = NULL;
	        }
	        if( this_lcl->lpVBIDesc != NULL )
	        {
		    MemFree( this_lcl->lpVBIDesc );
		    this_lcl->lpVBIDesc = NULL;
	        }
	        if( this_lcl->lpVBIInfo != NULL )
	        {
		    MemFree( this_lcl->lpVBIInfo );
		    this_lcl->lpVBIInfo = NULL;
	        }
	        this_lcl->dwVBIProcessID = 0;
	    }
	    else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
	    {
	        if( this_lcl->lpSurface != NULL )
	        {
		    DecrementRefCounts( this_lcl->lpSurface );
		    this_lcl->lpSurface = NULL;
	        }
	        if( this_lcl->lpVideoDesc != NULL )
	        {
		    MemFree( this_lcl->lpVideoDesc );
		    this_lcl->lpVideoDesc = NULL;
	        }
	        if( this_lcl->lpVideoInfo != NULL )
	        {
		    MemFree( this_lcl->lpVideoInfo );
		    this_lcl->lpVideoInfo = NULL;
	        }
	        this_lcl->dwProcessID = 0;
	    }
	    else
	    {
	        if( this_lcl->lpSurface != NULL )
	        {
		    DecrementRefCounts( this_lcl->lpSurface );
	        }
	        if( this_lcl->lpVBISurface != NULL )
	        {
		    DecrementRefCounts( this_lcl->lpVBISurface );
	        }
	        this_lcl->dwProcessID = 0;
	    }
        }
        else
        {
            this_lcl->lpVPNotify = NULL;
        }

	/*
	 * just in case someone comes back in with this pointer, set
	 * an invalid vtbl & data ptr.
	 */
	this_int->lpVtbl = NULL;
	this_int->lpLcl = NULL;
	MemFree( this_int );
    }

    /*
     * local object at zero?
     */
    if( this_lcl->dwRefCnt == 0 )
    {
	/*
	 * turn off the videoport hardware
	 */
	if( this_lcl->dwFlags & DDRAWIVPORT_ON )
	{
	    DD_VP_StopVideo( lpDVP );
	}
	#ifdef WIN95
    	    UpdateKernelVideoPort( this_lcl, DDKMVP_RELEASE );
	#endif

	/*
	 * Notify the HAL
	 */
    	pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.DestroyVideoPort;
	if( NULL != pfn )
	{
	    DDHAL_DESTROYVPORTDATA DestroyVportData;

	    DestroyVportData.lpDD = this_lcl->lpDD;
	    DestroyVportData.lpVideoPort = this_lcl;

	    DOHALCALL( DestroyVideoPort, pfn, DestroyVportData, rc, 0 );
	    if( ( DDHAL_DRIVER_HANDLED == rc ) && ( DD_OK != DestroyVportData.ddRVal ) )
	    {
	    	LEAVE_DDRAW();
	    	return DestroyVportData.ddRVal;
	    }
    	}
	MemFree( this_lcl->lpFlipInts );
	MemFree( this_lcl );
    }

    LEAVE_DDRAW();

    return dwIntRefCnt;
}

/*
 * DD_VP_SetTargetSurface
 */
HRESULT DDAPI DD_VP_SetTargetSurface(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE lpSurface, DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT surf_int;
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
    LPDDRAWI_DDRAWSURFACE_INT lpTemp;
    LPDDRAWI_DDRAWSURFACE_INT lpPrevious;
    BOOL bWasOn;
    DWORD ddRVal;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_SetTargetSurface");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	surf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpSurface;
    	if( ( NULL == lpSurface ) || !VALID_DIRECTDRAWSURFACE_PTR( surf_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
	surf_lcl = surf_int->lpLcl;

        /*
         * Make sure the surface and video port belong to the same device.
         */
        if (surf_lcl->lpSurfMore->lpDD_lcl->lpGbl != this_lcl->lpDD->lpGbl)
        {
            DPF_ERR("Video port and Surface must belong to the same device");
	    LEAVE_DDRAW();
	    return DDERR_DEVICEDOESNTOWNSURFACE;
        }

	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    if( dwFlags & DDVPTARGET_VIDEO )
	    {
		DPF_ERR( "DDVPTARGET_VIDEO specified on a VBI-only video port" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    dwFlags |= DDVPTARGET_VBI;
	}
	else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
	{
	    if( dwFlags & DDVPTARGET_VBI )
	    {
		DPF_ERR( "DDVPTARGET_VBI specified on a video-only video port" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    dwFlags |= DDVPTARGET_VIDEO;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Surface must have the video port flag set
     */
    if( !( surf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT ) )
    {
	DPF_ERR( "Specified surface doesnt have DDSCAPS_VIDEOPORT set" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Can surface live in system memory?
     */
    if( surf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
    {
	if( !( this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID].dwCaps &
	    DDVPCAPS_SYSTEMMEMORY ) )
	{
	    DPF_ERR( "Video port surface must live in video memory" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    	if( surf_lcl->lpSurfMore->dwPageLockCount == 0 )
    	{
	    DPF_ERR( "Surface must be page locked" );
            LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }

    /*
     * If another surface in the chain is attached to a different video
     * port, fail now.
     */
    surf_first = surf_int;
    do
    {
    	if( ( surf_int->lpLcl->lpSurfMore->lpVideoPort != NULL ) &&
    	    ( surf_int->lpLcl->lpSurfMore->lpVideoPort != this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    	surf_int = FindAttachedFlip( surf_int );
    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
    surf_int = surf_first;

    /*
     * If the video was on, we need to temporarily turn it off.  Otherwise,
     * we could lose our kernel surfaces while they are still in use.
     */
    bWasOn = FALSE;
    if( this_int->dwFlags & DDVPCREATE_VBIONLY )
    {
	if( this_lcl->lpVBIInfo != NULL )
	{
	    bWasOn = TRUE;
	}
    }
    else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
    {
	if( this_lcl->lpVideoInfo != NULL )
	{
	    bWasOn = TRUE;
	}
    }
    else if( this_lcl->dwFlags & DDRAWIVPORT_ON )
    {
	bWasOn = TRUE;
    }
    if( bWasOn )
    {
	DD_VP_StopVideo( lpDVP );
    }

    if( dwFlags & DDVPTARGET_VIDEO )
    {
	/*
	 * Set the new surface
	 */
	lpPrevious = this_lcl->lpSurface;
	lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) this_lcl->lpSurface;
	this_lcl->lpSurface = surf_int;
	IncrementRefCounts( surf_int );
    }
    else if( dwFlags & DDVPTARGET_VBI )
    {
	if( this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID].dwCaps & DDVPCAPS_VBISURFACE )
	{
	    /*
	     * Set the new surface
	     */
	    lpPrevious = this_lcl->lpVBISurface;
	    lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) this_lcl->lpVBISurface;
    	    this_lcl->lpVBISurface = surf_int;
	    IncrementRefCounts( surf_int );
	}
	else
	{
	    DPF_ERR( "device does not support attaching VBI surfaces" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDCAPS;
	}
    }
    else
    {
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * If the video port is already on, we should tell the hardware
     * to make this change.
     */
    if( bWasOn )
    {
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    ddRVal = DD_VP_StartVideo( lpDVP, this_lcl->lpVBIInfo );
	}
	else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
	{
	    ddRVal = DD_VP_StartVideo( lpDVP, this_lcl->lpVideoInfo );
	}
	else
	{
	    ddRVal = DD_VP_StartVideo( lpDVP, &(this_lcl->ddvpInfo) );
	}
	if( ddRVal != DD_OK )
	{
	    // Restore the old surface
	    DD_VP_SetTargetSurface( lpDVP,
		(LPDIRECTDRAWSURFACE) lpTemp, dwFlags );
	    if( lpTemp != NULL )
	    {
		DecrementRefCounts( lpTemp );
	    }
    	    LEAVE_DDRAW();
    	    return ddRVal;
	}
    }

    /*
     * Decrement the ref counts of the previously attached surfaces.  We
     * wait until now so we don't inadvertantly blast data to a surface that
     * has just been released.
     */
    if( lpPrevious != NULL )
    {
	DecrementRefCounts( lpPrevious );
    }

    LEAVE_DDRAW();
    return DD_OK;
}

/*
 * DD_VP_Flip
 */
HRESULT DDAPI DD_VP_Flip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE lpSurface, DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_LCL	surf_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	surf_int;
    LPDDRAWI_DDRAWSURFACE_GBL	surf;
    LPDDRAWI_DDRAWSURFACE_INT	surf_dest_int;
    LPDDRAWI_DDRAWSURFACE_LCL	surf_dest_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDVIDEOPORT_INT	this_int;
    LPDDRAWI_DDVIDEOPORT_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	next_save_int;
    LPDDRAWI_DDRAWSURFACE_INT	next_int;
    BOOL			found_dest;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_Flip");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    TRY
    {
	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;

	if( this_lcl->ddvpInfo.dwVPFlags & DDVP_AUTOFLIP )
	{
	    DPF_ERR( "cannot manually flip while autoflipping is enabled" );
	    LEAVE_DDRAW();
	    return DDERR_NOTFLIPPABLE;
	}

	surf_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpSurface;
	if( NULL != surf_dest_int )
	{
	    if( !VALID_DIRECTDRAWSURFACE_PTR( surf_dest_int ) )
	    {
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDOBJECT;
	    }
	    surf_dest_lcl = surf_dest_int->lpLcl;
	    if( SURFACE_LOST( surf_dest_lcl ) )
	    {
	    	LEAVE_DDRAW();
	    	return DDERR_SURFACELOST;
	    }
	}
	else
	{
	    surf_dest_lcl = NULL;
	}

	if( dwFlags & DDVPFLIP_VBI )
	{
	    surf_int = this_lcl->lpVBISurface;
	}
	else
	{
	    surf_int = this_lcl->lpSurface;
	}
	if( surf_int == NULL )
	{
	    DPF_ERR( "SetTargetSurface not yet called" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	surf_lcl = surf_int->lpLcl;
	if( NULL == surf_lcl )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACENOTATTACHED;
	}
	else if( SURFACE_LOST( surf_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
	surf = surf_lcl->lpGbl;

	/*
	 * device busy?
	 */
	pdrv_lcl = surf_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

	#ifdef USE_ALIAS
	    if( pdrv->dwBusyDueToAliasedLock > 0 )
	    {
		/*
		 * Aliased locks (the ones that don't take the Win16 lock) don't
		 * set the busy bit either (it can't or USER get's very confused).
		 * However, we must prevent blits happening via DirectDraw as
		 * otherwise we get into the old host talking to VRAM while
		 * blitter does at the same time. Bad. So fail if there is an
		 * outstanding aliased lock just as if the BUST bit had been
		 * set.
		 */
		DPF_ERR( "Graphics adapter is busy (due to a DirectDraw lock)" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */

	if( *(pdrv->lpwPDeviceFlags) & BUSY )
	{
            DPF( 0, "BUSY - Flip" );
	    LEAVE_DDRAW()
	    return DDERR_SURFACEBUSY;
	}

	/*
	 * make sure that it's OK to flip this surface
	 */
	if( !(surf_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP) )
	{
	    LEAVE_DDRAW();
	    return DDERR_NOTFLIPPABLE;
	}
	if( surf->dwUsageCount > 0 )
        {
            DPF_ERR( "Can't flip because surface is locked" );
            LEAVE_DDRAW();
            return DDERR_SURFACEBUSY;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * make sure no surfaces are in use
     */
    found_dest = FALSE;
    next_save_int = next_int = FindAttachedFlip( surf_int );
    if( next_int == NULL )
    {
	LEAVE_DDRAW();
	return DDERR_NOTFLIPPABLE;		// ACKACK: real error?
    }

    do
    {
	if( SURFACE_LOST( next_int->lpLcl ) )
	{
	    DPF_ERR( "Can't flip - back buffer is lost" );
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	if( next_int->lpLcl->lpGbl->dwUsageCount != 0 )
	{
	    LEAVE_DDRAW();
            return DDERR_SURFACEBUSY;
	}
        if( surf_dest_int->lpLcl == next_int->lpLcl )
	{
	    found_dest = TRUE;
	}
	next_int = FindAttachedFlip( next_int );
    } while( next_int->lpLcl != surf_lcl );

    /*
     * see if we can use the specified destination
     */
    if( surf_dest_int != NULL )
    {
	if( !found_dest )
	{
	    DPF_ERR( "Destination not part of flipping chain!" );
	    LEAVE_DDRAW();
	    return DDERR_NOTFLIPPABLE;		// ACKACK: real error?
	}
	next_save_int = surf_dest_int;
    }

    /*
     * found the linked surface we want to flip to
     */
    next_int = next_save_int;

    rc = InternalVideoPortFlip( this_lcl, next_int, 1 );

    LEAVE_DDRAW();
    return (HRESULT)rc;
}

/*
 * InternalGetBandwidth
 */
HRESULT InternalGetBandwidth( LPDDRAWI_DDVIDEOPORT_LCL this_lcl,
    LPDDPIXELFORMAT lpf, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags,
    LPDDVIDEOPORTBANDWIDTH lpBandwidth )

{
    LPDDHALVPORTCB_GETBANDWIDTH pfn;
    DDHAL_GETVPORTBANDWIDTHDATA GetBandwidthData;
    DWORD rc;

    lpBandwidth->dwCaps = 0;
    lpBandwidth->dwOverlay = (DWORD) -1;
    lpBandwidth->dwColorkey = (DWORD) -1;
    lpBandwidth->dwYInterpolate = (DWORD) -1;
    lpBandwidth->dwYInterpAndColorkey = (DWORD) -1;

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.GetVideoPortBandwidth;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
    	GetBandwidthData.lpDD = this_lcl->lpDD;
    	GetBandwidthData.lpVideoPort = this_lcl;
    	GetBandwidthData.lpddpfFormat = lpf;
    	GetBandwidthData.dwWidth = dwWidth;
    	GetBandwidthData.dwHeight = dwHeight;
    	GetBandwidthData.lpBandwidth = lpBandwidth;
    	GetBandwidthData.dwFlags = dwFlags;

	DOHALCALL( GetVideoPortBandwidthInfo, pfn, GetBandwidthData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != GetBandwidthData.ddRVal )
	{
	    return GetBandwidthData.ddRVal;
	}
	lpBandwidth->dwReserved1 = 0;
	lpBandwidth->dwReserved2 = 0;
    }
    else
    {
    	return DDERR_UNSUPPORTED;
    }

    return DD_OK;
}


/*
 * DD_VP_GetBandwidth
 */
HRESULT DDAPI DD_VP_GetBandwidth(LPDIRECTDRAWVIDEOPORT lpDVP,
    LPDDPIXELFORMAT lpf, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags,
    LPDDVIDEOPORTBANDWIDTH lpBandwidth )
{
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_Getbandwidth");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (lpf == NULL) || !VALID_DDPIXELFORMAT_PTR( lpf ) )
    	{
	    DPF_ERR( "Invalid LPDDPIXELFORMAT specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( (lpBandwidth == NULL) || !VALID_DDVIDEOPORTBANDWIDTH_PTR( lpBandwidth ) )
    	{
	    DPF_ERR( "Invalid LPDDVIDEOPORTBANDWIDTH specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( ( dwHeight == 0 ) || ( dwWidth == 0 ) ) &&
	    !( dwFlags & DDVPB_TYPE ) )
    	{
	    DPF_ERR( "Width and Height must be specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( dwFlags & DDVPB_VIDEOPORT ) && ( dwFlags & DDVPB_OVERLAY ) )
    	{
	    DPF_ERR( "Mutually exclusive flags specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( dwFlags & DDVPB_VIDEOPORT )
	{
            if( !( this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID].dwFX &
                ( DDVPFX_PRESTRETCHX | DDVPFX_PRESTRETCHY |
                  DDVPFX_PRESTRETCHXN | DDVPFX_PRESTRETCHYN ) ) )
            {
                if( ( dwWidth > this_lcl->ddvpDesc.dwFieldWidth ) ||
                    ( dwHeight > this_lcl->ddvpDesc.dwFieldHeight ) )
                {
                    DPF_ERR( "Invalid Width/Height specified" );
                    LEAVE_DDRAW();
                    return DDERR_INVALIDPARAMS;
                }
	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    rc = InternalGetBandwidth( this_lcl, lpf, dwWidth, dwHeight,
    	dwFlags, lpBandwidth );

    LEAVE_DDRAW();

    return rc;
}


/*
 * DD_VP_GetInputFormats
 */
HRESULT DDAPI DD_VP_GetInputFormats(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwNum, LPDDPIXELFORMAT lpf, DWORD dwFlags )
{
    LPDDHALVPORTCB_GETINPUTFORMATS pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    LPDDPIXELFORMAT lpTemp = NULL;
    DDHAL_GETVPORTINPUTFORMATDATA GetFormatData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_GetInputFormats");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (lpdwNum == NULL) || !VALID_BYTE_ARRAY( lpdwNum, sizeof( LPVOID ) ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( NULL != lpf )
    	{
	    if( 0 == *lpdwNum )
    	    {
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	    if( !VALID_BYTE_ARRAY( lpf, *lpdwNum * sizeof( DDPIXELFORMAT ) ) )
    	    {
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
      	}
	if( ( dwFlags == 0 ) ||
	   ( dwFlags & ~(DDVPFORMAT_VIDEO|DDVPFORMAT_VBI|DDVPFORMAT_NOFAIL) ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( ( this_int->dwFlags & DDVPCREATE_VBIONLY ) &&
	    !( dwFlags & DDVPFORMAT_NOFAIL ) )
	{
	    if( dwFlags & DDVPFORMAT_VIDEO )
	    {
		DPF_ERR( "DDVPFORMAT_VIDEO specified on a VBI-only video port" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    dwFlags |= DDVPFORMAT_VBI;
	}
	else if( ( this_int->dwFlags & DDVPCREATE_VIDEOONLY ) &&
	    !( dwFlags & DDVPFORMAT_NOFAIL ) )
	{
	    if( dwFlags & DDVPFORMAT_VBI )
	    {
		DPF_ERR( "DDVPFORMAT_VBI specified on a video-only video port" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    dwFlags |= DDVPFORMAT_VIDEO;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.GetVideoPortInputFormats;
    if( pfn != NULL )
    {
	/*
	 * Get the number of formats
	 */
    	GetFormatData.lpDD = this_lcl->lpDD;
    	GetFormatData.dwFlags = dwFlags;
    	GetFormatData.lpVideoPort = this_lcl;
    	GetFormatData.lpddpfFormat = NULL;

	DOHALCALL( GetVideoPortInputFormats, pfn, GetFormatData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return GetFormatData.ddRVal;
	}
	else if( DD_OK != GetFormatData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetFormatData.ddRVal;
	}

	if( NULL == lpf )
	{
    	    *lpdwNum = GetFormatData.dwNumFormats;
	}

	else
	{
	    /*
	     * Make sure we have enough room for formats
	     */
	    if( GetFormatData.dwNumFormats > *lpdwNum )
	    {
		lpTemp = (LPDDPIXELFORMAT) MemAlloc( sizeof( DDPIXELFORMAT ) *
	    	    GetFormatData.dwNumFormats );
    	        GetFormatData.lpddpfFormat = lpTemp;
	    }
	    else
	    {
    	    	GetFormatData.lpddpfFormat = lpf;
	    }

	    DOHALCALL( GetVideoPortInputFormats, pfn, GetFormatData, rc, 0 );
	    if( DDHAL_DRIVER_HANDLED != rc )
	    {
		MemFree( lpTemp );
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
	    else if( DD_OK != GetFormatData.ddRVal )
	    {
		MemFree( lpTemp );
	        LEAVE_DDRAW();
	        return GetFormatData.ddRVal;
	    }

	    if( GetFormatData.lpddpfFormat != lpf )
	    {
		memcpy( lpf, lpTemp, sizeof( DDPIXELFORMAT ) * *lpdwNum );
		MemFree( lpTemp );
    		LEAVE_DDRAW();
		return DDERR_MOREDATA;
	    }
	    else
	    {
		*lpdwNum = GetFormatData.dwNumFormats;
	    }
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
}

/*
 * DD_VP_GetOutputFormats
 */
HRESULT DDAPI DD_VP_GetOutputFormats(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDPIXELFORMAT lpddpfInput, LPDWORD lpdwNum, LPDDPIXELFORMAT lpddpfOutput, DWORD dwFlags )
{
    LPDDHALVPORTCB_GETOUTPUTFORMATS pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    LPDDPIXELFORMAT lpTemp = NULL;
    DDHAL_GETVPORTOUTPUTFORMATDATA GetFormatData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_GetOutputFormats");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( !VALID_DDPIXELFORMAT_PTR( lpddpfInput ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( (lpdwNum == NULL) || !VALID_BYTE_ARRAY( lpdwNum, sizeof( LPVOID ) ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( NULL != lpddpfOutput )
    	{
	    if( 0 == *lpdwNum )
    	    {
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	    if( !VALID_BYTE_ARRAY( lpddpfOutput, *lpdwNum * sizeof( DDPIXELFORMAT ) ) )
    	    {
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
      	}
	if( ( dwFlags == 0 ) ||
	    ( dwFlags & ~(DDVPFORMAT_VIDEO|DDVPFORMAT_VBI|DDVPFORMAT_NOFAIL) ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( ( this_int->dwFlags & DDVPCREATE_VBIONLY ) &&
	    !( dwFlags & DDVPFORMAT_NOFAIL ) )
	{
	    if( dwFlags & DDVPFORMAT_VIDEO )
	    {
		DPF_ERR( "DDVPFORMAT_VIDEO specified on a VBI-only video port" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    dwFlags |= DDVPFORMAT_VBI;
	}
	else if( ( this_int->dwFlags & DDVPCREATE_VIDEOONLY ) &&
	    !( dwFlags & DDVPFORMAT_NOFAIL ) )
	{
	    if( dwFlags & DDVPFORMAT_VBI )
	    {
		DPF_ERR( "DDVPFORMAT_VBI specified on a video-only video port" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    dwFlags |= DDVPFORMAT_VIDEO;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.GetVideoPortOutputFormats;
    if( pfn != NULL )
    {
	/*
	 * Get the number of formats
	 */
    	GetFormatData.lpDD = this_lcl->lpDD;
    	GetFormatData.dwFlags = dwFlags;
    	GetFormatData.lpVideoPort = this_lcl;
    	GetFormatData.lpddpfInputFormat = lpddpfInput;
    	GetFormatData.lpddpfOutputFormats = NULL;

	DOHALCALL( GetVideoPortOutputFormats, pfn, GetFormatData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
	else if( DD_OK != GetFormatData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetFormatData.ddRVal;
	}

	if( NULL == lpddpfOutput )
	{
    	    *lpdwNum = GetFormatData.dwNumFormats;
	}

	else
	{
	    /*
	     * Make sure we have enough room for formats
	     */
	    if( GetFormatData.dwNumFormats > *lpdwNum )
	    {
		lpTemp = (LPDDPIXELFORMAT) MemAlloc( sizeof( DDPIXELFORMAT ) *
	    	    GetFormatData.dwNumFormats );
    	        GetFormatData.lpddpfOutputFormats = lpTemp;
	    }
	    else
	    {
    	    	GetFormatData.lpddpfOutputFormats = lpddpfOutput;
	    }

	    DOHALCALL( GetVideoPortOutputFormats, pfn, GetFormatData, rc, 0 );
	    if( DDHAL_DRIVER_HANDLED != rc )
	    {
		MemFree( lpTemp );
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
	    else if( DD_OK != GetFormatData.ddRVal )
	    {
		MemFree( lpTemp );
	        LEAVE_DDRAW();
	        return GetFormatData.ddRVal;
	    }

	    if( GetFormatData.lpddpfOutputFormats != lpddpfOutput )
	    {
		memcpy( lpddpfOutput, lpTemp, sizeof( DDPIXELFORMAT ) * *lpdwNum );
		MemFree( lpTemp );
    		LEAVE_DDRAW();
		return DDERR_MOREDATA;
	    }
	    else
	    {
		*lpdwNum = GetFormatData.dwNumFormats;
	    }
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * DD_VP_GetField
 */
HRESULT DDAPI DD_VP_GetField(LPDIRECTDRAWVIDEOPORT lpDVP, LPBOOL lpField )
{
    LPDDHALVPORTCB_GETFIELD pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DWORD rc;
    DDHAL_GETVPORTFIELDDATA GetFieldData;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_GetField");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (NULL == lpField ) || !VALID_BOOL_PTR( lpField ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.GetVideoPortField;
    if( pfn != NULL )
    {
    	GetFieldData.lpDD = this_lcl->lpDD;
    	GetFieldData.lpVideoPort = this_lcl;
    	GetFieldData.bField = 0;

	DOHALCALL( GetVideoPortField, pfn, GetFieldData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
	else if( DD_OK != GetFieldData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetFieldData.ddRVal;
	}

	*lpField = GetFieldData.bField;
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * DD_VP_GetLine
 */
HRESULT DDAPI DD_VP_GetLine(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwLine )
{
    LPDDHALVPORTCB_GETLINE pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DWORD rc;
    DDHAL_GETVPORTLINEDATA GetLineData;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_GetLine");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (NULL == lpdwLine ) || !VALID_DWORD_PTR( lpdwLine ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.GetVideoPortLine;
    if( pfn != NULL )
    {
    	GetLineData.lpDD = this_lcl->lpDD;
    	GetLineData.lpVideoPort = this_lcl;
    	GetLineData.dwLine = 0;

	DOHALCALL( GetVideoPortLine, pfn, GetLineData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
	else if( DD_OK != GetLineData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetLineData.ddRVal;
	}

	*lpdwLine = GetLineData.dwLine;
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * ValidateVideoInfo
 */
HRESULT ValidateVideoInfo(LPDDRAWI_DDVIDEOPORT_INT this_int,
    LPDDVIDEOPORTINFO lpInfo, LPDWORD lpNumAutoFlip, LPDWORD lpNumVBIAutoFlip )
{
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    LPDDPIXELFORMAT lpOutputFormat;
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = NULL;
    DWORD rc;
    DWORD dwAvailCaps;
    DWORD dwAvailFX;
    DWORD dwConnectFlags;
    DWORD dwVPFlags;
    DWORD dwNum;
    DWORD i;

    this_lcl = this_int->lpLcl;
    *lpNumAutoFlip = 0;
    *lpNumVBIAutoFlip = 0;

    /*
     * Check for invalid caps
     */
    dwAvailCaps = this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID].dwCaps;
    dwAvailFX = this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID].dwFX;
    dwConnectFlags = this_lcl->ddvpDesc.VideoPortType.dwFlags;
    dwVPFlags = lpInfo->dwVPFlags;
    if( ( dwVPFlags & DDVP_AUTOFLIP ) && !( dwAvailCaps & DDVPCAPS_AUTOFLIP ) )
    {
	DPF_ERR( "Invalid autoflip capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & DDVP_INTERLEAVE ) && (
    	!( dwConnectFlags & DDVPCONNECT_INTERLACED ) ||
    	( dwConnectFlags & DDVPCONNECT_SHAREEVEN ) ||
    	( dwConnectFlags & DDVPCONNECT_SHAREODD ) ||
    	!( dwAvailFX & DDVPFX_INTERLEAVE ) ||
	( dwVPFlags & DDVP_SKIPODDFIELDS ) ||
	( dwVPFlags & DDVP_SKIPEVENFIELDS ) ) )
    {
	DPF_ERR( "Invalid interleave capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & DDVP_MIRRORLEFTRIGHT ) && !( dwAvailFX & DDVPFX_MIRRORLEFTRIGHT ) )
    {
	DPF_ERR( "Invalid mirror left/right capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & DDVP_MIRRORUPDOWN ) && !( dwAvailFX & DDVPFX_MIRRORUPDOWN ) )
    {
	DPF_ERR( "Invalid mirror up/down capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & DDVP_SKIPEVENFIELDS ) && (
    	!( dwConnectFlags & DDVPCONNECT_INTERLACED ) ||
    	( dwConnectFlags & DDVPCONNECT_SHAREEVEN ) ||
    	( dwConnectFlags & DDVPCONNECT_SHAREODD ) ||
    	!( dwAvailCaps & DDVPCAPS_SKIPEVENFIELDS ) ||
	( dwVPFlags & DDVP_SKIPODDFIELDS ) ) )
    {
	DPF_ERR( "Invalid skipevenfields capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & DDVP_SKIPODDFIELDS ) && (
    	!( dwConnectFlags & DDVPCONNECT_INTERLACED ) ||
    	( dwConnectFlags & DDVPCONNECT_SHAREEVEN ) ||
    	( dwConnectFlags & DDVPCONNECT_SHAREODD ) ||
    	!( dwAvailCaps & DDVPCAPS_SKIPODDFIELDS ) ) )
    {
	DPF_ERR( "Invalid skipoddfields capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & DDVP_VBINOSCALE ) && !( dwAvailFX & DDVPFX_VBINOSCALE ) )
    {
	DPF_ERR( "Invalid VBI no-scale capability specified" );
	return DDERR_INVALIDCAPS;
    }
    if( ( dwVPFlags & ( DDVP_VBICONVERT | DDVP_VBINOSCALE ) ) ||
    	( NULL != this_lcl->lpVBISurface ) )
    {
	if( ( lpInfo->dwVBIHeight == 0 ) ||
	    ( lpInfo->dwVBIHeight >= this_lcl->ddvpDesc.dwFieldHeight ) )
    	{
	    DPF_ERR( "Invalid dwVBIHeight specified" );
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( dwVPFlags & DDVP_CROP ) &&
	    ( lpInfo->rCrop.top > (int) lpInfo->dwVBIHeight ) )
	{
	    DPF_ERR( "Invalid dwVBIHeight specified" );
	    return DDERR_INVALIDPARAMS;
	}
    }
    if( dwVPFlags & DDVP_CROP )
    {
	if( lpInfo->rCrop.bottom > (int) this_lcl->ddvpDesc.dwFieldHeight )
	{
	    DPF_ERR( "Invalid cropping rectangle specified" );
	    return DDERR_SURFACENOTATTACHED;
	}
	if( !( dwAvailFX & ( DDVPFX_CROPY | DDVPFX_CROPTOPDATA ) ) && (
	        (lpInfo->rCrop.bottom - lpInfo->rCrop.top ) !=
	        (int) this_lcl->ddvpDesc.dwFieldHeight ) )
	{
	    DPF_ERR( "Invalid cropping rectangle specified" );
	    return DDERR_SURFACENOTATTACHED;
	}
	if( lpInfo->rCrop.top >= (int) lpInfo->dwVBIHeight )
	{
	    lpInfo->dwVBIHeight = 0;
	}

	/*
	 * Only do the extensive field width/height checking if the video
	 * region is involved
	 */
	if( lpInfo->rCrop.bottom > (int) lpInfo->dwVBIHeight )
	{
	    if( lpInfo->rCrop.right > (int) this_lcl->ddvpDesc.dwFieldWidth )
	    {
	        DPF_ERR( "Invalid cropping rectangle specified" );
	        return DDERR_SURFACENOTATTACHED;
	    }
	    if( !( dwAvailFX & DDVPFX_CROPX ) && (
	        (lpInfo->rCrop.right - lpInfo->rCrop.left ) !=
	        (int) this_lcl->ddvpDesc.dwFieldWidth ) )
	    {
	        DPF_ERR( "Invalid cropping rectangle specified" );
	        return DDERR_SURFACENOTATTACHED;
	    }
	    if( ( ( lpInfo->rCrop.right - lpInfo->rCrop.left ) ==
	        (int) this_lcl->ddvpDesc.dwFieldWidth ) &&
	        ( ( lpInfo->rCrop.bottom - lpInfo->rCrop.top ) ==
	        (int) this_lcl->ddvpDesc.dwFieldHeight ) )
	    {
	        dwVPFlags &= ~DDVP_CROP;
	        lpInfo->dwVPFlags &= ~DDVP_CROP;
	    }
	}
    }
    if( dwVPFlags & DDVP_PRESCALE )
    {
	DWORD dwPreWidth;
	DWORD dwPreHeight;

	if( dwVPFlags & DDVP_CROP )
	{
	    dwPreWidth = lpInfo->rCrop.right - lpInfo->rCrop.left;
	    dwPreHeight = lpInfo->rCrop.bottom - lpInfo->rCrop.top;
	}
	else
	{
	    dwPreWidth = this_lcl->ddvpDesc.dwFieldWidth;
	    dwPreHeight = this_lcl->ddvpDesc.dwFieldHeight;
	}
	if( lpInfo->dwPrescaleWidth > dwPreWidth )
	{
	    if( !( dwAvailFX & DDVPFX_PRESTRETCHX ) &&
	        !( ( dwAvailFX & DDVPFX_PRESTRETCHXN ) &&
		    ( lpInfo->dwPrescaleWidth % dwPreWidth ) ) )
	    {
	    	DPF_ERR( "Invalid stretch specified" );
	    	return DDERR_INVALIDPARAMS;
	    }
	}
	if( lpInfo->dwPrescaleHeight > dwPreHeight )
	{
	    if( !( dwAvailFX & DDVPFX_PRESTRETCHY ) &&
	        !( ( dwAvailFX & DDVPFX_PRESTRETCHYN ) &&
		    ( lpInfo->dwPrescaleHeight % dwPreHeight ) ) )
	    {
	    	DPF_ERR( "Invalid stretch specified" );
	    	return DDERR_INVALIDPARAMS;
	    }
	}

	if( lpInfo->dwPrescaleWidth < dwPreWidth )
	{
	    if( !( dwAvailFX & DDVPFX_PRESHRINKX ) &&
	        !( dwAvailFX & DDVPFX_PRESHRINKXS ) &&
	        !( dwAvailFX & DDVPFX_PRESHRINKXB ) )
	    {
	    	DPF_ERR( "Invalid shrink specified" );
	    	return DDERR_INVALIDPARAMS;
	    }
	}
	if( lpInfo->dwPrescaleHeight < dwPreHeight )
	{
	    if( !( dwAvailFX & DDVPFX_PRESHRINKY ) &&
	        !( dwAvailFX & DDVPFX_PRESHRINKYS ) &&
	        !( dwAvailFX & DDVPFX_PRESHRINKYB ) )
	    {
	    	DPF_ERR( "Invalid shrink specified" );
	    	return DDERR_INVALIDPARAMS;
	    }
	}
	if( ( lpInfo->dwPrescaleWidth == dwPreWidth ) &&
	    ( lpInfo->dwPrescaleHeight == dwPreHeight ) )
	{
	    dwVPFlags &= ~DDVP_PRESCALE;
	    lpInfo->dwVPFlags &= ~DDVP_PRESCALE;
	}
    }
    if( dwVPFlags & DDVP_VBINOINTERLEAVE )
    {
	if( !( dwAvailFX & DDVPFX_VBINOINTERLEAVE ) )
	{
	    DPF_ERR( "Device does not support DDVP_VBINOINTERLEAVE" );
	    return DDERR_INVALIDPARAMS;
	}
	if( this_lcl->lpVBISurface == NULL )
	{
	    DPF_ERR( "DDVP_VBINOINTERLEAVE only valid when using a separate VBI surface" );
	    return DDERR_INVALIDPARAMS;
	}
    }
    if( dwVPFlags & DDVP_HARDWAREDEINTERLACE )
    {
	if( !( dwAvailCaps & DDVPCAPS_HARDWAREDEINTERLACE ) )
	{
	    DPF_ERR( "DDVP_HARDWAREDEINTERLACE not supported by this device" );
	    return DDERR_INVALIDPARAMS;
	}
	if( ( this_lcl->lpSurface != NULL ) &&
	    !( this_lcl->lpSurface->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 &
	    DDSCAPS2_RESERVED4 ) )
	{
	    DPF_ERR( "DDSCAPS2_RESERVED4 not set on target surface" );
	    return DDERR_INVALIDPARAMS;
	}
	if( ( this_lcl->lpVBISurface != NULL ) &&
	    !( this_lcl->lpVBISurface->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 &
	    DDSCAPS2_RESERVED4 ) )
	{
	    DPF_ERR( "DDSCAPS2_RESERVED4 not set on target surface" );
	    return DDERR_INVALIDPARAMS;
	}
        if( dwVPFlags & DDVP_AUTOFLIP )
        {
	    DPF_ERR( "DDVP_HARDWAREDEINTERLACE not valid with DDVP_AUTOFLIP" );
	    return DDERR_INVALIDPARAMS;
	}
    }

    /*
     * Fail if neither a VBI or regular surface is attached
     */
    if( ( NULL == this_lcl->lpSurface ) && ( NULL == this_lcl->lpVBISurface ) )
    {
	DPF_ERR( "No surfaces are attached to the video port" );
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Validate the regular video data
     */
    if( ( NULL != this_lcl->lpSurface ) &&
        ( this_int->lpLcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
    {
	DWORD dwVidWidth;
	DWORD dwVidHeight;

	/*
	 * Validate the input format
	 */
	dwNum = MAX_VP_FORMATS;
	rc = DD_VP_GetInputFormats( (LPDIRECTDRAWVIDEOPORT) this_int,
	    &dwNum, ddpfVPFormats, DDVPFORMAT_VIDEO | DDVPFORMAT_NOFAIL );
	if( ( rc != DD_OK ) && ( rc != DDERR_MOREDATA ) )
	{
	    DPF_ERR( "Invalid input format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}
	i = 0;
	while( ( i < dwNum ) && IsDifferentPixelFormat( &(ddpfVPFormats[i]),
	    lpInfo->lpddpfInputFormat ) )
	{
	    i++;
	}
	if( i == dwNum )
	{
	    DPF_ERR( "Invalid input format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}

	/*
	 * Validate the output format
	 */
	dwNum = MAX_VP_FORMATS;
	rc = DD_VP_GetOutputFormats( (LPDIRECTDRAWVIDEOPORT) this_int,
	    lpInfo->lpddpfInputFormat, &dwNum, ddpfVPFormats,
	    DDVPFORMAT_VIDEO | DDVPFORMAT_NOFAIL );
	if( ( rc != DD_OK ) && ( rc != DDERR_MOREDATA ) )
	{
	    DPF_ERR( "Invalid output format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}
	i = 0;
	surf_lcl = this_lcl->lpSurface->lpLcl;
	lpOutputFormat = GetSurfaceFormat( surf_lcl );
	if( ( IsDifferentPixelFormat( lpInfo->lpddpfInputFormat,
	    lpOutputFormat ) ) && !( dwVPFlags |= DDVP_CONVERT ) )
	{
	    DPF_ERR( "Invalid output format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}
	while( ( i < dwNum ) && IsDifferentPixelFormat( &(ddpfVPFormats[i]),
	    lpOutputFormat ) )
	{
	    i++;
	}
	if( i == dwNum )
	{
	    DPF_ERR( "Invalid output format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}

	/*
	 * Make sure the video fits within the attached surface
	 */
	if( SURFACE_LOST( surf_lcl ) )
	{
	    DPF_ERR( "Target surface is lost" );
	    return DDERR_SURFACELOST;
	}

	if( dwVPFlags & DDVP_PRESCALE )
	{
	    dwVidWidth = lpInfo->dwPrescaleWidth;
	    dwVidHeight = lpInfo->dwPrescaleHeight;
	}
	else if( dwVPFlags & DDVP_CROP )
	{
	    dwVidWidth = lpInfo->rCrop.right - lpInfo->rCrop.left;
	    dwVidHeight = lpInfo->rCrop.bottom - lpInfo->rCrop.top;
	}
	else
	{
	    dwVidWidth = this_lcl->ddvpDesc.dwFieldWidth;
	    dwVidHeight = this_lcl->ddvpDesc.dwFieldHeight;
	}
        if( ( lpInfo->dwVBIHeight > 0 ) &&
            ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) &&
            ( NULL != this_lcl->lpVBISurface ) )
        {
            dwVidHeight -= lpInfo->dwVBIHeight;
        }
	if( dwVPFlags & DDVP_INTERLEAVE )
	{
	    dwVidHeight *= 2;
	}

	if( lpInfo->dwOriginX + dwVidWidth > (DWORD) surf_lcl->lpGbl->wWidth )
	{
	    DPF_ERR( "surface is not wide enough to hold the videoport data" );
	    return DDERR_TOOBIGWIDTH;
	}
	if( lpInfo->dwOriginY + dwVidHeight > (DWORD) surf_lcl->lpGbl->wHeight )
	{
	    DPF_ERR( "surface is not tall enough to hold the videoport data" );
	    return DDERR_TOOBIGHEIGHT;
	}
    }
    else if( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON )
    {
        DPF_ERR( "Video surface not specified" );
        return DDERR_INVALIDPARAMS;
    }

    /*
     * Validate the VBI formats.
     */
    if( ( lpInfo->dwVBIHeight > 0 ) &&
        ( this_int->lpLcl->dwFlags & DDRAWIVPORT_VBION ) )
    {
	if( lpInfo->lpddpfVBIInputFormat == NULL )
	{
	    DPF_ERR( "VBI input format not specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}
    }

    /*
     * Unless they want to convert the format, we don't do very much
     * error checking.
     */
    if( dwVPFlags & DDVP_VBICONVERT )
    {
	if( !( dwAvailFX & DDVPFX_VBICONVERT ) )
	{
	    DPF_ERR( "device cannot convert the VBI data" );
	    return DDERR_INVALIDCAPS;
	}

	/*
	 * Validate the VBI input format
	 */
    	dwNum = MAX_VP_FORMATS;
    	rc = DD_VP_GetInputFormats( (LPDIRECTDRAWVIDEOPORT) this_int,
    	    &dwNum, ddpfVPFormats, DDVPFORMAT_VBI | DDVPFORMAT_NOFAIL );
    	if( ( rc != DD_OK ) && ( rc != DDERR_MOREDATA ) )
    	{
	    DPF_ERR( "Invalid input VBI format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
    	}
    	i = 0;
    	while( ( i < dwNum ) && IsDifferentPixelFormat( &(ddpfVPFormats[i]),
    	    lpInfo->lpddpfVBIInputFormat ) )
    	{
	    i++;
    	}
    	if( i == dwNum )
    	{
	    DPF_ERR( "Invalid VBI input format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
    	}

    	/*
     	 * Validate the VBI output format
     	 */
	if( lpInfo->lpddpfVBIOutputFormat == NULL )
	{
	    DPF_ERR( "VBI output format not specified" );
	    return DDERR_INVALIDPIXELFORMAT;
	}
    	dwNum = MAX_VP_FORMATS;
    	rc = DD_VP_GetOutputFormats( (LPDIRECTDRAWVIDEOPORT) this_int,
    	    lpInfo->lpddpfVBIInputFormat, &dwNum, ddpfVPFormats,
	    DDVPFORMAT_VBI | DDVPFORMAT_NOFAIL );
    	if( ( rc != DD_OK ) && ( rc != DDERR_MOREDATA ) )
    	{
	    DPF_ERR( "Invalid output format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
    	}
    	i = 0;
    	while( ( i < dwNum ) && IsDifferentPixelFormat( &(ddpfVPFormats[i]),
    	    lpInfo->lpddpfVBIOutputFormat ) )
    	{
	    i++;
    	}
    	if( i == dwNum )
    	{
	    DPF_ERR( "Invalid VBI output format specified" );
	    return DDERR_INVALIDPIXELFORMAT;
    	}
    }

    /*
     * Validate the VBI surface
     */
    if( ( lpInfo->dwVBIHeight > 0 ) &&
        ( this_int->lpLcl->dwFlags & DDRAWIVPORT_VBION ) )
    {
	DWORD dwVBIBytes;
        DWORD dwSurfaceBytes = 0;
	DWORD dwVBIHeight;

	/*
	 * Determine the height of the VBI data
	 */
	dwVBIHeight = lpInfo->dwVBIHeight;
	if( dwVPFlags & DDVP_CROP )
	{
	    if( lpInfo->rCrop.top < (int) lpInfo->dwVBIHeight )
	    {
	        dwVBIHeight -= lpInfo->rCrop.top;
	        if( lpInfo->rCrop.bottom < (int) lpInfo->dwVBIHeight )
	        {
	            dwVBIHeight -= (lpInfo->dwVBIHeight - (DWORD)lpInfo->rCrop.bottom);
		}
	    }
	    else
	    {
	        dwVBIHeight = 0;
	    }
	}
	if( ( dwVPFlags & DDVP_INTERLEAVE ) &&
	    !( dwVPFlags & DDVP_VBINOINTERLEAVE ) )
	{
	    dwVBIHeight *= 2;
	}

	/*
	 * Make sure that the data will fit in the surface
	 */
	if( ( dwVPFlags & DDVP_VBINOSCALE ) ||
	    !( dwVPFlags & DDVP_PRESCALE ) )
	{
	    dwVBIBytes = this_lcl->ddvpDesc.dwVBIWidth;
	}
	else
	{
	    dwVBIBytes = lpInfo->dwPrescaleWidth;
	}
	if( dwVPFlags & DDVP_VBICONVERT )
	{
	    lpOutputFormat = lpInfo->lpddpfVBIOutputFormat;
	}
	else
	{
	    lpOutputFormat = lpInfo->lpddpfVBIInputFormat;
	}
	if( lpOutputFormat->dwRGBBitCount )
	{
	    dwVBIBytes *= lpOutputFormat->dwRGBBitCount;
	    dwVBIBytes /= 8;
	}
	else
	{
	    dwVBIBytes *= 2;
	}
    	if( NULL != this_lcl->lpVBISurface )
    	{
	    if( SURFACE_LOST( this_lcl->lpVBISurface->lpLcl ) )
	    {
	    	DPF_ERR( "Target VBI surface is lost" );
	    	return DDERR_SURFACELOST;
	    }

	    dwSurfaceBytes = (DWORD) this_lcl->lpVBISurface->lpLcl->lpGbl->wWidth;
	    if( this_lcl->lpVBISurface->lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	    {
	    	dwSurfaceBytes *= this_lcl->lpVBISurface->lpLcl->lpGbl->ddpfSurface.dwRGBBitCount;
	    }
	    else
	    {
	    	dwSurfaceBytes *= this_lcl->lpDD->lpGbl->vmiData.ddpfDisplay.dwRGBBitCount;
	    }

	    if( dwVBIHeight > (DWORD) this_lcl->lpVBISurface->lpLcl->lpGbl->wHeight )
	    {
	    	DPF_ERR( "VBI surface is not tall enough to hold the VBI data" );
	    	return DDERR_TOOBIGHEIGHT;
	    }
	}
	else if( NULL != surf_lcl )
    	{
	    dwSurfaceBytes = (DWORD) surf_lcl->lpGbl->wWidth;
	    if( surf_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	    {
	    	dwSurfaceBytes *= surf_lcl->lpGbl->ddpfSurface.dwRGBBitCount;
	    }
	    else
	    {
	    	dwSurfaceBytes *= this_lcl->lpDD->lpGbl->vmiData.ddpfDisplay.dwRGBBitCount;
	    }
	    if( dwVBIHeight > (DWORD) this_lcl->lpSurface->lpLcl->lpGbl->wHeight )
	    {
	    	DPF_ERR( "Surface is not tall enough to hold the VBI data" );
	    	return DDERR_TOOBIGHEIGHT;
	    }
	}
	dwSurfaceBytes /= 8;

        if( dwSurfaceBytes == 0 )
	{
            DPF_ERR( "No VBI/Video surface is attached to hold VBI data" );
            return DDERR_INVALIDPARAMS;
	}

	if( dwVBIBytes > dwSurfaceBytes )
	{
	    DPF_ERR( "VBI surface is not wide enough to hold the VBI data" );
	    return DDERR_TOOBIGWIDTH;
	}
    }

    /*
     * Validate the autoflip parameters
     */
    if( dwVPFlags & DDVP_AUTOFLIP )
    {
	LPDDRAWI_DDRAWSURFACE_INT surf_first;
	LPDDRAWI_DDRAWSURFACE_INT surf_int;

	/*
	 * Count how many regular surfaces there are
	 */
    	if( ( NULL != this_lcl->lpSurface ) &&
            ( this_int->lpLcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
    	    surf_first = surf_int = this_lcl->lpSurface;
    	    do
    	    {
		(*lpNumAutoFlip)++;
		surf_int = FindAttachedFlip( surf_int );
	    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
	    if( *lpNumAutoFlip == 1 )
	    {
		*lpNumAutoFlip = 0;
	    }
	}

	/*
	 * Count how many VBI surfaces there are
	 */
    	if( ( NULL != this_lcl->lpVBISurface ) &&
            ( this_int->lpLcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
    	    surf_first = surf_int = this_lcl->lpVBISurface;
    	    do
    	    {
		(*lpNumVBIAutoFlip)++;
		surf_int = FindAttachedFlip( surf_int );
	    } while( ( surf_int != NULL ) && ( surf_int->lpLcl != surf_first->lpLcl ) );
	    if( *lpNumVBIAutoFlip == 1 )
	    {
		*lpNumVBIAutoFlip = 0;
	    }
	}

	/*
	 * It's an error if neither one has sufficient surfaces to autoflip
	 */
	if( ( *lpNumAutoFlip == 0 ) && ( *lpNumVBIAutoFlip == 0 ) )
	{
	    DPF_ERR( "no autoflip surfaces are attached" );
	    return DDERR_INVALIDPARAMS;
	}
    }

    return DD_OK;
}


/*
 * FillFlipArray
 */
DWORD FillFlipArray( LPDDRAWI_DDRAWSURFACE_INT *lpArray,
	LPDDRAWI_DDRAWSURFACE_INT lpStart, LPDWORD lpdwCnt )
{
    LPDDRAWI_DDRAWSURFACE_INT surf_first;

    *lpdwCnt = 0;
    surf_first = lpStart;
    do
    {
	if( SURFACE_LOST( lpStart->lpLcl ) )
	{
	    DPF_ERR( "Autoflip surface is lost" );
	    return (DWORD) DDERR_SURFACELOST;
	}
	(*lpdwCnt)++;
	*lpArray++ = lpStart;
    	lpStart = FindAttachedFlip( lpStart );
    } while( ( lpStart != NULL ) && ( lpStart->lpLcl != surf_first->lpLcl ) );

    return DD_OK;
}


/*
 * InternalStartVideo
 */
HRESULT InternalStartVideo(LPDDRAWI_DDVIDEOPORT_INT this_int,
    LPDDVIDEOPORTINFO lpInfo )
{
    LPDDHALVPORTCB_UPDATE pfn;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDHAL_UPDATEVPORTDATA UpdateData;
    DDVIDEOPORTBANDWIDTH Bandwidth;
    LPDDRAWI_DDRAWSURFACE_INT *lpTempFlipInts;
    LPDDVIDEOPORTCAPS lpAvailCaps;
    DWORD dwTempNumAutoFlip;
    DWORD dwTempNumVBIAutoFlip;
    DWORD rc;
    DWORD dwNumAutoFlip;
    DWORD dwNumVBIAutoFlip;
    DWORD dwTemp;

    /*
     * Validate the input parameters
     */
    rc = ValidateVideoInfo( this_int, lpInfo, &dwNumAutoFlip, &dwNumVBIAutoFlip );
    if( DD_OK != rc )
    {
	return rc;
    }
    this_lcl = this_int->lpLcl;
    lpAvailCaps = &(this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID]);

    /*
     * Setup the autoflip surfaces
     */
    lpTempFlipInts = NULL;
    if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
    {
	DWORD dwCnt;

	lpTempFlipInts = this_lcl->lpFlipInts;
	this_lcl->lpFlipInts = MemAlloc( sizeof( LPDDRAWI_DDRAWSURFACE_INT ) *
	    ( dwNumAutoFlip + dwNumVBIAutoFlip ) );
	if( NULL == this_lcl->lpFlipInts )
	{
	    DPF_ERR( "insufficient memory" );
	    this_lcl->lpFlipInts = lpTempFlipInts;
	    return DDERR_OUTOFMEMORY;
	}

	/*
	 * Now put the surface INTs into the array.
	 */
	if( dwNumAutoFlip )
	{
	    rc = FillFlipArray( this_lcl->lpFlipInts, this_lcl->lpSurface, &dwCnt );
	    if( rc != DD_OK )
	    {
		MemFree( this_lcl->lpFlipInts );
		this_lcl->lpFlipInts = lpTempFlipInts;
		return rc;
	    }
	    DDASSERT( dwCnt == dwNumAutoFlip );

	    if( dwNumAutoFlip > lpAvailCaps->dwNumAutoFlipSurfaces )
	    {
		DPF_ERR( "Too many autoflip surfaces" );
		MemFree( this_lcl->lpFlipInts );
		this_lcl->lpFlipInts = lpTempFlipInts;
		return DDERR_INVALIDPARAMS;
	    }
	}

	/*
	 * Now put the VBI surface INTs into the array.
	 */
	if( dwNumVBIAutoFlip )
	{
	    rc = FillFlipArray( &(this_lcl->lpFlipInts[dwNumAutoFlip]),
	    	this_lcl->lpVBISurface, &dwCnt );
	    if( rc != DD_OK )
	    {
	    	MemFree( this_lcl->lpFlipInts );
	    	this_lcl->lpFlipInts = lpTempFlipInts;
	    	return rc;
	    }
	    DDASSERT( dwCnt == dwNumVBIAutoFlip );

	    if( dwNumVBIAutoFlip > lpAvailCaps->dwNumVBIAutoFlipSurfaces )
	    {
		DPF_ERR( "Too many VBI autoflip surfaces" );
		MemFree( this_lcl->lpFlipInts );
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
    dwTempNumAutoFlip = this_lcl->dwNumAutoflip;
    dwTempNumVBIAutoFlip = this_lcl->dwNumVBIAutoflip;
    this_lcl->dwNumAutoflip = dwNumAutoFlip;
    this_lcl->dwNumVBIAutoflip = dwNumVBIAutoFlip;

    /*
     * The kernel interface may have switched from hardware autoflipping
     * to software autoflipping w/o us knowing.  We need to check for
     * this.
     */
    #ifdef WIN95
        if( ( lpInfo->dwVPFlags & DDVP_AUTOFLIP ) &&
    	    ( this_lcl->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP ) &&
    	    ( ( this_lcl->lpSurface != NULL ) || ( this_lcl->lpVBISurface != NULL ) ) )
        {
	    DWORD dwState;

	    dwState = 0;
	    if( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON )
	    {
	        GetKernelSurfaceState( this_lcl->lpSurface->lpLcl, &dwState );
	    }
	    else
	    {
	        GetKernelSurfaceState( this_lcl->lpVBISurface->lpLcl, &dwState );
	    }
	    if( dwState & DDSTATE_SOFTWARE_AUTOFLIP )
	    {
    	        this_lcl->dwFlags |= DDRAWIVPORT_SOFTWARE_AUTOFLIP;
	    }
        }
    #endif

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.UpdateVideoPort;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
	memset( &UpdateData, 0, sizeof( UpdateData ) );
    	UpdateData.lpDD = this_lcl->lpDD;
    	UpdateData.lpVideoPort = this_lcl;
    	UpdateData.lpVideoInfo = lpInfo;
    	UpdateData.dwFlags = DDRAWI_VPORTSTART;
	if( dwNumAutoFlip && ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    UpdateData.lplpDDSurface = this_lcl->lpFlipInts;
	    UpdateData.dwNumAutoflip = dwNumAutoFlip;
	}
	else if( this_lcl->lpSurface && ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    UpdateData.lplpDDSurface = &(this_lcl->lpSurface);
	}
	else
	{
	    UpdateData.lplpDDSurface = NULL;
	}
	if( dwNumVBIAutoFlip && ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    UpdateData.lplpDDVBISurface =
		&(this_lcl->lpFlipInts[this_lcl->dwNumAutoflip]);
    	    UpdateData.dwNumVBIAutoflip = dwNumVBIAutoFlip;
	}
	else if( this_lcl->lpVBISurface && ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    UpdateData.lplpDDVBISurface = &(this_lcl->lpVBISurface);
	}
	else
	{
	    UpdateData.lplpDDVBISurface = NULL;
	}
	dwTemp = lpInfo->dwVPFlags;
	if( this_lcl->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP )
	{
	    lpInfo->dwVPFlags &= ~DDVP_AUTOFLIP;
	}

	/*
	 * Before we call the HAL, create the implicit kernel surfaces if
	 * needed and update the list.  A failure here will tell us whether
	 * software autoflip, etc. is an option.
	 */
	if( ( this_lcl->lpSurface != NULL ) &&
	    ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    ReleaseVPESurfaces( this_lcl->lpSurface, FALSE );
	    PrepareVPESurfaces( this_lcl->lpSurface, this_lcl,
		dwNumAutoFlip > 0 );
	}
	if( ( this_lcl->lpVBISurface != NULL ) &&
	    ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    ReleaseVPESurfaces( this_lcl->lpVBISurface, FALSE );
	    PrepareVPESurfaces( this_lcl->lpVBISurface, this_lcl,
		dwNumVBIAutoFlip > 0 );
	}
#ifdef WIN95
        if( this_lcl->lpSurface != NULL )
        {
            OverrideVideoPort( this_lcl->lpSurface, &(lpInfo->dwVPFlags) );
        }
#endif

	DOHALCALL( UpdateVideoPort, pfn, UpdateData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    lpInfo->dwVPFlags = dwTemp;
	    if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
	    {
		MemFree( this_lcl->lpFlipInts );
	    	this_lcl->lpFlipInts = lpTempFlipInts;
                this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
                this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	    }
	    return DDERR_UNSUPPORTED;
	}
	else if( DD_OK != UpdateData.ddRVal )
	{
	    /*
	     * If we failed due to hardware autoflipping, try again w/o
	     */
	    #ifdef WIN95
	    if( ( lpInfo->dwVPFlags & DDVP_AUTOFLIP ) &&
	    	CanSoftwareAutoflip( this_lcl ) )
	    {
	    	lpInfo->dwVPFlags &= ~DDVP_AUTOFLIP;
	    	DOHALCALL( UpdateVideoPort, pfn, UpdateData, rc, 0 );
	    	if( ( DDHAL_DRIVER_HANDLED != rc ) ||
		    ( DD_OK != UpdateData.ddRVal ) )
	    	{
		    lpInfo->dwVPFlags = dwTemp;
		    MemFree( this_lcl->lpFlipInts );
	    	    this_lcl->lpFlipInts = lpTempFlipInts;
		    this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
		    this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	    	    return UpdateData.ddRVal;
	    	}
    	    	this_lcl->dwFlags |= DDRAWIVPORT_SOFTWARE_AUTOFLIP;
	    }
	    else
	    {
	    #endif
	    	lpInfo->dwVPFlags = dwTemp;
	    	if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
	    	{
		    MemFree( this_lcl->lpFlipInts );
	    	    this_lcl->lpFlipInts = lpTempFlipInts;
		    this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
		    this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	    	}
	    	return UpdateData.ddRVal;
	    #ifdef WIN95
	    }
	    #endif
	}
	MemFree( lpTempFlipInts );
	lpTempFlipInts = NULL;
	lpInfo->dwVPFlags = dwTemp;

	UpdateInterleavedFlags( this_lcl, lpInfo->dwVPFlags );
    	this_lcl->dwFlags |= DDRAWIVPORT_ON;
	memcpy( &(this_lcl->ddvpInfo), lpInfo, sizeof( DDVIDEOPORTINFO ) );
	if( NULL != lpInfo->lpddpfInputFormat )
	{
	    this_lcl->ddvpInfo.lpddpfInputFormat = (LPDDPIXELFORMAT)
    		((LPBYTE)this_lcl +
    		sizeof( DDRAWI_DDVIDEOPORT_LCL ) );
	    memcpy( this_lcl->ddvpInfo.lpddpfInputFormat,
	    lpInfo->lpddpfInputFormat, sizeof( DDPIXELFORMAT ) );
	}

	/*
	 * Determine if this can be colorkeyed and interpolated at
	 * the same time.
	 */
	if( NULL != lpInfo->lpddpfInputFormat )
	{
	    memset( &Bandwidth, 0, sizeof( Bandwidth ) );
	    Bandwidth.dwSize = sizeof( Bandwidth );
	    InternalGetBandwidth( this_lcl, lpInfo->lpddpfInputFormat,
	    	0, 0, DDVPB_TYPE, &Bandwidth );
	    if( Bandwidth.dwCaps & DDVPBCAPS_SOURCE )
	    {
	    	if( InternalGetBandwidth( this_lcl, lpInfo->lpddpfInputFormat,
	    	    this_lcl->ddvpDesc.dwFieldWidth,
	    	    this_lcl->ddvpDesc.dwFieldHeight,
		    DDVPB_OVERLAY,
		    &Bandwidth ) == DD_OK )
	    	{
		    if( Bandwidth.dwYInterpAndColorkey ==
		    	Bandwidth.dwYInterpolate )
		    {
		    	this_lcl->dwFlags |= DDRAWIVPORT_COLORKEYANDINTERP;
		    }
	    	}
	    }
	    else
	    {
	    	if( InternalGetBandwidth( this_lcl, lpInfo->lpddpfInputFormat,
	    	    this_lcl->ddvpDesc.dwFieldWidth,
	    	    this_lcl->ddvpDesc.dwFieldHeight,
		    DDVPB_VIDEOPORT,
		    &Bandwidth ) == DD_OK )
	    	{
		    if( Bandwidth.dwYInterpAndColorkey <= 2000 )
		    {
		    	this_lcl->dwFlags |= DDRAWIVPORT_COLORKEYANDINTERP;
		    }
	    	}
	    }
	}
    }
    else
    {
	this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
	this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
	{
	    MemFree( this_lcl->lpFlipInts );
	    this_lcl->lpFlipInts = lpTempFlipInts;
	}
	return DDERR_UNSUPPORTED;
    }

    /*
     * Notify  kernel mode of the change
     */
    #ifdef WIN95
        UpdateKernelVideoPort( this_lcl, DDKMVP_UPDATE );
    #endif

    return DD_OK;
}

/*
 * InternalStopVideo
 */
HRESULT InternalStopVideo( LPDDRAWI_DDVIDEOPORT_INT this_int )
{
    LPDDHALVPORTCB_UPDATE pfn;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDHAL_UPDATEVPORTDATA UpdateData;
    DWORD dwTemp2;
    DWORD dwTemp;
    DWORD rc;

    this_lcl = this_int->lpLcl;
    if( !( this_lcl->dwFlags & DDRAWIVPORT_ON ) )
    {
	// VPORT is not on
	return DD_OK;
    }

    /*
     * Notify  kernel mode of the change
     */
    dwTemp2 = this_lcl->dwFlags;
    this_lcl->dwFlags &= ~DDRAWIVPORT_ON;
    dwTemp = this_lcl->ddvpInfo.dwVPFlags;
    this_lcl->ddvpInfo.dwVPFlags &= ~DDVP_AUTOFLIP;
    this_lcl->dwNumAutoflip = 0;
    this_lcl->dwNumVBIAutoflip = 0;
    #ifdef WIN95
        UpdateKernelVideoPort( this_lcl, DDKMVP_UPDATE );
    #endif
    this_lcl->ddvpInfo.dwVPFlags = dwTemp;
    this_lcl->dwFlags = dwTemp2;

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.UpdateVideoPort;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
	memset( &UpdateData, 0, sizeof( UpdateData ) );
    	UpdateData.lpDD = this_lcl->lpDD;
    	UpdateData.lpVideoPort = this_lcl;
    	UpdateData.lpVideoInfo = &(this_lcl->ddvpInfo);
    	UpdateData.dwFlags = DDRAWI_VPORTSTOP;
    	UpdateData.dwNumAutoflip = 0;
    	UpdateData.dwNumVBIAutoflip = 0;
    	UpdateData.lplpDDSurface = NULL;
	dwTemp = this_lcl->ddvpInfo.dwVPFlags;
	this_lcl->ddvpInfo.dwVPFlags &= ~DDVP_AUTOFLIP;

	DOHALCALL( UpdateVideoPort, pfn, UpdateData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    this_lcl->ddvpInfo.dwVPFlags = dwTemp;
	    return DDERR_UNSUPPORTED;
	}
	else if( DD_OK != UpdateData.ddRVal )
	{
	    this_lcl->ddvpInfo.dwVPFlags = dwTemp;
	    return UpdateData.ddRVal;
	}
    	this_lcl->dwFlags &= ~DDRAWIVPORT_ON;
	this_lcl->ddvpInfo.dwVPFlags = dwTemp;
    }
    else
    {
	return DDERR_UNSUPPORTED;
    }

    /*
     * Update the surfaces and release implicit kernel handles.
     */
    if( this_lcl->lpSurface != NULL )
    {
        ReleaseVPESurfaces( this_lcl->lpSurface, TRUE );
    }
    if( this_lcl->lpVBISurface != NULL )
    {
	ReleaseVPESurfaces( this_lcl->lpVBISurface, TRUE );
    }

    return DD_OK;
}

/*
 * InternalUpdateVideo
 */
HRESULT InternalUpdateVideo(LPDDRAWI_DDVIDEOPORT_INT this_int,
    LPDDVIDEOPORTINFO lpInfo )
{
    LPDDHALVPORTCB_UPDATE pfn;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDHAL_UPDATEVPORTDATA UpdateData;
    LPDDRAWI_DDRAWSURFACE_INT *lpTempFlipInts;
    LPDDVIDEOPORTCAPS lpAvailCaps;
    DWORD dwTempNumAutoFlip;
    DWORD dwTempNumVBIAutoFlip;
    DWORD rc;
    DWORD dwNumAutoFlip;
    DWORD dwNumVBIAutoFlip;
    DWORD dwTemp;

    /*
     * Validate the input parameters
     */
    rc = ValidateVideoInfo( this_int, lpInfo, &dwNumAutoFlip, &dwNumVBIAutoFlip );
    if( DD_OK != rc )
    {
	return rc;
    }
    this_lcl = this_int->lpLcl;
    lpAvailCaps = &(this_lcl->lpDD->lpGbl->lpDDVideoPortCaps[this_lcl->ddvpDesc.dwVideoPortID]);

    if( !( this_lcl->dwFlags & DDRAWIVPORT_ON ) )
    {
	// VPORT is not on - nothing to update
	return DD_OK;
    }

    /*
     * Setup the autoflip surfaces
     */
    lpTempFlipInts = NULL;
    if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
    {
	DWORD dwCnt;

	lpTempFlipInts = this_lcl->lpFlipInts;
	this_lcl->lpFlipInts = MemAlloc( sizeof( LPDDRAWI_DDRAWSURFACE_INT ) *
	    ( dwNumAutoFlip + dwNumVBIAutoFlip ) );
	if( NULL == this_lcl->lpFlipInts )
	{
	    DPF_ERR( "insufficient memory" );
	    this_lcl->lpFlipInts = lpTempFlipInts;
	    return DDERR_OUTOFMEMORY;
	}

	/*
	 * Now put the surface INTs into the array.
	 */
	if( dwNumAutoFlip )
	{
	    rc = FillFlipArray( this_lcl->lpFlipInts, this_lcl->lpSurface, &dwCnt );
	    if( rc != DD_OK )
	    {
		MemFree( this_lcl->lpFlipInts );
		this_lcl->lpFlipInts = lpTempFlipInts;
		return rc;
	    }
	    DDASSERT( dwCnt == dwNumAutoFlip );

	    if( dwNumAutoFlip > lpAvailCaps->dwNumAutoFlipSurfaces )
	    {
		DPF_ERR( "Too many autoflip surfaces" );
		MemFree( this_lcl->lpFlipInts );
		this_lcl->lpFlipInts = lpTempFlipInts;
		return DDERR_INVALIDPARAMS;
	    }
	}

	/*
	 * Now put the VBI surface INTs into the array.
	 */
	if( dwNumVBIAutoFlip )
	{
	    rc = FillFlipArray( &(this_lcl->lpFlipInts[dwNumAutoFlip]),
	    	this_lcl->lpVBISurface, &dwCnt );
	    if( rc != DD_OK )
	    {
	    	MemFree( this_lcl->lpFlipInts );
	    	this_lcl->lpFlipInts = lpTempFlipInts;
	    	return rc;
	    }
	    DDASSERT( dwCnt == dwNumVBIAutoFlip );

	    if( dwNumVBIAutoFlip > lpAvailCaps->dwNumVBIAutoFlipSurfaces )
	    {
		DPF_ERR( "Too many VBI autoflip surfaces" );
		MemFree( this_lcl->lpFlipInts );
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
    dwTempNumAutoFlip = this_lcl->dwNumAutoflip;
    dwTempNumVBIAutoFlip = this_lcl->dwNumVBIAutoflip;
    this_lcl->dwNumAutoflip = dwNumAutoFlip;
    this_lcl->dwNumVBIAutoflip = dwNumVBIAutoFlip;

    /*
     * The kernel interface may have switched from hardware autoflipping
     * to software autoflipping w/o us knowing.  We need to check for
     * this.
     */
    #ifdef WIN95
        if( ( lpInfo->dwVPFlags & DDVP_AUTOFLIP ) &&
    	    ( this_lcl->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP ) &&
    	    ( ( this_lcl->lpSurface != NULL ) || ( this_lcl->lpVBISurface != NULL ) ) )
        {
	    DWORD dwState;

	    dwState = 0;
	    if( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON )
	    {
	        GetKernelSurfaceState( this_lcl->lpSurface->lpLcl, &dwState );
	    }
	    else
	    {
	        GetKernelSurfaceState( this_lcl->lpVBISurface->lpLcl, &dwState );
	    }
	    if( dwState & DDSTATE_SOFTWARE_AUTOFLIP )
	    {
    	        this_lcl->dwFlags |= DDRAWIVPORT_SOFTWARE_AUTOFLIP;
	    }
        }
    #endif

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.UpdateVideoPort;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
	memset( &UpdateData, 0, sizeof( UpdateData ) );
    	UpdateData.lpDD = this_lcl->lpDD;
    	UpdateData.lpVideoPort = this_lcl;
    	UpdateData.lpVideoInfo = lpInfo;
    	UpdateData.dwFlags = DDRAWI_VPORTSTART;
	if( dwNumAutoFlip && ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    UpdateData.lplpDDSurface = this_lcl->lpFlipInts;
	    UpdateData.dwNumAutoflip = dwNumAutoFlip;
	}
	else if( this_lcl->lpSurface && ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    UpdateData.lplpDDSurface = &(this_lcl->lpSurface);
	}
	else
	{
	    UpdateData.lplpDDSurface = NULL;
	}
	if( dwNumVBIAutoFlip && ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    UpdateData.lplpDDVBISurface =
		&(this_lcl->lpFlipInts[this_lcl->dwNumAutoflip]);
    	    UpdateData.dwNumVBIAutoflip = dwNumVBIAutoFlip;
	}
	else if( this_lcl->lpVBISurface && ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    UpdateData.lplpDDVBISurface = &(this_lcl->lpVBISurface);
	}
	else
	{
	    UpdateData.lplpDDVBISurface = NULL;
	}
	dwTemp = lpInfo->dwVPFlags;
    	if( this_lcl->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP )
	{
	    lpInfo->dwVPFlags &= ~DDVP_AUTOFLIP;
	}
#ifdef WIN95
        if( this_lcl->lpSurface != NULL )
        {
            OverrideVideoPort( this_lcl->lpSurface, &(lpInfo->dwVPFlags) );
        }
#endif

	DOHALCALL( UpdateVideoPort, pfn, UpdateData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    lpInfo->dwVPFlags = dwTemp;
	    if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
	    {
		MemFree( this_lcl->lpFlipInts );
	    	this_lcl->lpFlipInts = lpTempFlipInts;
                this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
                this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	    }
	    return DDERR_UNSUPPORTED;
	}
	else if( DD_OK != UpdateData.ddRVal )
	{
	    /*
	     * If we failed due to hardware autoflipping, try again w/o
	     */
	    if( ( lpInfo->dwVPFlags & DDVP_AUTOFLIP ) ||
	    	CanSoftwareAutoflip( this_lcl ) )
	    {
	    	lpInfo->dwVPFlags &= ~DDVP_AUTOFLIP;
	    	DOHALCALL( UpdateVideoPort, pfn, UpdateData, rc, 0 );
	    	if( ( DDHAL_DRIVER_HANDLED != rc ) &&
		    ( DD_OK != UpdateData.ddRVal ) )
	    	{
		    lpInfo->dwVPFlags = dwTemp;
		    MemFree( this_lcl->lpFlipInts );
	    	    this_lcl->lpFlipInts = lpTempFlipInts;
		    this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
		    this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	    	    return UpdateData.ddRVal;
	    	}
    	    	this_lcl->dwFlags |= DDRAWIVPORT_SOFTWARE_AUTOFLIP;
	    }
	    else
	    {
	    	lpInfo->dwVPFlags = dwTemp;
	    	if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
	    	{
		    MemFree( this_lcl->lpFlipInts );
	    	    this_lcl->lpFlipInts = lpTempFlipInts;
		    this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
		    this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	    	}
	    	return UpdateData.ddRVal;
	    }
	}
	MemFree( lpTempFlipInts );
	lpTempFlipInts = NULL;
	lpInfo->dwVPFlags = dwTemp;

	/*
	 * If they are changing to or from autoflipping, we need to update
	 * the surfaces.
	 */
	if( ( dwNumAutoFlip > dwTempNumAutoFlip ) &&
	    ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    DDASSERT( this_lcl->lpSurface != NULL );
	    PrepareVPESurfaces( this_lcl->lpSurface, this_lcl, TRUE );
	}
	if( ( dwNumVBIAutoFlip > dwTempNumVBIAutoFlip ) &&
	    ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    DDASSERT( this_lcl->lpVBISurface != NULL );
	    PrepareVPESurfaces( this_lcl->lpVBISurface, this_lcl, TRUE );
	}
	if( ( dwNumAutoFlip < dwTempNumAutoFlip ) &&
	    ( this_lcl->dwFlags & DDRAWIVPORT_VIDEOON ) )
	{
	    DDASSERT( this_lcl->lpSurface != NULL );
	    ReleaseVPESurfaces( this_lcl->lpSurface, FALSE );
	    PrepareVPESurfaces( this_lcl->lpSurface, this_lcl, FALSE );
	}
	if( ( dwNumVBIAutoFlip < dwTempNumVBIAutoFlip ) &&
	    ( this_lcl->dwFlags & DDRAWIVPORT_VBION ) )
	{
	    DDASSERT( this_lcl->lpVBISurface != NULL );
	    ReleaseVPESurfaces( this_lcl->lpVBISurface, FALSE );
	    PrepareVPESurfaces( this_lcl->lpVBISurface, this_lcl, FALSE );
	}

	UpdateInterleavedFlags( this_lcl, lpInfo->dwVPFlags );
	memcpy( &(this_lcl->ddvpInfo), lpInfo, sizeof( DDVIDEOPORTINFO ) );
	if( NULL != lpInfo->lpddpfInputFormat )
	{
	    this_lcl->ddvpInfo.lpddpfInputFormat = (LPDDPIXELFORMAT)
    		((LPBYTE)this_lcl +
    		sizeof( DDRAWI_DDVIDEOPORT_LCL ) );
	    memcpy( this_lcl->ddvpInfo.lpddpfInputFormat,
	    lpInfo->lpddpfInputFormat, sizeof( DDPIXELFORMAT ) );
	}
    }
    else
    {
	this_lcl->dwNumAutoflip = dwTempNumAutoFlip;
	this_lcl->dwNumVBIAutoflip = dwTempNumVBIAutoFlip;
	if( lpInfo->dwVPFlags & DDVP_AUTOFLIP )
	{
	    MemFree( this_lcl->lpFlipInts );
	    this_lcl->lpFlipInts = lpTempFlipInts;
	}
	return DDERR_UNSUPPORTED;
    }

    /*
     * Notify  kernel mode of the change
     */
    #ifdef WIN95
        UpdateKernelVideoPort( this_lcl, DDKMVP_UPDATE );
    #endif

    return DD_OK;
}


/*
 * DD_VP_StartVideo
 */
HRESULT DDAPI DD_VP_StartVideo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDVIDEOPORTINFO lpInfo )
{
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    DDVIDEOPORTINFO TempInfo;
    DWORD dwTempFlags;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_StartVideo");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	if( (NULL == lpInfo) || !VALID_DDVIDEOPORTINFO_PTR( lpInfo ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( lpInfo->dwReserved1 != 0 ) ||
	    ( lpInfo->dwReserved2 != 0 ) )
	{
	    DPF_ERR( "Reserved field not set to zero" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    if( (NULL == lpInfo->lpddpfVBIInputFormat) ||
		!VALID_DDPIXELFORMAT_PTR( lpInfo->lpddpfVBIInputFormat ) )
	    {
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else if( (NULL == lpInfo->lpddpfInputFormat) ||
	    !VALID_DDPIXELFORMAT_PTR( lpInfo->lpddpfInputFormat ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    dwTempFlags = this_int->lpLcl->dwFlags;
    if( this_int->dwFlags )
    {
	rc = MergeVPInfo( this_int->lpLcl,
	    this_int->dwFlags & DDVPCREATE_VBIONLY ? lpInfo : this_int->lpLcl->lpVBIInfo,
	    this_int->dwFlags & DDVPCREATE_VIDEOONLY ? lpInfo : this_int->lpLcl->lpVideoInfo,
	    &TempInfo );
	if( rc == DD_OK )
	{
	    if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	    {
		this_int->lpLcl->dwFlags |= DDRAWIVPORT_VBION;
	    }
	    else
	    {
		this_int->lpLcl->dwFlags |= DDRAWIVPORT_VIDEOON;
	    }
	    rc = InternalStartVideo( this_int, &TempInfo );
	}
    }
    else
    {
	this_int->lpLcl->dwFlags |= DDRAWIVPORT_VIDEOON | DDRAWIVPORT_VBION;
	rc = InternalStartVideo( this_int, lpInfo );
    }

    if( ( rc == DD_OK ) && this_int->dwFlags )
    {
	/*
	 * Save the original info
	 */
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    if( this_int->lpLcl->lpVBIInfo == NULL )
	    {
	    	this_int->lpLcl->lpVBIInfo = MemAlloc( sizeof( TempInfo ) +
		    ( 2 * sizeof( DDPIXELFORMAT)) );
	    }
	    if( this_int->lpLcl->lpVBIInfo != NULL )
	    {
		memcpy( this_int->lpLcl->lpVBIInfo, lpInfo, sizeof( TempInfo ) );
		this_int->lpLcl->lpVBIInfo->lpddpfVBIInputFormat = (LPDDPIXELFORMAT)
		    ((LPBYTE)this_int->lpLcl->lpVBIInfo + sizeof( DDVIDEOPORTINFO ));
		this_int->lpLcl->lpVBIInfo->lpddpfVBIOutputFormat = (LPDDPIXELFORMAT)
		    ((LPBYTE)this_int->lpLcl->lpVBIInfo + sizeof( DDVIDEOPORTINFO ) +
		    sizeof( DDPIXELFORMAT ) );
		memcpy( this_int->lpLcl->lpVBIInfo->lpddpfVBIInputFormat,
		    lpInfo->lpddpfVBIInputFormat, sizeof( DDPIXELFORMAT ) );
		if( lpInfo->lpddpfVBIOutputFormat != NULL )
		{
		    memcpy( this_int->lpLcl->lpVBIInfo->lpddpfVBIOutputFormat,
			lpInfo->lpddpfVBIOutputFormat, sizeof( DDPIXELFORMAT ) );
		}
	    }
	}
	else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
	{
	    if( this_int->lpLcl->lpVideoInfo == NULL )
	    {
	    	this_int->lpLcl->lpVideoInfo = MemAlloc( sizeof( TempInfo ) );
	    }
	    if( this_int->lpLcl->lpVideoInfo != NULL )
	    {
		memcpy( this_int->lpLcl->lpVideoInfo, lpInfo, sizeof( TempInfo ) );
		this_int->lpLcl->lpVideoInfo->lpddpfInputFormat =
		    this_int->lpLcl->ddvpInfo.lpddpfInputFormat;
	    }
	}
    }
    else if( rc != DD_OK )
    {
	this_int->lpLcl->dwFlags = dwTempFlags;
    }

    LEAVE_DDRAW();

    return rc;
}


/*
 * DD_VP_StopVideo
 */
HRESULT DDAPI DD_VP_StopVideo(LPDIRECTDRAWVIDEOPORT lpDVP )
{
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDVIDEOPORTINFO TempInfo;
    BOOL bChanged;
    DWORD rc = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_StopVideo");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
	this_lcl = this_int->lpLcl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Three special things are done for VBI/Video-only video ports:
     * 1. Remove the lpVBI/VideoInfo reference so we know we are no
     *    longer on.
     * 2. If the other interface is running, instead of stoping the
     *    video stream, we simply crop it out so the other stream can
     *    continue un-interrupted.
     * 3. Release the kernel handles.
     */
    if( this_int->dwFlags )
    {
	bChanged = FALSE;
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    if( this_lcl->lpVBIInfo != NULL )
	    {
	        MemFree( this_lcl->lpVBIInfo );
	        this_lcl->lpVBIInfo = NULL;
	        bChanged = TRUE;
	    }
	    if( this_lcl->lpVBISurface != NULL )
	    {
		ReleaseVPESurfaces( this_lcl->lpVBISurface, TRUE );
    	    }
	    this_lcl->dwFlags &= ~DDRAWIVPORT_VBION;
	}
	else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
	{
	    if( this_lcl->lpVideoInfo != NULL )
	    {
	        MemFree( this_lcl->lpVideoInfo );
	        this_lcl->lpVideoInfo = NULL;
	        bChanged = TRUE;
	    }
	    if( this_lcl->lpSurface != NULL )
	    {
		ReleaseVPESurfaces( this_lcl->lpSurface, TRUE );
    	    }
	    this_lcl->dwFlags &= ~DDRAWIVPORT_VIDEOON;
	}
	if( bChanged && ( ( this_lcl->lpVideoInfo != NULL ) ||
	    ( this_lcl->lpVBIInfo != NULL ) ) )
	{
	    rc = MergeVPInfo( this_lcl,
		this_lcl->lpVBIInfo,
		this_lcl->lpVideoInfo,
		&TempInfo );
	    if( rc == DD_OK )
	    {
		rc = InternalUpdateVideo( this_int, &TempInfo );
	    }
	}
	else if( bChanged )
	{
	    rc = InternalStopVideo( this_int );
	}
    }
    else
    {
	this_lcl->dwFlags &= ~( DDRAWIVPORT_VIDEOON | DDRAWIVPORT_VBION );
	rc = InternalStopVideo( this_int );
    }

    LEAVE_DDRAW();

    return rc;
}

/*
 * DD_VP_UpdateVideo
 */
HRESULT DDAPI DD_VP_UpdateVideo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDVIDEOPORTINFO lpInfo )
{
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    DDVIDEOPORTINFO TempInfo;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_UpdateVideo");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	if( (NULL == lpInfo) || !VALID_DDVIDEOPORTINFO_PTR( lpInfo ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( lpInfo->dwReserved1 != 0 ) ||
	    ( lpInfo->dwReserved2 != 0 ) )
	{
	    DPF_ERR( "Reserved field not set to zero" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    if( (NULL == lpInfo->lpddpfVBIInputFormat) ||
		!VALID_DDPIXELFORMAT_PTR( lpInfo->lpddpfVBIInputFormat ) )
	    {
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else if( (NULL == lpInfo->lpddpfInputFormat) ||
	    !VALID_DDPIXELFORMAT_PTR( lpInfo->lpddpfInputFormat ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    if( this_int->dwFlags )
    {
	rc = MergeVPInfo( this_int->lpLcl,
	    this_int->dwFlags & DDVPCREATE_VBIONLY ? lpInfo : this_int->lpLcl->lpVBIInfo,
	    this_int->dwFlags & DDVPCREATE_VIDEOONLY ? lpInfo : this_int->lpLcl->lpVideoInfo,
	    &TempInfo );
	if( rc == DD_OK )
	{
	    rc = InternalUpdateVideo( this_int, &TempInfo );
	}
    }
    else
    {
	rc = InternalUpdateVideo( this_int, lpInfo );
    }

    if( ( rc == DD_OK ) && this_int->dwFlags )
    {
	/*
	 * Save the original info
	 */
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    if( this_int->lpLcl->lpVBIInfo != NULL )
	    {
		memcpy( this_int->lpLcl->lpVBIInfo, lpInfo, sizeof( TempInfo ) );
		this_int->lpLcl->lpVBIInfo->lpddpfVBIInputFormat = (LPDDPIXELFORMAT)
		    ((LPBYTE)this_int->lpLcl->lpVBIInfo + sizeof( DDVIDEOPORTINFO ));
		this_int->lpLcl->lpVBIInfo->lpddpfVBIOutputFormat = (LPDDPIXELFORMAT)
		    ((LPBYTE)this_int->lpLcl->lpVBIInfo + sizeof( DDVIDEOPORTINFO ) +
		    sizeof( DDPIXELFORMAT ) );
		memcpy( this_int->lpLcl->lpVBIInfo->lpddpfVBIInputFormat,
		    lpInfo->lpddpfVBIInputFormat, sizeof( DDPIXELFORMAT ) );
		if( lpInfo->lpddpfVBIOutputFormat != NULL )
		{
		    memcpy( this_int->lpLcl->lpVBIInfo->lpddpfVBIOutputFormat,
			lpInfo->lpddpfVBIOutputFormat, sizeof( DDPIXELFORMAT ) );
		}
	    }
	}
	else if( this_int->dwFlags & DDVPCREATE_VIDEOONLY )
	{
	    if( this_int->lpLcl->lpVideoInfo != NULL )
	    {
		memcpy( this_int->lpLcl->lpVideoInfo, lpInfo, sizeof( TempInfo ) );
		this_int->lpLcl->lpVideoInfo->lpddpfInputFormat =
		    this_int->lpLcl->ddvpInfo.lpddpfInputFormat;
	    }
	}
    }

    LEAVE_DDRAW();

    return rc;
}

/*
 * DD_VP_WaitForSync
 */
HRESULT DDAPI DD_VP_WaitForSync(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwFlags, DWORD dwLine, DWORD dwTimeOut )
{
    LPDDHALVPORTCB_WAITFORSYNC pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DWORD rc;
    DDHAL_WAITFORVPORTSYNCDATA WaitSyncData;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_WaitForSync");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    if( !dwFlags || ( dwFlags > 3 ) )
    {
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.WaitForVideoPortSync;
    if( pfn != NULL )
    {
    	WaitSyncData.lpDD = this_lcl->lpDD;
    	WaitSyncData.lpVideoPort = this_lcl;
    	WaitSyncData.dwFlags = dwFlags;
    	WaitSyncData.dwLine = dwLine;
	if( dwTimeOut != 0 )
	{
    	    WaitSyncData.dwTimeOut = dwTimeOut;
	}
	else
	{
    	    WaitSyncData.dwTimeOut = this_lcl->ddvpDesc.dwMicrosecondsPerField * 3;
	}

	DOHALCALL( WaitForVideoPortSync, pfn, WaitSyncData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return WaitSyncData.ddRVal;
}


/*
 * DD_VP_GetSignalStatus
 */
HRESULT DDAPI DD_VP_GetSignalStatus(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwStatus )
{
    LPDDHALVPORTCB_GETSIGNALSTATUS pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDHAL_GETVPORTSIGNALDATA GetSignalData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_GetSignalStatus");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (NULL == lpdwStatus ) || !VALID_DWORD_PTR( lpdwStatus ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.GetVideoSignalStatus;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
    	GetSignalData.lpDD = this_lcl->lpDD;
    	GetSignalData.lpVideoPort = this_lcl;
    	GetSignalData.dwStatus = DDVPSQ_NOSIGNAL;	// Let the HAL tell us otherwise

	DOHALCALL( GetVideoSignalStatus, pfn, GetSignalData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != GetSignalData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetSignalData.ddRVal;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }
    *lpdwStatus = GetSignalData.dwStatus;

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * DD_VP_GetColorControls
 */
HRESULT DDAPI DD_VP_GetColorControls(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDCOLORCONTROL lpColor )
{
    LPDDHALVPORTCB_COLORCONTROL pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDHAL_VPORTCOLORDATA ColorData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_GetColorControls");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (NULL == lpColor ) || !VALID_DDCOLORCONTROL_PTR( lpColor ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    DPF_ERR( "Unable to set color controls on a VBI-only video port" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.ColorControl;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
    	ColorData.lpDD = this_lcl->lpDD;
    	ColorData.lpVideoPort = this_lcl;
	ColorData.dwFlags = DDRAWI_VPORTGETCOLOR;
	ColorData.lpColorData = lpColor;

	DOHALCALL( VideoColorControl, pfn, ColorData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != ColorData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return ColorData.ddRVal;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * DD_VP_SetColorControls
 */
HRESULT DDAPI DD_VP_SetColorControls(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDCOLORCONTROL lpColor )
{
    LPDDHALVPORTCB_COLORCONTROL pfn;
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    DDHAL_VPORTCOLORDATA ColorData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_SetColorControls");

    /*
     * Don't allow access to this function if called from within the
     * the EnumVideoPort callback.
     */
    if( bInEnumCallback )
    {
        DPF_ERR ( "This function cannot be called from within the EnumVideoPort callback!");
	LEAVE_DDRAW();
	return DDERR_CURRENTLYNOTAVAIL;
    }

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpDVP;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (NULL == lpColor ) || !VALID_DDCOLORCONTROL_PTR( lpColor ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( this_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    DPF_ERR( "Unable to set color controls on a VBI-only video port" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_lcl->lpDD->lpDDCB->HALDDVideoPort.ColorControl;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
    	ColorData.lpDD = this_lcl->lpDD;
    	ColorData.lpVideoPort = this_lcl;
	ColorData.dwFlags = DDRAWI_VPORTSETCOLOR;
	ColorData.lpColorData = lpColor;

	DOHALCALL( VideoColorControl, pfn, ColorData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != ColorData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return ColorData.ddRVal;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * GetSurfaceFormat
 *
 * Fills in the DDPIXELFORMAT structure with the surface's format
 */
LPDDPIXELFORMAT GetSurfaceFormat( LPDDRAWI_DDRAWSURFACE_LCL surf_lcl )
{
    if( surf_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
    {
	return &(surf_lcl->lpGbl->ddpfSurface);
    }
    else
    {
	return &(surf_lcl->lpSurfMore->lpDD_lcl->lpGbl->vmiData.ddpfDisplay);
    }
    return NULL;
}


/*
 * CreateVideoPortNotify
 */
HRESULT CreateVideoPortNotify( LPDDRAWI_DDVIDEOPORT_INT lpDDVPInt, LPDIRECTDRAWVIDEOPORTNOTIFY *lplpVPNotify )
{
#ifdef WINNT
    OSVERSIONINFOEX             osvi;
    DWORDLONG                   dwlConditionMask = 0;
    LPDDRAWI_DDVIDEOPORT_INT    lpInt;
#endif

    *lplpVPNotify = NULL;

#ifdef WIN95
    // This is available on Win9X
    return DDERR_UNSUPPORTED;
#else
    // This is only available on whistler

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osvi.dwMajorVersion = 5;
    osvi.dwMinorVersion = 1;

    VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, 
        VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, 
        VER_GREATER_EQUAL );

    if (!VerifyVersionInfo(&osvi, VER_MAJORVERSION|VER_MINORVERSION, dwlConditionMask))
    {
        return DDERR_UNSUPPORTED;
    }

    // Only one notification interface can be active at any time for a single
    // video port

    if (lpDDVPInt->lpLcl->lpVPNotify != NULL)
    {
        DPF_ERR("A IDirectDrawVideoPortNotify interface already exists for this video port");
        return DDERR_CURRENTLYNOTAVAIL;
    }

    lpInt = MemAlloc(sizeof(DDRAWI_DDVIDEOPORT_INT));
    if (lpInt == NULL)
    {
        return DDERR_OUTOFMEMORY;
    }
    lpInt->lpVtbl = (LPVOID)&ddVideoPortNotifyCallbacks;
    lpInt->lpLcl = lpDDVPInt->lpLcl;
    lpInt->dwFlags = DDVPCREATE_NOTIFY | lpDDVPInt->dwFlags;

    DD_VP_AddRef( (LPDIRECTDRAWVIDEOPORT )lpInt );
    *lplpVPNotify = (LPDIRECTDRAWVIDEOPORTNOTIFY) lpInt;

    lpInt->lpLink = lpDDVPInt->lpLcl->lpDD->lpGbl->dvpList;
    lpDDVPInt->lpLcl->lpDD->lpGbl->dvpList = lpInt;
#endif
    return DD_OK;
}


/*
 * DDAPI DD_VP_Notify_AcquireNotification
 */
HRESULT DDAPI DD_VP_Notify_AcquireNotification( LPDIRECTDRAWVIDEOPORTNOTIFY lpNotify, HANDLE* pEvent, LPDDVIDEOPORTNOTIFY pBuffer )
{
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;
    HRESULT                  rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_Notify_AcquireNotification");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpNotify;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	if( (pBuffer == NULL) || !VALID_DDVIDEOPORTNOTIFY_PTR( pBuffer ) )
    	{
	    DPF_ERR( "Invalid LPDDVIDEOPORTNOTIFY specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( (pEvent == NULL) || !VALID_HANDLE_PTR( pEvent ) )
    	{
	    DPF_ERR( "Invalid event handle ptr specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    *pEvent = NULL;
    rc = DDERR_UNSUPPORTED;

#ifdef WINNT
    this_lcl->lpDD->lpGbl->lpDDCBtmp->HALDDVPE2.AcquireNotification(this_lcl, pEvent, pBuffer);
    if (*pEvent != NULL)
    {
        rc = DD_OK;
    }
#endif

    LEAVE_DDRAW();

    return rc;
}


/*
 * DDAPI DD_VP_Notify_AcquireNotification
 */
HRESULT DDAPI DD_VP_Notify_ReleaseNotification( LPDIRECTDRAWVIDEOPORTNOTIFY lpNotify, HANDLE pEvent )
{
    LPDDRAWI_DDVIDEOPORT_INT this_int;
    LPDDRAWI_DDVIDEOPORT_LCL this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_VP_Notify_ReleaseNotification");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDVIDEOPORT_INT) lpNotify;
    	if( !VALID_DDVIDEOPORT_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

#ifdef WINNT
    this_lcl->lpDD->lpGbl->lpDDCBtmp->HALDDVPE2.ReleaseNotification(this_lcl, pEvent);
#endif

    LEAVE_DDRAW();

    return DD_OK;
}


/*
 * ProcessVideoPortCleanup
 *
 * A process is done, clean up any videoports that it may have locked.
 *
 * NOTE: we enter with a lock taken on the DIRECTDRAW object.
 */
void ProcessVideoPortCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDVIDEOPORT_INT	pvport_int;
    LPDDRAWI_DDVIDEOPORT_LCL	pvport_lcl;
    LPDDRAWI_DDVIDEOPORT_INT	pvpnext_int;
    DWORD			rcnt;
    ULONG			rc;
    DWORD			vp_id;

    /*
     * run through all videoports owned by the driver object, and find ones
     * that have been accessed by this process.  If the pdrv_lcl parameter
     * is non-null, only delete videoports created by that local driver object.
     */
    pvport_int = pdrv->dvpList;
    DPF( 4, "ProcessVideoPortCleanup" );
    while( pvport_int != NULL )
    {
	pvport_lcl = pvport_int->lpLcl;
	pvpnext_int = pvport_int->lpLink;
	rc = 1;
	if( pvport_int->dwFlags & DDVPCREATE_VBIONLY )
	{
	    vp_id = pvport_lcl->dwVBIProcessID;
	}
	else
	{
	    vp_id = pvport_lcl->dwProcessID;
	}
	if( ( vp_id == pid ) &&
	    ( (NULL == pdrv_lcl) || (pvport_lcl->lpDD == pdrv_lcl) ) )
	{
	    /*
	     * release the references by this process
	     */
	    rcnt = pvport_int->dwIntRefCnt;
	    DPF( 5, "Process %08lx had %ld accesses to videoport %08lx", pid, rcnt, pvport_int );
	    while( rcnt >  0 )
	    {
		DD_VP_Release( (LPDIRECTDRAWVIDEOPORT) pvport_int );
		pvpnext_int = pdrv->dvpList;
		if( rc == 0 )
		{
		    break;
		}
		rcnt--;
	    }
	}
	else
	{
	    DPF( 5, "Process %08lx had no accesses to videoport %08lx", pid, pvport_int );
	}
	pvport_int = pvpnext_int;
    }
    DPF( 4, "Leaving ProcessVideoPortCleanup");

} /* ProcessVideoPortCleanup */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddsiunk.c ===
/*==========================================================================
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddsiunk.c
 *  Content:	DirectDraw surface IUnknown interface
 *		Implements QueryInterface, AddRef, and Release
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   12-mar-95	craige	split out of ddsurf.c; enhanced
 *   19-mar-95	craige	use HRESULTs
 *   28-mar-95	craige	use GETCURRPID
 *   01-apr-95	craige	happy fun joy updated header file
 *   07-apr-95	craige	bug 14 - check GUID ptr in QI
 *   09-apr-95	craige	release Win16Lock
 *   06-may-95	craige	use driver-level csects only
 *   12-may-95	craige	check for real guids in QI
 *   19-may-95	craige	free surface memory at the right time
 *   23-may-95	craige	no longer use MapLS_Pool
 *   24-may-95  kylej   add dirty rect when emulated overlay is released
 *   02-jun-95	craige	redraw primary whenever a process does last release
 *   12-jun-95	craige	new process list stuff
 *   16-jun-95	craige	new surface structure
 *   18-jun-95	craige	allow duplicate surfaces; creation of new interfaces
 *   20-jun-95	craige	need to check fpVidMemOrig for deciding to flip
 *   21-jun-95	craige	new streaming interface; work around compiler bug
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns; hide overlays
 *			when destroyed if they're still visible
 *   30-jun-95  kylej   don't free primary surface vidmem
 *   01-jul-95	craige	removed streaming & composition stuff
 *   02-jul-95	craige	fleshed out NewSurfaceInterface
 *   04-jul-95	craige	YEEHAW: new driver struct; SEH
 *   08-jul-95	craige	track invalid vs free
 *   19-jul-95	craige	need to allow AddRef of lost surfaces
 *   17-aug-95	craige	bug 557 - always turn off primay ptr in ddraw object
 *   05-sep-95	craige	bug 902: only remove locks if lclrefcnt hits zero
 *   10-sep-95	craige	bug 828: random vidmem heap free
 *   19-sep-95	craige	bug 1205: free first vidmem destroyed
 *   10-nov-95  colinmc support for shared, AddRef'd palettes
 *   23-nov-95  colinmc now supports aggregatable Direct3D textures and
 *                      devices
 *   09-dec-95  colinmc added execute buffer support
 *   17-dec-95  colinmc added shared back and z buffer support
 *   22-dec-95  colinmc Direct3D support no longer conditional
 *   02-jan-96	kylej	Handle new interface structs.
 *   10-jan-96  colinmc aggregated IUnknowns now maintained as a list
 *   13-jan-96  colinmc temporary hack to workround problem with Direct3D
 *                      cleanup
 *   26-jan-96  jeffno	NT kernel object cleanup, FlipToGDISurface only 1 arg
 *   29-jan-96  colinmc Aggregated IUnknowns now contained in additional
 *                      surface local data structure
 *   08-feb-96	colinmc	New D3D interface
 *   09-feb-96  colinmc Surface invalid flag moved from global to local
 *                      object
 *   13-mar-96  colinmc Added IID validation to QueryInterface
 *   16-mar-96  colinmc Fixed palette release problem (bug 13512)
 *   20-mar-96  colinmc Bug 13634: unidirectional attachments cause infinite
 *                      loop on cleanup
 *   23-mar-96  colinmc Bug 12252: Direct3D not cleaned up properly on
 *                      application termination
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   09-apr-96  colinmc Bug 16370: QueryInterface can fail with multiple
 *                      DirectDraw objects per process
 *   13-apr-96  colinmc Bug 17736: No notification to driver of flip to GDI
 *                      surface
 *   16-apr-96	kylej	Bug 18103: Apps which use overlays can fault in
 *			ProcessSurfaceCleanup
 *   29-apr-96  colinmc Bug 19954: Must query for Direct3D before textures
 *                      devices
 *   05-jul-96  colinmc Work Item: Remove requirement on taking Win16 lock
 *                      for VRAM surfaces (not primary)
 *   13-jan-97 jvanaken Basic support for IDirectDrawSurface3 interface
 *   29-jan-97  smac	Update video port struct when surface is released
 *   22-feb-97  colinmc Enabled OWNDC for explicit system memory surfaces
 *   03-mar-97  smac    Added kernel mode interface
 *   08-mar-97  colinmc Added function to allow surface pointer to be
 *                      overridden
 *   10-mar-97  smac	Fixed bug 5211 by hiding overlays in DestroySurface
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   05-nov-97 jvanaken Support for master sprite list in SetSpriteDisplayList
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
#endif

// function in ddsprite.c to remove invalid surface from master sprite list
extern void RemoveSpriteSurface(LPDDRAWI_DIRECTDRAW_GBL, LPDDRAWI_DDRAWSURFACE_INT);

#ifdef REFTRACKING

void AddRefTrack(LPVOID * p)
{
    LPDDRAWI_DDRAWSURFACE_INT pInt = (LPDDRAWI_DDRAWSURFACE_INT) *p;
    LPDDRAWI_REFTRACKNODE pNode;

    pInt->RefTrack.pLastAddref = *(p-1);    //This pulls the return address off the stack

    //Now store this addref in the linked list of addrefs/releases
    //Step 1: Search for previously existing addref/release with this ret address
    pNode = pInt->RefTrack.pHead;
    while (pNode)
    {
        if ( pNode->pReturnAddress == *(p-1) )
        {
            break;
        }
        pNode = pNode->pNext;
    }
    if (!pNode)
    {
        pNode = (LPDDRAWI_REFTRACKNODE) MemAlloc(sizeof(DDRAWI_REFTRACKNODE));
        pNode->pReturnAddress = *(p-1);
        pNode->pNext = pInt->RefTrack.pHead;
        pInt->RefTrack.pHead = pNode;
    }

    pNode->dwAddrefCount++;
}
void ReleaseTrack(LPVOID * p)
{
    LPDDRAWI_DDRAWSURFACE_INT pInt = (LPDDRAWI_DDRAWSURFACE_INT) *p;
    LPDDRAWI_REFTRACKNODE pNode;

    pInt->RefTrack.pLastRelease = *(p-1);    //This pulls the return address off the stack
    //Now store this release in the linked list of addrefs/releases
    //Step 1: Search for previously existing addref/release with this ret address
    pNode = pInt->RefTrack.pHead;
    while (pNode)
    {
        if ( pNode->pReturnAddress == *(p-1) )
        {
            break;
        }
        pNode = pNode->pNext;
    }
    if (!pNode)
    {
        pNode = (LPDDRAWI_REFTRACKNODE) MemAlloc(sizeof(DDRAWI_REFTRACKNODE));
        pNode->pReturnAddress = *(p-1);
        pNode->pNext = pInt->RefTrack.pHead;
        pInt->RefTrack.pHead = pNode;
    }
    pNode->dwReleaseCount++;
}
void DumpRefTrack(LPVOID p)
{
    LPDDRAWI_DDRAWSURFACE_INT pInt = (LPDDRAWI_DDRAWSURFACE_INT) p;
    LPDDRAWI_REFTRACKNODE pNode;
    char msg[100];

    wsprintf(msg,"Interface %08x:\r\n  LastAddRef:%08x\r\n  Last Release:%08x\r\n",
        pInt,
        pInt->RefTrack.pLastAddref,
        pInt->RefTrack.pLastRelease);
    OutputDebugString(msg);
    pNode = pInt->RefTrack.pHead;
    while (pNode)
    {
        wsprintf(msg,"   Address %08x had %d Addrefs and %d Releases\r\n",
            pNode->pReturnAddress,
            pNode->dwAddrefCount,
            pNode->dwReleaseCount);
        OutputDebugString(msg);
        pNode = pNode->pNext;
    }
}

#endif //REFTRACKING
/*
 * FindIUnknown
 *
 * Locate an aggredate IUnknown with the given IID (or NULL if no such
 * interface exists).
 */
static IUnknown FAR *FindIUnknown(LPDDRAWI_DDRAWSURFACE_LCL pThisLCL, REFIID riid)
{
    LPIUNKNOWN_LIST lpIUnknownNode;

    lpIUnknownNode = pThisLCL->lpSurfMore->lpIUnknowns;
    while( lpIUnknownNode != NULL )
    {
	if( IsEqualIID( riid, lpIUnknownNode->lpGuid ) )
	    return lpIUnknownNode->lpIUnknown;
	lpIUnknownNode = lpIUnknownNode->lpLink;
    }

    return NULL;
}

/*
 * InsertIUnknown
 *
 * Insert a new IUnknown with its associated IID into the IUnknown list of the
 * given surface.
 */
static LPIUNKNOWN_LIST InsertIUnknown(
			    LPDDRAWI_DDRAWSURFACE_LCL pThisLCL,
			    REFIID riid,
			    IUnknown FAR *lpIUnknown)
{
    LPIUNKNOWN_LIST lpIUnknownNode;

    DPF( 4, "Adding aggregated IUnknown %x", lpIUnknown );

    lpIUnknownNode = ( LPIUNKNOWN_LIST ) MemAlloc( sizeof( IUNKNOWN_LIST ) );
    if( lpIUnknownNode == NULL )
	return NULL;
    lpIUnknownNode->lpGuid = ( GUID FAR * ) MemAlloc( sizeof( GUID ) );
    if( lpIUnknownNode->lpGuid == NULL )
    {
	MemFree( lpIUnknownNode );
	return NULL;
    }
    memcpy( lpIUnknownNode->lpGuid, riid, sizeof( GUID ) );
    lpIUnknownNode->lpLink            = pThisLCL->lpSurfMore->lpIUnknowns;
    lpIUnknownNode->lpIUnknown        = lpIUnknown;
    pThisLCL->lpSurfMore->lpIUnknowns = lpIUnknownNode;

    return lpIUnknownNode;
}

/*
 * FreeIUnknowns
 *
 * Free all the nodes in the IUnknown list of the given local
 * surface object and NULL out the object's IUnknown list. If
 * fRelease is TRUE then release will be called on the IUnknown
 * interfaces.
 */
static void FreeIUnknowns( LPDDRAWI_DDRAWSURFACE_LCL pThisLCL, BOOL fRelease )
{
    LPIUNKNOWN_LIST lpIUnknownNode;
    LPIUNKNOWN_LIST lpLink;

    lpIUnknownNode = pThisLCL->lpSurfMore->lpIUnknowns;
    while( lpIUnknownNode != NULL )
    {
	lpLink = lpIUnknownNode->lpLink;
	if( fRelease )
	{
	    DPF( 4, "Releasing aggregated IUnknown %x", lpIUnknownNode->lpIUnknown );
	    lpIUnknownNode->lpIUnknown->lpVtbl->Release( lpIUnknownNode->lpIUnknown );
	}
	MemFree( lpIUnknownNode->lpGuid );
	MemFree( lpIUnknownNode );
	lpIUnknownNode = lpLink;
    }
    pThisLCL->lpSurfMore->lpIUnknowns = NULL;
}

/*
 * NewSurfaceLocal
 *
 * Construct a new surface local object.
 */
//Note: lpVtbl doesnt, seem to be used
LPDDRAWI_DDRAWSURFACE_LCL NewSurfaceLocal( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID lpvtbl )
{
    LPDDRAWI_DDRAWSURFACE_LCL	pnew_lcl;
    DWORD			surf_size_lcl;
    DWORD			surf_size;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;

    /*
     * NOTE: This single allocation can allocate space for local surface
     * structure (DDRAWI_DDRAWSURFACE_LCL) and the additional local surface
     * structure (DDRAWI_DDRAWSURFACE_MORE). As the local object can be
     * variable sized this can get pretty complex. The layout of the
     * various objects in the allocation is as follows:
     *
     * +-----------------+---------------+
     * | SURFACE_LCL     | SURFACE_MORE  |
     * | (variable)      |               |
     * +-----------------+---------------+
     * <- surf_size_lcl ->
     * <- surf_size --------------------->
     */
    if( this_lcl->dwFlags & DDRAWISURF_HASOVERLAYDATA )
    {
	DPF( 4, "OVERLAY DATA SPACE" );
	surf_size_lcl = sizeof( DDRAWI_DDRAWSURFACE_LCL );
    }
    else
    {
	surf_size_lcl = offsetof( DDRAWI_DDRAWSURFACE_LCL, ddckCKSrcOverlay );
    }

    surf_size = surf_size_lcl + sizeof( DDRAWI_DDRAWSURFACE_MORE );

    pnew_lcl = MemAlloc( surf_size );
    if( pnew_lcl == NULL )
    {
	return NULL;
    }
    pdrv = this_lcl->lpGbl->lpDD;

    /*
     * set up local data
     */
    pnew_lcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE) (((LPSTR) pnew_lcl) + surf_size_lcl);
    pnew_lcl->lpGbl = this_lcl->lpGbl;
    pnew_lcl->lpAttachList = NULL;
    pnew_lcl->lpAttachListFrom = NULL;
    pnew_lcl->dwProcessId = GetCurrentProcessId();
    pnew_lcl->dwLocalRefCnt = 0;
    pnew_lcl->dwFlags = this_lcl->dwFlags;
    pnew_lcl->ddsCaps = this_lcl->ddsCaps;
    pnew_lcl->lpDDPalette = NULL;
    pnew_lcl->lpDDClipper = NULL;
    pnew_lcl->lpSurfMore->lpDDIClipper = NULL;
    pnew_lcl->dwBackBufferCount = 0;
    pnew_lcl->ddckCKDestBlt.dwColorSpaceLowValue = 0;
    pnew_lcl->ddckCKDestBlt.dwColorSpaceHighValue = 0;
    pnew_lcl->ddckCKSrcBlt.dwColorSpaceLowValue = 0;
    pnew_lcl->ddckCKSrcBlt.dwColorSpaceHighValue = 0;
    pnew_lcl->dwReserved1 = this_lcl->dwReserved1;

    /*
     * set up overlay specific data
     */
    if( this_lcl->dwFlags & DDRAWISURF_HASOVERLAYDATA )
    {
	pnew_lcl->ddckCKDestOverlay.dwColorSpaceLowValue = 0;
	pnew_lcl->ddckCKDestOverlay.dwColorSpaceHighValue = 0;
	pnew_lcl->ddckCKSrcOverlay.dwColorSpaceLowValue = 0;
	pnew_lcl->ddckCKSrcOverlay.dwColorSpaceHighValue = 0;
	pnew_lcl->lpSurfaceOverlaying = NULL;
	pnew_lcl->rcOverlaySrc.top = 0;
	pnew_lcl->rcOverlaySrc.left = 0;
	pnew_lcl->rcOverlaySrc.bottom = 0;
	pnew_lcl->rcOverlaySrc.right = 0;
	pnew_lcl->rcOverlayDest.top = 0;
	pnew_lcl->rcOverlayDest.left = 0;
	pnew_lcl->rcOverlayDest.bottom = 0;
	pnew_lcl->rcOverlayDest.right = 0;
	pnew_lcl->dwClrXparent = 0;
	pnew_lcl->dwAlpha = 0;

	/*
	 * if this is an overlay, link it in
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
	{
	    pnew_lcl->dbnOverlayNode.next = pdrv->dbnOverlayRoot.next;
	    pnew_lcl->dbnOverlayNode.prev = (LPVOID)(&(pdrv->dbnOverlayRoot));
	    pdrv->dbnOverlayRoot.next = (LPVOID)(&(pnew_lcl->dbnOverlayNode));
	    pnew_lcl->dbnOverlayNode.next->prev = (LPVOID)(&(pnew_lcl->dbnOverlayNode));
//	    pnew_lcl->dbnOverlayNode.object = pnew_int;
	}
    }

    /*
     * turn off flags that aren't valid
     */
    pnew_lcl->dwFlags &= ~(DDRAWISURF_ATTACHED |
			   DDRAWISURF_ATTACHED_FROM |
			   DDRAWISURF_HASCKEYDESTOVERLAY |
			   DDRAWISURF_HASCKEYDESTBLT |
			   DDRAWISURF_HASCKEYSRCOVERLAY |
			   DDRAWISURF_HASCKEYSRCBLT |
			   DDRAWISURF_SW_CKEYDESTOVERLAY |
			   DDRAWISURF_SW_CKEYDESTBLT |
			   DDRAWISURF_SW_CKEYSRCOVERLAY |
			   DDRAWISURF_SW_CKEYSRCBLT |
			   DDRAWISURF_HW_CKEYDESTOVERLAY |
			   DDRAWISURF_HW_CKEYDESTBLT |
			   DDRAWISURF_HW_CKEYSRCOVERLAY |
			   DDRAWISURF_HW_CKEYSRCBLT |
			   DDRAWISURF_FRONTBUFFER |
			   DDRAWISURF_BACKBUFFER );

    /*
     * Additional local surface data.
     */
    pnew_lcl->lpSurfMore->dwSize      = sizeof( DDRAWI_DDRAWSURFACE_MORE );
    pnew_lcl->lpSurfMore->lpIUnknowns = NULL;
    pnew_lcl->lpSurfMore->lpDD_lcl = NULL;
    pnew_lcl->lpSurfMore->dwMipMapCount = 0UL;
#ifdef WIN95
    pnew_lcl->dwModeCreatedIn = this_lcl->dwModeCreatedIn;
#else
    pnew_lcl->lpSurfMore->dmiCreated = this_lcl->lpSurfMore->dmiCreated;
#endif

    return pnew_lcl;

} /* NewSurfaceLocal */


/*
 * NewSurfaceInterface
 *
 * Construct a new surface interface and local object.
 */
LPDDRAWI_DDRAWSURFACE_INT NewSurfaceInterface( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID lpvtbl )
{
    LPDDRAWI_DDRAWSURFACE_INT   pnew_int;
    LPDDRAWI_DDRAWSURFACE_INT   curr_int;
    LPDDRAWI_DDRAWSURFACE_INT   last_int;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;

    pdrv = this_lcl->lpGbl->lpDD;

    /*
     * try recycle the surface from list of all free interfeaces
     */
    curr_int = pdrv->dsFreeList;
    last_int = NULL;
    pnew_int = NULL;
    while( curr_int )
    {
        DDASSERT(0 == curr_int->dwIntRefCnt);
        if ( curr_int->lpLcl == this_lcl && curr_int->lpVtbl == lpvtbl)
        {
            pnew_int = curr_int;
            if (last_int)
            {
                last_int->lpLink = curr_int->lpLink;
            }
            else
            {
                pdrv->dsFreeList = curr_int->lpLink;
            }
	    break;
        }
        last_int = curr_int;
        curr_int = curr_int->lpLink;
    }
    if ( NULL == pnew_int)
    {
        pnew_int = MemAlloc( sizeof( DDRAWI_DDRAWSURFACE_INT ) );
        if( NULL == pnew_int )
            return NULL;

        /*
         * set up interface data
         */
        pnew_int->lpVtbl = lpvtbl;
        pnew_int->lpLcl = this_lcl;
    }
    pnew_int->lpLink = pdrv->dsList;
    pdrv->dsList = pnew_int;
    pnew_int->dwIntRefCnt = 0;

    return pnew_int;

} /* NewSurfaceInterface */

#undef DPF_MODNAME
#define DPF_MODNAME	"QueryInterface"

/*
 * getDDSInterface
 */
LPDDRAWI_DDRAWSURFACE_INT getDDSInterface( LPDDRAWI_DIRECTDRAW_GBL pdrv,
                                           LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
                                           LPVOID lpddcb )
{
    LPDDRAWI_DDRAWSURFACE_INT curr_int;

    for( curr_int = pdrv->dsList; curr_int != NULL; curr_int = curr_int->lpLink )
    {
        if( (curr_int->lpLcl == this_lcl) &&
            (curr_int->lpVtbl == lpddcb) )
        {
            break;
        }
    }
    if( NULL == curr_int )
    {
        // Couldn't find an existing interface, create one.
        curr_int = NewSurfaceInterface( this_lcl, lpddcb );
    }
    return curr_int;
}

/*
 * DD_Surface_QueryInterface
 */
HRESULT DDAPI DD_Surface_QueryInterface(
		LPDIRECTDRAWSURFACE lpDDSurface,
		REFIID riid,
		LPVOID FAR * ppvObj )
{
    LPDDRAWI_DIRECTDRAW_GBL		pdrv;
    LPDDRAWI_DDRAWSURFACE_INT		this_int;
    LPDDRAWI_DDRAWSURFACE_LCL		this_lcl;
    #ifdef STREAMING
	LPDDRAWI_DDRAWSURFACE_GBLSTREAMING	psurf_streaming;
    #endif
    LPDDRAWI_DDRAWSURFACE_GBL		this;
    LPDDRAWI_DIRECTDRAW_LCL		pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_INT		pdrv_int;
    D3DCreateTextProc                   lpfnD3DCreateTextProc;
    D3DCreateDeviceProc                 lpfnD3DCreateDeviceProc;
    HRESULT                             rval;
    IUnknown                            FAR* lpIUnknown;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_QueryInterface");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF_ERR( "Invalid surface interface pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*ppvObj = NULL;
	if( !VALIDEX_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv_int = this_lcl->lpSurfMore->lpDD_int;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * asking for IDirectDrawSurfaceNew?
     * Internal only: called by D3D after creating a vertex buffer so we 
     * don't have to run the surface list only - which is pointless since we've just 
     * created the surface
     */
    if( IsEqualIID(riid, &IID_IDirectDrawSurfaceNew) )
    {
	if( this_int->lpVtbl == (LPVOID) &ddSurfaceCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) NewSurfaceInterface( this_int->lpLcl, &ddSurfaceCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IUnknown?
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
	IsEqualIID(riid, &IID_IDirectDrawSurface) )
    {
	/*
	 * Our IUnknown interface is the same as our V1
	 * interface.  We must always return the V1 interface
	 * if IUnknown is requested.
	 */
	if( this_int->lpVtbl == &ddSurfaceCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurfaceCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawSurface2?
     */
    if( IsEqualIID(riid, &IID_IDirectDrawSurface2) )
    {
	/*
	 * if this is already an IDirectDrawSurface2 interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurface2Callbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurface2Callbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawSurface3?
     */
    if( IsEqualIID(riid, &IID_IDirectDrawSurface3) )
    {
	/*
	 * if this is already an IDirectDrawSurface3 interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurface3Callbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurface3Callbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawSurface4?
     */
    if( IsEqualIID(riid, &IID_IDirectDrawSurface4) )
    {
	/*
	 * if this is already an IDirectDrawSurface4 interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurface4Callbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurface4Callbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawSurface7?
     */
    if( IsEqualIID(riid, &IID_IDirectDrawSurface7) )
    {
	/*
	 * if this is already an IDirectDrawSurface7 interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurface7Callbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurface7Callbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawColorControl
     */
    if( IsEqualIID(riid, &IID_IDirectDrawColorControl) )
    {
	/*
	 * Color controls only work for an overlay/primary surface
	 */
    	if( this_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
    	{
    	    if( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_COLORCONTROLPRIMARY ) )
	    {
	    	LEAVE_DDRAW();
	    	return E_NOINTERFACE;
	    }
    	}
        else if( this_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
        {
    	    if( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_COLORCONTROLOVERLAY ) )
	    {
	    	LEAVE_DDRAW();
	    	return E_NOINTERFACE;
	    }
    	}
    	else
    	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}

	/*
	 * if this is already an IDirectDrawColorControl interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddColorControlCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddColorControlCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawGammaControl
     */
    if( IsEqualIID(riid, &IID_IDirectDrawGammaControl) )
    {
	/*
         * if this is already an IDirectDrawGammaControl interface, just
	 * addref and return
	 */
        if( this_int->lpVtbl == (LPVOID) &ddGammaControlCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
            *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddGammaControlCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawSurfaceKernel
     */
    if( IsEqualIID(riid, &IID_IDirectDrawSurfaceKernel) )
    {
	/*
	 * Don't create the interface if the VDD didn't load or if we
	 * don't have the DisplayDeviceHandle.
	 */
	if( !IsKernelInterfaceSupported( pdrv_lcl ) )
    	{
	    DPF( 0, "Kernel Mode interface not supported" );
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
    	}

	/*
	 * if this is already an IDirectDrawSurfaceKernel interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurfaceKernelCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurfaceKernelCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

#ifdef POSTPONED
    /*
     * asking for IPersist
     */
    if( IsEqualIID(riid, &IID_IPersist) )
    {
	/*
	 * if this is already an IID_IPersist interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurfacePersistCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurfacePersistCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IPersistStream
     */
    if( IsEqualIID(riid, &IID_IPersistStream) )
    {
	/*
	 * if this is already an IID_IPersist interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurfacePersistStreamCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurfacePersistStreamCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawOptSurface
     */
    if( IsEqualIID(riid, &IID_IDirectDrawOptSurface) )
    {
        /*
         * if this is already an IID_IDirectDrawOptSurface interface, just
         * addref and return
         */
        if( this_int->lpVtbl == (LPVOID) &ddOptSurfaceCallbacks )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl,
                                                &ddOptSurfaceCallbacks );
        if( NULL == *ppvObj )
        {
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        else
        {
            DD_Surface_AddRef( *ppvObj );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }
#endif //POSTPONED

    #ifdef STREAMING
	/*
	 * asking for IDirectDrawSurfaceStreaming?
	 */
	if( IsEqualIID(riid, &IID_IDirectDrawSurfaceStreaming) )
	{
	    /*
	     * if this is already an IDirectDrawSurfaceStreaming interface,
	     * just addref and return
	     */
	    if( this_int->lpVtbl == (LPVOID) &ddSurfaceStreamingCallbacks )
	    {
		DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) this_int );
		*ppvObj = (LPVOID) this_int;
	    }
	    /*
	     * not an IDirectDrawSurfaceStreaming interface, so we need to
	     * create one
	     */
	    else
	    {
		psurf_streaming = NewSurfaceInterface( this_lcl, &ddSurfaceStreamingCallbacks );
		if( psurf_streaming == NULL )
		{
		    LEAVE_DDRAW();
		    return DDERR_OUTOFMEMORY;
		}
		*ppvObj = (LPVOID) psurf_streaming;
	    }
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    #endif

    #ifdef COMPOSITION
	/*
	 * asking for IDirectDrawSurfaceComposition?
	 */
	if( IsEqualIID(riid, &IID_IDirectDrawSurfaceComposition) )
	{
	}
    #endif

    DPF( 4, "IID not understood by Surface QueryInterface - trying Direct3D" );

    /*
     * We maintain a list of IUnknowns aggregated by each surface.
     * These IUnknowns are lazily evaluated, i.e., we only create
     * the underlying aggregated object when someone requests the
     * the IUnknown via QueryInterface.
     *
     * We could just hardcode the Direct3D interfaces, check for
     * them here and create the appropriate interface but that's
     * inflexible and we would have to track new interfaces added
     * to Direct3D (a particularly big problem as there are likely
     * to be many Direct3DDevice interfaces for different device
     * types). So instead, we probe Direct3D but trying its create
     * functions with the IID we have been passed and seeing if
     * it suceeds or not.
     */

    /*
     * Do we have an existing aggregated IUnknown for this IID?
     */
    lpIUnknown = FindIUnknown( this_lcl, riid );
    if( lpIUnknown == NULL )
    {
        if (DDRAWILCL_DIRECTDRAW7 & pdrv_lcl->dwLocalFlags)
        {
            DPF(0,"running %s, no texture interface for Query", D3DDX7_DLLNAME);
	    LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        
        if( !D3D_INITIALIZED( pdrv_lcl ) )
	{
	    /*
	     * Direct3D is not yet initialized. Before we can attempt
	     * to query for the texture or device interface we must
	     * initialize it.
	     *
	     * NOTE: Currently if initialization fails for any reason
	     * we fail the QueryInterface() with the error returned
	     * by InitD3D()  (which will be E_NOINTERFACE if Direct3D
	     * is not properly installed). If we ever end up aggregating
	     * anything else then this is going to be WRONG as we may
	     * end up failing a query for a completely unrelated
	     * interface just because Direct3D failed to initialize.
	     * Hence, we must rethink this if we end up aggregating
	     * anything else.
	     */
	    rval = InitD3D( pdrv_int );
	    if( FAILED( rval ) )
	    {
		DPF_ERR( "Could not initialize Direct3D" );
		LEAVE_DDRAW();
		return rval;
	    }
	}

	DDASSERT( D3D_INITIALIZED( pdrv_lcl ) );

	/*
	 * No matching interface yet - is it a Direct3D texture IID?
	 */
        lpfnD3DCreateTextProc = (D3DCreateTextProc) GetProcAddress( pdrv_lcl->hD3DInstance, D3DCREATETEXTURE_PROCNAME );
        if( lpfnD3DCreateTextProc != NULL )
        {
            DPF( 4, "Attempting to create Direct3D Texture interface" );
            rval = (*lpfnD3DCreateTextProc)( riid, lpDDSurface, &lpIUnknown, (LPUNKNOWN)lpDDSurface );
	    if( rval == DD_OK )
	    {
		/*
		 * Found the interface. Add it to our list.
		 */
		if( InsertIUnknown( this_lcl, riid, lpIUnknown ) == NULL )
		{
		    /*
		     * Insufficient memory. Discard the interface and fail.
		     */
		    DPF_ERR( "Insufficient memory to aggregate the Direct3D Texture interface" );
		    lpIUnknown->lpVtbl->Release( lpIUnknown );
		    LEAVE_DDRAW();
		    return DDERR_OUTOFMEMORY;
		}
	    }
            else if ( rval != E_NOINTERFACE )
            {
                /*
                 * The CreateTexture call understood the IID but failed for some
                 * other reason. Fail the QueryInterface.
                 */
                DPF_ERR( "Direct3D CreateTexture with valid IID" );
                LEAVE_DDRAW();
                return rval;
            }
        }
        else
        {
            DPF( 0, "Could not locate the Direct3D CreateTexture entry point!" );
        }
    }
    if( lpIUnknown == NULL )
    {
	/*
	 * Still no matching interface - is it a Direct3D device IID?
	 */

	/*
	 * NOTE: Don't need to verify that Direct3D is initialized. If we
	 * got to here it must have been initialized (when we tried the
	 * texture interface).
	 */
	DDASSERT( D3D_INITIALIZED( pdrv_lcl ) );

	lpfnD3DCreateDeviceProc = (D3DCreateDeviceProc) GetProcAddress( pdrv_lcl->hD3DInstance, D3DCREATEDEVICE_PROCNAME );
	if( lpfnD3DCreateDeviceProc != NULL )
	{
	    DPF( 4, "Attempting to create Direct3D Device interface" );
	    rval = (*lpfnD3DCreateDeviceProc)( riid,
					       pdrv_lcl->pD3DIUnknown,
					       lpDDSurface, &lpIUnknown,
					       (LPUNKNOWN)lpDDSurface, 1);
	    if( rval == DD_OK )
	    {
		/*
		 * Found the interface. Add it to our list.
		 */
		if( InsertIUnknown( this_lcl, riid, lpIUnknown ) == NULL )
		{
		    /*
		     * Insufficient memory. Discard the interface and fail.
		     */
		    DPF_ERR( "Insufficient memory to aggregate the Direct3D Device interface" );
		    lpIUnknown->lpVtbl->Release( lpIUnknown );
		    LEAVE_DDRAW();
		    return DDERR_OUTOFMEMORY;
		}
	    }
	    else if ( rval != E_NOINTERFACE )
	    {
		/*
		 * The CreateDevice call understood the IID but failed for some
		 * other reason. Fail the QueryInterface.
		 */
		DPF_ERR( "Direct3D CreateDevice with valid IID" );
		LEAVE_DDRAW();
		return rval;
 	    }
	}
	else
	{
	    DPF( 0, "Could not locate the Direct3D CreateDevice entry point!" );
	}
    }

    if( lpIUnknown != NULL )
    {
	/*
	 * We have found an aggregated IID - pass the QueryInterface off
	 * on to it.
	 */
        DPF( 4, "Passing query to aggregated (Direct3D) interface" );
        rval = lpIUnknown->lpVtbl->QueryInterface( lpIUnknown, riid, ppvObj );
        if( rval == DD_OK )
        {
            DPF( 4, "Aggregated (Direct3D) QueryInterface successful" );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }

    DPF_ERR( "IID not understood by DirectDraw" );

    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DD_Surface_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME	"AddRef"

/*
 * DD_Surface_AddRef
 */
ULONG DDAPI DD_Surface_AddRef( LPDIRECTDRAWSURFACE lpDDSurface )
{
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    DWORD			rcnt;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_AddRef");

    TRY
    {
	/*
	 * validate parms
	 */
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface pointer" );
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;

   	// need to allow lost surfaces
   	#if 0
	    if( SURFACE_LOST( this_lcl ) )
	    {
		LEAVE_DDRAW();
		return 0;
	    }
	#endif

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }
    /*
     * If this surface is already being freed, immediately return to
     * prevent recursion.
     */

    if( this_lcl->dwFlags & DDRAWISURF_ISFREE )
    {
	DPF(4, "Leaving AddRef early to prevent recursion" );
	LEAVE_DDRAW();
	return 0;
    }


    /*
     * update surface reference count
     */
    this->dwRefCnt++;
    this_lcl->dwLocalRefCnt++;
    this_int->dwIntRefCnt++;
    ADDREFTRACK(lpDDSurface);
    rcnt = this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT;

    DPF( 5, "DD_Surface_AddRef, Reference Count: Global = %ld Local = %ld Int = %ld",
         this->dwRefCnt, rcnt, this_int->dwIntRefCnt );

    LEAVE_DDRAW();
    return this_int->dwIntRefCnt;

} /* DD_Surface_AddRef */

/*
 * DestroySurface
 *
 * destroys a DirectDraw surface.   does not unlink or free the surface struct.
 * The driver object MUST be locked while making this call
 */
extern void ReleaseSurfaceHandle(LPDWLIST   lpSurfaceHandleList,DWORD handle);
void DestroySurface( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    LPDDRAWI_DDRAWSURFACE_GBL		this;
    DDHAL_DESTROYSURFACEDATA		dsd;
    DWORD				rc;
    BOOL				free_vmem;
    LPDDHALSURFCB_DESTROYSURFACE	dsfn;
    LPDDHALSURFCB_DESTROYSURFACE	dshalfn;
    BOOL				emulation;
    DWORD                               caps;
    LPDDRAWI_DIRECTDRAW_LCL		pdrv_lcl;

    this = this_lcl->lpGbl;
    caps = this_lcl->ddsCaps.dwCaps;
    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;


    /*
     * Wait for driver to finish with any pending DMA operations
     */
    if( this->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
    {
        WaitForDriverToFinishWithSurface(pdrv_lcl, this_lcl);
    }

    /*
     * Turn off video port hardware.  It should already be off if it
     * was called due by Release, but not if it was called by
     * InvalidateSurface.
     */
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT )
    {
    	LPDDRAWI_DDVIDEOPORT_LCL lpVP_lcl;
    	LPDDRAWI_DDVIDEOPORT_INT lpVP_int;

	/*
	 * search all video ports to see if any are using this surface
	 */
        lpVP_lcl = this_lcl->lpSurfMore->lpVideoPort;
	lpVP_int = pdrv_lcl->lpGbl->dvpList;
	while( lpVP_int != NULL )
	{
	    if( ( lpVP_int->lpLcl == lpVP_lcl ) &&
                !( lpVP_int->dwFlags & DDVPCREATE_NOTIFY) )
	    {
                if( lpVP_int->dwFlags & DDVPCREATE_VBIONLY )
                {
                    if( ( lpVP_lcl->lpVBISurface != NULL ) &&
                        ( lpVP_lcl->lpVBISurface->lpLcl == this_lcl ) )
                    {
                        DD_VP_StopVideo( (LPDIRECTDRAWVIDEOPORT)lpVP_int );
                        if( ( lpVP_lcl->lpVBISurface != NULL ) &&
                            ( lpVP_lcl->lpVBISurface->dwIntRefCnt > 0 ) )
                        {
                            DecrementRefCounts( lpVP_lcl->lpVBISurface );
                        }
                        lpVP_lcl->lpVBISurface = NULL;
                    }
		}
                else if( lpVP_int->dwFlags & DDVPCREATE_VIDEOONLY )
                {
                    if( ( lpVP_lcl->lpSurface != NULL ) &&
                        ( lpVP_lcl->lpSurface->lpLcl == this_lcl ) )
                    {
                        DD_VP_StopVideo( (LPDIRECTDRAWVIDEOPORT)lpVP_int );
                        if( ( lpVP_lcl->lpSurface != NULL ) &&
                            ( lpVP_lcl->lpSurface->dwIntRefCnt > 0 ) )
                        {
                            DecrementRefCounts( lpVP_lcl->lpSurface );
                        }
                        lpVP_lcl->lpSurface = NULL;
                    }
		}
                else if( ( lpVP_lcl->lpSurface != NULL ) &&
                    ( lpVP_lcl->lpSurface->lpLcl == this_lcl ) )
		{
		    DD_VP_StopVideo( (LPDIRECTDRAWVIDEOPORT)lpVP_int );
		    if( ( lpVP_lcl->lpSurface != NULL ) &&
		        ( lpVP_lcl->lpSurface->dwIntRefCnt > 0 ) )
		    {
			DecrementRefCounts( lpVP_lcl->lpSurface );
		    }
		    lpVP_lcl->lpSurface = NULL;
		    if( ( lpVP_lcl->lpVBISurface != NULL ) &&
		        ( lpVP_lcl->lpVBISurface->dwIntRefCnt > 0 ) )
		    {
			DecrementRefCounts( lpVP_lcl->lpVBISurface );
		    }
		    lpVP_lcl->lpVBISurface = NULL;
		}
	    }
	    lpVP_int = lpVP_int->lpLink;
	}
    }

    /*
     * Release the kernel handle if one has been allocated
     */
    InternalReleaseKernelSurfaceHandle( this_lcl, TRUE );

    /*
     * Restore the color controls if they were changed.
     */
    ReleaseColorControl( this_lcl );
    RestoreGamma( this_lcl, pdrv_lcl );

    /*
     * Turn off the overlay.  If this function was called by Release,
     * the ovelray should already be off by now; however, it will not
     * if called because the surface was lost.
     */
    if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
	(this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE) &&
	(this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) )
    {
	LPDDHALSURFCB_UPDATEOVERLAY	uohalfn;
	LPDDHALSURFCB_UPDATEOVERLAY	uofn;
	DWORD			rc;
	DDHAL_UPDATEOVERLAYDATA	uod;

	uofn = pdrv_lcl->lpDDCB->HALDDSurface.UpdateOverlay;
	uohalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.UpdateOverlay;
	DDASSERT( uohalfn != NULL );
	DPF( 2, "Turning off hardware overlay" );
	uod.UpdateOverlay = uohalfn;
	uod.lpDD = this_lcl->lpSurfMore->lpDD_lcl->lpGbl;
	uod.lpDDSrcSurface = this_lcl;
	uod.lpDDDestSurface = this_lcl->lpSurfaceOverlaying->lpLcl;
	uod.dwFlags = DDOVER_HIDE;
	DOHALCALL( UpdateOverlay, uofn, uod, rc, FALSE );
	DDASSERT( ( rc == DDHAL_DRIVER_HANDLED ) && 
            (( uod.ddRVal == DD_OK ) || ( uod.ddRVal == DDERR_SURFACELOST )) );
	this_lcl->ddsCaps.dwCaps &= ~DDSCAPS_VISIBLE;
    }

    /*
     * see if we need to free video memory
     *
     * We don't if its already free, if it was allocated by the client (and
     * the client didn't specifically make DDraw responsible for freeing it),
     * or if it is the video memory GDI surface.
     */
#if 0 // DDRAWISURFGBL_DDFREESCLIENTMEM is gone
    if((this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE) ||
       (this->dwGlobalFlags & DDRAWISURFGBL_ISCLIENTMEM	&&
       !(this->dwGlobalFlags & DDRAWISURFGBL_DDFREESCLIENTMEM)) ||
       ((this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) &&         //((this->fpVidMem == this->lpDD->fpPrimaryOrig) &&
	(this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) ) )
#else
#ifdef WINNT
    // On Win2K we don't see any reason why the video memory primary
    // should not be freed. Actually, we don't see any reason on Win9x
    // as well, but we are not going to touch Win9x given that this is
    // March 2001.
    if((this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE))
#else
    if((this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE) ||
       ((this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) &&         //((this->fpVidMem == this->lpDD->fpPrimaryOrig) &&
	(this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) ) )
#endif // WINNT
#endif // 0
    {
	free_vmem = FALSE;
    }
    else
    {
	free_vmem = TRUE;
    }

    if( free_vmem )
    {
	/*
	 * ask the driver to free its video memory...
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
	{
            if( caps & DDSCAPS_EXECUTEBUFFER )
	        dsfn = pdrv_lcl->lpDDCB->HELDDExeBuf.DestroyExecuteBuffer;
            else
	        dsfn = pdrv_lcl->lpDDCB->HELDDSurface.DestroySurface;
	    dshalfn = dsfn;
	    emulation = TRUE;
	}
	else
	{
            if( caps & DDSCAPS_EXECUTEBUFFER )
            {
	        dsfn = pdrv_lcl->lpDDCB->HALDDExeBuf.DestroyExecuteBuffer;
	        dshalfn = pdrv_lcl->lpDDCB->cbDDExeBufCallbacks.DestroyExecuteBuffer;
            }
            else
            {
	        dsfn = pdrv_lcl->lpDDCB->HALDDSurface.DestroySurface;
	        dshalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.DestroySurface;
            }
	    emulation = FALSE;
	}
	rc = DDHAL_DRIVER_NOTHANDLED;
	if( dshalfn != NULL )
	{
            DWORD save;
	    dsd.DestroySurface = dshalfn;
	    dsd.lpDD = this->lpDD;
	    dsd.lpDDSurface = this_lcl;

            if(this_lcl->dwFlags & DDRAWISURF_DRIVERMANAGED)
            {
                save = this_lcl->dwFlags & DDRAWISURF_INVALID;
                this_lcl->dwFlags &= ~DDRAWISURF_INVALID;
            }

	    /*
	     * NOTE: THE DRIVER _CANNOT_ FAIL THIS CALL. ddrval is ignored.
	     */
            if( caps & DDSCAPS_EXECUTEBUFFER )
            {
	        DOHALCALL( DestroyExecuteBuffer, dsfn, dsd, rc, emulation );
            }
            else
            {
	        DOHALCALL( DestroySurface, dsfn, dsd, rc, emulation );
            }

            if(this_lcl->dwFlags & DDRAWISURF_DRIVERMANAGED)
            {
                this_lcl->dwFlags |= save;
            }
	}

	/*
	 * free the video memory ourselves
	 */
	if( rc == DDHAL_DRIVER_NOTHANDLED )
	{
	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
	    {
#ifndef WINNT
		if( this->lpVidMemHeap != NULL )
		{
		    VidMemFree( this->lpVidMemHeap, this->fpVidMem );
		}
#endif
	    }
	}
	this->lpVidMemHeap = NULL;
	this->fpVidMem = 0;
	this->dwGlobalFlags |= DDRAWISURFGBL_MEMFREE;
    }

} /* DestroySurface */

#undef DPF_MODNAME
#define DPF_MODNAME	"LooseManagedSurface"

/*
 * LooseManagedSurface
 *
 */
void LooseManagedSurface( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    LPDDRAWI_DDRAWSURFACE_GBL		this;
    DDHAL_DESTROYSURFACEDATA		dsd;
    DWORD				rc;
    LPDDHALSURFCB_DESTROYSURFACE	dsfn;
    LPDDHALSURFCB_DESTROYSURFACE	dshalfn;
    BOOL				emulation;
    LPDDRAWI_DIRECTDRAW_LCL		pdrv_lcl;
    DWORD                               save;

    this = this_lcl->lpGbl;
    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;

    dsfn = pdrv_lcl->lpDDCB->HALDDSurface.DestroySurface;
    dshalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.DestroySurface;
    emulation = FALSE;
    rc = DDHAL_DRIVER_NOTHANDLED;

    dsd.DestroySurface = dshalfn;
    dsd.lpDD = this->lpDD;
    dsd.lpDDSurface = this_lcl;

    save = this_lcl->dwFlags & DDRAWISURF_INVALID;
    this_lcl->dwFlags |= DDRAWISURF_INVALID;

    /*
     * NOTE: THE DRIVER _CANNOT_ FAIL THIS CALL. ddrval is ignored.
     */
    DOHALCALL( DestroySurface, dsfn, dsd, rc, emulation );

    this_lcl->dwFlags &= ~DDRAWISURF_INVALID;
    this_lcl->dwFlags |= save;
    
} /* LooseManagedSurface */

#undef DPF_MODNAME
#define DPF_MODNAME	"Release"


/*
 * NOTE: These two functions are hacks to get around a compiler bug
 * that caused an infinite loop.
 */
LPVOID GetAttachList( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    return this_lcl->lpAttachList;

}
LPVOID GetAttachListFrom( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    return this_lcl->lpAttachListFrom;
}

/*
 * findOtherInterface
 *
 * Finds another interface to the lcl surface object different than this_int.
 * Returns NULL if no other interface is found.
 *
 */
LPDDRAWI_DDRAWSURFACE_INT findOtherInterface(LPDDRAWI_DDRAWSURFACE_INT this_int,
					     LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
					     LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    LPDDRAWI_DDRAWSURFACE_INT psurf = pdrv->dsList;

    while(psurf != NULL)
    {
	if( (psurf != this_int) && (psurf->lpLcl == this_lcl) )
	{
	    return psurf;
	}

	psurf = psurf->lpLink;
    }

    return NULL;
}

/*
 * InternalSurfaceRelease
 *
 * Done with a surface.	  if no one else is using it, then we can free it.
 * Also called by ProcessSurfaceCleanup, EnumSurfaces and DD_Release.
 *
 * Assumes the lock is taken on the driver.
 */
DWORD InternalSurfaceRelease( LPDDRAWI_DDRAWSURFACE_INT this_int, BOOL bLightweight, BOOL bDX8 )
{
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPATTACHLIST		pattachlist;
    DWORD			intrefcnt;
    DWORD			lclrefcnt;
    DWORD			gblrefcnt;
    DWORD			pid;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL 	pdrv;
    BOOL			root_object_deleted;
    BOOL			do_free;
    DWORD                       caps;
    IUnknown *                  pOwner = NULL;
    LPDDRAWI_DDRAWSURFACE_INT	curr_int;
    LPDDRAWI_DDRAWSURFACE_INT	last_int;
    BOOL                        bPrimaryChain = FALSE;

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;

    if (this_lcl->dwFlags & DDRAWISURF_PARTOFPRIMARYCHAIN)
    {
        bPrimaryChain = TRUE;
    }

    /*
     * check owner of surface
     */
    pid = GETCURRPID();
    /*
     * don't allow someone to free an implicitly created surface
     */
    if( (this->dwRefCnt == 1) && (this_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE) )
    {
	DPF_ERR( "Cannot free an implicitly created surface" );
	return 0;
    }

    /*
     * remove locks taken on this surface by the current process
     */

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;
    if( (this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT) == 1 )
    {
	RemoveProcessLocks( pdrv_lcl, this_lcl, pid );
    }

    /*
     * decrement the reference count.  if it hits zero, free the surface
     */
    this->dwRefCnt--;
    gblrefcnt = this->dwRefCnt;
    this_lcl->dwLocalRefCnt--;
    lclrefcnt = this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT;
    this_int->dwIntRefCnt--;
    intrefcnt = this_int->dwIntRefCnt;

    DPF( 5, "DD_Surface_Release, Reference Count: Global = %ld Local = %ld Int = %ld",
         gblrefcnt, lclrefcnt, intrefcnt );

#ifdef POSTPONED2
    /*
     * If the reference count on the interface object has now gone to
     * zero and that object is referenced in the master sprite list,
     * remove the reference to that object from the master sprite list.
     */
    if (intrefcnt == 0 && this_lcl->dwFlags & DDRAWISURF_INMASTERSPRITELIST)
    {
	RemoveSpriteSurface(pdrv, this_int);
    }
#endif //POSTPONED2

    /*
     * local object at zero?
     */
    root_object_deleted = FALSE;
    if ( 0 == lclrefcnt )
    {
	LPDDRAWI_DDRAWSURFACE_INT	curr_int;
	LPDDRAWI_DDRAWSURFACE_LCL	curr_lcl;
	LPDDRAWI_DDRAWSURFACE_GBL	curr;
	DWORD				refcnt;

        // Do not call FlushD3DStates on DDHelp thread; if the app has died, then
        // D3DIM will be gone.

        if (dwHelperPid != GetCurrentProcessId())
        {
            FlushD3DStates(this_lcl);

            /* If there exists a D3D texture object, then we need to kill it */
            if(this_lcl->lpSurfMore->lpTex)
            {
                DDASSERT(pdrv_lcl->pD3DDestroyTexture);
                pdrv_lcl->pD3DDestroyTexture(this_lcl->lpSurfMore->lpTex);
            }
        }

	/*
	 * see if we are deleting the root object
	 */
	if( this_lcl->dwLocalRefCnt & OBJECT_ISROOT )
	{
	    root_object_deleted = TRUE;
	}


	/*
	 * reset if primary surface is the one being released
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
	{

	    /*
	     * restore GDI stuff if this is the GDI driver
	     */
	    if( pdrv->dwFlags & DDRAWI_DISPLAYDRV )
	    {
		if( !SURFACE_LOST( this_lcl ) )
		{
		    DPF( 2, "Resetting primary surface");

		    /*
		     * flip to the original primary surface if not emulated
		     */
                    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
		    {
			FlipToGDISurface( pdrv_lcl, this_int ); //, pdrv->fpPrimaryOrig );
		    }
		}

		/*
		 * Cause the GDI surface to be redrawn if the mode was ever changed.
		 */
                if (pdrv_lcl->dwLocalFlags & DDRAWILCL_MODEHASBEENCHANGED)
         		RedrawWindow( NULL, NULL, NULL, RDW_INVALIDATE | RDW_ERASE |
				 RDW_ALLCHILDREN );
	    }
	}

       	/*
	 * hide a hardware overlay...
	 */
	if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
	    (this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE) &&
	    (this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) )
	{
	    LPDDHALSURFCB_UPDATEOVERLAY	uohalfn;
	    LPDDHALSURFCB_UPDATEOVERLAY	uofn;
	    DWORD			rc;
	    DDHAL_UPDATEOVERLAYDATA	uod;

	    uofn = pdrv_lcl->lpDDCB->HALDDSurface.UpdateOverlay;
	    uohalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.UpdateOverlay;
	    if( (uohalfn != NULL) && (NULL != this_lcl->lpSurfaceOverlaying) )
	    {
		DPF( 2, "Turning off hardware overlay" );
		uod.UpdateOverlay = uohalfn;
		uod.lpDD = pdrv;
		uod.lpDDSrcSurface = this_lcl;
		uod.lpDDDestSurface = this_lcl->lpSurfaceOverlaying->lpLcl;
		uod.dwFlags = DDOVER_HIDE;
		DOHALCALL( UpdateOverlay, uofn, uod, rc, FALSE );
	        this_lcl->ddsCaps.dwCaps &= ~DDSCAPS_VISIBLE;
	    }
	}

	/*
	 * if an overlay, remove surface from the overlay Z order list
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
	{
	    // Remove surface from doubly linked list
	    this_lcl->dbnOverlayNode.prev->next = this_lcl->dbnOverlayNode.next;
	    this_lcl->dbnOverlayNode.next->prev = this_lcl->dbnOverlayNode.prev;

            // If this surface is overlaying an emulated surface, we must notify
            // the HEL that it needs to eventually update the part of the surface
            // touched by this overlay.
            if( this_lcl->lpSurfaceOverlaying != NULL )
            {
		LPDIRECTDRAWSURFACE lpTempSurface;
        	// We have a pointer to the surface being overlayed, check to
        	// see if it is being emulated.
        	if( this_lcl->lpSurfaceOverlaying->lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
        	{
        	    // Mark the destination region of this overlay as dirty.
        	    DD_Surface_AddOverlayDirtyRect(
        		(LPDIRECTDRAWSURFACE)(this_lcl->lpSurfaceOverlaying),
			&(this_lcl->rcOverlayDest) );
        	}
                lpTempSurface = (LPDIRECTDRAWSURFACE)(this_lcl->lpSurfaceOverlaying);
		this_lcl->lpSurfaceOverlaying = NULL;
		DD_Surface_Release( lpTempSurface );
            }
	}

	if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
	    ( this_lcl->lpSurfMore->lpddOverlayFX != NULL ) )
	{
	    MemFree( this_lcl->lpSurfMore->lpddOverlayFX );
	    this_lcl->lpSurfMore->lpddOverlayFX = NULL;
	}

	/*
	 * turn off video port hardware...
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT )
	{
    	    LPDDRAWI_DDVIDEOPORT_INT lpVideoPort;
    	    LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort_lcl;

	    /*
	     * search all video ports to see if any are using this surface
	     */
	    lpVideoPort = pdrv->dvpList;
	    while( ( NULL != lpVideoPort ) &&
	           !( lpVideoPort->dwFlags & DDVPCREATE_NOTIFY ) )
	    {
		lpVideoPort_lcl = lpVideoPort->lpLcl;
		if( lpVideoPort_lcl->lpSurface == this_int )
		{
		    DD_VP_StopVideo( (LPDIRECTDRAWVIDEOPORT)lpVideoPort );
		    lpVideoPort_lcl->lpSurface = NULL;
		}
		if( lpVideoPort_lcl->lpVBISurface == this_int )
		{
		    DD_VP_StopVideo( (LPDIRECTDRAWVIDEOPORT)lpVideoPort );
		    lpVideoPort_lcl->lpVBISurface = NULL;
		}
		lpVideoPort = lpVideoPort->lpLink;
	    }
	}

        /*
         * If is has a gamma ramp, release it now
         */
        ReleaseGammaControl( this_lcl );

    /*
     * Free the nodes in the IUnknown list and release all the interfaces.
     */
	FreeIUnknowns( this_lcl, TRUE );
	/*
	 * release all implicitly created attached surfaces
	 */
	pattachlist = GetAttachList( this_lcl );
	this_lcl->dwFlags |= DDRAWISURF_ISFREE;
	while( pattachlist != NULL )
	{
	    BOOL    was_implicit;
	    /*
	     * break all attachments
	     */
	    curr_int = pattachlist->lpIAttached;
	    if( pattachlist->dwFlags & DDAL_IMPLICIT )
		was_implicit = TRUE;
	    else
		was_implicit = FALSE;

	    DPF(5, "Deleting attachment from %08lx to %08lx (implicit = %d)",
		curr_int, this_int, was_implicit);
       	    DeleteOneAttachment( this_int, curr_int, TRUE, DOA_DELETEIMPLICIT );
	    // If the attachment was not implicit then curr_int may possibly have
	    // been destroyed as a result of DeleteOneAttachment.
	    if( was_implicit )
	    {
		curr_lcl = curr_int->lpLcl;
		curr = curr_lcl->lpGbl;

		/*
		 * release an implicitly created surface
		 */
		if( !(curr_lcl->dwFlags & DDRAWISURF_ISFREE) )
		{
		    if( curr_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE )
		    {
			refcnt = curr_int->dwIntRefCnt;
			curr_lcl->dwFlags &= ~DDRAWISURF_IMPLICITCREATE;
			while( refcnt > 0 )
			{
			    InternalSurfaceRelease( curr_int, bLightweight, bDX8 );
			    refcnt--;
			}
		    }
		}
	    }
	    /*
	     * start again at the beginning of the list because
	     * DeleteOneAttachment may have modified the attachment list.
	     * HACKHACK:  this fn call is needed to get around a compiler bug
	     */
	    pattachlist = GetAttachList( this_lcl );
	}

		/* at this point all D3DDevice must have detached themselves
                   unless if this is being called by DDHELP */
#if DBG
        if(dwHelperPid != GetCurrentProcessId())
        {
	    DDASSERT(NULL == this_lcl->lpSurfMore->lpD3DDevIList);
        }
#endif

        /*
	 * If a palette is attached to this surface remove it (and, as a
	 * side effect, release it). Use SetPaletteAlways just in case the 
         * surface has been lost.
	 */
	if( this_lcl->lpDDPalette )
	    SetPaletteAlways( this_int, NULL );

        /*
         * Release the attached clipper (if any).
         */
        if( this_lcl->lpSurfMore->lpDDIClipper )
            DD_Clipper_Release( (LPDIRECTDRAWCLIPPER)this_lcl->lpSurfMore->lpDDIClipper );

	/*
	 * remove all attachments to us from other surfaces
	 */
	pattachlist = this_lcl->lpAttachListFrom;
	while( pattachlist != NULL )
	{
	    curr_int = pattachlist->lpIAttached;
	    DPF( 5, "Deleting attachment from %08lx", curr_int );
	    DeleteOneAttachment( curr_int, this_int, TRUE, DOA_DELETEIMPLICIT );
	    /*
	     * start again at the beginning of the list because
	     * DeleteOneAttachment may have modified the attachment list.
	     * HACKHACK:  this fn call is needed to get around a compiler bug
	     */
	    pattachlist = GetAttachListFrom( this_lcl );
	}

	/*
	 *  Remove any association with a DC. This will tend to mean
	 *  that someone has orphaned a windows DC.
	 */
	if( this_lcl->dwFlags & DDRAWISURF_HASDC )
	{
	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC )
	    {
		HRESULT ddrval;
		DDASSERT( this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED );
		DDASSERT( this_lcl->hDC != 0UL );
		/*
		 * If this is an OWNDC surface the HDC lives as long as the surface
		 * so release it now.
		 */
		ddrval = InternalReleaseDC( this_lcl, (HDC)this_lcl->hDC
#ifdef WIN95
                , TRUE
#endif  //WIN95
                 );
		DDASSERT( !FAILED(ddrval) );
	    }
	    else
	    {
		/*
		 * If its not an OWNDC surface then the HDC should have been released before
		 * we ever got here.
		 */
		DPF( 1, "HDC Leaked! Surface should only be released after DC is released" );
		// Remove DC from the list
		InternalRemoveDCFromList( NULL, this_lcl );
		// Clear flags
		this_lcl->dwFlags &= ~(DDRAWISURF_HASDC | DDRAWISURF_GETDCNULL);
	    }
	}

        /*
         * Remove private data
         */
        FreeAllPrivateData( &this_lcl->lpSurfMore->pPrivateDataHead );

        /*
        * Region lists should be freed
        */
        if(IsD3DManaged(this_lcl))
        {
            MemFree(this_lcl->lpSurfMore->lpRegionList);
        }

        /*
         * If the ddraw interface which created this surface caused the surface to addref the ddraw
         * object, then we need to release that addref now.
         * We don't release ddraw object for implicitly created surfaces, since
         * that surface never took an addref.
         */
        if (this_lcl->lpSurfMore->lpDD_int)
        {
            pOwner = this_lcl->lpSurfMore->pAddrefedThisOwner;
        }

        if (!bLightweight)
        {
            MemFree(this_lcl->lpSurfMore->pCreatedDDSurfaceDesc2);
            MemFree(this_lcl->lpSurfMore->slist);
        }

	this_lcl->dwFlags &= ~DDRAWISURF_ISFREE;
    }

    /*
     * root object at zero?
     */
    do_free = FALSE;
    if( gblrefcnt == 0 )
    {
#ifdef WINNT
        if (this->dwGlobalFlags & DDRAWISURFGBL_NOTIFYWHENUNLOCKED)
        {
            if (--dwNumLockedWhenModeSwitched == 0)
            {
                NotifyDriverOfFreeAliasedLocks();
            }
            this->dwGlobalFlags &= ~DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
        }
#endif

	/*
	 * get rid of all memory associated with this surface
	 */
	DestroySurface( this_lcl );

        if (0 != this_lcl->lpSurfMore->dwSurfaceHandle)
        {
#ifdef WIN95
            // need to notify the driver that this system memory surface is not associated to
            // this surface handle anymore
            if (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
            {
                DDASSERT(0UL == this->fpVidMem);
                // For now, simply warn that the driver failed to associate the surface with the 
                // token and continue
                DDASSERT( pdrv_lcl == this_lcl->lpSurfMore->lpDD_lcl);
                createsurfaceEx(this_lcl);
            }
#endif  
            ReleaseSurfaceHandle(&SURFACEHANDLELIST(pdrv_lcl),this_lcl->lpSurfMore->dwSurfaceHandle);
            //DPF(0,"Release lpSurfMore->dwSurfaceHandle=%08lx",this_lcl->lpSurfMore->dwSurfaceHandle);
            this_lcl->lpSurfMore->dwSurfaceHandle=0;
        }

	this_lcl->dwFlags |= DDRAWISURF_INVALID;
	do_free = TRUE;

#ifdef WIN95
    //
    // Free persistent-content memory, if any
    //

    if (this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_PERSISTENTCONTENTS)
    {
        FreeSurfaceContents(this_lcl);
    }
#endif

    /*
	 * if this was the final delete, but this wasn't the root object,
	 * then we need to delete the dangling object
	 */
	if( !root_object_deleted )
	{
	    LPDDRAWI_DDRAWSURFACE_LCL	root_lcl;

	    /*
	     * Get the start of the root global data object.  Since the
	     * global data always follows the local data, we just need
	     * to back up the size of the local data to get the start of
	     * the allocated block.
	     *
	     * NOTE: The local surface allocation now includes the
	     * additional local surface structure (DDRAWI_DDRAWSURFACE_MORE).
	     * So we need to back up by the size of that structure also.
	     * And also need to move back 4 bytes for the extra pointer
	     * to the GBL_MORE.
	     *
	     * Since all duplicated surfaces have the same local data,
	     * we just need to test this surface for overlay data to determine
	     * if the root object had overlay data.
	     */
	    if( this_lcl->dwFlags & DDRAWISURF_HASOVERLAYDATA )
	    {
		root_lcl = (LPVOID) (((LPSTR) this) - ( sizeof( DDRAWI_DDRAWSURFACE_LCL ) +
		                                        sizeof( DDRAWI_DDRAWSURFACE_MORE ) +
							sizeof( LPDDRAWI_DDRAWSURFACE_GBL_MORE ) ) );
	    }
	    else
	    {
		root_lcl = (LPVOID) (((LPSTR) this) - ( offsetof( DDRAWI_DDRAWSURFACE_LCL, ddckCKSrcOverlay ) +
		                                        sizeof( DDRAWI_DDRAWSURFACE_MORE ) +
							sizeof( LPDDRAWI_DDRAWSURFACE_GBL_MORE ) ) );
	    }

            if (!bLightweight)
            {
	        MemFree( root_lcl );
            }
	}
    }
    else if( lclrefcnt == 0 )
    {
	/*
	 * only remove the object if it wasn't the root.   if it
	 * was the root, we must leave it dangling until the last
	 * object referencing it goes away.
	 */
	if( !root_object_deleted )
	{
	    do_free = TRUE;
	}
    }

    caps = this_lcl->ddsCaps.dwCaps;
    /*
     * If we are releasing an interface to a primary surface, update the pointer to the primary
     * surface stored in the local driver object.  If another interface to the primary surface exists,
     * store that one.  Otherwise, set the pointer to NULL.
     */
    if( intrefcnt == 0 )
    {
	/*
	 * If the video port is using this interface, make it stop
	 */
    	if( ( this_lcl->lpSurfMore->lpVideoPort != NULL ) &&
    	    ( this_lcl->lpSurfMore->lpVideoPort->lpSurface == this_int ) )
    	{
    	    this_lcl->lpSurfMore->lpVideoPort->lpSurface = NULL;
	}

	/*
	 * The following code is to work around a design flaw.
	 * The implicitly created surfaces are not freed until the LCL is
	 * freed, but the attached list references the INT.  Therefore, we
	 * can release an INT now and then try to reference it later when
	 * releasing the LCL.  This happens most often when a second
	 * interface is created for the same LCL, such as ColorControl,
	 * Kernel, Surface2, etc.
	 */
	if( ( lclrefcnt > 0 ) &&
	    ( ( GetAttachList( this_lcl ) != NULL ) ||
            ( GetAttachListFrom( this_lcl ) != NULL ) ) )
	{
	    LPDDRAWI_DDRAWSURFACE_INT new_int;
	    LPATTACHLIST ptr1, ptr2;

	    /*
	     * Find the other INT that is using the LCL
	     */
	    new_int = findOtherInterface(this_int, this_lcl, pdrv);
	    DDASSERT( new_int != NULL );

	    /*
	     * Update the surfaces attachements.
	     * We first go to all interfaces we are attached to and change
	     * their AttachListFrom to reference our new interface.
	     */
	    ptr1 = GetAttachList( this_lcl );
	    while( ptr1 != NULL )
	    {
		DDASSERT( ptr1->lpIAttached != this_int );
		ptr2 = ptr1->lpAttached->lpAttachListFrom;
		while( ptr2 != NULL )
		{
		    if( ptr2->lpIAttached == this_int )
		    {
		    	ptr2->lpIAttached = new_int;
		    }
		    ptr2 = ptr2->lpLink;
		}
		ptr1 = ptr1->lpLink;
	    }

	    /*
	     * We now go to all interfaces we are attached from and change
	     * their AttachList to reference our new interface.
	     */
	    ptr1 = this_lcl->lpAttachListFrom;
	    while( ptr1 != NULL )
	    {
		DDASSERT( ptr1->lpIAttached != this_int );
		ptr2 = GetAttachList( ptr1->lpAttached );
		while( ptr2 != NULL )
		{
		    if( ptr2->lpIAttached == this_int )
		    {
		    	ptr2->lpIAttached = new_int;
		    }
		    ptr2 = ptr2->lpLink;
		}
		ptr1 = ptr1->lpLink;
	    }
	}

	if( caps & DDSCAPS_PRIMARYSURFACE )
	{
	    LPDDRAWI_DDRAWSURFACE_INT temp_int;

	    if( this_lcl->lpSurfMore->lpDD_lcl )
	    {
		this_lcl->lpSurfMore->lpDD_lcl->lpPrimary = findOtherInterface(this_int, this_lcl, pdrv);
	    }

	    /*
	     * If an overlay is overlaying this surface, either make it use
	     * a new primary surface int or turn it off
	     */
	    temp_int = pdrv->dsList;
	    while( temp_int != NULL )
	    {
		if( temp_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
		{
		    if( temp_int->lpLcl->lpSurfaceOverlaying == this_int )
		    {
			if( lclrefcnt > 0 )
			{
			    temp_int->lpLcl->lpSurfaceOverlaying =
			    	findOtherInterface(this_int, this_lcl, pdrv);
			    DDASSERT( temp_int != NULL );
			}
			else
			{
			    temp_int->lpLcl->lpSurfaceOverlaying = NULL;
			}
			if( ( temp_int->lpLcl->lpSurfaceOverlaying == NULL ) &&
			    ( temp_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE ))
			{
			    LPDDHALSURFCB_UPDATEOVERLAY	uohalfn;
			    LPDDHALSURFCB_UPDATEOVERLAY	uofn;
			    DWORD			rc;
			    DDHAL_UPDATEOVERLAYDATA	uod;

			    /*
			     * Turn off the overlay
			     */
			    uofn = pdrv_lcl->lpDDCB->HALDDSurface.UpdateOverlay;
			    uohalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.UpdateOverlay;
			    DDASSERT( uohalfn != NULL );
			    DPF( 2, "Turning off hardware overlay" );
			    uod.UpdateOverlay = uohalfn;
			    uod.lpDD = pdrv;
			    uod.lpDDSrcSurface = temp_int->lpLcl;
			    uod.lpDDDestSurface = NULL;
			    uod.dwFlags = DDOVER_HIDE;
			    DOHALCALL( UpdateOverlay, uofn, uod, rc, FALSE );
			    temp_int->lpLcl->ddsCaps.dwCaps &= ~DDSCAPS_VISIBLE;
			}
		    }
		}
		temp_int = temp_int->lpLink;
	    }
	}
#ifdef SHAREDZ
	if( caps & DDSCAPS_SHAREDBACKBUFFER )
	{
	    if( this_lcl->lpSurfMore->lpDD_lcl )
	    {
		this_lcl->lpSurfMore->lpDD_lcl->lpSharedBack = findOtherInterface(this_int, this_lcl, pdrv);
	    }
	}
	if( caps & DDSCAPS_SHAREDZBUFFER )
	{
	    if( this_lcl->lpSurfMore->lpDD_lcl )
	    {
		this_lcl->lpSurfMore->lpDD_lcl->lpSharedZ = findOtherInterface(this_int, this_lcl, pdrv);
	    }
	}
#endif
    }

    /*
     * free the object if needed
     */
    if( do_free && !bLightweight )
    {
	this_lcl->lpGbl = NULL;

        #ifdef WINNT
        /*
         * Free the associated NT kernel-mode object only if it is a vram surface, it is not
	 * an execute buffer, and it has not yet been freed in the kernel
         */
        if (!(caps & (DDSCAPS_SYSTEMMEMORY) ) && this_lcl->hDDSurface )
        {
            DPF(5,"Deleting NT kernel-mode object handle %08x",this_lcl->hDDSurface);
            if (!DdDeleteSurfaceObject(this_lcl))
                DPF(5,"DdDeleteSurfaceObject failed");
        }
        #endif
        MemFree( this_lcl );
    }

    /*
     * interface at zero?
     */
    if(( intrefcnt == 0) && (!bDX8 || bPrimaryChain))
    {
	/*
	 * remove surface from list of all surfaces
	 */
	curr_int = pdrv->dsList;
	last_int = NULL;
	while( curr_int != this_int )
	{
	    last_int = curr_int;
	    curr_int = curr_int->lpLink;
	    if( curr_int == NULL )
	    {
		DPF_ERR( "Surface not in list!" );
		return 0;
	    }
	}
	if( last_int == NULL )
	{
	    pdrv->dsList = pdrv->dsList->lpLink;
	}
	else
	{
	    last_int->lpLink = curr_int->lpLink;
	}
        curr_int->lpLink = pdrv->dsFreeList;
        pdrv->dsFreeList = curr_int;
        DUMPREFTRACK(this_int);
    }

    if (( 0 == lclrefcnt) && !bLightweight )
    {    
        if (!bDX8 || bPrimaryChain)
        {
            /*
	     * remove surface from list of all surfaces
	     */
	    curr_int = pdrv->dsFreeList;
	    last_int = NULL;
	    while( curr_int )
	    {
                LPDDRAWI_DDRAWSURFACE_INT   temp_int = curr_int->lpLink;
                DDASSERT(0 == curr_int->dwIntRefCnt);
                if (curr_int->lpLcl == this_lcl)
                {
	            if( last_int == NULL )
	            {
	                pdrv->dsFreeList = temp_int;
	            }
	            else
	            {
	                last_int->lpLink = temp_int;
	            }
	            /*
	             * just in case someone comes back in with this pointer, set
	             * an invalid vtbl & data ptr.
	             */
                    curr_int->lpVtbl = NULL;
	            curr_int->lpLcl = NULL;
	            MemFree( curr_int );
                }
                else
                {
	            last_int = curr_int;
                }
                curr_int = temp_int;
	    }

        }
        else
        {
            this_int->lpVtbl = NULL;
	    this_int->lpLcl = NULL;
	    MemFree( this_int );
        }
    }

    /*
     * If the surface took a ref count on the ddraw object that created it,
     * release that ref now as the very last thing.
     * We don't want to do this on ddhelp's thread cuz it really mucks up the
     * process cleanup stuff.
     */
    if (pOwner && (dwHelperPid != GetCurrentProcessId()) )
    {
        pOwner->lpVtbl->Release(pOwner);
    }

    return intrefcnt;

} /* InternalSurfaceRelease */

/*
 * DD_Surface_Release
 *
 * Done with a surface.	  if no one else is using it, then we can free it.
 */
ULONG DDAPI DD_Surface_Release( LPDIRECTDRAWSURFACE lpDDSurface )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    DWORD			rc;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	pparentsurf_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Release");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALIDEX_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface pointer" );
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
	pdrv = this_lcl->lpGbl->lpDD;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * If this surface is already being freed, immediately return to
     * prevent recursion.
     */

    if( this_lcl->dwFlags & DDRAWISURF_ISFREE )
    {
	DPF(4, "Leaving Release early to prevent recursion" );
	LEAVE_DDRAW();
	return 0;
    }

    if ( this_int->dwIntRefCnt == 0 )
    {
        DPF_ERR( "Interface pointer has 0 ref count!" );
        LEAVE_DDRAW();
        return 0;
    }

    /*
     * If this surface is part of a mip-map chain then we will need
     * to update its parent map's mip-map count.
     */
    pparentsurf_int = NULL;
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
	pparentsurf_int = FindParentMipMap( this_int );

    rc = InternalSurfaceRelease( this_int, FALSE, FALSE );

#ifdef REFTRACKING
    if (rc)
    {
        RELEASETRACK(lpDDSurface);
    }
#endif

    /*
     * Update the parent's mip-map count if necessary
     * (if the surface really has gone and if the mip-map
     * has a parent).
     */
    if( ( rc == 0UL ) &&  ( pparentsurf_int != NULL ) )
	UpdateMipMapCount( pparentsurf_int );


    LEAVE_DDRAW();
    return rc;

} /* DD_Surface_Release */

/*
 * ProcessSurfaceCleanup
 *
 * A process is done, clean up any surfaces that it may have locked.
 *
 * NOTE: we enter with a lock taken on the DIRECTDRAW object.
 */
void ProcessSurfaceCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf;
    LPDDRAWI_DDRAWSURFACE_INT	psnext_int;
    DWORD			rcnt;
    ULONG			rc;

    /*
     * run through all surfaces owned by the driver object, and find ones
     * that have been accessed by this process.  If the pdrv_lcl parameter
     * is non-null, only delete surfaces created by that local driver object.
     */
    psurf_int = pdrv->dsList;
    DPF( 4, "ProcessSurfaceCleanup" );
    while( psurf_int != NULL )
    {
	psurf_lcl = psurf_int->lpLcl;
	psurf = psurf_lcl->lpGbl;
	psnext_int = psurf_int->lpLink;
	rc = 1;
	if( ( psurf_lcl->dwProcessId == pid ) &&
	    ( (NULL == pdrv_lcl) || (psurf_lcl->lpSurfMore->lpDD_lcl == pdrv_lcl) ) )
	{
	    if( NULL == pdrv_lcl )
	    {
	        /*
		 * If no local driver object is passed in then we are being called
		 * due to process termination. In this case we can't release
		 * the Direct3D objects as they no longer exist (Direct3D is a
		 * local DLL and dies with the application along with its objects)
		 * Hence, free all the nodes on the IUnknown list and NULL the
		 * list out to prevent InternalSurfaceRelease() from trying to
		 * free them.
	         */
		DPF( 4, "Discarding Direct3D surface interfaces - process terminated" );
	        FreeIUnknowns( psurf_lcl, FALSE );
	    }

	    /*
	     * release the references by this process
	     */
	    rcnt = psurf_int->dwIntRefCnt;
	    DPF( 5, "Process %08lx had %ld accesses to surface %08lx", pid, rcnt, psurf_int );
	    while( rcnt >  0 )
	    {
		if(!(psurf_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE) )
		{
		    rc = InternalSurfaceRelease( psurf_int, FALSE, FALSE );
		    // Multiple surfaces may be released in the call to InternalSurfaceRelease
		    // so we must start again at the beginning of the list.
		    psnext_int = pdrv->dsList;
		    if( rc == 0 )
		    {
			break;
		    }
		}
		rcnt--;
	    }
	}
	else
	{
	    DPF( 5, "Process %08lx had no accesses to surface %08lx", pid, psurf_int );
	}
	psurf_int = psnext_int;
    }
    DPF( 4, "Leaving ProcessSurfaceCleanup");

} /* ProcessSurfaceCleanup */

void FreeD3DSurfaceIUnknowns( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int = pdrv->dsList;
    while( psurf_int != NULL )
    {
	LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl = psurf_int->lpLcl;
	LPDDRAWI_DDRAWSURFACE_INT   psnext_int = psurf_int->lpLink;
	if( ( psurf_lcl->dwProcessId == pid ) &&
	    (psurf_lcl->lpSurfMore->lpDD_lcl == pdrv_lcl) )
	{
	    DPF( 4, "Release Direct3D surface interfaces" );
            FreeIUnknowns( psurf_lcl, TRUE );
	}
        psurf_int = psnext_int;
    }
} /* FreeD3DSurfaceIUnknowns */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\edid.h ===
//
// This include file contains the format of the VESA EDID data structure as
// described in the VESA Display Data Channel (DDC) Specification.  It should
// be included in any assembly language program that requires knowledge of the
// EDID data structure.
//
typedef struct VESA_EDID {
        BYTE    veHeader[8];        // 0,FFH,FFH,FFH,FFH,FFH,FFH,0
        BYTE    veManufactID[2];    // in compressed format - see spec
        BYTE    veProductCode[2];   // vendor assigned code
        DWORD   veSerialNbr;        // 32 bit serial nbr (LSB first)
        BYTE    veWeekMade;         // week of manufacture (0-53)
        BYTE    veYearMade;         // year of manufacture - 1990
        BYTE    veEDIDVersion;      // version number of EDID
        BYTE    veEDIDRevision;     // revision number of EDID
        BYTE    veVidInputDef;      // video input definition
        BYTE    veMaxHorizSize;     // horizontal image size in cm
        BYTE    veMaxVertSize;      // vertical image size in cm
        BYTE    veGammaXFER;        // (gamma * 100) - 100 (1.00-3.55)
        BYTE    veDPMSFeatures;     // DPMS feature support
        BYTE    veRedGreenLow;      // Rx1Rx0Ry1Ry0Gx1Gx0Gy1Gy0
        BYTE    veBlueWhiteLow;     // Bx1Bx0By1By0Wx1Wx0Wy1Wy0
        BYTE    veRedx;             // red X bit 9 - 2
        BYTE    veRedy;             // red Y bit 9 - 2
        BYTE    veGreenx;           // green X bit 9 - 2
        BYTE    veGreeny;           // green Y bit 9 - 2
        BYTE    veBluex;            // blue X bit 9 - 2
        BYTE    veBluey;            // blue Y bit 9 - 2
        BYTE    veWhitex;           // white X bit 9 - 2
        BYTE    veWhitey;           // white Y bit 9 - 2
        BYTE    veEstTime1;         // established timings I
        BYTE    veEstTime2;         // established timings II
        BYTE    veEstTime3;         // established timings II
        WORD    veStdTimeID1;       //
        WORD    veStdTimeID2;       //
        WORD    veStdTimeID3;       //
        WORD    veStdTimeID4;       //
        WORD    veStdTimeID5;       //
        WORD    veStdTimeID6;       //
        WORD    veStdTimeID7;       //
        WORD    veStdTimeID8;       //
        BYTE    veDetailTime1[18];  //
        BYTE    veDetailTime2[18];  //
        BYTE    veDetailTime3[18];  //
        BYTE    veDetailTime4[18];  //
        BYTE    veExtensionFlag;    // nbr of 128 EDID extensions
        BYTE    veChecksum;         // sum of all bytes == 0
}       VESA_EDID;

/*ASM
.errnz  size VESA_EDID - 128                    ;must be 128 bytes long!
*/

//
// bit definitions for the veEstTime1 field
//
#define veEstTime1_720x400x70Hz     0x80   // 720x400x70Hz  VGA,IBM
#define veEstTime1_720x400x88Hz     0x40   // 720x400x88Hz  XGA2,IBM
#define veEstTime1_640x480x60Hz     0x20   // 640x480x60Hz  VGA,IBM
#define veEstTime1_640x480x67Hz     0x10   // 640x480x67Hz  MacII,Apple
#define veEstTime1_640x480x72Hz     0x08   // 640x480x72Hz  VESA
#define veEstTime1_640x480x75Hz     0x04   // 640x480x75Hz  VESA
#define veEstTime1_800x600x56Hz     0x02   // 800x600x56Hz  VESA
#define veEstTime1_800x600x60Hz     0x01   // 800x600x60Hz  VESA

//
// bit definitions for the veEstTime2 field
//
#define veEstTime2_800x600x72Hz     0x80   // 800x600x72Hz   VESA
#define veEstTime2_800x600x75Hz     0x40   // 800x600x75Hz   VESA
#define veEstTime2_832x624x75Hz     0x20   // 832x624x75Hz   MacII,Apple
#define veEstTime2_1024x768x87Hz    0x10   // 1024x768x87Hz  IBM
#define veEstTime2_1024x768x60Hz    0x08   // 1024x768x60Hz  VESA
#define veEstTime2_1024x768x70Hz    0x04   // 1024x768x70Hz  VESA
#define veEstTime2_1024x768x75Hz    0x02   // 1024x768x75Hz  VESA
#define veEstTime2_1280x1024x75Hz   0x01   // 1280x1024x75Hz VESA

//
// bit definitions for the veEstTime3 field (was veManTimes in DDC 1)
//
#define veEstTime3_1152x870x75Hz    0x80   // 800x600x72Hz   MacII,Apple
#define veEstTime3_640x480x85Hz     0x40   // 640x480x85Hz   VESA
#define veEstTime3_800x600x85Hz     0x20   // 800x600x85Hz   VESA
#define veEstTime3_1280x1024x85Hz   0x10   // 1280x1024x85Hz VESA
#define veEstTime3_1024x768x85Hz    0x08   // 1024x768x85Hz  VESA
#define veEstTime3_1600x1200x75Hz   0x04   // 1600x1200x75Hz VESA
#define veEstTime3_1600x1200x85Hz   0x02   // 1600x1200x85Hz VESA
#define veEstTime3_ManReservedTime  0x01   // manufacturer's reserved timings

//
// bit definitions for the veStdTime field
//
#define veStdTime_HorzResMask       0x00FF    // HorzRes = (X + 31) * 8
#define veStdTime_RefreshRateMask   0x1F00    // RefreshRate = X + 60Hz
#define veStdTime_AspectRatioMask   0xC000    //
#define veStdTime_AspectRatio1to1   0x0000    // 1:1
#define veStdTime_AspectRatio4to3   0x4000    // 4:3
#define veStdTime_AspectRatio5to4   0x8000    // 5:4
#define veStdTime_AspectRatio16to9  0xC000    // 16:9
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\decoder.cpp ===
#include "ddrawpr.h"

#include <ImgUtil.H>
//#include <ocmm.h>
#include "decoder.h"
#include <atlcom.h>

#define Assert(x)
#define ReleaseMemoryDC(x)	DeleteObject(x)
#define MulDivQuick			MulDiv
#define	Verify(x)			x

extern HPALETTE hpalApp;


void CImageDecodeEventSink::Init(FILTERINFO * pFilter)
{
    m_nRefCount=0;
    m_pFilter=pFilter;
    m_pDDrawSurface=NULL;
    m_dwLastTick=0;
    ZeroMemory(&m_rcProg, sizeof(m_rcProg));
}
/*
CImageDecodeEventSink::~CImageDecodeEventSink()
{
}
*/

ULONG CImageDecodeEventSink::AddRef()
{
    m_nRefCount++;

    return (m_nRefCount);
}

ULONG CImageDecodeEventSink::Release()
{
    m_nRefCount--;
    if (m_nRefCount == 0)
    {
     //   delete this;
        return (0);
    }

    return (m_nRefCount);
}

STDMETHODIMP CImageDecodeEventSink::QueryInterface(REFIID iid, 
   void** ppInterface)
{
    if (ppInterface == NULL)
    {
        return (E_POINTER);
    }

    *ppInterface = NULL;

    if (IsEqualGUID(iid, IID_IUnknown))
    {
        *ppInterface = (IUnknown*)(IImageDecodeEventSink *)this;
    }
    else if (IsEqualGUID(iid, IID_IImageDecodeEventSink))
    {
        *ppInterface = (IImageDecodeEventSink*)this;
    }
    else
    {
        return (E_NOINTERFACE);
    }

    //  If we're going to return an interface, AddRef it first
    if (*ppInterface)
    {
        ((LPUNKNOWN)*ppInterface)->AddRef();
        return S_OK;
    }

    return (S_OK);
}

STDMETHODIMP CImageDecodeEventSink::OnBeginDecode(DWORD* pdwEvents, 
   ULONG* pnFormats, GUID** ppFormats)
{
    GUID* pFormats;

    if (pdwEvents != NULL)
    {
        *pdwEvents = 0;
    }
    if (pnFormats != NULL)
    {
        *pnFormats = 0;
    }
    if (ppFormats != NULL)
    {
        *ppFormats = NULL;
    }
    if (pdwEvents == NULL)
    {
        return (E_POINTER);
    }
    if (pnFormats == NULL)
    {
        return (E_POINTER);
    }
    if (ppFormats == NULL)
    {
        return (E_POINTER);
    }

#if 0
    if (m_pFilter->_colorMode == 8)
    {
        pFormats = (GUID*)CoTaskMemAlloc(1*sizeof(GUID));
        if(pFormats == NULL)
        {
            return (E_OUTOFMEMORY);
        }
        
        pFormats[0] = BFID_INDEXED_RGB_8;
        *pnFormats = 1;
    }
#endif
#if 1
    else
    {
        pFormats = (GUID*)CoTaskMemAlloc(2*sizeof(GUID));
        if(pFormats == NULL)
        {
            return (E_OUTOFMEMORY);
        }
        
        pFormats[0] = BFID_RGB_24;
        pFormats[1] = BFID_INDEXED_RGB_8;
        *pnFormats = 2;
    }
#else
    else
    {
        pFormats = (GUID*)CoTaskMemAlloc(1*sizeof(GUID));
        if(pFormats == NULL)
        {
            return (E_OUTOFMEMORY);
        }
        
        pFormats[0] = BFID_RGB_24;
        *pnFormats = 1;
    }
#endif
    *ppFormats = pFormats;
    *pdwEvents = IMGDECODE_EVENT_PALETTE|IMGDECODE_EVENT_BITSCOMPLETE|IMGDECODE_EVENT_PROGRESS;

	*pdwEvents |= IMGDECODE_EVENT_USEDDRAW;

#if 0
	if (m_pFilter->_colorMode != 8)
		*pdwEvents |= IMGDECODE_EVENT_USEDDRAW;
#endif

	m_dwLastTick = GetTickCount();

    return (S_OK);
}

STDMETHODIMP CImageDecodeEventSink::OnBitsComplete()
{
    return (S_OK);
}

STDMETHODIMP CImageDecodeEventSink::OnDecodeComplete(HRESULT hrStatus)
{
    return (S_OK);
}

#define LINEBYTES(_wid,_bits) ((((_wid)*(_bits) + 31) / 32) * 4)

STDMETHODIMP CImageDecodeEventSink::GetSurface(LONG nWidth, LONG nHeight, 
    REFGUID bfid, ULONG nPasses, DWORD dwHints, IUnknown** ppSurface)
{
    return GetDDrawSurface(nWidth, nHeight, bfid, nPasses, dwHints, ppSurface);
}


STDMETHODIMP CImageDecodeEventSink::GetDDrawSurface(LONG nWidth, LONG nHeight, 
    REFGUID bfid, ULONG nPasses, DWORD dwHints, IUnknown ** ppSurface)
{
	DDSURFACEDESC2	ddsd = {sizeof(ddsd)};

    (void)nPasses;
    (void)dwHints;
    
    if (ppSurface != NULL)
    {
        *ppSurface = NULL;
    }
    if (ppSurface == NULL)
    {
        return (E_POINTER);
    }

    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
    ddsd.dwHeight = nHeight;
    ddsd.dwWidth = nWidth;
    ddsd.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);

    if (IsEqualGUID(bfid, BFID_INDEXED_RGB_8))
    {
        m_pFilter->m_nBytesPerPixel = 1;

		ddsd.ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
		ddsd.ddpfPixelFormat.dwRGBBitCount = 8;
		ddsd.ddpfPixelFormat.dwRBitMask = 0;
		ddsd.ddpfPixelFormat.dwGBitMask = 0;
		ddsd.ddpfPixelFormat.dwBBitMask = 0;
		ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0;
    }
    else if (IsEqualGUID(bfid, BFID_RGB_24))
    {
        m_pFilter->m_nBytesPerPixel = 3;

		ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
		ddsd.ddpfPixelFormat.dwRGBBitCount = 24;
		ddsd.ddpfPixelFormat.dwRBitMask = 0x00FF0000L;
		ddsd.ddpfPixelFormat.dwGBitMask = 0x0000FF00L;
		ddsd.ddpfPixelFormat.dwBBitMask = 0x000000FFL;
		ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0;
    }
    else
    {
        return (E_NOINTERFACE);
    }

    IDirectDrawSurface4 * lpDDS;


	if (FAILED(m_pDirectDrawEx->CreateSurface(&ddsd, &lpDDS, NULL)))
		return (E_OUTOFMEMORY);

        HRESULT hr = lpDDS->QueryInterface(IID_IDirectDrawSurface,(void**)&m_pDDrawSurface);
        lpDDS->Release();
        if (FAILED(hr))
        {
            return hr;
        }

	// If this is a palette surface create/attach a palette to it.

	if (m_pFilter->m_nBytesPerPixel == 1)
	{
		PALETTEENTRY	ape[256];
		LPDIRECTDRAWPALETTE2	pDDPalette;


		m_pDirectDrawEx->CreatePalette(DDPCAPS_8BIT | DDPCAPS_ALLOW256, ape, &pDDPalette, NULL);
		m_pDDrawSurface->SetPalette((LPDIRECTDRAWPALETTE)pDDPalette);
		pDDPalette->Release();
	}

	m_pFilter->m_pDDrawSurface = m_pDDrawSurface;
	m_pDDrawSurface->AddRef();

    *ppSurface = (IUnknown *)m_pDDrawSurface;
    (*ppSurface)->AddRef();
	
	return S_OK;
}

STDMETHODIMP CImageDecodeEventSink::OnPalette()
{
    return (S_OK);
}

STDMETHODIMP CImageDecodeEventSink::OnProgress(RECT* pBounds, BOOL bComplete)
{
	DWORD	dwTick = GetTickCount();

    if (pBounds == NULL)
    {
        return (E_INVALIDARG);
    }

	UnionRect(&m_rcProg, &m_rcProg, pBounds);

	if (dwTick - m_dwLastTick > 250)
	{
//              Used for progressive rendering.  Uncomment later
//		DrawImage(NULL, m_pFilter, &m_rcProg);  
		m_dwLastTick = GetTickCount();
	}

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\dx8priv.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dx8priv.h
 *  Content:    Private header file for all changes that are truly
 *              private to Dx8.
 *
 ***************************************************************************/

#include "d3d8typesp.h"
#include "d3d8ddi.h"

#ifdef WIN95
    extern ULONG giDisplaySettingsUniqueness;
#endif

#ifdef IS_32

extern HRESULT InternalDirectDrawCreate( GUID * lpGUID, LPDIRECTDRAW *lplpDD, LPDDRAWI_DIRECTDRAW_INT pnew_int, DWORD dwFlags, char* pDeviceName );

extern HRESULT InternalCreateSurface( LPDDRAWI_DIRECTDRAW_LCL thisg, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *lplpDDSurface, LPDDRAWI_DIRECTDRAW_INT this_int, LPDDSURFACEINFO pSysMemInfo, DWORD DX8Flags );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\dvpp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dvp.h
 *  Content:	DirectDrawVideoPort include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   11-jun-96	scottm	initial implementation
 *   29-jan-97	smac	Various API changes
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DVP_INCLUDED__
#define __DVP_INCLUDED__

/*
 * GUIDS used by DirectDrawVideoPort objects
 */
#if defined( _WIN32 ) && (!defined( _NO_COM ) || defined( DEFINE_GUID ))
DEFINE_GUID( IID_IDDVideoPortContainer,		0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawVideoPort,		0xB36D93E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDrawVideoPortNotify,    0xA655FB94,0x0589,0x4E57,0xB3,0x33,0x56,0x7A,0x89,0x46,0x8C,0x88);



DEFINE_GUID( DDVPTYPE_E_HREFH_VREFH, 0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFH_VREFL, 0x92783220L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFH, 0xA07A02E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFL, 0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_CCIR656,	     0xFCA326A0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_BROOKTREE,     0x1352A560L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_PHILIPS,	     0x332CF160L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
#endif

#ifndef GUID_DEFS_ONLY

#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#endif

/*
 * These definitions are required to allow polymorphic structure members (i.e. those
 * that are referred to both as DWORDs and as pointers) to resolve into a type
 * of correct size to hold the largest of those two types (i.e. pointer) on 64 bit
 * systems. For 32 bit environments, ULONG_PTR resolves to a DWORD.
 */
#ifndef MAXULONG_PTR
#define ULONG_PTR    DWORD
#endif //MAXULONG_PTR

#ifdef __cplusplus
extern "C" {
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
struct IDirectDrawSurfaceComposition;
#endif
#ifdef STREAMING
struct IDirectDrawSurfaceStreaming;
#endif
//@@END_MSINTERNAL
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoPortContainer            FAR *LPDDVIDEOPORTCONTAINER;
typedef struct IDirectDrawVideoPort             FAR *LPDIRECTDRAWVIDEOPORT;
typedef struct IDirectDrawVideoPortNotify       FAR *LPDIRECTDRAWVIDEOPORTNOTIFY;

typedef struct _DDVIDEOPORTCONNECT              FAR *LPDDVIDEOPORTCONNECT;
typedef struct _DDVIDEOPORTCAPS                 FAR *LPDDVIDEOPORTCAPS;
typedef struct _DDVIDEOPORTDESC                 FAR *LPDDVIDEOPORTDESC;
typedef struct _DDVIDEOPORTINFO                 FAR *LPDDVIDEOPORTINFO;
typedef struct _DDVIDEOPORTBANDWIDTH            FAR *LPDDVIDEOPORTBANDWIDTH;
typedef struct _DDVIDEOPORTSTATUS               FAR *LPDDVIDEOPORTSTATUS;
typedef struct _DDVIDEOPORTNOTIFY               FAR *LPDDVIDEOPORTNOTIFY;

typedef struct IDDVideoPortContainerVtbl        DDVIDEOPORTCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoPortVtbl         DIRECTDRAWVIDEOPORTCALLBACKS;
typedef struct IDirectDrawVideoPortNotifyVtbl   DIRECTDRAWVIDEOPORTNOTIFYCALLBACKS;


/*
 * API's
 */
typedef HRESULT (FAR PASCAL * LPDDENUMVIDEOCALLBACK)(LPDDVIDEOPORTCAPS, LPVOID);


/*
 * INTERACES FOLLOW:
 *	IDirectDrawVideoPort
 *	IVideoPort
 */

/*
 * IDirectDrawVideoPortContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoPortContainer
DECLARE_INTERFACE_( IDDVideoPortContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawVideoPort methods ***/
    STDMETHOD(CreateVideoPort)(THIS_ DWORD, LPDDVIDEOPORTDESC, LPDIRECTDRAWVIDEOPORT FAR *, IUnknown FAR *) PURE;
    STDMETHOD(EnumVideoPorts)(THIS_ DWORD, LPDDVIDEOPORTCAPS, LPVOID,LPDDENUMVIDEOCALLBACK ) PURE;
    STDMETHOD(GetVideoPortConnectInfo)(THIS_ DWORD, LPDWORD, LPDDVIDEOPORTCONNECT ) PURE;
    STDMETHOD(QueryVideoPortStatus)(THIS_ DWORD, LPDDVIDEOPORTSTATUS ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IVideoPortContainer_Release(p)                      (p)->lpVtbl->Release(p)
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->lpVtbl->CreateVideoPort(p, a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->lpVtbl->EnumVideoPorts(p, a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->lpVtbl->GetVideoPortConnectInfo(p, a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->lpVtbl->QueryVideoPortStatus(p, a, b)
#else
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->AddRef()
#define IVideoPortContainer_Release(p)                      (p)->Release()
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->CreateVideoPort(a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->EnumVideoPorts(a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->GetVideoPortConnectInfo(a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->QueryVideoPortStatus(a, b)
#endif

#endif


/*
 * IDirectDrawVideoPort
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoPort
DECLARE_INTERFACE_( IDirectDrawVideoPort, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IVideoPort methods ***/
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetBandwidthInfo)(THIS_ LPDDPIXELFORMAT, DWORD, DWORD, DWORD, LPDDVIDEOPORTBANDWIDTH) PURE;
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(GetInputFormats)(THIS_ LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetOutputFormats)(THIS_ LPDDPIXELFORMAT, LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetFieldPolarity)(THIS_ LPBOOL) PURE;
    STDMETHOD(GetVideoLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVideoSignalStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetTargetSurface)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(StartVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(StopVideo)(THIS) PURE;
    STDMETHOD(UpdateVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(WaitForSync)(THIS_ DWORD, DWORD, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPort_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoPort_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IVideoPort_Release(p)                   (p)->lpVtbl->Release(p)
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->lpVtbl->SetTargetSurface(p,a,b)
#define IVideoPort_Flip(p,a,b)			(p)->lpVtbl->Flip(p,a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->lpVtbl->GetBandwidthInfo(p,a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->lpVtbl->GetColorControls(p,a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->lpVtbl->GetInputFormats(p,a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->lpVtbl->GetOutputFormats(p,a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->lpVtbl->GetFieldPolarity(p,a)
#define IVideoPort_GetVideoLine(p,a)		(p)->lpVtbl->GetVideoLine(p,a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->lpVtbl->GetVideoSignalStatus(p,a)
#define IVideoPort_SetColorControls(p,a)	(p)->lpVtbl->SetColorControls(p,a)
#define IVideoPort_StartVideo(p,a)		(p)->lpVtbl->StartVideo(p,a)
#define IVideoPort_StopVideo(p)			(p)->lpVtbl->StopVideo(p)
#define IVideoPort_UpdateVideo(p,a)		(p)->lpVtbl->UpdateVideo(p,a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->lpVtbl->WaitForSync(p,a,b,c)
#else
#define IVideoPort_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IVideoPort_AddRef(p)                    (p)->AddRef()
#define IVideoPort_Release(p)                   (p)->Release()
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->SetTargetSurface(a,b)
#define IVideoPort_Flip(p,a,b)			(p)->Flip(a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->GetBandwidthInfo(a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->GetColorControls(a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->GetInputFormats(a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->GetOutputFormats(a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->GetFieldPolarity(a)
#define IVideoPort_GetVideoLine(p,a)		(p)->GetVideoLine(a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->GetVideoSignalStatus(a)
#define IVideoPort_SetColorControls(p,a)	(p)->SetColorControls(a)
#define IVideoPort_StartVideo(p,a)		(p)->StartVideo(a)
#define IVideoPort_StopVideo(p)			(p)->StopVideo()
#define IVideoPort_UpdateVideo(p,a)		(p)->UpdateVideo(a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->WaitForSync(a,b,c)
#endif

#endif

/*
 * IDirectDrawVideoPort
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoPortNotify
DECLARE_INTERFACE_( IDirectDrawVideoPortNotify, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IVideoPort methods ***/
    STDMETHOD(AcquireNotification)(THIS_ HANDLE *, LPDDVIDEOPORTNOTIFY) PURE;
    STDMETHOD(ReleaseNotification)(THIS_ HANDLE) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPortNotify_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoPortNotify_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoPortNotify_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoPortNotify_AcquireNotification(p,a,b) (p)->lpVtbl->AcquireNotification(p,a,b)
#define IVideoPortNotify_ReleaseNotification(p,a)   (p)->lpVtbl->ReleaseNotification(p,a)
#else
#define IVideoPortNotify_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoPortNotify_AddRef(p)                  (p)->AddRef()
#define IVideoPortNotify_Release(p)                 (p)->Release()
#define IVideoPortNotify_AcquireNotification(p,a,b) (p)->lpVtbl->AcquireNotification(a,b)
#define IVideoPortNotify_ReleaseNotification(p,a)   (p)->lpVtbl->ReleaseNotification(a)
#endif

#endif

/*
 * DDVIDEOPORTCONNECT
 */
typedef struct _DDVIDEOPORTCONNECT
{
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    ULONG_PTR dwReserved1;      // Reserved, set to zero.
} DDVIDEOPORTCONNECT;


/*
 * DDVIDEOPORTCAPS
 */
typedef struct _DDVIDEOPORTCAPS
{
    DWORD dwSize;			// size of the DDVIDEOPORTCAPS structure
    DWORD dwFlags;			// indicates which fields contain data
    DWORD dwMaxWidth;			// max width of the video port field
    DWORD dwMaxVBIWidth;		// max width of the VBI data
    DWORD dwMaxHeight; 			// max height of the video port field
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwCaps;			// Video port capabilities
    DWORD dwFX;				// More video port capabilities
    DWORD dwNumAutoFlipSurfaces;	// Max number of autoflippable surfaces allowed
    DWORD dwAlignVideoPortBoundary;	// Byte restriction of placement within the surface
    DWORD dwAlignVideoPortPrescaleWidth;// Byte restriction of width after prescaling
    DWORD dwAlignVideoPortCropBoundary;	// Byte restriction of left cropping
    DWORD dwAlignVideoPortCropWidth;	// Byte restriction of cropping width
    DWORD dwPreshrinkXStep;		// Width can be shrunk in steps of 1/x
    DWORD dwPreshrinkYStep;		// Height can be shrunk in steps of 1/x
    DWORD dwNumVBIAutoFlipSurfaces;	// Max number of VBI autoflippable surfaces allowed
    DWORD dwNumPreferredAutoflip;	// Optimal number of autoflippable surfaces for hardware
    WORD  wNumFilterTapsX;              // Number of taps the prescaler uses in the X direction (0 - no prescale, 1 - replication, etc.)
    WORD  wNumFilterTapsY;              // Number of taps the prescaler uses in the Y direction (0 - no prescale, 1 - replication, etc.)
} DDVIDEOPORTCAPS;

/*
 * The dwMaxWidth and dwMaxVBIWidth members are valid
 */
#define DDVPD_WIDTH		0x00000001l

/*
 * The dwMaxHeight member is valid
 */
#define DDVPD_HEIGHT		0x00000002l

/*
 * The dwVideoPortID member is valid
 */
#define DDVPD_ID		0x00000004l

/*
 * The dwCaps member is valid
 */
#define DDVPD_CAPS		0x00000008l

/*
 * The dwFX member is valid
 */
#define DDVPD_FX		0x00000010l

/*
 * The dwNumAutoFlipSurfaces member is valid
 */
#define DDVPD_AUTOFLIP		0x00000020l

/*
 * All of the alignment members are valid
 */
#define DDVPD_ALIGN		0x00000040l

/*
 * The dwNumPreferredAutoflip member is valid
 */
#define DDVPD_PREFERREDAUTOFLIP 0x00000080l

/*
 * The wNumFilterTapsX and wNumFilterTapsY fields are valid
 */
#define DDVPD_FILTERQUALITY     0x00000100l

/*
 * DDVIDEOPORTDESC
 */
typedef struct _DDVIDEOPORTDESC
{
    DWORD dwSize;			// size of the DDVIDEOPORTDESC structure
    DWORD dwFieldWidth;			// width of the video port field
    DWORD dwVBIWidth;			// width of the VBI data
    DWORD dwFieldHeight;		// height of the video port field
    DWORD dwMicrosecondsPerField;	// Microseconds per video field
    DWORD dwMaxPixelsPerSecond;		// Maximum pixel rate per second
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwReserved1;			// Reserved for future use - set to zero (struct padding)
    DDVIDEOPORTCONNECT VideoPortType; 	// Description of video port connection
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved3;		// Reserved for future use - set to zero
} DDVIDEOPORTDESC;


/*
 * DDVIDEOPORTINFO
 */
typedef struct _DDVIDEOPORTINFO
{
    DWORD dwSize;			// Size of the structure
    DWORD dwOriginX;			// Placement of the video data within the surface.
    DWORD dwOriginY;			// Placement of the video data within the surface.
    DWORD dwVPFlags;			// Video port options
    RECT rCrop;				// Cropping rectangle (optional).
    DWORD dwPrescaleWidth;		// Determines pre-scaling/zooming in the X direction (optional).
    DWORD dwPrescaleHeight;		// Determines pre-scaling/zooming in the Y direction (optional).
    LPDDPIXELFORMAT lpddpfInputFormat;	// Video format written to the video port
    LPDDPIXELFORMAT lpddpfVBIInputFormat; // Input format of the VBI data
    LPDDPIXELFORMAT lpddpfVBIOutputFormat;// Output format of the data
    DWORD dwVBIHeight;			// Specifies the number of lines of data within the vertical blanking interval.
    ULONG_PTR dwReserved1;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTINFO;


/*
 * DDVIDEOPORTBANDWIDTH
 */
typedef struct _DDVIDEOPORTBANDWIDTH
{
    DWORD dwSize;			// Size of the structure
    DWORD dwCaps;
    DWORD dwOverlay;           		// Zoom factor at which overlay is supported
    DWORD dwColorkey;			// Zoom factor at which overlay w/ colorkey is supported
    DWORD dwYInterpolate;		// Zoom factor at which overlay w/ Y interpolation is supported
    DWORD dwYInterpAndColorkey;		// Zoom factor at which ovelray w/ Y interpolation and colorkeying is supported
    ULONG_PTR dwReserved1;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTBANDWIDTH;


/*
 * DDVIDEOPORTSTATUS
 */
typedef struct _DDVIDEOPORTSTATUS
{
    DWORD dwSize;			// Size of the structure
    BOOL  bInUse;			// TRUE if video port is currently being used
    DWORD dwFlags;           		// Currently not used
    DWORD dwReserved1;			// Reserved for future use
    DDVIDEOPORTCONNECT VideoPortType;	// Information about the connection
    ULONG_PTR dwReserved2;		// Reserved for future use
    ULONG_PTR dwReserved3;		// Reserved for future use
} DDVIDEOPORTSTATUS;

/*
 * DDVIDEOPORTNOTIFY
 */
typedef struct _DDVIDEOPORTNOTIFY
{
    LARGE_INTEGER ApproximateTimeStamp;	// Timestamp in the event notification
    LONG lField;                        // 0 if even, 1 if odd, -1 if unknown
    UINT dwSurfaceIndex;                // Index in the surface chain of the surface that received the sample
    LONG lDone;                         // Call InterlockedIncrement on this when done with sample
} DDVIDEOPORTNOTIFY;


/*============================================================================
 *
 * Video Port Flags
 *
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTCONNECT FLAGS
 *
 ****************************************************************************/

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of double clocking the data.
 * When this is set by the client, this indicates that the video port
 * should enable double clocking.  This flag is only valid with external
 * syncs.
 */
#define DDVPCONNECT_DOUBLECLOCK			0x00000001l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of using an external VACT
 * signal. When this is set by the client, this indicates that the
 * video port should use the external VACT signal.
 */
#define DDVPCONNECT_VACT			0x00000002l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of treating even fields
 * like odd fields and visa versa.  When this is set by the client,
 * this indicates that the video port should treat even fields like odd
 * fields.
 */
#define DDVPCONNECT_INVERTPOLARITY		0x00000004l

/*
 * Indicates that any data written to the video port during the VREF
 * period will not be written into the frame buffer. This flag is read only.
 */
#define DDVPCONNECT_DISCARDSVREFDATA		0x00000008l

/*
 * When this is set be the driver and passed to the client, this
 * indicates that the device will write half lines into the frame buffer
 * if half lines are provided by the decoder.  If this is set by the client,
 * this indicates that the decoder will be supplying half lines.
 */
#define DDVPCONNECT_HALFLINE			0x00000010l

/*
 * Indicates that the signal is interlaced. This flag is only
 * set by the client.
 */
#define DDVPCONNECT_INTERLACED			0x00000020l

/*
 * Indicates that video port is shareable and that this video port
 * will use the even fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREEVEN			0x00000040l

/*
 * Indicates that video port is shareable and that this video port
 * will use the odd fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREODD			0x00000080l

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC CAPS
 *
 ****************************************************************************/

/*
 * Flip can be performed automatically to avoid tearing.
 */
#define DDVPCAPS_AUTOFLIP			0x00000001l

/*
 * Supports interlaced video
 */
#define DDVPCAPS_INTERLACED			0x00000002l

/*
 * Supports non-interlaced video
 */
#define DDVPCAPS_NONINTERLACED			0x00000004l

/*
 * Indicates that the device can return whether the current field
 * of an interlaced signal is even or odd.
 */
#define DDVPCAPS_READBACKFIELD			0x00000008l

/*
 * Indicates that the device can return the current line of video
 * being written into the frame buffer.
 */
#define DDVPCAPS_READBACKLINE			0x00000010l

/*
 * Allows two gen-locked video streams to share a single video port,
 * where one stream uses the even fields and the other uses the odd
 * fields. Separate parameters (including address, scaling,
 * cropping, etc.) are maintained for both fields.)
 */
#define DDVPCAPS_SHAREABLE			0x00000020l

/*
 * Even fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPEVENFIELDS			0x00000040l

/*
 * Odd fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPODDFIELDS			0x00000080l

/*
 * Indicates that the device is capable of driving the graphics
 * VSYNC with the video port VSYNC.
 */
#define DDVPCAPS_SYNCMASTER			0x00000100l

/*
 * Indicates that data within the vertical blanking interval can
 * be written to a different surface.
 */
#define DDVPCAPS_VBISURFACE			0x00000200l

/*
 * Indicates that the video port can perform color operations
 * on the incoming data before it is written to the frame buffer.
 */
#define DDVPCAPS_COLORCONTROL			0x00000400l

/*
 * Indicates that the video port can accept VBI data in a different
 * width or format than the regular video data.
 */
#define DDVPCAPS_OVERSAMPLEDVBI			0x00000800l

/*
 * Indicates that the video port can write data directly to system memory
 */
#define DDVPCAPS_SYSTEMMEMORY			0x00001000l

/*
 * Indicates that the VBI and video portions of the video stream can
 * be controlled by an independent processes.
 */
#define DDVPCAPS_VBIANDVIDEOINDEPENDENT		0x00002000l

/*
 * Indicates that the video port contains high quality hardware
 * de-interlacing hardware that should be used instead of the
 * bob/weave algorithms.
 */
#define DDVPCAPS_HARDWAREDEINTERLACE		0x00004000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC FX
 *
 ****************************************************************************/

/*
 * Limited cropping is available to crop out the vertical interval data.
 */
#define DDVPFX_CROPTOPDATA			0x00000001l

/*
 * Incoming data can be cropped in the X direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPX				0x00000002l

/*
 * Incoming data can be cropped in the Y direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPY				0x00000004l

/*
 * Supports interleaving interlaced fields in memory.
 */
#define DDVPFX_INTERLEAVE			0x00000008l

/*
 * Supports mirroring left to right as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORLEFTRIGHT			0x00000010l

/*
 * Supports mirroring top to bottom as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORUPDOWN			0x00000020l

/*
 * Data can be arbitrarily shrunk in the X direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKX			0x00000040l

/*
 * Data can be arbitrarily shrunk in the Y direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKY			0x00000080l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the X
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXB			0x00000100l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the Y
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYB			0x00000200l

/*
 * Data can be shrunk in increments of 1/x in the X direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkXStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXS			0x00000400l

/*
 * Data can be shrunk in increments of 1/x in the Y direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkYStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYS			0x00000800l

/*
 * Data can be arbitrarily stretched in the X direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHX			0x00001000l

/*
 * Data can be arbitrarily stretched in the Y direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHY			0x00002000l

/*
 * Data can be integer stretched in the X direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHXN			0x00004000l

/*
 * Data can be integer stretched in the Y direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHYN			0x00008000l

/*
 * Indicates that data within the vertical blanking interval can
 * be converted independently of the remaining video data.
 */
#define DDVPFX_VBICONVERT			0x00010000l

/*
 * Indicates that scaling can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOSCALE			0x00020000l

/*
 * Indicates that the video data can ignore the left and right
 * cropping coordinates when cropping oversampled VBI data.
 */
#define DDVPFX_IGNOREVBIXCROP			0x00040000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOINTERLEAVE			0x00080000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTINFO FLAGS
 *
 ****************************************************************************/

/*
 * Perform automatic flipping.   Auto-flipping is performed between
 * the overlay surface that was attached to the video port using
 * IDirectDrawVideoPort::AttachSurface and the overlay surfaces that
 * are attached to the surface via the IDirectDrawSurface::AttachSurface
 * method.  The flip order is the order in which the overlay surfaces
 * were. attached.
 */
#define DDVP_AUTOFLIP				0x00000001l

/*
 * Perform conversion using the ddpfOutputFormat information.
 */
#define DDVP_CONVERT				0x00000002l

/*
 * Perform cropping using the specified rectangle.
 */
#define DDVP_CROP				0x00000004l

/*
 * Indicates that interlaced fields should be interleaved in memory.
 */
#define DDVP_INTERLEAVE				0x00000008l

/*
 * Indicates that the data should be mirrored left to right as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORLEFTRIGHT			0x00000010l

/*
 * Indicates that the data should be mirrored top to bottom as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORUPDOWN			0x00000020l

/*
 * Perform pre-scaling/zooming based on the pre-scale parameters.
 */
#define DDVP_PRESCALE				0x00000040l

/*
 * Ignore input of even fields.
 */
#define DDVP_SKIPEVENFIELDS			0x00000080l

/*
 * Ignore input of odd fields.
 */
#define DDVP_SKIPODDFIELDS			0x00000100l

/*
 * Drive the graphics VSYNCs using the video port VYSNCs.
 */
#define DDVP_SYNCMASTER				0x00000200l

/*
 * The ddpfVBIOutputFormatFormat member contains data that should be used
 * to convert the data within the vertical blanking interval.
 */
#define DDVP_VBICONVERT				0x00000400l

/*
 * Indicates that data within the vertical blanking interval
 * should not be scaled.
 */
#define DDVP_VBINOSCALE				0x00000800l

/*
 * Indicates that these bob/weave decisions should not be
 * overriden by other interfaces.
 */
#define DDVP_OVERRIDEBOBWEAVE			0x00001000l

/*
 * Indicates that the video data should ignore the left and right
 * cropping coordinates when cropping the VBI data.
 */
#define DDVP_IGNOREVBIXCROP			0x00002000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVP_VBINOINTERLEAVE			0x00004000l

/*
 * Indicates that the video port should use the hardware
 * de-interlacing hardware.
 */
#define DDVP_HARDWAREDEINTERLACE		0x00008000l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETINPUTFORMAT/GETOUTPUTFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * Return formats for the video data
 */
#define DDVPFORMAT_VIDEO			0x00000001l

/*
 * Return formats for the VBI data
 */
#define DDVPFORMAT_VBI				0x00000002l
//@@BEGIN_MSINTERNAL

/*
 * Internal flag to disable the VBI/video-only check
 */
#define DDVPFORMAT_NOFAIL			0x08000000l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT SETTARGETSURFACE FLAGS
 *
 ****************************************************************************/

/*
 * Surface should receive video data (and VBI data if a surface
 * is not explicitly attached for that purpose)
 */
#define DDVPTARGET_VIDEO			0x00000001l

/*
 * Surface should receive VBI data
 */
#define DDVPTARGET_VBI				0x00000002l


/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT WAITFORSYNC FLAGS
 *
 ****************************************************************************/

/*
 * Waits until the beginning of the next VSYNC
 */
#define DDVPWAIT_BEGIN				0x00000001l

/*
 * Waits until the end of the next/current VSYNC
 */
#define DDVPWAIT_END				0x00000002l

/*
 * Waits until the beginning of the specified line
 */
#define DDVPWAIT_LINE				0x00000003l

/****************************************************************************
 *
 * DIRECTDRAWVIDEOPORT FLIP FLAGS
 *
 ****************************************************************************/

/*
 * Flips the normal video surface
 */
#define DDVPFLIP_VIDEO				0x00000001l

/*
 * Flips the VBI surface
 */
#define DDVPFLIP_VBI				0x00000002l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETVIDEOSIGNALSTATUS VALUES
 *
 ****************************************************************************/

/*
 * No video signal is present at the video port
 */
#define DDVPSQ_NOSIGNAL				0x00000001l

/*
 * A valid video signal is present at the video port
 */
#define DDVPSQ_SIGNALOK				0x00000002l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Flags
 *
 ****************************************************************************/

/*
 * The specified height/width refer to the size of the video port data
 * written into memory, after prescaling has occured.
 */
#define DDVPB_VIDEOPORT				0x00000001l

/*
 * The specified height/width refer to the source size of the overlay.
 */
#define DDVPB_OVERLAY				0x00000002l

/*
 * This is a query for the device to return which caps this device requires.
 */
#define DDVPB_TYPE				0x00000004l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Caps
 *
 ****************************************************************************/

/*
 * The bandwidth for this device is dependant on the overlay source size.
 */
#define DDVPBCAPS_SOURCE			0x00000001l

/*
 * The bandwidth for this device is dependant on the overlay destination
 * size.
 */
#define DDVPBCAPS_DESTINATION			0x00000002l

/****************************************************************************
 *
 * DDVIDEOPORTCONTAINER CreateVideoPort flags
 *
 ****************************************************************************/

/*
 * The process only wants to control the VBI portion of the video stream.
 */
#define DDVPCREATE_VBIONLY			0x00000001l

/*
 * The process only wants to control the non-VBI (video) portion of
 * the video stream.
 */
#define DDVPCREATE_VIDEOONLY			0x00000002l
//@@BEGIN_MSINTERNAL

/*
 * Internal flag indicating interface is for the IDirectDrawVidoePortNotify object
 */
#define DDVPCREATE_NOTIFY			0x80000000l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DDVIDEOPORTSTATUS flags
 *
 ****************************************************************************/

/*
 * The video port interface is only controlling the VBI portion of the
 * video stream
 */
#define DDVPSTATUS_VBIONLY			0x00000001l

/*
 * The video port interface is only controlling the video portion of the
 * video stream
 */
#define DDVPSTATUS_VIDEOONLY			0x00000002l


#ifdef __cplusplus
};
#endif

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\drvinfo.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All R