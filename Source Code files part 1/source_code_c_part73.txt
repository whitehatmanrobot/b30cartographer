#define CT_SEND_PTR 3

	int m_threadCmd;
	UINT_PTR m_hThread;
	void Notify(IWbemServices * service);
	void NotifyError(void);
	HRESULT EnsureThread(void);
	HWND m_hWndGetPtr;
	IStream *m_pStream;

	LOGIN_CREDENTIALS *m_credentials;

	LONG m_cRef;
};

#endif __SERVICETHREAD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIMFC=1
WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=Common
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES); \
	$(STDLIBRARY_INC)

SOURCES= \
	ServiceThread.cpp \
	ConnectThread.cpp \
	sshWbemHelpers.cpp \
	CHString1.cpp

# Next, specify options for the compiler using C_DEFINES. 
C_DEFINES=$(C_DEFINES) /DBUILDING_DLL /DSHARE_SOURCE
WIN32_WINNT_VERSION=0x0501
USE_NATIVE_EH=ASYNC
USE_RTTI=1
USE_MSVCRT=1
USE_ATL=1
ATL_VER=30
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\simplearray.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#if (_ATL_VER < 0x0300)
/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

#ifndef __SIMPLEARRAY__
#define __SIMPLEARRAY__

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aT[nIndex] = t;
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};
#endif __SIMPLEARRAY__

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\sshwbemhelpers.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  SshWbemHelpers.cpp
//
//
//
//
//  History:
//
//
//
//  Copyright (c) 1997-1999 Microsoft Corporation
///////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <stdio.h>
#include <cominit.h>

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "SshWbemHelpers.h"

#define REFCOUNT(obj) obj->AddRef()?obj->Release():0xFFFFFFFF



//-----------------------------------------------------------------------------
IErrorInfo * CWbemException::GetErrorObject()
{
    IErrorInfo * pEI = NULL;
    GetErrorInfo(0, &pEI);
    return pEI;
}

//-----------------------------------------------------------------------------
IErrorInfo * CWbemException::MakeErrorObject(_bstr_t sDescription)
{
    ICreateErrorInfoPtr pcerrinfo;
    HRESULT hr;

    hr = CreateErrorInfo(&pcerrinfo);

    if(SUCCEEDED(hr))
    {
        pcerrinfo->SetDescription(sDescription);
        pcerrinfo->SetSource(_bstr_t("CWbemException"));

        IErrorInfoPtr perrinfo;
        hr = pcerrinfo->QueryInterface(IID_IErrorInfo, (LPVOID FAR*) &perrinfo);

        if(SUCCEEDED(hr))
        {
            SetErrorInfo(0, perrinfo);
        }
    }

    return GetErrorObject();
}

//-----------------------------------------------------------------------------
void CWbemException::GetWbemStatusObject()
{
    m_pWbemError = new CWbemClassObject();

    if(m_pWbemError)
    {
        IErrorInfoPtr pEI = ErrorInfo();

        if(pEI)
        {
            pEI->QueryInterface(IID_IWbemClassObject, (void**)&(*m_pWbemError));
        }
    }
}

//-----------------------------------------------------------------------------
CWbemException::CWbemException(HRESULT hr,_bstr_t sDescription) :
    _com_error(hr,GetErrorObject()),
    m_sDescription(sDescription),
    m_hr(hr)
{
    GetWbemStatusObject();
}

//-----------------------------------------------------------------------------
CWbemException::CWbemException(_bstr_t sDescription) :
					_com_error(WBEM_E_FAILED,MakeErrorObject(sDescription)),
					m_sDescription(sDescription)
{
    GetWbemStatusObject();
}

//-----------------------------------------------------------------------------
CWbemClassObject CWbemException::GetWbemError()
{
    return *m_pWbemError;
}


//-----------------------------------------------------------------------------
CWbemServices::CWbemServices(IWbemContext * _pContext)
{
    m_pCtx              = _pContext;
	m_authIdent = 0;
	m_pService = 0;
    m_cloak = 0;
}

//-----------------------------------------------------------------------------
CWbemServices::CWbemServices(const CWbemServices& _p, COAUTHIDENTITY *authIdent)
{
	m_authIdent = authIdent;
	m_pService = 0;
    IWbemServicesPtr pServices;
    m_cloak = 0;

    m_hr = S_OK;
    if(SUCCEEDED(const_cast<CWbemServices&>(_p).GetInterfacePtr(pServices)))
    {
        m_hr = CommonInit(pServices);
    }

    m_pCtx = _p.m_pCtx;
}

//-----------------------------------------------------------------------------
CWbemServices::CWbemServices(const IWbemServicesPtr& _in)
{
	m_authIdent = 0;
    m_hr = S_OK;
	m_pService = 0;
    m_cloak = 0;
    m_hr = CommonInit(const_cast<IWbemServicesPtr&>(_in));
}


//-----------------------------------------------------------------------------
CWbemServices::CWbemServices(IWbemServices *_in,IWbemContext * _pContext)
{
    m_pCtx = _pContext;
	m_authIdent = 0;
    m_hr = S_OK;
	m_pService = 0;
    m_cloak = 0;

    IWbemServicesPtr pServices = _in;
    m_hr = CommonInit(pServices);
}


//-----------------------------------------------------------------------------
CWbemServices::CWbemServices(const IUnknownPtr& _in)
{
    IWbemServicesPtr pServices = _in;
	m_authIdent = 0;
    m_hr = S_OK;
	m_pService = 0;
    m_cloak = 0;

    m_hr = CommonInit(pServices);
}


//-----------------------------------------------------------------------------
CWbemServices::CWbemServices(IUnknown * _in)
{
    IWbemServicesPtr pServices = _in;

	m_authIdent = 0;
    m_hr = S_OK;
	m_pService = 0;
    m_cloak = 0;

    m_hr = CommonInit(pServices);
}


//-----------------------------------------------------------------------------
CWbemServices::~CWbemServices()
{
}


//-----------------------------------------------------------------------------
CWbemServices&  CWbemServices::operator=(IWbemServices *_p)
{
    m_pCtx = NULL;

    IWbemServicesPtr pServices = _p;

    m_hr = CommonInit(pServices);
	return *this;
}


//-----------------------------------------------------------------------------
CWbemServices& CWbemServices::operator=(IUnknown * _p)
{
    IWbemServicesPtr pServices = _p;

    m_pCtx = NULL;

    m_hr = CommonInit(pServices);
	return *this;
}


//-----------------------------------------------------------------------------
CWbemServices& CWbemServices::operator=(IUnknownPtr& _p)
{
    IWbemServicesPtr pServices = _p;

    m_pCtx = NULL;

    m_hr = CommonInit(pServices);
	return *this;
}


//-----------------------------------------------------------------------------
CWbemServices& CWbemServices::operator=(const CWbemServices& _p)
{
    IWbemServicesPtr pServices;

    if(SUCCEEDED(const_cast<CWbemServices&>(_p).GetInterfacePtr(pServices)))
    {
        m_hr = CommonInit(pServices);
    }

    m_pCtx = _p.m_pCtx;
	return *this;
}


//-----------------------------------------------------------------------------
HRESULT CWbemServices::GetInterfacePtr(
                                IWbemServicesPtr& pServices,
                                DWORD dwProxyCapabilities)  // = EOAC_NONE
{

    pServices = m_pService;
    SetBlanket(pServices, dwProxyCapabilities);
	return S_OK;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::CommonInit(IWbemServicesPtr& pServ)
{
	HRESULT hr = E_FAIL;
    if(pServ)
    {
		m_pService = pServ;
		hr = SetBlanket((IWbemServices *)m_pService);
    }
	return hr;
}

//---------------------------------------------------------------------
bool CWbemServices::IsClientNT5OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return ( os.dwPlatformId == VER_PLATFORM_WIN32_NT ) && ( os.dwMajorVersion >= 5 ) ;
}

//---------------------------------------------------------------
void CWbemServices::SetPriv(LPCTSTR privName /* = SE_SYSTEM_ENVIRONMENT_NAME */)
{
    ImpersonateSelf(SecurityImpersonation);

	if(OpenThreadToken( GetCurrentThread(),
						TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
						FALSE, &m_hAccessToken ) )
	{
		m_fClearToken = true;

		// Now, get the LUID for the privilege from the local system
		ZeroMemory(&m_luid, sizeof(m_luid));

		LookupPrivilegeValue(NULL, privName, &m_luid);
		m_cloak = true;
		EnablePriv(true);
	}
	else
	{
		DWORD err = GetLastError();
	}
}

//---------------------------------------------------------------
DWORD CWbemServices::EnablePriv(bool fEnable)
{
	DWORD				dwError = ERROR_SUCCESS;
	TOKEN_PRIVILEGES	tokenPrivileges;

	tokenPrivileges.PrivilegeCount = 1;
	tokenPrivileges.Privileges[0].Luid = m_luid;
	tokenPrivileges.Privileges[0].Attributes = ( fEnable ? SE_PRIVILEGE_ENABLED : 0 );

	if(AdjustTokenPrivileges(m_hAccessToken,
								FALSE,
								&tokenPrivileges,
								0, NULL, NULL) != 0)
	{
		IWbemServices *service = NULL;
		GetServices(&service);

        //
        // Enable cloaking so the thread token is available to the
        // provider for the priv check. Reciprocate for disable.
        //
		SetBlanket(service, fEnable ? EOAC_STATIC_CLOAKING : EOAC_NONE);
	}
	else
	{
		dwError = ::GetLastError();
	}

	return dwError;
}

//---------------------------------------------------------------
void CWbemServices::ClearPriv(void)
{

	m_cloak = false;
	EnablePriv(false);

	if(m_fClearToken)
	{
		CloseHandle(m_hAccessToken);
		m_hAccessToken = 0;
		m_fClearToken = false;
	}

	RevertToSelf(); //to make sure impersonation token is removed from thread (counterpart to ImpersonateSelf() in SetPriv())
}

//---------------------------------------------------------------------
HRESULT CWbemServices::SetBlanket(IUnknown *service,
                                  DWORD dwProxyCapabilities) // = EOAC_NONE
{
	HRESULT hr = E_FAIL;
    if(service)
    {
        //
        // Sigh, maintain this hack for RC1.
        //
        DWORD eoac = EOAC_NONE;
        if(IsClientNT5OrMore() && m_cloak)
        {
            eoac = EOAC_STATIC_CLOAKING;
        }

		try
		{
            RPC_AUTH_IDENTITY_HANDLE AuthInfo = NULL;
            DWORD dwAuthnSvc = 0;
            DWORD dwAuthnLvl = 0;
            hr = CoQueryProxyBlanket(
                    service,
                    &dwAuthnSvc,
                    NULL,
                    NULL,
                    &dwAuthnLvl,
                    NULL,
                    &AuthInfo,
                    NULL);

            if (SUCCEEDED(hr))
            {
                hr = SetInterfaceSecurityEx(service,
                                            m_authIdent,
                                            NULL,
                                            dwAuthnLvl,
                                            RPC_C_IMP_LEVEL_IMPERSONATE,
                                            (eoac != EOAC_NONE) ? eoac :
                                                dwProxyCapabilities);
		    }
		}
		catch( ... )
		{
			hr = E_FAIL;
		}
    }
	return hr;
}

//-----------------------------------------------------------------------------
void CWbemServices::DisconnectServer(void)
{
	m_pCtx = NULL;
	m_pService = NULL;
}

//-----------------------------------------------------------------------------
CWbemClassObject CWbemServices::CreateInstance(_bstr_t  _sClass,
												IWbemCallResultPtr& _cr)
{
	CWbemClassObject coClassDef = GetObject(_sClass,_cr);
	CWbemClassObject coRet;

	if(!coClassDef.IsNull())
	{
		coRet = coClassDef.SpawnInstance();
	}

	return coRet;
}

//-----------------------------------------------------------------------------
CWbemClassObject CWbemServices::CreateInstance(_bstr_t _sClass)
{
    IWbemCallResultPtr crUnused;
	return CreateInstance(_sClass,crUnused);
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::DeleteInstance(_bstr_t _sClass)
{
    HRESULT hr;
    IWbemCallResultPtr pResult;

    hr = m_pService->DeleteInstance(_sClass, WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pResult);

    if (SUCCEEDED(hr))      // Useless probably, but eases my paranoia.
    {
        hr = this->SetBlanket(pResult);

        if (SUCCEEDED(hr))
        {
            HRESULT hrTemp;
            hr = pResult->GetCallStatus(WBEM_INFINITE, &hrTemp);

            if (SUCCEEDED(hr))
            {
                hr = hrTemp;
            }
        }
    }

    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::GetMethodSignatures(const _bstr_t& _sObjectName,
											const _bstr_t& _sMethodName,
											CWbemClassObject& _in,
											CWbemClassObject& _out)
{
    CWbemClassObject methodClass = GetObject(_sObjectName);

    if(methodClass)
    {
        m_hr = methodClass.GetMethod(_sMethodName,_in,_out);
    }

    return m_hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::PutInstance(CWbemClassObject&   _object,
									IWbemCallResultPtr& _cr,
									long _lFlags /*= WBEM_FLAG_CREATE_OR_UPDATE*/)
{
	HRESULT hr = E_FAIL;
	IWbemServicesPtr pServices;
	GetInterfacePtr(pServices);
#ifdef NOT_NECESSARY
	if(m_pCtx == NULL)
	{
		IWbemContext *pContext = NULL;
		hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

		if(FAILED(hr))
		{
//			::MessageBox(NULL,_T("Cannot CoCreateInstance"),_T("Error"),MB_OK);
			return hr;
		}
		
		m_pCtx = pContext;
	}
    hr = pServices->PutInstance(_object,_lFlags,m_pCtx,&_cr);
#endif // NOT_NECESSARY

	hr = pServices->PutInstance(_object,_lFlags,NULL,&_cr);
	return hr;
}

//---------------- VINOTH ------------------------------------------------------
HRESULT CWbemServices::PutInstance(
                            CWbemClassObject&   _object,
                            IWbemContext *pContext,
                            long _lFlags,   // = WBEM_FLAG_CREATE_OR_UPDATE
                            DWORD _dwProxyCapabilities)  // = EOAC_NONE
{
	HRESULT hr = E_FAIL;
	IWbemServicesPtr pServices;
	GetInterfacePtr(pServices, _dwProxyCapabilities);
#ifdef NOT_NECESSARY
    IWbemCallResultPtr crUnused;
	hr = pServices->PutInstance(_object,_lFlags,pContext,&crUnused);
#endif // NOT_NECESSARY
	hr = pServices->PutInstance(_object,_lFlags,pContext,NULL);
	return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::PutInstance(
                            CWbemClassObject&   _object,
                            long _lFlags,   // = WBEM_FLAG_CREATE_OR_UPDATE
                            DWORD dwProxyCapabilities)  // = EOAC_NONE
{
#ifdef NOT_NECESSARY
    IWbemCallResultPtr crUnused;
    return PutInstance(_object,crUnused,_lFlags);
#endif // NOT_NECESSARY
    return PutInstance(_object,NULL,_lFlags,dwProxyCapabilities);
}

//-----------------------------------------------------------------------------
bool CWbemServices::IsNull()
{
    bool bRet = m_pService == NULL;

    return bRet;
}

//-----------------------------------------------------------------------------
CWbemServices::operator bool()
{
    bool bRet = m_pService != NULL;
    return bRet;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::CreateInstanceEnum(_bstr_t Class,
											long lFlags,
											IEnumWbemClassObject **ppEnum)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		SetBlanket(m_pService);
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->CreateInstanceEnum(Class, lFlags, m_pCtx, ppEnum);
		SetBlanket(*ppEnum);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::CreateInstanceEnumAsync(_bstr_t Class,
												IWbemObjectSink *ppSink,
												long lFlags /*= 0*/)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		SetBlanket(m_pService);
		hr = m_pService->CreateInstanceEnumAsync(Class, lFlags, m_pCtx, ppSink);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::CreateClassEnum(_bstr_t Class,
										long lFlags,
										IEnumWbemClassObject **ppEnum)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		SetBlanket(m_pService);
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->CreateClassEnum(Class, lFlags, m_pCtx, ppEnum);
		SetBlanket(*ppEnum);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::CreateClassEnumAsync(_bstr_t Class,
												IWbemObjectSink *ppSink,
												long lFlags /*= 0*/)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		SetBlanket(m_pService);
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->CreateClassEnumAsync(Class, lFlags, m_pCtx, ppSink);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ExecQuery(_bstr_t QueryLanguage,
									_bstr_t Query,
									long lFlags,
									IEnumWbemClassObject **ppEnum)
{
    HRESULT hr = E_FAIL;
	if(m_pService)
	{
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->ExecQuery(QueryLanguage, Query,lFlags, m_pCtx, ppEnum);
		SetBlanket(*ppEnum);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ExecQuery(_bstr_t Query,
									long lFlags,
									IEnumWbemClassObject **ppEnum)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->ExecQuery(_bstr_t("WQL"), Query,lFlags, m_pCtx, ppEnum);
		SetBlanket(*ppEnum);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ExecQuery(_bstr_t Query,
									IEnumWbemClassObject **ppEnum)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->ExecQuery(_bstr_t("WQL"), Query,0, m_pCtx, ppEnum);
		SetBlanket(*ppEnum);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ExecQueryAsync(_bstr_t Query,
										IWbemObjectSink * pSink,
										long lFlags /*= 0*/)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->ExecQueryAsync(_bstr_t("WQL"), Query,0, m_pCtx, pSink);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ExecMethod(_bstr_t sPath,
									_bstr_t sMethod,
									CWbemClassObject& inParams,
									CWbemClassObject& outParams)
{
    IWbemCallResultPtr crUnused;
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->ExecMethod(sPath, sMethod,0, m_pCtx, inParams,&outParams,&crUnused);
	}
	return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::CancelAsyncCall(IWbemObjectSink * pSink)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		hr = m_pService->CancelAsyncCall(pSink);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::GetServices(IWbemServices ** ppServices)
{
    IWbemServicesPtr pServices;
    GetInterfacePtr(pServices);

    *ppServices = pServices.Detach();

    return S_OK;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ConnectServer(_bstr_t sNetworkResource)
{
    IWbemLocatorPtr pLocator;
    HRESULT hr;

    // Get a pointer locator and use it to get a pointer to WbemServices!
    hr = pLocator.CreateInstance(CLSID_WbemLocator);

    if(SUCCEEDED(hr))
    {
        IWbemServicesPtr pServices = 0;

        hr = pLocator->ConnectServer(sNetworkResource,               // Network
										NULL,                         // User
										NULL,                         // Password
										NULL,                         // Locale
										0,                            // Security Flags
										NULL,                         // Authority
										NULL,                         // Context
										&pServices);                  // Namespace

        if(SUCCEEDED(hr))
        {
            hr = CommonInit(pServices);
			m_path = sNetworkResource;
        }
    }
	return hr;
}

//-----------------------------------------------------------
CWbemServices CWbemServices::OpenNamespace(_bstr_t sNetworkResource)
{
	CWbemServices coRet;
    IWbemServicesPtr pServices = NULL, pTemp = NULL;

    GetInterfacePtr(pServices);

	m_hr = S_OK;

	if(pServices)
	{
		try {
			m_hr = pServices->OpenNamespace(sNetworkResource,// Network
											0, NULL,           // Password
											&pTemp, NULL);    // Namespace

			if(SUCCEEDED(m_hr))
			{
				coRet = (IWbemServices *)pTemp;
				coRet.m_authIdent = m_authIdent;
				coRet.SetBlanket(pTemp);
				coRet.m_path = sNetworkResource;
			}
		}
		catch( ... )
		{
		}
	}
	return coRet;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ConnectServer(_bstr_t sNetworkResource,
									_bstr_t sUser,
									_bstr_t sPassword,
									long    lSecurityFlags)
{
    IWbemLocatorPtr pLocator;
    HRESULT hr = S_OK;

    // Get a pointer locator and use it to get a pointer to WbemServices!
    pLocator.CreateInstance(CLSID_WbemLocator);

    if(SUCCEEDED(hr))
    {
        IWbemServicesPtr pServices = 0;

        hr = pLocator->ConnectServer(sNetworkResource,               // Network
									sUser,                          // User
									sPassword,                      // Password
									NULL,                           // Locale
									lSecurityFlags,                 // Security Flags
									NULL,                           // Authority
									NULL,                           // Context
									&pServices);

        if(SUCCEEDED(hr))
        {
			//Now Store the User,Passowrd and Security Flags for later use
			m_User = sUser;
			m_Password = sPassword;
			m_lFlags = lSecurityFlags;
            hr = CommonInit(pServices);
			m_path = sNetworkResource;
        }
    }
	return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ConnectServer(_bstr_t sNetworkResource,
									LOGIN_CREDENTIALS *user,
									long    lSecurityFlags/* = 0*/)

{
	HRESULT hr = S_OK;

	if((user == NULL) || user->currUser)
	{
		if(m_authIdent)
		{
			WbemFreeAuthIdentity(m_authIdent);
			m_authIdent = 0;
		}

		hr = ConnectServer(sNetworkResource);
	}
	else
	{
		IWbemLocatorPtr pLocator;

		m_authIdent = user->authIdent;

		// Get a pointer locator and use it to get a pointer to WbemServices!
		pLocator.CreateInstance(CLSID_WbemLocator);

		if(SUCCEEDED(hr))
		{
			IWbemServicesPtr pServices = 0;
			bstr_t usr(user->fullAcct), pwd;

			if(user->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
			{
				WCHAR temp[100] = {0};
				mbstowcs(temp, (const char *)user->authIdent->Password, sizeof(temp)/sizeof(temp[0]));
				pwd = temp;
			}
			else
			{
				// unicode to unicode
				pwd = user->authIdent->Password;
			}

			hr = pLocator->ConnectServer(sNetworkResource, // Network
										(bstr_t)usr,       // User
										(bstr_t)pwd,       // Password
										NULL,              // Locale
										lSecurityFlags,    // Security Flags
										NULL,              // Authority
										NULL,              // Context
										&pServices);

            if (SUCCEEDED(hr))
            {
                // Now Store the User,Password and Security Flags for
                // later use
				m_User = usr;
				m_Password = pwd;
				m_lFlags = lSecurityFlags;
				hr = CommonInit(pServices);
				m_path = sNetworkResource;
		    }
		}
	}
	return hr;
}

//-----------------------------------------------------------------------------
CWbemClassObject CWbemServices::GetObject(_bstr_t _sName,
											IWbemCallResultPtr &_cr,
											long flags /*= 0*/)
{
    CWbemClassObject coRet;
	m_hr = S_OK;
    IWbemServicesPtr pServices;
    GetInterfacePtr(pServices);
	if(m_pCtx == NULL)
	{
		IWbemContext *pContext = NULL;
		m_hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

		if(FAILED(m_hr))
		{
//			::MessageBox(NULL,_T("Cannot CoCreateInstance"),_T("Error"),MB_OK);
			return coRet;
		}
		
		m_pCtx = pContext;
	}

	if( pServices ) 
	{
		m_hr = pServices->GetObject(_sName, flags, m_pCtx,&coRet, &_cr);

	} else {

		//
		// Have no idea whether connected to Remote
		// otherwise the error should have been
		// RPC_E_DISCONNECTED
		//

		m_hr = E_POINTER;
	}

    return coRet;
}

//------------------------------------------------
CWbemClassObject CWbemServices::GetObject(_bstr_t _sName, long flags /*= 0*/)
{
    IWbemCallResultPtr crUnused;
    return GetObject(_sName,crUnused, flags);
}

//------------------------------------------------
// get the first instance of the named class.
IWbemClassObject *CWbemServices::FirstInstanceOf(bstr_t className)
{
	IWbemClassObject *pInst = NULL;
	ULONG uReturned;
	IEnumWbemClassObject *Enum = NULL;

	m_hr = S_OK;
	// get the class.
	m_hr = CreateInstanceEnum(className, WBEM_FLAG_SHALLOW, &Enum);
	if(SUCCEEDED(m_hr))
	{
		// get the first and only instance.
		Enum->Next(-1, 1, &pInst, &uReturned);
		Enum->Release();
	}
	return pInst;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::SetContextValue(_bstr_t sName,_variant_t value)
{
    HRESULT hr = S_OK;

    if(!bool(m_pCtx))
    {
        hr = m_pCtx.CreateInstance(CLSID_WbemContext);
    }

    if( SUCCEEDED(hr) )
    {
        hr = m_pCtx->SetValue(sName,0,&value);
    }

    return hr;
}


//-----------------------------------------------------------------------------
HRESULT CWbemServices::SetContext(IWbemContext * pWbemContext)
{
    HRESULT hr = S_OK;

    m_pCtx = pWbemContext;

    return hr;
}


//-----------------------------------------------------------------------------
HRESULT CWbemServices::GetContextValue(_bstr_t sName,_variant_t& value)
{
    HRESULT hr = S_OK;

    if(m_pCtx)
    {
        hr = m_pCtx->GetValue(sName,0,&value);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


//-----------------------------------------------------------------------------
HRESULT CWbemServices::DeleteContextValue(_bstr_t sName)
{
    HRESULT hr = S_OK;

    if(m_pCtx)
    {
        hr = m_pCtx->DeleteValue(sName,0);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::DeleteAllContextValues()
{
    HRESULT hr = S_OK;

    if(m_pCtx)
    {
        hr = m_pCtx->DeleteAll();
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


//-----------------------------------------------------------------------------
HRESULT CWbemServices::GetContext(IWbemContext **ppWbemContext)
{
    HRESULT hr = E_FAIL;

    if(m_pCtx)
    {
        m_pCtx->AddRef();
        *ppWbemContext = m_pCtx;
        hr = S_OK;
    }

    return hr;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

DWORD g_ObjectCount = 0;

#define TESTOBJ if(m_pWbemObject==0)return WBEM_E_NOT_AVAILABLE;

//-----------------------------------------------------------------------------
CWbemClassObject::CWbemClassObject(const CWbemClassObject&  _in):
	m_pWbemObject(_in.m_pWbemObject)
{
	ref = 0;
    g_ObjectCount++;
}

//-----------------------------------------------------------------------------
CWbemClassObject::CWbemClassObject(IWbemClassObject * const _in):
	m_pWbemObject(_in)
{
	ref = 0;
    g_ObjectCount++;
}


//-----------------------------------------------------------------------------
CWbemClassObject::CWbemClassObject(IWbemClassObjectPtr& _in) :
    m_pWbemObject(_in)
{
	ref = 0;
    g_ObjectCount++;
}


//-----------------------------------------------------------------------------
CWbemClassObject::CWbemClassObject(IUnknown * _in):
	m_pWbemObject(_in)
{
	ref = 0;
    g_ObjectCount++;
}

//-----------------------------------------------------------------------------
CWbemClassObject::CWbemClassObject(IUnknownPtr& _in):
	m_pWbemObject(_in)
{
	ref = 0;
    g_ObjectCount++;
}


//-----------------------------------------------------------------------------
CWbemClassObject::CWbemClassObject():
	m_pWbemObject()
{
	ref = 0;
    g_ObjectCount++;
}


//-----------------------------------------------------------------------------
CWbemClassObject::~CWbemClassObject()
{
    g_ObjectCount--;
}

//-----------------------------------------------------------------------------
void CWbemClassObject::Attach(IWbemClassObject * pWbemObject)
{
    m_pWbemObject.Attach(pWbemObject);
}

//-----------------------------------------------------------------------------
void CWbemClassObject::Attach(IWbemClassObject * pWbemObject,bool bAddRef)
{
    m_pWbemObject.Attach(pWbemObject,bAddRef);
}

//-----------------------------------------------------------------------------
IWbemClassObject *CWbemClassObject::operator->()
{
    return m_pWbemObject;
}

//-----------------------------------------------------------------------------
_bstr_t CWbemClassObject::GetObjectText()
{
    _bstr_t bRet;

    BSTR bstr;

    if( !FAILED(m_pWbemObject->GetObjectText(0,&bstr)) )
    {
        bRet = _bstr_t(bstr,false);
    }

    return bRet;
}

//-----------------------------------------------------------------------------
IWbemClassObject * CWbemClassObject::Detach()
{
    return m_pWbemObject.Detach();
}

//-----------------------------------------------------------------------------
CWbemClassObject::operator IWbemClassObject*()
{
    return m_pWbemObject;
}

//-----------------------------------------------------------------------------
CWbemClassObject::operator IWbemClassObject**()
{
    return &m_pWbemObject;
}

//-----------------------------------------------------------------------------
CWbemClassObject::operator IWbemClassObjectPtr()
{
    return m_pWbemObject;
}

//-----------------------------------------------------------------------------
CWbemClassObject::operator IUnknown *()
{
    return (IUnknown *)(IWbemClassObject *)m_pWbemObject;
}


//-----------------------------------------------------------------------------
IWbemClassObject ** CWbemClassObject::operator &()
{
    return &m_pWbemObject;
}

//-----------------------------------------------------------------------------
bool CWbemClassObject::operator!()
{
    return m_pWbemObject == NULL;
}

//-----------------------------------------------------------------------------
CWbemClassObject::operator bool()
{
    return m_pWbemObject != NULL;
}

//-----------------------------------------------------------------------------
ULONG CWbemClassObject::AddRef()
{
	ref++;
    return m_pWbemObject->AddRef();
}

//-----------------------------------------------------------------------------
ULONG CWbemClassObject::Release()
{
	ref--;
    return m_pWbemObject->Release();
}

//-----------------------------------------------------------------------------
IWbemClassObject* CWbemClassObject::operator=(IWbemClassObject* _p)
{
    m_pWbemObject = _p;
	return m_pWbemObject;
}

//-----------------------------------------------------------------------------
IWbemClassObjectPtr CWbemClassObject::operator=(IWbemClassObjectPtr& _p)
{
    m_pWbemObject = _p;
	return m_pWbemObject;
}


//-----------------------------------------------------------------------------
IWbemClassObject* CWbemClassObject::operator=(IUnknown * _p)
{
    m_pWbemObject = _p;
	return m_pWbemObject;
}

//-----------------------------------------------------------------------------
IWbemClassObjectPtr CWbemClassObject::operator=(IUnknownPtr& _p)
{
    m_pWbemObject = _p;
	return m_pWbemObject;
}


//-----------------------------------------------------------------------------
IWbemClassObject* CWbemClassObject::operator=(const CWbemClassObject& _p)
{
    m_pWbemObject = _p.m_pWbemObject;
	return m_pWbemObject;
}

//-----------------------------------------------------------------------------
bool CWbemClassObject::IsNull() const
{
    return m_pWbemObject ==NULL;
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Clone(CWbemClassObject& _newObject)
{
    return m_pWbemObject->Clone(_newObject);
}

//-----------------------------------------------------------------------------
CWbemClassObject CWbemClassObject::SpawnInstance()
{
    CWbemClassObject coRet;

    HRESULT hr = m_pWbemObject->SpawnInstance(0,coRet);

    return coRet;
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::GetMethod(const IN _bstr_t& _name,
									CWbemClassObject& coInSignature,
									CWbemClassObject& coOutSignature,
									long _lFlags /*= 0*/)
{
	TESTOBJ;
	return m_pWbemObject->GetMethod(_name, _lFlags, coInSignature, coOutSignature);
}

//-----------------------------------------------------------------------------
bool CWbemClassObject::operator<(const CWbemClassObject& _comp)
{
    return m_pWbemObject < _comp.m_pWbemObject;
}


//-----------------------------------------------------------------------------
// put overloads
HRESULT CWbemClassObject::Put(const _bstr_t& _Name,_variant_t _value,CIMTYPE vType /*= 0*/)
{
	TESTOBJ;
    return m_pWbemObject->Put(_Name,0,&_value,vType);
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Put(const _bstr_t& _Name,const _bstr_t& _value,CIMTYPE vType /*= 0*/)
{
	TESTOBJ;
	return m_pWbemObject->Put(_Name,0,&_variant_t(_value),vType);
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Put(const _bstr_t& _Name, const long _value, CIMTYPE vType /*= 0*/)
{
	TESTOBJ;
	return m_pWbemObject->Put(_Name,0,&_variant_t(_value), vType);
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Put(const _bstr_t& _Name, const bool _value,CIMTYPE vType /*= 0*/)
{
	TESTOBJ;
    return m_pWbemObject->Put(_Name,0,&_variant_t(_value),vType);
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Get(const _bstr_t& _Name, _bstr_t& _value)
{
	_variant_t v1;
	TESTOBJ;
	HRESULT hr = m_pWbemObject->Get (_Name, 0, &v1, NULL, NULL);
	_value = v1;
	return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Get(const _bstr_t& _Name, long& _value)
{
	_variant_t v1;
	TESTOBJ;
	HRESULT hr = m_pWbemObject->Get (_Name, 0, &v1, NULL, NULL);
	_value = v1;
	return hr;

}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Get(const _bstr_t& _Name, bool& _value)
{
	_variant_t v1;
	TESTOBJ;
	HRESULT hr = m_pWbemObject->Get (_Name, 0, &v1, NULL, NULL);
	_value = v1;
	return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Get(const _bstr_t& _Name,_variant_t& _value)
{
	TESTOBJ;
	return m_pWbemObject->Get (_Name, 0, &_value, NULL, NULL);
}


//-----------------------------------------------------------------------------
_variant_t CWbemClassObject::Get(const _bstr_t& _Name,CIMTYPE& vType,long& lFlavor)
{
    _variant_t vRet;

    m_pWbemObject->Get(_Name, 0, &vRet, &vType, &lFlavor);

    return vRet;
}

//-----------------------------------------------------------------------------
unsigned long CWbemClassObject::GetObjectSize()
{
    unsigned long ulRet = 0;

    IMarshalPtr pTest = (IUnknown*)m_pWbemObject;

    if(pTest)
    {
        pTest->GetMarshalSizeMax(IID_IWbemClassObject,(IUnknown*)m_pWbemObject,MSHCTX_LOCAL,NULL,MSHLFLAGS_NORMAL,&ulRet);
    }

    return ulRet;
}

//-----------------------------------------------------------------------------
_bstr_t CWbemClassObject::GetString(const _bstr_t& _Name)
{
    HRESULT hr;
    _variant_t v1;
    hr = Get(_Name, v1);
	if(v1.vt == VT_NULL)
	{
		return "";
	}
	return v1;
}

//-----------------------------------------------------------------------------
_int64 CWbemClassObject::GetI64(const _bstr_t& _Name)
{
    HRESULT hr;
    _variant_t v1;
	_bstr_t str;

    hr = Get(_Name, v1);
	if(v1.vt == VT_NULL)
	{
		return 0;
	}
	str = (_bstr_t) v1;
	return _atoi64(str);
}


//-----------------------------------------------------------------------------
long CWbemClassObject::GetLong(const _bstr_t& _Name)
{
    HRESULT hr;
    _variant_t v1;
    hr = Get(_Name,v1);
	if(v1.vt == VT_NULL)
	{
		return 0;
	}
    return v1;
}


//-----------------------------------------------------------------------------
bool CWbemClassObject::GetBool(const _bstr_t& _Name)
{
	HRESULT hr;
	_variant_t v1;
	hr = Get (_Name, v1);
	if(v1.vt == VT_NULL)
	{
		return false;
	}
	return v1;
}


//-----------------------------------------------------------------------------
_bstr_t CWbemClassObject::GetCIMTYPE(const _bstr_t& _Name)
{
    IWbemQualifierSetPtr pQualifierSet;
    _bstr_t              sRet;

    if(m_pWbemObject->GetPropertyQualifierSet(_Name, &pQualifierSet) == S_OK)
    {
        _variant_t vt;

        if(pQualifierSet->Get(_bstr_t("CIMTYPE"), 0, &vt, NULL) == S_OK)
        {
            sRet = vt;
        }
    }

    return sRet;
}


//-----------------------------------------------------------------------------
CWbemClassObject CWbemClassObject::GetEmbeddedObject(const _bstr_t& _Name)
{
    CWbemClassObject    coRet;
    HRESULT             hr;

    _variant_t v1;

    hr = Get(_Name,v1);

    if(hr == S_OK)
    {
        if(v1.vt == VT_UNKNOWN)
        {
            coRet = (IWbemClassObject*) v1.punkVal;
        }
    }

    return coRet;
}


//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::PutEmbeddedObject(const _bstr_t& _Name,
											CWbemClassObject &obj)
{
	HRESULT hr = S_OK;
	IWbemClassObject *temp = obj;
	LPUNKNOWN pUnk = 0;

	if(temp)
	{
		hr = temp->QueryInterface(IID_IUnknown, (void**)&pUnk);
		if(SUCCEEDED(hr))
		{
			_variant_t v1((IUnknown *)pUnk);

			hr = Put(_Name, v1);
		}
	}

	return hr;
}

//--------------------------------------------------------------------------
HRESULT CWbemClassObject::GetBLOB(const _bstr_t& _Name,
									BYTE **ptr,
									DWORD *outLen)
{
	void* pVoid;
	variant_t vValue;
  	SAFEARRAY* sa;
	DWORD len = 0;

	HRESULT hr = Get(_Name, vValue);

	// if got a BYTE array back....
	if(SUCCEEDED(hr) &&
		(vValue.vt & VT_ARRAY) &&
		(vValue.vt & VT_UI1))
	{
		// get it out.
		sa = V_ARRAY(&vValue);

		long lLowerBound = 0, lUpperBound = 0 ;

		SafeArrayGetLBound(sa, 1, &lLowerBound);
		SafeArrayGetUBound(sa, 1, &lUpperBound);

		len = lUpperBound - lLowerBound + 1;

		if(ptr)
		{
			// I want an null ptr ptr.
			if(*ptr)
			{
				hr = E_FAIL;
			}
			else
			{
  				 // Get a pointer to read the data into.
				*ptr = (LPBYTE)LocalAlloc(LPTR, len);
				if(*ptr != NULL)
				{
 					SafeArrayAccessData(sa, &pVoid);
					memcpy(*ptr, pVoid, len);
  					SafeArrayUnaccessData(sa);

					if(outLen)
						*outLen = len;

					hr = S_OK;
				}
				else
				{
					hr = E_FAIL;
				}
			}
		}
	}
	return hr;
}

//--------------------------------------------------------------------------
HRESULT CWbemClassObject::PutBLOB(const _bstr_t& _Name,
								const BYTE *ptr,
								const DWORD len)
{
	variant_t vValue;
	HRESULT hr = E_FAIL;
	void *pBuf = 0;

	// got something to do?
	if(ptr)
	{
		// set the UINT8 array for the BLOB.
		SAFEARRAY* sa;
		SAFEARRAYBOUND rgsabound[1];

		rgsabound[0].cElements = len;
		rgsabound[0].lLbound = 0;
		sa = SafeArrayCreate(VT_UI1, 1, rgsabound);

 		 // Get a pointer to read the data into
      	SafeArrayAccessData(sa, &pBuf);
      	memcpy(pBuf, ptr, rgsabound[0].cElements);
      	SafeArrayUnaccessData(sa);

		// Put the safearray into a variant, and send it off
		V_VT(&vValue) = VT_UI1 | VT_ARRAY;
		V_ARRAY(&vValue) = sa;

		hr = Put(_Name, vValue);
	}
	return hr;
}

//----------------------------------------------------------------------
HRESULT CWbemClassObject::GetDIB(const _bstr_t& _Name, HDC hDC,
								 HBITMAP &hDDBitmap)
{

	//NOTE: THIS DOESN'T WORK YET.

	variant_t blob;

	HRESULT hr = Get(_Name, blob);

	// if got a BYTE array back....
	if(SUCCEEDED(hr) &&
		(blob.vt & VT_ARRAY) &&
		(blob.vt & VT_UI1))
	{
		BITMAPFILEHEADER *lpFile;
		BYTE *blobData;
		DWORD len = 0;

		// get it out.
		SAFEARRAY *sa = V_ARRAY(&blob);

		// go right to the bytes.
 		SafeArrayAccessData(sa, (void **)&blobData);

		// cast to FileHeader
		lpFile = (BITMAPFILEHEADER *)blobData;

		// is it a DIB?
		if(lpFile->bfType == 0x4d42)	/* 'BM' */
		{
			DWORD bfileSize = lpFile->bfOffBits;
			BITMAPINFOHEADER *lpInfo;

			// pt to the BITMAPINFO which immediately follows the BITMAPFILEHEADER.
			lpInfo = (BITMAPINFOHEADER *)blobData + sizeof(BITMAPFILEHEADER);

			// let this guy do the work.
			hDDBitmap = CreateDIBitmap(hDC,
										(LPBITMAPINFOHEADER)lpInfo,
										CBM_INIT,
										(LPSTR)lpInfo + lpInfo->biSize + PaletteSize(lpInfo),
										(BITMAPINFO *)lpInfo,
										DIB_RGB_COLORS);
		}
		else
		{
			hDDBitmap = 0;
			hr = WBEM_E_TYPE_MISMATCH;  // not a DIB.
		}

  		SafeArrayUnaccessData(sa);

		hr = S_OK;
	}

    return hr;
}

//-------------------------------------------------------------------
WORD CWbemClassObject::PaletteSize(LPBITMAPINFOHEADER lpbi)
{
    WORD NumColors = DibNumColors(lpbi);

    if(lpbi->biSize == sizeof(BITMAPCOREHEADER))
	{
        return (WORD)(NumColors * sizeof(RGBTRIPLE));
	}
    else
	{
        return (WORD)(NumColors * sizeof(RGBQUAD));
	}
}

//-------------------------------------------------------------------
WORD CWbemClassObject::DibNumColors(LPBITMAPINFOHEADER lpbi)
{
    int bits = 0;
    LPBITMAPCOREHEADER  lpbc = (LPBITMAPCOREHEADER)lpbi;

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     */
    if(lpbi->biSize != sizeof(BITMAPCOREHEADER))
	{
        if (lpbi->biClrUsed != 0)
            return (WORD)lpbi->biClrUsed;

        bits = lpbi->biBitCount;
    }
    else
	{
        bits = lpbc->bcBitCount;
	}

    switch(bits)
	{
        case 1: return 2;
        case 4: return 16;
        case 8: return 256;
        default: return 0;  /* A 24 bitcount DIB has no color table */
    }
}

//-------------------------------------------------------------------
HRESULT CWbemClassObject::GetValueMap(const _bstr_t& _Name,
									  long value,
									  _bstr_t &str)
{
    HRESULT hrMap, hr = WBEM_E_NOT_FOUND;
    _variant_t vArray, vMapArray;
	IWbemQualifierSet *qual = NULL;

	// get the qualifiers.
    hr = m_pWbemObject->GetPropertyQualifierSet(_Name, &qual);
	if(SUCCEEDED(hr) && qual)
	{
		// see if there's a valueMap.
		hrMap = qual->Get(L"ValueMap", 0, &vMapArray, NULL);

		// get the Value qualifier.
		hr = qual->Get(L"Values", 0, &vArray, NULL);
		if(SUCCEEDED(hr) && (vArray.vt == (VT_BSTR|VT_ARRAY)))
		{
			// get the property value we're mapping.
		    long index;

			// do we need to walk through the valueMap?
			if(SUCCEEDED(hrMap))
			{
				SAFEARRAY *pma = V_ARRAY(&vMapArray);
				long lLowerBound = 0, lUpperBound = 0 ;

				SafeArrayGetLBound(pma, 1, &lLowerBound);
				SafeArrayGetUBound(pma, 1, &lUpperBound);

				for(long x = lLowerBound; x <= lUpperBound; x++)
				{
					BSTR vMap;
					SafeArrayGetElement(pma, &x, &vMap);
					long vInt = _ttol((LPCTSTR)vMap);

					if(value == vInt)
					{
						index = x;
						break; // found it.
					}
				} //endfor
			}
			else
			{
				index = value;
			}

			// lookup the string.
			SAFEARRAY *psa = V_ARRAY(&vArray);
			long ix[1] = {index};
			BSTR str2;
			hr = SafeArrayGetElement(psa, ix, &str2);
			if(SUCCEEDED(hr))
			{
				str = str2;
				SysFreeString(str2);
				hr = S_OK;
			}
			else
			{
				hr = WBEM_E_VALUE_OUT_OF_RANGE;
			}
		}
		qual->Release();
	}
	return hr;
}

//-----------------------------------------------------------
#define ITSA_BAD_PREFIX -3
#define ITSA_GOT_LETTERS -2
#define ITSA_MISSING_DECIMAL -1
#define ITSA_WRONG_SIZE 0
#define ITSA_DATETIME 1
#define ITSA_INTERVAL 2

int CWbemClassObject::ValidDMTF(bstr_t dmtf)
{
    int retval = ITSA_DATETIME;
	TCHAR wszText[26] = {0};

	_tcscpy(wszText, (LPCTSTR)dmtf);

    if(_tcslen(wszText) != 25)
        retval = ITSA_WRONG_SIZE; // wrong size.

    else if(wszText[14] != _T('.'))
        retval = ITSA_MISSING_DECIMAL;   // missing decimal

    else if(_tcsspn(wszText, _T("0123456789-+:.")) != 25)
        retval = ITSA_GOT_LETTERS;

    else if(retval > 0)
    {
        if(wszText[21] == _T('+'))
            retval = ITSA_DATETIME;
        else if(wszText[21] == _T('-'))
            retval = ITSA_DATETIME;
        else if(wszText[21] == _T(':'))
            retval = ITSA_INTERVAL;
        else
            retval = ITSA_BAD_PREFIX;   // wrong utc prefix.
    }
    return retval;
}

//-----------------------------------------------------------
HRESULT CWbemClassObject::GetDateTimeFormat(const _bstr_t& _Name,
											bstr_t &timeStr)
{
    int v = 0;
	HRESULT hr = WBEM_E_NOT_FOUND;

	SYSTEMTIME st, local;
	TCHAR temp[100] = {0};

	bstr_t dmtf = GetString(_Name);

    // validate it.
    if((v = ValidDMTF(dmtf)) == ITSA_DATETIME)
    {
		_stscanf(dmtf, _T("%4hu%2hu%2hu%2hu%2hu%2hu"),
					&st.wYear, &st.wMonth, &st.wDay,
					&st.wHour, &st.wMinute, &st.wSecond);

		st.wMilliseconds = 0;

		// its always GMT so localize it.
		TIME_ZONE_INFORMATION tzi;
		DWORD zone = GetTimeZoneInformation(&tzi);

		if(SystemTimeToTzSpecificLocalTime(&tzi, &st, &local) == 0)
		{
			// argh 9x, we're on our own.
			LARGE_INTEGER UTC_FT, local_FT, bias;

			// failed cuz its 9x so GetTzInfo() return behavior is "obvious".
			bias.QuadPart = Int32x32To64((zone == TIME_ZONE_ID_DAYLIGHT ?
												(tzi.Bias + tzi.DaylightBias)*60 :
												(tzi.Bias + tzi.StandardBias)*60), // Bias in seconds
											10000000);

			// convert the UTC systemtime to UTC filetime.
			if(SystemTimeToFileTime(&st, (LPFILETIME)&UTC_FT))
			{
				// now we can trust the math.
				local_FT.QuadPart = UTC_FT.QuadPart - bias.QuadPart;

				if(!FileTimeToSystemTime((LPFILETIME)&local_FT, &local))
				{
					// failed. Pass through UTC.
					memcpy(&local, &st, sizeof(SYSTEMTIME));
				}
			}
			else
			{
				// failed. Pass through UTC.
				memcpy(&local, &st, sizeof(SYSTEMTIME));
			}
		}

		DWORD chUsed = GetDateFormat(NULL, 0, &local, NULL, temp, 100);

		if(chUsed <= 0)
		{
			hr = HRESULT_FROM_WIN32(chUsed);
		}
		else
		{
			temp[chUsed-1] = _T(' ');
			chUsed = GetTimeFormat(NULL, TIME_NOSECONDS, &local, NULL, &(temp[chUsed]), 100 - chUsed);
			//claim victory.

			if(chUsed <= 0)
			{
				hr = HRESULT_FROM_WIN32(chUsed);
			}
			else
			{
				timeStr = temp;
				hr = S_OK;
			}
		}
    }
	else
	{
		hr = WBEM_E_TYPE_MISMATCH;
	}

    return hr;
}

//-----------------------------------------------------------------------------
// these cast string props fm the parm.
HRESULT CWbemClassObject::PutEx(const _bstr_t& _Name, const long _value, CIMTYPE vType)
{
	_variant_t test;
	HRESULT hr = Get(_Name, test);

	// it wants a string...
	if(test.vt == VT_BSTR)
	{
		TCHAR temp[40] = {0};
		_ltot(_value, temp, 10);
		return Put(_Name, (bstr_t)temp);
	}
	else
		return Put(_Name, (long)_value);

}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::PutEx(const _bstr_t& _Name, const bool _value,CIMTYPE vType)
{
	_variant_t test;
	HRESULT hr = Get(_Name, test);

	// it wants a string...
	if(test.vt == VT_BSTR)
	{
		bstr_t temp = (_value? _T("1"):_T("0"));
		return Put(_Name, temp);
	}
	else
		return Put(_Name, (long)_value);

}

//-----------------------------------------------------------------------------
long CWbemClassObject::GetLongEx(const _bstr_t& _Name)
{
	_variant_t _value(0L);
	HRESULT hr = Get(_Name, _value);

	if(FAILED(hr))
		return 0;
	if(_value.vt == VT_BSTR)
	{
		bstr_t temp = V_BSTR(&_value);
		return _ttol(temp);
	}
	else if (_value.vt == VT_NULL)
		return 0;
	else
		return _value;
}

//-----------------------------------------------------------------------------
bool CWbemClassObject::GetBoolEx(const _bstr_t& _Name)
{
	_variant_t _value;
	HRESULT hr = Get(_Name, _value);

	if(_value.vt == VT_BSTR)
	{
		LPWSTR temp = V_BSTR(&_value);
		return (temp[0] != L'0');
	}
	else if (_value.vt == VT_NULL)
		return false;
	else
		return _value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\sshwbemhelpers.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#if !defined(__SdkWbemHelpers_H)
#define      __SdkWbemHelpers_H
#pragma once

#if defined(_SDKWBEMHELPERS) || defined(_BUILD_SDKWBEMHELPERS)
#undef SMSSDK_Export

    #if defined(_BUILD_SDKWBEMHELPERS)
        #define SMSSDK_Export __declspec(dllexport)
    #else
        #define SMSSDK_Export __declspec(dllimport)
    #endif
#else
    #define SMSSDK_Export
#endif

#include <wbemidl.h>
#include <comdef.h>

SMSSDK_Export _bstr_t GetWbemErrorText(HRESULT hr);


class CWbemClassObject;
class CWbemServices;



_COM_SMARTPTR_TYPEDEF(IUnsecuredApartment,          IID_IUnsecuredApartment);
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink,              IID_IWbemObjectSink);
_COM_SMARTPTR_TYPEDEF(IWbemClassObject,             IID_IWbemClassObject);
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemCallResult,              IID_IWbemCallResult);
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet,            IID_IWbemQualifierSet);
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);
_COM_SMARTPTR_TYPEDEF(IWbemObjectAccess,            IID_IWbemObjectAccess);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);


//-----------------------------------------------------------------------------
class SMSSDK_Export CWbemException : public _com_error
{
private:
    CWbemClassObject *  m_pWbemError;
    HRESULT             m_hr;
    _bstr_t             m_sDescription;

    static IErrorInfo * GetErrorObject();
    static IErrorInfo * MakeErrorObject(_bstr_t);
    void GetWbemStatusObject();

public:
    CWbemException(HRESULT hr,_bstr_t sMessage);
    CWbemException(_bstr_t sMessage);

    CWbemClassObject GetWbemError();

    _bstr_t GetDescription() { return m_sDescription;  }
    HRESULT GetErrorCode()   { return m_hr;            }
};


//-----------------------------------------------------------------------------
class SMSSDK_Export CWbemClassObject
{
private:
    IWbemClassObjectPtr     m_pWbemObject;
	ULONG ref;
public:
	CWbemClassObject(const CWbemClassObject&  _in);
	CWbemClassObject(IWbemClassObject * const _in);
    CWbemClassObject(IWbemClassObjectPtr& _in);
    CWbemClassObject(IUnknown * _in);
    CWbemClassObject(IUnknownPtr& _in);
	CWbemClassObject();
    ~CWbemClassObject();

    ULONG AddRef();
    ULONG Release();

    void Attach(IWbemClassObject * pWbemObject);
    void Attach(IWbemClassObject * pWbemObject,bool bAddRef);
    IWbemClassObject * Detach();

    IWbemClassObject * operator->();
    operator IWbemClassObject*();
    operator IWbemClassObject**();
    operator IWbemClassObjectPtr();
	operator IUnknown *();
    IWbemClassObject ** operator &();
	IWbemClassObject* operator=(IWbemClassObject* _p);
	IWbemClassObjectPtr operator=(IWbemClassObjectPtr& _p);
	IWbemClassObject* operator=(IUnknown * _p);
	IWbemClassObjectPtr operator=(IUnknownPtr& _p);
	IWbemClassObject* operator=(const CWbemClassObject& _p);

    bool operator<(const CWbemClassObject& _comp);

    bool IsNull() const ;
    bool operator !();
    operator bool();

    unsigned long GetObjectSize();
    _bstr_t GetObjectText();

    HRESULT Clone(CWbemClassObject& _newObject);
    CWbemClassObject SpawnInstance();

	// put overloads
    HRESULT Put(const _bstr_t& _Name,_variant_t _value,CIMTYPE vType = 0);
    HRESULT Put(const _bstr_t& _Name,const _bstr_t& _value,CIMTYPE vType = 0);
	HRESULT Put(const _bstr_t& _Name, const long _value, CIMTYPE vType = 0);
	HRESULT Put(const _bstr_t& _Name, const bool _value,CIMTYPE vType = 0);
    HRESULT Get(const _bstr_t& _Name, _bstr_t& _value);
	HRESULT Get(const _bstr_t& _Name, long& _value);
	HRESULT Get(const _bstr_t& _Name, bool& _value);
    HRESULT Get(const _bstr_t& _Name,_variant_t& _value);
    _variant_t Get(const _bstr_t& _Name,CIMTYPE& vType,long& lFlavor);

    _bstr_t GetString(const _bstr_t& _Name);
    _int64  GetI64(const _bstr_t& _Name);
    long    GetLong(const _bstr_t& _Name);
	bool    GetBool(const _bstr_t& _Name);
    _bstr_t GetCIMTYPE(const _bstr_t& _Name);
	HRESULT GetValueMap (const _bstr_t& _Name, long value, _bstr_t &str);

	// these cast string props to the retval.
    long    GetLongEx(const _bstr_t& _Name);
	bool    GetBoolEx(const _bstr_t& _Name);
	// these cast string props fm the parm.
	HRESULT PutEx(const _bstr_t& _Name, const long _value, CIMTYPE vType = 0);
	HRESULT PutEx(const _bstr_t& _Name, const bool _value,CIMTYPE vType = 0);
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    CWbemClassObject GetEmbeddedObject(const _bstr_t& _Name);
    HRESULT PutEmbeddedObject(const _bstr_t& _Name, CWbemClassObject &obj);

	HRESULT GetBLOB(const _bstr_t& _Name, BYTE **ptr, DWORD *outLen = NULL);
	HRESULT PutBLOB(const _bstr_t& _Name, const BYTE *ptr, const DWORD len);
	HRESULT GetDateTimeFormat(const _bstr_t& _Name, bstr_t &timeStr);
	HRESULT GetDIB(const _bstr_t& _Name, HDC hDC, HBITMAP &hDDBitmap);

    HRESULT BeginEnumeration(long _lFlags = WBEM_FLAG_LOCAL_ONLY);
    HRESULT Next(_bstr_t& _sName,_variant_t& _value);
    HRESULT Next(_bstr_t& _sName,_variant_t& _value,CIMTYPE& _vartype);
    HRESULT Next(_bstr_t& _sName,_variant_t& _value,CIMTYPE& _vartype,long& _flavor);
    HRESULT EndEnumeration();

	HRESULT GetMethod(const IN _bstr_t& _name, CWbemClassObject& coInSignature,
								CWbemClassObject& coOutSignature, long _lFlags = 0);


private:
	int ValidDMTF(bstr_t dmtf);

	// helpers for GetDIB().
	WORD DibNumColors(LPBITMAPINFOHEADER lpbi);
	WORD PaletteSize(LPBITMAPINFOHEADER lpbi);

};


__inline bool operator<(const CWbemClassObject& _X,const CWbemClassObject& _Y)
{
    return _X < _Y;
}

__inline bool operator==(const CWbemClassObject& _X,const CWbemClassObject& _Y)
{
    return _X == _Y;
}

//-----------------------------------------------------------------------------
typedef struct {
	bool currUser;
	COAUTHIDENTITY *authIdent;
	TCHAR fullAcct[100];
} LOGIN_CREDENTIALS;

class SMSSDK_Export CWbemServices 
{
private:

    HRESULT GetInterfacePtr(IWbemServicesPtr & pServices,
                            DWORD _dwProxyCapabilities = EOAC_NONE);
    HRESULT CommonInit(IWbemServicesPtr& pServ);
	bool IsClientNT5OrMore(void);
	HANDLE m_hAccessToken;
	LUID m_luid;
	bool m_fClearToken;
public:
	bool m_cloak;  // protects the cloak from eoac.
	COAUTHIDENTITY *m_authIdent;
	_bstr_t m_path;
    HRESULT m_hr;
    IWbemServicesPtr m_pService;
    IWbemContextPtr     m_pCtx;

	_bstr_t m_User;
	_bstr_t m_Password;
	long m_lFlags;

	CWbemServices(IWbemContext * _pContext = NULL);
    CWbemServices(const CWbemServices& _p, COAUTHIDENTITY *authIdent = 0);
	CWbemServices(const IWbemServicesPtr& _in);
    CWbemServices(const IUnknownPtr& _in);
    CWbemServices(IUnknown * _in);
	CWbemServices(IWbemServices *_in,IWbemContext * _pContext = NULL);
    
	~CWbemServices();

    CWbemServices& operator=(IUnknown * _p);
    CWbemServices& operator=(IUnknownPtr& _p);
	CWbemServices& operator=(IWbemServices *_p);
	CWbemServices& operator=(const CWbemServices& _p);

    bool IsNull()  ;
    operator bool();

    HRESULT GetServices(IWbemServices ** ppServices);
	HRESULT SetBlanket(IUnknown *service,
                       DWORD _dwProxyCapabilities = EOAC_NONE);
	void SetPriv(LPCTSTR privName = SE_SYSTEM_ENVIRONMENT_NAME);
	DWORD EnablePriv(bool fEnable );
	void ClearPriv(void);

    // Login as guest...
    HRESULT ConnectServer(_bstr_t sNetworkResource);
    // Login as user...
    HRESULT ConnectServer(_bstr_t sNetworkResource,
							_bstr_t sUser,
							_bstr_t sPassword,
							long SecurityFlags = 0);

    HRESULT ConnectServer(_bstr_t sNetworkResource,
							LOGIN_CREDENTIALS *user,
							long lSecurityFlags = 0);

    CWbemServices OpenNamespace(_bstr_t sNetworkResource);
	void DisconnectServer(void);

	CWbemClassObject CreateInstance(_bstr_t _sClass, IWbemCallResultPtr& _cr);
	CWbemClassObject CreateInstance(_bstr_t _sClass);

	HRESULT DeleteInstance(_bstr_t _sClass);

    CWbemClassObject GetObject(_bstr_t _sName, IWbemCallResultPtr &_cr, long flags = 0);
    CWbemClassObject GetObject(_bstr_t _sName, long flags = 0);
	IWbemClassObject *FirstInstanceOf(bstr_t className);

    HRESULT PutInstance(CWbemClassObject&   _object, IWbemCallResultPtr& _cr,
						long _lFlags = WBEM_FLAG_CREATE_OR_UPDATE);
	HRESULT PutInstance(CWbemClassObject&   _object,
                        IWbemContext *pContext,
                        long _lFlags = WBEM_FLAG_CREATE_OR_UPDATE,
                        DWORD _dwProxyCapabilities = EOAC_NONE);

    HRESULT PutInstance(CWbemClassObject&   _object,
                        long _lFlags = WBEM_FLAG_CREATE_OR_UPDATE,
                        DWORD _dwProxyCapabilities = EOAC_NONE);

    HRESULT CreateInstanceEnum(_bstr_t Class, long lFlags, IEnumWbemClassObject **ppEnum);
    HRESULT CreateInstanceEnumAsync(_bstr_t Class, IWbemObjectSink * ppSink, long lFlags = 0);

    HRESULT CreateClassEnum(_bstr_t Class, long lFlags, IEnumWbemClassObject **ppEnum);
	
    HRESULT ExecQuery(_bstr_t QueryLanguage,_bstr_t Query, long lFlags, IEnumWbemClassObject **ppEnum);
    HRESULT ExecQuery(_bstr_t Query, long lFlags, IEnumWbemClassObject **ppEnum);
    HRESULT ExecQuery(_bstr_t Query, IEnumWbemClassObject **ppEnum) ;
    HRESULT ExecQueryAsync(_bstr_t Query, IWbemObjectSink *pSink, long lFlags = 0);

    HRESULT GetMethodSignatures(const _bstr_t& _sObjectName,
								const _bstr_t& _sMethodName,
								CWbemClassObject& _in,
								CWbemClassObject& _out);
    HRESULT ExecMethod(_bstr_t sPath,
						_bstr_t sMethod,
						CWbemClassObject& inParams,
						CWbemClassObject& outParams);

    HRESULT CancelAsyncCall(IWbemObjectSink * pSink);

    HRESULT SetContextValue(_bstr_t sName,_variant_t value);
    HRESULT GetContextValue(_bstr_t sName,_variant_t& value);
	HRESULT DeleteContextValue(_bstr_t sName);
    HRESULT DeleteAllContextValues();
	HRESULT SetContext(IWbemContext * pWbemContext);
    HRESULT GetContext(IWbemContext ** ppWbemContext);
	HRESULT CreateClassEnumAsync(_bstr_t Class,
								IWbemObjectSink *ppSink,
								long lFlags /*= 0*/);

};


#endif //__SdkWbemHelpers_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\util.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "util.h"
#include "shlwapi.h"

//----------------------------------------------------------------
HRESULT Extract(IDataObject *_DO, wchar_t* fmt, wchar_t* data)
{
    HGLOBAL     hMem = GlobalAlloc(GMEM_SHARE,1024);
    wchar_t	*pRet = NULL;
	HRESULT hr = 0;

    if(hMem != NULL)
    {
		memset(hMem, 0, 1024);
        STGMEDIUM stgmedium = { TYMED_HGLOBAL, (HBITMAP) hMem};

		CLIPFORMAT regFmt = (CLIPFORMAT)RegisterClipboardFormat(fmt);

        FORMATETC formatetc = { regFmt,
								NULL,
								DVASPECT_CONTENT,
								-1,
								TYMED_HGLOBAL };

        if((hr = _DO->GetDataHere(&formatetc, &stgmedium)) == S_OK )
        {
            wcscpy(data, (wchar_t*)hMem);
        }

		GlobalFree(hMem);
    }

    return hr;
}

HRESULT Extract(IDataObject *_DO, wchar_t* fmt, bstr_t &data)
{
	wchar_t temp[1024];
	memset(temp, 0, 1024 * sizeof(wchar_t));

	HRESULT hr = Extract(_DO, fmt, temp);
	data = temp;
	return hr;
}
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: Int64ToString
//
// DESCRIPTION:
//    Converts the numeric value of a _int64 to a text string.
//    The string may optionally be formatted to include decimal places
//    and commas according to current user locale settings.
//
// ARGUMENTS:
//    n
//       The 64-bit integer to format.
//
//    szOutStr
//       Address of the destination buffer.
//
//    nSize
//       Number of characters in the destination buffer.
//
//    bFormat
//       TRUE  = Format per locale settings.
//       FALSE = Leave number unformatted.
//
//    pFmt
//       Address of a number format structure of type NUMBERFMT.
//       If NULL, the function automatically provides this information
//       based on the user's default locale settings.
//
//    dwNumFmtFlags
//       Encoded flag word indicating which members of *pFmt to use in
//       formatting the number.  If a bit is clear, the user's default
//       locale setting is used for the corresponding format value.  These
//       constants can be OR'd together.
//
//          NUMFMT_IDIGITS
//          NUMFMT_ILZERO
//          NUMFMT_SGROUPING
//          NUMFMT_SDECIMAL
//          NUMFMT_STHOUSAND
//          NUMFMT_INEGNUMBER
//
///////////////////////////////////////////////////////////////////////////////
INT WINAPI Int64ToString(_int64 n, LPTSTR szOutStr, UINT nSize, BOOL bFormat,
                                   NUMBERFMT *pFmt, DWORD dwNumFmtFlags)
{
   INT nResultSize;
   TCHAR szBuffer[_MAX_PATH + 1] = {0};
   NUMBERFMT NumFmt;
   TCHAR szDecimalSep[5] = {0};
   TCHAR szThousandSep[5] = {0};

   //
   // Use only those fields in caller-provided NUMBERFMT structure
   // that correspond to bits set in dwNumFmtFlags.  If a bit is clear,
   // get format value from locale info.
   //
   if (bFormat)
   {
      TCHAR szInfo[20] = {0};

      if (NULL == pFmt)
         dwNumFmtFlags = 0;  // Get all format data from locale info.

      if (dwNumFmtFlags & NUMFMT_IDIGITS)
      {
         NumFmt.NumDigits = pFmt->NumDigits;
      }
      else
      {
         GetLocaleInfo(LOCALE_USER_DEFAULT,
						LOCALE_IDIGITS,
						szInfo,
						ARRAYSIZE(szInfo));
		_stscanf(szInfo, _T("%ld"), &(NumFmt.NumDigits));

//        NumFmt.NumDigits = StrToLong(szInfo);
      }

      if (dwNumFmtFlags & NUMFMT_ILZERO)
      {
         NumFmt.LeadingZero = pFmt->LeadingZero;
      }
      else
      {
         GetLocaleInfo(LOCALE_USER_DEFAULT,
						LOCALE_ILZERO,
						szInfo,
						ARRAYSIZE(szInfo));
		_stscanf(szInfo, _T("%ld"), &(NumFmt.LeadingZero));

//         NumFmt.LeadingZero = StrToLong(szInfo);
      }

      if (dwNumFmtFlags & NUMFMT_SGROUPING)
      {
         NumFmt.Grouping = pFmt->Grouping;
      }
      else
      {
         GetLocaleInfo(LOCALE_USER_DEFAULT,
						LOCALE_SGROUPING,
						szInfo,
						ARRAYSIZE(szInfo));
		_stscanf(szInfo, _T("%ld"), &(NumFmt.Grouping));

//         NumFmt.Grouping = StrToLong(szInfo);
      }

      if (dwNumFmtFlags & NUMFMT_SDECIMAL)
      {
         NumFmt.lpDecimalSep = pFmt->lpDecimalSep;
      }
      else
      {
         GetLocaleInfo(LOCALE_USER_DEFAULT,
						LOCALE_SDECIMAL,
						szDecimalSep,
						ARRAYSIZE(szDecimalSep));
         NumFmt.lpDecimalSep = szDecimalSep;
      }

      if (dwNumFmtFlags & NUMFMT_STHOUSAND)
      {
         NumFmt.lpThousandSep = pFmt->lpThousandSep;
      }
      else
      {
         GetLocaleInfo(LOCALE_USER_DEFAULT,
						LOCALE_STHOUSAND,
						szThousandSep,
						ARRAYSIZE(szThousandSep));
         NumFmt.lpThousandSep = szThousandSep;
      }

      if (dwNumFmtFlags & NUMFMT_INEGNUMBER)
      {
         NumFmt.NegativeOrder = pFmt->NegativeOrder;
      }
      else
      {
         GetLocaleInfo(LOCALE_USER_DEFAULT,
						LOCALE_INEGNUMBER,
						szInfo,
						ARRAYSIZE(szInfo));


		_stscanf(szInfo, _T("%ld"), &(NumFmt.NegativeOrder));
//         NumFmt.NegativeOrder  = StrToLong(szInfo);
      }

      pFmt = &NumFmt;
   }

   Int64ToStr( n, szBuffer);

   //
   //  Format the number string for the locale if the caller wants a
   //  formatted number string.
   //
   if (bFormat)
   {
      if ( 0 != ( nResultSize = GetNumberFormat( LOCALE_USER_DEFAULT,  // User's locale
                                         0,                            // No flags
                                         szBuffer,                     // Unformatted number string
                                         pFmt,                         // Number format info
                                         szOutStr,                     // Output buffer
                                         nSize )) )                    // Chars in output buffer.
      {
          //  Remove nul terminator char from return size count.
          --nResultSize;
      }
	  else
	  {
		//
		//  GetNumberFormat call failed, so just return the number string
		//  unformatted.
		//
		DWORD err = GetLastError();
		lstrcpyn(szOutStr, szBuffer, nSize);
		nResultSize = lstrlen(szOutStr);
	  }
   }
   else
   {
	   // a-khint; give it back raw.
		lstrcpyn(szOutStr, szBuffer, nSize);
		nResultSize = lstrlen(szOutStr);
   }
   return nResultSize;
}
//---------------------------------------------------------------
void Int64ToStr( _int64 n, LPTSTR lpBuffer)
{
    TCHAR   szTemp[MAX_INT64_SIZE] = {0};
    _int64  iChr;

    iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(n % 10);
        n = n / 10;
    } while (n != 0);

    do {
        iChr--;
        *lpBuffer++ = szTemp[iChr];
    } while (iChr != 0);

    *lpBuffer++ = '\0';
}

//---------------------------------------------------------------
// takes a DWORD add commas etc to it and puts the result in the buffer
LPTSTR WINAPI AddCommas64(_int64 n, LPTSTR pszResult)
{
    TCHAR  szTemp[MAX_COMMA_NUMBER_SIZE] = {0};
    TCHAR  szSep[5] = {0};
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
	_stscanf(szSep, _T("%d"), &(nfmt.Grouping));
//    nfmt.Grouping = StrToInt(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    Int64ToStr(n, szTemp);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, ARRAYSIZE(szTemp)) == 0)
        lstrcpy(pszResult, szTemp);

    return pszResult;
}

//----------------------------------------------------------------------
// takes a DWORD add commas etc to it and puts the result in the buffer
LPTSTR WINAPI AddCommas(DWORD dw, LPTSTR pszResult)
{
    return AddCommas64( dw, pszResult );
}

//----------------------------------------------------------------------
long StrToLong(LPTSTR x)
{
	long val;
	_stscanf(x, _T("%ld"), &val);

	return val;
}

//----------------------------------------------------------------------
/*
int StrToInt(LPTSTR x)
{
	int val;
	_stscanf(x, _T("%d"), &val);

	return val;
}


//----------------------------------------------------------------------
#define LEN_MID_ELLIPSES        4
#define LEN_END_ELLIPSES        3
#define MIN_CCHMAX              LEN_MID_ELLIPSES + LEN_END_ELLIPSES

// PathCompactPathEx
// Output:
//          "."
//          ".."
//          "..."
//          "...\"
//          "...\."
//          "...\.."
//          "...\..."
//          "...\Truncated filename..."
//          "...\whole filename"
//          "Truncated path\...\whole filename"
//          "Whole path\whole filename"
// The '/' might be used instead of a '\' if the original string used it
// If there is no path, but only a file name that does not fit, the output is:
//          "truncated filename..."

BOOL MyPathCompactPathEx(LPTSTR  pszOut,
						LPCTSTR pszSrc,
						UINT    cchMax,
						DWORD   dwFlags)
{
    if(pszSrc)
    {
        TCHAR * pszFileName, *pszWalk;
        UINT uiFNLen = 0;
        int cchToCopy = 0, n;
        TCHAR chSlash = TEXT('0');

        ZeroMemory(pszOut, cchMax * sizeof(TCHAR));

        if((UINT)lstrlen(pszSrc)+1 < cchMax)
        {
            lstrcpy(pszOut, pszSrc);
            ATLASSERT(pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Determine what we use as a slash - a / or a \ (default \)
        pszWalk = (TCHAR*)pszSrc;
        chSlash = TEXT('\\');
        // Scan the entire string as we want the path separator closest to the end
        // eg. "file://\\Themesrv\desktop\desktop.htm"
        while(*pszWalk)
        {
            if((*pszWalk == TEXT('/')) || (*pszWalk == TEXT('\\')))
                chSlash = *pszWalk;

            pszWalk = FAST_CharNext(pszWalk);
        }

        pszFileName = PathFindFileName(pszSrc);
        uiFNLen = lstrlen(pszFileName);

        // if the whole string is a file name
        if(pszFileName == pszSrc && cchMax > LEN_END_ELLIPSES)
        {
            lstrcpyn(pszOut, pszSrc, cchMax - LEN_END_ELLIPSES);
#ifndef UNICODE
            if(IsTrailByte(pszSrc, pszSrc+cchMax-LEN_END_ELLIPSES))
                *(pszOut+cchMax-LEN_END_ELLIPSES-1) = TEXT('\0');
#endif
            lstrcat(pszOut, TEXT("..."));
            ASSERT(pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Handle all the cases where we just use ellipses ie '.' to '.../...'
        if((cchMax < MIN_CCHMAX))
        {
            for(n = 0; n < (int)cchMax-1; n++)
            {
                if((n+1) == LEN_MID_ELLIPSES)
                    pszOut[n] = chSlash;
                else
                    pszOut[n] = TEXT('.');
            }
            ASSERT(0==cchMax || pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Ok, how much of the path can we copy ? Buffer - (Lenght of MID_ELLIPSES + Len_Filename)
        cchToCopy = cchMax - (LEN_MID_ELLIPSES + uiFNLen);
        if (cchToCopy < 0)
            cchToCopy = 0;
#ifndef UNICODE
        if (cchToCopy > 0 && IsTrailByte(pszSrc, pszSrc+cchToCopy))
            cchToCopy--;
#endif

        lstrcpyn(pszOut, pszSrc, cchToCopy);

        // Now throw in the ".../" or "...\"
        lstrcat(pszOut, TEXT(".../"));
        pszOut[lstrlen(pszOut) - 1] = chSlash;

        //Finally the filename and ellipses if necessary
        if(cchMax > (LEN_MID_ELLIPSES + uiFNLen))
        {
            lstrcat(pszOut, pszFileName);
        }
        else
        {
            cchToCopy = cchMax - LEN_MID_ELLIPSES - LEN_END_ELLIPSES;
#ifndef UNICODE
            if(cchToCopy >0 && IsTrailByte(pszFileName, pszFileName+cchToCopy))
                cchToCopy--;
#endif
            lstrcpyn(pszOut + LEN_MID_ELLIPSES, pszFileName, cchToCopy);
            lstrcat(pszOut, TEXT("..."));
        }
        ASSERT(pszOut[cchMax-1] == TEXT('\0'));
        return TRUE;
    }
    return FALSE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\util.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __UTIL__
#define __UTIL__
#pragma once

#include "comdef.h"

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SIZEOF(x)    sizeof(x)

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)

// Sizes of various string-ized numbers
#define MAX_INT64_SIZE  30              // 2^64 is less than 30 chars long
#define MAX_COMMA_NUMBER_SIZE   (MAX_INT64_SIZE + 10)
#define MAX_COMMA_AS_K_SIZE     (MAX_COMMA_NUMBER_SIZE + 10)

HRESULT Extract(IDataObject *_DO, wchar_t* fmt, wchar_t* data);
HRESULT Extract(IDataObject *_DO, wchar_t* fmt, bstr_t &data);

INT WINAPI Int64ToString(_int64 n, LPTSTR szOutStr, UINT nSize, BOOL bFormat,
                                   NUMBERFMT *pFmt, DWORD dwNumFmtFlags);
void Int64ToStr( _int64 n, LPTSTR lpBuffer);

LPTSTR WINAPI AddCommas64(_int64 n, LPTSTR pszResult);
LPTSTR WINAPI AddCommas(DWORD dw, LPTSTR pszResult);

long StrToLong(LPTSTR x);
//int StrToInt(LPTSTR x);

//BOOL MyPathCompactPathEx(LPTSTR  pszOut,
//						LPCTSTR pszSrc,
//						UINT    cchMax,
//						DWORD   dwFlags);

#define HINST_THISDLL   _Module.GetModuleInstance()

#define NUMFMT_IDIGITS 1
#define NUMFMT_ILZERO 2
#define NUMFMT_SGROUPING 4
#define NUMFMT_SDECIMAL 8
#define NUMFMT_STHOUSAND 16
#define NUMFMT_INEGNUMBER 32
#define NUMFMT_ALL 0xFFFF

#define MAXCOMPUTER_NAME 262 // This is the current size allowed in snapin UI.

#endif __UTIL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\wbempagehelper.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __WBEMPAGEHELPER__
#define __WBEMPAGEHELPER__

#pragma once

#include "..\common\SshWbemHelpers.h"
#include "..\common\ServiceThread.h"

#define SCB_FROMFILE     (0x1)
#define SCB_REPLACEONLY  (0x2)
#define CLOSE_SNAPIN	0xfdfd

#define WBEM_ENABLE             ( 0x0001 )   
#define WBEM_METHOD_EXECUTE     ( 0x0002 )   
#define WBEM_FULL_WRITE_REP     ( 0x001c )   
#define WBEM_PARTIAL_WRITE_REP  ( 0x0008 )   
#define WBEM_WRITE_PROVIDER     ( 0x0010 )   

class WBEMPageHelper
{
public:
	IWbemServices *m_service;
	CWbemServices m_WbemServices;
	bool m_okPressed;
	HWND m_hDlg;
	bool m_userCancelled; // the connectServer() thread.
	HWND m_AVIbox;

	WBEMPageHelper(CWbemServices &service);
	WBEMPageHelper(WbemServiceThread *serviceThread);

	virtual ~WBEMPageHelper();

	CWbemClassObject ExchangeInstance(IWbemClassObject **ppbadInst);

	virtual bool GetOnOkPressed(void) {return m_okPressed;};

	// get the first instance of the named class.
	IWbemClassObject *FirstInstanceOf(bstr_t className);

	static LPTSTR CloneString( LPTSTR pszSrc );

	BOOL SetClearBitmap(HWND control, 
						LPCTSTR resource, 
						UINT fl);

	void HourGlass( bool bOn );

	int MsgBoxParam(HWND hWnd, 
					DWORD wText, 
					DWORD wCaption, 
					DWORD wType,
					LPTSTR var1 = NULL,
					LPTSTR var2 = NULL);

	DWORD SetLBWidthEx(HWND hwndLB, 
						LPTSTR szBuffer, 
						DWORD cxCurWidth, 
						DWORD cxExtra);

	void SetDefButton(HWND hwndDlg, 
						int idButton);

	void SetDlgItemMB(HWND hDlg, 
						int idControl, 
						ULONG dwMBValue );

	void SetWbemService(IWbemServices *pServices);

#define NO_UI 0  // for uCaption
	bool ServiceIsReady(UINT uCaption, 
						UINT uWaitMsg,
						UINT uBadMsg);

	HRESULT Reboot(UINT flags = EWX_REBOOT,
				   long *retval = NULL);

	
	HRESULT RemoteRegWriteable(const _bstr_t regPath,
								BOOL& writable);

	bool HasPerm(DWORD mask);
	bool HasPriv(LPCTSTR privName);

	static BOOL g_fRebootRequired;
	WbemServiceThread *m_serviceThread;

private:
	// these support efficiency in RemoteRegWriteable().
	CWbemClassObject m_checkAccessIn;
	CWbemClassObject m_checkAccessOut;
	CWbemServices m_defaultNS;
};

#endif __WBEMPAGEHELPER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\unsecwrap.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
class CUnsecWrap
{
protected:
    IWbemObjectSink* m_pSink;
    IWbemObjectSink* m_pWrapper;
    
    static IUnsecuredApartment* mstatic_pApartment;

protected:
    static void Init()
    {
        if(mstatic_pApartment == NULL)
        {
            HRESULT hres = CoCreateInstance(CLSID_UnsecuredApartment, NULL, 
                            CLSCTX_ALL,
                            IID_IUnsecuredApartment, 
                            (void**)&mstatic_pApartment);
        }
    }
public:
    CUnsecWrap(IWbemObjectSink* pSink) : 
			m_pSink(pSink), 
			m_pWrapper(NULL)
    {
        m_pSink->AddRef();
        Init();
    }
    ~CUnsecWrap()
    {
        m_pSink->Release();
        if(m_pWrapper)
            m_pWrapper->Release();
    }

    operator IWbemObjectSink*()
    {
        if(m_pWrapper)
            return m_pWrapper;
        
        IUnknown* pUnk;
        mstatic_pApartment->CreateObjectStub(m_pSink, &pUnk);
        pUnk->QueryInterface(IID_IWbemObjectSink, (void**)&m_pWrapper);
        pUnk->Release();
        return m_pWrapper;
    }
};
        
IUnsecuredApartment* CUnsecWrap::mstatic_pApartment = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\ansi\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\unicode\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\t_dataextractor.h ===
//-----------------------------------------------------------------------------
// NMGR_CClientDataExtractor.h
//
//
//  This header containes the template implementation of T_DataExtractor.
//
//  The name of this header will be changing!!!!!!
//
//
//
//
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//-----------------------------------------------------------------------------

#if !defined(__CClientDataExtractor_h)
#define      __CClientDataExtractor_h

#include "SimpleArray.h"

//-----------------------------------------------------------------------------
// template T_DataExtractor
//
//
//  This template class allows you to act as if a pointer to an IDataObject 
//  is the clipboard format that you are trying to extract from the IDataObject.
//  What????
//
//  Ok.  Given that any IDataObject exposes one of more CCF_'s (Clip board formats)
//  you want to ask the IDataObject for a specific CCF_.  Using this template
//  allows you to "auto-magically" handle both the asking of the question
//  "Does this data object support this CCF_?" and the subsequent extraction of 
//  particular clip board format.
//
//  Syntax:
//  
//      T_DataExtractor<__type,CCF_> data;
//  
//  __type  is the actual type of data you hope to extract from the IDataObject
//  CCF_    is the registered clip board format for the given type that you want
//          to extract.
//
//   
//    Examples:  
//      int       :  T_DataExtractor<int,     CCF_INT>          iMyInt;
//      CClass *  :  T_DataExtractor<CClass*, CCF_CCLASSPTR>    pMyClass;
//
//                             

template<typename TNData,const wchar_t* pClipFormat>
class T_DataExtractor
{
    private:
        typedef CSimpleArray<HGLOBAL> HGlobVector;

        IDataObject *       m_pDataObject;      // Wrapped Data Object
        HGlobVector         m_MemoryHandles;    // Memory Allocated

        TNData *            m_pData;            // "Cached" Value

        static UINT         m_nClipFormat;      // Registered Clipboard Format

    protected:

        //-------------------------------------
        // Extract  : Does the data extraction.

        TNData* Extract()
        {
            HGLOBAL     hMem = GlobalAlloc(GMEM_SHARE,sizeof(TNData));
            TNData *    pRet = NULL;

            if(hMem != NULL)
            {
                m_MemoryHandles.Add(hMem);

                STGMEDIUM stgmedium = { TYMED_HGLOBAL, (HBITMAP) hMem};
                FORMATETC formatetc = { m_nClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

                if(m_pDataObject->GetDataHere(&formatetc, &stgmedium) == S_OK )
                {
                    pRet = reinterpret_cast<TNData*>(hMem);
                }
            }

            return pRet;
        }


    public:


        //---------------------------------------------------------
        // TDataExtractor : C-Tor
        //
        //  Create an extractor object from an IDataObject pointer
        //
        //  After the object has been constructed, you must test
        //  to see if the IDataObject pointer exposed the 
        //  clipboard format that you were looking for.  If a call
        //  to IsValidData returns true you know two things.
        //
        //  1)  The data object exposed the clipboard format 
        //      you asked for.
        //
        //  2.) This class was able to extract a copy of the data 
        //      and now holds a local copy of the data.
        //
        //  _pObject        : Pointer to the IDataObject we "manage"
        //  bAutoExtract    : Automatically attempt to extract 
        //                    the data from the IDataObject pointer
        //

        T_DataExtractor(IDataObject * _pObject,bool bAutoExtract = true)
        {
            m_pDataObject   = _pObject;
            m_pData         = NULL;


            if(m_pDataObject)
            {
                if(bAutoExtract)
                {
                    m_pData = Extract();
                }

                m_pDataObject->AddRef();
            }
        }

        //-------------------------------------------------------
        // IsValidData:     True if the clipboard format
        //                  was exposed by the IDataObject and
        //                  was copied into our local version.
        //
        //                  This is only useful if you construct the 
        //                  class with bAutoExtract = true!!!!!!
        //  
        //  Note:           No guarentee is made for the quality
        //                  of the data.  This just indicates
        //                  that the data was extracted.

        bool IsValidData()   
        { 
            return m_pData != NULL; 
        }

        
        //-------------------------------------------------------
        // ~T_DataExtractor : D-Tor
        //
        //  Cleans up any allocated memory and releases our 
        //  AddRef on the IDataObject.
        //

        ~T_DataExtractor()
        {
            HGLOBAL walk;
  
			for(int i = 0; i > m_MemoryHandles.GetSize(); i++)
            {
				walk = m_MemoryHandles[i];
                GlobalFree(walk);
            }

            m_pDataObject->Release();
        }

        
        //-------------------------------------------------------
        // operator TNData
        //
        //  This conversion operator should allow you to act apon 
        //  this class as if it was the underlying data type that 
        //  was extracted from the IDataObject
        //
        //  i.e. Pretend CCF_INT exposes an integer:
        //
        //  void SomeIntFunction(int iMyData) {}
        //
        //  T_DataExtractor<int,CC_INT> iMyInt;
        //
        //  SomeIntFunction(iMyInt);
        //  
        //
        
        operator TNData()
        { 
            return *m_pData;  
        }

        //-------------------------------------------------------
        // TNData operator->
        //
        //  If a clpboard format is exposed as a pointer, this
        //  will allow you to use the T_DataExtractor class as 
        //  if it were the actual underlying pointer type.
        //  
        //  i.e. 
        // 
        //  class CMyClass;
        //
        //  T_DataExtractor<CMyClass *,CCF_MYCLASS> pMyClass;
        //
        //  pMyClass->SomeMemberFunction();
        //
        //

        TNData operator->()
        { 
            return *m_pData;  
        }


        //-------------------------------------------------------
        // GetDataPointer
        //
        //  In the case that you need to extract a pointer to
        //  the acutal data item.  (Say extracting the clipboard format
        //  increments a value or something.)  This will alow you to 
        //  Get a pointer to the data.
        //
        //  This is also very useful if the data item is quite large.
        //  It would be very expensive to be continuely accessing 
        //  the data via the above operators.
        //
        //  Each time you call this member a NEW data item will be
        //  extracted.  If your data item is large, make sure that 
        //  you construct the class without automatically extracting 
        //  the clipboard format.
        //


        TNData * GetDataPointer()   
        { 
            return Extract(); 
        }
};

template<typename TNData,const wchar_t* pClipFormat>
UINT T_DataExtractor<TNData,pClipFormat>::m_nClipFormat = RegisterClipboardFormatW(pClipFormat);




template<const wchar_t* pClipFormat>
class T_bstr_tExtractor
{
    private:
        IDataObject *   m_pDataObject;
        _bstr_t         m_sString;
        bool            m_bIsValidData;

        static UINT     m_nClipFormat;      // Registered Clipboard Format

    protected:

        void GetString()
        {
            STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
            FORMATETC formatetc = { m_nClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

            if(m_pDataObject->GetData(&formatetc, &stgmedium) == S_OK )
            {
                m_sString = reinterpret_cast<wchar_t*>(stgmedium.hGlobal);

                m_bIsValidData = true;

                GlobalFree(stgmedium.hGlobal);
            }
        }

    public:

        T_bstr_tExtractor(IDataObject * _pDO)
        {
            m_bIsValidData = false;

            m_pDataObject = _pDO;
            m_pDataObject->AddRef();

            GetString();

            m_pDataObject->Release();
        }

        ~T_bstr_tExtractor()
        {
        }

        operator _bstr_t&()
        {
            return m_sString;
        }

        bool IsValidData() { return m_bIsValidData; }

};

template<const wchar_t* pClipFormat>
UINT T_bstr_tExtractor<pClipFormat>::m_nClipFormat = RegisterClipboardFormatW(pClipFormat);




#endif // __CCientDataExtractor_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\wbempagehelper.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\MMFUtil\MsgDlg.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "util.h"
#include "..\Common\ServiceThread.h"
#include "WBEMPageHelper.h"
#include <stdarg.h>


BOOL WBEMPageHelper::g_fRebootRequired = FALSE;

//------------------------------------------------
WBEMPageHelper::WBEMPageHelper(CWbemServices &service)

{
	m_service = 0;
	m_WbemServices = service;
	m_WbemServices.GetServices(&m_service);
	m_WbemServices.SetBlanket(m_service);

	m_okPressed = false;
	m_userCancelled = false;
	m_hDlg = NULL;
	m_AVIbox = 0;
}

//------------------------------------------------
WBEMPageHelper::WBEMPageHelper(WbemServiceThread *serviceThread)

{    
	m_serviceThread = serviceThread;
	if (m_serviceThread)
    	m_serviceThread->AddRef();
	m_service = 0;
	if(m_serviceThread->m_status == WbemServiceThread::ready)
	{
		m_WbemServices = m_serviceThread->m_WbemServices;
		m_WbemServices.GetServices(&m_service);
		m_WbemServices.SetBlanket(m_service);
	}

	m_okPressed = false;
	m_userCancelled = false;
	m_hDlg = NULL;
	m_AVIbox = 0;
}

//------------------------------------------------
WBEMPageHelper::~WBEMPageHelper()
{
	// in case ServiceThread still has a ptr to this
	//   handle. It knows not to use NULL HWNDs.
	m_AVIbox = 0;
	m_hDlg = NULL;
	if(m_service)
	{
		m_service->Release();
		m_service = 0;
	}
	m_WbemServices.DisconnectServer();

	if (m_serviceThread)
    	m_serviceThread->Release();
}

//------------------------------------------------
CWbemClassObject WBEMPageHelper::ExchangeInstance(IWbemClassObject **ppbadInst)
{
	CWbemClassObject inst;
	_variant_t v1;

	if(SUCCEEDED((*ppbadInst)->Get(bstr_t("__PATH"), 0, &v1, NULL, NULL)))
	{
		inst = m_WbemServices.GetObject((_bstr_t) v1);
		(*ppbadInst)->Release();
		*ppbadInst = NULL;
	}
	return inst;
}
//------------------------------------------------
// get the first instance of the named class.
IWbemClassObject *WBEMPageHelper::FirstInstanceOf(bstr_t className)
{
	IWbemClassObject *pInst = NULL;
	ULONG uReturned;
	IEnumWbemClassObject *Enum = NULL;

	// get the class.
	if(SUCCEEDED(m_WbemServices.CreateInstanceEnum(className,
													WBEM_FLAG_SHALLOW,
													&Enum)))
	{
		// get the first and only instance.
		Enum->Next(-1, 1, &pInst, &uReturned);
		Enum->Release();
	}
	return pInst;
}

//---------------------------------------------------
LPTSTR WBEMPageHelper::CloneString( LPTSTR pszSrc )
{
    LPTSTR pszDst = NULL;

    if (pszSrc != NULL)
	{
        pszDst = new TCHAR[(lstrlen(pszSrc) + 1)];
        if (pszDst)
		{
            lstrcpy( pszDst, pszSrc );
        }
    }

    return pszDst;
}
//*************************************************************
//
//  SetClearBitmap()
//
//  Purpose:    Sets or clears an image in a static control.
//
//  Parameters: control  -   handle of static control
//              resource -   resource / filename of bitmap
//              fl       -   SCB_ flags:
//                SCB_FROMFILE      'resource' specifies a filename instead of a resource
//                SCB_REPLACEONLY   only put the new image up if there was an old one
//
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Ported
//
//*************************************************************

BOOL WBEMPageHelper::SetClearBitmap( HWND control,
									 LPCTSTR resource,
									 UINT fl )
{
    HBITMAP hbm = (HBITMAP)SendMessage(control, STM_GETIMAGE, IMAGE_BITMAP, 0);

    if( hbm )
    {
        DeleteObject( hbm );
    }
    else if( fl & SCB_REPLACEONLY )
    {
        return FALSE;
    }

    if( resource )
    {
        SendMessage(control, STM_SETIMAGE, IMAGE_BITMAP,
					(LPARAM)LoadImage(	HINST_THISDLL,
										resource,
										IMAGE_BITMAP,
										0, 0,
										LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS |
										( ( fl & SCB_FROMFILE )? LR_LOADFROMFILE : 0 ) )
					);
    }

    return
        ((HBITMAP)SendMessage(control, STM_GETIMAGE, IMAGE_BITMAP, 0) != NULL);
}

//------------------------------------------------------------
int WBEMPageHelper::MsgBoxParam(HWND hWnd,
								DWORD wText,
								DWORD wCaption,
								DWORD wType,
								LPTSTR var1,
								LPTSTR var2)
{
    TCHAR   szText[ 4 * MAX_PATH ] = {0}, szCaption[ 2 * MAX_PATH ] = {0};
    int     ival;

    if( !LoadString( HINST_THISDLL, wText, szCaption, ARRAYSIZE( szCaption ) ) )
	{
        return 0;
	}
	if(var2)
		_snwprintf(szText, 4 * MAX_PATH, szCaption, var1, var2);
	else if(var1)
		_snwprintf(szText, 4 * MAX_PATH, szCaption, var1);
	else
		_snwprintf(szText, 4 * MAX_PATH, szCaption);

    if( !LoadString( HINST_THISDLL, wCaption, szCaption, ARRAYSIZE( szCaption ) ) )
	{
        return 0;
	}

    ival = MessageBox( hWnd, szText, szCaption, wType);

    return ival;
}

//------------------------------------------------------------
void WBEMPageHelper::HourGlass( bool bOn )
{
    if( !GetSystemMetrics( SM_MOUSEPRESENT ) )
        ShowCursor( bOn );

    SetCursor( LoadCursor( NULL, bOn ? IDC_WAIT : IDC_ARROW ) );
}

////////////////////////////////////////////////////////////////////////////
//  SetLBWidthEx
//
//  Set the width of the listbox, in pixels, acording to the size of the
//  string passed in.
//
//  Note: this function is also used by the Virtual Memory dialog
//
//  History:
//  11-Jan-1996 JonPa   Created from SetGenLBWidth
////////////////////////////////////////////////////////////////////////////

DWORD WBEMPageHelper::SetLBWidthEx( HWND hwndLB,
									LPTSTR szBuffer,
									DWORD cxCurWidth,
									DWORD cxExtra)
{
    HDC     hDC;
    SIZE    Size;
    HFONT   hfont, hfontOld;

    // Get the new Win4.0 thin dialog font
    hfont = (HFONT)SendMessage(hwndLB, WM_GETFONT, 0, 0);

    hDC = GetDC(hwndLB);

    // if we got a font back, select it in this clean hDC
    if (hfont != NULL)
        hfontOld = (HFONT)SelectObject(hDC, hfont);


    // If cxExtra is 0, then give our selves a little breathing space.
    if (cxExtra == 0)
	{
        GetTextExtentPoint(hDC, TEXT("1234"), 4 , &Size);
        cxExtra = Size.cx;
    }

    // Set scroll width of listbox
    GetTextExtentPoint(hDC, szBuffer, lstrlen(szBuffer), &Size);

    Size.cx += cxExtra;

    // Get the name length and adjust the longest name
    if ((DWORD) Size.cx > cxCurWidth)
    {
        cxCurWidth = Size.cx;
        SendMessage (hwndLB, LB_SETHORIZONTALEXTENT, (DWORD)Size.cx, 0L);
    }

    // retstore the original font if we changed it.
    if (hfont != NULL)
        SelectObject(hDC, hfontOld);

    ReleaseDC(NULL, hDC);

    return cxCurWidth;

	return 1; // bs
}
//---------------------------------------------------
void WBEMPageHelper::SetDefButton(HWND hwndDlg,
								  int idButton)
{
    LRESULT lr;

    if(HIWORD(lr = SendMessage(hwndDlg, DM_GETDEFID, 0, 0)) == DC_HASDEFID)
    {
        HWND hwndOldDefButton = GetDlgItem(hwndDlg, LOWORD(lr));

        SendMessage (hwndOldDefButton,
                     BM_SETSTYLE,
                     MAKEWPARAM(BS_PUSHBUTTON, 0),
                     MAKELPARAM(TRUE, 0));
    }

    SendMessage( hwndDlg, DM_SETDEFID, idButton, 0L );
    SendMessage( GetDlgItem(hwndDlg, idButton),
                 BM_SETSTYLE,
                 MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
                 MAKELPARAM( TRUE, 0 ));
}

//-------------------------------------------------------------------
void WBEMPageHelper::SetDlgItemMB( HWND hDlg,
								  int idControl,
								  ULONG dwMBValue )
{
    TCHAR szBuf[20] = {0};
    wsprintf(szBuf, _T("%u MB"), dwMBValue);
    SetDlgItemText(hDlg, idControl, szBuf);
}

//--------------------------------------------------------------
void WBEMPageHelper::SetWbemService(IWbemServices *pServices)
{
   	m_serviceThread->m_realServices = pServices;
   	m_serviceThread->m_WbemServices = pServices;
	m_WbemServices = pServices;
}

//--------------------------------------------------------------
bool WBEMPageHelper::ServiceIsReady(UINT uCaption /* = 0*/,
									UINT uWaitMsg,
									UINT uBadMsg)
{
	switch(m_serviceThread->m_status)
	{
	// its already there.
	case WbemServiceThread::ready:
		{
		ATLTRACE(L"start marshal\n");
		for(int i = 0; (i < 5); i++)
		{
			// if "Object is not connected to server"
			if(m_serviceThread->m_hr == 0x800401fd)
			{
				// lost my connection,
				ATLTRACE(_T("Reconnecting to cimom!!!!!!!!!!!\n"));
				m_serviceThread->ReConnect();
				ATLTRACE(_T("new service status: %d\n"), m_serviceThread->m_status);
				continue;
			}
			else if(FAILED(m_serviceThread->m_hr))
			{
				// some other problem.
				m_serviceThread->m_WbemServices = (IWbemServices *)NULL;
				m_serviceThread->m_status = WbemServiceThread::error;
			}


			ATLTRACE(_T("marshalled ok\n"));
			break;

		} //endfor

		if(m_AVIbox)
		{
			PostMessage(m_AVIbox,
						WM_ASYNC_CIMOM_CONNECTED,
						0, 0);
			m_AVIbox = 0;
		}
		// it marshaled, must still be connected/useable.
		return true;
		}
		break;

	// its coming.
	case WbemServiceThread::notStarted:
	case WbemServiceThread::locating:
	case WbemServiceThread::connecting:
		{
			// let me know when its there.
			m_serviceThread->NotifyWhenDone(m_hDlg);

			// also kill the cancel box at that time.
			m_AVIbox = 0;
			m_serviceThread->NotifyWhenDone(m_AVIbox);

			if(uCaption != NO_UI)
			{
				TCHAR caption[100] = {0}, msg[256] = {0};

				::LoadString(HINST_THISDLL, uCaption,
								caption, 100);

				::LoadString(HINST_THISDLL, uWaitMsg,
								msg, 256);

                m_userCancelled = false;

				if(DisplayAVIBox(m_hDlg, caption, msg, &m_AVIbox) == IDCANCEL)
				{
					m_serviceThread->Cancel();
					m_userCancelled = true;
				}
			}
		}
		return false;
		break;

	case WbemServiceThread::error:			// cant connect.
	case WbemServiceThread::threadError:	// cant start that thread.
	default:
		if(::IsWindow(m_AVIbox))
		{
			PostMessage(m_AVIbox,
						WM_ASYNC_CIMOM_CONNECTED,
						0, 0);
			m_AVIbox = 0;
		}

		if(uCaption != NO_UI)
		{
			DisplayUserMessage(m_hDlg, HINST_THISDLL,
								uCaption, BASED_ON_SRC,
								ConnectServer,
								m_serviceThread->m_hr,
								MB_ICONSTOP);
		}
		return false;

	}; //endswitch
}

//----------------------------------------------------
HRESULT WBEMPageHelper::Reboot(UINT flags,
							   long *retval)
{
	HRESULT hr = WBEM_E_PROVIDER_NOT_FOUND;
	bstr_t path;
	CWbemClassObject paramCls;

	// need to class def to get the method signature.
	paramCls = m_WbemServices.GetObject("Win32_OperatingSystem");

	if(paramCls)
	{
		// get the method signature. dummy wont actually be used.
		CWbemClassObject dummy, inSig;

		hr = paramCls.GetMethod(L"Win32Shutdown",
									inSig, dummy);

		// if got a good signature....
		if((bool)inSig)
		{
			// find the OperatingSystem for the current service ptr.
			IWbemClassObject *pInst = NULL;
			pInst = FirstInstanceOf("Win32_OperatingSystem");
			if(pInst)
			{
				// wrap it for convenience.
				CWbemClassObject OS(pInst);
				path = OS.GetString(_T("__PATH"));

				// fill in the values.
				inSig.Put(_T("Flags"), (const long)flags);
				inSig.Put(_T("Reserved"), (long)0);

				// adjust privilege.
				m_WbemServices.SetPriv(SE_SHUTDOWN_NAME);

				// now call the method.
				hr = m_WbemServices.ExecMethod(path, L"Win32Shutdown",
												inSig, dummy);

				m_WbemServices.ClearPriv();

				// did the caller want the ReturnValue.
				if(SUCCEEDED(hr) && (bool)dummy && retval)
				{
					// NOTE: this guy return STATUS codes.
					*retval = dummy.GetLong(_T("ReturnValue"));
				}
			}
		}
	} //endif paramCls
	return hr;
}

//---------------------------------------------------------------
bool WBEMPageHelper::HasPriv(LPCTSTR privName)
{
	HANDLE hAccessToken = 0;
	bool retval = false;

	if (ImpersonateSelf(SecurityImpersonation))
	{
		if(OpenThreadToken(GetCurrentThread(),
							TOKEN_QUERY,
							FALSE, &hAccessToken))
		{
			DWORD dwLen;

			//Find out the size.
			GetTokenInformation(hAccessToken, TokenPrivileges,
									NULL, 0, &dwLen);

			BYTE* pBuffer = new BYTE[dwLen];
			if(pBuffer != NULL)
			{
				if(GetTokenInformation(hAccessToken, TokenPrivileges,
										pBuffer, dwLen, &dwLen))
				{
					TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
					LUID luidTgt;
					LookupPrivilegeValue(NULL, privName, &luidTgt);

					for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
					{
						if((pPrivs->Privileges[i].Luid.LowPart == luidTgt.LowPart) &&
							(pPrivs->Privileges[i].Luid.HighPart == luidTgt.HighPart))
						{
							retval = true;
							break;
						}
					}
				}
				delete [] pBuffer;
			}
			CloseHandle(hAccessToken);
		}
		else
		{
			DWORD err = GetLastError();
		}
	}
	else
	{
		 DWORD err = GetLastError();
	}

	return retval;
}

//---------------------------------------------------------------
bool WBEMPageHelper::HasPerm(DWORD mask)
{
	// call the method..
	CWbemClassObject _in;
	CWbemClassObject _out;
	bool retval = true;
	// NOTE: for backwards compability with wmi builds that didn't have this
	// method, assume 'true' unless a newer build says you cant do this.

	HRESULT hr = m_WbemServices.GetMethodSignatures("__SystemSecurity",
													"GetCallerAccessRights",
													_in, _out);

	if(SUCCEEDED(hr))
	{
		hr = m_WbemServices.ExecMethod("__SystemSecurity",
										"GetCallerAccessRights",
										_in, _out);

		if(SUCCEEDED(hr) && (bool)_out)
		{
			hr = HRESULT_FROM_NT(_out.GetLong("ReturnValue"));
			if(SUCCEEDED(hr))
			{
				DWORD grantedMask = 0;
				grantedMask = (DWORD)_out.GetLong("Rights");

				retval = (bool)((mask & (DWORD)grantedMask) != 0);
			}
		}
	}
	return retval;
}

//--------------------------------------------------------------
HRESULT WBEMPageHelper::RemoteRegWriteable(const _bstr_t regPath,
											BOOL& writable)
{
	HRESULT hr = E_FAIL;

	// if not even connected yet...
	if(!(bool)m_defaultNS)
	{
		bstr_t defaultName;

		// already whacked...
		if(wcsncmp((wchar_t *)m_serviceThread->m_machineName, _T("\\"), 1) == 0)
		{
			// use it.
			defaultName = m_serviceThread->m_machineName;
			defaultName += "\\root\\default";
		}
		else if(m_serviceThread->m_machineName.length() > 0) // not whacked but remote...
		{
			// whack it myself.
			defaultName = "\\\\";
			defaultName += m_serviceThread->m_machineName;
			defaultName += "\\root\\default";
		}
		else  // must be local
		{
			defaultName = "root\\default";
		}

		m_defaultNS.ConnectServer(defaultName);

	}

	// do we need the signatures?
	if((bool)m_defaultNS && !(bool)m_checkAccessIn)
	{
		hr = m_defaultNS.GetMethodSignatures("StdRegProv", "CheckAccess",
												m_checkAccessIn,
												m_checkAccessOut);
	}
	// got connection and signatures already?
	if((bool)m_defaultNS && (bool)m_checkAccessIn)
	{
		// fill in the parms.
		m_checkAccessIn.Put("sSubKeyName", regPath);
		m_checkAccessIn.Put("uRequired", KEY_WRITE);

		// call.
        hr = m_defaultNS.ExecMethod("StdRegProv", "CheckAccess",
										m_checkAccessIn,
										m_checkAccessOut);

		// ExecMethod() itself worked.
		if(SUCCEEDED(hr))
		{
			// did CheckAccess() work.
			HRESULT hr1 = HRESULT_FROM_NT(m_checkAccessOut.GetLong("ReturnValue"));
			if(FAILED(hr1))
			{
				hr = hr1;
			}
			else
			{
				writable = m_checkAccessOut.GetBool("bGranted");
			}
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\mmfutil\declspec.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//#define TRACKING 

// If we are building a the  DLL then define the 
// class as exporteded otherwise its inmported
// ============================================
#ifndef COREPOL_HEADERFILE_IS_INCLUDED
#define COREPOL_HEADERFILE_IS_INCLUDED
//#pragma message( "Including DECLSPEC.H..." )


 #ifdef BUILDING_DLL
//  #pragma message( "Building static library or DLL..." )
  #define POLARITY __declspec( dllexport )
 #else 
 // #pragma message( "Building Client..." )
  #define POLARITY __declspec( dllimport )
 #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\inc\snapins.inc\rpc.h ===
/*++

Copyright (c) 1991-1997 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/

#if !defined( RPC_NO_WINDOWS_H ) && !defined( MAC ) && !defined( _MAC )
#include <windows.h>
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#pragma message("rpc in snapins")

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------------------------
// platform specific defines
//-------------------------------------------------------------

//-------------------  MAC ---------------------------
#if defined( MAC ) || defined( _MAC )

#define __RPC_MAC__
// Set the packing level for RPC structures.

#include <pshpack2.h>

//-------------------  WIN32 ---------------------------
#else // win32 platforms

#define __RPC_WIN32__

#endif


#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

typedef void * I_RPC_HANDLE;
typedef long RPC_STATUS;

#ifndef _MAC
#define RPC_UNICODE_SUPPORTED
#endif //_MAC


#ifdef __RPC_MAC__
#	define __RPC_FAR
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#	define RPC_ENTRY
#elif   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#	define __RPC_FAR
#	define __RPC_API  __stdcall
#	define __RPC_USER __stdcall
#	define __RPC_STUB __stdcall
#	define  RPC_ENTRY __stdcall
#else
#	define __RPC_FAR
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#endif

// Some RPC platforms don't define DECLSPEC_IMPORT
#if !defined(DECLSPEC_IMPORT)
#if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif
#endif

#if !defined(_RPCRT4_)
#define RPCRTAPI DECLSPEC_IMPORT
#else
#define RPCRTAPI
#endif

#if !defined(_RPCNS4_)
#define RPCNSAPI DECLSPEC_IMPORT
#else
#define RPCNSAPI
#endif

#ifdef IN
#undef IN
#undef OUT
#undef OPTIONAL
#endif /* IN */

#ifdef __RPC_MAC__

#include <setjmp.h>

#define RPCXCWORD (sizeof(jmp_buf)/sizeof(int))

#pragma warning( disable: 4005 ) 
#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcerr.h>
#include <rpcmac.h>
#pragma warning( default :  4005 )

typedef void  (RPC_ENTRY *MACYIELDCALLBACK)(/*OSErr*/ short *) ; 
RPC_STATUS RPC_ENTRY
RpcMacSetYieldInfo(
	MACYIELDCALLBACK pfnCallback) ;

#if !defined(UNALIGNED)
#define UNALIGNED
#endif

#include <poppack.h>

#else // __RPC_MAC__

#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcnterr.h>
#include <excpt.h>
#include <winerror.h>

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcImpersonateClient (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelfEx (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelf (
    );

RPCRTAPI
long
RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    );

#endif // __RPC_MAC__

// Definitions which depend on windows.h
#if !defined( RPC_NO_WINDOWS_H ) && !defined( MAC ) && !defined( _MAC )

#include <rpcasync.h>

#endif // RPC_NO_WINDOWS_H

#ifdef __cplusplus
}
#endif

#endif // __RPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\wbemversion.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "stdpch.h"
#include "..\common\WbemVersion.h"
#include "..\common\Util.h"

//----------------------------------------------------------------------
LONG GetCimomFileName(LPTSTR filename, UINT size)
{
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, 
									&hkeyLocalMachine);
	if(lResult != ERROR_SUCCESS) 
	{
		return lResult;
	}

	HKEY hkeyHmomCwd;

	lResult = RegOpenKeyEx(hkeyLocalMachine,
							_T("SOFTWARE\\Microsoft\\WBEM\\CIMOM"),
							0,				
							KEY_READ | KEY_QUERY_VALUE,
							&hkeyHmomCwd);
	
	if(lResult != ERROR_SUCCESS) 
	{
		RegCloseKey(hkeyLocalMachine);
		return lResult;
	}

	TCHAR buf[MAX_PATH];
	unsigned long lcbValue = MAX_PATH * sizeof(TCHAR);
	unsigned long lType;

	lResult = RegQueryValueEx(hkeyHmomCwd,
								_T("Working Directory"), 
								NULL, &lType,
								buf, &lcbValue);
 
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	TCHAR cimomName[20] = {0};
	wcscpy(cimomName, _T("\\cimom.exe"));

	if((lResult == ERROR_SUCCESS) &&
	   ((lcbValue + sizeof(cimomName)) <= size))
	{
		wcsncpy(filename, buf, MAX_PATH - wcslen(cimomName) - 1);
		wcsncat(filename, cimomName, wcslen(cimomName));
	}
	return lResult;
}

//----------------------------------------------------------------------
bstr_t GetDoubleVersion(void)
{
	//    <myversion/cimomVer>
	TCHAR filename[MAX_PATH+1] = {0};

	GetModuleFileName(HINST_THISDLL, filename, MAX_PATH);
	bstr_t DoubleVersion = GetStringFileInfo(filename, _T("FileVersion"));

	// append cimom's version.
	DoubleVersion += _T("\\");
	DoubleVersion += GetCimomVersion();
	return DoubleVersion;
}

//----------------------------------------------------------------------
bstr_t GetMyVersion(void)
{
	TCHAR filename[MAX_PATH+1] = {0};
	GetModuleFileName(HINST_THISDLL, filename, MAX_PATH);
	return GetStringFileInfo(filename, _T("FileVersion"));
}

//----------------------------------------------------------------------
bstr_t GetMyCompany(void)
{
	TCHAR filename[MAX_PATH+1] = {0};
	GetModuleFileName(HINST_THISDLL, filename, MAX_PATH);
	return GetStringFileInfo(filename, _T("CompanyName"));
}

//----------------------------------------------------------------------
bstr_t GetCimomVersion(void)
{
	TCHAR filename[MAX_PATH+1] = {0};
	//if the wbem key, etc is there...
	if(GetCimomFileName(filename, sizeof(filename)) == ERROR_SUCCESS)
	{
		return GetStringFileInfo(filename, _T("FileVersion"));
	}
	return "No CIMOM";
}

//----------------------------------------------------------------------
bstr_t GetStringFileInfo(LPCTSTR filename, LPCTSTR key)
{
	_bstr_t sDesc("Unknown");

	DWORD infoSize = 0;
	UINT  valSize = 0;
	LPBYTE info = NULL;
	DWORD handle = 0;
	LPVOID verStr = NULL;
	DWORD *TransBlk = NULL;
	TCHAR blockStr[100] = {0};

	infoSize = GetFileVersionInfoSize((LPTSTR)filename, &handle);

	if(infoSize)
	{
		info = new BYTE[infoSize];

		if(GetFileVersionInfo((LPTSTR)filename, handle,
								infoSize, info))
		{
			// get the translation block.
			// NOTE: This assumes that the localizers REPLACE the english with
			// the 'other' language so there will only be ONE entry in the
			// translation table. If we ever do a single binary that supports
			// multiple languages, it's a whole nother ballgame folks.
			if(VerQueryValue(info, _T("\\VarFileInfo\\Translation"),
								(void **)&TransBlk, &valSize))
			{

			   snwprintf(blockStr, 100, _T("\\StringFileInfo\\%04hX%04hX\\%s"),
						 LOWORD(*TransBlk),
						 HIWORD(*TransBlk),
						 key);

				if(VerQueryValue(info, (LPTSTR)blockStr,
									(void **)&verStr, &valSize))
				{
					sDesc = (TCHAR *)verStr;
				} //endif VerQueryValue()
			}

		} //endif GetFileVersionInfo()

		delete[] (LPBYTE)info;

	} // endif infoSize

	return sDesc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\common\wbemversion.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __WBEMVERSION__
#define __WBEMVERSION__
#pragma once

// version resource helpers.
bstr_t GetDoubleVersion(void);
bstr_t GetMyVersion(void);
bstr_t GetMyCompany(void);
bstr_t GetCimomVersion(void);
bstr_t GetStringFileInfo(LPCTSTR filename, LPCTSTR key);
LONG GetCimomFileName(LPTSTR filename, UINT size);

#endif __WBEMVERSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\inc\snapins.inc\rpcasync.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rpcasync.h

Abstract:

    This module contains the RPC runtime APIs needed to use
    [async] RPC features.

--*/

#ifndef __RPCASYNC_H__
#define __RPCASYNC_H__

#pragma message("rpcasync in snapins")

#ifdef __cplusplus
extern "C" {
#endif

#define RPC_ASYNC_VERSION_1_0     sizeof(RPC_ASYNC_STATE)

typedef
enum _RPC_NOTIFICATION_TYPES
{
    RpcNotificationTypeNone,
    RpcNotificationTypeEvent,
    RpcNotificationTypeApc, 
    RpcNotificationTypeIoc,
    RpcNotificationTypeHwnd,
    RpcNotificationTypeCallback
} RPC_NOTIFICATION_TYPES;

typedef
enum _RPC_ASYNC_EVENT {
    RpcCallComplete,
    RpcSendComplete,
    RpcReceiveComplete
    } RPC_ASYNC_EVENT;

typedef void RPC_ENTRY
RPCNOTIFICATION_ROUTINE (
                  struct _RPC_ASYNC_STATE *pAsync,
                  void *Context,                              
                  RPC_ASYNC_EVENT Event);
typedef RPCNOTIFICATION_ROUTINE *PFN_RPCNOTIFICATION_ROUTINE;
    
typedef struct _RPC_ASYNC_STATE {
    unsigned int    Size; // size of this structure
    unsigned long   Signature;
    long   Lock;
    unsigned long   Flags;
    void           *StubInfo;
    void           *UserInfo;
    void           *RuntimeInfo;
    RPC_ASYNC_EVENT Event;

    RPC_NOTIFICATION_TYPES NotificationType;
    union {
        //
        // Notification by APC
        //
        struct {
            PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
            HANDLE hThread;
            } APC;

        //
        // Notification by IO completion port
        //
        struct {
            HANDLE hIOPort;
            DWORD dwNumberOfBytesTransferred;
            DWORD dwCompletionKey;
            LPOVERLAPPED lpOverlapped;
            } IOC;

        //
        // Notification by window message
        //
        struct {
            HWND hWnd;
            UINT Msg;
            } HWND;


        //
        // Notification by event
        //
        HANDLE hEvent;

        //
        // Notification by callback function
        //
        // This option is available only to OLE
        //
        PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
        } u;

    long Reserved[4]; 
    } RPC_ASYNC_STATE, *PRPC_ASYNC_STATE;

// Possible values for Flags
#define RPC_C_NOTIFY_ON_SEND_COMPLETE      0x1
#define RPC_C_INFINITE_TIMEOUT             INFINITE

#define RpcAsyncGetCallHandle(pAsync) (((PRPC_ASYNC_STATE) pAsync)->RuntimeInfo)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncInitializeHandle (
    PRPC_ASYNC_STATE pAsync,
    unsigned int     Size
    );
                      
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncRegisterInfo (
    PRPC_ASYNC_STATE pAsync
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncGetCallStatus (
    PRPC_ASYNC_STATE pAsync
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCompleteCall (
    PRPC_ASYNC_STATE pAsync,
    void *Reply
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncAbortCall (
    PRPC_ASYNC_STATE pAsync,
    unsigned long ExceptionCode
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCancelCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN BOOL fAbort
    ) ;

//
// Internal APIs
//
RPC_STATUS RPC_ENTRY
I_RpcAsyncSetHandle (
    IN  PRPC_MESSAGE Message,
    IN  PRPC_ASYNC_STATE pAsync
    );

RPC_STATUS RPC_ENTRY
I_RpcAsyncAbortCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    ) ;


//
// This stuff is in here so we don't break ole, stubs and the tests
// remove before we ship
//
#define RpcInitializeAsyncHandle  RpcAsyncInitializeHandle
#define RpcRegisterAsyncInfo  RpcAsyncRegisterInfo
#define RpcGetAsyncCallStatus  RpcAsyncGetCallStatus
#define RpcCompleteAsyncCall  RpcAsyncCompleteCall
#define RpcAbortAsyncCall  RpcAsyncAbortCall
#define RpcCancelAsyncCall  RpcAsyncCancelCall
#define I_RpcSetAsyncHandle  I_RpcAsyncSetHandle
#define I_RpcAbortAsyncCall  I_RpcAsyncAbortCall

#ifdef __cplusplus
}
#endif

#endif /* __RPCASYNC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\inc\snapins.inc\rpcndr.h ===
/*++

Copyright (c) 1992-1997 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Author:

    DonnaLi (01-01-91)

Environment:

    DOS, Win 3.X, and Win/NT.

Revision History:

   DONNALI  08-29-91     Start recording history
   donnali  09-11-91     change conversion macros
   donnali  09-18-91     check in files for moving
   STEVEZ   10-15-91     Merge with NT tree
   donnali  10-28-91     add prototype
   donnali  11-19-91     bugfix for strings
   MIKEMON  12-17-91     DCE runtime API conversion
   donnali  03-24-92     change rpc public header f
   STEVEZ   04-04-92     add nsi include
   mikemon  04-18-92     security support and misc
   DovhH    04-24-24     Changed signature of <int>_from_ndr
                         (to unsigned <int>)
                         Added <base_type>_array_from_ndr routines
   RyszardK 06-17-93     Added support for hyper
   VibhasC  09-11-93     Created rpcndrn.h
   DKays    10-14-93     Fixed up rpcndrn.h MIDL 2.0
   RyszardK 01-15-94     Merged in the midl 2.0 changes from rpcndrn.h
   Stevebl  04-22-96     Hookole support changes to MIDL_*_INFO
   RyszardK 05-20-97     Added async support, started version at 450.

--*/

// This version of the rpcproxy.h file corresponds to MIDL version 3.3.106
// used with NT5 beta env from build #1574 on.

#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__        ( 450 )
#endif // __RPCNDR_H_VERSION__


#ifndef __RPCNDR_H__
#define __RPCNDR_H__

#ifdef __REQUIRED_RPCNDR_H_VERSION__
    #if ( __RPCNDR_H_VERSION__ < __REQUIRED_RPCNDR_H_VERSION__ )
        #error incorrect <rpcndr.h> version. Use the header that matches with the MIDL compiler.
    #endif 
#endif

#pragma message("rpcndr in snapins")

//
// Set the packing level for RPC structures for Dos, Windows and Mac.
//

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__) || defined(__RPC_MAC__)
#pragma pack(2)
#endif

#if defined(__RPC_MAC__)
#define _MAC_
#endif

#include <rpcnsip.h>

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************

     Network Computing Architecture (NCA) definition:

     Network Data Representation: (NDR) Label format:
     An unsigned long (32 bits) with the following layout:

     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    +---------------+---------------+---------------+-------+-------+
    |   Reserved    |   Reserved    |Floating point | Int   | Char  |
    |               |               |Representation | Rep.  | Rep.  |
    +---------------+---------------+---------------+-------+-------+

     Where

         Reserved:

             Must be zero (0) for NCA 1.5 and NCA 2.0.

         Floating point Representation is:

             0 - IEEE
             1 - VAX
             2 - Cray
             3 - IBM

         Int Rep. is Integer Representation:

             0 - Big Endian
             1 - Little Endian

         Char Rep. is Character Representation:

             0 - ASCII
             1 - EBCDIC

     The Microsoft Local Data Representation (for all platforms which are
     of interest currently is edefined below:

 ****************************************************************************/

#define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
#define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
#define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L

#define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
#define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L

#define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
#define NDR_VAX_FLOAT                   (unsigned long)0X00000100L

#define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
#define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L

#if defined(__RPC_MAC__)
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000000L
#define NDR_LOCAL_ENDIAN                NDR_BIG_ENDIAN
#else
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
#define NDR_LOCAL_ENDIAN                NDR_LITTLE_ENDIAN
#endif


/****************************************************************************
 *  Macros for targeted platforms
 ****************************************************************************/

#if (0x500 <= _WIN32_WINNT)
#define TARGET_IS_NT50_OR_LATER                   1
#else
#define TARGET_IS_NT50_OR_LATER                   0
#endif

#if (defined(_WIN32_DCOM) || 0x400 <= _WIN32_WINNT)
#define TARGET_IS_NT40_OR_LATER                   1
#else
#define TARGET_IS_NT40_OR_LATER                   0
#endif

#if (0x400 <= WINVER)
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         1
#else
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         0
#endif

/****************************************************************************
 *  Other MIDL base types / predefined types:
 ****************************************************************************/

#define small char
typedef unsigned char byte;
typedef unsigned char boolean;

#ifndef _HYPER_DEFINED
#define _HYPER_DEFINED

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
#define  hyper           __int64
#define MIDL_uhyper  unsigned __int64
#else
typedef double  hyper;
typedef double MIDL_uhyper;
#endif

#endif // _HYPER_DEFINED

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifdef __RPC_DOS__
#define __RPC_CALLEE       __far __pascal
#endif

#ifdef __RPC_WIN16__
#define __RPC_CALLEE       __far __pascal __export
#endif

#ifdef __RPC_WIN32__
#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_CALLEE       __stdcall
#else
#define __RPC_CALLEE
#endif
#endif

#ifdef __RPC_MAC__
#define __RPC_CALLEE __far
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void             __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifdef __RPC_WIN16__
#define RPC_VAR_ENTRY __export __cdecl
#else
#define RPC_VAR_ENTRY __cdecl
#endif


/* winnt only */
#if defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA)
#define __MIDL_DECLSPEC_DLLIMPORT   __declspec(dllimport)
#define __MIDL_DECLSPEC_DLLEXPORT   __declspec(dllexport)
#else
#define __MIDL_DECLSPEC_DLLIMPORT
#define __MIDL_DECLSPEC_DLLEXPORT
#endif




/****************************************************************************
 * Context handle management related definitions:
 *
 * Client and Server Contexts.
 *
 ****************************************************************************/

typedef void __RPC_FAR * NDR_CCONTEXT;

typedef struct
    {
    void __RPC_FAR * pad[2];
    void __RPC_FAR * userContext;
    } __RPC_FAR * NDR_SCONTEXT;

#define NDRSContextValue(hContext) (&(hContext)->userContext)

#define cbNDRContext 20         /* size of context on WIRE */

typedef void (__RPC_USER __RPC_FAR * NDR_RUNDOWN)(void __RPC_FAR * context);

typedef struct _SCONTEXT_QUEUE {
    unsigned long   NumberOfObjects;
    NDR_SCONTEXT  * ArrayOfObjects;
    } SCONTEXT_QUEUE, __RPC_FAR * PSCONTEXT_QUEUE;

RPCRTAPI
RPC_BINDING_HANDLE
RPC_ENTRY
NDRCContextBinding (
    IN NDR_CCONTEXT     CContext
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextMarshall (
    IN  NDR_CCONTEXT    CContext,
    OUT void __RPC_FAR *pBuff
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextUnmarshall (
    OUT NDR_CCONTEXT __RPC_FAR *pCContext,
    IN  RPC_BINDING_HANDLE      hBinding,
    IN  void __RPC_FAR *        pBuff,
    IN  unsigned long           DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshall (
    IN  NDR_SCONTEXT    CContext,
    OUT void __RPC_FAR *pBuff,
    IN  NDR_RUNDOWN     userRunDownIn
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshall (
    IN  void __RPC_FAR *pBuff,
    IN  unsigned long   DataRepresentation
    );

RPCRTAPI
void 
RPC_ENTRY
NDRSContextMarshallEx (
    IN  RPC_BINDING_HANDLE  BindingHandle, 
    IN  NDR_SCONTEXT        CContext,
    OUT void __RPC_FAR     *pBuff,
    IN  NDR_RUNDOWN         userRunDownIn
    );

RPCRTAPI
NDR_SCONTEXT 
RPC_ENTRY
NDRSContextUnmarshallEx (
    IN  RPC_BINDING_HANDLE  BindingHandle, 
    IN  void __RPC_FAR     *pBuff,
    IN  unsigned long       DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDestroyClientContext (
    IN void __RPC_FAR * __RPC_FAR * ContextHandle
    );


/****************************************************************************
    NDR conversion related definitions.
 ****************************************************************************/

#define byte_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define byte_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define boolean_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define boolean_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define small_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define small_from_ndr_temp(source, target, format) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)(source))++; \
    }

#define small_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

/****************************************************************************
    Platform specific mapping of c-runtime functions.
 ****************************************************************************/

#ifdef __RPC_DOS__
#define MIDL_ascii_strlen(string) \
    _fstrlen(string)
#define MIDL_ascii_strcpy(target,source) \
    _fstrcpy(target,source)
#define MIDL_memset(s,c,n) \
    _fmemset(s,c,n)
#endif

#ifdef __RPC_WIN16__
#define MIDL_ascii_strlen(string) \
    _fstrlen(string)
#define MIDL_ascii_strcpy(target,source) \
    _fstrcpy(target,source)
#define MIDL_memset(s,c,n) \
    _fmemset(s,c,n)
#endif

#if defined(__RPC_WIN32__) || defined(__RPC_MAC__)
#define MIDL_ascii_strlen(string) \
    strlen(string)
#define MIDL_ascii_strcpy(target,source) \
    strcpy(target,source)
#define MIDL_memset(s,c,n) \
    memset(s,c,n)
#endif

/****************************************************************************
    Ndr Library helper function prototypes for MIDL 1.0 ndr functions.
 ****************************************************************************/

RPCRTAPI
void
RPC_ENTRY
NDRcopy (
    IN void __RPC_FAR *pTarget,
    IN void __RPC_FAR *pSource,
    IN unsigned int size
    );

RPCRTAPI
size_t
RPC_ENTRY
MIDL_wchar_strlen (
    IN wchar_t __RPC_FAR *   s
    );

RPCRTAPI
void
RPC_ENTRY
MIDL_wchar_strcpy (
    OUT void __RPC_FAR *     t,
    IN wchar_t __RPC_FAR *   s
    );

RPCRTAPI
void
RPC_ENTRY
char_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned char __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
char_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned char __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
short_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned short __RPC_FAR *                target
    );

RPCRTAPI
void
RPC_ENTRY
short_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned short __RPC_FAR *                Target
    );

RPCRTAPI
void
RPC_ENTRY
short_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned short __RPC_FAR *                target,
    IN unsigned long                              format
    );

RPCRTAPI
void
RPC_ENTRY
long_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned long __RPC_FAR *                 target
    );

RPCRTAPI
void
RPC_ENTRY
long_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned long __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
long_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned long __RPC_FAR *                 target,
    IN unsigned long                              format
    );

RPCRTAPI
void
RPC_ENTRY
enum_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned int __RPC_FAR *                  Target
    );

RPCRTAPI
void
RPC_ENTRY
float_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
float_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
double_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
double_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT    hyper __RPC_FAR *                      target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT          hyper __RPC_FAR *                Target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT             hyper __RPC_FAR *             target,
    IN   unsigned   long                          format
    );

RPCRTAPI
void
RPC_ENTRY
data_from_ndr (
    PRPC_MESSAGE                                  source,
    void __RPC_FAR *                              target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
data_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
data_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_peek_ndr (
    PRPC_MESSAGE                                  source,
    unsigned char __RPC_FAR * __RPC_FAR *         buffer,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
midl_allocate (
    size_t      size
    );

/****************************************************************************
    MIDL 2.0 ndr definitions.
 ****************************************************************************/

typedef unsigned long error_status_t;

#define _midl_ma1( p, cast )    *(*( cast **)&p)++
#define _midl_ma2( p, cast )    *(*( cast **)&p)++
#define _midl_ma4( p, cast )    *(*( cast **)&p)++
#define _midl_ma8( p, cast )    *(*( cast **)&p)++

#define _midl_unma1( p, cast )  *(( cast *)p)++
#define _midl_unma2( p, cast )  *(( cast *)p)++
#define _midl_unma3( p, cast )  *(( cast *)p)++
#define _midl_unma4( p, cast )  *(( cast *)p)++

// Some alignment specific macros.


#define _midl_fa2( p )          (p = (RPC_BUFPTR )((unsigned long)(p+1) & 0xfffffffe))
#define _midl_fa4( p )          (p = (RPC_BUFPTR )((unsigned long)(p+3) & 0xfffffffc))
#define _midl_fa8( p )          (p = (RPC_BUFPTR )((unsigned long)(p+7) & 0xfffffff8))

#define _midl_addp( p, n )      (p += n)

// Marshalling macros

#define _midl_marsh_lhs( p, cast )  *(*( cast **)&p)++
#define _midl_marsh_up( mp, p )     *(*(unsigned long **)&mp)++ = (unsigned long)p
#define _midl_advmp( mp )           *(*(unsigned long **)&mp)++
#define _midl_unmarsh_up( p )       (*(*(unsigned long **)&p)++)


////////////////////////////////////////////////////////////////////////////
// Ndr macros.
////////////////////////////////////////////////////////////////////////////

#define NdrMarshConfStringHdr( p, s, l )    (_midl_ma4( p, unsigned long) = s, \
                                            _midl_ma4( p, unsigned long) = 0, \
                                            _midl_ma4( p, unsigned long) = l)

#define NdrUnMarshConfStringHdr(p, s, l)    ((s=_midl_unma4(p,unsigned long),\
                                            (_midl_addp(p,4)),               \
                                            (l=_midl_unma4(p,unsigned long))

#define NdrMarshCCtxtHdl(pc,p)  (NDRCContextMarshall( (NDR_CCONTEXT)pc, p ),p+20)

#define NdrUnMarshCCtxtHdl(pc,p,h,drep) \
        (NDRCContextUnmarshall((NDR_CONTEXT)pc,h,p,drep), p+20)

#define NdrUnMarshSCtxtHdl(pc, p,drep)  (pc = NdrSContextUnMarshall(p,drep ))


#define NdrMarshSCtxtHdl(pc,p,rd)   (NdrSContextMarshall((NDR_SCONTEXT)pc,p, (NDR_RUNDOWN)rd)

#define NdrFieldOffset(s,f)     (long)(& (((s __RPC_FAR *)0)->f))
#define NdrFieldPad(s,f,p,t)    (NdrFieldOffset(s,f) - NdrFieldOffset(s,p) - sizeof(t))

#if defined(__RPC_MAC__)
#define NdrFcShort(s)   (unsigned char)(s >> 8), (unsigned char)(s & 0xff)
#define NdrFcLong(s)    (unsigned char)(s >> 24), (unsigned char)((s & 0x00ff0000) >> 16), \
                        (unsigned char)((s & 0x0000ff00) >> 8), (unsigned char)(s & 0xff)
#else
#define NdrFcShort(s)   (unsigned char)(s & 0xff), (unsigned char)(s >> 8)
#define NdrFcLong(s)    (unsigned char)(s & 0xff), (unsigned char)((s & 0x0000ff00) >> 8), \
                        (unsigned char)((s & 0x00ff0000) >> 16), (unsigned char)(s >> 24)
#endif //  Mac

//
// On the server side, the following exceptions are mapped to
// the bad stub data exception if -error stub_data is used.
//

#define RPC_BAD_STUB_DATA_EXCEPTION_FILTER  \
                 ( (RpcExceptionCode() == STATUS_ACCESS_VIOLATION)  || \
                   (RpcExceptionCode() == STATUS_DATATYPE_MISALIGNMENT) || \
                   (RpcExceptionCode() == RPC_X_BAD_STUB_DATA) )

/////////////////////////////////////////////////////////////////////////////
// Some stub helper functions.
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Stub helper structures.
////////////////////////////////////////////////////////////////////////////

struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;

typedef unsigned char __RPC_FAR * RPC_BUFPTR;
typedef unsigned long             RPC_LENGTH;

// Expression evaluation callback routine prototype.
typedef void (__RPC_USER __RPC_FAR * EXPR_EVAL)( struct _MIDL_STUB_MESSAGE __RPC_FAR * );

typedef const unsigned char __RPC_FAR * PFORMAT_STRING;

/*
 * Multidimensional conformant/varying array struct.
 */
typedef struct
    {
    long                            Dimension;

    /* These fields MUST be (unsigned long *) */
    unsigned long __RPC_FAR *       BufferConformanceMark;
    unsigned long __RPC_FAR *       BufferVarianceMark;

    /* Count arrays, used for top level arrays in -Os stubs */
    unsigned long __RPC_FAR *       MaxCountArray;
    unsigned long __RPC_FAR *       OffsetArray;
    unsigned long __RPC_FAR *       ActualCountArray;
    } ARRAY_INFO, __RPC_FAR *PARRAY_INFO;

/*
 *  Pipe related definitions.
 */

typedef struct _NDR_PIPE_DESC *       PNDR_PIPE_DESC;
typedef struct _NDR_PIPE_MESSAGE *    PNDR_PIPE_MESSAGE;

typedef struct _NDR_ASYNC_MESSAGE *   PNDR_ASYNC_MESSAGE;

/*
 * MIDL Stub Message
 */
#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__)
#include <pshpack4.h>
#endif

typedef struct _MIDL_STUB_MESSAGE
    {
    /* RPC message structure. */
    PRPC_MESSAGE                RpcMsg;

    /* Pointer into RPC message buffer. */
    unsigned char __RPC_FAR *   Buffer;

    /*
     * These are used internally by the Ndr routines to mark the beginning
     * and end of an incoming RPC buffer.
     */
    unsigned char __RPC_FAR *   BufferStart;
    unsigned char __RPC_FAR *   BufferEnd;

    /*
     * Used internally by the Ndr routines as a place holder in the buffer.
     * On the marshalling side it's used to mark the location where conformance
     * size should be marshalled.
     * On the unmarshalling side it's used to mark the location in the buffer
     * used during pointer unmarshalling to base pointer offsets off of.
     */
    unsigned char __RPC_FAR *   BufferMark;

    /* Set by the buffer sizing routines. */
    unsigned long               BufferLength;

    /* Set by the memory sizing routines. */
    unsigned long               MemorySize;

    /* Pointer to user memory. */
    unsigned char __RPC_FAR *   Memory;

    /* Is the Ndr routine begin called from a client side stub. */
    int                         IsClient;

    /* Can the buffer be re-used for memory on unmarshalling. */
    int                         ReuseBuffer;

    /* Holds the current pointer to an allocate all nodes memory block. */
    unsigned char __RPC_FAR *   AllocAllNodesMemory;

    /* Used for debugging asserts only, remove later. */
    unsigned char __RPC_FAR *   AllocAllNodesMemoryEnd;

    /*
     * Stuff needed while handling complex structures
     */

    /* Ignore imbeded pointers while computing buffer or memory sizes. */
    int                         IgnoreEmbeddedPointers;

    /*
     * This marks the location in the buffer where pointees of a complex
     * struct reside.
     */
    unsigned char __RPC_FAR *   PointerBufferMark;

    /*
     * Used to catch errors in SendReceive.
     */
    unsigned char               fBufferValid;

    /*
     * Obsolete unused field (formerly MaxContextHandleNumber).
     */
    unsigned char               Unused;

    /*
     * Used internally by the Ndr routines.  Holds the max counts for
     * a conformant array.
     */
    unsigned long               MaxCount;

    /*
     * Used internally by the Ndr routines.  Holds the offsets for a varying
     * array.
     */
    unsigned long               Offset;

    /*
     * Used internally by the Ndr routines.  Holds the actual counts for
     * a varying array.
     */
    unsigned long               ActualCount;

    /* Allocation and Free routine to be used by the Ndr routines. */
    void __RPC_FAR *    (__RPC_FAR __RPC_API * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_API * pfnFree)(void __RPC_FAR *);

    /*
     * Top of parameter stack.  Used for "single call" stubs during marshalling
     * to hold the beginning of the parameter list on the stack.  Needed to
     * extract parameters which hold attribute values for top level arrays and
     * pointers.
     */
    unsigned char __RPC_FAR *       StackTop;

    /*
     *  Fields used for the transmit_as and represent_as objects.
     *  For represent_as the mapping is: presented=local, transmit=named.
     */
    unsigned char __RPC_FAR *       pPresentedType;
    unsigned char __RPC_FAR *       pTransmitType;

    /*
     * When we first construct a binding on the client side, stick it
     * in the rpcmessage and later call RpcGetBuffer, the handle field
     * in the rpcmessage is changed. That's fine except that we need to
     * have that original handle for use in unmarshalling context handles
     * (the second argument in NDRCContextUnmarshall to be exact). So
     * stash the contructed handle here and extract it when needed.
     */
    handle_t                        SavedHandle;

    /*
     * Pointer back to the stub descriptor.  Use this to get all handle info.
     */
    const struct _MIDL_STUB_DESC __RPC_FAR *    StubDesc;

    /*
     * Full pointer stuff.
     */
    struct _FULL_PTR_XLAT_TABLES __RPC_FAR *    FullPtrXlatTables;

    unsigned long                   FullPtrRefId;

    /*
     * flags
     */

    int                             fCheckBounds;

    int                             fInDontFree       :1;
    int                             fDontCallFreeInst :1;
    int                             fInOnlyParam      :1;
    int                             fHasReturn        :1;

    unsigned long                   dwDestContext;
    void __RPC_FAR *                pvDestContext;

    NDR_SCONTEXT *                  SavedContextHandles;

    long                            ParamNumber;

    struct IRpcChannelBuffer __RPC_FAR *    pRpcChannelBuffer;

    PARRAY_INFO                     pArrayInfo;

    /*
     * This is where the Beta2 stub message ends.
     */

    unsigned long __RPC_FAR *       SizePtrCountArray;
    unsigned long __RPC_FAR *       SizePtrOffsetArray;
    unsigned long __RPC_FAR *       SizePtrLengthArray;

    /*
     * Interpreter argument queue.  Used on server side only.
     */
    void __RPC_FAR *                pArgQueue;

    unsigned long                   dwStubPhase;

    /*
     * Pipe descriptor, defined for the 4.0 release.
     */
    PNDR_PIPE_DESC                  pPipeDesc;

    /*
     *  Async message pointer, an NT 5.0 feature.
     */
    PNDR_ASYNC_MESSAGE              pAsyncMsg;

    unsigned long                   Reserved[3];

    /*
     *  Fields up to this point present since the 3.50 release.
     */

    } MIDL_STUB_MESSAGE, __RPC_FAR *PMIDL_STUB_MESSAGE;

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__)
#include <poppack.h>
#endif

/*
 * Generic handle bind/unbind routine pair.
 */
typedef void __RPC_FAR *
        (__RPC_FAR __RPC_API * GENERIC_BINDING_ROUTINE)
        (void __RPC_FAR *);
typedef void
        (__RPC_FAR __RPC_API * GENERIC_UNBIND_ROUTINE)
        (void __RPC_FAR *, unsigned char __RPC_FAR *);

typedef struct _GENERIC_BINDING_ROUTINE_PAIR
    {
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_ROUTINE_PAIR, __RPC_FAR *PGENERIC_BINDING_ROUTINE_PAIR;

typedef struct __GENERIC_BINDING_INFO
    {
    void __RPC_FAR *            pObj;
    unsigned int                Size;
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_INFO, __RPC_FAR *PGENERIC_BINDING_INFO;

// typedef EXPR_EVAL - see above
// typedefs for xmit_as

#if (defined(_MSC_VER)) && !defined(MIDL_PASS)
// a Microsoft C++ compiler
#define NDR_SHAREABLE __inline
#else
#define NDR_SHAREABLE static
#endif


typedef void (__RPC_FAR __RPC_USER * XMIT_HELPER_ROUTINE)
    ( PMIDL_STUB_MESSAGE );

typedef struct _XMIT_ROUTINE_QUINTUPLE
    {
    XMIT_HELPER_ROUTINE     pfnTranslateToXmit;
    XMIT_HELPER_ROUTINE     pfnTranslateFromXmit;
    XMIT_HELPER_ROUTINE     pfnFreeXmit;
    XMIT_HELPER_ROUTINE     pfnFreeInst;
    } XMIT_ROUTINE_QUINTUPLE, __RPC_FAR *PXMIT_ROUTINE_QUINTUPLE;

typedef unsigned long
(__RPC_FAR __RPC_USER * USER_MARSHAL_SIZING_ROUTINE)
    (unsigned long __RPC_FAR *,
     unsigned long,
     void __RPC_FAR * );

typedef unsigned char __RPC_FAR *
(__RPC_FAR __RPC_USER * USER_MARSHAL_MARSHALLING_ROUTINE)
    (unsigned long __RPC_FAR *,
     unsigned char  __RPC_FAR * ,
     void __RPC_FAR * );

typedef unsigned char __RPC_FAR *
(__RPC_FAR __RPC_USER * USER_MARSHAL_UNMARSHALLING_ROUTINE)
    (unsigned long __RPC_FAR *,
     unsigned char  __RPC_FAR * ,
     void __RPC_FAR * );

typedef void (__RPC_FAR __RPC_USER * USER_MARSHAL_FREEING_ROUTINE)
    (unsigned long __RPC_FAR *,
     void __RPC_FAR * );

typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE
    {
    USER_MARSHAL_SIZING_ROUTINE          pfnBufferSize;
    USER_MARSHAL_MARSHALLING_ROUTINE     pfnMarshall;
    USER_MARSHAL_UNMARSHALLING_ROUTINE   pfnUnmarshall;
    USER_MARSHAL_FREEING_ROUTINE         pfnFree;
    } USER_MARSHAL_ROUTINE_QUADRUPLE;

typedef struct _USER_MARSHAL_CB
{
    unsigned long       Flags;
    PMIDL_STUB_MESSAGE  pStubMsg;
    PFORMAT_STRING      pReserve;
} USER_MARSHAL_CB;


#define USER_CALL_CTXT_MASK(f)  ((f) & 0x00ff)
#define USER_CALL_AUX_MASK(f)   ((f) & 0xff00)
#define GET_USER_DATA_REP(f)    ((f) >> 16)

#define USER_CALL_IS_ASYNC      0x0100      /* aux flag: in an [async] call */


typedef struct _MALLOC_FREE_STRUCT
    {
    void __RPC_FAR *    (__RPC_FAR __RPC_USER * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_USER * pfnFree)(void __RPC_FAR *);
    } MALLOC_FREE_STRUCT;

typedef struct _COMM_FAULT_OFFSETS
    {
    short       CommOffset;
    short       FaultOffset;
    } COMM_FAULT_OFFSETS;

/*
 * MIDL Stub Descriptor
 */

typedef struct _MIDL_STUB_DESC
    {

    void __RPC_FAR *    RpcInterfaceInformation;

    void __RPC_FAR *    (__RPC_FAR __RPC_API * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_API * pfnFree)(void __RPC_FAR *);

    union
        {
        handle_t __RPC_FAR *            pAutoHandle;
        handle_t __RPC_FAR *            pPrimitiveHandle;
        PGENERIC_BINDING_INFO           pGenericBindingInfo;
        } IMPLICIT_HANDLE_INFO;

    const NDR_RUNDOWN __RPC_FAR *                   apfnNdrRundownRoutines;
    const GENERIC_BINDING_ROUTINE_PAIR __RPC_FAR *  aGenericBindingRoutinePairs;

    const EXPR_EVAL __RPC_FAR *                     apfnExprEval;

    const XMIT_ROUTINE_QUINTUPLE __RPC_FAR *        aXmitQuintuple;

    const unsigned char __RPC_FAR *                 pFormatTypes;

    int                                             fCheckBounds;

    /* Ndr library version. */
    unsigned long                                   Version;

    /*
     * Reserved for future use. (no reserves )
     */

    MALLOC_FREE_STRUCT __RPC_FAR *                  pMallocFreeStruct;

    long                                MIDLVersion;

    const COMM_FAULT_OFFSETS __RPC_FAR *    CommFaultOffsets;

    // New fields for version 3.0+

    const USER_MARSHAL_ROUTINE_QUADRUPLE __RPC_FAR * aUserMarshalQuadruple;

    long                                    Reserved1;
    long                                    Reserved2;
    long                                    Reserved3;
    long                                    Reserved4;
    long                                    Reserved5;

    } MIDL_STUB_DESC;

typedef const MIDL_STUB_DESC __RPC_FAR * PMIDL_STUB_DESC;

typedef void __RPC_FAR * PMIDL_XMIT_TYPE;

/*
 * MIDL Stub Format String.  This is a const in the stub.
 */
#if !defined( RC_INVOKED )
#pragma warning( disable:4200 )
#endif
typedef struct _MIDL_FORMAT_STRING
    {
    short               Pad;
    unsigned char       Format[];
    } MIDL_FORMAT_STRING;
#if !defined( RC_INVOKED )
#pragma warning( default:4200 )
#endif

/*
 * Stub thunk used for some interpreted server stubs.
 */
typedef void (__RPC_FAR __RPC_API * STUB_THUNK)( PMIDL_STUB_MESSAGE );

typedef long (__RPC_FAR __RPC_API * SERVER_ROUTINE)();

/*
 * Server Interpreter's information strucuture.
 */
typedef struct  _MIDL_SERVER_INFO_
    {
    PMIDL_STUB_DESC             pStubDesc;
    const SERVER_ROUTINE *      DispatchTable;
    PFORMAT_STRING              ProcString;
    const unsigned short *      FmtStringOffset;
    const STUB_THUNK *          ThunkTable;
    PFORMAT_STRING              LocalFormatTypes;
    PFORMAT_STRING              LocalProcString;
    const unsigned short *      LocalFmtStringOffset;
    } MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;

/*
 * Stubless object proxy information structure.
 */
typedef struct _MIDL_STUBLESS_PROXY_INFO
    {
    PMIDL_STUB_DESC                     pStubDesc;
    PFORMAT_STRING                      ProcFormatString;
    const unsigned short __RPC_FAR *    FormatStringOffset;
    PFORMAT_STRING                      LocalFormatTypes;
    PFORMAT_STRING                      LocalProcString;
    const unsigned short __RPC_FAR *    LocalFmtStringOffset;
    } MIDL_STUBLESS_PROXY_INFO;

typedef MIDL_STUBLESS_PROXY_INFO __RPC_FAR * PMIDL_STUBLESS_PROXY_INFO;

/*
 * This is the return value from NdrClientCall.
 */
typedef union _CLIENT_CALL_RETURN
    {
    void __RPC_FAR *        Pointer;
    long                    Simple;
    } CLIENT_CALL_RETURN;

/*
 * Full pointer data structures.
 */

typedef enum
        {
        XLAT_SERVER = 1,
        XLAT_CLIENT
        } XLAT_SIDE;

/*
 * Stores the translation for the conversion from a full pointer into it's
 * corresponding ref id.
 */
typedef struct _FULL_PTR_TO_REFID_ELEMENT
    {
    struct _FULL_PTR_TO_REFID_ELEMENT __RPC_FAR *  Next;

    void __RPC_FAR *            Pointer;
    unsigned long       RefId;
    unsigned char       State;
    } FULL_PTR_TO_REFID_ELEMENT, __RPC_FAR *PFULL_PTR_TO_REFID_ELEMENT;

/*
 * Full pointer translation tables.
 */
typedef struct _FULL_PTR_XLAT_TABLES
    {
    /*
     * Ref id to pointer translation information.
     */
    struct
        {
        void __RPC_FAR *__RPC_FAR *             XlatTable;
        unsigned char __RPC_FAR *     StateTable;
        unsigned long       NumberOfEntries;
        } RefIdToPointer;

    /*
     * Pointer to ref id translation information.
     */
    struct
        {
        PFULL_PTR_TO_REFID_ELEMENT __RPC_FAR *  XlatTable;
        unsigned long                   NumberOfBuckets;
        unsigned long                   HashMask;
        } PointerToRefId;

    /*
     * Next ref id to use.
     */
    unsigned long           NextRefId;

    /*
     * Keep track of the translation size we're handling : server or client.
     * This tells us when we have to do reverse translations when we insert
     * new translations.  On the server we must insert a pointer-to-refid
     * translation whenever we insert a refid-to-pointer translation, and
     * vica versa for the client.
     */
    XLAT_SIDE               XlatSide;
    } FULL_PTR_XLAT_TABLES, __RPC_FAR *PFULL_PTR_XLAT_TABLES;

/***************************************************************************
 ** New MIDL 2.0 Ndr routine templates
 ***************************************************************************/

/*
 * Marshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    unsigned char                       FormatChar
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrPointerMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrSimpleStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantVaryingStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrHardStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrComplexStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrFixedArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrComplexArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNonConformantStringMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantStringMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNonEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Byte count pointer */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrByteCountPointerMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrXmitOrRepAsMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrUserMarshalMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Cairo interface pointer */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrInterfacePointerMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextMarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_CCONTEXT          ContextHandle,
    int                   fCheck
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerContextMarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_SCONTEXT          ContextHandle,
    NDR_RUNDOWN           RundownRoutine
    );

/*
 * Unmarshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    unsigned char                       FormatChar
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrPointerUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Structures */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrSimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantVaryingStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrHardStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Arrays */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrFixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Strings */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Unions */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNonEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Byte count pointer */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrByteCountPointerUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrXmitOrRepAsUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* User_marshal */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrUserMarshalUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Cairo interface pointer */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrInterfacePointerUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextUnmarshall(
    PMIDL_STUB_MESSAGE          pStubMsg,
    NDR_CCONTEXT __RPC_FAR *    pContextHandle,
    RPC_BINDING_HANDLE          BindHandle
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrServerContextUnmarshall(
    PMIDL_STUB_MESSAGE          pStubMsg
    );

/*
 * Buffer sizing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrHardStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

RPCRTAPI
void
RPC_ENTRY
NdrConformantStringBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonConformantStringBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Byte count pointer */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

// Context Handle size
//
RPCRTAPI
void
RPC_ENTRY
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/*
 * Memory sizing routines
 */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrSimpleStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrHardStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrFixedArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStringMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned long
RPC_ENTRY
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/*
 * Freeing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrHardStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Byte count */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/*
 * Endian conversion routine.
 */

RPCRTAPI
void
RPC_ENTRY
NdrConvert2(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    long                                NumberParams
    );

RPCRTAPI
void
RPC_ENTRY
NdrConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

#define USER_MARSHAL_FC_BYTE         1
#define USER_MARSHAL_FC_CHAR         2
#define USER_MARSHAL_FC_SMALL        3
#define USER_MARSHAL_FC_USMALL       4
#define USER_MARSHAL_FC_WCHAR        5
#define USER_MARSHAL_FC_SHORT        6
#define USER_MARSHAL_FC_USHORT       7
#define USER_MARSHAL_FC_LONG         8
#define USER_MARSHAL_FC_ULONG        9
#define USER_MARSHAL_FC_FLOAT       10
#define USER_MARSHAL_FC_HYPER       11
#define USER_MARSHAL_FC_DOUBLE      12

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrUserMarshalSimpleTypeConvert(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    unsigned char   FormatChar
    );

/*
 * Auxilary routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrClientInitializeNew(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrServerInitializeNew(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializePartial(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned long                       RequestedBufferSize
    );

RPCRTAPI
void
RPC_ENTRY
NdrClientInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrServerInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrServerInitializeUnmarshall (
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    PRPC_MESSAGE                        pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializeMarshall (
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrGetBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNsGetBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrGetPipeBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle );

RPCRTAPI
void
RPC_ENTRY
NdrGetPartialBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR*            pBufferEnd
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pBufferEnd,
    RPC_BINDING_HANDLE __RPC_FAR *      pAutoHandle
    );

RPCRTAPI
void
RPC_ENTRY
NdrPipeSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PNDR_PIPE_DESC                      pPipeDesc
    );

RPCRTAPI
void
RPC_ENTRY
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrGetDcomProtocolVersion( 
    PMIDL_STUB_MESSAGE   pStubMsg,
    RPC_VERSION *        pVersion );


/*
 * Pipe specific calls
 */

RPCRTAPI
void
RPC_ENTRY
NdrPipesInitialize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pParamDesc,
    PNDR_PIPE_DESC                      pPipeDesc,
    PNDR_PIPE_MESSAGE                   pPipeMsg,
    char             __RPC_FAR *        pStackTop,
    unsigned long                       NumberParams );

RPCRTAPI
void
RPC_ENTRY
NdrPipePull(
    char          __RPC_FAR *           pState,
    void          __RPC_FAR *           buf,
    unsigned long                       esize,
    unsigned long __RPC_FAR *           ecount );

RPCRTAPI
void
RPC_ENTRY
NdrPipePush(
    char          __RPC_FAR *           pState,
    void          __RPC_FAR *           buf,
    unsigned long                       ecount );

RPCRTAPI
void
RPC_ENTRY
NdrIsAppDoneWithPipes(
    PNDR_PIPE_DESC                      pPipeDesc
    );

RPCRTAPI
void
RPC_ENTRY
NdrPipesDone(
    PMIDL_STUB_MESSAGE                  pStubMsg
    );


/*
 * Interpeter calls.
 */

/* client */

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall2(
    PMIDL_STUB_DESC                     pStubDescriptor,
    PFORMAT_STRING                      pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall(
    PMIDL_STUB_DESC                     pStubDescriptor,
    PFORMAT_STRING                      pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrAsyncClientCall(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    ...
    );

/* server */
typedef enum {
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT
}STUB_PHASE;

typedef enum {
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL
}PROXY_PHASE;

struct IRpcStubBuffer;      // Forward declaration

RPCRTAPI
long
RPC_ENTRY
NdrAsyncStubCall(
    struct IRpcStubBuffer *             pThis,
    struct IRpcChannelBuffer *          pChannel,
    PRPC_MESSAGE                        pRpcMsg,
    unsigned long *                     pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrAsyncServerCall(
    PRPC_MESSAGE                        pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall2(
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    unsigned long __RPC_FAR *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall2(
    PRPC_MESSAGE                        pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall (
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    unsigned long __RPC_FAR *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall(
    PRPC_MESSAGE                        pRpcMsg
    );

RPCRTAPI
int
RPC_ENTRY
NdrServerUnmarshall(
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PMIDL_STUB_DESC                      pStubDescriptor,
    PFORMAT_STRING                       pFormat,
    void __RPC_FAR *                     pParamList
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerMarshall(
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PFORMAT_STRING                       pFormat
    );

/* Comm and Fault status */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrMapCommAndFaultStatus(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long __RPC_FAR *                       pCommStatus,
    unsigned long __RPC_FAR *                       pFaultStatus,
    RPC_STATUS                          Status
    );

/* Helper routines */

RPCRTAPI
int
RPC_ENTRY
NdrSH_UPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    RPC_BUFPTR                          pBuffer
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_TLUPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_TLUPDecisionBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_IfAlloc(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_IfAllocRef(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_IfAllocSet(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_IfCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_IfAllocCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrSH_Copy(
    unsigned char           __RPC_FAR *         pStubMsg,
    unsigned char           __RPC_FAR *         pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
void
RPC_ENTRY
NdrSH_IfFree(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *         pPtr );


RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_StringMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *         pMemory,
    unsigned long                       Count,
    int                                 Size );

RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_StringUnMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *__RPC_FAR *          pMemory,
    int                                 Size );

/****************************************************************************
    MIDL 2.0 memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

typedef void __RPC_FAR * RPC_SS_THREAD_HANDLE;

typedef void __RPC_FAR * __RPC_API
RPC_CLIENT_ALLOC (
    IN size_t Size
    );

typedef void __RPC_API
RPC_CLIENT_FREE (
    IN void __RPC_FAR * Ptr
    );

/*++
     RpcSs* package
--*/

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
RpcSsAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDisableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsEnableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsFree (
    IN void __RPC_FAR * NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSsGetThreadHandle (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree,
    OUT RPC_CLIENT_ALLOC __RPC_FAR * __RPC_FAR * OldClientAlloc,
    OUT RPC_CLIENT_FREE __RPC_FAR * __RPC_FAR * OldClientFree
    );

/*++
     RpcSm* package
--*/

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
RpcSmAllocate (
    IN  size_t          Size,
    OUT RPC_STATUS __RPC_FAR *    pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmClientFree (
    IN  void __RPC_FAR * pNodeToFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDestroyClientContext (
    IN void __RPC_FAR * __RPC_FAR * ContextHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDisableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmEnableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmFree (
    IN void __RPC_FAR * NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSmGetThreadHandle (
    OUT RPC_STATUS __RPC_FAR *    pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree,
    OUT RPC_CLIENT_ALLOC __RPC_FAR * __RPC_FAR * OldClientAlloc,
    OUT RPC_CLIENT_FREE __RPC_FAR * __RPC_FAR * OldClientFree
    );

/*++
     Ndr stub entry points
--*/

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
NdrRpcSmClientAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmClientFree (
    IN void __RPC_FAR * NodeToFree
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
NdrRpcSsDefaultAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDefaultFree (
    IN void __RPC_FAR * NodeToFree
    );

/****************************************************************************
    end of memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

/****************************************************************************
 * Full Pointer APIs
 ****************************************************************************/

RPCRTAPI
PFULL_PTR_XLAT_TABLES
RPC_ENTRY
NdrFullPointerXlatInit(
    unsigned long           NumberOfPointers,
    XLAT_SIDE               XlatSide
    );

RPCRTAPI
void
RPC_ENTRY
NdrFullPointerXlatFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables
    );

RPCRTAPI
int
RPC_ENTRY
NdrFullPointerQueryPointer(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void __RPC_FAR *                    pPointer,
    unsigned char           QueryType,
    unsigned long __RPC_FAR *           pRefId
    );

RPCRTAPI
int
RPC_ENTRY
NdrFullPointerQueryRefId(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    unsigned char           QueryType,
    void __RPC_FAR *__RPC_FAR *                 ppPointer
    );

RPCRTAPI
void
RPC_ENTRY
NdrFullPointerInsertRefId(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    void __RPC_FAR *                    pPointer
    );

RPCRTAPI
int
RPC_ENTRY
NdrFullPointerFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void __RPC_FAR *                    Pointer
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
NdrAllocate(
    PMIDL_STUB_MESSAGE      pStubMsg,
    size_t                  Len
    );

RPCRTAPI
void
RPC_ENTRY
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    void __RPC_FAR *        ArgAddr
    );


/****************************************************************************
 * Proxy APIs
 ****************************************************************************/

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
NdrOleAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrOleFree (
    IN void __RPC_FAR * NodeToFree
    );

#ifdef CONST_VTABLE
#define CONST_VTBL const
#else
#define CONST_VTBL
#endif

/****************************************************************************
 * Special things for VC5 Com support
 ****************************************************************************/

#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#define MIDL_INTERFACE(x)   struct __declspec(uuid(x)) __declspec(novtable)
#else
#define DECLSPEC_UUID(x)
#define MIDL_INTERFACE(x)   struct
#endif

#if _MSC_VER >= 1100
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)  \
  EXTERN_C const IID __declspec(selectany) itf = {l1,s1,s2,{c1,c2,c3,c4,c5,c6,c7,c8}}
#else
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) EXTERN_C const IID itf
#endif



#ifdef __cplusplus
}
#endif

// Reset the packing level for DOS, Windows and Mac.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__) || defined(__RPC_MAC__)
#pragma pack()
#endif

#endif /* __RPCNDR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\inc\snapins.inc\mmc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0266 */
/* at Tue Jun 15 16:57:25 1999
 */
/* Compiler settings for mmc.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mmc_h__
#define __mmc_h__

/* Forward Declarations */ 

#ifndef __IComponentData_FWD_DEFINED__
#define __IComponentData_FWD_DEFINED__
typedef interface IComponentData IComponentData;
#endif 	/* __IComponentData_FWD_DEFINED__ */


#ifndef __IComponent_FWD_DEFINED__
#define __IComponent_FWD_DEFINED__
typedef interface IComponent IComponent;
#endif 	/* __IComponent_FWD_DEFINED__ */


#ifndef __IResultDataCompare_FWD_DEFINED__
#define __IResultDataCompare_FWD_DEFINED__
typedef interface IResultDataCompare IResultDataCompare;
#endif 	/* __IResultDataCompare_FWD_DEFINED__ */


#ifndef __IResultOwnerData_FWD_DEFINED__
#define __IResultOwnerData_FWD_DEFINED__
typedef interface IResultOwnerData IResultOwnerData;
#endif 	/* __IResultOwnerData_FWD_DEFINED__ */


#ifndef __IConsole_FWD_DEFINED__
#define __IConsole_FWD_DEFINED__
typedef interface IConsole IConsole;
#endif 	/* __IConsole_FWD_DEFINED__ */


#ifndef __IHeaderCtrl_FWD_DEFINED__
#define __IHeaderCtrl_FWD_DEFINED__
typedef interface IHeaderCtrl IHeaderCtrl;
#endif 	/* __IHeaderCtrl_FWD_DEFINED__ */


#ifndef __IContextMenuCallback_FWD_DEFINED__
#define __IContextMenuCallback_FWD_DEFINED__
typedef interface IContextMenuCallback IContextMenuCallback;
#endif 	/* __IContextMenuCallback_FWD_DEFINED__ */


#ifndef __IContextMenuProvider_FWD_DEFINED__
#define __IContextMenuProvider_FWD_DEFINED__
typedef interface IContextMenuProvider IContextMenuProvider;
#endif 	/* __IContextMenuProvider_FWD_DEFINED__ */


#ifndef __IExtendContextMenu_FWD_DEFINED__
#define __IExtendContextMenu_FWD_DEFINED__
typedef interface IExtendContextMenu IExtendContextMenu;
#endif 	/* __IExtendContextMenu_FWD_DEFINED__ */


#ifndef __IImageList_FWD_DEFINED__
#define __IImageList_FWD_DEFINED__
typedef interface IImageList IImageList;
#endif 	/* __IImageList_FWD_DEFINED__ */


#ifndef __IResultData_FWD_DEFINED__
#define __IResultData_FWD_DEFINED__
typedef interface IResultData IResultData;
#endif 	/* __IResultData_FWD_DEFINED__ */


#ifndef __IConsoleNameSpace_FWD_DEFINED__
#define __IConsoleNameSpace_FWD_DEFINED__
typedef interface IConsoleNameSpace IConsoleNameSpace;
#endif 	/* __IConsoleNameSpace_FWD_DEFINED__ */


#ifndef __IConsoleNameSpace2_FWD_DEFINED__
#define __IConsoleNameSpace2_FWD_DEFINED__
typedef interface IConsoleNameSpace2 IConsoleNameSpace2;
#endif 	/* __IConsoleNameSpace2_FWD_DEFINED__ */


#ifndef __IPropertySheetCallback_FWD_DEFINED__
#define __IPropertySheetCallback_FWD_DEFINED__
typedef interface IPropertySheetCallback IPropertySheetCallback;
#endif 	/* __IPropertySheetCallback_FWD_DEFINED__ */


#ifndef __IPropertySheetProvider_FWD_DEFINED__
#define __IPropertySheetProvider_FWD_DEFINED__
typedef interface IPropertySheetProvider IPropertySheetProvider;
#endif 	/* __IPropertySheetProvider_FWD_DEFINED__ */


#ifndef __IExtendPropertySheet_FWD_DEFINED__
#define __IExtendPropertySheet_FWD_DEFINED__
typedef interface IExtendPropertySheet IExtendPropertySheet;
#endif 	/* __IExtendPropertySheet_FWD_DEFINED__ */


#ifndef __IControlbar_FWD_DEFINED__
#define __IControlbar_FWD_DEFINED__
typedef interface IControlbar IControlbar;
#endif 	/* __IControlbar_FWD_DEFINED__ */


#ifndef __IExtendControlbar_FWD_DEFINED__
#define __IExtendControlbar_FWD_DEFINED__
typedef interface IExtendControlbar IExtendControlbar;
#endif 	/* __IExtendControlbar_FWD_DEFINED__ */


#ifndef __IToolbar_FWD_DEFINED__
#define __IToolbar_FWD_DEFINED__
typedef interface IToolbar IToolbar;
#endif 	/* __IToolbar_FWD_DEFINED__ */


#ifndef __IConsoleVerb_FWD_DEFINED__
#define __IConsoleVerb_FWD_DEFINED__
typedef interface IConsoleVerb IConsoleVerb;
#endif 	/* __IConsoleVerb_FWD_DEFINED__ */


#ifndef __ISnapinAbout_FWD_DEFINED__
#define __ISnapinAbout_FWD_DEFINED__
typedef interface ISnapinAbout ISnapinAbout;
#endif 	/* __ISnapinAbout_FWD_DEFINED__ */


#ifndef __IMenuButton_FWD_DEFINED__
#define __IMenuButton_FWD_DEFINED__
typedef interface IMenuButton IMenuButton;
#endif 	/* __IMenuButton_FWD_DEFINED__ */


#ifndef __ISnapinHelp_FWD_DEFINED__
#define __ISnapinHelp_FWD_DEFINED__
typedef interface ISnapinHelp ISnapinHelp;
#endif 	/* __ISnapinHelp_FWD_DEFINED__ */


#ifndef __IExtendPropertySheet2_FWD_DEFINED__
#define __IExtendPropertySheet2_FWD_DEFINED__
typedef interface IExtendPropertySheet2 IExtendPropertySheet2;
#endif 	/* __IExtendPropertySheet2_FWD_DEFINED__ */


#ifndef __IHeaderCtrl2_FWD_DEFINED__
#define __IHeaderCtrl2_FWD_DEFINED__
typedef interface IHeaderCtrl2 IHeaderCtrl2;
#endif 	/* __IHeaderCtrl2_FWD_DEFINED__ */


#ifndef __ISnapinHelp2_FWD_DEFINED__
#define __ISnapinHelp2_FWD_DEFINED__
typedef interface ISnapinHelp2 ISnapinHelp2;
#endif 	/* __ISnapinHelp2_FWD_DEFINED__ */


#ifndef __IEnumTASK_FWD_DEFINED__
#define __IEnumTASK_FWD_DEFINED__
typedef interface IEnumTASK IEnumTASK;
#endif 	/* __IEnumTASK_FWD_DEFINED__ */


#ifndef __IExtendTaskPad_FWD_DEFINED__
#define __IExtendTaskPad_FWD_DEFINED__
typedef interface IExtendTaskPad IExtendTaskPad;
#endif 	/* __IExtendTaskPad_FWD_DEFINED__ */


#ifndef __IConsole2_FWD_DEFINED__
#define __IConsole2_FWD_DEFINED__
typedef interface IConsole2 IConsole2;
#endif 	/* __IConsole2_FWD_DEFINED__ */


#ifndef __IDisplayHelp_FWD_DEFINED__
#define __IDisplayHelp_FWD_DEFINED__
typedef interface IDisplayHelp IDisplayHelp;
#endif 	/* __IDisplayHelp_FWD_DEFINED__ */


#ifndef __IRequiredExtensions_FWD_DEFINED__
#define __IRequiredExtensions_FWD_DEFINED__
typedef interface IRequiredExtensions IRequiredExtensions;
#endif 	/* __IRequiredExtensions_FWD_DEFINED__ */


#ifndef __IStringTable_FWD_DEFINED__
#define __IStringTable_FWD_DEFINED__
typedef interface IStringTable IStringTable;
#endif 	/* __IStringTable_FWD_DEFINED__ */


#ifndef __IColumnData_FWD_DEFINED__
#define __IColumnData_FWD_DEFINED__
typedef interface IColumnData IColumnData;
#endif 	/* __IColumnData_FWD_DEFINED__ */


#ifndef __IMessageView_FWD_DEFINED__
#define __IMessageView_FWD_DEFINED__
typedef interface IMessageView IMessageView;
#endif 	/* __IMessageView_FWD_DEFINED__ */


#ifndef __IResultDataCompareEx_FWD_DEFINED__
#define __IResultDataCompareEx_FWD_DEFINED__
typedef interface IResultDataCompareEx IResultDataCompareEx;
#endif 	/* __IResultDataCompareEx_FWD_DEFINED__ */


/* header files for imported files */
#include "basetsd.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_mmc_0000 */
/* [local] */ 

#ifndef MMC_VER
#define MMC_VER 0x0120
#endif













#if (MMC_VER >= 0x0110)





#endif // MMC_VER >= 0x0110
#if (MMC_VER >= 0x0120)


#endif // MMC_VER >= 0x0120









#if (MMC_VER >= 0x0110)





#endif // MMC_VER >= 0x0110
typedef IConsole __RPC_FAR *LPCONSOLE;

typedef IHeaderCtrl __RPC_FAR *LPHEADERCTRL;

typedef IToolbar __RPC_FAR *LPTOOLBAR;

typedef IImageList __RPC_FAR *LPIMAGELIST;

typedef IResultData __RPC_FAR *LPRESULTDATA;

typedef IConsoleNameSpace __RPC_FAR *LPCONSOLENAMESPACE;

typedef IPropertySheetProvider __RPC_FAR *LPPROPERTYSHEETPROVIDER;

typedef IPropertySheetCallback __RPC_FAR *LPPROPERTYSHEETCALLBACK;

typedef IContextMenuProvider __RPC_FAR *LPCONTEXTMENUPROVIDER;

typedef IContextMenuCallback __RPC_FAR *LPCONTEXTMENUCALLBACK;

typedef IControlbar __RPC_FAR *LPCONTROLBAR;

typedef IConsoleVerb __RPC_FAR *LPCONSOLEVERB;

typedef IMenuButton __RPC_FAR *LPMENUBUTTON;

#if (MMC_VER >= 0x0110)
typedef IConsole2 __RPC_FAR *LPCONSOLE2;

typedef IHeaderCtrl2 __RPC_FAR *LPHEADERCTRL2;

typedef IConsoleNameSpace2 __RPC_FAR *LPCONSOLENAMESPACE2;

typedef IDisplayHelp __RPC_FAR *LPDISPLAYHELP;

typedef IStringTable __RPC_FAR *LPSTRINGTABLE;

#endif // MMC_VER >= 0x0110
#if (MMC_VER >= 0x0120)
typedef IColumnData __RPC_FAR *LPCOLUMNDATA;

typedef IResultDataCompareEx __RPC_FAR *LPRESULTDATACOMPAREEX;

#endif // MMC_VER >= 0x0120
typedef IComponent __RPC_FAR *LPCOMPONENT;

typedef IComponentData __RPC_FAR *LPCOMPONENTDATA;

typedef IExtendPropertySheet __RPC_FAR *LPEXTENDPROPERTYSHEET;

typedef IExtendContextMenu __RPC_FAR *LPEXTENDCONTEXTMENU;

typedef IExtendControlbar __RPC_FAR *LPEXTENDCONTROLBAR;

typedef IResultDataCompare __RPC_FAR *LPRESULTDATACOMPARE;

typedef IResultOwnerData __RPC_FAR *LPRESULTOWNERDATA;

typedef ISnapinAbout __RPC_FAR *LPSNAPABOUT;

typedef ISnapinAbout __RPC_FAR *LPSNAPINABOUT;

typedef ISnapinHelp __RPC_FAR *LPSNAPHELP;

typedef ISnapinHelp __RPC_FAR *LPSNAPINHELP;

#if (MMC_VER >= 0x0110)
typedef IEnumTASK __RPC_FAR *LPENUMTASK;

typedef IExtendPropertySheet2 __RPC_FAR *LPEXTENDPROPERTYSHEET2;

typedef ISnapinHelp2 __RPC_FAR *LPSNAPINHELP2;

typedef IExtendTaskPad __RPC_FAR *LPEXTENDTASKPAD;

typedef IRequiredExtensions __RPC_FAR *LPREQUIREDEXTENSIONS;

#endif // MMC_VER >= 0x0110
#define	MMCLV_AUTO	( -1 )

#define	MMCLV_NOPARAM	( -2 )

#define	MMCLV_NOICON	( -1 )

#define	MMCLV_VIEWSTYLE_ICON	( 0 )

#define	MMCLV_VIEWSTYLE_SMALLICON	( 0x2 )

#define	MMCLV_VIEWSTYLE_LIST	( 0x3 )

#define	MMCLV_VIEWSTYLE_REPORT	( 0x1 )

#define	MMCLV_VIEWSTYLE_FILTERED	( 0x4 )

#define	MMCLV_NOPTR	( 0 )

#define	MMCLV_UPDATE_NOINVALIDATEALL	( 0x1 )

#define	MMCLV_UPDATE_NOSCROLL	( 0x2 )

static unsigned short __RPC_FAR *MMC_CALLBACK	=	( unsigned short __RPC_FAR * )-1;

#if (MMC_VER >= 0x0120)
#define MMC_IMAGECALLBACK (-1)
#define MMC_TEXTCALLBACK  MMC_CALLBACK
#endif // MMC_VER >= 0x0120
typedef LONG_PTR HSCOPEITEM;

typedef long COMPONENTID;

typedef LONG_PTR HRESULTITEM;

#define	RDI_STR	( 0x2 )

#define	RDI_IMAGE	( 0x4 )

#define	RDI_STATE	( 0x8 )

#define	RDI_PARAM	( 0x10 )

#define	RDI_INDEX	( 0x20 )

#define	RDI_INDENT	( 0x40 )

typedef enum _MMC_RESULT_VIEW_STYLE      
{                                        
    MMC_SINGLESEL           = 0x0001,    
    MMC_SHOWSELALWAYS       = 0x0002,    
    MMC_NOSORTHEADER        = 0x0004,    
#if (MMC_VER >= 0x0120)                  
    MMC_ENSUREFOCUSVISIBLE  = 0x0008     
#endif // MMC_VER >= 0x0120              
} MMC_RESULT_VIEW_STYLE;                 
#if 0
typedef 
enum _MMC_RESULT_VIEW_STYLE
    {	_MMC_VIEW_STYLE__dummy_	= 0
    }	MMC_RESULT_VIEW_STYLE;

#endif
#define	MMC_VIEW_OPTIONS_NONE	( 0 )

#define	MMC_VIEW_OPTIONS_NOLISTVIEWS	( 0x1 )

#define	MMC_VIEW_OPTIONS_MULTISELECT	( 0x2 )

#define	MMC_VIEW_OPTIONS_OWNERDATALIST	( 0x4 )

#define	MMC_VIEW_OPTIONS_FILTERED	( 0x8 )

#define	MMC_VIEW_OPTIONS_CREATENEW	( 0x10 )

#if (MMC_VER >= 0x0110)
#define	MMC_VIEW_OPTIONS_USEFONTLINKING	( 0x20 )

#endif // MMC_VER >= 0x0110
#if (MMC_VER >= 0x0120)
#define	MMC_VIEW_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST	( 0x40 )

#define	MMC_VIEW_OPTIONS_LEXICAL_SORT	( 0x80 )

#endif // MMC_VER >= 0x0120
#define	MMC_PSO_NOAPPLYNOW	( 0x1 )

#define	MMC_PSO_HASHELP	( 0x2 )

#define	MMC_PSO_NEWWIZARDTYPE	( 0x4 )

#define	MMC_PSO_NO_PROPTITLE	( 0x8 )

typedef 
enum _MMC_CONTROL_TYPE
    {	TOOLBAR	= 0,
	MENUBUTTON	= TOOLBAR + 1,
	COMBOBOXBAR	= MENUBUTTON + 1
    }	MMC_CONTROL_TYPE;

typedef enum _MMC_CONSOLE_VERB                               
{                                                            
    MMC_VERB_NONE            = 0x0000,                       
    MMC_VERB_OPEN            = 0x8000,                       
    MMC_VERB_COPY            = 0x8001,                       
    MMC_VERB_PASTE           = 0x8002,                       
    MMC_VERB_DELETE          = 0x8003,                       
    MMC_VERB_PROPERTIES      = 0x8004,                       
    MMC_VERB_RENAME          = 0x8005,                       
    MMC_VERB_REFRESH         = 0x8006,                       
    MMC_VERB_PRINT           = 0x8007,                       
#if (MMC_VER >= 0x0110)                                      
    MMC_VERB_CUT             = 0x8008,  // Used only to explicitly disable/hide
                                        // the cut verb, when copy & paste are enabled.
                                                             
    // must be last                                          
    MMC_VERB_MAX,                                            
    MMC_VERB_FIRST           = MMC_VERB_OPEN,                
    MMC_VERB_LAST            = MMC_VERB_MAX - 1              
#endif // MMC_VER >= 0x0110                                  
} MMC_CONSOLE_VERB;                                          
#if 0
typedef 
enum _MMC_CONSOLE_VERB
    {	MMC_VERB__dummy_	= 0
    }	MMC_CONSOLE_VERB;

#endif
#include <pshpack8.h>
typedef struct _MMCButton
    {
    int nBitmap;
    int idCommand;
    BYTE fsState;
    BYTE fsType;
    LPOLESTR lpButtonText;
    LPOLESTR lpTooltipText;
    }	MMCBUTTON;

#include <poppack.h>
typedef MMCBUTTON __RPC_FAR *LPMMCBUTTON;

typedef 
enum _MMC_BUTTON_STATE
    {	ENABLED	= 0x1,
	CHECKED	= 0x2,
	HIDDEN	= 0x4,
	INDETERMINATE	= 0x8,
	BUTTONPRESSED	= 0x10
    }	MMC_BUTTON_STATE;

typedef struct _RESULTDATAITEM
    {
    DWORD mask;
    BOOL bScopeItem;
    HRESULTITEM itemID;
    int nIndex;
    int nCol;
    LPOLESTR str;
    int nImage;
    UINT nState;
    LPARAM lParam;
    int iIndent;
    }	RESULTDATAITEM;

typedef RESULTDATAITEM __RPC_FAR *LPRESULTDATAITEM;

#define	RFI_PARTIAL	( 0x1 )

#define	RFI_WRAP	( 0x2 )

typedef struct _RESULTFINDINFO
    {
    LPOLESTR psz;
    int nStart;
    DWORD dwOptions;
    }	RESULTFINDINFO;

typedef RESULTFINDINFO __RPC_FAR *LPRESULTFINDINFO;

#define	RSI_DESCENDING	( 0x1 )

#define	SDI_STR	( 0x2 )

#define	SDI_IMAGE	( 0x4 )

#define	SDI_OPENIMAGE	( 0x8 )

#define	SDI_STATE	( 0x10 )

#define	SDI_PARAM	( 0x20 )

#define	SDI_CHILDREN	( 0x40 )

#define	SDI_PARENT	( 0 )

#define	SDI_PREVIOUS	( 0x10000000 )

#define	SDI_NEXT	( 0x20000000 )

#define	SDI_FIRST	( 0x8000000 )

typedef struct _SCOPEDATAITEM
    {
    DWORD mask;
    LPOLESTR displayname;
    int nImage;
    int nOpenImage;
    UINT nState;
    int cChildren;
    LPARAM lParam;
    HSCOPEITEM relativeID;
    HSCOPEITEM ID;
    }	SCOPEDATAITEM;

typedef SCOPEDATAITEM __RPC_FAR *LPSCOPEDATAITEM;

typedef 
enum _MMC_SCOPE_ITEM_STATE
    {	MMC_SCOPE_ITEM_STATE_NORMAL	= 0x1,
	MMC_SCOPE_ITEM_STATE_BOLD	= 0x2,
	MMC_SCOPE_ITEM_STATE_EXPANDEDONCE	= 0x3
    }	MMC_SCOPE_ITEM_STATE;

typedef struct _CONTEXTMENUITEM
    {
    LPWSTR strName;
    LPWSTR strStatusBarText;
    LONG lCommandID;
    LONG lInsertionPointID;
    LONG fFlags;
    LONG fSpecialFlags;
    }	CONTEXTMENUITEM;

typedef CONTEXTMENUITEM __RPC_FAR *LPCONTEXTMENUITEM;

typedef 
enum _MMC_MENU_COMMAND_IDS
    {	MMCC_STANDARD_VIEW_SELECT	= -1
    }	MMC_MENU_COMMAND_IDS;

typedef struct _MENUBUTTONDATA
    {
    int idCommand;
    int x;
    int y;
    }	MENUBUTTONDATA;

typedef MENUBUTTONDATA __RPC_FAR *LPMENUBUTTONDATA;

typedef LONG_PTR MMC_COOKIE;

#define	MMC_MULTI_SELECT_COOKIE	( -2 )

#define	MMC_WINDOW_COOKIE	( -3 )

#if (MMC_VER >= 0x0110)
#define	SPECIAL_COOKIE_MIN	( -10 )

#define	SPECIAL_COOKIE_MAX	( -1 )

typedef 
enum _MMC_FILTER_TYPE
    {	MMC_STRING_FILTER	= 0,
	MMC_INT_FILTER	= 0x1,
	MMC_FILTER_NOVALUE	= 0x8000
    }	MMC_FILTER_TYPE;

typedef struct _MMC_FILTERDATA
    {
    LPOLESTR pszText;
    INT cchTextMax;
    LONG lValue;
    }	MMC_FILTERDATA;

typedef 
enum _MMC_FILTER_CHANGE_CODE
    {	MFCC_DISABLE	= 0,
	MFCC_ENABLE	= 1,
	MFCC_VALUE_CHANGE	= 2
    }	MMC_FILTER_CHANGE_CODE;

typedef struct _MMC_RESTORE_VIEW
    {
    DWORD dwSize;
    MMC_COOKIE cookie;
    LPOLESTR pViewType;
    long lViewOptions;
    }	MMC_RESTORE_VIEW;

typedef struct _MMC_EXPANDSYNC_STRUCT
    {
    BOOL bHandled;
    BOOL bExpanding;
    HSCOPEITEM hItem;
    }	MMC_EXPANDSYNC_STRUCT;

#endif // MMC_VER >= 0x0110
#if (MMC_VER >= 0x0120)
typedef struct _MMC_VISIBLE_COLUMNS
    {
    INT nVisibleColumns;
    INT rgVisibleCols[ 1 ];
    }	MMC_VISIBLE_COLUMNS;

#endif // MMC_VER >= 0x0120
typedef enum _MMC_NOTIFY_TYPE                                
{                                                            
    MMCN_ACTIVATE           = 0x8001,                        
    MMCN_ADD_IMAGES         = 0x8002,                        
    MMCN_BTN_CLICK          = 0x8003,                        
    MMCN_CLICK              = 0x8004,   // NOT USED          
    MMCN_COLUMN_CLICK       = 0x8005,                        
    MMCN_CONTEXTMENU        = 0x8006,   // NOT USED          
    MMCN_CUTORMOVE          = 0x8007,                        
    MMCN_DBLCLICK           = 0x8008,                        
    MMCN_DELETE             = 0x8009,                        
    MMCN_DESELECT_ALL       = 0x800A,                        
    MMCN_EXPAND             = 0x800B,                        
    MMCN_HELP               = 0x800C,   // NOT USED          
    MMCN_MENU_BTNCLICK      = 0x800D,                        
    MMCN_MINIMIZED          = 0x800E,                        
    MMCN_PASTE              = 0x800F,                        
    MMCN_PROPERTY_CHANGE    = 0x8010,                        
    MMCN_QUERY_PASTE        = 0x8011,                        
    MMCN_REFRESH            = 0x8012,                        
    MMCN_REMOVE_CHILDREN    = 0x8013,                        
    MMCN_RENAME             = 0x8014,                        
    MMCN_SELECT             = 0x8015,                        
    MMCN_SHOW               = 0x8016,                        
    MMCN_VIEW_CHANGE        = 0x8017,                        
    MMCN_SNAPINHELP         = 0x8018,                        
    MMCN_CONTEXTHELP        = 0x8019,                        
    MMCN_INITOCX            = 0x801A,                        
#if (MMC_VER >= 0x0110)                                      
    MMCN_FILTER_CHANGE      = 0x801B,                        
    MMCN_FILTERBTN_CLICK    = 0x801C,                        
    MMCN_RESTORE_VIEW       = 0x801D,                        
    MMCN_PRINT              = 0x801E,                        
    MMCN_PRELOAD            = 0x801F,                        
    MMCN_LISTPAD            = 0x8020,                        
    MMCN_EXPANDSYNC         = 0x8021,                        
#if (MMC_VER >= 0x0120)                                      
    MMCN_COLUMNS_CHANGED    = 0x8022,                        
#endif // MMC_VER >= 0x0120                                  
#endif // MMC_VER >= 0x0110                                  
} MMC_NOTIFY_TYPE;                                           
#if 0
typedef 
enum _MMC_NOTIFY_TYPE
    {	MMCN__dummy_	= 0
    }	MMC_NOTIFY_TYPE;

#endif
typedef 
enum _DATA_OBJECT_TYPES
    {	CCT_SCOPE	= 0x8000,
	CCT_RESULT	= 0x8001,
	CCT_SNAPIN_MANAGER	= 0x8002,
	CCT_UNINITIALIZED	= 0xffff
    }	DATA_OBJECT_TYPES;

#define	MMC_NW_OPTION_NONE	( 0 )

#define	MMC_NW_OPTION_NOSCOPEPANE	( 0x1 )

#define	MMC_NW_OPTION_NOTOOLBARS	( 0x2 )

#define	MMC_NW_OPTION_SHORTTITLE	( 0x4 )

#define	MMC_NW_OPTION_CUSTOMTITLE	( 0x8 )

#define	MMC_NW_OPTION_NOPERSIST	( 0x10 )

#define	CCF_NODETYPE	( L"CCF_NODETYPE" )

#define	CCF_SZNODETYPE	( L"CCF_SZNODETYPE" )

#define	CCF_DISPLAY_NAME	( L"CCF_DISPLAY_NAME" )

#define	CCF_SNAPIN_CLASSID	( L"CCF_SNAPIN_CLASSID" )

#define	CCF_WINDOW_TITLE	( L"CCF_WINDOW_TITLE" )

#define	CCF_MMC_MULTISELECT_DATAOBJECT	( L"CCF_MMC_MULTISELECT_DATAOBJECT" )

typedef struct _SMMCDataObjects
    {
    DWORD count;
    LPDATAOBJECT lpDataObject[ 1 ];
    }	SMMCDataObjects;

#define	CCF_MULTI_SELECT_SNAPINS	( L"CCF_MULTI_SELECT_SNAPINS" )

typedef struct _SMMCObjectTypes
    {
    DWORD count;
    GUID guid[ 1 ];
    }	SMMCObjectTypes;

#define	CCF_OBJECT_TYPES_IN_MULTI_SELECT	( L"CCF_OBJECT_TYPES_IN_MULTI_SELECT" )

#if (MMC_VER >= 0x0110)
typedef SMMCObjectTypes SMMCDynamicExtensions;

#define	CCF_MMC_DYNAMIC_EXTENSIONS	( L"CCF_MMC_DYNAMIC_EXTENSIONS" )

#define	CCF_SNAPIN_PRELOADS	( L"CCF_SNAPIN_PRELOADS" )

typedef struct _SNodeID
    {
    DWORD cBytes;
    BYTE id[ 1 ];
    }	SNodeID;

#if (MMC_VER >= 0x0120)
typedef struct _SNodeID2
    {
    DWORD dwFlags;
    DWORD cBytes;
    BYTE id[ 1 ];
    }	SNodeID2;

#define	MMC_NODEID_SLOW_RETRIEVAL	( 0x1 )

#define	CCF_NODEID2	( L"CCF_NODEID2" )

#endif // MMC_VER >= 0x0120
#define	CCF_NODEID	( L"CCF_NODEID" )

#if (MMC_VER >= 0x0120)
typedef struct _SColumnSetID
    {
    DWORD dwFlags;
    DWORD cBytes;
    BYTE id[ 1 ];
    }	SColumnSetID;

#define	CCF_COLUMN_SET_ID	( L"CCF_COLUMN_SET_ID" )

#endif // MMC_VER >= 0x0120
#endif // MMC_VER >= 0x0110
STDAPI MMCPropertyChangeNotify(LONG_PTR lNotifyHandle, LPARAM param);
#if (MMC_VER >= 0x0110)
STDAPI MMCPropertyHelp(LPOLESTR pszHelpTopic);
#endif // MMC_VER >= 0x0110
STDAPI MMCFreeNotifyHandle(LONG_PTR lNotifyHandle);
STDAPI MMCPropPageCallback(void* vpsp);
EXTERN_C const CLSID CLSID_NodeManager;
#if (MMC_VER >= 0x0120)
EXTERN_C const CLSID CLSID_MessageView;
#endif // MMC_VER >= 0x0120
#define DOBJ_NULL        (LPDATAOBJECT)   0
#define DOBJ_CUSTOMOCX   (LPDATAOBJECT)  -1
#define DOBJ_CUSTOMWEB   (LPDATAOBJECT)  -2
#if (MMC_VER >= 0x0110)
#if (MMC_VER >= 0x0120)
#define DOBJ_NOCONSOLE   (LPDATAOBJECT)  -3
#endif // MMC_VER >= 0x0120
#define SPECIAL_DOBJ_MIN                -10
#define SPECIAL_DOBJ_MAX                  0
#endif // MMC_VER >= 0x0110
#define IS_SPECIAL_DATAOBJECT(d) (((LONG_PTR)(d) >= SPECIAL_DOBJ_MIN)   && ((LONG_PTR)(d) <= SPECIAL_DOBJ_MAX))
#define IS_SPECIAL_COOKIE(c)     (((c)          >= SPECIAL_COOKIE_MIN) && ((c)          <= SPECIAL_COOKIE_MAX))


extern RPC_IF_HANDLE __MIDL_itf_mmc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0000_v0_0_s_ifspec;

#ifndef __IComponentData_INTERFACE_DEFINED__
#define __IComponentData_INTERFACE_DEFINED__

/* interface IComponentData */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IComponentData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("955AB28A-5218-11D0-A985-00C04FD8D565")
    IComponentData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPUNKNOWN pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
            /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponentData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponentData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ LPUNKNOWN pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateComponent )( 
            IComponentData __RPC_FAR * This,
            /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IComponentData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryDataObject )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayInfo )( 
            IComponentData __RPC_FAR * This,
            /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareObjects )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        END_INTERFACE
    } IComponentDataVtbl;

    interface IComponentData
    {
        CONST_VTBL struct IComponentDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponentData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponentData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponentData_Initialize(This,pUnknown)	\
    (This)->lpVtbl -> Initialize(This,pUnknown)

#define IComponentData_CreateComponent(This,ppComponent)	\
    (This)->lpVtbl -> CreateComponent(This,ppComponent)

#define IComponentData_Notify(This,lpDataObject,event,arg,param)	\
    (This)->lpVtbl -> Notify(This,lpDataObject,event,arg,param)

#define IComponentData_Destroy(This)	\
    (This)->lpVtbl -> Destroy(This)

#define IComponentData_QueryDataObject(This,cookie,type,ppDataObject)	\
    (This)->lpVtbl -> QueryDataObject(This,cookie,type,ppDataObject)

#define IComponentData_GetDisplayInfo(This,pScopeDataItem)	\
    (This)->lpVtbl -> GetDisplayInfo(This,pScopeDataItem)

#define IComponentData_CompareObjects(This,lpDataObjectA,lpDataObjectB)	\
    (This)->lpVtbl -> CompareObjects(This,lpDataObjectA,lpDataObjectB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_Initialize_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ LPUNKNOWN pUnknown);


void __RPC_STUB IComponentData_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_CreateComponent_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);


void __RPC_STUB IComponentData_CreateComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_Notify_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ LPARAM arg,
    /* [in] */ LPARAM param);


void __RPC_STUB IComponentData_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_Destroy_Proxy( 
    IComponentData __RPC_FAR * This);


void __RPC_STUB IComponentData_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_QueryDataObject_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ MMC_COOKIE cookie,
    /* [in] */ DATA_OBJECT_TYPES type,
    /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);


void __RPC_STUB IComponentData_QueryDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_GetDisplayInfo_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);


void __RPC_STUB IComponentData_GetDisplayInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_CompareObjects_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObjectA,
    /* [in] */ LPDATAOBJECT lpDataObjectB);


void __RPC_STUB IComponentData_CompareObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponentData_INTERFACE_DEFINED__ */


#ifndef __IComponent_INTERFACE_DEFINED__
#define __IComponent_INTERFACE_DEFINED__

/* interface IComponent */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB2-D36C-11CF-ADBC-00AA00A80033")
    IComponent : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponent __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IComponent __RPC_FAR * This,
            /* [in] */ LPCONSOLE lpConsole);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IComponent __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IComponent __RPC_FAR * This,
            /* [in] */ MMC_COOKIE cookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryDataObject )( 
            IComponent __RPC_FAR * This,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultViewType )( 
            IComponent __RPC_FAR * This,
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayInfo )( 
            IComponent __RPC_FAR * This,
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareObjects )( 
            IComponent __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        END_INTERFACE
    } IComponentVtbl;

    interface IComponent
    {
        CONST_VTBL struct IComponentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponent_Initialize(This,lpConsole)	\
    (This)->lpVtbl -> Initialize(This,lpConsole)

#define IComponent_Notify(This,lpDataObject,event,arg,param)	\
    (This)->lpVtbl -> Notify(This,lpDataObject,event,arg,param)

#define IComponent_Destroy(This,cookie)	\
    (This)->lpVtbl -> Destroy(This,cookie)

#define IComponent_QueryDataObject(This,cookie,type,ppDataObject)	\
    (This)->lpVtbl -> QueryDataObject(This,cookie,type,ppDataObject)

#define IComponent_GetResultViewType(This,cookie,ppViewType,pViewOptions)	\
    (This)->lpVtbl -> GetResultViewType(This,cookie,ppViewType,pViewOptions)

#define IComponent_GetDisplayInfo(This,pResultDataItem)	\
    (This)->lpVtbl -> GetDisplayInfo(This,pResultDataItem)

#define IComponent_CompareObjects(This,lpDataObjectA,lpDataObjectB)	\
    (This)->lpVtbl -> CompareObjects(This,lpDataObjectA,lpDataObjectB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_Initialize_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ LPCONSOLE lpConsole);


void __RPC_STUB IComponent_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_Notify_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ LPARAM arg,
    /* [in] */ LPARAM param);


void __RPC_STUB IComponent_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_Destroy_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ MMC_COOKIE cookie);


void __RPC_STUB IComponent_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_QueryDataObject_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ MMC_COOKIE cookie,
    /* [in] */ DATA_OBJECT_TYPES type,
    /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);


void __RPC_STUB IComponent_QueryDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_GetResultViewType_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ MMC_COOKIE cookie,
    /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
    /* [out] */ long __RPC_FAR *pViewOptions);


void __RPC_STUB IComponent_GetResultViewType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_GetDisplayInfo_Proxy( 
    IComponent __RPC_FAR * This,
    /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);


void __RPC_STUB IComponent_GetDisplayInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_CompareObjects_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObjectA,
    /* [in] */ LPDATAOBJECT lpDataObjectB);


void __RPC_STUB IComponent_CompareObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponent_INTERFACE_DEFINED__ */


#ifndef __IResultDataCompare_INTERFACE_DEFINED__
#define __IResultDataCompare_INTERFACE_DEFINED__

/* interface IResultDataCompare */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IResultDataCompare;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E8315A52-7A1A-11D0-A2D2-00C04FD909DD")
    IResultDataCompare : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ LPARAM lUserParam,
            /* [in] */ MMC_COOKIE cookieA,
            /* [in] */ MMC_COOKIE cookieB,
            /* [out][in] */ int __RPC_FAR *pnResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultDataCompareVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultDataCompare __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultDataCompare __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultDataCompare __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Compare )( 
            IResultDataCompare __RPC_FAR * This,
            /* [in] */ LPARAM lUserParam,
            /* [in] */ MMC_COOKIE cookieA,
            /* [in] */ MMC_COOKIE cookieB,
            /* [out][in] */ int __RPC_FAR *pnResult);
        
        END_INTERFACE
    } IResultDataCompareVtbl;

    interface IResultDataCompare
    {
        CONST_VTBL struct IResultDataCompareVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultDataCompare_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultDataCompare_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultDataCompare_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultDataCompare_Compare(This,lUserParam,cookieA,cookieB,pnResult)	\
    (This)->lpVtbl -> Compare(This,lUserParam,cookieA,cookieB,pnResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataCompare_Compare_Proxy( 
    IResultDataCompare __RPC_FAR * This,
    /* [in] */ LPARAM lUserParam,
    /* [in] */ MMC_COOKIE cookieA,
    /* [in] */ MMC_COOKIE cookieB,
    /* [out][in] */ int __RPC_FAR *pnResult);


void __RPC_STUB IResultDataCompare_Compare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultDataCompare_INTERFACE_DEFINED__ */


#ifndef __IResultOwnerData_INTERFACE_DEFINED__
#define __IResultOwnerData_INTERFACE_DEFINED__

/* interface IResultOwnerData */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IResultOwnerData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9CB396D8-EA83-11d0-AEF1-00C04FB6DD2C")
    IResultOwnerData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItem( 
            /* [in] */ LPRESULTFINDINFO pFindInfo,
            /* [out] */ int __RPC_FAR *pnFoundIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CacheHint( 
            /* [in] */ int nStartIndex,
            /* [in] */ int nEndIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SortItems( 
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultOwnerDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultOwnerData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultOwnerData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItem )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ LPRESULTFINDINFO pFindInfo,
            /* [out] */ int __RPC_FAR *pnFoundIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CacheHint )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ int nStartIndex,
            /* [in] */ int nEndIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SortItems )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam);
        
        END_INTERFACE
    } IResultOwnerDataVtbl;

    interface IResultOwnerData
    {
        CONST_VTBL struct IResultOwnerDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultOwnerData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultOwnerData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultOwnerData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultOwnerData_FindItem(This,pFindInfo,pnFoundIndex)	\
    (This)->lpVtbl -> FindItem(This,pFindInfo,pnFoundIndex)

#define IResultOwnerData_CacheHint(This,nStartIndex,nEndIndex)	\
    (This)->lpVtbl -> CacheHint(This,nStartIndex,nEndIndex)

#define IResultOwnerData_SortItems(This,nColumn,dwSortOptions,lUserParam)	\
    (This)->lpVtbl -> SortItems(This,nColumn,dwSortOptions,lUserParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultOwnerData_FindItem_Proxy( 
    IResultOwnerData __RPC_FAR * This,
    /* [in] */ LPRESULTFINDINFO pFindInfo,
    /* [out] */ int __RPC_FAR *pnFoundIndex);


void __RPC_STUB IResultOwnerData_FindItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultOwnerData_CacheHint_Proxy( 
    IResultOwnerData __RPC_FAR * This,
    /* [in] */ int nStartIndex,
    /* [in] */ int nEndIndex);


void __RPC_STUB IResultOwnerData_CacheHint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultOwnerData_SortItems_Proxy( 
    IResultOwnerData __RPC_FAR * This,
    /* [in] */ int nColumn,
    /* [in] */ DWORD dwSortOptions,
    /* [in] */ LPARAM lUserParam);


void __RPC_STUB IResultOwnerData_SortItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultOwnerData_INTERFACE_DEFINED__ */


#ifndef __IConsole_INTERFACE_DEFINED__
#define __IConsole_INTERFACE_DEFINED__

/* interface IConsole */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IConsole;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB1-D36C-11CF-ADBC-00AA00A80033")
    IConsole : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetHeader( 
            /* [in] */ LPHEADERCTRL pHeader) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetToolbar( 
            /* [in] */ LPTOOLBAR pToolbar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryResultView( 
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryScopeImageList( 
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryResultImageList( 
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UpdateAllViews( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ LPARAM data,
            /* [in] */ LONG_PTR hint) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MessageBox( 
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryConsoleVerb( 
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SelectScopeItem( 
            /* [in] */ HSCOPEITEM hScopeItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMainWindow( 
            /* [out] */ HWND __RPC_FAR *phwnd) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NewWindow( 
            /* [in] */ HSCOPEITEM hScopeItem,
            /* [in] */ unsigned long lOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsole __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsole __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHeader )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPHEADERCTRL pHeader);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetToolbar )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPTOOLBAR pToolbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultView )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryScopeImageList )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultImageList )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateAllViews )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ LPARAM data,
            /* [in] */ LONG_PTR hint);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MessageBox )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryConsoleVerb )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectScopeItem )( 
            IConsole __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMainWindow )( 
            IConsole __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IConsole __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem,
            /* [in] */ unsigned long lOptions);
        
        END_INTERFACE
    } IConsoleVtbl;

    interface IConsole
    {
        CONST_VTBL struct IConsoleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsole_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsole_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsole_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsole_SetHeader(This,pHeader)	\
    (This)->lpVtbl -> SetHeader(This,pHeader)

#define IConsole_SetToolbar(This,pToolbar)	\
    (This)->lpVtbl -> SetToolbar(This,pToolbar)

#define IConsole_QueryResultView(This,pUnknown)	\
    (This)->lpVtbl -> QueryResultView(This,pUnknown)

#define IConsole_QueryScopeImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryScopeImageList(This,ppImageList)

#define IConsole_QueryResultImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryResultImageList(This,ppImageList)

#define IConsole_UpdateAllViews(This,lpDataObject,data,hint)	\
    (This)->lpVtbl -> UpdateAllViews(This,lpDataObject,data,hint)

#define IConsole_MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)	\
    (This)->lpVtbl -> MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)

#define IConsole_QueryConsoleVerb(This,ppConsoleVerb)	\
    (This)->lpVtbl -> QueryConsoleVerb(This,ppConsoleVerb)

#define IConsole_SelectScopeItem(This,hScopeItem)	\
    (This)->lpVtbl -> SelectScopeItem(This,hScopeItem)

#define IConsole_GetMainWindow(This,phwnd)	\
    (This)->lpVtbl -> GetMainWindow(This,phwnd)

#define IConsole_NewWindow(This,hScopeItem,lOptions)	\
    (This)->lpVtbl -> NewWindow(This,hScopeItem,lOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_SetHeader_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPHEADERCTRL pHeader);


void __RPC_STUB IConsole_SetHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_SetToolbar_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPTOOLBAR pToolbar);


void __RPC_STUB IConsole_SetToolbar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryResultView_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);


void __RPC_STUB IConsole_QueryResultView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryScopeImageList_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);


void __RPC_STUB IConsole_QueryScopeImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryResultImageList_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);


void __RPC_STUB IConsole_QueryResultImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_UpdateAllViews_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ LPARAM data,
    /* [in] */ LONG_PTR hint);


void __RPC_STUB IConsole_UpdateAllViews_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_MessageBox_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPCWSTR lpszText,
    /* [in] */ LPCWSTR lpszTitle,
    /* [in] */ UINT fuStyle,
    /* [out] */ int __RPC_FAR *piRetval);


void __RPC_STUB IConsole_MessageBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryConsoleVerb_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);


void __RPC_STUB IConsole_QueryConsoleVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_SelectScopeItem_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hScopeItem);


void __RPC_STUB IConsole_SelectScopeItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_GetMainWindow_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ HWND __RPC_FAR *phwnd);


void __RPC_STUB IConsole_GetMainWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_NewWindow_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hScopeItem,
    /* [in] */ unsigned long lOptions);


void __RPC_STUB IConsole_NewWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsole_INTERFACE_DEFINED__ */


#ifndef __IHeaderCtrl_INTERFACE_DEFINED__
#define __IHeaderCtrl_INTERFACE_DEFINED__

/* interface IHeaderCtrl */
/* [unique][helpstring][uuid][object] */ 

#define	AUTO_WIDTH	( -1 )

#if (MMC_VER >= 0x0120)
#define	HIDE_COLUMN	( -4 )

#endif // MMC_VER >= 0x0120

EXTERN_C const IID IID_IHeaderCtrl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB3-D36C-11CF-ADBC-00AA00A80033")
    IHeaderCtrl : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertColumn( 
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title,
            /* [in] */ int nFormat,
            /* [in] */ int nWidth) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteColumn( 
            /* [in] */ int nCol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnText( 
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnText( 
            /* [in] */ int nCol,
            /* [out] */ LPOLESTR __RPC_FAR *pText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnWidth( 
            /* [in] */ int nCol,
            /* [in] */ int nWidth) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnWidth( 
            /* [in] */ int nCol,
            /* [out] */ int __RPC_FAR *pWidth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeaderCtrlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHeaderCtrl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHeaderCtrl __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertColumn )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title,
            /* [in] */ int nFormat,
            /* [in] */ int nWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteColumn )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnText )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnText )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out] */ LPOLESTR __RPC_FAR *pText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnWidth )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ int nWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnWidth )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out] */ int __RPC_FAR *pWidth);
        
        END_INTERFACE
    } IHeaderCtrlVtbl;

    interface IHeaderCtrl
    {
        CONST_VTBL struct IHeaderCtrlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeaderCtrl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeaderCtrl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeaderCtrl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeaderCtrl_InsertColumn(This,nCol,title,nFormat,nWidth)	\
    (This)->lpVtbl -> InsertColumn(This,nCol,title,nFormat,nWidth)

#define IHeaderCtrl_DeleteColumn(This,nCol)	\
    (This)->lpVtbl -> DeleteColumn(This,nCol)

#define IHeaderCtrl_SetColumnText(This,nCol,title)	\
    (This)->lpVtbl -> SetColumnText(This,nCol,title)

#define IHeaderCtrl_GetColumnText(This,nCol,pText)	\
    (This)->lpVtbl -> GetColumnText(This,nCol,pText)

#define IHeaderCtrl_SetColumnWidth(This,nCol,nWidth)	\
    (This)->lpVtbl -> SetColumnWidth(This,nCol,nWidth)

#define IHeaderCtrl_GetColumnWidth(This,nCol,pWidth)	\
    (This)->lpVtbl -> GetColumnWidth(This,nCol,pWidth)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_InsertColumn_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ LPCWSTR title,
    /* [in] */ int nFormat,
    /* [in] */ int nWidth);


void __RPC_STUB IHeaderCtrl_InsertColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_DeleteColumn_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol);


void __RPC_STUB IHeaderCtrl_DeleteColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_SetColumnText_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ LPCWSTR title);


void __RPC_STUB IHeaderCtrl_SetColumnText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_GetColumnText_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [out] */ LPOLESTR __RPC_FAR *pText);


void __RPC_STUB IHeaderCtrl_GetColumnText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_SetColumnWidth_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ int nWidth);


void __RPC_STUB IHeaderCtrl_SetColumnWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_GetColumnWidth_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [out] */ int __RPC_FAR *pWidth);


void __RPC_STUB IHeaderCtrl_GetColumnWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHeaderCtrl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0112 */
/* [local] */ 


enum __MIDL___MIDL_itf_mmc_0112_0001
    {	CCM_INSERTIONPOINTID_MASK_SPECIAL	= 0xffff0000,
	CCM_INSERTIONPOINTID_MASK_SHARED	= 0x80000000,
	CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY	= 0x40000000,
	CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY	= 0x20000000,
	CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY	= 0x10000000,
	CCM_INSERTIONPOINTID_MASK_RESERVED	= 0xfff0000,
	CCM_INSERTIONPOINTID_MASK_FLAGINDEX	= 0x1f,
	CCM_INSERTIONPOINTID_PRIMARY_TOP	= 0xa0000000,
	CCM_INSERTIONPOINTID_PRIMARY_NEW	= 0xa0000001,
	CCM_INSERTIONPOINTID_PRIMARY_TASK	= 0xa0000002,
	CCM_INSERTIONPOINTID_PRIMARY_VIEW	= 0xa0000003,
	CCM_INSERTIONPOINTID_3RDPARTY_NEW	= 0x90000001,
	CCM_INSERTIONPOINTID_3RDPARTY_TASK	= 0x90000002,
	CCM_INSERTIONPOINTID_ROOT_MENU	= 0x80000000
    };

enum __MIDL___MIDL_itf_mmc_0112_0002
    {	CCM_INSERTIONALLOWED_TOP	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_TOP & CCM_INSERTIONPOINTID_MASK_FLAGINDEX),
	CCM_INSERTIONALLOWED_NEW	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_NEW & CCM_INSERTIONPOINTID_MASK_FLAGINDEX),
	CCM_INSERTIONALLOWED_TASK	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_TASK & CCM_INSERTIONPOINTID_MASK_FLAGINDEX),
	CCM_INSERTIONALLOWED_VIEW	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_VIEW & CCM_INSERTIONPOINTID_MASK_FLAGINDEX)
    };

enum __MIDL___MIDL_itf_mmc_0112_0003
    {	CCM_COMMANDID_MASK_RESERVED	= 0xffff0000
    };

enum __MIDL___MIDL_itf_mmc_0112_0004
    {	CCM_SPECIAL_SEPARATOR	= 0x1,
	CCM_SPECIAL_SUBMENU	= 0x2,
	CCM_SPECIAL_DEFAULT_ITEM	= 0x4,
	CCM_SPECIAL_INSERTION_POINT	= 0x8,
	CCM_SPECIAL_TESTONLY	= 0x10
    };


extern RPC_IF_HANDLE __MIDL_itf_mmc_0112_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0112_v0_0_s_ifspec;

#ifndef __IContextMenuCallback_INTERFACE_DEFINED__
#define __IContextMenuCallback_INTERFACE_DEFINED__

/* interface IContextMenuCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IContextMenuCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB7-D36C-11CF-ADBC-00AA00A80033")
    IContextMenuCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextMenuCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextMenuCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextMenuCallback __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            IContextMenuCallback __RPC_FAR * This,
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);
        
        END_INTERFACE
    } IContextMenuCallbackVtbl;

    interface IContextMenuCallback
    {
        CONST_VTBL struct IContextMenuCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMenuCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextMenuCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextMenuCallback_AddItem(This,pItem)	\
    (This)->lpVtbl -> AddItem(This,pItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuCallback_AddItem_Proxy( 
    IContextMenuCallback __RPC_FAR * This,
    /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);


void __RPC_STUB IContextMenuCallback_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextMenuCallback_INTERFACE_DEFINED__ */


#ifndef __IContextMenuProvider_INTERFACE_DEFINED__
#define __IContextMenuProvider_INTERFACE_DEFINED__

/* interface IContextMenuProvider */
/* [unique][helpstring][object][uuid][object] */ 


EXTERN_C const IID IID_IContextMenuProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB6-D36C-11CF-ADBC-00AA00A80033")
    IContextMenuProvider : public IContextMenuCallback
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EmptyMenuList( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPrimaryExtensionItems( 
            /* [in] */ LPUNKNOWN piExtension,
            /* [in] */ LPDATAOBJECT piDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddThirdPartyExtensionItems( 
            /* [in] */ LPDATAOBJECT piDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowContextMenu( 
            /* [in] */ HWND hwndParent,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [retval][out] */ long __RPC_FAR *plSelected) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextMenuProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextMenuProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmptyMenuList )( 
            IContextMenuProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryExtensionItems )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ LPUNKNOWN piExtension,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddThirdPartyExtensionItems )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowContextMenu )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [retval][out] */ long __RPC_FAR *plSelected);
        
        END_INTERFACE
    } IContextMenuProviderVtbl;

    interface IContextMenuProvider
    {
        CONST_VTBL struct IContextMenuProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMenuProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextMenuProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextMenuProvider_AddItem(This,pItem)	\
    (This)->lpVtbl -> AddItem(This,pItem)


#define IContextMenuProvider_EmptyMenuList(This)	\
    (This)->lpVtbl -> EmptyMenuList(This)

#define IContextMenuProvider_AddPrimaryExtensionItems(This,piExtension,piDataObject)	\
    (This)->lpVtbl -> AddPrimaryExtensionItems(This,piExtension,piDataObject)

#define IContextMenuProvider_AddThirdPartyExtensionItems(This,piDataObject)	\
    (This)->lpVtbl -> AddThirdPartyExtensionItems(This,piDataObject)

#define IContextMenuProvider_ShowContextMenu(This,hwndParent,xPos,yPos,plSelected)	\
    (This)->lpVtbl -> ShowContextMenu(This,hwndParent,xPos,yPos,plSelected)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_EmptyMenuList_Proxy( 
    IContextMenuProvider __RPC_FAR * This);


void __RPC_STUB IContextMenuProvider_EmptyMenuList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_AddPrimaryExtensionItems_Proxy( 
    IContextMenuProvider __RPC_FAR * This,
    /* [in] */ LPUNKNOWN piExtension,
    /* [in] */ LPDATAOBJECT piDataObject);


void __RPC_STUB IContextMenuProvider_AddPrimaryExtensionItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_AddThirdPartyExtensionItems_Proxy( 
    IContextMenuProvider __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT piDataObject);


void __RPC_STUB IContextMenuProvider_AddThirdPartyExtensionItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_ShowContextMenu_Proxy( 
    IContextMenuProvider __RPC_FAR * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ long xPos,
    /* [in] */ long yPos,
    /* [retval][out] */ long __RPC_FAR *plSelected);


void __RPC_STUB IContextMenuProvider_ShowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextMenuProvider_INTERFACE_DEFINED__ */


#ifndef __IExtendContextMenu_INTERFACE_DEFINED__
#define __IExtendContextMenu_INTERFACE_DEFINED__

/* interface IExtendContextMenu */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IExtendContextMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F3B7A4F-CFAC-11CF-B8E3-00C04FD8D5B0")
    IExtendContextMenu : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
            /* [in] */ LPDATAOBJECT piDataObject,
            /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
            /* [out][in] */ long __RPC_FAR *pInsertionAllowed) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
            /* [in] */ long lCommandID,
            /* [in] */ LPDATAOBJECT piDataObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendContextMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendContextMenu __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendContextMenu __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendContextMenu __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMenuItems )( 
            IExtendContextMenu __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT piDataObject,
            /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
            /* [out][in] */ long __RPC_FAR *pInsertionAllowed);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Command )( 
            IExtendContextMenu __RPC_FAR * This,
            /* [in] */ long lCommandID,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        END_INTERFACE
    } IExtendContextMenuVtbl;

    interface IExtendContextMenu
    {
        CONST_VTBL struct IExtendContextMenuVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendContextMenu_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendContextMenu_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendContextMenu_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendContextMenu_AddMenuItems(This,piDataObject,piCallback,pInsertionAllowed)	\
    (This)->lpVtbl -> AddMenuItems(This,piDataObject,piCallback,pInsertionAllowed)

#define IExtendContextMenu_Command(This,lCommandID,piDataObject)	\
    (This)->lpVtbl -> Command(This,lCommandID,piDataObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendContextMenu_AddMenuItems_Proxy( 
    IExtendContextMenu __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT piDataObject,
    /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
    /* [out][in] */ long __RPC_FAR *pInsertionAllowed);


void __RPC_STUB IExtendContextMenu_AddMenuItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendContextMenu_Command_Proxy( 
    IExtendContextMenu __RPC_FAR * This,
    /* [in] */ long lCommandID,
    /* [in] */ LPDATAOBJECT piDataObject);


void __RPC_STUB IExtendContextMenu_Command_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendContextMenu_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0115 */
/* [local] */ 

#if (MMC_VER >= 0x0120)
#define ILSIF_LEAVE_LARGE_ICON  0x40000000
#define ILSIF_LEAVE_SMALL_ICON  0x20000000
#define ILSIF_LEAVE_MASK        (ILSIF_LEAVE_LARGE_ICON | ILSIF_LEAVE_SMALL_ICON)
#define ILSI_LARGE_ICON(nLoc)   (nLoc | ILSIF_LEAVE_SMALL_ICON)
#define ILSI_SMALL_ICON(nLoc)   (nLoc | ILSIF_LEAVE_LARGE_ICON)
#endif // MMC_VER >= 0x0120


extern RPC_IF_HANDLE __MIDL_itf_mmc_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0115_v0_0_s_ifspec;

#ifndef __IImageList_INTERFACE_DEFINED__
#define __IImageList_INTERFACE_DEFINED__

/* interface IImageList */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IImageList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB8-D36C-11CF-ADBC-00AA00A80033")
    IImageList : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ImageListSetIcon( 
            /* [in] */ LONG_PTR __RPC_FAR *pIcon,
            /* [in] */ long nLoc) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ImageListSetStrip( 
            /* [in] */ LONG_PTR __RPC_FAR *pBMapSm,
            /* [in] */ LONG_PTR __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ COLORREF cMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImageList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImageList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImageList __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetIcon )( 
            IImageList __RPC_FAR * This,
            /* [in] */ LONG_PTR __RPC_FAR *pIcon,
            /* [in] */ long nLoc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetStrip )( 
            IImageList __RPC_FAR * This,
            /* [in] */ LONG_PTR __RPC_FAR *pBMapSm,
            /* [in] */ LONG_PTR __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ COLORREF cMask);
        
        END_INTERFACE
    } IImageListVtbl;

    interface IImageList
    {
        CONST_VTBL struct IImageListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageList_ImageListSetIcon(This,pIcon,nLoc)	\
    (This)->lpVtbl -> ImageListSetIcon(This,pIcon,nLoc)

#define IImageList_ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)	\
    (This)->lpVtbl -> ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IImageList_ImageListSetIcon_Proxy( 
    IImageList __RPC_FAR * This,
    /* [in] */ LONG_PTR __RPC_FAR *pIcon,
    /* [in] */ long nLoc);


void __RPC_STUB IImageList_ImageListSetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IImageList_ImageListSetStrip_Proxy( 
    IImageList __RPC_FAR * This,
    /* [in] */ LONG_PTR __RPC_FAR *pBMapSm,
    /* [in] */ LONG_PTR __RPC_FAR *pBMapLg,
    /* [in] */ long nStartLoc,
    /* [in] */ COLORREF cMask);


void __RPC_STUB IImageList_ImageListSetStrip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageList_INTERFACE_DEFINED__ */


#ifndef __IResultData_INTERFACE_DEFINED__
#define __IResultData_INTERFACE_DEFINED__

/* interface IResultData */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IResultData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31DA5FA0-E0EB-11cf-9F21-00AA003CA9F6")
    IResultData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [out][in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ int nCol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItemByLParam( 
            /* [in] */ LPARAM lParam,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteAllRsltItems( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItem( 
            /* [in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItem( 
            /* [out][in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [out][in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ModifyItemState( 
            /* [in] */ int nIndex,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ UINT uAdd,
            /* [in] */ UINT uRemove) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ModifyViewStyle( 
            /* [in] */ MMC_RESULT_VIEW_STYLE add,
            /* [in] */ MMC_RESULT_VIEW_STYLE remove) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetViewMode( 
            /* [in] */ long lViewMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetViewMode( 
            /* [out] */ long __RPC_FAR *lViewMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UpdateItem( 
            /* [in] */ HRESULTITEM itemID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Sort( 
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDescBarText( 
            /* [in] */ LPOLESTR DescText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItemCount( 
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IResultData __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IResultData __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByLParam )( 
            IResultData __RPC_FAR * This,
            /* [in] */ LPARAM lParam,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllRsltItems )( 
            IResultData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IResultData __RPC_FAR * This,
            /* [in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IResultData __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IResultData __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyItemState )( 
            IResultData __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ UINT uAdd,
            /* [in] */ UINT uRemove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyViewStyle )( 
            IResultData __RPC_FAR * This,
            /* [in] */ MMC_RESULT_VIEW_STYLE add,
            /* [in] */ MMC_RESULT_VIEW_STYLE remove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetViewMode )( 
            IResultData __RPC_FAR * This,
            /* [in] */ long lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetViewMode )( 
            IResultData __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateItem )( 
            IResultData __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sort )( 
            IResultData __RPC_FAR * This,
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescBarText )( 
            IResultData __RPC_FAR * This,
            /* [in] */ LPOLESTR DescText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemCount )( 
            IResultData __RPC_FAR * This,
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions);
        
        END_INTERFACE
    } IResultDataVtbl;

    interface IResultData
    {
        CONST_VTBL struct IResultDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultData_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IResultData_DeleteItem(This,itemID,nCol)	\
    (This)->lpVtbl -> DeleteItem(This,itemID,nCol)

#define IResultData_FindItemByLParam(This,lParam,pItemID)	\
    (This)->lpVtbl -> FindItemByLParam(This,lParam,pItemID)

#define IResultData_DeleteAllRsltItems(This)	\
    (This)->lpVtbl -> DeleteAllRsltItems(This)

#define IResultData_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IResultData_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IResultData_GetNextItem(This,item)	\
    (This)->lpVtbl -> GetNextItem(This,item)

#define IResultData_ModifyItemState(This,nIndex,itemID,uAdd,uRemove)	\
    (This)->lpVtbl -> ModifyItemState(This,nIndex,itemID,uAdd,uRemove)

#define IResultData_ModifyViewStyle(This,add,remove)	\
    (This)->lpVtbl -> ModifyViewStyle(This,add,remove)

#define IResultData_SetViewMode(This,lViewMode)	\
    (This)->lpVtbl -> SetViewMode(This,lViewMode)

#define IResultData_GetViewMode(This,lViewMode)	\
    (This)->lpVtbl -> GetViewMode(This,lViewMode)

#define IResultData_UpdateItem(This,itemID)	\
    (This)->lpVtbl -> UpdateItem(This,itemID)

#define IResultData_Sort(This,nColumn,dwSortOptions,lUserParam)	\
    (This)->lpVtbl -> Sort(This,nColumn,dwSortOptions,lUserParam)

#define IResultData_SetDescBarText(This,DescText)	\
    (This)->lpVtbl -> SetDescBarText(This,DescText)

#define IResultData_SetItemCount(This,nItemCount,dwOptions)	\
    (This)->lpVtbl -> SetItemCount(This,nItemCount,dwOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_InsertItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out][in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_InsertItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_DeleteItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ HRESULTITEM itemID,
    /* [in] */ int nCol);


void __RPC_STUB IResultData_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_FindItemByLParam_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ LPARAM lParam,
    /* [out] */ HRESULTITEM __RPC_FAR *pItemID);


void __RPC_STUB IResultData_FindItemByLParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_DeleteAllRsltItems_Proxy( 
    IResultData __RPC_FAR * This);


void __RPC_STUB IResultData_DeleteAllRsltItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_SetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out][in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetNextItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out][in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_GetNextItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_ModifyItemState_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ HRESULTITEM itemID,
    /* [in] */ UINT uAdd,
    /* [in] */ UINT uRemove);


void __RPC_STUB IResultData_ModifyItemState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_ModifyViewStyle_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ MMC_RESULT_VIEW_STYLE add,
    /* [in] */ MMC_RESULT_VIEW_STYLE remove);


void __RPC_STUB IResultData_ModifyViewStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetViewMode_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ long lViewMode);


void __RPC_STUB IResultData_SetViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetViewMode_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *lViewMode);


void __RPC_STUB IResultData_GetViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_UpdateItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ HRESULTITEM itemID);


void __RPC_STUB IResultData_UpdateItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_Sort_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ int nColumn,
    /* [in] */ DWORD dwSortOptions,
    /* [in] */ LPARAM lUserParam);


void __RPC_STUB IResultData_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetDescBarText_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ LPOLESTR DescText);


void __RPC_STUB IResultData_SetDescBarText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetItemCount_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ int nItemCount,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IResultData_SetItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultData_INTERFACE_DEFINED__ */


#ifndef __IConsoleNameSpace_INTERFACE_DEFINED__
#define __IConsoleNameSpace_INTERFACE_DEFINED__

/* interface IConsoleNameSpace */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IConsoleNameSpace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEDEB620-F24D-11cf-8AFC-00AA003CA9F6")
    IConsoleNameSpace : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [out][in] */ LPSCOPEDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItem( 
            /* [in] */ LPSCOPEDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItem( 
            /* [out][in] */ LPSCOPEDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildItem( 
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetParentItem( 
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleNameSpaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsoleNameSpace __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsoleNameSpace __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        END_INTERFACE
    } IConsoleNameSpaceVtbl;

    interface IConsoleNameSpace
    {
        CONST_VTBL struct IConsoleNameSpaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsoleNameSpace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsoleNameSpace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsoleNameSpace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsoleNameSpace_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IConsoleNameSpace_DeleteItem(This,hItem,fDeleteThis)	\
    (This)->lpVtbl -> DeleteItem(This,hItem,fDeleteThis)

#define IConsoleNameSpace_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IConsoleNameSpace_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IConsoleNameSpace_GetChildItem(This,item,pItemChild,pCookie)	\
    (This)->lpVtbl -> GetChildItem(This,item,pItemChild,pCookie)

#define IConsoleNameSpace_GetNextItem(This,item,pItemNext,pCookie)	\
    (This)->lpVtbl -> GetNextItem(This,item,pItemNext,pCookie)

#define IConsoleNameSpace_GetParentItem(This,item,pItemParent,pCookie)	\
    (This)->lpVtbl -> GetParentItem(This,item,pItemParent,pCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_InsertItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [out][in] */ LPSCOPEDATAITEM item);


void __RPC_STUB IConsoleNameSpace_InsertItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_DeleteItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hItem,
    /* [in] */ long fDeleteThis);


void __RPC_STUB IConsoleNameSpace_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_SetItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ LPSCOPEDATAITEM item);


void __RPC_STUB IConsoleNameSpace_SetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [out][in] */ LPSCOPEDATAITEM item);


void __RPC_STUB IConsoleNameSpace_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetChildItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM item,
    /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
    /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);


void __RPC_STUB IConsoleNameSpace_GetChildItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetNextItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM item,
    /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
    /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);


void __RPC_STUB IConsoleNameSpace_GetNextItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetParentItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM item,
    /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
    /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);


void __RPC_STUB IConsoleNameSpace_GetParentItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsoleNameSpace_INTERFACE_DEFINED__ */


#ifndef __IConsoleNameSpace2_INTERFACE_DEFINED__
#define __IConsoleNameSpace2_INTERFACE_DEFINED__

/* interface IConsoleNameSpace2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IConsoleNameSpace2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("255F18CC-65DB-11D1-A7DC-00C04FD8D565")
    IConsoleNameSpace2 : public IConsoleNameSpace
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Expand( 
            /* [in] */ HSCOPEITEM hItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddExtension( 
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ LPCLSID lpClsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleNameSpace2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsoleNameSpace2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsoleNameSpace2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtension )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ LPCLSID lpClsid);
        
        END_INTERFACE
    } IConsoleNameSpace2Vtbl;

    interface IConsoleNameSpace2
    {
        CONST_VTBL struct IConsoleNameSpace2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsoleNameSpace2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsoleNameSpace2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsoleNameSpace2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsoleNameSpace2_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IConsoleNameSpace2_DeleteItem(This,hItem,fDeleteThis)	\
    (This)->lpVtbl -> DeleteItem(This,hItem,fDeleteThis)

#define IConsoleNameSpace2_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IConsoleNameSpace2_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IConsoleNameSpace2_GetChildItem(This,item,pItemChild,pCookie)	\
    (This)->lpVtbl -> GetChildItem(This,item,pItemChild,pCookie)

#define IConsoleNameSpace2_GetNextItem(This,item,pItemNext,pCookie)	\
    (This)->lpVtbl -> GetNextItem(This,item,pItemNext,pCookie)

#define IConsoleNameSpace2_GetParentItem(This,item,pItemParent,pCookie)	\
    (This)->lpVtbl -> GetParentItem(This,item,pItemParent,pCookie)


#define IConsoleNameSpace2_Expand(This,hItem)	\
    (This)->lpVtbl -> Expand(This,hItem)

#define IConsoleNameSpace2_AddExtension(This,hItem,lpClsid)	\
    (This)->lpVtbl -> AddExtension(This,hItem,lpClsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace2_Expand_Proxy( 
    IConsoleNameSpace2 __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hItem);


void __RPC_STUB IConsoleNameSpace2_Expand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace2_AddExtension_Proxy( 
    IConsoleNameSpace2 __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hItem,
    /* [in] */ LPCLSID lpClsid);


void __RPC_STUB IConsoleNameSpace2_AddExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsoleNameSpace2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0120 */
/* [local] */ 


typedef struct _PSP __RPC_FAR *HPROPSHEETPAGE;



extern RPC_IF_HANDLE __MIDL_itf_mmc_0120_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0120_v0_0_s_ifspec;

#ifndef __IPropertySheetCallback_INTERFACE_DEFINED__
#define __IPropertySheetCallback_INTERFACE_DEFINED__

/* interface IPropertySheetCallback */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IPropertySheetCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DE64DD-EF21-11cf-A285-00C04FD8DBE6")
    IPropertySheetCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPage( 
            /* [in] */ HPROPSHEETPAGE hPage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePage( 
            /* [in] */ HPROPSHEETPAGE hPage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySheetCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetCallback __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPage )( 
            IPropertySheetCallback __RPC_FAR * This,
            /* [in] */ HPROPSHEETPAGE hPage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemovePage )( 
            IPropertySheetCallback __RPC_FAR * This,
            /* [in] */ HPROPSHEETPAGE hPage);
        
        END_INTERFACE
    } IPropertySheetCallbackVtbl;

    interface IPropertySheetCallback
    {
        CONST_VTBL struct IPropertySheetCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySheetCallback_AddPage(This,hPage)	\
    (This)->lpVtbl -> AddPage(This,hPage)

#define IPropertySheetCallback_RemovePage(This,hPage)	\
    (This)->lpVtbl -> RemovePage(This,hPage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetCallback_AddPage_Proxy( 
    IPropertySheetCallback __RPC_FAR * This,
    /* [in] */ HPROPSHEETPAGE hPage);


void __RPC_STUB IPropertySheetCallback_AddPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetCallback_RemovePage_Proxy( 
    IPropertySheetCallback __RPC_FAR * This,
    /* [in] */ HPROPSHEETPAGE hPage);


void __RPC_STUB IPropertySheetCallback_RemovePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySheetCallback_INTERFACE_DEFINED__ */


#ifndef __IPropertySheetProvider_INTERFACE_DEFINED__
#define __IPropertySheetProvider_INTERFACE_DEFINED__

/* interface IPropertySheetProvider */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPropertySheetProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DE64DE-EF21-11cf-A285-00C04FD8DBE6")
    IPropertySheetProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertySheet( 
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ LPDATAOBJECT pIDataObjectm,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindPropertySheet( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ LPCOMPONENT lpComponent,
            /* [in] */ LPDATAOBJECT lpDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPrimaryPages( 
            LPUNKNOWN lpUnknown,
            BOOL bCreateHandle,
            HWND hNotifyWindow,
            BOOL bScopePane) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddExtensionPages( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ LONG_PTR window,
            /* [in] */ int page) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySheetProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertySheet )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ LPDATAOBJECT pIDataObjectm,
            /* [in] */ DWORD dwOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPropertySheet )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ LPCOMPONENT lpComponent,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryPages )( 
            IPropertySheetProvider __RPC_FAR * This,
            LPUNKNOWN lpUnknown,
            BOOL bCreateHandle,
            HWND hNotifyWindow,
            BOOL bScopePane);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtensionPages )( 
            IPropertySheetProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Show )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ LONG_PTR window,
            /* [in] */ int page);
        
        END_INTERFACE
    } IPropertySheetProviderVtbl;

    interface IPropertySheetProvider
    {
        CONST_VTBL struct IPropertySheetProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySheetProvider_CreatePropertySheet(This,title,type,cookie,pIDataObjectm,dwOptions)	\
    (This)->lpVtbl -> CreatePropertySheet(This,title,type,cookie,pIDataObjectm,dwOptions)

#define IPropertySheetProvider_FindPropertySheet(This,cookie,lpComponent,lpDataObject)	\
    (This)->lpVtbl -> FindPropertySheet(This,cookie,lpComponent,lpDataObject)

#define IPropertySheetProvider_AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)	\
    (This)->lpVtbl -> AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)

#define IPropertySheetProvider_AddExtensionPages(This)	\
    (This)->lpVtbl -> AddExtensionPages(This)

#define IPropertySheetProvider_Show(This,window,page)	\
    (This)->lpVtbl -> Show(This,window,page)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_CreatePropertySheet_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    /* [in] */ LPCWSTR title,
    /* [in] */ boolean type,
    /* [in] */ MMC_COOKIE cookie,
    /* [in] */ LPDATAOBJECT pIDataObjectm,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IPropertySheetProvider_CreatePropertySheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_FindPropertySheet_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    /* [in] */ MMC_COOKIE cookie,
    /* [in] */ LPCOMPONENT lpComponent,
    /* [in] */ LPDATAOBJECT lpDataObject);


void __RPC_STUB IPropertySheetProvider_FindPropertySheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_AddPrimaryPages_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    LPUNKNOWN lpUnknown,
    BOOL bCreateHandle,
    HWND hNotifyWindow,
    BOOL bScopePane);


void __RPC_STUB IPropertySheetProvider_AddPrimaryPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_AddExtensionPages_Proxy( 
    IPropertySheetProvider __RPC_FAR * This);


void __RPC_STUB IPropertySheetProvider_AddExtensionPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_Show_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    /* [in] */ LONG_PTR window,
    /* [in] */ int page);


void __RPC_STUB IPropertySheetProvider_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySheetProvider_INTERFACE_DEFINED__ */


#ifndef __IExtendPropertySheet_INTERFACE_DEFINED__
#define __IExtendPropertySheet_INTERFACE_DEFINED__

/* interface IExtendPropertySheet */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IExtendPropertySheet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DE64DC-EF21-11cf-A285-00C04FD8DBE6")
    IExtendPropertySheet : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendPropertySheetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendPropertySheet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendPropertySheet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendPropertySheet __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyPages )( 
            IExtendPropertySheet __RPC_FAR * This,
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryPagesFor )( 
            IExtendPropertySheet __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        END_INTERFACE
    } IExtendPropertySheetVtbl;

    interface IExtendPropertySheet
    {
        CONST_VTBL struct IExtendPropertySheetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendPropertySheet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendPropertySheet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendPropertySheet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendPropertySheet_CreatePropertyPages(This,lpProvider,handle,lpIDataObject)	\
    (This)->lpVtbl -> CreatePropertyPages(This,lpProvider,handle,lpIDataObject)

#define IExtendPropertySheet_QueryPagesFor(This,lpDataObject)	\
    (This)->lpVtbl -> QueryPagesFor(This,lpDataObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendPropertySheet_CreatePropertyPages_Proxy( 
    IExtendPropertySheet __RPC_FAR * This,
    /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
    /* [in] */ LONG_PTR handle,
    /* [in] */ LPDATAOBJECT lpIDataObject);


void __RPC_STUB IExtendPropertySheet_CreatePropertyPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendPropertySheet_QueryPagesFor_Proxy( 
    IExtendPropertySheet __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject);


void __RPC_STUB IExtendPropertySheet_QueryPagesFor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendPropertySheet_INTERFACE_DEFINED__ */


#ifndef __IControlbar_INTERFACE_DEFINED__
#define __IControlbar_INTERFACE_DEFINED__

/* interface IControlbar */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IControlbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69FB811E-6C1C-11D0-A2CB-00C04FD909DD")
    IControlbar : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPEXTENDCONTROLBAR pExtendControlbar,
            /* [out] */ LPUNKNOWN __RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPUNKNOWN lpUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Detach( 
            /* [in] */ LPUNKNOWN lpUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IControlbar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IControlbar __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPEXTENDCONTROLBAR pExtendControlbar,
            /* [out] */ LPUNKNOWN __RPC_FAR *ppUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Attach )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPUNKNOWN lpUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ LPUNKNOWN lpUnknown);
        
        END_INTERFACE
    } IControlbarVtbl;

    interface IControlbar
    {
        CONST_VTBL struct IControlbarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IControlbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IControlbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IControlbar_Create(This,nType,pExtendControlbar,ppUnknown)	\
    (This)->lpVtbl -> Create(This,nType,pExtendControlbar,ppUnknown)

#define IControlbar_Attach(This,nType,lpUnknown)	\
    (This)->lpVtbl -> Attach(This,nType,lpUnknown)

#define IControlbar_Detach(This,lpUnknown)	\
    (This)->lpVtbl -> Detach(This,lpUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbar_Create_Proxy( 
    IControlbar __RPC_FAR * This,
    /* [in] */ MMC_CONTROL_TYPE nType,
    /* [in] */ LPEXTENDCONTROLBAR pExtendControlbar,
    /* [out] */ LPUNKNOWN __RPC_FAR *ppUnknown);


void __RPC_STUB IControlbar_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbar_Attach_Proxy( 
    IControlbar __RPC_FAR * This,
    /* [in] */ MMC_CONTROL_TYPE nType,
    /* [in] */ LPUNKNOWN lpUnknown);


void __RPC_STUB IControlbar_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbar_Detach_Proxy( 
    IControlbar __RPC_FAR * This,
    /* [in] */ LPUNKNOWN lpUnknown);


void __RPC_STUB IControlbar_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IControlbar_INTERFACE_DEFINED__ */


#ifndef __IExtendControlbar_INTERFACE_DEFINED__
#define __IExtendControlbar_INTERFACE_DEFINED__

/* interface IExtendControlbar */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IExtendControlbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49506520-6F40-11D0-A98B-00C04FD8D565")
    IExtendControlbar : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
            /* [in] */ LPCONTROLBAR pControlbar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendControlbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendControlbar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendControlbar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendControlbar __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetControlbar )( 
            IExtendControlbar __RPC_FAR * This,
            /* [in] */ LPCONTROLBAR pControlbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ControlbarNotify )( 
            IExtendControlbar __RPC_FAR * This,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
        
        END_INTERFACE
    } IExtendControlbarVtbl;

    interface IExtendControlbar
    {
        CONST_VTBL struct IExtendControlbarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendControlbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendControlbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendControlbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendControlbar_SetControlbar(This,pControlbar)	\
    (This)->lpVtbl -> SetControlbar(This,pControlbar)

#define IExtendControlbar_ControlbarNotify(This,event,arg,param)	\
    (This)->lpVtbl -> ControlbarNotify(This,event,arg,param)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendControlbar_SetControlbar_Proxy( 
    IExtendControlbar __RPC_FAR * This,
    /* [in] */ LPCONTROLBAR pControlbar);


void __RPC_STUB IExtendControlbar_SetControlbar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendControlbar_ControlbarNotify_Proxy( 
    IExtendControlbar __RPC_FAR * This,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ LPARAM arg,
    /* [in] */ LPARAM param);


void __RPC_STUB IExtendControlbar_ControlbarNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendControlbar_INTERFACE_DEFINED__ */


#ifndef __IToolbar_INTERFACE_DEFINED__
#define __IToolbar_INTERFACE_DEFINED__

/* interface IToolbar */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IToolbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB9-D36C-11CF-ADBC-00AA00A80033")
    IToolbar : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddBitmap( 
            /* [in] */ int nImages,
            /* [in] */ HBITMAP hbmp,
            /* [in] */ int cxSize,
            /* [in] */ int cySize,
            /* [in] */ COLORREF crMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddButtons( 
            /* [in] */ int nButtons,
            /* [in] */ LPMMCBUTTON lpButtons) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertButton( 
            /* [in] */ int nIndex,
            /* [in] */ LPMMCBUTTON lpButton) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteButton( 
            /* [in] */ int nIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetButtonState( 
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButtonState( 
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IToolbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IToolbar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IToolbar __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddBitmap )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nImages,
            /* [in] */ HBITMAP hbmp,
            /* [in] */ int cxSize,
            /* [in] */ int cySize,
            /* [in] */ COLORREF crMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddButtons )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nButtons,
            /* [in] */ LPMMCBUTTON lpButtons);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertButton )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ LPMMCBUTTON lpButton);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteButton )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetButtonState )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetButtonState )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState);
        
        END_INTERFACE
    } IToolbarVtbl;

    interface IToolbar
    {
        CONST_VTBL struct IToolbarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IToolbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IToolbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IToolbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IToolbar_AddBitmap(This,nImages,hbmp,cxSize,cySize,crMask)	\
    (This)->lpVtbl -> AddBitmap(This,nImages,hbmp,cxSize,cySize,crMask)

#define IToolbar_AddButtons(This,nButtons,lpButtons)	\
    (This)->lpVtbl -> AddButtons(This,nButtons,lpButtons)

#define IToolbar_InsertButton(This,nIndex,lpButton)	\
    (This)->lpVtbl -> InsertButton(This,nIndex,lpButton)

#define IToolbar_DeleteButton(This,nIndex)	\
    (This)->lpVtbl -> DeleteButton(This,nIndex)

#define IToolbar_GetButtonState(This,idCommand,nState,pState)	\
    (This)->lpVtbl -> GetButtonState(This,idCommand,nState,pState)

#define IToolbar_SetButtonState(This,idCommand,nState,bState)	\
    (This)->lpVtbl -> SetButtonState(This,idCommand,nState,bState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_AddBitmap_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nImages,
    /* [in] */ HBITMAP hbmp,
    /* [in] */ int cxSize,
    /* [in] */ int cySize,
    /* [in] */ COLORREF crMask);


void __RPC_STUB IToolbar_AddBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_AddButtons_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nButtons,
    /* [in] */ LPMMCBUTTON lpButtons);


void __RPC_STUB IToolbar_AddButtons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_InsertButton_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ LPMMCBUTTON lpButton);


void __RPC_STUB IToolbar_InsertButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_DeleteButton_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nIndex);


void __RPC_STUB IToolbar_DeleteButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_GetButtonState_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [out] */ BOOL __RPC_FAR *pState);


void __RPC_STUB IToolbar_GetButtonState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_SetButtonState_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [in] */ BOOL bState);


void __RPC_STUB IToolbar_SetButtonState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IToolbar_INTERFACE_DEFINED__ */


#ifndef __IConsoleVerb_INTERFACE_DEFINED__
#define __IConsoleVerb_INTERFACE_DEFINED__

/* interface IConsoleVerb */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConsoleVerb;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E49F7A60-74AF-11D0-A286-00C04FD8FE93")
    IConsoleVerb : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVerbState( 
            /* [in] */ MMC_CONSOLE_VERB eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVerbState( 
            /* [in] */ MMC_CONSOLE_VERB eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDefaultVerb( 
            /* [in] */ MMC_CONSOLE_VERB eCmdID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDefaultVerb( 
            /* [out] */ MMC_CONSOLE_VERB __RPC_FAR *peCmdID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleVerbVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsoleVerb __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsoleVerb __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVerbState )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ MMC_CONSOLE_VERB eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVerbState )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ MMC_CONSOLE_VERB eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultVerb )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ MMC_CONSOLE_VERB eCmdID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultVerb )( 
            IConsoleVerb __RPC_FAR * This,
            /* [out] */ MMC_CONSOLE_VERB __RPC_FAR *peCmdID);
        
        END_INTERFACE
    } IConsoleVerbVtbl;

    interface IConsoleVerb
    {
        CONST_VTBL struct IConsoleVerbVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsoleVerb_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsoleVerb_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsoleVerb_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsoleVerb_GetVerbState(This,eCmdID,nState,pState)	\
    (This)->lpVtbl -> GetVerbState(This,eCmdID,nState,pState)

#define IConsoleVerb_SetVerbState(This,eCmdID,nState,bState)	\
    (This)->lpVtbl -> SetVerbState(This,eCmdID,nState,bState)

#define IConsoleVerb_SetDefaultVerb(This,eCmdID)	\
    (This)->lpVtbl -> SetDefaultVerb(This,eCmdID)

#define IConsoleVerb_GetDefaultVerb(This,peCmdID)	\
    (This)->lpVtbl -> GetDefaultVerb(This,peCmdID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_GetVerbState_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [in] */ MMC_CONSOLE_VERB eCmdID,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [out] */ BOOL __RPC_FAR *pState);


void __RPC_STUB IConsoleVerb_GetVerbState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_SetVerbState_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [in] */ MMC_CONSOLE_VERB eCmdID,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [in] */ BOOL bState);


void __RPC_STUB IConsoleVerb_SetVerbState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_SetDefaultVerb_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [in] */ MMC_CONSOLE_VERB eCmdID);


void __RPC_STUB IConsoleVerb_SetDefaultVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_GetDefaultVerb_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [out] */ MMC_CONSOLE_VERB __RPC_FAR *peCmdID);


void __RPC_STUB IConsoleVerb_GetDefaultVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsoleVerb_INTERFACE_DEFINED__ */


#ifndef __ISnapinAbout_INTERFACE_DEFINED__
#define __ISnapinAbout_INTERFACE_DEFINED__

/* interface ISnapinAbout */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISnapinAbout;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1245208C-A151-11D0-A7D7-00C04FD909DD")
    ISnapinAbout : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinDescription( 
            /* [out] */ LPOLESTR __RPC_FAR *lpDescription) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ LPOLESTR __RPC_FAR *lpName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinVersion( 
            /* [out] */ LPOLESTR __RPC_FAR *lpVersion) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinImage( 
            /* [out] */ HICON __RPC_FAR *hAppIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStaticFolderImage( 
            /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
            /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
            /* [out] */ COLORREF __RPC_FAR *cMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISnapinAboutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISnapinAbout __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISnapinAbout __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISnapinAbout __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSnapinDescription )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpDescription);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProvider )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSnapinVersion )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpVersion);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSnapinImage )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ HICON __RPC_FAR *hAppIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStaticFolderImage )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
            /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
            /* [out] */ COLORREF __RPC_FAR *cMask);
        
        END_INTERFACE
    } ISnapinAboutVtbl;

    interface ISnapinAbout
    {
        CONST_VTBL struct ISnapinAboutVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISnapinAbout_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISnapinAbout_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISnapinAbout_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISnapinAbout_GetSnapinDescription(This,lpDescription)	\
    (This)->lpVtbl -> GetSnapinDescription(This,lpDescription)

#define ISnapinAbout_GetProvider(This,lpName)	\
    (This)->lpVtbl -> GetProvider(This,lpName)

#define ISnapinAbout_GetSnapinVersion(This,lpVersion)	\
    (This)->lpVtbl -> GetSnapinVersion(This,lpVersion)

#define ISnapinAbout_GetSnapinImage(This,hAppIcon)	\
    (This)->lpVtbl -> GetSnapinImage(This,hAppIcon)

#define ISnapinAbout_GetStaticFolderImage(This,hSmallImage,hSmallImageOpen,hLargeImage,cMask)	\
    (This)->lpVtbl -> GetStaticFolderImage(This,hSmallImage,hSmallImageOpen,hLargeImage,cMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinDescription_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpDescription);


void __RPC_STUB ISnapinAbout_GetSnapinDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetProvider_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpName);


void __RPC_STUB ISnapinAbout_GetProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinVersion_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpVersion);


void __RPC_STUB ISnapinAbout_GetSnapinVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinImage_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ HICON __RPC_FAR *hAppIcon);


void __RPC_STUB ISnapinAbout_GetSnapinImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetStaticFolderImage_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
    /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
    /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
    /* [out] */ COLORREF __RPC_FAR *cMask);


void __RPC_STUB ISnapinAbout_GetStaticFolderImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISnapinAbout_INTERFACE_DEFINED__ */


#ifndef __IMenuButton_INTERFACE_DEFINED__
#define __IMenuButton_INTERFACE_DEFINED__

/* interface IMenuButton */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMenuButton;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("951ED750-D080-11d0-B197-000000000000")
    IMenuButton : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddButton( 
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButton( 
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButtonState( 
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMenuButtonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMenuButton __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMenuButton __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddButton )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetButton )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetButtonState )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState);
        
        END_INTERFACE
    } IMenuButtonVtbl;

    interface IMenuButton
    {
        CONST_VTBL struct IMenuButtonVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMenuButton_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMenuButton_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMenuButton_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMenuButton_AddButton(This,idCommand,lpButtonText,lpTooltipText)	\
    (This)->lpVtbl -> AddButton(This,idCommand,lpButtonText,lpTooltipText)

#define IMenuButton_SetButton(This,idCommand,lpButtonText,lpTooltipText)	\
    (This)->lpVtbl -> SetButton(This,idCommand,lpButtonText,lpTooltipText)

#define IMenuButton_SetButtonState(This,idCommand,nState,bState)	\
    (This)->lpVtbl -> SetButtonState(This,idCommand,nState,bState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMenuButton_AddButton_Proxy( 
    IMenuButton __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ LPOLESTR lpButtonText,
    /* [in] */ LPOLESTR lpTooltipText);


void __RPC_STUB IMenuButton_AddButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMenuButton_SetButton_Proxy( 
    IMenuButton __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ LPOLESTR lpButtonText,
    /* [in] */ LPOLESTR lpTooltipText);


void __RPC_STUB IMenuButton_SetButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMenuButton_SetButtonState_Proxy( 
    IMenuButton __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [in] */ BOOL bState);


void __RPC_STUB IMenuButton_SetButtonState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMenuButton_INTERFACE_DEFINED__ */


#ifndef __ISnapinHelp_INTERFACE_DEFINED__
#define __ISnapinHelp_INTERFACE_DEFINED__

/* interface ISnapinHelp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISnapinHelp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6B15ACE-DF59-11D0-A7DD-00C04FD909DD")
    ISnapinHelp : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHelpTopic( 
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISnapinHelpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISnapinHelp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISnapinHelp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISnapinHelp __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHelpTopic )( 
            ISnapinHelp __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);
        
        END_INTERFACE
    } ISnapinHelpVtbl;

    interface ISnapinHelp
    {
        CONST_VTBL struct ISnapinHelpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISnapinHelp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISnapinHelp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISnapinHelp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISnapinHelp_GetHelpTopic(This,lpCompiledHelpFile)	\
    (This)->lpVtbl -> GetHelpTopic(This,lpCompiledHelpFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinHelp_GetHelpTopic_Proxy( 
    ISnapinHelp __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);


void __RPC_STUB ISnapinHelp_GetHelpTopic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISnapinHelp_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0130 */
/* [local] */ 

#if (MMC_VER >= 0x0110)


extern RPC_IF_HANDLE __MIDL_itf_mmc_0130_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0130_v0_0_s_ifspec;

#ifndef __IExtendPropertySheet2_INTERFACE_DEFINED__
#define __IExtendPropertySheet2_INTERFACE_DEFINED__

/* interface IExtendPropertySheet2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IExtendPropertySheet2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B7A87232-4A51-11D1-A7EA-00C04FD909DD")
    IExtendPropertySheet2 : public IExtendPropertySheet
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendPropertySheet2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendPropertySheet2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendPropertySheet2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendPropertySheet2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyPages )( 
            IExtendPropertySheet2 __RPC_FAR * This,
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryPagesFor )( 
            IExtendPropertySheet2 __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWatermarks )( 
            IExtendPropertySheet2 __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch);
        
        END_INTERFACE
    } IExtendPropertySheet2Vtbl;

    interface IExtendPropertySheet2
    {
        CONST_VTBL struct IExtendPropertySheet2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendPropertySheet2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendPropertySheet2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendPropertySheet2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendPropertySheet2_CreatePropertyPages(This,lpProvider,handle,lpIDataObject)	\
    (This)->lpVtbl -> CreatePropertyPages(This,lpProvider,handle,lpIDataObject)

#define IExtendPropertySheet2_QueryPagesFor(This,lpDataObject)	\
    (This)->lpVtbl -> QueryPagesFor(This,lpDataObject)


#define IExtendPropertySheet2_GetWatermarks(This,lpIDataObject,lphWatermark,lphHeader,lphPalette,bStretch)	\
    (This)->lpVtbl -> GetWatermarks(This,lpIDataObject,lphWatermark,lphHeader,lphPalette,bStretch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendPropertySheet2_GetWatermarks_Proxy( 
    IExtendPropertySheet2 __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpIDataObject,
    /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
    /* [out] */ HBITMAP __RPC_FAR *lphHeader,
    /* [out] */ HPALETTE __RPC_FAR *lphPalette,
    /* [out] */ BOOL __RPC_FAR *bStretch);


void __RPC_STUB IExtendPropertySheet2_GetWatermarks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendPropertySheet2_INTERFACE_DEFINED__ */


#ifndef __IHeaderCtrl2_INTERFACE_DEFINED__
#define __IHeaderCtrl2_INTERFACE_DEFINED__

/* interface IHeaderCtrl2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHeaderCtrl2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9757abb8-1b32-11d1-a7ce-00c04fd8d565")
    IHeaderCtrl2 : public IHeaderCtrl
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetChangeTimeOut( 
            /* [in] */ unsigned long uTimeout) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnFilter( 
            /* [in] */ UINT nColumn,
            /* [in] */ DWORD dwType,
            /* [in] */ MMC_FILTERDATA __RPC_FAR *pFilterData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnFilter( 
            /* [in] */ UINT nColumn,
            /* [out][in] */ LPDWORD pdwType,
            /* [out][in] */ MMC_FILTERDATA __RPC_FAR *pFilterData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeaderCtrl2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHeaderCtrl2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHeaderCtrl2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertColumn )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title,
            /* [in] */ int nFormat,
            /* [in] */ int nWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteColumn )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnText )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnText )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out] */ LPOLESTR __RPC_FAR *pText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnWidth )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ int nWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnWidth )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out] */ int __RPC_FAR *pWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetChangeTimeOut )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ unsigned long uTimeout);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnFilter )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ UINT nColumn,
            /* [in] */ DWORD dwType,
            /* [in] */ MMC_FILTERDATA __RPC_FAR *pFilterData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnFilter )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ UINT nColumn,
            /* [out][in] */ LPDWORD pdwType,
            /* [out][in] */ MMC_FILTERDATA __RPC_FAR *pFilterData);
        
        END_INTERFACE
    } IHeaderCtrl2Vtbl;

    interface IHeaderCtrl2
    {
        CONST_VTBL struct IHeaderCtrl2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeaderCtrl2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeaderCtrl2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeaderCtrl2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeaderCtrl2_InsertColumn(This,nCol,title,nFormat,nWidth)	\
    (This)->lpVtbl -> InsertColumn(This,nCol,title,nFormat,nWidth)

#define IHeaderCtrl2_DeleteColumn(This,nCol)	\
    (This)->lpVtbl -> DeleteColumn(This,nCol)

#define IHeaderCtrl2_SetColumnText(This,nCol,title)	\
    (This)->lpVtbl -> SetColumnText(This,nCol,title)

#define IHeaderCtrl2_GetColumnText(This,nCol,pText)	\
    (This)->lpVtbl -> GetColumnText(This,nCol,pText)

#define IHeaderCtrl2_SetColumnWidth(This,nCol,nWidth)	\
    (This)->lpVtbl -> SetColumnWidth(This,nCol,nWidth)

#define IHeaderCtrl2_GetColumnWidth(This,nCol,pWidth)	\
    (This)->lpVtbl -> GetColumnWidth(This,nCol,pWidth)


#define IHeaderCtrl2_SetChangeTimeOut(This,uTimeout)	\
    (This)->lpVtbl -> SetChangeTimeOut(This,uTimeout)

#define IHeaderCtrl2_SetColumnFilter(This,nColumn,dwType,pFilterData)	\
    (This)->lpVtbl -> SetColumnFilter(This,nColumn,dwType,pFilterData)

#define IHeaderCtrl2_GetColumnFilter(This,nColumn,pdwType,pFilterData)	\
    (This)->lpVtbl -> GetColumnFilter(This,nColumn,pdwType,pFilterData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl2_SetChangeTimeOut_Proxy( 
    IHeaderCtrl2 __RPC_FAR * This,
    /* [in] */ unsigned long uTimeout);


void __RPC_STUB IHeaderCtrl2_SetChangeTimeOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl2_SetColumnFilter_Proxy( 
    IHeaderCtrl2 __RPC_FAR * This,
    /* [in] */ UINT nColumn,
    /* [in] */ DWORD dwType,
    /* [in] */ MMC_FILTERDATA __RPC_FAR *pFilterData);


void __RPC_STUB IHeaderCtrl2_SetColumnFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl2_GetColumnFilter_Proxy( 
    IHeaderCtrl2 __RPC_FAR * This,
    /* [in] */ UINT nColumn,
    /* [out][in] */ LPDWORD pdwType,
    /* [out][in] */ MMC_FILTERDATA __RPC_FAR *pFilterData);


void __RPC_STUB IHeaderCtrl2_GetColumnFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHeaderCtrl2_INTERFACE_DEFINED__ */


#ifndef __ISnapinHelp2_INTERFACE_DEFINED__
#define __ISnapinHelp2_INTERFACE_DEFINED__

/* interface ISnapinHelp2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISnapinHelp2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4861A010-20F9-11d2-A510-00C04FB6DD2C")
    ISnapinHelp2 : public ISnapinHelp
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLinkedTopics( 
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFiles) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISnapinHelp2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISnapinHelp2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISnapinHelp2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISnapinHelp2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHelpTopic )( 
            ISnapinHelp2 __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLinkedTopics )( 
            ISnapinHelp2 __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFiles);
        
        END_INTERFACE
    } ISnapinHelp2Vtbl;

    interface ISnapinHelp2
    {
        CONST_VTBL struct ISnapinHelp2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISnapinHelp2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISnapinHelp2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISnapinHelp2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISnapinHelp2_GetHelpTopic(This,lpCompiledHelpFile)	\
    (This)->lpVtbl -> GetHelpTopic(This,lpCompiledHelpFile)


#define ISnapinHelp2_GetLinkedTopics(This,lpCompiledHelpFiles)	\
    (This)->lpVtbl -> GetLinkedTopics(This,lpCompiledHelpFiles)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinHelp2_GetLinkedTopics_Proxy( 
    ISnapinHelp2 __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFiles);


void __RPC_STUB ISnapinHelp2_GetLinkedTopics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISnapinHelp2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0133 */
/* [local] */ 

typedef 
enum _MMC_TASK_DISPLAY_TYPE
    {	MMC_TASK_DISPLAY_UNINITIALIZED	= 0,
	MMC_TASK_DISPLAY_TYPE_SYMBOL	= MMC_TASK_DISPLAY_UNINITIALIZED + 1,
	MMC_TASK_DISPLAY_TYPE_VANILLA_GIF	= MMC_TASK_DISPLAY_TYPE_SYMBOL + 1,
	MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF	= MMC_TASK_DISPLAY_TYPE_VANILLA_GIF + 1,
	MMC_TASK_DISPLAY_TYPE_BITMAP	= MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF + 1
    }	MMC_TASK_DISPLAY_TYPE;

typedef struct _MMC_TASK_DISPLAY_SYMBOL
    {
    LPOLESTR szFontFamilyName;
    LPOLESTR szURLtoEOT;
    LPOLESTR szSymbolString;
    }	MMC_TASK_DISPLAY_SYMBOL;

typedef struct _MMC_TASK_DISPLAY_BITMAP
    {
    LPOLESTR szMouseOverBitmap;
    LPOLESTR szMouseOffBitmap;
    }	MMC_TASK_DISPLAY_BITMAP;

typedef struct _MMC_TASK_DISPLAY_OBJECT
    {
    MMC_TASK_DISPLAY_TYPE eDisplayType;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ MMC_TASK_DISPLAY_BITMAP uBitmap;
        /* [case()] */ MMC_TASK_DISPLAY_SYMBOL uSymbol;
        /* [default] */  /* Empty union arm */ 
        }	;
    }	MMC_TASK_DISPLAY_OBJECT;

typedef 
enum _MMC_ACTION_TYPE
    {	MMC_ACTION_UNINITIALIZED	= -1,
	MMC_ACTION_ID	= MMC_ACTION_UNINITIALIZED + 1,
	MMC_ACTION_LINK	= MMC_ACTION_ID + 1,
	MMC_ACTION_SCRIPT	= MMC_ACTION_LINK + 1
    }	MMC_ACTION_TYPE;

typedef struct _MMC_TASK
    {
    MMC_TASK_DISPLAY_OBJECT sDisplayObject;
    LPOLESTR szText;
    LPOLESTR szHelpString;
    MMC_ACTION_TYPE eActionType;
    union 
        {
        LONG_PTR nCommandID;
        LPOLESTR szActionURL;
        LPOLESTR szScript;
        }	;
    }	MMC_TASK;

typedef struct _MMC_LISTPAD_INFO
    {
    LPOLESTR szTitle;
    LPOLESTR szButtonText;
    LONG_PTR nCommandID;
    }	MMC_LISTPAD_INFO;

typedef DWORD MMC_STRING_ID;



extern RPC_IF_HANDLE __MIDL_itf_mmc_0133_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0133_v0_0_s_ifspec;

#ifndef __IEnumTASK_INTERFACE_DEFINED__
#define __IEnumTASK_INTERFACE_DEFINED__

/* interface IEnumTASK */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumTASK;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("338698b1-5a02-11d1-9fec-00600832db4a")
    IEnumTASK : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ MMC_TASK __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTASKVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumTASK __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumTASK __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumTASK __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumTASK __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ MMC_TASK __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumTASK __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumTASK __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumTASK __RPC_FAR * This,
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumTASKVtbl;

    interface IEnumTASK
    {
        CONST_VTBL struct IEnumTASKVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTASK_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTASK_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTASK_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTASK_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumTASK_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumTASK_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTASK_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTASK_Next_Proxy( 
    IEnumTASK __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ MMC_TASK __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumTASK_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTASK_Skip_Proxy( 
    IEnumTASK __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumTASK_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTASK_Reset_Proxy( 
    IEnumTASK __RPC_FAR * This);


void __RPC_STUB IEnumTASK_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTASK_Clone_Proxy( 
    IEnumTASK __RPC_FAR * This,
    /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumTASK_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTASK_INTERFACE_DEFINED__ */


#ifndef __IExtendTaskPad_INTERFACE_DEFINED__
#define __IExtendTaskPad_INTERFACE_DEFINED__

/* interface IExtendTaskPad */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IExtendTaskPad;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8dee6511-554d-11d1-9fea-00600832db4a")
    IExtendTaskPad : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TaskNotify( 
            /* [in] */ IDataObject __RPC_FAR *pdo,
            /* [in] */ VARIANT __RPC_FAR *arg,
            /* [in] */ VARIANT __RPC_FAR *param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumTasks( 
            /* [in] */ IDataObject __RPC_FAR *pdo,
            /* [string][in] */ LPOLESTR szTaskGroup,
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [string][out] */ LPOLESTR __RPC_FAR *pszTitle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDescriptiveText( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [string][out] */ LPOLESTR __RPC_FAR *pszDescriptiveText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetBackground( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_TASK_DISPLAY_OBJECT __RPC_FAR *pTDO) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetListPadInfo( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_LISTPAD_INFO __RPC_FAR *lpListPadInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendTaskPadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendTaskPad __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendTaskPad __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TaskNotify )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [in] */ IDataObject __RPC_FAR *pdo,
            /* [in] */ VARIANT __RPC_FAR *arg,
            /* [in] */ VARIANT __RPC_FAR *param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTasks )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [in] */ IDataObject __RPC_FAR *pdo,
            /* [string][in] */ LPOLESTR szTaskGroup,
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTitle )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [string][in] */ LPOLESTR pszGroup,
            /* [string][out] */ LPOLESTR __RPC_FAR *pszTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptiveText )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [string][in] */ LPOLESTR pszGroup,
            /* [string][out] */ LPOLESTR __RPC_FAR *pszDescriptiveText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackground )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_TASK_DISPLAY_OBJECT __RPC_FAR *pTDO);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListPadInfo )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_LISTPAD_INFO __RPC_FAR *lpListPadInfo);
        
        END_INTERFACE
    } IExtendTaskPadVtbl;

    interface IExtendTaskPad
    {
        CONST_VTBL struct IExtendTaskPadVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendTaskPad_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendTaskPad_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendTaskPad_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendTaskPad_TaskNotify(This,pdo,arg,param)	\
    (This)->lpVtbl -> TaskNotify(This,pdo,arg,param)

#define IExtendTaskPad_EnumTasks(This,pdo,szTaskGroup,ppEnumTASK)	\
    (This)->lpVtbl -> EnumTasks(This,pdo,szTaskGroup,ppEnumTASK)

#define IExtendTaskPad_GetTitle(This,pszGroup,pszTitle)	\
    (This)->lpVtbl -> GetTitle(This,pszGroup,pszTitle)

#define IExtendTaskPad_GetDescriptiveText(This,pszGroup,pszDescriptiveText)	\
    (This)->lpVtbl -> GetDescriptiveText(This,pszGroup,pszDescriptiveText)

#define IExtendTaskPad_GetBackground(This,pszGroup,pTDO)	\
    (This)->lpVtbl -> GetBackground(This,pszGroup,pTDO)

#define IExtendTaskPad_GetListPadInfo(This,pszGroup,lpListPadInfo)	\
    (This)->lpVtbl -> GetListPadInfo(This,pszGroup,lpListPadInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendTaskPad_TaskNotify_Proxy( 
    IExtendTaskPad __RPC_FAR * This,
    /* [in] */ IDataObject __RPC_FAR *pdo,
    /* [in] */ VARIANT __RPC_FAR *arg,
    /* [in] */ VARIANT __RPC_FAR *param);


void __RPC_STUB IExtendTaskPad_TaskNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendTaskPad_EnumTasks_Proxy( 
    IExtendTaskPad __RPC_FAR * This,
    /* [in] */ IDataObject __RPC_FAR *pdo,
    /* [string][in] */ LPOLESTR szTaskGroup,
    /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK);


void __RPC_STUB IExtendTaskPad_EnumTasks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendTaskPad_GetTitle_Proxy( 
    IExtendTaskPad __RPC_FAR * This,
    /* [string][in] */ LPOLESTR pszGroup,
    /* [string][out] */ LPOLESTR __RPC_FAR *pszTitle);


void __RPC_STUB IExtendTaskPad_GetTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendTaskPad_GetDescriptiveText_Proxy( 
    IExtendTaskPad __RPC_FAR * This,
    /* [string][in] */ LPOLESTR pszGroup,
    /* [string][out] */ LPOLESTR __RPC_FAR *pszDescriptiveText);


void __RPC_STUB IExtendTaskPad_GetDescriptiveText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendTaskPad_GetBackground_Proxy( 
    IExtendTaskPad __RPC_FAR * This,
    /* [string][in] */ LPOLESTR pszGroup,
    /* [out] */ MMC_TASK_DISPLAY_OBJECT __RPC_FAR *pTDO);


void __RPC_STUB IExtendTaskPad_GetBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendTaskPad_GetListPadInfo_Proxy( 
    IExtendTaskPad __RPC_FAR * This,
    /* [string][in] */ LPOLESTR pszGroup,
    /* [out] */ MMC_LISTPAD_INFO __RPC_FAR *lpListPadInfo);


void __RPC_STUB IExtendTaskPad_GetListPadInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendTaskPad_INTERFACE_DEFINED__ */


#ifndef __IConsole2_INTERFACE_DEFINED__
#define __IConsole2_INTERFACE_DEFINED__

/* interface IConsole2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IConsole2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("103D842A-AA63-11D1-A7E1-00C04FD8D565")
    IConsole2 : public IConsole
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Expand( 
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ BOOL bExpand) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsTaskpadViewPreferred( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatusText( 
            /* [string][in] */ LPOLESTR pszStatusText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsole2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsole2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsole2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHeader )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ LPHEADERCTRL pHeader);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetToolbar )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ LPTOOLBAR pToolbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultView )( 
            IConsole2 __RPC_FAR * This,
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryScopeImageList )( 
            IConsole2 __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultImageList )( 
            IConsole2 __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateAllViews )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ LPARAM data,
            /* [in] */ LONG_PTR hint);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MessageBox )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryConsoleVerb )( 
            IConsole2 __RPC_FAR * This,
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectScopeItem )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMainWindow )( 
            IConsole2 __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem,
            /* [in] */ unsigned long lOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ BOOL bExpand);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsTaskpadViewPreferred )( 
            IConsole2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusText )( 
            IConsole2 __RPC_FAR * This,
            /* [string][in] */ LPOLESTR pszStatusText);
        
        END_INTERFACE
    } IConsole2Vtbl;

    interface IConsole2
    {
        CONST_VTBL struct IConsole2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsole2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsole2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsole2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsole2_SetHeader(This,pHeader)	\
    (This)->lpVtbl -> SetHeader(This,pHeader)

#define IConsole2_SetToolbar(This,pToolbar)	\
    (This)->lpVtbl -> SetToolbar(This,pToolbar)

#define IConsole2_QueryResultView(This,pUnknown)	\
    (This)->lpVtbl -> QueryResultView(This,pUnknown)

#define IConsole2_QueryScopeImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryScopeImageList(This,ppImageList)

#define IConsole2_QueryResultImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryResultImageList(This,ppImageList)

#define IConsole2_UpdateAllViews(This,lpDataObject,data,hint)	\
    (This)->lpVtbl -> UpdateAllViews(This,lpDataObject,data,hint)

#define IConsole2_MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)	\
    (This)->lpVtbl -> MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)

#define IConsole2_QueryConsoleVerb(This,ppConsoleVerb)	\
    (This)->lpVtbl -> QueryConsoleVerb(This,ppConsoleVerb)

#define IConsole2_SelectScopeItem(This,hScopeItem)	\
    (This)->lpVtbl -> SelectScopeItem(This,hScopeItem)

#define IConsole2_GetMainWindow(This,phwnd)	\
    (This)->lpVtbl -> GetMainWindow(This,phwnd)

#define IConsole2_NewWindow(This,hScopeItem,lOptions)	\
    (This)->lpVtbl -> NewWindow(This,hScopeItem,lOptions)


#define IConsole2_Expand(This,hItem,bExpand)	\
    (This)->lpVtbl -> Expand(This,hItem,bExpand)

#define IConsole2_IsTaskpadViewPreferred(This)	\
    (This)->lpVtbl -> IsTaskpadViewPreferred(This)

#define IConsole2_SetStatusText(This,pszStatusText)	\
    (This)->lpVtbl -> SetStatusText(This,pszStatusText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole2_Expand_Proxy( 
    IConsole2 __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hItem,
    /* [in] */ BOOL bExpand);


void __RPC_STUB IConsole2_Expand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole2_IsTaskpadViewPreferred_Proxy( 
    IConsole2 __RPC_FAR * This);


void __RPC_STUB IConsole2_IsTaskpadViewPreferred_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole2_SetStatusText_Proxy( 
    IConsole2 __RPC_FAR * This,
    /* [string][in] */ LPOLESTR pszStatusText);


void __RPC_STUB IConsole2_SetStatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsole2_INTERFACE_DEFINED__ */


#ifndef __IDisplayHelp_INTERFACE_DEFINED__
#define __IDisplayHelp_INTERFACE_DEFINED__

/* interface IDisplayHelp */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDisplayHelp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cc593830-b926-11d1-8063-0000f875a9ce")
    IDisplayHelp : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowTopic( 
            /* [in] */ LPOLESTR pszHelpTopic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDisplayHelpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDisplayHelp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDisplayHelp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDisplayHelp __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowTopic )( 
            IDisplayHelp __RPC_FAR * This,
            /* [in] */ LPOLESTR pszHelpTopic);
        
        END_INTERFACE
    } IDisplayHelpVtbl;

    interface IDisplayHelp
    {
        CONST_VTBL struct IDisplayHelpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDisplayHelp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDisplayHelp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDisplayHelp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDisplayHelp_ShowTopic(This,pszHelpTopic)	\
    (This)->lpVtbl -> ShowTopic(This,pszHelpTopic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDisplayHelp_ShowTopic_Proxy( 
    IDisplayHelp __RPC_FAR * This,
    /* [in] */ LPOLESTR pszHelpTopic);


void __RPC_STUB IDisplayHelp_ShowTopic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDisplayHelp_INTERFACE_DEFINED__ */


#ifndef __IRequiredExtensions_INTERFACE_DEFINED__
#define __IRequiredExtensions_INTERFACE_DEFINED__

/* interface IRequiredExtensions */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IRequiredExtensions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72782D7A-A4A0-11d1-AF0F-00C04FB6DD2C")
    IRequiredExtensions : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnableAllExtensions( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFirstExtension( 
            /* [out] */ LPCLSID pExtCLSID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextExtension( 
            /* [out] */ LPCLSID pExtCLSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequiredExtensionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequiredExtensions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequiredExtensions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequiredExtensions __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableAllExtensions )( 
            IRequiredExtensions __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstExtension )( 
            IRequiredExtensions __RPC_FAR * This,
            /* [out] */ LPCLSID pExtCLSID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextExtension )( 
            IRequiredExtensions __RPC_FAR * This,
            /* [out] */ LPCLSID pExtCLSID);
        
        END_INTERFACE
    } IRequiredExtensionsVtbl;

    interface IRequiredExtensions
    {
        CONST_VTBL struct IRequiredExtensionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequiredExtensions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequiredExtensions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequiredExtensions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequiredExtensions_EnableAllExtensions(This)	\
    (This)->lpVtbl -> EnableAllExtensions(This)

#define IRequiredExtensions_GetFirstExtension(This,pExtCLSID)	\
    (This)->lpVtbl -> GetFirstExtension(This,pExtCLSID)

#define IRequiredExtensions_GetNextExtension(This,pExtCLSID)	\
    (This)->lpVtbl -> GetNextExtension(This,pExtCLSID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequiredExtensions_EnableAllExtensions_Proxy( 
    IRequiredExtensions __RPC_FAR * This);


void __RPC_STUB IRequiredExtensions_EnableAllExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequiredExtensions_GetFirstExtension_Proxy( 
    IRequiredExtensions __RPC_FAR * This,
    /* [out] */ LPCLSID pExtCLSID);


void __RPC_STUB IRequiredExtensions_GetFirstExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequiredExtensions_GetNextExtension_Proxy( 
    IRequiredExtensions __RPC_FAR * This,
    /* [out] */ LPCLSID pExtCLSID);


void __RPC_STUB IRequiredExtensions_GetNextExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequiredExtensions_INTERFACE_DEFINED__ */


#ifndef __IStringTable_INTERFACE_DEFINED__
#define __IStringTable_INTERFACE_DEFINED__

/* interface IStringTable */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IStringTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DE40B7A4-0F65-11d2-8E25-00C04F8ECD78")
    IStringTable : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddString( 
            /* [in] */ LPCOLESTR pszAdd,
            /* [out] */ MMC_STRING_ID __RPC_FAR *pStringID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ MMC_STRING_ID StringID,
            /* [in] */ ULONG cchBuffer,
            /* [size_is][out] */ LPOLESTR lpBuffer,
            /* [out] */ ULONG __RPC_FAR *pcchOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringLength( 
            /* [in] */ MMC_STRING_ID StringID,
            /* [out] */ ULONG __RPC_FAR *pcchString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteString( 
            /* [in] */ MMC_STRING_ID StringID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteAllStrings( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindString( 
            /* [in] */ LPCOLESTR pszFind,
            /* [out] */ MMC_STRING_ID __RPC_FAR *pStringID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Enumerate( 
            /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStringTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStringTable __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStringTable __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddString )( 
            IStringTable __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszAdd,
            /* [out] */ MMC_STRING_ID __RPC_FAR *pStringID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetString )( 
            IStringTable __RPC_FAR * This,
            /* [in] */ MMC_STRING_ID StringID,
            /* [in] */ ULONG cchBuffer,
            /* [size_is][out] */ LPOLESTR lpBuffer,
            /* [out] */ ULONG __RPC_FAR *pcchOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStringLength )( 
            IStringTable __RPC_FAR * This,
            /* [in] */ MMC_STRING_ID StringID,
            /* [out] */ ULONG __RPC_FAR *pcchString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteString )( 
            IStringTable __RPC_FAR * This,
            /* [in] */ MMC_STRING_ID StringID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllStrings )( 
            IStringTable __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindString )( 
            IStringTable __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFind,
            /* [out] */ MMC_STRING_ID __RPC_FAR *pStringID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enumerate )( 
            IStringTable __RPC_FAR * This,
            /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IStringTableVtbl;

    interface IStringTable
    {
        CONST_VTBL struct IStringTableVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStringTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStringTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStringTable_AddString(This,pszAdd,pStringID)	\
    (This)->lpVtbl -> AddString(This,pszAdd,pStringID)

#define IStringTable_GetString(This,StringID,cchBuffer,lpBuffer,pcchOut)	\
    (This)->lpVtbl -> GetString(This,StringID,cchBuffer,lpBuffer,pcchOut)

#define IStringTable_GetStringLength(This,StringID,pcchString)	\
    (This)->lpVtbl -> GetStringLength(This,StringID,pcchString)

#define IStringTable_DeleteString(This,StringID)	\
    (This)->lpVtbl -> DeleteString(This,StringID)

#define IStringTable_DeleteAllStrings(This)	\
    (This)->lpVtbl -> DeleteAllStrings(This)

#define IStringTable_FindString(This,pszFind,pStringID)	\
    (This)->lpVtbl -> FindString(This,pszFind,pStringID)

#define IStringTable_Enumerate(This,ppEnum)	\
    (This)->lpVtbl -> Enumerate(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_AddString_Proxy( 
    IStringTable __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszAdd,
    /* [out] */ MMC_STRING_ID __RPC_FAR *pStringID);


void __RPC_STUB IStringTable_AddString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_GetString_Proxy( 
    IStringTable __RPC_FAR * This,
    /* [in] */ MMC_STRING_ID StringID,
    /* [in] */ ULONG cchBuffer,
    /* [size_is][out] */ LPOLESTR lpBuffer,
    /* [out] */ ULONG __RPC_FAR *pcchOut);


void __RPC_STUB IStringTable_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_GetStringLength_Proxy( 
    IStringTable __RPC_FAR * This,
    /* [in] */ MMC_STRING_ID StringID,
    /* [out] */ ULONG __RPC_FAR *pcchString);


void __RPC_STUB IStringTable_GetStringLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_DeleteString_Proxy( 
    IStringTable __RPC_FAR * This,
    /* [in] */ MMC_STRING_ID StringID);


void __RPC_STUB IStringTable_DeleteString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_DeleteAllStrings_Proxy( 
    IStringTable __RPC_FAR * This);


void __RPC_STUB IStringTable_DeleteAllStrings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_FindString_Proxy( 
    IStringTable __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFind,
    /* [out] */ MMC_STRING_ID __RPC_FAR *pStringID);


void __RPC_STUB IStringTable_FindString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_Enumerate_Proxy( 
    IStringTable __RPC_FAR * This,
    /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IStringTable_Enumerate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStringTable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0139 */
/* [local] */ 

#endif // MMC_VER >= 0x0110
#if (MMC_VER >= 0x0120)
#define	HDI_HIDDEN	( 0x1 )

typedef struct _MMC_COLUMN_DATA
    {
    int nColIndex;
    DWORD dwFlags;
    int nWidth;
    ULONG_PTR ulReserved;
    }	MMC_COLUMN_DATA;

typedef struct _MMC_COLUMN_SET_DATA
    {
    int cbSize;
    int nNumCols;
    MMC_COLUMN_DATA __RPC_FAR *pColData;
    }	MMC_COLUMN_SET_DATA;

typedef struct _MMC_SORT_DATA
    {
    int nColIndex;
    DWORD dwSortOptions;
    ULONG_PTR ulReserved;
    }	MMC_SORT_DATA;

typedef struct _MMC_SORT_SET_DATA
    {
    int cbSize;
    int nNumItems;
    MMC_SORT_DATA __RPC_FAR *pSortData;
    }	MMC_SORT_SET_DATA;



extern RPC_IF_HANDLE __MIDL_itf_mmc_0139_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0139_v0_0_s_ifspec;

#ifndef __IColumnData_INTERFACE_DEFINED__
#define __IColumnData_INTERFACE_DEFINED__

/* interface IColumnData */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IColumnData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("547C1354-024D-11d3-A707-00C04F8EF4CB")
    IColumnData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnConfigData( 
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [in] */ MMC_COLUMN_SET_DATA __RPC_FAR *pColSetData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnConfigData( 
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [out] */ MMC_COLUMN_SET_DATA __RPC_FAR *__RPC_FAR *ppColSetData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnSortData( 
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [in] */ MMC_SORT_SET_DATA __RPC_FAR *pColSortData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnSortData( 
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [out] */ MMC_SORT_SET_DATA __RPC_FAR *__RPC_FAR *ppColSortData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColumnData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColumnData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColumnData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnConfigData )( 
            IColumnData __RPC_FAR * This,
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [in] */ MMC_COLUMN_SET_DATA __RPC_FAR *pColSetData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnConfigData )( 
            IColumnData __RPC_FAR * This,
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [out] */ MMC_COLUMN_SET_DATA __RPC_FAR *__RPC_FAR *ppColSetData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnSortData )( 
            IColumnData __RPC_FAR * This,
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [in] */ MMC_SORT_SET_DATA __RPC_FAR *pColSortData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnSortData )( 
            IColumnData __RPC_FAR * This,
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [out] */ MMC_SORT_SET_DATA __RPC_FAR *__RPC_FAR *ppColSortData);
        
        END_INTERFACE
    } IColumnDataVtbl;

    interface IColumnData
    {
        CONST_VTBL struct IColumnDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumnData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColumnData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColumnData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColumnData_SetColumnConfigData(This,pColID,pColSetData)	\
    (This)->lpVtbl -> SetColumnConfigData(This,pColID,pColSetData)

#define IColumnData_GetColumnConfigData(This,pColID,ppColSetData)	\
    (This)->lpVtbl -> GetColumnConfigData(This,pColID,ppColSetData)

#define IColumnData_SetColumnSortData(This,pColID,pColSortData)	\
    (This)->lpVtbl -> SetColumnSortData(This,pColID,pColSortData)

#define IColumnData_GetColumnSortData(This,pColID,ppColSortData)	\
    (This)->lpVtbl -> GetColumnSortData(This,pColID,ppColSortData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IColumnData_SetColumnConfigData_Proxy( 
    IColumnData __RPC_FAR * This,
    /* [in] */ SColumnSetID __RPC_FAR *pColID,
    /* [in] */ MMC_COLUMN_SET_DATA __RPC_FAR *pColSetData);


void __RPC_STUB IColumnData_SetColumnConfigData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IColumnData_GetColumnConfigData_Proxy( 
    IColumnData __RPC_FAR * This,
    /* [in] */ SColumnSetID __RPC_FAR *pColID,
    /* [out] */ MMC_COLUMN_SET_DATA __RPC_FAR *__RPC_FAR *ppColSetData);


void __RPC_STUB IColumnData_GetColumnConfigData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IColumnData_SetColumnSortData_Proxy( 
    IColumnData __RPC_FAR * This,
    /* [in] */ SColumnSetID __RPC_FAR *pColID,
    /* [in] */ MMC_SORT_SET_DATA __RPC_FAR *pColSortData);


void __RPC_STUB IColumnData_SetColumnSortData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IColumnData_GetColumnSortData_Proxy( 
    IColumnData __RPC_FAR * This,
    /* [in] */ SColumnSetID __RPC_FAR *pColID,
    /* [out] */ MMC_SORT_SET_DATA __RPC_FAR *__RPC_FAR *ppColSortData);


void __RPC_STUB IColumnData_GetColumnSortData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IColumnData_INTERFACE_DEFINED__ */


#ifndef __IMessageView_INTERFACE_DEFINED__
#define __IMessageView_INTERFACE_DEFINED__

/* interface IMessageView */
/* [unique][helpstring][uuid][object] */ 

typedef 
enum tagIconIdentifier
    {	Icon_None	= 0,
	Icon_Error	= 32513,
	Icon_Question	= 32514,
	Icon_Warning	= 32515,
	Icon_Information	= 32516,
	Icon_First	= Icon_Error,
	Icon_Last	= Icon_Information
    }	IconIdentifier;


EXTERN_C const IID IID_IMessageView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80F94174-FCCC-11d2-B991-00C04F8ECD78")
    IMessageView : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTitleText( 
            /* [in] */ LPCOLESTR pszTitleText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetBodyText( 
            /* [in] */ LPCOLESTR pszBodyText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIcon( 
            /* [in] */ IconIdentifier id) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMessageViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMessageView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMessageView __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMessageView __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTitleText )( 
            IMessageView __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszTitleText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBodyText )( 
            IMessageView __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszBodyText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIcon )( 
            IMessageView __RPC_FAR * This,
            /* [in] */ IconIdentifier id);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IMessageView __RPC_FAR * This);
        
        END_INTERFACE
    } IMessageViewVtbl;

    interface IMessageView
    {
        CONST_VTBL struct IMessageViewVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMessageView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMessageView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMessageView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMessageView_SetTitleText(This,pszTitleText)	\
    (This)->lpVtbl -> SetTitleText(This,pszTitleText)

#define IMessageView_SetBodyText(This,pszBodyText)	\
    (This)->lpVtbl -> SetBodyText(This,pszBodyText)

#define IMessageView_SetIcon(This,id)	\
    (This)->lpVtbl -> SetIcon(This,id)

#define IMessageView_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMessageView_SetTitleText_Proxy( 
    IMessageView __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszTitleText);


void __RPC_STUB IMessageView_SetTitleText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMessageView_SetBodyText_Proxy( 
    IMessageView __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszBodyText);


void __RPC_STUB IMessageView_SetBodyText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMessageView_SetIcon_Proxy( 
    IMessageView __RPC_FAR * This,
    /* [in] */ IconIdentifier id);


void __RPC_STUB IMessageView_SetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMessageView_Clear_Proxy( 
    IMessageView __RPC_FAR * This);


void __RPC_STUB IMessageView_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMessageView_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0141 */
/* [local] */ 

typedef struct _RDCITEMHDR
    {
    DWORD dwFlags;
    MMC_COOKIE cookie;
    LPARAM lpReserved;
    }	RDITEMHDR;

#define	RDCI_ScopeItem	( 0x80000000 )

typedef struct _RDCOMPARE
    {
    DWORD cbSize;
    DWORD dwFlags;
    int nColumn;
    LPARAM lUserParam;
    RDITEMHDR __RPC_FAR *prdch1;
    RDITEMHDR __RPC_FAR *prdch2;
    }	RDCOMPARE;



extern RPC_IF_HANDLE __MIDL_itf_mmc_0141_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0141_v0_0_s_ifspec;

#ifndef __IResultDataCompareEx_INTERFACE_DEFINED__
#define __IResultDataCompareEx_INTERFACE_DEFINED__

/* interface IResultDataCompareEx */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IResultDataCompareEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96933476-0251-11d3-AEB0-00C04F8ECD78")
    IResultDataCompareEx : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ RDCOMPARE __RPC_FAR *prdc,
            /* [out] */ int __RPC_FAR *pnResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultDataCompareExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultDataCompareEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultDataCompareEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultDataCompareEx __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Compare )( 
            IResultDataCompareEx __RPC_FAR * This,
            /* [in] */ RDCOMPARE __RPC_FAR *prdc,
            /* [out] */ int __RPC_FAR *pnResult);
        
        END_INTERFACE
    } IResultDataCompareExVtbl;

    interface IResultDataCompareEx
    {
        CONST_VTBL struct IResultDataCompareExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultDataCompareEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultDataCompareEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultDataCompareEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultDataCompareEx_Compare(This,prdc,pnResult)	\
    (This)->lpVtbl -> Compare(This,prdc,pnResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataCompareEx_Compare_Proxy( 
    IResultDataCompareEx __RPC_FAR * This,
    /* [in] */ RDCOMPARE __RPC_FAR *prdc,
    /* [out] */ int __RPC_FAR *pnResult);


void __RPC_STUB IResultDataCompareEx_Compare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultDataCompareEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0142 */
/* [local] */ 

#endif // MMC_VER >= 0x0120


extern RPC_IF_HANDLE __MIDL_itf_mmc_0142_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0142_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HBITMAP_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HBITMAP __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBITMAP_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBITMAP __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBITMAP_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBITMAP __RPC_FAR * ); 
void                      __RPC_USER  HBITMAP_UserFree(     unsigned long __RPC_FAR *, HBITMAP __RPC_FAR * ); 

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HICON __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HICON __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HICON __RPC_FAR * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long __RPC_FAR *, HICON __RPC_FAR * ); 

unsigned long             __RPC_USER  HPALETTE_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HPALETTE __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HPALETTE_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HPALETTE __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HPALETTE_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HPALETTE __RPC_FAR * ); 
void                      __RPC_USER  HPALETTE_UserFree(     unsigned long __RPC_FAR *, HPALETTE __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\mmfutil\mmfutil.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// MMFUtil.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f MMFUtilps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include "initguid.h"
#include "MMFUtil.h"

#include "MMFUtil_i.c"


CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\mmfutil\precomp.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\mmfutil\msgdlg.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __MSGDLGEXTERNS__
#define __MSGDLGEXTERNS__

#include "DeclSpec.h"

// pick icon based on severity code.
#define BASED_ON_HRESULT 0	// use with uType
#define BASED_ON_SRC 0		// use with ERROR_SRC

typedef enum {
	ConnectServer = 1,
	PutInstance = 2,
	GetSecurityDescriptor = 3,
	SetSecurityDescriptor = 4,
} ERROR_SRC;

POLARITY int DisplayUserMessage(HWND hWnd,
							HINSTANCE inst,
							UINT caption, 
							UINT clientMsg, 
							ERROR_SRC src,
							HRESULT sc, 
							UINT uType = BASED_ON_HRESULT);

POLARITY int DisplayUserMessage(HWND hWnd,
								LPCTSTR lpCaption,
								LPCTSTR lpClientMsg,
								ERROR_SRC src,
								HRESULT sc,
								UINT uType = BASED_ON_HRESULT);

// NOTE: send WM_USER + 1 to make it go away.
POLARITY INT_PTR DisplayAVIBox(HWND hWnd,
							LPCTSTR lpCaption,
							LPCTSTR lpClientMsg,
							HWND *boxHwnd);

#endif __MSGDLGEXTERNS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\mmfutil\precomp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_)
#define AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
};

extern CExeModule  _Module;

#include <atlcom.h>
#include <atlwin.h>


#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\mmfutil\resource.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MMFUtil.rc
//
#define IDS_PROJNAME                    100
#define IDD_ANIMATE                     101
#define IDD_DIALOG1                     129
#define IDS_ERROR_UNKN_ERROR_FMT        130
#define IDS_ERROR_FMT                   131
#define IDC_BUTTONADVANCED              1000
#define IDC_ANIMATE                     1000
#define IDC_STATICCLIENTMSG             1001
#define IDC_STATICPROVIDERNAME          1002
#define IDC_STATICOPERATION             1003
#define IDC_STATICPARAMETER             1004
#define IDC_STATICFRAME                 1005
#define IDC_STATICHMOMMSG               1006
#define IDC_CODEPLUSMESSAGE             1007
#define IDC_MYICON                      1009
#define IDC_MSG                         1019
#define IDR_AVIWAIT                     1020
#define S1E8004100e						1021
#define S1E80080005						1022
#define S4E80041003						1023

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         132
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\mmfutil\msgdlg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// MsgDlg.cpp : Defines the initialization routines for the DLL.
//

#include "precomp.h"
#include "MsgDlg.h"
#include "wbemError.h"
#include "resource.h"
#include "commctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//------------------------------------------------------------
POLARITY int DisplayUserMessage(HWND hWnd,
							HINSTANCE inst,
							UINT caption, 
							UINT clientMsg, 
							ERROR_SRC src,
							HRESULT sc, 
							UINT uType)
{
	//EXTASSERT(inst);
	//EXTASSERT(caption);

	TCHAR tCaption[100] = {0};
	TCHAR tClientMsg[256] = {0};
	DWORD resError = 0;

	if(LoadString(inst, caption, tCaption, 100) == 0)
	{
		return 0;
	}
	if(clientMsg == BASED_ON_SRC)
	{
		HINSTANCE UtilInst = GetModuleHandle(_T("MMFUtil.dll"));
		WCHAR resName[16] = {0};

		// FMT: "S<src>E<sc>"
		wsprintf(resName, L"S%dE%x", src, sc);

		if(_wcsicmp(resName,L"S1E8004100e") == 0)
		{
			LoadString(UtilInst,S1E8004100e,tClientMsg,256);
		}
		else if(_wcsicmp(resName,L"S1E80080005") == 0)
		{
			LoadString(UtilInst,S1E80080005,tClientMsg,256);
		}
		else if(_wcsicmp(resName,L"S4E80041003") == 0)
		{
			LoadString(UtilInst,S4E80041003,tClientMsg,256);
		}
	}
	else 		    // use the one passed in.
	{
		LoadString(inst, clientMsg, tClientMsg, 256);
	}

	return DisplayUserMessage(hWnd, tCaption, 
								(wcslen(tClientMsg) > 0 ? tClientMsg : NULL), 
								src, sc, uType);
}

//------------------------------------------------------------
POLARITY int DisplayUserMessage(HWND hWnd,
								LPCTSTR lpCaption,
								LPCTSTR lpClientMsg,
								ERROR_SRC src,
								HRESULT sc,
								UINT uType)
{
#define MAX_MSG 512

	TCHAR errMsg[MAX_MSG] = {0};
   UINT sevIcon = 0;

	if(ErrorStringEx(sc, errMsg, MAX_MSG,
					   &sevIcon))
	{
		// if no icon explicitly selected...
		if(!(uType & MB_ICONMASK))
		{
			// use the recommendation.
			uType |= sevIcon;
		}

		// append the clientmsg if there is one.
		if(lpClientMsg)
		{
			_tcscat(errMsg, _T("\n\n"));
			_tcscat(errMsg, lpClientMsg);
		}

		// do it.
		return MessageBox(hWnd, errMsg,
							lpCaption, uType);
	}
	else
	{
		// failed.
		return 0;
	}
	return 0;
}

//---------------------------------------------------------
typedef struct {
	LPCTSTR lpCaption;
	LPCTSTR lpClientMsg;
	UINT uAnim;
	HWND *boxHwnd;
} ANIMCONFIG;

INT_PTR CALLBACK AnimDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
	INT_PTR retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{//BEGIN
			//lParam = ANIMCONFIG *

			ANIMCONFIG *cfg = (ANIMCONFIG *)lParam;
			*(cfg->boxHwnd) = hwndDlg;

			// save this pointer for the WM_DESTROY.
			SetWindowLongPtr(hwndDlg, DWLP_USER, (LPARAM)cfg->boxHwnd);

			HWND hAnim = GetDlgItem(hwndDlg, IDC_ANIMATE);
			HWND hMsg = GetDlgItem(hwndDlg, IDC_MSG);

			Animate_Open(hAnim, MAKEINTRESOURCE(cfg->uAnim));

			SetWindowText(hwndDlg, cfg->lpCaption);
			SetWindowText(hMsg, cfg->lpClientMsg);

			retval = TRUE;
		}//END
		break;

	case WM_USER + 20:  //WM_ASYNC_CIMOM_CONNECTED
		// the client has completed 'whatever' and I should
		// claim victory and go away now.
		EndDialog(hwndDlg, IDOK);
		break;

	case WM_COMMAND:
		// they're only one button.
		if(HIWORD(wParam) == BN_CLICKED)
		{
			// I'm going away now so anybody that has a ptr to my
			// hwnd (which I gave out in my WM_INITDIALOG) shouldn't
			// use it anymore.
			HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			*me = 0;
			EndDialog(hwndDlg, IDCANCEL);
		}
		retval = TRUE; // I processed it.
		break;

	case WM_DESTROY:
		{// BEGIN
			// I'm going away now so anybody that has a ptr to my
			// hwnd (which I gave out in my WM_INITDIALOG) shouldn't
			// use it anymore.
			HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			*me = 0;
			retval = TRUE; // I processed it.
		} //END
		break;

	default:
		retval = FALSE; // I did NOT process this msg.
		break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
POLARITY INT_PTR DisplayAVIBox(HWND hWnd,
							LPCTSTR lpCaption,
							LPCTSTR lpClientMsg,
							HWND *boxHwnd)
{
	ANIMCONFIG cfg = {lpCaption, lpClientMsg, IDR_AVIWAIT, boxHwnd};

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_ANIMATE), 
							hWnd, AnimDlgProc, 
							(LPARAM)&cfg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\servdeps\precomp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_)
#define AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
};

extern CExeModule  _Module;

#include <atlcom.h>
#include <atlwin.h>


#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\mmfutil\wbemerror.h ===
#ifndef __WBEMERROR__
#define __WBEMERROR__
//=============================================================================
//
//                              WbemError.h
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//	Implements string table based, error msgs for all of wbem.
//
//  History:
//
//      a-khint  5-mar-98       Created.
//
//============================================================================= 
#include "precomp.h"
#include "DeclSpec.h"

//---------------------------------------------------------
// ErrorString: Extracts convenient information out of the
//				SCODE (HRESULT). If its not a wbem error,
//				system error msgs will be checked.
// Parms:
//		sc - The error code from any facility.
//		errMsg - pointer to an allocated string buffer for
//					the error msg. Can be NULL.
//		errSize - the size of errMsg in chars.
//
//		facility - pointer to an allocated string buffer for
//					the facility name. Can be NULL.
//		facSize - the size of errMsg in chars.
//
//		sevIcon - ptr to receive the appropriate MB_ICON*
//					value for the sc. Can be NULL. Value
//					should be OR'ed with the MessageBox()
//					uType.
//---------------------------------------------------------
extern "C"
{

// formats the facility part for you too.
POLARITY bool ErrorStringEx(HRESULT hr, 
						   TCHAR *errMsg, UINT errSize,
						   UINT *sevIcon = NULL);

}
#endif __WBEMERROR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\servdeps\deppage.cpp ===
// Copyright (c) 1997-2002 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "DepPage.h"

// avoid some warnings.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
#include "resource.h"
#include <stdlib.h>
#include <TCHAR.h>
#include "..\Common\util.h"
#include <regstr.h>
#include "..\common\ConnectThread.h"
#include "..\MMFUtil\MsgDlg.h"
#include "winuser.h"


BOOL AfxIsValidAddress(const void* lp, 
							  UINT nBytes, 
							  BOOL bReadWrite)
{
	// simple version using Win-32 APIs for pointer validation.
	return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
		(!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}


const wchar_t *CFServiceName = L"FILEMGMT_SNAPIN_SERVICE_NAME";
const wchar_t *CFServiceDisplayName = L"FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME";


//--------------------------------------------------------------
DependencyPage::DependencyPage(WbemConnectThread *pConnectThread,
								IDataObject *pDataObject, 
								long lNotifyHandle, bool bDeleteHandle, TCHAR* pTitle)
					  : PageHelper(pConnectThread),
						CSnapInPropertyPageImpl<DependencyPage> (pTitle),
						m_lNotifyHandle(lNotifyHandle),
						m_bDeleteHandle(bDeleteHandle),
						m_qLang("WQL"),
						m_NameProp("Name"),
						m_DispNameProp("DisplayName")
{
	m_servIcon = 0;
	m_sysDriverIcon = 0;
	m_emptyIcon = 0;
	m_groupIcon = 0;

	ATLTRACE(L"dependency Page CTOR\n");

	m_queryFormat = new TCHAR[QUERY_SIZE];
	m_queryTemp = new TCHAR[QUERY_SIZE];

	Extract(pDataObject, L"FILEMGMT_SNAPIN_SERVICE_NAME", m_ServiceName);
	Extract(pDataObject, L"FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME", m_ServiceDispName);
}

//--------------------------------------------------------------
DependencyPage::~DependencyPage()
{
	ATLTRACE(L"dependency Page DTOR\n");
	delete[] m_queryFormat;
	delete[] m_queryTemp;
}

//--------------------------------------------------------------
void DependencyPage::BuildQuery(TV_ITEM *fmNode, 
								QUERY_TYPE queryType,
								bool depends, 
								bstr_t &query)
{
	// clean the working space.
	memset(m_queryFormat, 0, QUERY_SIZE * sizeof(TCHAR));
	memset(m_queryTemp, 0, QUERY_SIZE * sizeof(TCHAR));

	// here's the WQL syntax format.
	switch(queryType)
	{
	case DepService:
		_tcscpy(m_queryFormat, 
			_T("Associators of {Win32_BaseService.Name=\"%s\"} where Role=%s AssocClass=Win32_DependentService"));
		
		// build the query for this level.
		_sntprintf(m_queryTemp, QUERY_SIZE- 1, m_queryFormat, 
								(LPCTSTR)((ITEMEXTRA *)fmNode->lParam)->realName, 
								(depends ? _T("Dependent") : _T("Antecedent")));

		break;
	case DepGroup:
		_tcscpy(m_queryFormat, 
			_T("Associators of {Win32_BaseService.Name=\"%s\"} where ResultClass=Win32_LoadOrderGroup Role=%s AssocClass=Win32_LoadOrderGroupServiceDependencies"));

		// build the query for this level.
		_sntprintf(m_queryTemp, QUERY_SIZE- 1, m_queryFormat, 
								(LPCTSTR)((ITEMEXTRA *)fmNode->lParam)->realName, 
								(depends ? _T("Dependent") : _T("Antecedent")));		
		break;

	case GroupMember:
		_tcscpy(m_queryFormat, 
			_T("Associators of {Win32_LoadOrderGroup.Name=\"%s\"} where Role=GroupComponent AssocClass=Win32_LoadOrderGroupServiceMembers"));
//			L"Associators of {Win32_LoadOrderGroup.Name=\"%s\"} where ResultClass=Win32_Service Role=GroupComponent AssocClass=Win32_LoadOrderGroupServiceMembers");

		// build the query for this level.
		_sntprintf(m_queryTemp, QUERY_SIZE- 1, m_queryFormat, 
							(LPCTSTR)((ITEMEXTRA *)fmNode->lParam)->realName);
		break;
	} // endswitch
	m_queryTemp[QUERY_SIZE - 1] = 0;
	// cast to bstr_t and return.
	query = m_queryTemp;
}

//--------------------------------------------------------------
void DependencyPage::LoadLeaves(HWND hTree, TV_ITEM *fmNode, bool depends )
{
	bstr_t query;
	NODE_TYPE nodeType = ((ITEMEXTRA *)fmNode->lParam)->nodeType;
	bool foundIt = false;

//	HourGlass(true);

	switch(nodeType)
	{
	case ServiceNode:
		// NOTE: services can depend on groups but not the
		// other way around.
		if(depends)
		{
			//load groups.
			BuildQuery(fmNode, DepGroup, depends, query);
			foundIt = Load(hTree, fmNode, query, GroupNode);
		}

		// load services.
		BuildQuery(fmNode, DepService, depends, query);
		foundIt |= Load(hTree, fmNode, query, ServiceNode);
		break;

	case GroupNode:
		// NOTE: 'depends' doesn't matter in this case.
		// load group members.
		BuildQuery(fmNode, GroupMember, depends, query);
		foundIt = Load(hTree, fmNode, query, ServiceNode);
		break;

	}//endswitch

	//TODO: Decide opn what to do for this
//	HourGlass(false);

	if(!foundIt)
	{
		NothingMore(hTree, fmNode);
		if(depends)
		{
			if(fmNode->hItem == TVI_ROOT)
			{
				::EnableWindow(GetDlgItem(IDC_DEPENDS_LBL), FALSE);
			}
		}
		else
		{
			if(fmNode->hItem == TVI_ROOT)
			{
				::EnableWindow(GetDlgItem(IDC_NEEDED_LBL), FALSE);
			}
		}
	}
}

//--------------------------------------------------------------
// READ: In 'hTree', run 'query' and make the children
// 'childType' nodes under 'fmNode'.
bool DependencyPage::Load(HWND hTree, TV_ITEM *fmNode, bstr_t query,
							NODE_TYPE childType)
{
	HRESULT  hRes;
	variant_t pRealName, pDispName;
	ULONG uReturned;

	IWbemClassObject *pOther = NULL;
	IEnumWbemClassObject *pEnumOther = NULL;

	TV_INSERTSTRUCT leaf;
	leaf.hInsertAfter = TVI_SORT;
	leaf.hParent = fmNode->hItem;
	bool foundOne = false;

    ATLTRACE(L"query started\n");

	hRes = m_WbemServices.ExecQuery(m_qLang, query,
										WBEM_FLAG_RETURN_IMMEDIATELY |
										WBEM_FLAG_FORWARD_ONLY,
										&pEnumOther);
	//-------------------
	// query for all related services or groups.
	if(hRes == S_OK)
	{
        ATLTRACE(L"query worked %x\n", hRes);
		//-------------------
		// enumerate through services.
		while(SUCCEEDED(hRes = pEnumOther->Next(500, 1, &pOther, &uReturned)))
		{
			if(hRes == WBEM_S_TIMEDOUT)
				continue;

			if(uReturned != 1)
			{
			    ATLTRACE(L"uReturned failed %x: %s \n", hRes, query);
				break;
			}

			foundOne = true;

			//-------------------
			// get the node's name(s).
			switch(childType)
			{
			case ServiceNode:
			    hRes = pOther->Get(m_DispNameProp, 0, &pDispName, NULL, NULL);
				hRes = pOther->Get(m_NameProp, 0, &pRealName, NULL, NULL);
				if(SUCCEEDED(hRes))
				{
				    hRes = pOther->Get(m_DispNameProp, 0, &pDispName, NULL, NULL);
				}
				break;

			case GroupNode:
				hRes = pOther->Get(m_NameProp, 0, &pRealName, NULL, NULL);
				if(SUCCEEDED(hRes))
				{
					pDispName = pRealName;
				}
				break;

			}// endswitch


			// got the properties ok?
			if(SUCCEEDED(hRes))
			{
				// add the leaf.
				leaf.item.mask =  TVIF_TEXT | TVIF_PARAM | 
									TVIF_CHILDREN |TVIF_IMAGE |TVIF_SELECTEDIMAGE; 
				leaf.item.hItem = 0; 
				leaf.item.state = 0; 
				leaf.item.stateMask = 0; 
				if(pDispName.vt == VT_BSTR)
				{
					leaf.item.pszText = CloneString((bstr_t)pDispName);
				}
				else
				{
					leaf.item.pszText = CloneString((bstr_t)pRealName);
				}
				leaf.item.cchTextMax = ARRAYSIZE(leaf.item.pszText); 

				TCHAR pszCreationClassName[20];
				_tcscpy(pszCreationClassName,_T("CreationClassName"));

				variant_t pCreationName;
				_bstr_t strCreationClassName;

				// set the icon based on 'childType'
				switch(childType)
				{
				case ServiceNode:
					//Here we will have to change the icon depending on whether it is a win32_service or
					//Win32_SystemDriver

					pOther->Get(pszCreationClassName, 0, &pCreationName, NULL, NULL);
					strCreationClassName = pCreationName.bstrVal;

					if(_tcsicmp(strCreationClassName,_T("Win32_Service")) == 0)
					{
						leaf.item.iImage = m_servIcon; 
						leaf.item.iSelectedImage = m_servIcon; 
					}
					else
					{
						leaf.item.iImage = m_sysDriverIcon; 
						leaf.item.iSelectedImage = m_sysDriverIcon; 
					}
					break;

				case GroupNode:
					leaf.item.iImage = m_groupIcon; 
					leaf.item.iSelectedImage = m_groupIcon; 
					break;

				} // endswitch

				// turn on the '+' sign.
				leaf.item.cChildren = 1; 

				// set internal data.
				ITEMEXTRA *extra = new ITEMEXTRA;
                if (extra != NULL)
                {
                    extra->loaded = false;
                    extra->nodeType = childType;
                    // true name.
                    extra->realName = CloneString((bstr_t)pRealName);
                    leaf.item.lParam = (LPARAM) extra;

                    TreeView_InsertItem(hTree, &leaf);

                    // if there is a parent...
                    if(fmNode->hItem != TVI_ROOT)
                    {
                    // indicate that the parent's children have been
                    // loaded.  This helps optimize for collapsing/re-
                    // expanding.
                    fmNode->mask =  TVIF_PARAM | TVIF_HANDLE;
                    ((ITEMEXTRA *)fmNode->lParam)->loaded = true;
                    TreeView_SetItem(hTree, fmNode);
                    }
                }

			} // endif Get() user name

			// done with the ClassObject
			if (pOther)
			{ 
				pOther->Release(); 
				pOther = NULL;
			}

		} //endwhile Next()
			    
		ATLTRACE(L"while %x: %s \n", hRes, (wchar_t *)query);


		// release the enumerator.
		if(pEnumOther)
		{ 
			pEnumOther->Release(); 
			pEnumOther = NULL;
		}
	}
	else
	{
	    ATLTRACE(L"query failed %x: %s \n", hRes, query);

	} //endif ExecQuery()

		// if nothing found...
	return foundOne;
}

//---------------------------------------------------
void DependencyPage::NothingMore(HWND hTree, TV_ITEM *fmNode)
{
	TV_INSERTSTRUCT leaf;
	leaf.hInsertAfter = TVI_SORT;
	leaf.hParent = fmNode->hItem;

	// and its the root...
	if(fmNode->hItem == TVI_ROOT)
	{
		// indicate an 'empty' tree.
		leaf.item.pszText = new TCHAR[100];

		if( NULL == leaf.item.pszText ) return;

		leaf.item.cchTextMax = 100;
		::LoadString(HINST_THISDLL, IDS_NO_DEPS, 
						leaf.item.pszText, 
						leaf.item.cchTextMax);

		leaf.item.mask =  TVIF_TEXT | TVIF_PARAM |
							TVIF_CHILDREN | TVIF_IMAGE |
							TVIF_SELECTEDIMAGE;
		leaf.item.hItem = 0;
		leaf.item.state = 0;
		leaf.item.stateMask = 0; 
		leaf.item.iImage = m_emptyIcon; 
		leaf.item.iSelectedImage = m_emptyIcon; 
		leaf.item.cChildren = 0; 

		ITEMEXTRA *extra = new ITEMEXTRA;
		if(extra == NULL)
                {
                	delete[] leaf.item.pszText;
			return;
                }
		extra->loaded = false;
		extra->nodeType = ServiceNode;
		extra->realName = NULL; // to be safe during cleanup.
		leaf.item.lParam = (LPARAM) extra;
		TreeView_InsertItem(hTree, &leaf);
		::EnableWindow(hTree, FALSE);
		delete[] leaf.item.pszText;
	}
	else // not the root.
	{
		// Cant drill down anymore.
		// Turn off the [+] symbol.
		fmNode->mask =  TVIF_CHILDREN | TVIF_HANDLE; 
		fmNode->cChildren = 0; 
		TreeView_SetItem(hTree, fmNode);
	}
}

//--------------------------------------------------------------
void DependencyPage::TwoLines(UINT uID, LPCTSTR staticString, LPCTSTR inStr, LPTSTR outStr,bool bStaticFirst)
{
	HWND ctl = ::GetDlgItem(m_hWnd, uID);
	HDC hDC = ::GetDC(ctl);

	//THIS IS A HACK. I COULD NOT CALCULATE THE ACTUAL WIDTH OF THE CONTROL
	//IN LOGICAL UNITS. SO AS OF NOW, CALCULATED MANUALLY AND HARDCODING IT.
	int ctlWidth = 509;
	TCHAR strTemp[1024];
	TCHAR *strCurr;
	int lenstrTemp;
	SIZE sizeTemp;
	int nFit = 0;

	//First we will try whether the whole string fits in the space
	if(bStaticFirst == true)
	{
		_sntprintf(strTemp, 1023, _T("%s \"%s\""),staticString,inStr);
	}
	else
	{
		_sntprintf(strTemp, 1023, _T("\"%s\" %s"),inStr,staticString);
	}
	strTemp[1023] = 0;
	strCurr = strTemp;

	lenstrTemp = lstrlen(strTemp);

	GetTextExtentExPoint(hDC,strTemp,lenstrTemp,ctlWidth,&nFit,NULL,&sizeTemp);

	if(lenstrTemp <= nFit)
	{
		//The whole string will fit in a line. So we will all a \r\n in the beginning
		_sntprintf(outStr, 1023, _T("\r\n%s"),strTemp);
		outStr[1023] = 0;
		return;
	}

	//Now we will try if the whole string atleast fits in 2 lines.
	strCurr += nFit;

	int nFit1;
	lenstrTemp = lstrlen(strCurr);

	GetTextExtentExPoint(hDC,strCurr,lenstrTemp,ctlWidth,&nFit1,NULL,&sizeTemp);

	if(lenstrTemp <= nFit1)
	{
		//The whole string will fit in 2 lines. So we will all a \r\n in the end of the first line

		TCHAR strTemp1[1024];
		_tcsncpy(strTemp1,strTemp,nFit);
		strTemp1[nFit] = _T('\0');
		_sntprintf(outStr,1023,_T("%s\r\n%s"),strTemp1,strCurr);
		outStr[1023] = 0;
		return;
	}

	//NOW since it won't fit in 2 lines, we will have to do some calculations and
	//add a "..." to the end of the instr so that it will fit in 2 lines.

	//If the static string is in the from, then we can easily do it.
	TCHAR strLast[5];
	_tcscpy(strLast,_T("...\""));
	int sizeLast = lstrlen(strLast);

	SIZE sz1;
	GetTextExtentPoint32(hDC,strLast,sizeLast,&sz1);
	TCHAR strTemp1[1024];
	_tcsncpy(strTemp1,strTemp,nFit);
	strTemp1[nFit] = _T('\0');

	if(bStaticFirst == true)
	{
		TCHAR strTemp2[10];

		//Now take characters from the end of the array and match it until the 
		//width needed to print is greater than the "..."" string
		bool bFit = false;
		int nStart = nFit1 - 4;
		int nStart1;
		SIZE sz2;
		while(bFit == false)
		{
			nStart1 = nStart;
			for(int i=0; i < nFit1 - nStart; i++)
			{
				strTemp2[i] = strCurr[nStart1];
				nStart1 ++;
			}

			strTemp2[i] = _T('\0');

			GetTextExtentPoint32(hDC,strTemp2,nFit1 - nStart,&sz2);

			if(sz2.cx < sz1.cx)
			{
				nStart --;
			}
			else
			{
				break;
			}
		}
		
		strCurr[nStart] = _T('\0');
		_sntprintf(outStr,1023,_T("%s\r\n%s%s"),strTemp1,strCurr,strLast);
		outStr[1023] = 0;
		return;
	}
	else
	{
		//Now we will have to add strLast to the end of trimmed string.
		//Since it will be the same in the first line, we will first calculate fit1 again.

		SIZE szFinal;
		TCHAR strFinal[1024];

		_sntprintf(strFinal,1023,_T("%s %s"),strLast,staticString);		
		strFinal[1023] = 0;

		GetTextExtentPoint32(hDC,strFinal,lstrlen(strFinal),&szFinal);

		//Now subtract szFinal from the ctlWidth and calculate the number of characters
		//that will fit in to that space
	
		GetTextExtentExPoint(hDC,strCurr,lstrlen(strCurr),ctlWidth - szFinal.cx ,&nFit1,NULL,&sizeTemp);
		strCurr[nFit1-1] = _T('\0');

		_sntprintf(outStr,1023,_T("%s\r\n%s%s"),strTemp1,strCurr,strFinal);
		outStr[1023] = 0;
		return;
	}
}

//--------------------------------------------------------------
LRESULT DependencyPage::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	m_hDlg = m_hWnd;

	//TODO: Check this out
	if(m_pgConnectThread)
	{
		m_pgConnectThread->SendPtr(m_hWnd);
	}

	TCHAR szBuffer1[100] = {0}, szBuffer2[256] = {0};

    SetDlgItemText(IDC_DEPENDS_SRVC, (wchar_t *)m_ServiceDispName);

	// set the nice bitmap.
    SetClearBitmap(GetDlgItem(IDC_PICT ), MAKEINTRESOURCE( IDB_SERVICE ), 0);

	// create an empty imagelist.
	HIMAGELIST hImageList = ImageList_Create(16, 16, ILC_COLOR8|ILC_MASK, 3, 0);

	// add an icon
	m_servIcon = ImageList_AddIcon(hImageList, 
								   LoadIcon(HINST_THISDLL, 
									MAKEINTRESOURCE(IDI_SERVICE)));

	m_sysDriverIcon = ImageList_AddIcon(hImageList, 
								   LoadIcon(HINST_THISDLL, 
									MAKEINTRESOURCE(IDI_SYSTEMDRIVER)));


	m_emptyIcon = ImageList_AddIcon(hImageList, 
								   LoadIcon(NULL, 
									MAKEINTRESOURCE(IDI_INFORMATION)));
	
	m_groupIcon = ImageList_AddIcon(hImageList, 
								   LoadIcon(HINST_THISDLL, 
									MAKEINTRESOURCE(IDI_SERVGROUP)));

	// sent it to the trees.
	TreeView_SetImageList(GetDlgItem(IDC_DEPENDS_TREE), 
							hImageList, 
							TVSIL_NORMAL);

	TreeView_SetImageList(GetDlgItem(IDC_NEEDED_TREE), 
							hImageList, 
							TVSIL_NORMAL);

	InvalidateRect(NULL);
    UpdateWindow();
    ATLTRACE(L"UpdateWindow() fm Init\n");

	// can we get data yet?
    ::PostMessage(m_hDlg, WM_ENUM_NOW, 0, 0);


	HourGlass(true);
	return S_OK;
}
//--------------------------------------------------------------
void DependencyPage::LoadTrees(void)
{

    ATLTRACE(L"checking service\n");

	// did that background connection thread work yet?
	if(ServiceIsReady(IDS_DISPLAY_NAME, IDS_CONNECTING, IDS_BAD_CONNECT))
	{	
		//Now we will check if there is already some nodes.
		//If it is, then it means that we don't have to enumerate it again.
		//This normally happens in the first time when we connect to a remote machine
		
/*		//We will clear the nodes if it already exists
		TreeView_DeleteAllItems(GetDlgItem(IDC_DEPENDS_TREE));
		TreeView_DeleteAllItems(GetDlgItem(IDC_NEEDED_TREE));
*/
		if(TreeView_GetCount(GetDlgItem(IDC_DEPENDS_TREE)) == 0)
		{
			HourGlass(true);

			TV_ITEM root;
			ITEMEXTRA *extra = new ITEMEXTRA;
			if(extra == NULL)
				return;
			root.hItem = TVI_ROOT;           // I'm making a root.
			root.pszText = m_ServiceDispName;
			extra->realName = CloneString(m_ServiceName);
			extra->loaded = false;
			extra->nodeType = ServiceNode;
			root.lParam = (LPARAM)extra;

			InvalidateRect(NULL);
    
			UpdateWindow();

			// load the first levels.
			LoadLeaves(GetDlgItem(IDC_DEPENDS_TREE), 
						&root, true);

			LoadLeaves(GetDlgItem(IDC_NEEDED_TREE), 
						&root, false);

			SetFocus();
			HourGlass(false);
		}
	}
}

//--------------------------------------------------------------
BOOL DependencyPage::OnApply()
{
	::SetWindowLongPtr(m_hDlg, DWLP_USER, 0);
	return TRUE;
}

//--------------------------------------------------------------
BOOL DependencyPage::OnKillActive()
{
	//SetWindowLong(DWL_MSGRESULT, 0);
	return TRUE;
}

//--------------------------------------------------------------
LRESULT DependencyPage::OnEnumNow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(lParam)
	{
		IStream *pStream = (IStream *)lParam;
		IWbemServices *pServices = 0;
		HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
											IID_IWbemServices,
											(void**)&pServices);
		if(SUCCEEDED(hr))
		{
			SetWbemService(pServices);
			pServices->Release();
		}

		LoadTrees();  //calls ServiceIsReady() itself.
	}
	else if(FAILED(m_pgConnectThread->m_hr))
	{
		DisplayUserMessage(m_hDlg, HINST_THISDLL,
							IDS_DISPLAY_NAME, BASED_ON_SRC, 
							ConnectServer,
							m_pgConnectThread->m_hr, 
							MB_ICONSTOP);
	}
	else
	{
		m_pgConnectThread->NotifyWhenDone(&m_hDlg);
	}

	return S_OK;
}

//--------------------------------------------------------------
LRESULT DependencyPage::OnItemExpanding(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{ 
	// which node?
	NM_TREEVIEW *notice = (NM_TREEVIEW *)pnmh;

	// we're expanding, not collapsing...
	if(notice->action == TVE_EXPAND)
	{
		// which tree?
		HWND treeHWND = GetDlgItem(idCtrl);

		TV_ITEM item;
		item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_CHILDREN |TVIF_IMAGE;
		item.pszText = new TCHAR[200];
		item.cchTextMax = 200;
		item.hItem = notice->itemNew.hItem;

		TreeView_GetItem(treeHWND, &item);

		// if we've never tried...
		if(((ITEMEXTRA *)item.lParam)->loaded == false)
		{
			// NOTE: really cant get here if its not ready
			// but better safe than sorry.
			if(ServiceIsReady(IDS_DISPLAY_NAME, IDS_CONNECTING, IDS_BAD_CONNECT))
			{	
				// load it.
				LoadLeaves(treeHWND, &item, (idCtrl == IDC_DEPENDS_TREE));
			}
		}

		delete[] item.pszText;
	} //end action
	return S_OK;
}

//-------------------------------------------------------------------------------
LRESULT DependencyPage::OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{ 
	NM_TREEVIEW *notice = (NM_TREEVIEW *)pnmh;
	delete[] (TCHAR *)((ITEMEXTRA *)notice->itemOld.lParam)->realName;
	delete (ITEMEXTRA *)notice->itemOld.lParam;
	return S_OK;
}

//-------------------------------------------------------------------------------
DWORD aDepHelpIds[] = {
    IDC_PICT,			-1,
    IDC_DESC,			-1,
    IDC_DEPENDS_LBL,    (985),	// dependsOn
    IDC_DEPENDS_TREE,   (985),	// dependsOn
    IDC_NEEDED_LBL,     (988),	// neededBy
    IDC_NEEDED_TREE,    (988),	// neededBy
    0, 0
};

LRESULT DependencyPage::OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
				L"filemgmt.hlp", 
				HELP_WM_HELP, 
				(ULONG_PTR)(LPSTR)aDepHelpIds);

	return S_OK;
}

//-------------------------------------------------------------------------------
LRESULT DependencyPage::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)wParam,
				L"filemgmt.hlp", 
				HELP_CONTEXTMENU, 
				(ULONG_PTR)(LPSTR)aDepHelpIds);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\servdeps\stdafx.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\mmfutil\wbemerror.cpp ===
//=============================================================================
//
//                              WbemError.cpp
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//	Implements string table based, error msgs for all of wbem.
//
//  History:
//
//      a-khint  5-mar-98       Created.
//
//============================================================================= 
#include "precomp.h"
#include "WbemError.h"
#include "resource.h"
#include <wbemcli.h>

//--------------PUBLIC-----------------------------
#define TEMP_BUF 512

POLARITY bool ErrorStringEx(HRESULT hr, 
						   TCHAR *errMsg, UINT errSize,
						   UINT *sevIcon)
{
    WCHAR szError[TEMP_BUF];
	WCHAR szFacility[TEMP_BUF];
    WCHAR szFormat[100];
	IWbemStatusCodeText * pStatus = NULL;

    // initialize buffers.
	errMsg[0] = 0;
	szFacility[0] = 0;
	szError[0] = 0;

	HRESULT hr1 = CoInitialize(NULL);
	SCODE sc1 = CoCreateInstance(CLSID_WbemStatusCodeText, 
								0, CLSCTX_INPROC_SERVER,
								IID_IWbemStatusCodeText, 
								(LPVOID *) &pStatus);

	// loaded OK?
	if(sc1 == S_OK)
	{
		BSTR bstr = 0;
		sc1 = pStatus->GetErrorCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
			_tcsncpy(szError, bstr, TEMP_BUF-1);
			SysFreeString(bstr);
			bstr = 0;
		}

		sc1 = pStatus->GetFacilityCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
			_tcsncpy(szFacility, bstr, TEMP_BUF-1);
			SysFreeString(bstr);
			bstr = 0;
		}

		// RELEASE
		pStatus->Release();
		pStatus = NULL;
	}
	else
	{
		::MessageBox(NULL, _T("WBEM error features not available. Upgrade WMI to a newer build."),
					 _T("Internal Error"), MB_ICONSTOP|MB_OK);
	}

	// if not msgs returned....
	if(wcslen(szFacility) == 0 || wcslen(szError) == 0)
	{
		// format the error nbr as a reasonable default.
		LoadString(GetModuleHandle(_T("MMFUtil.dll")), IDS_ERROR_UNKN_ERROR_FMT, szFormat, 99);
		_stprintf(errMsg, szFormat, hr);
	}
	else
	{
		// format a readable msg.
		LoadString(GetModuleHandle(_T("MMFUtil.dll")), IDS_ERROR_FMT, szFormat, 99);
		_stprintf(errMsg, szFormat, szFacility, szError);
	}

	// want an icon recommendation with that?
	if(sevIcon)
	{
		switch(SCODE_SEVERITY(hr))
		{
		case 0: // - Success
			*sevIcon = MB_ICONINFORMATION;
			break;
		case 1: //- Failed
			*sevIcon = MB_ICONEXCLAMATION;
			break;
		} //endswitch severity

	} //endif sevIcon

	if(hr1 == S_OK)
		CoUninitialize();

	return (SUCCEEDED(sc1) && SUCCEEDED(hr1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\servdeps\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ServDeps.rc
//
#define CX_CDWN_OFFS                    0
#define IDS_DISPLAY_NAME                1
#define IDS_TITLE                       2
#define IDS_DEPENDS_LBL                 3
#define IDS_NEEDED_LBL                  4
#define IDS_DESCRIPTION                 5
#define IDS_CONNECTING                  6
#define IDS_BAD_CONNECT                 7
#define IDD_DEPENDENCY                  101
#define IDB_SERVICE                     102
#define IDI_SERVICE                     103
#define IDI_SERVDEPS                    104
#define IDI_EMPTY                       105
#define IDI_SERVGROUP                   106
#define IDI_SYSTEMDRIVER				107
#define IDS_PROJNAME                    110
#define IDB_SDSNAPIN_16                 111
#define IDB_SDSNAPIN_32                 112
#define IDD_SDSNAPIN                    113
#define IDS_SDSNAPIN_DESC               114
#define IDS_SDSNAPIN_PROVIDER           115
#define IDS_SDSNAPIN_VERSION            116
#define IDR_SDSNAPIN                    117
#define IDS_WORKING                     117
#define IDS_NO_DEPS                     118
#define IDI_WAITING                     202
#define IDC_DEPENDS_TREE                1003
#define IDC_NEEDED_TREE                 1004
#define IDC_NEEDED_LBL                  1005
#define IDC_DEPENDS_LBL                 1006
#define IDC_DESC                        1007
#define IDC_PICT                        1008
#define IDC_DEPENDS_SRVC                1009
#define IDS_BYTES                       10000
#define IDS_ORDERKB                     10001
#define IDS_ORDERMB                     10002
#define IDS_ORDERGB                     10003
#define IDS_ORDERTB                     10004
#define IDS_ORDERPB                     10005
#define IDS_ORDEREB                     10006
#define IDS_MB                          10007
#define IDS_SERVICE_READY               10008

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\servdeps\deppage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __DEPPAGE__
#define __DEPPAGE__
#pragma once

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#include "atlsnap.h"
#include "resource.h"
#include "..\common\PageHelper.h"

#define WM_ENUM_NOW WM_USER + 20

//-----------------------------------------------------------------------------
class DependencyPage : public CSnapInPropertyPageImpl<DependencyPage>,
					   public PageHelper
{
private:

	// supports the query builder routine.
#define	ServiceNode 0
#define	GroupNode 1
typedef BYTE NODE_TYPE;

#define	DepService 0
#define	DepGroup 1
#define	GroupMember 2
typedef BYTE QUERY_TYPE;

typedef struct 
{
	LPCTSTR realName;
	bool loaded;
	NODE_TYPE nodeType;
} ITEMEXTRA;


#define QUERY_SIZE 512
	TCHAR *m_queryFormat;
	TCHAR *m_queryTemp;

	bstr_t m_ServiceName;
	bstr_t m_ServiceDispName;

	// icons for the trees.
	int m_servIcon;
	int m_sysDriverIcon;
	int m_emptyIcon;
	int m_groupIcon;

	// convenient strings.
	bstr_t m_qLang;
	bstr_t m_NameProp;
	bstr_t m_DispNameProp;
	CWbemServices m_Services;
	WbemConnectThread *m_pConnectThread;

	void Init(HWND hDlg);

	// builds the various queries.
	void BuildQuery(TV_ITEM *fmNode, 
					QUERY_TYPE queryType,
					bool depends, 
					bstr_t &query);

	// Figures out WHAT to load.
	void LoadLeaves(HWND hTree, 
					TV_ITEM *fmNode, 
					bool depends);

	// actually queries and loads child nodes.
	bool Load(HWND hTree, 
				TV_ITEM *fmNode, 
				bstr_t query,
				NODE_TYPE childType);

	// indicate that there's nothing below 'fmNode'.
	void NothingMore(HWND hTree, TV_ITEM *fmNode);

	// loads the roots.
	void LoadTrees(void);
	void TwoLines(UINT uID, LPCTSTR staticString, LPCTSTR inStr, LPTSTR outStr,bool bStaticFirst);
	
public:

	// this page uses the global IWbemService.
	DependencyPage(WbemConnectThread *pConnectThread,
					IDataObject *pDataObject, 
					long lNotifyHandle, 
					bool bDeleteHandle = false, 
					TCHAR* pTitle = NULL);

	virtual ~DependencyPage();

	HRESULT PropertyChangeNotify(long param)
	{
		return MMCPropertyChangeNotify(m_lNotifyHandle, param);
	}

	enum { IDD = IDD_DEPENDENCY };

	typedef CSnapInPropertyPageImpl<DependencyPage> _baseClass;

	BEGIN_MSG_MAP(DependencyPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		MESSAGE_HANDLER(WM_ENUM_NOW, OnEnumNow)
		MESSAGE_HANDLER(WM_ASYNC_CIMOM_CONNECTED, OnEnumNow)
		NOTIFY_HANDLER(IDC_DEPENDS_TREE, TVN_ITEMEXPANDING, OnItemExpanding)
		NOTIFY_HANDLER(IDC_NEEDED_TREE, TVN_ITEMEXPANDING, OnItemExpanding)
		NOTIFY_HANDLER(IDC_DEPENDS_TREE, TVN_DELETEITEM, OnDeleteItem)
		NOTIFY_HANDLER(IDC_NEEDED_TREE, TVN_DELETEITEM, OnDeleteItem)
		MESSAGE_HANDLER(WM_HELP, OnF1Help)
		MESSAGE_HANDLER(WM_CONTEXTMENU , OnContextHelp)
		CHAIN_MSG_MAP(_baseClass)
	END_MSG_MAP()

	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnEnumNow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnItemExpanding(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	LRESULT OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	LRESULT OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	BOOL OnApply();
	BOOL OnKillActive();

	long m_lNotifyHandle;
	bool m_bDeleteHandle;
};


#endif __DEPPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\servdeps\servdeps.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// ServDeps.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ServDepsps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include "initguid.h"
#include "ServDeps.h"

#include "ServDeps_i.c"
#include "SDSnapin.h"


CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_SDSnapin, CSDSnapin)
	OBJECT_ENTRY(CLSID_SDSnapinAbout, CSDSnapinAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		CSnapInItem::Init();
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\servdeps\sdsnapin.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __SDSNAPIN_H_
#define __SDSNAPIN_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include <atlsnap.h>

class CSDSnapinExtData : public CSnapInItemImpl<CSDSnapinExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	CSDSnapinExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CSDSnapinExtData()
	{
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
									LONG_PTR handle, 
									IUnknown* pUnk,
									DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}

};
class CSDSnapin : public CComObjectRootEx<CComSingleThreadModel>,
					public CSnapInObjectRoot<0, CSDSnapin>,
					public IExtendPropertySheetImpl<CSDSnapin>,
					public CComCoClass<CSDSnapin, &CLSID_SDSnapin>
{
public:
	CSDSnapin()
	{
		m_pComponentData = this;
	}
EXTENSION_SNAPIN_DATACLASS(CSDSnapinExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CSDSnapin)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CSDSnapinExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CSDSnapin)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

//DECLARE_REGISTRY_RESOURCEID(IDR_SDSNAPIN)

DECLARE_NOT_AGGREGATABLE(CSDSnapin)

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		HRESULT hr;
		TCHAR pName[100] = {0};
		if(::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, 
			pName, 100) <= 0)
		{
			wcscpy(pName, _T("Service Dependencies"));
		}
		TCHAR dispName[_MAX_PATH+102] = {0};
        TCHAR szModule[_MAX_PATH+1];
        szModule[_MAX_PATH] = 0;
        ::GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
        _sntprintf( dispName,_MAX_PATH+102,_T("@%s,-%d"), szModule, IDS_DISPLAY_NAME);

		
		_ATL_REGMAP_ENTRY regMap[] = {{ OLESTR("PRETTYNAME"), pName },
										{ OLESTR("NAMESTRINGINDIRECT"),dispName},
										{ 0, 0 }};

		hr = _Module.UpdateRegistryFromResourceD(IDR_SDSNAPIN, TRUE, regMap);

		return hr;
	}


	static void WINAPI ObjectMain(bool bStarting)
	{
		if(bStarting)
			CSnapInItem::Init();
	}
};

class ATL_NO_VTABLE CSDSnapinAbout : public ISnapinAbout,
									public CComObjectRoot,
									public CComCoClass< CSDSnapinAbout, &CLSID_SDSnapinAbout>
{
public:
	DECLARE_REGISTRY(CSDSnapinAbout, _T("SDSnapinAbout.1"), _T("SDSnapinAbout.1"), IDS_SDSNAPIN_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CSDSnapinAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_DESCRIPTION, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_SDSNAPIN_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_SDSNAPIN_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		*hAppIcon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_SERVDEPS));
		return S_OK;
	}

    STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
									HBITMAP *hSmallImageOpen,
									HBITMAP *hLargeImage,
									COLORREF *cMask)
	{
		*hSmallImage = *hSmallImageOpen = LoadBitmap(_Module.GetResourceInstance(), 
														MAKEINTRESOURCE(IDB_SDSNAPIN_16));
		
		*hLargeImage = LoadBitmap(_Module.GetResourceInstance(), 
									MAKEINTRESOURCE(IDB_SDSNAPIN_32));
		*cMask = RGB(255,255,255);

		return S_OK;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\advpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __ADVANCEDPAGE__
#define __ADVANCEDPAGE__

#include "UIHelpers.h"
#include "DataSrc.h"

class CAdvancedPage : public CUIHelpers
{
private:

public:
    CAdvancedPage(DataSource *ds, bool htmlSupport);
    virtual ~CAdvancedPage(void);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitDlg(HWND hDlg);
	void Refresh(HWND hDlg);
    void OnApply(HWND hDlg, bool bClose);
	void OnNSSelChange(HWND hDlg);

	DataSource *m_DS;
	bool m_enableASP, m_anonConnection;
	DataSource::RESTART m_oldRestart;
	CHString1 m_DefNamespace;

};
#endif __ADVANCEDPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\servdeps\sdsnapin.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "DepPage.h"
#include "ServDeps.h"
#include "SDSnapin.h"
#include "..\common\ConnectThread.h"
#include "autoptr.h"

/////////////////////////////////////////////////////////////////////////////
// CSDSnapinComponentData
static const GUID CSDSnapinExtGUID_NODETYPE = 
{ 0x4e410f16, 0xabc1, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
const GUID*  CSDSnapinExtData::m_NODETYPE = &CSDSnapinExtGUID_NODETYPE;
const OLECHAR* CSDSnapinExtData::m_SZNODETYPE = OLESTR("4e410f16-abc1-11d0-b944-00c04fd8d5b0");
const OLECHAR* CSDSnapinExtData::m_SZDISPLAY_NAME = OLESTR("SDSnapin");
const CLSID* CSDSnapinExtData::m_SNAPIN_CLASSID = &CLSID_SDSnapin;

WbemConnectThread *g_connectThread = NULL;

HRESULT CSDSnapinExtData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
											LONG_PTR handle, 
											IUnknown* pUnk,
											DATA_OBJECT_TYPES type)
{
    wmilib::auto_ptr<WbemConnectThread> pConnectThread(new WbemConnectThread);
	if( NULL == pConnectThread.get())
		return E_FAIL;

	pConnectThread->Connect(m_pDataObject);

    wmilib::auto_ptr<DependencyPage> pPage(new DependencyPage(pConnectThread.get(), 
												m_pDataObject, 
												handle, 
												true));

    if(pPage.get() ) {
        lpProvider->AddPage(pPage->Create());
    }
    pPage.release();
	// The second parameter  to the property page class constructor
	// should be true for only one page.

	// TODO : Add code here to add additional pages
	
	pConnectThread->Release();	
    pConnectThread.release();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\advpage.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright (c) 1997-1999 Microsoft Corporation
/**********************************************************************/


#include "precomp.h"
#include "AdvPage.h"
#include "chstring1.h"
#include "resource.h"
#include "WMIHelp.h"
#include "ShlWapi.h"

const static DWORD advPageHelpIDs[] = {  // Context Help IDs
	IDC_SCRIPT_LABEL,		IDH_WMI_CTRL_ADVANCED_SCRIPTING_PATH,
	IDC_SCRIPT_NS,			IDH_WMI_CTRL_ADVANCED_SCRIPTING_PATH,
	IDC_CHANGE_SCRIPT_NS,	IDH_WMI_CTRL_ADVANCED_CHANGE_BUTTON,
	IDC_ASP,				IDH_WMI_CTRL_ADVANCED_ASP_ACCESS,
	IDC_ASP_LABEL,			IDH_WMI_CTRL_ADVANCED_ASP_ACCESS,
	IDC_9X_ANON_CONNECTION, IDH_WMI_CTRL_ADVANCED_ENABLE_CONNECT,
	IDC_9X_ONLY,			IDH_WMI_CTRL_ADVANCED_RESTART_BOX,
	IDC_NORESTART,			IDH_WMI_CTRL_ADVANCED_RESTART_BOX,
	IDC_ESSRESTART,			IDH_WMI_CTRL_ADVANCED_RESTART_BOX,
	IDC_ALWAYSAUTORESTART,	IDH_WMI_CTRL_ADVANCED_RESTART_BOX,
	IDC_ADV_PARA,			-1,
    0, 0};


// WARNING: This class handles IDD_ADVANCED_NT and IDD_ADVANCED_9X so protect
// yourself from controls that aren't on both templates.

CAdvancedPage::CAdvancedPage(DataSource *ds, bool htmlSupport) :
								CUIHelpers(ds, &(ds->m_rootThread), htmlSupport),
								m_DS(ds)
{
}

CAdvancedPage::~CAdvancedPage(void)
{
}

//-------------------------------------------------------------------------
void CAdvancedPage::InitDlg(HWND hDlg)
{
	m_hDlg = hDlg;
	ATLTRACE(_T("ADV: init\n"));
}

//---------------------------------------------------------------------------
void CAdvancedPage::Refresh(HWND hDlg)
{
	if(m_DS && m_DS->IsNewConnection(&m_sessionID))
	{
		CHString1 temp;
		CHString1 szNotRemoteable, szUnavailable;
		HRESULT hr = S_OK;
		BOOL enable = TRUE;
		HWND hWnd;

		szNotRemoteable.LoadString(IDS_NOT_REMOTEABLE);
		szUnavailable.LoadString(IDS_UNAVAILABLE);

		PageChanged(PB_ADVANCED, false);

		//Make sure we don't display this stuff if there's no connection...
		if((m_DS->m_OSType == OSTYPE_WINNT) || (m_DS->m_rootThread.m_status != WbemServiceThread::ready))
		{
			ATLTRACE(_T("ADV: winnt\n"));
			::ShowWindow(GetDlgItem(hDlg,IDC_NORESTART), SW_HIDE);
			::ShowWindow(GetDlgItem(hDlg,IDC_ESSRESTART), SW_HIDE);
			::ShowWindow(GetDlgItem(hDlg,IDC_ALWAYSAUTORESTART), SW_HIDE);
			::ShowWindow(GetDlgItem(hDlg,IDC_9X_ANON_CONNECTION), SW_HIDE);
			::ShowWindow(GetDlgItem(hDlg,IDC_9X_ONLY), SW_HIDE);

			CHString1 para;
			para.LoadString(IDS_ADV_PARA_NT);
			SetDlgItemText(hDlg, IDC_ADV_PARA, para);
			// - - - - - - - - - - - - - -
			// Enable for ASP:
			hWnd = GetDlgItem(hDlg,IDC_ASP);
			if(hWnd)
			{
				// only display it for NT 3.51 and NT4.0.
				CHString1 ver;
				m_DS->GetOSVersion(ver);
				if((_tcsncmp((LPCTSTR)ver, _T("3.51"), 4) == 0) || 
					ver[0] == _T('4'))
				{
					ATLTRACE(_T("ADV: winnt  4.0\n"));

					::ShowWindow(hWnd, SW_SHOW);
					::ShowWindow(GetDlgItem(hDlg, IDC_ASP_LABEL), SW_SHOW);

					hr = m_DS->GetScriptASPEnabled(m_enableASP);
					if(SUCCEEDED(hr))
					{
						Button_SetCheck(hWnd, (m_enableASP ? BST_CHECKED : BST_UNCHECKED));
					}
				}
				else // this must be w2k
				{
					ATLTRACE(_T("ADV: winnt 5.0\n"));
					::ShowWindow(hWnd, SW_HIDE);
					::ShowWindow(GetDlgItem(hDlg, IDC_ASP_LABEL), SW_HIDE);
				}
			}
		}
		else // 9x box
		{
			ATLTRACE(_T("ADV: 9x\n"));

			::ShowWindow(GetDlgItem(hDlg,IDC_NORESTART), SW_SHOW);
			::ShowWindow(GetDlgItem(hDlg,IDC_ESSRESTART), SW_SHOW);
			::ShowWindow(GetDlgItem(hDlg,IDC_ALWAYSAUTORESTART), SW_SHOW);
			::ShowWindow(GetDlgItem(hDlg,IDC_9X_ANON_CONNECTION), SW_SHOW);
			::ShowWindow(GetDlgItem(hDlg,IDC_9X_ONLY), SW_SHOW);

			ShowWindow(GetDlgItem(hDlg,IDC_ASP), SW_HIDE);
			ShowWindow(GetDlgItem(hDlg,IDC_ASP_LABEL), SW_HIDE);

			CHString1 para;
			para.LoadString(IDS_ADV_PARA_9X);
			SetDlgItemText(hDlg, IDC_ADV_PARA, para);

			// - - - - - - - - - - - - - -
			// 9x restart.
			int ID;
			hr = m_DS->GetRestart(m_oldRestart);
			if(SUCCEEDED(hr))
			{
				switch(m_oldRestart)
				{
				case DataSource::Dont:			ID = IDC_NORESTART; break;
				case DataSource::AsNeededByESS:	ID = IDC_ESSRESTART;   break;
				case DataSource::Always:		ID = IDC_ALWAYSAUTORESTART; break;
				}
				CheckRadioButton(hDlg, IDC_NORESTART, IDC_ALWAYSAUTORESTART, ID);
			}

			// - - - - - - - - - - - - - -
			// 9x Anonymous connection:
			hWnd = GetDlgItem(hDlg, IDC_9X_ANON_CONNECTION);
			if(hWnd)
			{
				hr = m_DS->GetAnonConnections(m_anonConnection);
				if(SUCCEEDED(hr))
				{
					Button_SetCheck(hWnd, (m_anonConnection ? BST_CHECKED : BST_UNCHECKED));
				}
			}
		} //endif OSTtype

		// - - - - - - - - - - - - - -
		// ASP def namespace:
		hWnd = GetDlgItem(hDlg, IDC_SCRIPT_NS);
		if(hWnd)
		{
			hr = m_DS->GetScriptDefNS(m_DefNamespace);
			if(SUCCEEDED(hr))
			{
				enable = TRUE;
				TCHAR shortPath[50] = {0};
				PathCompactPathEx(shortPath, m_DefNamespace, 40,0);
				SetWindowText(hWnd, shortPath);
			}
			else //failed
			{
				enable = FALSE;
				SetWindowText(hWnd, szUnavailable);
			}

			::EnableWindow(GetDlgItem(hDlg,IDC_CHANGE_SCRIPT_NS), enable);
		}
	}
}

//------------------------------------------------------------------------
void CAdvancedPage::OnNSSelChange(HWND hDlg)
{
	TCHAR path[MAX_PATH] = {0};

	if(DisplayNSBrowser(hDlg, path, MAX_PATH) == IDOK)
	{
		m_DefNamespace = path;
		HWND hWnd = GetDlgItem(hDlg, IDC_SCRIPT_NS);
		TCHAR shortPath[50] = {0};
		PathCompactPathEx(shortPath, m_DefNamespace, 40,0);
		::SetWindowText(hWnd, shortPath);
		Edit_SetModify(hWnd, TRUE);
		PageChanged(PB_ADVANCED, true);
	}

}

//------------------------------------------------------------------------
void CAdvancedPage::OnApply(HWND hDlg, bool bClose)
{
	// enable ASP
	HWND hWnd = GetDlgItem(hDlg, IDC_ASP);
	bool needToPut = false;

	if(hWnd)
	{
		bool newEnable = (IsDlgButtonChecked(hDlg, IDC_ASP) & BST_CHECKED ?true:false);

		if(m_enableASP != newEnable)
		{
			m_DS->SetScriptASPEnabled(newEnable);
			m_enableASP = newEnable;
			needToPut = true;
		}
	}

	// default scripting namespace.
	TCHAR buf[_MAX_PATH] = {0};
	hWnd = GetDlgItem(hDlg, IDC_SCRIPT_NS);
	//if(Edit_GetModify(hWnd))
	{
		::GetWindowText(hWnd, buf, ARRAYSIZE(buf));
		m_DS->SetScriptDefNS(m_DefNamespace);
		needToPut = true;
	}

	// Anon Connections
	hWnd = GetDlgItem(hDlg, IDC_9X_ANON_CONNECTION);
	if(hWnd)
	{
		bool anonConn = (IsDlgButtonChecked(hDlg, IDC_9X_ANON_CONNECTION) & BST_CHECKED ?true:false);

		if(m_anonConnection != anonConn)
		{
			m_DS->SetAnonConnections(anonConn);
			m_anonConnection = anonConn;
			needToPut = true;
		}
	}

	// 9x restart
	hWnd = GetDlgItem(hDlg, IDC_NORESTART);
	if(hWnd)
	{
		DataSource::RESTART restart = DataSource::Dont;

		if(IsDlgButtonChecked(hDlg, IDC_NORESTART) & BST_CHECKED)
			restart = DataSource::Dont;
		else if(IsDlgButtonChecked(hDlg, IDC_ESSRESTART) & BST_CHECKED)
			restart = DataSource::AsNeededByESS;
		else if(IsDlgButtonChecked(hDlg, IDC_ALWAYSAUTORESTART) & BST_CHECKED)
			restart = DataSource::Always;

		if(m_oldRestart != restart)
		{
			m_DS->SetRestart(restart);
			m_oldRestart = restart;
			needToPut = true;
		}
	}

	if(needToPut)
	{
		NeedToPut(PB_ADVANCED, !bClose);
		if(!bClose)
			Refresh(hDlg);
	}
}

//------------------------------------------------------------------------
BOOL CAdvancedPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

    case WM_NOTIFY:
        switch(((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            Refresh(hDlg);
            break;

        case PSN_HELP:
			HTMLHelper(hDlg);
            break;

        case PSN_APPLY:
            OnApply(hDlg, (((LPPSHNOTIFY)lParam)->lParam == 1));
            break;
        }
        break;

    case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_ASP:
		case IDC_9X_ANON_CONNECTION:
		case IDC_NORESTART:
		case IDC_ESSRESTART:
		case IDC_ALWAYSAUTORESTART:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				PageChanged(PB_ADVANCED, true);
				return TRUE;
			}
			break;

		case IDC_CHANGE_SCRIPT_NS:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				OnNSSelChange(hDlg);
				return TRUE;
			}
			break;

		} //endswitch(LOWORD(wParam))
	
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)advPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)advPageHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\aboutdlg.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
class CAboutDlg : public CDialogImpl<CAboutDlg>
{
public:
	enum { IDD = IDD_ABOUTBOX };

	BEGIN_MSG_MAP(CAboutDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER(IDOK, OnCloseCmd)
		COMMAND_ID_HANDLER(IDCANCEL, OnCloseCmd)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		CenterWindow(GetParent());
		return TRUE;
	}

	LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		EndDialog(wID);
		return 0;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\asyncobjectsink.h ===
#ifndef __ASYN_OBJECT_ASYNC_DJFDVINOTHDLKJ
#define __ASYN_OBJECT_ASYNC_DJFDVINOTHDLKJ

#include "Wbemidl.h"
#include "DataSrc.h"

enum ENUMTYPE
{
	ENUM_NAMESPACE,
	ENUM_CLASS,
	ENUM_INSTANCE,
	ENUM_SCOPE_INSTANCE
};

class CAsyncObjectSink : public IWbemObjectSink
{
	// Declare the reference count for the object.
	LONG m_lRef;
	struct NSNODE *m_pParent;
	HTREEITEM m_hItem;
	HWND m_hTreeWnd;
	DataSource *m_pDataSrc;
	ENUMTYPE m_enumType;
	bool m_bChildren;
	IWbemObjectSink *m_pStub;
	
public:
	CAsyncObjectSink(HWND hTreeWnd, HTREEITEM hItem,struct NSNODE *parent,DataSource *dataSrc, ENUMTYPE eType);
	~CAsyncObjectSink(); 

	// IUnknown methods
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();        
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

	// IWbemObjectSink methods
	virtual HRESULT STDMETHODCALLTYPE Indicate( 
		  /* [in] */ long lObjectCount,
		  /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray);
	virtual HRESULT STDMETHODCALLTYPE SetStatus( 
		  /* [in] */ long lFlags,
		  /* [in] */ HRESULT hResult,
		  /* [in] */ BSTR strParam,
		  /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);

	HRESULT SetSinkStub(IWbemObjectSink *pStub);
	IWbemObjectSink* GetSinkStub();

};

#endif //__ASYN_OBJECT_ASYNC_DJFDVINOTHDLKJ
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\backuppage.cpp ===
// Copyright (c) 1999 Microsoft Corporation

#include "precomp.h"
#include "BackupPage.h"
#include <chstring1.h>
#include <util.h>
#include "resource.h"
#include "wbemerror.h"
#include <process.h>
#include "WMIHelp.h"
#include "ShlWapi.h"
#include <cominit.h>
#include <stdlib.h>
#include <stdio.h>

#define REC_WILDCARD    _T("*.rec")
#define ALL_WILDCARD    _T("*.*")

const static DWORD buPageHelpIDs[] = {  // Context Help IDs
	IDC_BACKUP_ENABLED,		IDH_WMI_CTRL_BACKUP_AUTOMATIC_CHECKBOX,
	IDC_BACKUPINTERVAL,		IDH_WMI_CTRL_BACKUP_TIME,
	IDC_BACKUP_UNITS,		IDH_WMI_CTRL_BACKUP_MINUTES_HOURS,
	IDC_LASTBACKUP_LABEL,	IDH_WMI_CTRL_BACKUP_LAST,
	IDC_LASTBACKUP,			IDH_WMI_CTRL_BACKUP_LAST,
	IDC_RESTORE_FM_AUTO,	IDH_WMI_CTRL_BACKUP_RESTORE_AUTO,
	IDC_BACKUP_BTN,			IDH_WMI_CTRL_BACKUP_BACKUP_MANUAL,
	IDC_RESTORE_BTN,		IDH_WMI_CTRL_BACKUP_RESTORE_MANUAL,
	IDC_DBDIRECTORY_LABEL,	IDH_WMI_CTRL_ADVANCED_REPOSITORY_LOC,
	IDC_DB_DIR,				IDH_WMI_CTRL_ADVANCED_REPOSITORY_LOC,
	IDC_ADV_NOW_TEXT,		-1,
	IDC_ADV_NOW_TEXT2,		-1,
	65535, -1,
    0, 0
};

const double WIN2K_CORE_VERSION = 1085.0005;		//Win2K Core Version


CBackupPage::CBackupPage(DataSource *ds, bool htmlSupport):
	CUIHelpers(ds, &(ds->m_rootThread), htmlSupport),
	m_AVIbox(NULL),
	m_wszArgs(NULL),
	m_cred(NULL),
	m_bWhistlerCore(false),
	m_hAccessToken(NULL),
	m_fClearToken(false),
	m_cloak(false)
{
    memset(&m_luid,0,sizeof(LUID));
}

CBackupPage::~CBackupPage(void)
{
}

//-------------------------------------------------------------------------
void CBackupPage::InitDlg(HWND hDlg)
{
	m_hDlg = hDlg;

	::SendMessage(GetDlgItem(hDlg, IDC_BACKUPINTERVAL),
					EM_LIMITTEXT, 3, 0);

	HWND hWnd = GetDlgItem(hDlg, IDC_BACKUP_UNITS);
	if(hWnd)
	{
		CHString1 str;
		str.LoadString(IDS_MINUTES);
		ComboBox_AddString(hWnd, str);

		str.LoadString(IDS_HOURS);
		ComboBox_AddString(hWnd, str);
	}


	if(m_DS)
	{
		USES_CONVERSION;
		CHString1 strVersion = _T("0.0");
		m_DS->GetBldNbr(strVersion);
		double ver = _tstof(strVersion);
		if(ver > WIN2K_CORE_VERSION)		
		{
			HideAutomaticBackupControls(hDlg);
		}
	}
}

//---------------------------------------------------------------------------
// NOTE: This must match to order of the combobox.
#define UNIT_MINUTE 0
#define UNIT_HOUR 1
#define UNIT_DAY 2

#define MINS_IN_HOUR 60
#define MINS_IN_DAY 1440
#define DISABLE_BACKUP -1

void CBackupPage::SetInterval(HWND hDlg, UINT minutes)
{
	int m_CBIdx = UNIT_MINUTE;
	UINT value = minutes;

	if((minutes % MINS_IN_HOUR) == 0)
	{
		m_CBIdx = UNIT_HOUR;
		value = minutes / MINS_IN_HOUR;
	}
	else if((minutes % MINS_IN_DAY) == 0)
	{
		m_CBIdx = UNIT_DAY;
		value = minutes / MINS_IN_DAY;
	}

	CHString1 temp;
	temp.Format(_T("%d"), value);
	SetWindowText(GetDlgItem(hDlg, IDC_BACKUPINTERVAL), temp);
	ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_BACKUP_UNITS), m_CBIdx);
}

//---------------------------------------------------------------------------
bool CBackupPage::GetInterval(HWND hDlg, UINT &iValue, bool &valid)
{
	int idx = ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_BACKUP_UNITS));
	TCHAR value[4] = {0};
	valid = false;
	iValue = 0;
	::GetWindowText(GetDlgItem(hDlg, IDC_BACKUPINTERVAL), value, 4);
	iValue = _ttoi(value);

	// scale to minutes based on the combo box.
	switch(idx)
	{
	case UNIT_HOUR:
		iValue *= MINS_IN_HOUR;
		break;
	case UNIT_DAY:
		iValue *= MINS_IN_DAY;
		break;
	}

	if((iValue == 0) ||
	   ((iValue >= 5) && (iValue <= 1440)))
	{
		valid = true;
	}
	else
	{
		CHString1 caption, threat;
		caption.LoadString(IDS_SHORT_NAME);
		threat.LoadString(IDS_BAD_INTERVAL);

		MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
							MB_OK|MB_ICONEXCLAMATION);

	}

	return (m_CBIdx != idx);
}

//---------------------------------------------------------------------------
void CBackupPage::Refresh(HWND hDlg, bool force)
{
	if(force || 
		(m_DS && m_DS->IsNewConnection(&m_sessionID)))
	{
		CHString1 temp;
		UINT iTemp = 0;
		CHString1 szNotRemoteable, szUnavailable;
		HRESULT hr = S_OK;
		BOOL enable = TRUE;

		szNotRemoteable.LoadString(IDS_NOT_REMOTEABLE);
		szUnavailable.LoadString(IDS_UNAVAILABLE);

		PageChanged(PB_BACKUP, false);

		// - - - - - - - - - - - - - -
		// Interval:
		iTemp = 0;
		hr = m_DS->GetBackupInterval(iTemp);
		if(SUCCEEDED(hr))
		{
			if(iTemp == 0)
			{
				Button_SetCheck(GetDlgItem(hDlg, IDC_BACKUP_ENABLED), BST_UNCHECKED);
				SetWindowText(GetDlgItem(hDlg, IDC_BACKUPINTERVAL), _T("0"));
				ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_BACKUP_UNITS), -1);
				enable = FALSE;
			}
			else
			{
				Button_SetCheck(GetDlgItem(hDlg, IDC_BACKUP_ENABLED), BST_CHECKED);
				SetInterval(hDlg, iTemp);
				enable = TRUE;
			}
		}
		else //failed
		{
			enable = FALSE;
			SetWindowText(GetDlgItem(hDlg, IDC_BACKUPINTERVAL),
							szUnavailable);
			::EnableWindow(GetDlgItem(hDlg, IDC_BACKUP_ENABLED), enable);
		}

		::EnableWindow(GetDlgItem(hDlg, IDC_BACKUPINTERVAL), enable);
		::EnableWindow(GetDlgItem(hDlg, IDC_BACKUP_UNITS), enable);

		// - - - - - - - - - - - - - -
		// DB dir:
		HWND hWnd = GetDlgItem(hDlg, IDC_DB_DIR);
		if(hWnd)
		{
			CHString1 dir;
			hr = m_DS->GetDBLocation(dir);
			if(SUCCEEDED(hr))
			{
				enable = TRUE;
				TCHAR shortPath[40] = {0};
				PathCompactPathEx(shortPath, dir, 35,0);
				Edit_SetText(hWnd, (LPCTSTR)shortPath);
			}
			else
			{
				enable = FALSE;
				SetWindowText(hWnd,szUnavailable);
			}
		
			::EnableWindow(hWnd, enable);
			::EnableWindow (GetDlgItem(hDlg, IDC_DBDIRECTORY_LABEL), enable);

		}

		// - - - - - - - - - - - - - -
		// Last backup:
		temp.Empty();

		hr = m_DS->GetLastBackup(temp);
		if(SUCCEEDED(hr))
		{
			enable = (hr != WBEM_S_FALSE);
			SetWindowText(GetDlgItem(hDlg, IDC_LASTBACKUP),
							temp);
		}
		else //failed
		{
			enable = FALSE;
			SetWindowText(GetDlgItem(hDlg, IDC_LASTBACKUP),
							szUnavailable);
		}
		::EnableWindow(GetDlgItem(hDlg, IDC_LASTBACKUP_LABEL), enable);
		::EnableWindow(GetDlgItem(hDlg, IDC_LASTBACKUP), enable);
	}
}

//------------------------------------------------------------------------
void CBackupPage::OnApply(HWND hDlg, bool bClose)
{
	if(m_bWhistlerCore == false)
	{
		HWND intervalHWND = GetDlgItem(hDlg, IDC_BACKUPINTERVAL);
		bool needToPut = false;
		UINT iValue = 0;
		bool valid = false;
		
		bool changed = GetInterval(hDlg, iValue, valid);

		if((changed || Edit_GetModify(intervalHWND)) && valid)
		{
			m_DS->SetBackupInterval(iValue);
			needToPut = true;
		}

		if(needToPut)
		{
			NeedToPut(PB_BACKUP, !bClose);
			if(!bClose)
				Refresh(hDlg);
		}
	}
}

//-----------------------------------------------------
void CBackupPage::Reconnect(void)
{
	HRESULT hr = 0;

	LOGIN_CREDENTIALS *credentials = m_DS->GetCredentials();

	m_DS->Disconnect();
	
	hr = m_DS->Connect(credentials);

	if(SUCCEEDED(hr))
	{
		m_alreadyAsked = false;

		if(ServiceIsReady(NO_UI, 0,0))
		{
			m_DS->Initialize(0);
		}
		else
		{
 			TCHAR caption[100] = {0}, msg[256] = {0};

			::LoadString(_Module.GetModuleInstance(), IDS_SHORT_NAME,
							caption, 100);

			::LoadString(_Module.GetModuleInstance(), IDS_CONNECTING, 
							msg, 256);

			if(DisplayAVIBox(m_hDlg, caption, msg, &m_AVIbox) == IDCANCEL)
			{
				g_serviceThread->Cancel();
			}
		}
	}
}

//-----------------------------------------------------
void CBackupPage::Reconnect2(void)
{
	m_DS->Disconnect();

 	TCHAR caption[100] = {0}, msg[256] = {0};

	::LoadString(_Module.GetModuleInstance(), IDS_SHORT_NAME,
					caption, 100);

	::LoadString(_Module.GetModuleInstance(), IDS_POST_RESTORE, 
					msg, 256);

	MessageBox(m_hDlg, (LPCTSTR)msg, (LPCTSTR)caption, 
							MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

	PropSheet_SetCurSel(GetParent(m_hDlg), 0, 0);
}

//---------------------------------------------------------------------------
void CBackupPage::OnFinishConnected(HWND hDlg, LPARAM lParam)
{
	if(m_AVIbox)
	{
		PostMessage(m_AVIbox, 
					WM_ASYNC_CIMOM_CONNECTED, 
					0, 0);
		m_AVIbox = 0;
	}

	IStream *pStream = (IStream *)lParam;
	IWbemServices *pServices = 0;
	HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
										IID_IWbemServices,
										(void**)&pServices);
	SetWbemService(pServices);

	if(ServiceIsReady(NO_UI, 0,0))
	{
		m_DS->Initialize(pServices);
	}

}	

//---------------------------------------------------------------
void CBackupPage::SetPriv(LPCTSTR privName, IWbemBackupRestore *br)
{
    if (ImpersonateSelf(SecurityImpersonation))
	{
		if(OpenThreadToken( GetCurrentThread(), 
							TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
							FALSE, &m_hAccessToken ) )
		{
			m_fClearToken = true;

			// Now, get the LUID for the privilege from the local system
			ZeroMemory(&m_luid, sizeof(m_luid));

			LookupPrivilegeValue(NULL, privName, &m_luid);
	//		m_cloak = true;
			EnablePriv(true, br);
		}
		else
		{
			DWORD err = GetLastError();
		}
	}
	else
	{
		DWORD err = GetLastError();
	}
}

//---------------------------------------------------------------------
bool CBackupPage::IsClientNT5OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return ( os.dwPlatformId == VER_PLATFORM_WIN32_NT ) && ( os.dwMajorVersion >= 5 ) ;
}


//---------------------------------------------------------------
DWORD CBackupPage::EnablePriv(bool fEnable, IWbemBackupRestore *br)
{
	DWORD				dwError = ERROR_SUCCESS;
	TOKEN_PRIVILEGES	tokenPrivileges;

	tokenPrivileges.PrivilegeCount = 1;
	tokenPrivileges.Privileges[0].Luid = m_luid;
	tokenPrivileges.Privileges[0].Attributes = ( fEnable ? SE_PRIVILEGE_ENABLED : 0 );

	if(AdjustTokenPrivileges(m_hAccessToken, 
								FALSE, 
								&tokenPrivileges, 
								0, NULL, NULL) != 0)
	{
		HRESULT hr = E_FAIL;
		if(br)
		{
			//Privileges for backup/restore are only set for the local box
			//case, so in this case we need to set cloaking on the
			//interface for the privileges to be transfered with the call.
			//Make sure this is never called remotely, since in that case
			//the authident needs to be used and privileges are transferred
			//remotely so cloaking is NOT needed for remote (and if set
			//will null the user authident out !!)	    	
			try 
			{
			    
				hr = SetInterfaceSecurityEx(
                                br, 
                                m_cred->authIdent, //for local this is actually not relevant... 
                                NULL,
                                RPC_C_AUTHN_LEVEL_DEFAULT, 
                                RPC_C_IMP_LEVEL_IMPERSONATE,
                                IsClientNT5OrMore() ? EOAC_DYNAMIC_CLOAKING :
                                    EOAC_NONE);
                                  
			}
			catch( ... )
			{
				hr = E_FAIL;
			}
		}
	}
	else
	{
		dwError = ::GetLastError();
	}

	return dwError;
}

//---------------------------------------------------------------
void CBackupPage::ClearPriv(void)
{
//    m_cloak = true;
	EnablePriv(false);

	if(m_fClearToken)
	{
		CloseHandle(m_hAccessToken);
		m_hAccessToken = 0;
		m_fClearToken = false;
	}

	RevertToSelf(); //to make sure token is removed from thread (counterpart to ImpersonateSelf() in SetPriv())
}


//-----------------------------------------------------
void __cdecl BackupRestoreThread(LPVOID lpParameter)
{
	CBackupPage *me = (CBackupPage *)lpParameter;

	MULTI_QI qi = {&IID_IWbemBackupRestore, 0, 0};

	CoInitialize(0);

	if(me->m_DS->IsLocal())
	{
		me->m_backupHr = CoCreateInstanceEx(CLSID_WbemBackupRestore, 0, 
											CLSCTX_LOCAL_SERVER, 0, 1, &qi);
	}
	else
	{
		COSERVERINFO server = {0,0,0,0};
		WCHAR machine[MAXCOMPUTER_NAME + 1] = {0};

		#ifdef UNICODE
			wcscpy(machine, me->m_DS->m_whackedMachineName);
		#else
			mbstowcs(machine, 
						(LPCTSTR)me->m_DS->m_whackedMachineName, 
						_tcslen(me->m_DS->m_whackedMachineName) + 1);
		#endif

		server.pwszName = machine;

		COAUTHINFO authInfo = {10,0, 0, RPC_C_AUTHN_LEVEL_DEFAULT,
								RPC_C_IMP_LEVEL_IMPERSONATE, 
								me->m_cred->authIdent, 0};

		server.pAuthInfo = &authInfo;

		me->m_backupHr = CoCreateInstanceEx(CLSID_WbemBackupRestore, 0, 
											CLSCTX_REMOTE_SERVER, 
											&server, 1, &qi);
	}

	if(SUCCEEDED(me->m_backupHr) && SUCCEEDED(qi.hr))
	{
		IWbemBackupRestore *pBR = (IWbemBackupRestore *)qi.pItf;

            		    SetInterfaceSecurityEx(pBR, 
											me->m_cred->authIdent, 
											NULL,
											RPC_C_AUTHN_LEVEL_DEFAULT, 
											RPC_C_IMP_LEVEL_IMPERSONATE,
											0); 

		ATLTRACE(_T("begin backup/restore\n"));

		//Sleep(1000);

		CHString1 verStr;
		bool TgtisNT5 = true;
		if(me->m_DS)
		{
			me->m_DS->GetOSVersion(verStr);
			if(verStr[0] == _T('4'))
				TgtisNT5 = false;
		}

		if(me->m_doingBackup)
		{
			//Only set the privilege if we are local - otherwise the privilege is there already
			//in the thread token...
			if( me->m_DS->IsLocal() && TgtisNT5)
				me->SetPriv(SE_BACKUP_NAME, pBR);

			me->m_backupHr = pBR->Backup(me->m_wszArgs, 0);
		}
		else
		{
			//Only set the privilege if we are local - otherwise the privilege is there already
			//in the thread token...
			if( me->m_DS->IsLocal() && TgtisNT5)
				me->SetPriv(SE_RESTORE_NAME, pBR);

			me->m_backupHr = pBR->Restore(me->m_wszArgs,
								WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN);
		}

		if(TgtisNT5)
			me->ClearPriv();

		ATLTRACE(_T("done backup/restore\n"));

		qi.pItf->Release();
	}

	CoUninitialize();

	// kill the distraction.
	if(me->m_AVIbox)
	{
		::PostMessage(me->m_AVIbox, WM_ASYNC_CIMOM_CONNECTED, 0, 0);
	}

	_endthread();
}


//------------------------------------------------------------------------
void CBackupPage::DealWithPath(LPCTSTR pathFile)
{
	#ifdef UNICODE
        if (m_wszArgs != NULL)
            delete m_wszArgs;

        m_wszArgs = new TCHAR[lstrlen(pathFile) + 1];

        if (m_wszArgs != NULL)
            lstrcpy(m_wszArgs, pathFile);
	#else
		size_t nSize = mbstowcs(NULL, (LPCTSTR)pathFile, _tcslen(pathFile) + 1);
		m_wszArgs = new wchar_t[nSize + 1];
		mbstowcs(m_wszArgs, (LPCTSTR)pathFile, _tcslen(pathFile) + 1);
	#endif
}

//------------------------------------------------------------------------
void CBackupPage::DealWithDomain(void)
{
	m_cred = m_DS->GetCredentials();

    // 54062- Nt 4.0 rpc crashes if given a null domain name along with a valid user name

    if((m_cred->authIdent != 0) &&
		(m_cred->authIdent->DomainLength == 0) && 
		(m_cred->authIdent->UserLength > 0) && IsNT(4))
    {
	    LPTSTR pNTDomain = NULL;

        CNtSid sid(CNtSid::CURRENT_USER);

        DWORD dwRet = sid.GetInfo(NULL, &pNTDomain, NULL);

        if(dwRet == 0)
        {
		#ifdef UNICODE
			if(m_cred->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
			{
				// convert UNICODE to ansi.
				int size = wcstombs(NULL, pNTDomain, 0);
				
				m_cred->authIdent->Domain =
                        (LPWSTR)CoTaskMemAlloc((size+1) * sizeof(TCHAR));
                if (m_cred->authIdent->Domain != NULL)
                {
				    memset(m_cred->authIdent->Domain, 0,
                            (size+1) * sizeof(TCHAR));
				    wcstombs((char *)m_cred->authIdent->Domain, pNTDomain,
                                size);
				    m_cred->authIdent->DomainLength = size;
                }
			}
			else
			{
				//straight unicode copy.
				m_cred->authIdent->DomainLength = wcslen(pNTDomain);
				m_cred->authIdent->Domain = (LPWSTR)pNTDomain;
			}
		#else // ANSI
			if(m_cred->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
			{
				//straight ansi copy.
				m_cred->authIdent->DomainLength = strlen(pNTDomain);
				m_cred->authIdent->Domain = (LPWSTR)pNTDomain;
			}
			else
			{
				// convert ansi to UNICODE.
				int size = mbstowcs(NULL, pNTDomain, 0);
				WCHAR temp[100] = {0};
				m_cred->authIdent->Domain =
                        (LPWSTR)CoTaskMemAlloc((size+1) * sizeof(WCHAR));
                if (m_cred->authIdent->Domain != NULL)
                {
				    memset(m_cred->authIdent->Domain, 0,
                            (size+1) * sizeof(WCHAR));
				    mbstowcs(temp, pNTDomain, min(99, size)); //so it's always null terminated
				    wcscpy(m_cred->authIdent->Domain, temp);
				    m_cred->authIdent->DomainLength = size;
			    }
			}

		#endif UNICODE
        }
    }
}

//----------------------------------------------------------
BOOL CBackupPage::BackupMethod(HWND hDlg, LPCTSTR pathFile)
{
	UINT prompt = IDYES;

	TCHAR drive[_MAX_DRIVE] = {0}, path[_MAX_DIR] = {0},
		  temp[_MAX_PATH] = {0};

	// rip it apart.
	_tsplitpath(pathFile, drive, path, NULL, NULL);

	_tcscpy(temp, drive);
	_tcscat(temp, path);

	if(!m_DS->IsValidDir(CHString1(temp)))
	{
		CHString1 caption, threat;
		caption.LoadString(IDS_SHORT_NAME);
		threat.LoadString(IDS_NEED_EXISTING_DIR);

		MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
							MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

		return FALSE;
	}
	else if(m_DS->IsValidFile(pathFile))
	{
		CHString1 caption, threat;
		caption.LoadString(IDS_SHORT_NAME);
		threat.LoadString(IDS_BACKUP_OVERWRITE);

		prompt = MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
							MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION);

	}		

	if(prompt == IDYES)
	{
		DealWithPath(pathFile);

		// UI
		CHString1 title, msg, fmt;
		m_AVIbox = 0;
		TCHAR shortPath[33] = {0};
		m_backupHr = S_OK;

		title.LoadString(IDS_BACKUP_TITLE);
		fmt.LoadString(IDS_BACKUP_FMT);
		
		PathCompactPathEx(shortPath, pathFile, 32,0);
		msg.Format(fmt, shortPath);
		DealWithDomain();
//		m_DS->m_rootThread.m_WbemServices.SetPriv(SE_BACKUP_NAME);
		m_doingBackup = true;

		if(_beginthread(BackupRestoreThread, 0,
						(LPVOID)this) != -1)
		{
			DisplayAVIBox(hDlg, title, msg, &m_AVIbox, FALSE);
		}

		if(FAILED(m_backupHr))
		{
			TCHAR msg[256] = {0};
			if(ErrorStringEx(m_backupHr,  msg, 256))
			{
				CHString1 caption;
				caption.LoadString(IDS_SHORT_NAME);
				MessageBox(hDlg, msg, caption, MB_OK| MB_ICONWARNING);
			}
		}
//		m_DS->m_rootThread.m_WbemServices.ClearPriv();
	}  //endif doIt

	return SUCCEEDED(m_backupHr);
}

//------------------------------------------------------------------------
HRESULT CBackupPage::RestoreMethod(HWND hDlg, LPCTSTR pathFile)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	if(m_DS->IsValidFile(pathFile))
	{
		DealWithPath(pathFile);

		// UI
		CHString1 title, msg, fmt;
		m_AVIbox = 0;
		TCHAR shortPath[33] = {0};
		
		title.LoadString(IDS_RESTORE_TITLE);
		fmt.LoadString(IDS_RESTORE_FMT);

		PathCompactPathEx(shortPath, pathFile, 32,0);
		msg.Format(fmt, shortPath);
		DealWithDomain();

		m_doingBackup = false;
		if(_beginthread(BackupRestoreThread, 0,
						(LPVOID)this) != -1)
		{
			DisplayAVIBox(hDlg, title, msg, &m_AVIbox, FALSE);
			Reconnect2();
		}

		if(FAILED(m_backupHr))
		{
			TCHAR msg[256] = {0};
			if(ErrorStringEx(m_backupHr,  msg, 256))
			{
				CHString1 caption;
				caption.LoadString(IDS_SHORT_NAME);
				MessageBox(hDlg, msg, caption, MB_OK| MB_ICONWARNING);
			}
		}
		hr = m_backupHr;
	}
	else
	{
		// NOTE: shouldn't ever get here... but..
		CHString1 caption, threat;
		caption.LoadString(IDS_SHORT_NAME);
		threat.LoadString(IDS_NO_BACKUP_FILE);

		MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
						MB_OK|MB_ICONEXCLAMATION);
	}
	return hr;
}

//------------------------------------------------------------------------
BOOL CBackupPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR * pszFilter;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

	case WM_ASYNC_CIMOM_CONNECTED:
		{
			OnFinishConnected(hDlg, lParam);
			Refresh(hDlg);
		}
		break;

    case WM_NOTIFY:
        switch(((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            Refresh(hDlg);
            break;

        case PSN_HELP:
			HTMLHelper(hDlg);
            break;

        case PSN_APPLY:
            OnApply(hDlg, (((LPPSHNOTIFY)lParam)->lParam == 1));
            break;
        }
        break;

    case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_BACKUPINTERVAL:
			if(HIWORD(wParam) == EN_KILLFOCUS)
			{
				TCHAR buf[4] = {0};
				int iVal = 0;
				::GetWindowText((HWND)lParam, buf, ARRAYSIZE(buf));
				iVal = _ttoi(buf);

				if(iVal == 0) 
				{
					BOOL enable = TRUE;
					CHString1 caption, threat;
					caption.LoadString(IDS_SHORT_NAME);
					threat.LoadString(IDS_BACKUP_THREAT);

					if(MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
									MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION) == IDYES)
					{
						ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_BACKUP_UNITS), -1);
						::EnableWindow((HWND)lParam, FALSE);
						::EnableWindow(GetDlgItem(hDlg, IDC_BACKUP_UNITS), FALSE);
						Button_SetCheck(GetDlgItem(hDlg, IDC_BACKUP_ENABLED), BST_UNCHECKED);
					}
					else
					{
						Button_SetCheck(GetDlgItem(hDlg, IDC_BACKUP_ENABLED), BST_CHECKED);
						Refresh(hDlg, true);
						return TRUE;
					}
				}

				PageChanged(PB_BACKUP, true);
			}
			else if((HIWORD(wParam) == EN_CHANGE) && 
					Edit_GetModify((HWND)lParam))
			{
				PageChanged(PB_BACKUP, true);
				return TRUE;
			}
			break;

		case IDC_BACKUP_UNITS:
			if(HIWORD(wParam) == CBN_SELCHANGE)
			{
				PageChanged(PB_BACKUP, true);
				return TRUE;
			}
			break;

		case IDC_RESTORE_FM_AUTO:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				CHString1 dbPath;

				m_DS->GetDBDir(dbPath);
				dbPath += _T("\\Cim.rec");

				CHString1 caption, threat;
				caption.LoadString(IDS_AUTORESTORE);
				threat.LoadString(IDS_SURE);

				if(MessageBox(hDlg, threat, caption, 
								MB_YESNO|MB_DEFBUTTON2|MB_ICONQUESTION) == IDYES)
				{
					RestoreMethod(hDlg, dbPath);
				}
			}
			break;

		case IDC_BACKUP_BTN:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				TCHAR pathFile[MAX_PATH] = {0};
				CHString1 dbPath;

				TCHAR recFilter[200] = {0}, all[100] = {0};

				TCHAR *pTemp = recFilter;

				m_DS->GetDBDir(dbPath);

				int recSize = ::LoadString(_Module.GetModuleInstance(), IDS_REC_FILTER,
								recFilter, 100);
				
				int allSize = ::LoadString(_Module.GetModuleInstance(), IDS_ALL_FILTER,
								all, 100);

				// Build this string with the words coming from the string table.
				//_T("WMI Recovery Files (*.rec)\0*.rec\0All Files (*.*)\0*.*\0\0");

                pszFilter = new TCHAR[_tcslen(recFilter) + 1 +
                                      ARRAYSIZE(REC_WILDCARD) +
                                      _tcslen(all) + 1 +
                                      ARRAYSIZE(ALL_WILDCARD) + 1];

                if (pszFilter != NULL)
                {
                    TCHAR * psz = pszFilter;
                    _tcscpy(psz, recFilter);
                    psz += recSize + 1;
                    _tcscpy(psz,REC_WILDCARD);
                    psz += ARRAYSIZE(REC_WILDCARD);
                    _tcscpy(psz, all);
                    psz += allSize + 1;
                    _tcscpy(psz, ALL_WILDCARD);
                    psz += ARRAYSIZE(ALL_WILDCARD);
                    *psz = _T('\0');
                                    
				    if(BrowseForFile(hDlg,
                                     IDS_OPEN_BACKUP,
                                     recFilter,
								     (LPCTSTR)dbPath,
                                     pathFile,
                                     MAX_PATH))
				    {
					    BackupMethod(hDlg, pathFile);
				    }

                    delete pszFilter;
                }
			}
			break;

		case IDC_RESTORE_BTN:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				TCHAR pathFile[MAX_PATH] = {0};
				CHString1 dbPath, title;
				TCHAR recFilter[100] = {0}, all[100] = {0};

				m_DS->GetDBDir(dbPath);

				int recSize = ::LoadString(_Module.GetModuleInstance(), IDS_REC_FILTER,
								recFilter, 100);
				
				int allSize = ::LoadString(_Module.GetModuleInstance(), IDS_ALL_FILTER,
								all, 100);

				// Build this string with the words coming from the string table.
				//_T("WMI Recovery Files (*.rec)\0*.rec\0All Files (*.*)\0*.*\0\0");

                pszFilter = new TCHAR[_tcslen(recFilter) + 1 +
                                      ARRAYSIZE(REC_WILDCARD) +
                                      _tcslen(all) + 1 +
                                      ARRAYSIZE(ALL_WILDCARD) + 1];

                if (pszFilter != NULL)
                {
                    TCHAR * psz = pszFilter;
                    _tcscpy(psz, recFilter);
                    psz += recSize + 1;
                    _tcscpy(psz,REC_WILDCARD);
                    psz += ARRAYSIZE(REC_WILDCARD);
                    _tcscpy(psz, all);
                    psz += allSize + 1;
                    _tcscpy(psz, ALL_WILDCARD);
                    psz += ARRAYSIZE(ALL_WILDCARD);
                    *psz = _T('\0');
                                    
				    if(BrowseForFile(hDlg,
                                     IDS_OPEN_RESTORE,
                                     pszFilter,
								     (LPCTSTR)dbPath,
                                     pathFile,
                                     MAX_PATH,
								     0))
				    {
					    RestoreMethod(hDlg, pathFile);
				    }

                    delete pszFilter;
                }
			}
			break;

		case IDC_BACKUP_ENABLED:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				int x = Button_GetState((HWND)lParam);
				BOOL checked = (x & BST_CHECKED);
				BOOL enable = FALSE;
				if(checked)
				{
					// turn on and repopulate the edit fields.
					CHString1 temp;
					UINT iTemp = 30;
					SetInterval(hDlg, iTemp);
					enable = TRUE;
				}
				else  // turning off.
				{
					CHString1 caption, threat;
					caption.LoadString(IDS_SHORT_NAME);
					threat.LoadString(IDS_BACKUP_THREAT);

					if(MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
									MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION) == IDYES)
					{
						SetWindowText(GetDlgItem(hDlg, IDC_BACKUPINTERVAL), _T("0"));
						ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_BACKUP_UNITS), -1);
						enable = FALSE;
					}
					else
					{
						Button_SetCheck(GetDlgItem(hDlg, IDC_BACKUP_ENABLED), BST_CHECKED);
						Refresh(hDlg);
						return TRUE;
					}
				}
				::EnableWindow(GetDlgItem(hDlg, IDC_BACKUPINTERVAL), enable);
				::EnableWindow(GetDlgItem(hDlg, IDC_BACKUP_UNITS), enable);

				PageChanged(PB_BACKUP, true);
				return TRUE;
			}
			break;

		default: break;
		} //endswitch(LOWORD(wParam))
	
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)buPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)buPageHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void CBackupPage::HideAutomaticBackupControls(HWND hDlg)
{
	ShowWindow(GetDlgItem(hDlg,IDC_AUTOMATIC_GROUPBOX),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_ADV_NOW_TEXT),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_BACKUP_ENABLED),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_BACKUPINTERVAL),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_BACKUP_UNITS),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_LASTBACKUP_LABEL),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_LASTBACKUP),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_RESTORE_FM_AUTO),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_BACKUP_UNITS),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_DBDIRECTORY_LABEL),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_DB_DIR),SW_HIDE);

	SetWindowPos(GetDlgItem(hDlg,IDC_MANUAL_GROUPBOX),NULL,7,12,0,0,SWP_NOSIZE | SWP_NOZORDER);
	SetWindowPos(GetDlgItem(hDlg,IDC_ADV_NOW_TEXT2),NULL,32,35,0,0,SWP_NOSIZE | SWP_NOZORDER);
	SetWindowPos(GetDlgItem(hDlg,IDC_BACKUP_BTN),NULL,40,97,87,14,SWP_NOSIZE | SWP_NOZORDER);
	SetWindowPos(GetDlgItem(hDlg,IDC_RESTORE_BTN),NULL,195,97,87,14,SWP_NOSIZE | SWP_NOZORDER);
	m_bWhistlerCore = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\asyncobjectsink.cpp ===
#include "precomp.h"
#include "AsyncObjectSink.h"
#include <stdio.h>

CAsyncObjectSink::CAsyncObjectSink(HWND hTreeWnd, HTREEITEM hItem,struct NSNODE *parent,DataSource *dataSrc, ENUMTYPE eType) 
{ 
	m_lRef = 0; 
	m_pParent = parent;
	m_hTreeWnd = hTreeWnd;
	m_hItem = hItem;
	m_pDataSrc = dataSrc;
	m_enumType = eType;
	m_bChildren = false;
	m_pStub = NULL;
}

CAsyncObjectSink::~CAsyncObjectSink()
{
}

ULONG CAsyncObjectSink::AddRef()
{
	return InterlockedIncrement(&m_lRef);
}

ULONG CAsyncObjectSink::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT CAsyncObjectSink::QueryInterface(REFIID riid, void** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppv = (IWbemObjectSink *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

HRESULT CAsyncObjectSink::Indicate(long lObjCount, IWbemClassObject **pArray)
{

//	OutputDebugString(_T("Indicate Received"));
	// Loop through the array, examining the objects.
	for (long i = 0; i < lObjCount; i++)
	{
		IWbemClassObject *pTemp = pArray[i];
		// Use the object
		switch(m_enumType)
		{
			case ENUM_NAMESPACE:
				m_pDataSrc->InsertNamespaceNode(m_hTreeWnd,m_hItem,m_pParent,pTemp);
				break;
			case ENUM_CLASS :
				m_pDataSrc->InsertClassNode(m_hTreeWnd,m_hItem,m_pParent,pTemp);
				break;
			case ENUM_INSTANCE:
				m_pDataSrc->InsertInstanceNode(m_hTreeWnd,m_hItem,m_pParent,pTemp);
				break;
			case ENUM_SCOPE_INSTANCE:
				m_pDataSrc->InsertScopeInstanceNode(m_hTreeWnd,m_hItem,m_pParent,pTemp);
				break;
			default:
				break;
		}
		if(m_bChildren == false)
		{
			m_bChildren = true;
			TreeView_Expand(m_hTreeWnd,m_hItem,TVE_EXPAND);
		}
	}

  return WBEM_S_NO_ERROR;
}

HRESULT CAsyncObjectSink::SetStatus(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam
    )
{
//	printf("CAsyncObjectSink::SetStatus hResult = 0x%X\n", hResult);
	if(lFlags == WBEM_STATUS_COMPLETE)
	{
		if(m_bChildren == false)
		{
			m_pDataSrc->RemovePlus(m_hTreeWnd,m_hItem);
		}
		m_pDataSrc->ProcessEndEnumAsync((IWbemObjectSink *) this);
	}
	return WBEM_S_NO_ERROR;
}

HRESULT CAsyncObjectSink::SetSinkStub(IWbemObjectSink *pStub)
{
    if (m_pStub != NULL)
        m_pStub->Release();

    m_pStub = pStub;

    if (m_pStub != NULL)
	    m_pStub->AddRef();

	return S_OK;
}

IWbemObjectSink* CAsyncObjectSink::GetSinkStub()
{
	return m_pStub;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\backuppage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __BACKUPPAGE__
#define __BACKUPPAGE__

#include "UIHelpers.h"
#include "DataSrc.h"

class CBackupPage : public CUIHelpers
{
public:
    CBackupPage(DataSource *ds, bool htmlSupport);
    virtual ~CBackupPage(void);

	// for the BackupRestoreThread.
	HRESULT m_backupHr;
	HWND m_AVIbox;
	wchar_t *m_wszArgs;
	bool m_doingBackup;
	LOGIN_CREDENTIALS *m_cred;
	bool m_bWhistlerCore;

	void SetPriv(LPCTSTR privName, IWbemBackupRestore *br);
	void ClearPriv(void);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitDlg(HWND hDlg);
	void Refresh(HWND hDlg, bool force = false);
    void OnApply(HWND hDlg, bool bClose);
	BOOL BackupMethod(HWND hDlg, LPCTSTR pathFile);
	HRESULT RestoreMethod(HWND hDlg, LPCTSTR pathFile);
	void DealWithPath(LPCTSTR pathFile);
	void DealWithDomain(void);
	void Reconnect(void);
	void Reconnect2(void);
	void OnFinishConnected(HWND hDlg, LPARAM lParam);
	void HideAutomaticBackupControls(HWND hDlg);
	void SetInterval(HWND hDlg, UINT minutes);
	bool GetInterval(HWND hDlg, UINT &iValue, bool &valid);
	int m_CBIdx;

	// for the backup thread.
	bool IsClientNT5OrMore(void);
	DWORD EnablePriv(bool fEnable, IWbemBackupRestore *br = 0);
	HANDLE m_hAccessToken;
	LUID m_luid;
	bool m_fClearToken;
	bool m_cloak;  // protects the cloak from eoac.

};
#endif __BACKUPPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\chklisthandler.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "ChkListHandler.h"
#include "resource.h"

//---------------------------------------
CCheckListHandler::CCheckListHandler()
{
	m_hDlg = 0;
	m_hwndList = 0;
}

//---------------------------------------
void CCheckListHandler::Attach(HWND hDlg, int chklistID)
{
	m_hDlg = hDlg;
	m_hwndList = GetDlgItem(hDlg, chklistID);
}

//---------------------------------------
CCheckListHandler::~CCheckListHandler()
{
	Empty();
}

//---------------------------------------
void CCheckListHandler::Empty(void)
{
    if (m_hwndList != NULL)
    {
        UINT_PTR cItems = SendMessage(m_hwndList, CLM_GETITEMCOUNT, 0, 0);

        while (cItems > 0)
        {
            cItems--;
        }
    }
    SendMessage(m_hwndList, CLM_RESETCONTENT, 0, 0);
}

//-----------------------------------------------------------------------------
void CCheckListHandler::Reset(void)
{
    SendMessage(m_hwndList, CLM_RESETCONTENT, 0, 0);
}

//-------------------------------------------------------
#define AllFlagsOn(dw1, dw2)        (((dw1) & (dw2)) == (dw2))  // equivalent to ((dw1 | dw2) == dw1)

void CCheckListHandler::HandleListClick(PNM_CHECKLIST pnmc)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\chklist.h ===
//-----------------------------------------------------------------------------
//
// chklist.h - Definitions and prototypes for the checklist pseudo-control
//
// Copyright 1996, Microsoft Corporation
//
//
//-----------------------------------------------------------------------------

#ifndef _CHKLIST_H_
#define _CHKLIST_H_

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// CheckList window class name
//
#define WC_CHECKLIST        "CHECKLIST_SCE"

//
// CheckList check states
//
#define CLST_UNCHECKED      0   // == BST_UNCHECKED
#define CLST_CHECKED        1   // == BST_CHECKED
#define CLST_DISABLED       2   // == BST_INDETERMINATE
#define CLST_CHECKDISABLED  (CLST_CHECKED | CLST_DISABLED)

//
// CheckList window styles
//
#define CLS_1CHECK          0x0001
#define CLS_2CHECK          0x0002
//#define CLS_3CHECK          0x0003
//#define CLS_4CHECK          0x0004
#define CLS_CHECKMASK       0x000f

//
// CheckList messages
//
// row is 0-based
// column is 1-based
//
#define CLM_SETCOLUMNWIDTH  (WM_USER + 1)   // lParam = width (dlg units) of a check column (default=32)
#define CLM_ADDITEM         (WM_USER + 2)   // wParam = pszName, lParam = item data, return = row
#define CLM_GETITEMCOUNT    (WM_USER + 3)   // no parameters
#define CLM_SETSTATE        (WM_USER + 4)   // wParam = row/column, lParam = state
#define CLM_GETSTATE        (WM_USER + 5)   // wParam = row/column, return = state
#define CLM_SETITEMDATA     (WM_USER + 6)   // wParam = row, lParam = item data
#define CLM_GETITEMDATA     (WM_USER + 7)   // wParam = row, return = item data
#define CLM_RESETCONTENT    (WM_USER + 8)   // no parameters
#define CLM_GETVISIBLECOUNT (WM_USER + 9)   // no parameters, return = # of visible rows
#define CLM_GETTOPINDEX     (WM_USER + 10)  // no parameters, return = index of top row
#define CLM_SETTOPINDEX     (WM_USER + 11)  // wParam = index of new top row
#define CLM_ENSUREVISIBLE   (WM_USER + 12)  // wParam = index of item to make fully visible

//
// CheckList notification messages
//
#define CLN_CLICK           (0U-1000U)      // lparam = PNM_CHECKLIST

typedef struct _NM_CHECKLIST
{
    NMHDR hdr;
    int iItem;                              // row (0-based)
    int iSubItem;                           // column (1-based)
    DWORD dwState;
    DWORD_PTR dwItemData;
} NM_CHECKLIST, *PNM_CHECKLIST;

#define CBL_GetItemCount(x) (SendMessage(x, CLM_GETITEMCOUNT, 0,0))
#define CBL_GetItemData(x,y) (SendMessage(x, CLM_GETITEMDATA,(WPARAM)y, 0))
#define CBL_GetState(x, r, c) (SendMessage(x, CLM_GETSTATE, MAKEWPARAM(r, c), 0))
#define CBL_SetState(x, r, c, s) (SendMessage(x, CLM_SETSTATE, MAKEWPARAM(r, c),(LPARAM)s))


BOOL RegisterCheckListWndClass(void);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _CHKLIST_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\chklisthandler.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __CHECKLISTHANDLER__
#define __CHECKLISTHANDLER__
#pragma once

#include "ChkList.h"

// knows how to do security stuff with the 'generic' chklist.
class CCheckListHandler
{
public:
	CCheckListHandler();
    ~CCheckListHandler();

	void Attach(HWND hDlg, int chklistID);
	void Reset(void);
	void Empty(void);

	// handles the complex relationship between allow and deny
	// checkboxes.
	void HandleListClick(PNM_CHECKLIST pnmc);
private:

	HWND m_hDlg, m_hwndList;

};
#endif __CHECKLISTHANDLER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\chklist.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*

    CHKLIST.CPP

    This file contains the implementation of the CheckList control.

*/

#include "precomp.h"
#include <windowsx.h>
#include "chklist.h"
#include "debug.h"
#include "Richedit.h"

//
// Text and Background colors
//
#define TEXT_COLOR  COLOR_WINDOWTEXT
#define BK_COLOR    COLOR_WINDOW

//
// Default dimensions for child controls. All are in dialog units.
// Currently only the column width is user-adjustable (via the
// CLM_SETCOLUMNWIDTH message).
//
#define DEFAULT_COLUMN_WIDTH    32
#define DEFAULT_CHECK_WIDTH     9
#define DEFAULT_HORZ_SPACE      7
#define DEFAULT_VERTICAL_SPACE  3
#define DEFAULT_ITEM_HEIGHT     8

//
// 16 bits are used for the control ID's, divided into n bits for
// the subitem (least significant) and 16-n bits for the item index.
//
// ID_SUBITEM_BITS can be adjusted to control the maximum number of
// items and subitems. For example, to allow up to 7 subitems and 8k
// items, set ID_SUBITEM_BITS to 3.
//

// Use the low 2 bits for the subitem index, the rest for the item index.
// (4 subitems max, 16k items max)
#define ID_SUBITEM_BITS         2

#define ID_SUBITEM_MASK         ((1 << ID_SUBITEM_BITS) - 1)
#define GET_ITEM(id)            ((id) >> ID_SUBITEM_BITS)
#define GET_SUBITEM(id)         ((id) & ID_SUBITEM_MASK)

#define MAKE_CTRL_ID(i, s)      (0xffff & (((i) << ID_SUBITEM_BITS) | ((s) & ID_SUBITEM_MASK)))
#define MAKE_LABEL_ID(i)        MAKE_CTRL_ID(i, 0)
// Note that the subitem (column) index is one-based for the checkboxes
// (the zero column is the label).  The item (row) index is zero-based.

#define MAX_CHECK_COLUMNS       ID_SUBITEM_MASK


typedef struct _USERDATA_STRUCT_LABEL
{
    LPARAM      lParam;
    int         nLabelHeight;
} USERDATA_STRUCT_LABEL, *LPUSERDATA_STRUCT_LABEL;

class CCheckList
{
private:
    LONG m_cItems;
    LONG m_cSubItems;
    RECT m_rcItemLabel;
    LONG m_nCheckPos[MAX_CHECK_COLUMNS];
    LONG m_cxCheckBox;
    LONG m_cxCheckColumn;

    int m_nDefaultVerticalSpace;
    int m_nDefaultItemHeight;
    int m_nNewItemYPos;

    HWND m_hwndCheckFocus;

    BOOL m_fInMessageEnable;

    int m_cWheelDelta;
    static UINT g_ucScrollLines;

private:
    CCheckList(HWND hWnd, LPCREATESTRUCT lpcs);

    LRESULT MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl);
    void MsgPaint(HWND hWnd, HDC hdc);
    void MsgVScroll(HWND hWnd, int nCode, int nPos);
    void MsgMouseWheel(HWND hWnd, WORD fwFlags, int zDelta);
    void MsgButtonDown(HWND hWnd, WPARAM fwFlags, int xPos, int yPos);
    void MsgEnable(HWND hWnd, BOOL fEnabled);
    void MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight);

    LONG AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam);
    void SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState);
    LONG GetState(HWND hWnd, WORD iItem, WORD iSubItem);
    void SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn);
    void ResetContent(HWND hWnd);
    LONG GetVisibleCount(HWND hWnd);
    LONG GetTopIndex(HWND hWnd, LONG *pnAmountObscured = NULL);
    void SetTopIndex(HWND hWnd, LONG nIndex);
    void EnsureVisible(HWND hWnd, LONG nIndex);
    void DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw);

public:
    static LRESULT CALLBACK WindowProc(HWND hWnd,
                                       UINT uMsg,
                                       WPARAM wParam,
                                       LPARAM lParam);
};

BOOL RegisterCheckListWndClass(void)
{
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CCheckList::WindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
//    AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
    wc.hInstance        = _Module.GetModuleInstance(); //hModule;
    wc.hIcon            = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(BK_COLOR+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = TEXT(WC_CHECKLIST);

    return (BOOL)RegisterClass(&wc);
}


UINT CCheckList::g_ucScrollLines = (UINT)-1;


CCheckList::CCheckList(HWND hWnd, LPCREATESTRUCT lpcs)
: m_cItems(0), m_hwndCheckFocus(NULL), m_fInMessageEnable(FALSE), m_cWheelDelta(0)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::CCheckList");
    TraceAssert(hWnd != NULL);
    TraceAssert(lpcs != NULL);

    //
    // Get number of check columns
    //
    m_cSubItems = lpcs->style & CLS_CHECKMASK;

    // for wsecedit only
    if ( m_cSubItems > 3 ) {
        m_cSubItems = 3;
    }

    //
    // Convert default coordinates from dialog units to pixels
    //
    RECT rc;
    rc.left = DEFAULT_CHECK_WIDTH;
    rc.right = DEFAULT_COLUMN_WIDTH;
    rc.top = rc.bottom = 0;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_cxCheckBox = rc.left;
    m_cxCheckColumn = rc.right;

    rc.left = DEFAULT_HORZ_SPACE;
    rc.top = DEFAULT_VERTICAL_SPACE;
    rc.right = 10;              // bogus (unused)
    rc.bottom = DEFAULT_VERTICAL_SPACE + DEFAULT_ITEM_HEIGHT;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_rcItemLabel = rc;

    m_nDefaultVerticalSpace = rc.top;
    m_nDefaultItemHeight = rc.bottom - rc.top;
    m_nNewItemYPos = rc.top;

    //
    // Get info for mouse wheel scrolling
    //
    if ((UINT)-1 == g_ucScrollLines)
    {
        g_ucScrollLines = 3; // default
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &g_ucScrollLines, 0);
    }

    TraceLeaveVoid();
}


LRESULT
CCheckList::MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgCommand");

    // Should only get notifications from visible, enabled, check boxes
    TraceAssert(GET_ITEM(idCmd) < m_cItems);
    TraceAssert(0 < GET_SUBITEM(idCmd) && GET_SUBITEM(idCmd) <= m_cSubItems);
    TraceAssert(hwndCtrl && IsWindowEnabled(hwndCtrl));

    switch (wNotify)
    {
    case EN_SETFOCUS:
        {
            // Make the focus go to one of the checkboxes
            POINT pt;
            DWORD dwPos = GetMessagePos();
            pt.x = GET_X_LPARAM(dwPos);
            pt.y = GET_Y_LPARAM(dwPos);
            MapWindowPoints(NULL, hWnd, &pt, 1);
            MsgButtonDown(hWnd, 0, pt.x, pt.y);
        }
        break;

    case BN_CLICKED:
        {
            LPUSERDATA_STRUCT_LABEL lpUserData;
            NM_CHECKLIST nmc;
            nmc.hdr.hwndFrom = hWnd;
            nmc.hdr.idFrom = GetDlgCtrlID(hWnd);
            nmc.hdr.code = CLN_CLICK;
            nmc.iItem = GET_ITEM(idCmd);
            nmc.iSubItem = GET_SUBITEM(idCmd);
            nmc.dwState = (DWORD)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
            if (!IsWindowEnabled(hwndCtrl))
                nmc.dwState |= CLST_DISABLED;
            lpUserData = (LPUSERDATA_STRUCT_LABEL)
                            GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID(nmc.iItem)),
                                                GWLP_USERDATA);
            nmc.dwItemData = lpUserData->lParam;

            SendMessage(GetParent(hWnd),
                        WM_NOTIFY,
                        nmc.hdr.idFrom,
                        (LPARAM)&nmc);

        }
        break;

    case BN_SETFOCUS:
        if (GetFocus() != hwndCtrl)
        {
            // This causes another BN_SETFOCUS
            SetFocus(hwndCtrl);
        }
        else
        {
            if (m_hwndCheckFocus != hwndCtrl)   // Has the focus moved?
            {
                // Remember where the focus is
                m_hwndCheckFocus = hwndCtrl;

                // Make sure the row is scrolled into view
                EnsureVisible(hWnd, GET_ITEM(idCmd));
            }
            // Always draw the focus rect
            DrawCheckFocusRect(hWnd, hwndCtrl, TRUE);
        }
        break;

    case BN_KILLFOCUS:
        // Remove the focus rect
        m_hwndCheckFocus = NULL;
        DrawCheckFocusRect(hWnd, hwndCtrl, FALSE);
        break;
    }

    TraceLeaveValue(0);
}


void
CCheckList::MsgPaint(HWND hWnd, HDC hdc)
{
    if (hdc == NULL && m_hwndCheckFocus != NULL)
    {
        // This will cause a focus rect to be drawn after the window and
        // all checkboxes have been painted.
        PostMessage(hWnd,
                    WM_COMMAND,
                    GET_WM_COMMAND_MPS(GetDlgCtrlID(m_hwndCheckFocus), m_hwndCheckFocus, BN_SETFOCUS));
    }

    // Default paint
    DefWindowProc(hWnd, WM_PAINT, (WPARAM)hdc, 0);
}


void
CCheckList::MsgVScroll(HWND hWnd, int nCode, int nPos)
{
    UINT cScrollUnitsPerLine;
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;

    if (!GetScrollInfo(hWnd, SB_VERT, &si))
        return;

    cScrollUnitsPerLine = m_rcItemLabel.bottom;

    // One page is always visible, so adjust the range to a more useful value
    si.nMax -= si.nPage - 1;

    switch (nCode)
    {
    case SB_LINEUP:
        // "line" is the height of one item (includes the space in between)
        nPos = si.nPos - cScrollUnitsPerLine;
        break;

    case SB_LINEDOWN:
        nPos = si.nPos + cScrollUnitsPerLine;
        break;

    case SB_PAGEUP:
        nPos = si.nPos - si.nPage;
        break;

    case SB_PAGEDOWN:
        nPos = si.nPos + si.nPage;
        break;

    case SB_TOP:
        nPos = si.nMin;
        break;

    case SB_BOTTOM:
        nPos = si.nMax;
        break;

    case SB_ENDSCROLL:
        nPos = si.nPos;     // don't go anywhere
        break;

    case SB_THUMBTRACK:
        // Do nothing here to allow tracking
        // nPos = si.nPos;    // Do this to prevent tracking
    case SB_THUMBPOSITION:
        // nothing to do here... nPos is passed in
        break;
    }

    // Make sure the new position is within the range
    if (nPos < si.nMin)
        nPos = si.nMin;
    else if (nPos > si.nMax)
        nPos = si.nMax;

    if (nPos != si.nPos)  // are we moving?
    {
        SetScrollPos(hWnd, SB_VERT, nPos, TRUE);
        ScrollWindow(hWnd, 0, si.nPos - nPos, NULL, NULL);
    }
}


void
CCheckList::MsgMouseWheel(HWND hWnd, WORD fwFlags, int iWheelDelta)
{
    int cDetants;

    if ((fwFlags & (MK_SHIFT | MK_CONTROL)) || 0 == g_ucScrollLines)
        return;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgMouseWheel");

    // Update count of scroll amount
    m_cWheelDelta -= iWheelDelta;
    cDetants = m_cWheelDelta / WHEEL_DELTA;
    if (0 == cDetants)
        TraceLeaveVoid();
    m_cWheelDelta %= WHEEL_DELTA;

    if (WS_VSCROLL & GetWindowLong(hWnd, GWL_STYLE))
    {
        SCROLLINFO  si;
        UINT        cScrollUnitsPerLine;
        UINT        cLinesPerPage;
        UINT        cLinesPerDetant;

        // Get the scroll amount of one line
        cScrollUnitsPerLine = m_rcItemLabel.bottom;
        TraceAssert(cScrollUnitsPerLine > 0);

        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_PAGE | SIF_POS;
        if (!GetScrollInfo(hWnd, SB_VERT, &si))
            TraceLeaveVoid();

        // The size of a page is at least one line, and
        // leaves one line of overlap
        cLinesPerPage = (si.nPage - cScrollUnitsPerLine) / cScrollUnitsPerLine;
        cLinesPerPage = max(1, cLinesPerPage);

        // Don't scroll more than one page per detant
        cLinesPerDetant = min(cLinesPerPage, g_ucScrollLines);

        si.nPos += cDetants * cLinesPerDetant * cScrollUnitsPerLine;

        MsgVScroll(hWnd, SB_THUMBTRACK, si.nPos);
    }
    TraceLeaveVoid();
}


void
CCheckList::MsgButtonDown(HWND hWnd, WPARAM /*fwFlags*/, int /*xPos*/, int yPos)
{
    LONG nItemIndex;
    HWND hwndCheck;
    RECT rc;

    // Get position of the top visible item in client coords
    nItemIndex = GetTopIndex(hWnd);
    if (nItemIndex == -1)
    {
        return;
    }
    hwndCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(nItemIndex, 0));
    GetWindowRect(hwndCheck, &rc);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rc, 2);

    // Find nearest item
    nItemIndex += (yPos - rc.top + m_rcItemLabel.top/2)/m_rcItemLabel.bottom;
    nItemIndex = max(0, min(nItemIndex, m_cItems - 1)); // 0 <= y < m_cItems

    // Set focus to first subitem that is enabled
    for (LONG j = 1; j <= m_cSubItems; j++)
    {
        int id = MAKE_CTRL_ID(nItemIndex, j);
        HWND hwndCheck = GetDlgItem(hWnd, id);
        if (IsWindowEnabled(hwndCheck))
        {
            // Don't just SetFocus here.  We sometimes call this during
            // EN_SETFOCUS, and USER doesn't like it when you mess with
            // focus during a focus change.
            //
            //SetFocus(hwndCheck);
            PostMessage(hWnd,
                        WM_COMMAND,
                        GET_WM_COMMAND_MPS(id, hwndCheck, BN_SETFOCUS));
            break;
        }
    }
}


void
CCheckList::MsgEnable(HWND hWnd, BOOL fEnabled)
{
    HWND hwndCurrentCheck;
    BOOL fCheckEnabled;

    if (!m_fInMessageEnable)
    {
        m_fInMessageEnable = TRUE;
        for (LONG i = 0; i < m_cItems; i++)
        {
            for (LONG j = 1; j <= m_cSubItems; j++)
            {
                hwndCurrentCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(i, j));
                fCheckEnabled =   (BOOL) GetWindowLongPtr(hwndCurrentCheck, GWLP_USERDATA);

                //
                // If the user of the checklist control is disabling the control
                // altogether, or the current checkbox has been disabled singularly
                // then disable the checkbox
                //
                if (!fEnabled || !fCheckEnabled)
                {
                    EnableWindow(hwndCurrentCheck, FALSE);
                }
                else
                {
                    EnableWindow(hwndCurrentCheck, TRUE);
                }
            }
        }
        // Note that the main chklist window must remain enabled
        // for scrolling to work while "disabled".
        if (!fEnabled)
            EnableWindow(hWnd, TRUE);

        m_fInMessageEnable = FALSE;
    }
}


void
CCheckList::MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgSize");
    TraceAssert(hWnd != NULL);

    if (dwSizeType == SIZE_RESTORED)
    {
        RECT rc;
        SCROLLINFO si;

        si.cbSize = sizeof(si);
        si.fMask = SIF_RANGE | SIF_PAGE;
        si.nMin = 0;
        si.nMax = m_nNewItemYPos - 1;
        si.nPage = nHeight;

        SetScrollInfo(hWnd, SB_VERT, &si, FALSE);

        // Don't trust the width value passed in, since SetScrollInfo may
        // affect it if the scroll bar is turning on or off.
        GetClientRect(hWnd, &rc);
        nWidth = rc.right;

        // If the scrollbar is turned on, artificially bump up the width
        // by the width of the scrollbar, so the boxes don't jump to the left
        // when we have a scrollbar.
        if ((UINT)si.nMax >= si.nPage)
            nWidth += GetSystemMetrics(SM_CYHSCROLL);

        SetColumnWidth(hWnd, nWidth, m_cxCheckColumn);
    }

    TraceLeaveVoid();
}

LONG
CCheckList::AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam)
{
    HWND                    hwndNew;
    HWND                    hwndPrev;
    RECT                    rc;
    LONG                    nLabelHeight;
    HINSTANCE               hModule;
    HDC                     hdc;
    TEXTRANGE               tr;
    SIZE                    size;
    LPUSERDATA_STRUCT_LABEL lpUserData;
    SCROLLINFO              si;
    LONG                    nLineCount = 1;
    LONG                    i, j;
    DWORD                   dwCheckStyle;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::AddItem");
    TraceAssert(hWnd != NULL);
    TraceAssert(pszLabel != NULL && !IsBadStringPtr(pszLabel, MAX_PATH));

    lpUserData = new (USERDATA_STRUCT_LABEL);
    if (lpUserData == NULL)
        TraceLeaveValue(-1);

    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;
    si.nPos = 0;
    GetScrollInfo(hWnd, SB_VERT, &si);

    // Set the initial label height extra big so the control can wrap the text,
    // then reset it after creating the control.
    GetClientRect(hWnd, &rc);
    nLabelHeight = rc.bottom;

//    AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
    hModule = _Module.GetModuleInstance();

    // Create a new label control
    hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                             TEXT("edit"),
                             pszLabel,
                             WS_CHILD | WS_VISIBLE | WS_GROUP | ES_MULTILINE | ES_READONLY | ES_LEFT,// | WS_GROUP,
                             m_rcItemLabel.left,
                             m_nNewItemYPos - si.nPos,
                             m_rcItemLabel.right - m_rcItemLabel.left,
                             nLabelHeight,
                             hWnd,
                             (HMENU)IntToPtr(MAKE_LABEL_ID(m_cItems)),
                             hModule,
                             NULL);
    if (!hwndNew)
    {
        delete (lpUserData);
        TraceLeaveValue(-1);
    }

    //
    // Reset window height after word wrap has been done.
    //
    nLineCount = (LONG) SendMessage(hwndNew, EM_GETLINECOUNT, 0, (LPARAM) 0);
    nLabelHeight = nLineCount * m_nDefaultItemHeight;
    SetWindowPos(hwndNew,
                 NULL,
                 0,
                 0,
                 m_rcItemLabel.right - m_rcItemLabel.left,
                 nLabelHeight,
                 SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    //
    // Save item data
    //
    lpUserData->lParam = lParam;
    lpUserData->nLabelHeight = nLabelHeight;
    SetWindowLongPtr(hwndNew, GWLP_USERDATA, (LPARAM) lpUserData);

    // Set the font
    SendMessage(hwndNew,
                WM_SETFONT,
                SendMessage(GetParent(hWnd), WM_GETFONT, 0, 0),
                0);

    // Set Z-order position just after the last checkbox. This keeps
    // tab order correct.
    if (m_cItems > 0)
    {
        hwndPrev = GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems - 1, m_cSubItems));
        SetWindowPos(hwndNew,
                     hwndPrev,
                     0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    // Create new checkboxes
    dwCheckStyle = WS_CHILD | WS_VISIBLE | WS_GROUP | WS_TABSTOP | BS_NOTIFY | BS_FLAT | BS_AUTOCHECKBOX;
    for (j = 0; j < m_cSubItems; j++)
    {
        hwndPrev = hwndNew;
        hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                                 TEXT("BUTTON"),
                                 NULL,
                                 dwCheckStyle,
                                 m_nCheckPos[j],
                                 m_nNewItemYPos - si.nPos,
                                 m_cxCheckBox,
                                 m_rcItemLabel.bottom - m_rcItemLabel.top,
                                 hWnd,
                                 (HMENU)IntToPtr(MAKE_CTRL_ID(m_cItems, j + 1)),
                                 hModule,
                                 NULL);
        if (!hwndNew)
        {
            while (j >= 0)
            {
                DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems, j)));
                j--;
            }

            TraceLeaveValue(-1);
        }

        SetWindowPos(hwndNew,
                     hwndPrev,
                     0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        //
        // Default "enabled" to TRUE
        //
        SetWindowLongPtr(hwndNew, GWLP_USERDATA, (LPARAM) TRUE);

        // Only want this style on the first checkbox
        dwCheckStyle &= ~WS_GROUP;
    }

    // We now officially have a new item
    m_cItems++;

    // calculate Y pos for next item to be inserted
    m_nNewItemYPos += nLabelHeight + m_nDefaultVerticalSpace;

    //
    // The last thing is to set the scroll range
    //
    GetClientRect(hWnd, &rc);
    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE | SIF_RANGE;
    si.nMin = 0;
    si.nMax = m_nNewItemYPos - 1;
    si.nPage = rc.bottom;

    SetScrollInfo(hWnd, SB_VERT, &si, FALSE);

    TraceLeaveValue(m_cItems - 1);  // return the index of the new item
}


void
CCheckList::SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState)
{
    HWND hwndCtrl;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetState");
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

    if (iSubItem > 0)
    {
        hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));
        if (hwndCtrl != NULL)
        {
            SetWindowLongPtr(hwndCtrl, GWLP_USERDATA, (LPARAM) !(lState & CLST_DISABLED));
            SendMessage(hwndCtrl, BM_SETCHECK, lState & CLST_CHECKED, 0);
            EnableWindow(hwndCtrl, !(lState & CLST_DISABLED));
        }
    }

    TraceLeaveVoid();
}


LONG
CCheckList::GetState(HWND hWnd, WORD iItem, WORD iSubItem)
{
    LONG lState = 0;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::GetState");
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

    HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));

    if (hwndCtrl != NULL)
    {
        lState = (LONG)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
        TraceAssert(!(lState & BST_INDETERMINATE));

        if (!IsWindowEnabled(hwndCtrl))
            lState |= CLST_DISABLED;
    }

    TraceLeaveValue(lState);
}


void
CCheckList::SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn)
{
    LONG                    j;
    LPUSERDATA_STRUCT_LABEL pUserData;
    LONG                    nLabelHeight;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetColumnWidth");
    TraceAssert(hWnd != NULL);
    TraceAssert(cxColumn > 10);

    m_cxCheckColumn = cxColumn;

    if (m_cSubItems > 0)
    {
        m_nCheckPos[m_cSubItems-1] = cxDialog                       // dlg width
                                    - m_rcItemLabel.left            // right margin
                                    - (cxColumn + m_cxCheckBox)/2;  // 1/2 col & 1/2 checkbox

        for (j = m_cSubItems - 1; j > 0; j--)
            m_nCheckPos[j-1] = m_nCheckPos[j] - cxColumn;

        //              (leftmost check pos) - (horz margin)
        m_rcItemLabel.right = m_nCheckPos[0] - m_rcItemLabel.left;
    }
    else
        m_rcItemLabel.right = cxDialog - m_rcItemLabel.left;

    LONG nTop = m_rcItemLabel.top;
    LONG nBottom = m_rcItemLabel.bottom;

    for (LONG i = 0; i < m_cItems; i++)
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)i)),
                                        GWLP_USERDATA);
        if (pUserData != NULL)
        {
            nLabelHeight = pUserData->nLabelHeight;
        }
        else
        {
            nLabelHeight = nBottom - nTop;
        }

        MoveWindow(GetDlgItem(hWnd, MAKE_LABEL_ID(i)),
                   m_rcItemLabel.left,
                   nTop,
                   m_rcItemLabel.right - m_rcItemLabel.left,
                   nLabelHeight,
                   FALSE);

        for (j = 0; j < m_cSubItems; j++)
        {
            MoveWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j + 1)),
                       m_nCheckPos[j],
                       nTop,
                       m_cxCheckBox,
                       nBottom - nTop,
                       FALSE);
        }

        nTop += nLabelHeight + m_nDefaultVerticalSpace;
        nBottom += nLabelHeight + m_nDefaultVerticalSpace;
    }

    TraceLeaveVoid();
}


void
CCheckList::ResetContent(HWND hWnd)
{
    LPUSERDATA_STRUCT_LABEL pUserData;
    HWND                    hwndCurrentLabel;

    for (LONG i = 0; i < m_cItems; i++)
    {
        hwndCurrentLabel = GetDlgItem(hWnd, MAKE_LABEL_ID((int)i));
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   hwndCurrentLabel,
                                        GWLP_USERDATA);
        if (pUserData != NULL)
        {
            delete(pUserData);
        }
        DestroyWindow(hwndCurrentLabel);

        for (LONG j = 1; j <= m_cSubItems; j++)
        {
            DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)));
        }
    }

    // Hide the scroll bar
    SetScrollRange(hWnd, SB_VERT, 0, 0, FALSE);
    m_cItems = 0;
}


LONG
CCheckList::GetVisibleCount(HWND hWnd)
{
    LONG                    nCount = 0;
    RECT                    rc;
    LONG                    nTopIndex;
    LONG                    nAmountShown = 0;
    LONG                    nAmountObscured = 0;
    LPUSERDATA_STRUCT_LABEL pUserData;

    if (!GetClientRect(hWnd, &rc))
    {
        return 1;
    }

    nTopIndex = GetTopIndex(hWnd, &nAmountObscured);
    if (nTopIndex == -1)
    {
        return 1;
    }

    while ((nTopIndex < m_cItems) && (nAmountShown < rc.bottom))
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nTopIndex)),
                                        GWLP_USERDATA);
        nAmountShown += (m_nDefaultVerticalSpace + pUserData->nLabelHeight - nAmountObscured);
        nAmountObscured = 0;    // nAmountObscured only matters for the first iteration where
                                // the real top index's amount shown is being calculated
        nCount++;
        nTopIndex++;
    }

    //
    // since that last one may be obscured see if we need to adjust nCount
    //
    if (nAmountShown > rc.bottom)
    {
        nCount--;
    }

    return max(1, nCount);
}

LONG
CCheckList::GetTopIndex(HWND hWnd, LONG *pnAmountObscured)
{
    LONG                    nIndex = 0;
    LPUSERDATA_STRUCT_LABEL pUserData;
    SCROLLINFO              si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;

    //
    // initialize
    //
    if (pnAmountObscured != NULL)
    {
        *pnAmountObscured = 0;
    }

    if (GetScrollInfo(hWnd, SB_VERT, &si) && m_rcItemLabel.bottom > 0)
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nIndex)),
                                        GWLP_USERDATA);
        //
        // if there are no items get out
        //
        if (pUserData == NULL)
        {
            return -1;
        }

        while (si.nPos >= (m_nDefaultVerticalSpace + pUserData->nLabelHeight))
        {
            si.nPos -= (m_nDefaultVerticalSpace + pUserData->nLabelHeight);
            nIndex++;
            pUserData = (LPUSERDATA_STRUCT_LABEL)
                        GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nIndex)),
                                            GWLP_USERDATA);
        }

        if (pnAmountObscured != NULL)
        {
            *pnAmountObscured = si.nPos;
        }
    }

    return nIndex;
}

void
CCheckList::SetTopIndex(HWND hWnd, LONG nIndex)
{
    int                     i;
    int                     nPos = 0;
    LPUSERDATA_STRUCT_LABEL pUserData;

    for (i=0; i<nIndex; i++)
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)i)),
                                        GWLP_USERDATA);
        nPos += (m_nDefaultVerticalSpace + pUserData->nLabelHeight);
    }

    m_cWheelDelta = 0;
    MsgVScroll(hWnd, SB_THUMBPOSITION, nPos);
}


void
CCheckList::EnsureVisible(HWND hWnd, LONG nItemIndex)
{
    LONG                    nAmountObscured = 0;
    LONG                    nTopIndex;
    RECT                    rc;
    LPUSERDATA_STRUCT_LABEL pUserData;

    nTopIndex = GetTopIndex(hWnd, &nAmountObscured);
    if (nTopIndex == -1)
    {
        return;
    }

    // Note that the top item may only be partially visible,
    // so we need to test for equality here.  Raid #208449
    if (nItemIndex < nTopIndex)
    {
        SetTopIndex(hWnd, nItemIndex);
    }
    else if (nItemIndex == nTopIndex)
    {
        if (nAmountObscured != 0)
        {
            SetTopIndex(hWnd, nItemIndex);
        }
    }
    else
    {
        LONG nVisible = GetVisibleCount(hWnd);

        if (nItemIndex >= nTopIndex + nVisible)
        {
            if (!GetClientRect(hWnd, &rc))
            {
                //
                // This is just best effort
                //
                SetTopIndex(hWnd, nItemIndex - nVisible + 1);
            }
            else
            {
                //
                // Calculate what the top index should be to allow
                // nItemIndex to be fully visible
                //
                nTopIndex = nItemIndex + 1;
                do
                {
                    nTopIndex--;
                    pUserData = (LPUSERDATA_STRUCT_LABEL)
                                GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nTopIndex)),
                                                    GWLP_USERDATA);
                    if (pUserData != NULL)
                    {
                        rc.bottom -= (pUserData->nLabelHeight + m_nDefaultVerticalSpace);
                        if (rc.bottom < 0)
                        {
                            nTopIndex++;
                        }
                    }
                    else
                    {
                        //
                        // Should not hit this, just added to make things safe
                        //
                        rc.bottom = 0;
                        nTopIndex = 0;
                    }
                } while (rc.bottom > 0);

                SetTopIndex(hWnd, nTopIndex);
            }
        }
    }
}


void
CCheckList::DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw)
{
    RECT rcCheck;
    HDC hdc;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::DrawCheckFocusRect");
    TraceAssert(hWnd != NULL);
    TraceAssert(hwndCheck != NULL);

    GetWindowRect(hwndCheck, &rcCheck);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rcCheck, 2);
    InflateRect(&rcCheck, 2, 2);    // draw *outside* the checkbox

    hdc = GetDC(hWnd);
    if (hdc)
    {
        // Always erase before drawing, since we may already be
        // partially visible and drawing is an XOR operation.
        // (Don't want to leave any turds on the screen.)

        FrameRect(hdc, &rcCheck, GetSysColorBrush(BK_COLOR));

        if (fDraw)
        {
            SetTextColor(hdc, GetSysColor(TEXT_COLOR));
            SetBkColor(hdc, GetSysColor(BK_COLOR));
            DrawFocusRect(hdc, &rcCheck);
        }

        ReleaseDC(hWnd, hdc);
    }

    TraceLeaveVoid();
}

LRESULT
CALLBACK
CCheckList::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT                 lResult = 0;
    LPUSERDATA_STRUCT_LABEL pUserData = NULL;
    CCheckList *pThis = (CCheckList*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    TraceEnter(TRACE_CHECKLIST, "CCheckList::WindowProc");
    TraceAssert(hWnd != NULL);

    switch (uMsg)
    {
    case WM_NCCREATE:
        pThis = new CCheckList(hWnd, (LPCREATESTRUCT)lParam);
        if (pThis != NULL)
        {
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            lResult = TRUE;
        }
        break;

    case WM_DESTROY:
        pThis->ResetContent(hWnd);
        break;

    case WM_NCDESTROY:
        delete pThis;
        break;

    case WM_COMMAND:
        TraceAssert(pThis != NULL);
        lResult = pThis->MsgCommand(hWnd,
                                    GET_WM_COMMAND_ID(wParam, lParam),
                                    GET_WM_COMMAND_CMD(wParam, lParam),
                                    GET_WM_COMMAND_HWND(wParam, lParam));
        break;

    case WM_CTLCOLORSTATIC:
        TraceAssert(pThis != NULL);
        SetBkMode((HDC)wParam, TRANSPARENT);
        SetTextColor((HDC)wParam, GetSysColor(TEXT_COLOR));
        SetBkColor((HDC)wParam, GetSysColor(BK_COLOR));
        lResult = (LRESULT)GetSysColorBrush(BK_COLOR);
        break;

    case WM_PAINT:
        TraceAssert(pThis != NULL);
        pThis->MsgPaint(hWnd, (HDC)wParam);
        break;

    case WM_VSCROLL:
        TraceAssert(pThis != NULL);
        pThis->MsgVScroll(hWnd,
                          (int)(short)GET_WM_VSCROLL_CODE(wParam, lParam),
                          (int)(short)GET_WM_VSCROLL_POS(wParam, lParam));
        break;

    case WM_MOUSEWHEEL:
        TraceAssert(pThis != NULL);
        pThis->MsgMouseWheel(hWnd,
                             LOWORD(wParam),
                             (int)(short)HIWORD(wParam));
        break;

    case WM_LBUTTONDOWN:
        TraceAssert(pThis != NULL);
        pThis->MsgButtonDown(hWnd,
                             wParam,
                             (int)(short)LOWORD(lParam),
                             (int)(short)HIWORD(lParam));
        break;

    case WM_ENABLE:
        TraceAssert(pThis != NULL);
        pThis->MsgEnable(hWnd, (BOOL)wParam);
        break;

    case WM_SETFONT:
        TraceAssert(pThis != NULL);
        {
            for (LONG i = 0; i < pThis->m_cItems; i++)
                SendDlgItemMessage(hWnd,
                                   MAKE_LABEL_ID(i),
                                   WM_SETFONT,
                                   wParam,
                                   lParam);
        }
        break;

    case WM_SIZE:
        TraceAssert(pThis != NULL);
        pThis->MsgSize(hWnd, (DWORD)wParam, LOWORD(lParam), HIWORD(lParam));
        break;

    case CLM_ADDITEM:
        TraceAssert(pThis != NULL);
        lResult = pThis->AddItem(hWnd, (LPCTSTR)wParam, lParam);
        break;

    case CLM_GETITEMCOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->m_cItems;
        break;

    case CLM_SETSTATE:
        TraceAssert(pThis != NULL);
        pThis->SetState(hWnd, LOWORD(wParam), HIWORD(wParam), (LONG)lParam);
        break;

    case CLM_GETSTATE:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetState(hWnd, LOWORD(wParam), HIWORD(wParam));
        break;

    case CLM_SETCOLUMNWIDTH:
        TraceAssert(pThis != NULL);
        {
            RECT rc;
            LONG cxDialog;

            GetClientRect(hWnd, &rc);
            cxDialog = rc.right;

            rc.right = (LONG)lParam;
            MapDialogRect(GetParent(hWnd), &rc);

            pThis->SetColumnWidth(hWnd, cxDialog, rc.right);
        }
        break;

    case CLM_SETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                                        GWLP_USERDATA);
        if (pUserData != NULL)
            pUserData->lParam = lParam;
        break;

    case CLM_GETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                                        GWLP_USERDATA);
        if (pUserData != NULL)
            lResult = pUserData->lParam;
        break;

    case CLM_RESETCONTENT:
        TraceAssert(pThis != NULL);
        pThis->ResetContent(hWnd);
        break;

    case CLM_GETVISIBLECOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetVisibleCount(hWnd);
        break;

    case CLM_GETTOPINDEX:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetTopIndex(hWnd);
        break;

    case CLM_SETTOPINDEX:
        TraceAssert(pThis != NULL);
        pThis->SetTopIndex(hWnd, (LONG)wParam);
        break;

    case CLM_ENSUREVISIBLE:
        TraceAssert(pThis != NULL);
        pThis->EnsureVisible(hWnd, (LONG)wParam);
        break;

    //
    // Always refer to the chklist window for help. Don't pass
    // one of the child window handles here.
    //
    case WM_HELP:
        ((LPHELPINFO)lParam)->hItemHandle = hWnd;
        lResult = SendMessage(GetParent(hWnd), uMsg, wParam, lParam);
        break;
    case WM_CONTEXTMENU:
        lResult = SendMessage(GetParent(hWnd), uMsg, (WPARAM)hWnd, lParam);
        break;

    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT)
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            lResult = TRUE;
            break;
        }
    // Fall Through
    default:
        lResult = DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    TraceLeaveValue(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\debug.h ===
#ifndef __debug_h
#define __debug_h


/*-----------------------------------------------------------------------------
/ Debugging APIs (use the Macros, they make it easier and cope with correctly
/ removing debugging when it is disabled at built time).
/----------------------------------------------------------------------------*/
/*
void DoTraceSetMask(DWORD dwMask);
void DoTraceEnter(DWORD dwMask, LPCTSTR pName);
void DoTraceLeave(void);
void DoTrace(LPCTSTR pFormat, ...);
void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID);
void DoTraceAssert(int iLine, LPTSTR pFilename);
*/

/*-----------------------------------------------------------------------------
/ Macros to ease the use of the debugging APIS.
/----------------------------------------------------------------------------*/

#pragma warning(disable:4127)	// conditional expression is constant

#if DBG
#ifndef DEBUG
#define DEBUG
#endif
#define debug if ( TRUE )
#else
#undef  DEBUG
#define debug if ( FALSE )
#endif

#ifdef NEVER //DEBUG
#define TraceSetMask(dwMask)    debug DoTraceSetMask(dwMask)
#define TraceEnter(dwMask, fn)  debug DoTraceEnter(dwMask, TEXT(fn))
#define TraceLeave              debug DoTraceLeave

#define Trace                   debug DoTrace
#define TraceMsg(s)             debug DoTrace(TEXT(s))
#define TraceGUID(s, rGUID)     debug DoTraceGUID(TEXT(s), rGUID)


#define TraceAssert(x) \
                { if ( !(x) ) DoTraceAssert(__LINE__, TEXT(__FILE__)); }

#define TraceLeaveResult(hr) \
                { HRESULT __hr = hr; if (FAILED(__hr)) Trace(TEXT("Failed (%08x)"), hr); TraceLeave(); return __hr; }

#define TraceLeaveVoid() \
                { TraceLeave(); return; }

#define TraceLeaveValue(value) \
                { TraceLeave(); return(value); }

#else
#define TraceAssert(x)
#define TraceLeaveResult(hr)    { return hr; }
#define TraceLeaveVoid()	{ return; }
#define TraceLeaveValue(value)  { return(value); }

#define TraceSetMask(dwMask)  
#define TraceEnter(dwMask, fn)
#define TraceLeave           

#define Trace               
#define TraceMsg(s)        
#define TraceGUID(s, rGUID)


#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\errorsecpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#if !defined(AFX_ERRORSECPAGE_H)
#define AFX_ERRORSECPAGE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RootSecPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CErrorSecurityPage dialog
#include "UIHelpers.h"

class CErrorSecurityPage : public CUIHelpers
{
// Construction
public:
	CErrorSecurityPage(UINT msg);   // standard constructor

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
	void InitDlg(HWND hDlg);

	UINT m_msg;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ERRORSECPAGE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\errorsecpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// RootSecPage.cpp : implementation file
//

#include "precomp.h"
#include "ErrorSecPage.h"
#include "DataSrc.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CErrorSecurityPage dialog


CErrorSecurityPage::CErrorSecurityPage(UINT msg) :
					CUIHelpers(NULL, NULL, false),
					m_msg(msg)
{
}

//---------------------------------------------------------------------------
void CErrorSecurityPage::InitDlg(HWND hDlg)
{
    HWND hwnd = GetDlgItem(hDlg, IDC_NO_SECURITY);

	CHString1 msgStr;
	if(msgStr.LoadString(m_msg))
	{
		::SetWindowText(hwnd, (LPCTSTR)msgStr);
	}
	else
	{
		::SetWindowText(hwnd, _T("Cannot display the correct problem due to an internal error."));
	}
}

//------------------------------------------------------------------------
BOOL CErrorSecurityPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\genpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __GENERALPAGE__
#define __GENERALPAGE__

#include "UIHelpers.h"
#include "CHString1.h"
#include <mmc.h>

class DataSource;
class CGenPage : public CUIHelpers
{
private:

public:
    CGenPage(DataSource *ds, bool htmlSupport);
    virtual ~CGenPage(void);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitDlg(HWND hDlg);
	void Refresh(HWND hDlg);
	void OnConnect(HWND hDlg, LOGIN_CREDENTIALS *credentials = NULL);
	void OnFinishConnected(HWND hDlg, LPARAM lParam);
	void StatusIcon(HWND hDlg, UINT icon);
	void SetUserName(HWND hDlg, LOGIN_CREDENTIALS *credentials);
	size_t UserLen(LOGIN_CREDENTIALS *credentials);
	void MinorError(CHString1 &initMsg, UINT fmtID, 
					HRESULT hr, CHString1 &success);

	bool m_connected;
	CHString1 m_machineName;
	HRESULT m_DSStatus;
};


#endif __GENERALPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\datasrc.cpp ===
// Copyright (c) 1999 Microsoft Corporation
#include "precomp.h"
#include "DataSrc.h"
#include "..\common\util.h"
#include "resource.h"
#include <stdio.h>
#include "si.h"
#include <cominit.h>
#include "ShlWapi.h"
#include "AsyncObjectSink.h"
#include "UIHelpers.h"

#define FULLACCTSIZE 100
//---------------------------------------------------------
DataSource::DataSource():m_cRef(1)
{
	CoInitialize(NULL);
	m_OSType = 0;				//UNKNOWN;
	m_user.authIdent = NULL;
	m_user.currUser = true;
	memset(m_user.fullAcct, 0, FULLACCTSIZE * sizeof(TCHAR));
	m_hImageList = 0;
	m_folderIcon = 0;
	m_earthIcon = 0;
	m_classIcon = 0;
	m_instanceIcon = 0;
	m_scopeInstanceIcon = 0;
	m_scopeClassIcon = 0;
	m_sessionID = 0;

	m_NSCache.display = 0;
	m_NSCache.fullPath = 0;
	m_NSCache.ns = 0;

    m_hwndPropSheet = NULL;

	//Initialize return codes to failed state and namespaces to disconnected state
	m_securityHr = E_FAIL;
	m_osHr = E_FAIL;
	m_cpuHr = E_FAIL;
	m_settingHr = E_FAIL;

	m_rootSecNS.DisconnectServer();
	m_cimv2NS.DisconnectServer();

}

//---------------------------------------------------------
DataSource::~DataSource()
{
	CancelAllAsyncCalls();
	Disconnect();
	CoUninitialize();
}

//---------------------------------------------------------
// connecting.
void DataSource::SetMachineName(CHString1 &machine)
{
	TCHAR curComp[256] = {0};
	DWORD size = ARRAYSIZE(curComp);

	// check the whacks
	if (GetComputerName(curComp, &size))
	{
		// if local...
		if((machine.GetLength() == 0) ||
			(machine == curComp))
		{
			m_whackedMachineName = "";
		}
		else if(machine[0] == _T('\\')) // its whacked.
		{
			m_whackedMachineName = machine;
		}
		else  //its not whacked.
		{
			m_whackedMachineName = _T("\\\\");
			m_whackedMachineName += machine;
		}
	}
	else //failed to get local computer name
		m_whackedMachineName = "";
}

//---------------------------------------------------------
// connecting.
HRESULT DataSource::Connect(LOGIN_CREDENTIALS *credentials, HWND notify)
{
	// start the connection thread.
	if(m_rootThread.Connect((bstr_t)m_whackedMachineName, "root", true, credentials, notify))
	{
	}

	m_sessionID++;
	return m_rootThread.m_hr;
}

//----------------------------------------------------------
// closes property sheet if displated
void DataSource::ClosePropSheet()
{
    if (m_hwndPropSheet)
    {
        SendMessage(m_hwndPropSheet, WM_CLOSE, 0, 0 );
        m_hwndPropSheet = NULL;
    }
}

//----------------------------------------------------------
bool DataSource::IsNewConnection(long *sessionID)
{
	bool retval = false;
	if(m_sessionID != *sessionID)
	{
		*sessionID = m_sessionID;
		retval = true;
	}
	return retval;
}

//----------------------------------------------------------
HRESULT DataSource::Reconnect(void)
{
	Disconnect();
	Connect(GetCredentials());
	return m_rootThread.m_hr;
}

//----------------------------------------------------------
HRESULT DataSource::Initialize(IWbemServices *pServices)
{
	IWbemClassObject *pInst = NULL;
	HRESULT retval = S_OK;
	
	m_securityHr = S_OK;
	m_osHr = S_OK;
	m_cpuHr = S_OK;
	m_settingHr = S_OK;

	if(pServices == 0) return E_FAIL;

	try 
	{
		m_rootThread.m_WbemServices.DisconnectServer();
		m_rootThread.m_WbemServices = pServices;
		m_rootThread.m_WbemServices.m_authIdent = m_user.authIdent;

		if(m_rootThread.m_status == WbemServiceThread::ready)
		{

			m_cimv2NS.DisconnectServer();
			// we'll use some general info from root\cimv2
			m_cimv2NS = m_rootThread.m_WbemServices.OpenNamespace("cimv2");
			m_cimv2NS.m_authIdent = m_user.authIdent;

			if((bool)m_cimv2NS)
			{
				if((pInst = m_cimv2NS.FirstInstanceOf("Win32_OperatingSystem")) != NULL)
				{
					m_OS = pInst;
					m_OSType = (short)m_OS.GetLong("OSType");
				}
				m_osHr = m_cimv2NS.m_hr;

				if((pInst = m_cimv2NS.FirstInstanceOf("Win32_Processor")) != NULL)
				{
					m_cpu = pInst;
				}
				m_cpuHr = m_cimv2NS.m_hr;

				m_winMgmt = m_cimv2NS.GetObject("Win32_WMISetting=@");

				// if the wmisetting class doesn't even exist....	
				if(!(bool)m_winMgmt)
				{
					// create what we can on the fly.
					UpdateOldBuild();
					
					// try again.
					m_winMgmt = m_cimv2NS.GetObject("Win32_WMISetting=@");
				}
				m_settingHr = m_cimv2NS.m_hr;
			}
			else
			{
				m_osHr = m_rootThread.m_WbemServices.m_hr;
				m_cpuHr = m_rootThread.m_WbemServices.m_hr;
				m_settingHr = m_rootThread.m_WbemServices.m_hr;
			}

			// find security...
			CWbemClassObject sysSec = m_rootThread.m_WbemServices.GetObject("__SystemSecurity=@");
			if((bool)sysSec)
			{
				// its the new SD security
				m_NSSecurity = true;
			}
			else
			{
				// its old fashioned namespace security.
				m_rootSecNS = m_rootThread.m_WbemServices.OpenNamespace("security");
				m_NSSecurity = false;
			}
			m_securityHr = m_rootThread.m_WbemServices.m_hr;

		}
	}
	catch ( ... )
	{
		retval = WBEM_E_INITIALIZATION_FAILURE;
	}
	return retval;
}

//----------------------------------------------------------
#include "mofstr.inc"
#include "mofsec.inc"

HRESULT DataSource::UpdateOldBuild(void)
{
	HRESULT hr = S_OK;
	UINT mofSize = strlen(CLASSMOF);
	mofSize += strlen(INSTMOF);

	char *mofStr = new char[mofSize + 2];
	memset(mofStr, 0, mofSize + 2);
	strcpy(mofStr, CLASSMOF);
	strcat(mofStr, INSTMOF);

	wchar_t svrNS[100] = {0};

	wcscpy(svrNS,(LPCWSTR)m_rootThread.m_nameSpace);  // this will point to \root.
	wcscat(svrNS, L"\\cimv2");

    IMofCompiler *pCompiler = NULL;
	hr = CoCreateInstance(CLSID_MofCompiler, 0, CLSCTX_INPROC_SERVER,
							IID_IMofCompiler, (LPVOID *) &pCompiler);

	hr = pCompiler->CompileBuffer(strlen(mofStr), (LPBYTE)mofStr,
									svrNS,			//ServerAndNamespace,
									NULL,			//User,
									NULL,			//Authority,
									NULL,			//Password,
									0, 0, 0, NULL);	//lOptionFlags,lClassFlags, lInstanceFlags

	delete[] mofStr;

	// now for the security trick.
	mofSize = strlen(SECMOF);
	mofStr = new char[mofSize + 2];
	strcpy(mofStr, SECMOF);
	wcscpy(svrNS,(LPCWSTR)m_rootThread.m_nameSpace);  // this will point to \root.
	wcscat(svrNS, L"\\security");

	hr = pCompiler->CompileBuffer(strlen(mofStr), (LPBYTE)mofStr,
									svrNS,			//ServerAndNamespace,
									NULL,			//User,
									NULL,			//Authority,
									NULL,			//Password,
									0, 0, 0, NULL);	//lOptionFlags,lClassFlags, lInstanceFlags

	delete[] mofStr;

	pCompiler->Release();
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::Disconnect(bool clearCredentials)
{
	if(m_user.authIdent && clearCredentials)
	{
		m_rootThread.m_WbemServices.m_authIdent = 0;
		m_cimv2NS.m_authIdent = 0;
		m_rootSecNS.m_authIdent = 0;

		WbemFreeAuthIdentity(m_user.authIdent);
		m_user.authIdent = 0;
		m_user.currUser = true;
		memset(m_user.fullAcct, 0, FULLACCTSIZE * sizeof(TCHAR));

	}

	if(IsConnected())
	{
		m_rootSecNS.DisconnectServer();
		m_cimv2NS.DisconnectServer();

		// this is the root NS.
		m_rootThread.DisconnectServer();
		m_sessionID++;
	}

	if ((bool)m_winMgmt)
		m_winMgmt = (IWbemClassObject *)NULL;
	if ((bool)m_OS)
		m_OS = (IWbemClassObject *)NULL;
	if ((bool)m_cpu)
		m_cpu = (IWbemClassObject *)NULL;

	m_securityHr = E_FAIL;
	m_osHr = E_FAIL;
	m_cpuHr = E_FAIL;
	m_settingHr = E_FAIL;

	return ERROR_SUCCESS;
}

//----------------------------------------------------------
bool DataSource::IsConnected(void) const
{
	return (m_rootThread.m_status == WbemServiceThread::ready);
}

//----------------------------------------------------------
bool DataSource::IsLocal(void) const
{
	return (m_whackedMachineName.GetLength() == 0);
}

//----------------------------------------------------------
bool DataSource::IsAncient(void) const
{
	return (!m_NSSecurity);
}

//----------------------------------------------------------
LOGIN_CREDENTIALS *DataSource::GetCredentials(void)
{
	return &m_user;
}

//----------------------------------------------------------
bstr_t DataSource::GetRootNS(void)
{
	return m_rootSecNS.m_path;
}

//----------------------------------------------------------
ISecurityInformation *DataSource::GetSI(struct NSNODE *nsNode)
{
	ISecurityInformation *si = NULL;
	
    // hacky fix for when we have a broken WMI for some reason.
    // we can edit locally if we're on NT.
    if(m_NSSecurity && 
        ((m_OSType == OSTYPE_WINNT) || (IsNT() && IsLocal())))
	{
		// access the acl methods.
		//Check whether the namespace is already opened
		if(nsNode->nsLoaded == false)
		{
			if(nsNode->sType == TYPE_SCOPE_INSTANCE)
			{
			}
			else
			{
				//Connect to the namespace now...
				*(nsNode->ns) = nsNode->ns->OpenNamespace(nsNode->display);
				if(nsNode->sType == TYPE_STATIC_INSTANCE)
				{
					//Now open the WbemClassObject with flags to read the __SD
					if(nsNode->pclsObj != NULL)
					{
						delete nsNode->pclsObj;
					}
					nsNode->pclsObj = new CWbemClassObject();
					*(nsNode->pclsObj) = nsNode->ns->GetObject(nsNode->relPath/*,Flag*/);
				}
			}
			nsNode->nsLoaded = true;
		}

		bstr_t server = m_cpu.GetString("__SERVER");
		si = new CSDSecurity(nsNode,server,IsLocal());
/*								ns, m_user.authIdent,
								path, display, 
								server, IsLocal());
*/
	}
	return si;
}

//----------------------------------------------------------
// general tab.
HRESULT DataSource::GetCPU(CHString1 &cpu)
{
	HRESULT hr = m_cpuHr;

	if((bool)m_cpu)
	{
		cpu = (LPCTSTR)m_cpu.GetString("Name");
		if(cpu.GetLength() != 0)
		{
			hr = S_OK;
		}
	}

	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetOS(CHString1 &os)
{
	HRESULT hr = m_osHr;

	if((bool)m_OS)
	{
		os = (LPCTSTR)m_OS.GetString("Caption");
		if(os.GetLength() != 0)
		{
			hr = S_OK;
		}
	}

	return hr;
}

//----------------------------------------------------
HRESULT DataSource::GetOSVersion(CHString1 &ver)
{
	HRESULT hr = m_osHr;

	if((bool)m_OS)
	{
		TCHAR _scr1[100] = {0};
		TCHAR _scr2[100] = {0};

		// Build and set the serial number string
		if (m_OS.GetBool("Debug")) 
		{
			_scr1[0] = TEXT(' ');
			LoadString(HINST_THISDLL, IDS_DEBUG, &(_scr1[1]), ARRAYSIZE(_scr1)-1);
		} 
		else 
		{
			_scr1[0] = TEXT('\0');
		}

		// Version.buildNumber (DEBUG).
		_tcscpy(_scr2, (LPCTSTR)m_OS.GetString("Version"));
		_sntprintf(_scr2, ARRAYSIZE(_scr2)-1, TEXT("%s%s"), _scr2, _scr1);
		_scr2[ARRAYSIZE(_scr2)-1] = 0;

		ver = (LPCTSTR)_scr2;
		hr = S_OK;
	}

	return hr;
}

//----------------------------------------------------
HRESULT DataSource::GetServicePackNumber(CHString1 &ServPack)
{
	HRESULT hr = m_osHr;

	if((bool)m_OS)
	{
		TCHAR _scr1[100] = {0};
		_sntprintf(_scr1, ARRAYSIZE(_scr1)-1, TEXT("%ld.%ld"), m_OS.GetLong("ServicePackMajorVersion"), m_OS.GetLong("ServicePackMinorVersion"));

		_scr1[ARRAYSIZE(_scr1)-1] = 0;

		ServPack = (LPCTSTR)_scr1;
		hr = S_OK;
	}

	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetBldNbr(CHString1 &bldNbr)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		bldNbr = (LPCTSTR)m_winMgmt.GetString("BuildVersion");
		if(bldNbr.GetLength() != 0)
		{
			hr = S_OK;
		}
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetInstallDir(CHString1 &dir)
{
	bstr_t value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		dir = (LPCTSTR)m_winMgmt.GetString("InstallationDirectory");
		if(dir.GetLength() != 0)
		{
			hr = S_OK;
		}
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetDBDir(CHString1 &dir)
{
	bstr_t value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		dir = (LPCTSTR)m_winMgmt.GetString("DatabaseDirectory");
		if(dir.GetLength() != 0)
		{
			hr = S_OK;
		}
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetBackupInterval(UINT &interval)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		interval = m_winMgmt.GetLongEx("BackupInterval");
		hr = S_OK;
	}

	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetBackupInterval(UINT interval)
{
	CHString1 value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		hr = m_winMgmt.PutEx("BackupInterval", (long)interval);
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetLastBackup(CHString1 &time)
{
	HRESULT hr = m_settingHr;
	bstr_t dmtf;
	if((bool)m_winMgmt)
	{
		hr = m_winMgmt.GetDateTimeFormat("BackupLastTime", dmtf);
		if(SUCCEEDED(hr))
			time = (LPCTSTR)dmtf;
	}
	return hr;
}

//----------------------------------------------------------
// logging tab.
HRESULT DataSource::GetLoggingStatus(LOGSTATUS &status)
{
	bstr_t temp;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		status = (LOGSTATUS)m_winMgmt.GetLongEx("LoggingLevel");
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetLoggingStatus(LOGSTATUS status)
{
	CHString1 value;
	bstr_t temp;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		hr = m_winMgmt.PutEx("LoggingLevel", (long)status);
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetLoggingSize(ULONG &size)
{
	bstr_t value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		size = m_winMgmt.GetLongEx("MaxLogFileSize");
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetLoggingSize(const ULONG size)
{
	CHString1 value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		hr = m_winMgmt.PutEx("MaxLogFileSize", (long)size);
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetDBLocation(CHString1 &dir)
{
	bstr_t value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		dir = (LPCTSTR)m_winMgmt.GetString("DatabaseDirectory");
		if(dir.GetLength() != 0)
		{
			hr = S_OK;
		}
	}
	return hr;
}


//----------------------------------------------------------
HRESULT DataSource::GetLoggingLocation(CHString1 &dir)
{
	bstr_t value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		CHString1 dir2;
		dir2 = (LPCTSTR)m_winMgmt.GetString("LoggingDirectory");
		TCHAR temp[_MAX_PATH] = {0};
		_tcscpy(temp, (LPCTSTR)dir2);
		PathAddBackslash(temp);
		dir = temp;
		hr  = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetLoggingLocation(CHString1 dir)
{
	HRESULT hr = m_settingHr;
	bstr_t value = dir;

	if((bool)m_winMgmt && dir.GetLength() != 0)
	{
		hr = m_winMgmt.Put("LoggingDirectory", (bstr_t)(LPCTSTR)dir);
	}
	return hr;
}

#define WIN32_DIRECTORY _T("Win32_directory=\"")
//----------------------------------------------------------
bool DataSource::IsValidDir(CHString1 &dir)
{
	bool retval = true;

	if((bool)m_cimv2NS)
	{
		// double the whacks because wmi has bad syntax.
		TCHAR cooked[_MAX_PATH * 2] = {0};
		TCHAR input[_MAX_PATH] = {0};
		TCHAR path[_MAX_PATH * 2 + ARRAYSIZE(WIN32_DIRECTORY) + 1] = {0};

		int len = dir.GetLength();

		_tcscpy(input, (LPCTSTR)dir);
		_tcscpy(path, WIN32_DIRECTORY);

		for(int x = 0; x < len; x++)
		{
			_tcsncat(cooked, &input[x], 1);

			// if its a whack...
			if(input[x] == _T('\\'))
			{
				// have another pleeb.
				_tcscat(cooked, _T("\\"));			
			}
		} //endfor

		_tcscat(path, cooked);
		path[_tcslen(path) - 2] = 0;
		_tcscat(path, _T("\""));

		CWbemClassObject inst = m_cimv2NS.GetObject(path);
		retval = (bool)inst;
	}
	else //can't check, assume it's valid and let it through
	{
//		//warn & maybe.
//		retval = false;
	}
	return retval;
}

#define CIM_LOGICALFILE _T("CIM_LogicalFile=\"")
//----------------------------------------------------------
bool DataSource::IsValidFile(LPCTSTR szDir)
{
    TCHAR szBuffer[MAX_PATH * 2 + ARRAYSIZE(CIM_LOGICALFILE) + 1]; //size should accommodate additional escapes

	bool retval = true;
	if((bool)m_cimv2NS)
	{
        _tcscpy(szBuffer, CIM_LOGICALFILE);
        TCHAR * psz = szBuffer + ARRAYSIZE(CIM_LOGICALFILE) - 1;

        while (*psz = *szDir)
        {
            if (*szDir == _T('\\'))
            {
                *psz++ = _T('\\');
                *psz   = _T('\\');
            }
            psz++;
            szDir++;
        }
        *psz++ = _T('\"');
        *psz   = _T('\0');

		CWbemClassObject inst = m_cimv2NS.GetObject(szBuffer);
		retval = (bool)inst;
	}
	else //can't check, assume it's valid and let it through
	{
//		//warn & maybe.
//		retval = false;
	}
	return retval;
}

//----------------------------------------------------------
bool DataSource::CanBrowseFS(void) const
{
	return IsLocal();
}

//----------------------------------------------------------
// advanced tab.
HRESULT DataSource::GetScriptASPEnabled(bool &enabled)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		enabled = m_winMgmt.GetBoolEx("ASPScriptEnabled");
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetScriptASPEnabled(bool &enabled)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		m_winMgmt.PutEx("ASPScriptEnabled", enabled);
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetAnonConnections(bool &enabled)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		enabled = m_winMgmt.GetBoolEx("EnableAnonWin9xConnections");
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetAnonConnections(bool &enabled)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		m_winMgmt.PutEx("EnableAnonWin9xConnections", enabled);
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------

HRESULT DataSource::GetScriptDefNS(CHString1 &ns)
{
	HRESULT hr = m_settingHr;
	bstr_t value;

	if((bool)m_winMgmt)
	{
		ns = (LPCTSTR)m_winMgmt.GetString("ASPScriptDefaultNamespace");
		if(ns.GetLength() != 0)
		{
			hr = S_OK;
		}
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetScriptDefNS(LPCTSTR ns)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		hr = m_winMgmt.Put("ASPScriptDefaultNamespace", (bstr_t)(LPCTSTR)ns);
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetRestart(RESTART &restart)
{
	bstr_t value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		restart = (RESTART)m_winMgmt.GetLongEx("AutoStartWin9X");
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetRestart(RESTART restart)
{
	CHString1 value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		hr = m_winMgmt.PutEx("AutoStartWin9X", (long)restart);
	}

	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::PutWMISetting(BOOL refresh)
{
	HRESULT hr = m_cimv2NS.PutInstance(m_winMgmt);
	
	if(refresh)
		m_winMgmt = m_cimv2NS.GetObject("Win32_WMISetting=@");

	return hr;
}

//----------------------------------------------------------
//----------------------------------------------------------
// NAMESPACE CACHE -----------------------------------------
LPTSTR DataSource::CopyString( LPTSTR pszSrc ) 
{
    LPTSTR pszDst = NULL;

    if (pszSrc != NULL) 
	{
        pszDst = new TCHAR[(lstrlen(pszSrc) + 1)];
        if (pszDst) 
		{
            lstrcpy( pszDst, pszSrc );
        }
    }

    return pszDst;
}

//---------------------------------------------------------------------------
void DataSource::DeleteAllNodes(void)
{
	DeleteNode(&m_NSCache);
}

//---------------------------------------------------------------------------
void DataSource::DeleteNode(NSNODE *node)
{
	if(node)
	{
		delete[] node->display;
		delete[] node->fullPath;
		node->ns = 0;

		int size = node->children.GetSize();
		// walk the children.
		for(int x = 0; x < size; x++)
		{
			struct NSNODE *child = node->children[x];
			DeleteNode(child);
		}

		if(node != &m_NSCache)
		{
			delete node;
		}
		else
		{
			m_NSCache.children.RemoveAll();
		}
	}
}

//---------------------------------------------------------------------------
void DataSource::LoadImageList(HWND hTree)
{

	if(m_hImageList == 0)
	{
		// create an empty imagelist.
		m_hImageList = ImageList_Create(16, 16, ILC_COLOR8|ILC_MASK, 3, 0);

		// add an icon
		m_folderIcon = ImageList_AddIcon(m_hImageList, 
									   LoadIcon(_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDI_CLSD_FOLDER)));

		m_earthIcon = ImageList_AddIcon(m_hImageList, 
									   LoadIcon(_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDI_EARTH)));
		m_classIcon = ImageList_AddIcon(m_hImageList, 
									   LoadIcon(_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDI_CLSD_CLASS)));
		m_instanceIcon = ImageList_AddIcon(m_hImageList, 
									   LoadIcon(_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDI_CLSD_INSTANCE)));
		m_scopeInstanceIcon = ImageList_AddIcon(m_hImageList, 
									   LoadIcon(_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDI_CLSD_SCOPEINSTANCE)));
		m_scopeClassIcon = ImageList_AddIcon(m_hImageList, 
									   LoadIcon(_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDI_CLSD_SCOPECLASS)));
	}

	// sent it to the tree.
	TreeView_SetImageList(hTree, m_hImageList, TVSIL_NORMAL);
}

//---------------------------------------------------------------------------
HRESULT DataSource::LoadNode(HWND hTree, HTREEITEM hItem /* = TVI_ROOT */,
							 int flags)
{
	HRESULT hr = E_FAIL;

	// loading the root?
	if(hItem == TVI_ROOT)
	{
		// initialize the node.
		m_NSCache.display = CopyString(_T("Root"));
		m_NSCache.fullPath = CopyString(_T("Root"));
		m_NSCache.ns = &m_rootThread.m_WbemServices;
		m_NSCache.hideMe = false;
		m_NSCache.sType = TYPE_NAMESPACE;

		ITEMEXTRA *extra = new ITEMEXTRA;
		if(extra == NULL)
			return E_FAIL;
		extra->nsNode = &m_NSCache;
		extra->loaded = false;

		// initialize the invariant parts.
		TVINSERTSTRUCT tvInsert;
		tvInsert.hParent = TVI_ROOT;
		tvInsert.hInsertAfter = TVI_SORT;
		tvInsert.item.mask =  TVIF_TEXT | TVIF_CHILDREN |TVIF_PARAM|TVIF_IMAGE|TVIF_SELECTEDIMAGE;
		tvInsert.item.hItem = 0;
		tvInsert.item.state = 0;
		tvInsert.item.iImage = FolderIcon();
		tvInsert.item.iSelectedImage = FolderIcon();
		tvInsert.item.stateMask = 0;
		tvInsert.item.cChildren = (flags == ROOT_ONLY? 0: 1);
		tvInsert.item.pszText = CopyString(m_NSCache.display);
		
		if (!tvInsert.item.pszText)
		    {
		    delete extra;
 		    return E_FAIL;
		    }

		tvInsert.item.cchTextMax = _tcslen(tvInsert.item.pszText); 
		tvInsert.item.lParam = (LPARAM)extra;

		HTREEITEM hItem2;
		hItem2 = TreeView_InsertItem(hTree, &tvInsert);
		hr = (hItem != 0 ? S_OK : E_FAIL);
	}
	else if(flags != ROOT_ONLY)  // expanding an existing node.
	{
		TV_ITEM item;
		struct NSNODE *node = NULL;
		// find the cached node.
		item.mask = TVIF_PARAM | TVIF_CHILDREN;
		item.hItem = hItem;
		BOOL x = TreeView_GetItem(hTree, &item);

		ITEMEXTRA *extra = (ITEMEXTRA *)item.lParam;
		node = extra->nsNode;

		// are the kids in the cache??
/*		int size = node->children.GetSize();
		ATLTRACE(_T("NODE STATE: %d, %d\n"), size, extra->loaded);
		if((size == 0) &&
			(extra->loaded == false))
*/
		if(extra->loaded == false)
		{
			//Now delete all the children in the cache as they might be due to a previously cancelled enumeration
			node->children.RemoveAll();
			// nope!!! Enum that 'node' to the cache.
//			ShowControls(true);
			hr = PopulateCacheNode(hTree,hItem,extra);
			// NOTE: empties will be WBEM_E_NOT_FOUND here.
		}

/*		// got kids now?
		size = node->children.GetSize();
		if(size == 0)
		{
			// get rid of the plus sign.
			item.mask = TVIF_CHILDREN;
			item.cChildren = 0; 
			TreeView_SetItem(hTree, &item);
		}
		else if(extra->loaded == false)  // && size != 0
		{
			// load the tree now.
			hr = PopulateTreeNode(hTree, hItem, node, flags);
			extra->loaded = true;
		}
*/
	}

	return hr;
}

//---------------------------------------------------------------------------
bool DataSource::MFLNamepace(LPTSTR name)
{
	bool t1 = (_tcslen(name) == 6);					// just the right length...
	bool t2 = (_tcsnicmp(name, _T("MS_"), 3) == 0);		// starts right...
	int scan = _tcsspn(&name[3], _T("0123456789"));
	bool t3 = (scan == 3);

	return t1 && t2 && t3;
}

//---------------------------------------------------------------------------
HRESULT DataSource::PopulateCacheNode(HWND hTreeWnd,HTREEITEM hItem,struct ITEMEXTRA *extra)
{
	// load up the principals.
	IWbemClassObject *inst = NULL;
	IEnumWbemClassObject *nsEnum = NULL;

	ULONG uReturned = 0;
	HRESULT hr = E_FAIL;
	HRESULT hr1 = E_FAIL;

	struct NSNODE *parent= extra->nsNode;

	CWbemServices *ns = NULL;
	extra->loaded = true;						

	switch(parent->sType)
	{
		case TYPE_NAMESPACE:
		{
			//Check whether the namespace is already opened
			if(parent->nsLoaded == false)
			{
				//Connect to the namespace now...
				*(parent->ns) = parent->ns->OpenNamespace(parent->display);
				parent->nsLoaded = true;
			}
			ns = parent->ns;

			//Create the Namespace Enum
			CAsyncObjectSink *objSinkNS;
			objSinkNS = new CAsyncObjectSink(hTreeWnd,hItem,parent,this,ENUM_NAMESPACE);
            if (objSinkNS != NULL)
            {
			    IWbemObjectSink *pSyncStubNS = NULL;
			    hr = GetAsyncSinkStub(objSinkNS,&pSyncStubNS);

                if (SUCCEEDED(hr))
                {
			        objSinkNS->SetSinkStub(pSyncStubNS);
			        hr = ns->CreateInstanceEnumAsync(L"__namespace",pSyncStubNS);
			        pSyncStubNS->Release();

                    if (parent->objSink != NULL)
                    {
			            ((CAsyncObjectSink *)parent->objSink)->SetSinkStub(NULL);
			            parent->objSink->Release();
                    }

			        parent->objSink = NULL;

                    if (parent->objSinkNS != NULL)
                    {
			            ((CAsyncObjectSink *)parent->objSinkNS)->SetSinkStub(NULL);
                        parent->objSinkNS->Release();
                    }
                    parent->objSinkNS = objSinkNS;
                    parent->objSinkNS->AddRef();
                }
                else
                    delete objSinkNS;
            }
            else
                hr = E_OUTOFMEMORY;

			if(SUCCEEDED(hr))
			{
				asyncList.push_back(extra);
			}
			else
			{
				//Some problem with the enumerations. So remove the Plus sign as no nodes will be populated
				RemovePlus(hTreeWnd,hItem);
			}
			break;
		}
		case TYPE_SCOPE_CLASS:
		case TYPE_STATIC_CLASS:
		{
			//Check whether the namespace is already opened
			if(parent->nsLoaded == false)
			{
				//Connect to the namespace now...
				*(parent->ns) = parent->ns->OpenNamespace(parent->display);
				parent->nsLoaded = true;
			}
			ns = parent->ns;
			//Since we can set the secutiry for the static Instances Enumerate the Instances of this static class now
			CAsyncObjectSink *objSink;
			objSink = new CAsyncObjectSink(hTreeWnd,hItem,parent,this,ENUM_INSTANCE);
            if (objSink != NULL)
            {
			    IWbemObjectSink *pSyncStub = NULL;
			    hr = GetAsyncSinkStub(objSink,&pSyncStub);

                if (SUCCEEDED(hr))
                {
			        objSink->SetSinkStub(pSyncStub);
			        hr = ns->CreateInstanceEnumAsync(parent->display,pSyncStub);
			        pSyncStub->Release();

                    if (parent->objSink != NULL)
                    {
                        ((CAsyncObjectSink *)parent->objSink)->SetSinkStub(NULL);
                        parent->objSink->Release();
                    }

                    parent->objSink = objSink;
                    parent->objSink->AddRef();
                }
                else
                    delete objSink;
            }
            else
                hr = E_OUTOFMEMORY;

			if(FAILED(hr))
			{
				//Some problem with the enumeration. So remove the Plus sign as no nodes will be populated
				RemovePlus(hTreeWnd,hItem);
			}
			else
			{
				asyncList.push_back(extra);
			}
			break;
		}
		case TYPE_SCOPE_INSTANCE:
		{
			//Check whether the namespace is already opened
/*			if(parent->nsLoaded == false)
			{
				IWbemServices *pServ = NULL;
//				IWbemServicesEx *pServEx = NULL,*pServEx1 = NULL;
				//Connect to the scope now.
				pServ = m_rootThread.m_WbemServices.m_pService;
//				hr = pServ->QueryInterface(IID_IWbemServicesEx,(void **)&pServEx);
//				if(SUCCEEDED(hr))
				{
//					parent->pServicesEx = NULL;
					TCHAR strTemp[1024];
					_tcscpy(strTemp,_T("ScopeClass.Name=\"ScopeInst1\""));
					//Now open the scope
					hr = pServEx->Open(strTemp,0,0,NULL,&pServEx1,NULL);
//					hr = pServEx->Open(parent->fullPath,NULL,0,NULL,&pServEx1,NULL);
					if(SUCCEEDED(hr))
					{
						//Now we have opened the scope
						parent->nsLoaded = true;

						//Enumerate the Instances in the scope now
						CAsyncObjectSink *objSink;
						parent->objSink = new CAsyncObjectSink(hTreeWnd,hItem,parent,this,ENUM_SCOPE_INSTANCE);
						IWbemObjectSink *pSyncStub = NULL;
						GetAsyncSinkStub(parent->objSink,&pSyncStub);
						objSink = (CAsyncObjectSink *)parent->objSink;
						objSink->SetSinkStub(pSyncStub);
						hr = parent->pServicesEx->CreateInstanceEnumAsync(L"",0,NULL,pSyncStub);
						pSyncStub->Release();
						if(FAILED(hr))
						{
							//Some problem with the enumeration. So remove the Plus sign as no nodes will be populated
							RemovePlus(hTreeWnd,hItem);
						}
						else
						{
							asyncList.push_back(extra);
						}
					}
				}

			}

			if(parent->nsLoaded == false)
			{
				//Do we have to display an error message here???
				MessageBox(NULL,_T("Unable to open scope"),_T("NULL"),MB_OK);
			}
*/
			break;
		}
		case TYPE_DYNAMIC_CLASS:
		{
			//The control should not come here. Even if it comes we won't do anything
			break;
		}
		case TYPE_STATIC_INSTANCE:
		{
			break;
		}

	}

	return hr;
}

//---------------------------------------------------------------------------
HRESULT DataSource::PopulateTreeNode(HWND hTree, HTREEITEM hParentItem, 
										struct NSNODE *parent,
										int flags)
{
	HRESULT hr = E_FAIL;

	if(parent)
	{
		// initialize the invariant parts.
		TVINSERTSTRUCT tvInsert;
		tvInsert.hParent = hParentItem;
		tvInsert.hInsertAfter = TVI_SORT;
		tvInsert.item.hItem = 0;
		tvInsert.item.state = 0;
		tvInsert.item.iImage = 1;
		tvInsert.item.stateMask = 0;

		int size = parent->children.GetSize();
		
		if(size == 0) 
			return WBEM_E_NOT_FOUND;

		hr = E_FAIL; // in case we bounce right over the for(...).

		// walk the children.
		for(int x = 0; x < size; x++)
		{
			struct NSNODE *child = parent->children[x];

			if(!((flags == HIDE_SOME) && child->hideMe) )
			{

				ATLTRACE(_T("NStree: %s %s\n"), parent->display, child->display);

				tvInsert.item.mask =  TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM|TVIF_IMAGE|TVIF_SELECTEDIMAGE;
				tvInsert.item.pszText = CopyString(child->display);
				if (!tvInsert.item.pszText)
					return E_FAIL;

				tvInsert.item.cchTextMax = _tcslen(tvInsert.item.pszText);

				ITEMEXTRA *extra = new ITEMEXTRA;
				if(extra == NULL)
					return E_FAIL;
				extra->nsNode = child;
				extra->loaded = false;

				tvInsert.item.lParam = (LPARAM)extra;
				tvInsert.item.cChildren = 1;
				if(MFLNamepace(child->display))
				{
					tvInsert.item.iImage = EarthIcon();
					tvInsert.item.iSelectedImage = EarthIcon();
				}
				else
				{
					if((child->sType == TYPE_DYNAMIC_CLASS) || (child->sType == TYPE_STATIC_CLASS))
					{
						tvInsert.item.iImage = ClassIcon();
						tvInsert.item.iSelectedImage = ClassIcon();
					}
					else
					{ //Defaulted to Namespace
						tvInsert.item.iImage = FolderIcon();
						tvInsert.item.iSelectedImage = FolderIcon();
					}
				}

				// Insert principal into list.
				HTREEITEM hItem2;
				hItem2 = TreeView_InsertItem(hTree, &tvInsert);
			}

		} //endwhile

	hr = S_OK;
	} //endif (bool)ns

	return hr;
}

void DataSource::InsertNamespaceNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj)
{

    std::auto_ptr<NSNODE> AutoNode(new struct NSNODE);
    NSNODE *node = AutoNode.get();

    if (NULL == node ) return;

	CWbemClassObject easy(pclsObj);
	bstr_t name = easy.GetString("Name");
	bstr_t path = easy.GetString("__NAMESPACE");
	bstr_t full = path + _T("\\");
	full += name;
	bstr_t relPath = easy.GetString("__RELPATH");

	node->fullPath = CopyString(full);
	node->relPath = CopyString(relPath);
	node->display = CopyString(name);
	node->hideMe = false; //HideableNode(node->display);
	node->nsLoaded = false;
	node->sType = TYPE_NAMESPACE;
	parent->children.Add(node);
    AutoNode.release();
	node->ns = new CWbemServices(*(parent->ns));

	//Now add the node to the tree
	TVINSERTSTRUCT tvInsert;
	tvInsert.hParent = hItem;
	tvInsert.hInsertAfter = TVI_SORT;
	tvInsert.item.hItem = 0;
	tvInsert.item.state = 0;
	tvInsert.item.iImage = 1;
	tvInsert.item.stateMask = 0;

	ITEMEXTRA *extra = new ITEMEXTRA;
	if(extra == NULL)
		return;
	extra->nsNode = node;
	extra->loaded = false;

	tvInsert.item.mask =  TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM|TVIF_IMAGE|TVIF_SELECTEDIMAGE;
	tvInsert.item.pszText = CopyString(node->display);
	tvInsert.item.cchTextMax = _tcslen(tvInsert.item.pszText);
	tvInsert.item.lParam = (LPARAM)extra;
	tvInsert.item.cChildren = 1;
	if(MFLNamepace(node->display))
	{
		tvInsert.item.iImage = EarthIcon();
		tvInsert.item.iSelectedImage = EarthIcon();
	}
	else
	{
		tvInsert.item.iImage = FolderIcon();
		tvInsert.item.iSelectedImage = FolderIcon();
	}

	// Insert principal into list.
	HTREEITEM hItem2;
	hItem2 = TreeView_InsertItem(hTreeWnd, &tvInsert);
}

void DataSource::InsertClassNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj)
{
	IWbemQualifierSet *qSet;
	pclsObj->GetQualifierSet(&qSet);
	VARIANT vt;
	VariantInit(&vt);
	HRESULT hr = qSet->Get(L"Abstract",0,&vt,NULL);

	if(hr != WBEM_E_NOT_FOUND)
	{
		if(vt.boolVal == VARIANT_TRUE)
		{
			qSet->Release();
			return;
		}
	}

    std::auto_ptr<NSNODE> AutoNode(new struct NSNODE);

	NSNODE *node = AutoNode.get();

    if( NULL == node ) return;

	CWbemClassObject easy(pclsObj);
	bstr_t name = easy.GetString("__CLASS");
	bstr_t path = easy.GetString("__PATH");
	bstr_t relPath = easy.GetString("__RELPATH");

	node->fullPath = CopyString(path);
	node->relPath = CopyString(relPath);
	node->display = CopyString(name);
	node->hideMe = false;
	node->nsLoaded = true;

	VariantClear(&vt);
	hr = qSet->Get(L"Dynamic",0,&vt,NULL);
	if((hr != WBEM_E_NOT_FOUND) && (vt.boolVal == VARIANT_TRUE))
	{
		node->sType = TYPE_DYNAMIC_CLASS;
		node->ns = NULL;
	}
	else
	{
		//Now check whether it is a scope class
		hr = qSet->Get(L"Scope",0,&vt,NULL);
		if((hr != WBEM_E_NOT_FOUND) && (vt.boolVal == VARIANT_TRUE))
		{
			//This class is marked as scope. So all instances of this class can be scopes
			node->sType = TYPE_SCOPE_CLASS;
		}
		else
		{
			//It is a static class
			node->sType = TYPE_STATIC_CLASS;
		}
		node->ns = new CWbemServices(*(parent->ns));
		node->pclsObj = new CWbemClassObject(pclsObj);
	}

	parent->children.Add(node);
    AutoNode.release();

	//Now Add the node to the Tree
	TVINSERTSTRUCT tvInsert;
	tvInsert.hParent = hItem;
	tvInsert.hInsertAfter = TVI_SORT;
	tvInsert.item.hItem = 0;
	tvInsert.item.state = 0;
	tvInsert.item.iImage = 1;
	tvInsert.item.stateMask = 0;

	ITEMEXTRA *extra = new ITEMEXTRA;
	if(extra == NULL)
		return;
	extra->nsNode = node;
	extra->loaded = false;

	tvInsert.item.mask =  TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM|TVIF_IMAGE|TVIF_SELECTEDIMAGE;
	tvInsert.item.pszText = CopyString(node->display);
	tvInsert.item.cchTextMax = _tcslen(tvInsert.item.pszText);
	tvInsert.item.lParam = (LPARAM)extra;
	if(node->sType == TYPE_DYNAMIC_CLASS)
	{
		//Remove the plus sign for the Dynamic Classes
		tvInsert.item.cChildren = 0;
	}
	else
	{
		tvInsert.item.cChildren = 1;
	}

	if(node->sType == TYPE_SCOPE_CLASS)
	{
		tvInsert.item.iImage = ScopeClassIcon();
		tvInsert.item.iSelectedImage = ScopeClassIcon();
	}
	else
	{
		tvInsert.item.iImage = ClassIcon();
		tvInsert.item.iSelectedImage = ClassIcon();
	}
	
	// Insert principal into list.
	HTREEITEM hItem2;
	hItem2 = TreeView_InsertItem(hTreeWnd, &tvInsert);

}

void DataSource::InsertInstanceNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj)
{
	TCHAR strKey[10240];
	struct NSNODE *node = new struct NSNODE;

	CWbemClassObject easy(pclsObj);
	HRESULT hr = E_FAIL;
	_bstr_t strName;
	_variant_t vtValue;
	VARIANT Value;
	_tcscpy(strKey,_T(""));
	VariantInit(&Value);
	bool bfirstTime = true;
	//Now Enumerate the Keys and for a name like "key1,key2,key3,..."
	if(SUCCEEDED(hr = pclsObj->BeginEnumeration(WBEM_FLAG_KEYS_ONLY)))
	{
		while(pclsObj->Next(0,NULL,&Value,NULL,NULL) != WBEM_S_NO_MORE_DATA)
		{
			vtValue = Value;
			if(bfirstTime)
			{
				bfirstTime = false;
			}
			else
			{
				_tcscat(strKey,_T(","));
			}
			vtValue.ChangeType(VT_BSTR,NULL);
			_bstr_t temp = _bstr_t(vtValue); //for PREFIX
			if (!temp)
				return;
			_tcscat(strKey,temp);
			VariantClear(&Value);
		}
	}
	if(_tcscmp(strKey,_T("")) == 0)
	{
		//Some Problem or it is the instance of a singleton class
		_tcscpy(strKey,_T("@"));
	}

	bstr_t name = strKey;
	bstr_t path = easy.GetString("__PATH");
	bstr_t relPath = easy.GetString("__RELPATH");

	node->fullPath = CopyString(path);
	node->relPath = CopyString(relPath);
	node->display = CopyString(name);
	node->hideMe = false;
	node->nsLoaded = false;
	node->ns = new CWbemServices(*(parent->ns));
	if(parent->sType == TYPE_SCOPE_CLASS)
	{
		node->sType = TYPE_SCOPE_INSTANCE;
	}
	else
	{
		node->sType = TYPE_STATIC_INSTANCE;
	}
	node->pclsObj = new CWbemClassObject(pclsObj);

	parent->children.Add(node);

	TVITEM item;
	item.mask = TVIF_CHILDREN | TVIF_HANDLE;
	item.hItem = hItem;
	item.cChildren = 1;				
	TreeView_SetItem(hTreeWnd, &item);

	//Now Add the node to the Tree
	TVINSERTSTRUCT tvInsert;
	tvInsert.hParent = hItem;
	tvInsert.hInsertAfter = TVI_SORT;
	tvInsert.item.hItem = 0;
	tvInsert.item.state = 0;
	tvInsert.item.iImage = 1;
	tvInsert.item.stateMask = 0;

	ITEMEXTRA *extra = new ITEMEXTRA;
	if(extra == NULL)
		return;
	extra->nsNode = node;
	extra->loaded = false;

	tvInsert.item.mask =  TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM|TVIF_IMAGE|TVIF_SELECTEDIMAGE;
	tvInsert.item.pszText = CopyString(node->display);
	tvInsert.item.cchTextMax = _tcslen(tvInsert.item.pszText);
	tvInsert.item.lParam = (LPARAM)extra;
	if(node->sType == TYPE_SCOPE_INSTANCE)
	{
		tvInsert.item.iImage = ScopeInstanceIcon();
		tvInsert.item.iSelectedImage = ScopeInstanceIcon();
		tvInsert.item.cChildren = 1;
	}
	else
	{
		tvInsert.item.iImage = InstanceIcon();
		tvInsert.item.iSelectedImage = InstanceIcon();
		tvInsert.item.cChildren = 0;	//Since these are regular static instances, remove the plus sign
	}

	// Insert principal into list.
	HTREEITEM hItem2;
	hItem2 = TreeView_InsertItem(hTreeWnd, &tvInsert);
}

void DataSource::InsertScopeInstanceNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj)
{
}

void DataSource::RemovePlus(HWND hTreeWnd,HTREEITEM hItem)
{
	// get rid of the plus sign.
	TVITEM item;
	item.mask = TVIF_CHILDREN | TVIF_HANDLE;
	item.hItem = hItem;
	item.cChildren = 0; 
	TreeView_SetItem(hTreeWnd, &item);
}

void DataSource::CancelAllAsyncCalls()
{
	struct NSNODE *pNode;
	ASYNCLIST::iterator iter = asyncList.begin();
	TV_ITEM item;
	ITEMEXTRA *extra;
	CAsyncObjectSink *objSink;

	for(;iter != asyncList.end();iter++)
	{
		extra = *iter;
		pNode = extra->nsNode;

		if(pNode->objSinkNS != NULL)
		{
			objSink = (CAsyncObjectSink *)pNode->objSinkNS;

            if (objSink->GetSinkStub() != NULL)
            {
			    HRESULT hr = pNode->ns->CancelAsyncCall(objSink->GetSinkStub());

			    if((hr == WBEM_E_FAILED) || (hr == WBEM_E_INVALID_PARAMETER) || (hr == WBEM_E_OUT_OF_MEMORY) || (hr == WBEM_E_TRANSPORT_FAILURE))
			    {
				    hr = E_FAIL;
			    }
    			else
			    {
				    objSink->SetSinkStub(NULL);
				    extra->loaded = false;
			    }
            }
		}
		if(pNode->objSink != NULL)
		{
			objSink = (CAsyncObjectSink *)pNode->objSink;

            if (objSink->GetSinkStub() != NULL)
            {
			    HRESULT hr = pNode->ns->CancelAsyncCall(objSink->GetSinkStub());

			    if((hr == WBEM_E_FAILED) || (hr == WBEM_E_INVALID_PARAMETER) || (hr == WBEM_E_OUT_OF_MEMORY) || (hr == WBEM_E_TRANSPORT_FAILURE))
			    {
				    hr = E_FAIL;
			    }
			    else
			    {
				    objSink->SetSinkStub(NULL);
				    extra->loaded = false;
			    }
			}
		}
	}
	asyncList.clear();
}

void DataSource::ProcessEndEnumAsync(IWbemObjectSink *pSink)
{
	//First delete the node for this enum
//	OutputDebugString(_T("End Enum Received!!!\n"));

	struct ITEMEXTRA *extra;
	struct NSNODE *pNode;
	
	if(asyncList.empty() == true)
		return;

	ASYNCLIST::iterator iter = asyncList.begin();
	CAsyncObjectSink *objSink;

	for(;iter != asyncList.end();iter++)
	{
		extra = *iter;
		pNode = extra->nsNode;
		if(pNode->objSinkNS == pSink)
		{
			objSink = (CAsyncObjectSink *)pNode->objSinkNS;
			objSink->SetSinkStub(NULL);
			pNode->objSinkNS->Release();
			pNode->objSinkNS = NULL;
			break;
		}
		if(pNode->objSink == pSink)
		{
			objSink = (CAsyncObjectSink *)pNode->objSink;
			objSink->SetSinkStub(NULL);
			pNode->objSink->Release();
			pNode->objSink = NULL;
			break;
		}
	}

	if((pNode->objSinkNS == NULL) && (pNode->objSink == NULL))
	{
		asyncList.remove(*iter);
		extra->loaded = true;
	}

	if(asyncList.empty())
	{
		//Now Hide the Windows
//		ShowControls(false);
	}
}

void DataSource::SetControlHandles(HWND hwndStatic, HWND hwndButton)
{
	m_hWndStatic = hwndStatic;
	m_hWndButton = hwndButton;
}

void DataSource::ShowControls(bool bShow)
{
	if(bShow == true)
	{
		ShowWindow(m_hWndStatic,SW_SHOW);
		ShowWindow(m_hWndButton,SW_SHOW);
	}
	else
	{
		ShowWindow(m_hWndStatic,SW_HIDE);
		ShowWindow(m_hWndButton,SW_HIDE);
	}
}

HRESULT DataSource::GetAsyncSinkStub(IWbemObjectSink *pSink, IWbemObjectSink **pStubSink)
{
    HRESULT hr;
	IUnsecuredApartment* pUnsecApp = NULL;

    if (pSink != NULL)
    {
	    hr = CoCreateInstance(CLSID_UnsecuredApartment,
                              NULL,
                              CLSCTX_LOCAL_SERVER,
                              IID_IUnsecuredApartment, 
					          (void**)&pUnsecApp);

        if (SUCCEEDED(hr))
        {
	        IUnknown* pStubUnk = NULL;
	        hr = pUnsecApp->CreateObjectStub(pSink, &pStubUnk);

            if (SUCCEEDED(hr))
            {
	            *pStubSink = NULL;
	            hr = pStubUnk->QueryInterface(IID_IWbemObjectSink,
                                              (void **)pStubSink);
	            pStubUnk->Release();
            }

	        pUnsecApp->Release();
        }
    }
    else
        hr = E_UNEXPECTED;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\datasrc.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __DATASOURCE__
#define __DATASOURCE__

#include <CHString1.h>
#include "..\common\sshWbemHelpers.h"
#include "ServiceThread.h"
#include <aclui.h>
#include <list>

#define OSTYPE_WIN95 16
#define OSTYPE_WIN98 17
#define OSTYPE_WINNT 18

#define	ROOT_ONLY 0 
#define	HIDE_SOME 1
#define	SHOW_ALL 2

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

// this structure is saved.
enum NODE_TYPE
{
	TYPE_NAMESPACE,
	TYPE_STATIC_CLASS,
	TYPE_DYNAMIC_CLASS,
	TYPE_SCOPE_CLASS,
	TYPE_STATIC_INSTANCE,
	TYPE_SCOPE_INSTANCE,
};

//struct NSNODE;

struct NSNODE 
{
	NSNODE()
	{
		sType = TYPE_NAMESPACE;		//For backward Compatibility
		nsLoaded = false;
		pclsObj = NULL;
		objSinkNS = NULL;
		objSink = NULL;

        ns = NULL;
        display = NULL;
        fullPath = NULL;
        relPath = NULL;
	}

	LPTSTR display;			// single word
	LPTSTR fullPath;		// whole objpath
	LPTSTR relPath;
	CWbemServices *ns;
	CWbemClassObject *pclsObj;
//	IWbemServicesEx *pServicesEx;
	IWbemObjectSink *objSinkNS;
	IWbemObjectSink *objSink;
	bool hideMe;
	bool nsLoaded;
	NODE_TYPE sType;
	CSimpleArray<NSNODE *> children;
};

// for the namespace tree nodes.
typedef struct ITEMEXTRA
{
	struct NSNODE *nsNode;
	bool loaded;
} ITEMEXTRA;


// INTERFACE NOTES:
// WBEM_S_ACCESS_DENIED = no access to data.
// WBEM_S_FALSE = readonly access.
class DataSource
{
public:
	DataSource();
	virtual long AddRef(){ return InterlockedIncrement(&m_cRef); };
	virtual long Release()
	{
	    long lTemp = InterlockedDecrement(&m_cRef); 
    	if (0 == lTemp) delete this; 
    	return lTemp;
    }
private:	
	virtual ~DataSource();
    
    // property sheet - non-null while page is displayed.
    // set during property page initialization in General tab
    // cleared when ClosePropSheet is called.
    HWND m_hwndPropSheet;

public:	
	short m_OSType;

    // property sheet access
    void SetPropSheetHandle(HWND hPropSheet)
    {   m_hwndPropSheet = hPropSheet; }

    void ClosePropSheet();


	// connecting.
	// NOTE: WBEM_S_DIFFERENT means it changed 'machine'. Refresh your UI.
	void SetMachineName(CHString1 &machine);
	HRESULT Connect(LOGIN_CREDENTIALS *credentials, HWND notify = 0);
	HRESULT Initialize(IWbemServices *pServices);
	HRESULT Disconnect(bool clearCredentials = true);
	HRESULT Reconnect(void);
	bool IsNewConnection(long *sessionID);

	bool IsConnected(void) const;
	bool IsLocal(void) const;
	bool IsAncient(void) const;
	LOGIN_CREDENTIALS *GetCredentials(void);
	bstr_t GetRootNS(void);
	CWbemServices RootSecNS(void) const 
	{
		return m_rootSecNS;
	};

	ISecurityInformation *GetSI(struct NSNODE *nsNode);

	void LoadImageList(HWND hTree);

	// load a tree control from NSCache.
	HRESULT LoadNode(HWND hTree, HTREEITEM hItem = TVI_ROOT, 
						int flags = SHOW_ALL);
	void DeleteAllNodes(void);

	// general tab.
	HRESULT GetCPU(CHString1 &cpu);
	HRESULT GetOS(CHString1 &os);
	HRESULT GetOSVersion(CHString1 &ver);
	HRESULT GetServicePackNumber(CHString1 &ServPack);

	HRESULT GetBldNbr(CHString1 &bldNbr);
	HRESULT GetInstallDir(CHString1 &dir);
	HRESULT GetDBDir(CHString1 &dir);

	HRESULT GetBackupInterval(UINT &interval);
	HRESULT SetBackupInterval(UINT interval);
	
	HRESULT GetLastBackup(CHString1 &time);

	// logging tab.
	enum LOGSTATUS
	{
		Disabled = 0,
		ErrorsOnly,
		Verbose
	};
	HRESULT GetLoggingStatus(LOGSTATUS &status);
	HRESULT SetLoggingStatus(LOGSTATUS status);

	HRESULT GetLoggingSize(ULONG &size);
	HRESULT SetLoggingSize(ULONG size);

	HRESULT GetDBLocation(CHString1 &dir);

	HRESULT GetLoggingLocation(CHString1 &dir);
	HRESULT SetLoggingLocation(CHString1 dir);
	bool CanBrowseFS(void) const;

	// advanced tab.
	HRESULT GetScriptASPEnabled(bool &enabled);
	HRESULT SetScriptASPEnabled(bool &enabled);
	HRESULT GetAnonConnections(bool &enabled);
	HRESULT SetAnonConnections(bool &enabled);

	HRESULT GetScriptDefNS(CHString1 &ns);
	HRESULT SetScriptDefNS(LPCTSTR ns);

	enum RESTART
	{
		Dont = 0,
		AsNeededByESS,
		Always
	};
	HRESULT GetRestart(RESTART &restart);
	HRESULT SetRestart(RESTART restart);

	HRESULT PutWMISetting(BOOL refresh);
	bool IsValidDir(CHString1 &dir);
	bool IsValidFile(LPCTSTR szDir);
	
	WbemServiceThread m_rootThread;  // this will be \root.
	CHString1 m_whackedMachineName;
	CWbemServices m_rootSecNS, m_cimv2NS;
	HRESULT m_settingHr, m_securityHr, m_osHr, m_cpuHr;

	void InsertNamespaceNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj);
	void InsertClassNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj);
	void InsertInstanceNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj);
	void InsertScopeInstanceNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj);
	void RemovePlus(HWND hTreeWnd,HTREEITEM hItem);
	void CancelAllAsyncCalls();
	void ProcessEndEnumAsync(IWbemObjectSink *pSink);
	void SetControlHandles(HWND hwndStatic, HWND hwndButton);
	void ShowControls(bool bShow = true);
	
	
private:
	long m_sessionID;
	LOGIN_CREDENTIALS m_user;
	HWND m_hWndStatic;
	HWND m_hWndButton;

	typedef std::list<struct ITEMEXTRA*> ASYNCLIST;
	ASYNCLIST asyncList;
	IUnsecuredApartment* m_pUnsecApp;

	HRESULT UpdateOldBuild(void);

	bool m_NSSecurity;
	CWbemClassObject m_OS, m_cpu, m_winMgmt;
	struct NSNODE m_NSCache;
	
	HIMAGELIST m_hImageList;
	UINT m_folderIcon, m_earthIcon, m_classIcon, m_instanceIcon,m_scopeInstanceIcon,m_scopeClassIcon;

	UINT FolderIcon(void) const { return m_folderIcon;};
	UINT EarthIcon(void) const { return m_earthIcon;};
	UINT ClassIcon(void) const { return m_classIcon;};
	UINT InstanceIcon(void) const { return m_instanceIcon;};
	UINT ScopeInstanceIcon(void) const { return m_scopeInstanceIcon;};
	UINT ScopeClassIcon(void) const { return m_scopeClassIcon;};


	LPTSTR CopyString( LPTSTR pszSrc );
	bool MFLNamepace(LPTSTR name);


	// load the NSCache from WMI.
	HRESULT PopulateCacheNode(HWND hTreeWnd,HTREEITEM hItem,struct ITEMEXTRA *extra);

	HRESULT PopulateTreeNode(HWND hTree, HTREEITEM hParentItem, 
								struct NSNODE *parent,
								int flags);
	void DeleteNode(NSNODE *node);
	HRESULT GetAsyncSinkStub(IWbemObjectSink *pSink, IWbemObjectSink **pStubSink);

private:
    long m_cRef;

};


#endif __DATASOURCE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\logpage.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright (c) 1997-1999 Microsoft Corporation
/**********************************************************************/

#include "precomp.h"
#include "LogPage.h"
#include "CHString1.h"
#include "resource.h"
#include <shlobj.h>
#include "WMIHelp.h"
#include <errno.h>
#include "ShlWapi.h"

const static DWORD logPageHelpIDs[] = {  // Context Help IDs
	IDC_LOG_PARA,				-1,
	IDC_STATUS_FRAME,			-1,
	IDC_DISABLELOGGING,			IDH_WMI_CTRL_LOGGING_LOGGING_LEVEL,
	IDC_ERRORLOGGING,			IDH_WMI_CTRL_LOGGING_LOGGING_LEVEL,
	IDC_VERBOSELOGGING,			IDH_WMI_CTRL_LOGGING_LOGGING_LEVEL,
	IDC_MAXFILESIZE_LABEL,		IDH_WMI_CTRL_LOGGING_MAX_SIZE,
	IDC_MAXFILESIZE,			IDH_WMI_CTRL_LOGGING_MAX_SIZE,
	IDC_LOGGINGDIRECTORY_LABEL,	IDH_WMI_CTRL_LOGGING_LOCATION,
	IDC_LOGGINGDIRECTORY,		IDH_WMI_CTRL_LOGGING_LOCATION,
	IDC_BROWSE,					IDH_WMI_CTRL_LOGGING_BROWSE,
    0, 0
};

CLogPage::~CLogPage(void)
{
}

//-------------------------------------------------------------------------
void CLogPage::InitDlg(HWND hDlg)
{
	m_hDlg = hDlg;

	::SendMessage(GetDlgItem(hDlg, IDC_MAXFILESIZE),
					EM_LIMITTEXT, 10, 0);

	::SendMessage(GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY),
					EM_LIMITTEXT, _MAX_PATH, 0);
}

//---------------------------------------------------------------------------
void CLogPage::Refresh(HWND hDlg)
{
	if(m_DS && m_DS->IsNewConnection(&m_sessionID))
	{
		CHString1 temp;
		ULONG iTemp;
		CHString1 szNotRemoteable, szUnavailable;
		HRESULT hr = S_OK;
		BOOL enable = TRUE;

		szNotRemoteable.LoadString(IDS_NOT_REMOTEABLE);
		szUnavailable.LoadString(IDS_UNAVAILABLE);

		PageChanged(PB_LOGGING, false);

		// - - - - - - - - - - - - - -
		// logging status:
		UINT ID = IDC_DISABLELOGGING;

		hr = m_DS->GetLoggingStatus(m_oldStatus);
		if(SUCCEEDED(hr))
		{
			switch(m_oldStatus)
			{
			case DataSource::Disabled:   ID = IDC_DISABLELOGGING; break;
			case DataSource::ErrorsOnly: ID = IDC_ERRORLOGGING;   break;
			case DataSource::Verbose:	 ID = IDC_VERBOSELOGGING; break;
			}
			enable = TRUE;
			CheckRadioButton(hDlg, IDC_DISABLELOGGING, IDC_VERBOSELOGGING,
								ID);
		}
		else //failed
		{
			enable = FALSE;
		}

		::EnableWindow(GetDlgItem(hDlg, IDC_STATUS_FRAME), enable);
		::EnableWindow(GetDlgItem(hDlg, IDC_DISABLELOGGING), enable);
		::EnableWindow(GetDlgItem(hDlg, IDC_ERRORLOGGING), enable);
		::EnableWindow(GetDlgItem(hDlg, IDC_VERBOSELOGGING), enable);

		// - - - - - - - - - - - - - -
		// max file size:
		hr = m_DS->GetLoggingSize(iTemp);
		if(SUCCEEDED(hr))
		{
			enable = TRUE;
			temp.Format(_T("%u"), iTemp);
			SetWindowText(GetDlgItem(hDlg, IDC_MAXFILESIZE),
							temp);
		}
		else //failed
		{
			enable = FALSE;
			SetWindowText(GetDlgItem(hDlg, IDC_MAXFILESIZE),
							_T(""));
		}

		::EnableWindow(GetDlgItem(hDlg, IDC_MAXFILESIZE),
						enable);
		::EnableWindow(GetDlgItem(hDlg, IDC_MAXFILESIZE_LABEL),
						enable);

		// - - - - - - - - - - - - - -
		// Location:
		hr = m_DS->GetLoggingLocation(temp);
		if(SUCCEEDED(hr))
		{
			enable = TRUE;
			SetWindowText(GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY),
							temp);
		}
		else
		{
			enable = FALSE;
			SetWindowText(GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY),
							_T(""));
		}

		::EnableWindow(GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY),
						enable);
		// browse only works for local connections.
		::EnableWindow(GetDlgItem(hDlg, IDC_BROWSE),
						((BOOL)m_DS->IsLocal() && enable) );
	}
}

//------------------------------------------------------------------------
bool CLogPage::GoodPathSyntax(LPCTSTR path)
{
	bool retval = true;
	
	if(PathIsUNC(path))
	{
		TCHAR caption[50] = {0}, threat[256] = {0};
		::LoadString(_Module.GetResourceInstance(),
						IDS_SHORT_NAME, caption, ARRAYSIZE(caption));
		::LoadString(_Module.GetResourceInstance(),
						IDS_NO_UNC, threat, ARRAYSIZE(threat));

		MessageBox(m_hDlg, threat, caption, 
					MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);
		retval = false;
	}
	else
	{
		TCHAR pth[_MAX_PATH] = {0},
			file[_MAX_FNAME] = {0}, ext[_MAX_EXT] = {0};	
		TCHAR drive[_MAX_DRIVE] = {0};

		// rip it apart.
		_tsplitpath(path, drive, pth, file, ext);

		// missing a letter?
		if((!_istalpha(drive[0])) || 
		   (drive[1] != _T(':')))
		{
			TCHAR caption[50] = {0}, threat[100] = {0};
			::LoadString(_Module.GetResourceInstance(),
							IDS_SHORT_NAME, caption, ARRAYSIZE(caption));
			::LoadString(_Module.GetResourceInstance(),
							IDS_NO_DRIVE_LTR, threat, ARRAYSIZE(threat));

			MessageBox(m_hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
						MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

			retval = false;
		}
		// has a filename?
		else if((_tcslen(file) != 0) || (_tcslen(ext) != 0))
		{
			TCHAR caption[50] = {0}, threat[256] = {0};
			::LoadString(_Module.GetResourceInstance(),
							IDS_SHORT_NAME, caption, ARRAYSIZE(caption));
			::LoadString(_Module.GetResourceInstance(),
							IDS_DIRS_ONLY, threat, ARRAYSIZE(threat));

			MessageBox(m_hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
						MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

			retval = false;
		}

		// what kind of drive?
		CWbemClassObject inst;
		TCHAR drvRoot[40] = {0};
		_tcscpy(drvRoot, _T("Win32_LogicalDisk=\""));
		_tcsncat(drvRoot, path, 2);
		_tcscat(drvRoot, _T("\""));

		inst = m_DS->m_cimv2NS.GetObject(drvRoot);
		if(inst)
		{
			DWORD driveType = inst.GetLong(_T("DriveType"));
			if(driveType != 3)
			{
				// cant use removeables.
				TCHAR caption[50] = {0}, threat[100] = {0};
				::LoadString(_Module.GetResourceInstance(),
								IDS_SHORT_NAME, caption, ARRAYSIZE(caption));
				::LoadString(_Module.GetResourceInstance(),
								IDS_LOGS_WRONG_DRIVETYPE, threat, ARRAYSIZE(threat));

				MessageBox(m_hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
							MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

				retval = false;
			}
		}
		else
		{
		}
	}
	return retval;
}

//------------------------------------------------------------------------
BOOL CLogPage::OnValidate(HWND hDlg)
{
	BOOL keepFocus = FALSE;
	HWND hwnd = GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY);

	if(Edit_GetModify(hwnd))
	{
		TCHAR buf[_MAX_PATH] = {0};

		::GetWindowText(hwnd, buf, _MAX_PATH);
		if(_tcslen(buf) == 0)
		{
			CHString1 caption, threat;
			caption.LoadString(IDS_SHORT_NAME);
			threat.LoadString(IDS_DIR_EMPTY);

			MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
							MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

			CHString1 temp;
			HRESULT hr = m_DS->GetLoggingLocation(temp);
			if(SUCCEEDED(hr))
			{
				SetWindowText(GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY),
								temp);
			}
			// send him back to fix it.
			Edit_SetModify(hwnd, FALSE);

			::SetFocus(hwnd);
			keepFocus = TRUE;

		}
		else if(!GoodPathSyntax(buf))
		{
			::SetFocus(hwnd);
			keepFocus = TRUE;

		}
		else if(m_DS->IsValidDir(CHString1(buf)))
		{
			keepFocus = FALSE;
		}
		else 
		{
			CHString1 strLogDir;
			m_DS->GetLoggingLocation(strLogDir);

			if(CHString1(buf) != strLogDir)
			{
				// msg box here.
				CHString1 caption, threat;
				caption.LoadString(IDS_SHORT_NAME);
				threat.LoadString(IDS_DIR_DOESNT_EXIST);

				if(MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
								MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION) == IDYES)
				{
					// let it go through then.
					Edit_SetModify(hwnd, TRUE);
					keepFocus = FALSE;
				}
				else
				{
					// send him back to fix it.
					Edit_SetModify(hwnd, FALSE);

					::SetFocus(hwnd);
					keepFocus = TRUE;
				}
			}
			else
			{
				keepFocus = FALSE;
			}
		}
	}
	
	// check the logsize.
	hwnd = GetDlgItem(hDlg, IDC_MAXFILESIZE);

	if((keepFocus == FALSE) && Edit_GetModify(hwnd))
	{
		TCHAR buf[16] = {0};
		ULONG temp = 0;

		::GetWindowText(hwnd, buf, 16);
		errno = 0;
		temp = _tcstoul(buf, NULL, 10);

		if(errno == ERANGE)
		{
			TCHAR caption[50] = {0}, threat[256] = {0};
			::LoadString(_Module.GetResourceInstance(),
							IDS_SHORT_NAME, caption, ARRAYSIZE(caption));
			::LoadString(_Module.GetResourceInstance(),
							IDS_BAD_LOGSIZE, threat, ARRAYSIZE(threat));

			MessageBox(m_hDlg, threat, caption, 
						MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

			::SetFocus(hwnd);
			keepFocus = TRUE;
		}
	}
	return keepFocus;
}

//------------------------------------------------------------------------
void CLogPage::OnApply(HWND hDlg, bool bClose)
{
	DataSource::LOGSTATUS status = DataSource::Disabled;
	bool needToPut = false;

	if(IsDlgButtonChecked(hDlg, IDC_DISABLELOGGING) == BST_CHECKED)
		status = DataSource::Disabled;
	else if(IsDlgButtonChecked(hDlg, IDC_ERRORLOGGING) == BST_CHECKED)
		status = DataSource::ErrorsOnly;
	else if(IsDlgButtonChecked(hDlg, IDC_VERBOSELOGGING) == BST_CHECKED)
		status = DataSource::Verbose;

	if(m_oldStatus != status)
	{
		m_DS->SetLoggingStatus(status);
		m_oldStatus = status;
		needToPut = true;
	}

	HWND hwnd = GetDlgItem(hDlg, IDC_MAXFILESIZE);

	TCHAR buf[_MAX_PATH] = {0};
	ULONG temp = 0;

	if(Edit_GetModify(hwnd))
	{
		::GetWindowText(hwnd, buf, ARRAYSIZE(buf));
		temp = _tcstoul(buf, NULL, 10);
		if(SUCCEEDED(m_DS->SetLoggingSize(temp)))
		{
			needToPut = true;
		}
	}

	hwnd = GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY);
	if(Edit_GetModify(hwnd))
	{
		::GetWindowText(hwnd, buf, ARRAYSIZE(buf));
		if(SUCCEEDED(m_DS->SetLoggingLocation(buf)))
		{
			needToPut = true;
		}
	}

	if(needToPut)
	{
		NeedToPut(PB_LOGGING, !bClose);
		if(!bClose)
			Refresh(hDlg);
	}
}

//------------------------------------------------------------------------
BOOL CLogPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

    case WM_NOTIFY:
        {
            switch (((LPNMHDR)lParam)->code)
            {
			case PSN_SETACTIVE:
				Refresh(hDlg);
				break;

			case PSN_HELP:
				HTMLHelper(hDlg);
				break;

            case PSN_APPLY:
                OnApply(hDlg, (((LPPSHNOTIFY)lParam)->lParam == 1));
                break;

            case PSN_KILLACTIVE:
				{
					BOOL retval = OnValidate(hDlg);
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, retval);
					return retval;
				}
                break;
            }
        }
        break;

    case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_DISABLELOGGING:
		case IDC_ERRORLOGGING:
		case IDC_VERBOSELOGGING:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				PageChanged(PB_LOGGING, true);
				return TRUE;
			}
			break;
		
		case IDC_MAXFILESIZE:
			if(HIWORD(wParam) == EN_UPDATE)
			{
			    bool valid = true;
				HWND hwnd = GetDlgItem(hDlg, IDC_MAXFILESIZE);
				TCHAR buf[_MAX_PATH] = {0};

				::GetWindowText(hwnd, buf, _MAX_PATH);
				for(UINT x = 0; valid && x < _tcslen(buf); x++)
				{
					switch(buf[x])
					{
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						valid = true;
						break;

					default: 
						valid = false;
						break;
					} //endswitch
				} //endfor

                if(!valid) 
				{
					buf[_tcslen(buf) - 1] = _T('\0');
                    SetWindowText(hwnd, buf); 
                    SendMessage(hwnd, EM_SETSEL, 0, -1);
					MessageBeep(MB_ICONASTERISK);
                    
                } // endif

			}
			else if((HIWORD(wParam) == EN_CHANGE) && 
					 Edit_GetModify((HWND)lParam))
			{
				PageChanged(PB_LOGGING, true);
				return TRUE;
			}
			break;

		case IDC_LOGGINGDIRECTORY:
			if((HIWORD(wParam) == EN_CHANGE) && Edit_GetModify((HWND)lParam))
			{
				PageChanged(PB_LOGGING, true);
				return TRUE;
			}
			break;

		case IDC_BROWSE:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				LPMALLOC pMalloc;    /* Gets the Shell's default allocator */
				if(::SHGetMalloc(&pMalloc) == NOERROR)    
				{        
					BROWSEINFO bi;
					TCHAR pszBuffer[MAX_PATH] = {0};
					LPITEMIDLIST pidl;
					ITEMIDLIST *root;

					// Get the PIDL for the Programs folder. 
					if(SUCCEEDED(SHGetSpecialFolderLocation(hDlg, CSIDL_DRIVES, 
																&root))) 
					{ 
						bi.pidlRoot = root;
					} 
					else
					{					
						bi.pidlRoot = NULL;

					}
					// Get help on BROWSEINFO struct - it's got all the bit settings.
					TCHAR title[100] = {0};
					::LoadString(_Module.GetModuleInstance(), IDS_LOG_SELECT_FDR, 
									title, 100);
					bi.hwndOwner = hDlg;
					bi.pszDisplayName = pszBuffer;
					bi.lpszTitle = title;
					bi.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS;
					bi.lpfn = NULL;
					bi.lParam = 0;
					// This next call issues the dialog box.
					if((pidl = ::SHBrowseForFolder(&bi)) != NULL)
					{
						if(::SHGetPathFromIDList(pidl, pszBuffer))
						{ 
							// At this point pszBuffer contains the selected path */.
							HWND hwnd = GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY);
							PathAddBackslash(pszBuffer);
							SetWindowText(hwnd, pszBuffer);
							Edit_SetModify(hwnd, TRUE);
							PageChanged(PB_LOGGING, true);
						}
						// Free the PIDL allocated by SHBrowseForFolder.
						pMalloc->Free(pidl);
					}
					// Release the shell's allocator.
					pMalloc->Release();
				}
			}
			break;

		default: break;
		} //endswitch(LOWORD(wParam))
	
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)logPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)logPageHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\genpage.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright (c) 1997-1999 Microsoft Corporation
/**********************************************************************/

#include "precomp.h"
#include "GenPage.h"
#include "LogPage.h"
#include "AdvPage.h"
#include "resource.h"
#include "CHString1.h"
#include "DataSrc.h"
#include "wbemerror.h"
#include "WMIHelp.h"
#include <windowsx.h>
#include <util.h>

#ifdef SNAPIN
const static DWORD genPageHelpIDs[] = {  // Context Help IDs
	IDC_CHANGE,		IDH_WMI_CTRL_GENERAL_CHANGE_BUTTON,
	IDC_STATUS,		IDH_WMI_CTRL_GENERAL_DISPLAY_INFO,
	IDC_GEN_PARA,	-1,
    0, 0};
#else
const static DWORD genPageHelpIDs[] = {  // Context Help IDs
	IDC_COMP_LABEL,	IDH_WMI_EXE_GENERAL_CONNECTED_TO,
	IDC_MACHINE,	IDH_WMI_EXE_GENERAL_CONNECTED_TO,
	IDC_CHANGE,		IDH_WMI_EXE_GENERAL_CHANGE_BUTTON,
	IDC_STATUS,		IDH_WMI_CTRL_GENERAL_DISPLAY_INFO,
	IDC_GEN_PARA,	-1,
    0, 0};

#endif

//-------------------------------------------------------------------------
CGenPage::CGenPage(DataSource *ds, bool htmlSupport) :
				CUIHelpers(ds, &(ds->m_rootThread), htmlSupport)
{
	m_connected = false;
}

//-------------------------------------------------------------------------
CGenPage::~CGenPage(void)
{
}

//-------------------------------------------------------------------------
/*#undef Static_SetIcon
#define Static_SetIcon(hwndCtl, hIcon) ((HICON)(UINT)(DWORD)::SendMessage((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
*/

void CGenPage::StatusIcon(HWND hDlg, UINT icon)
{
	HICON hiconT, hIcon = LoadIcon(NULL, MAKEINTRESOURCE(icon));

	// set it into the picture control.
    if(hIcon)
    {
		hiconT = Static_SetIcon(GetDlgItem(hDlg, IDC_STATUSICON), hIcon);

		// destroy the old icon.
        if(hiconT)
        {
            DestroyIcon(hiconT);
        }
    }
}

//---------------------------------------------------------------------------
void CGenPage::InitDlg(HWND hDlg)
{
	CHString1 local, label;

//	SetCHString1ResourceHandle(_Module.GetModuleInstance());
	m_hDlg = hDlg;

#ifdef SNAPIN
	label.LoadString(IDS_GEN_PARA_SNAPIN);
	::SetWindowText(GetDlgItem(hDlg, IDC_GEN_PARA), label);
#else
	local.LoadString(IDS_LOCAL_CONN);
	::SetWindowText(GetDlgItem(hDlg, IDC_MACHINE), local);
#endif
    m_DS->SetPropSheetHandle(GetParent(hDlg));

	OnConnect(hDlg, m_DS->GetCredentials());
}

//---------------------------------------------------------------------------
void CGenPage::OnConnect(HWND hDlg,
						 LOGIN_CREDENTIALS *credentials)
{
	m_connected = false;

	CHString1 wait;
	wait.LoadString(IDS_WAIT);
	::SetDlgItemText(hDlg, IDC_STATUS, wait);

//#ifndef SNAPIN
//    EnablePrivilege(SE_BACKUP_NAME);
//    EnablePrivilege(SE_RESTORE_NAME);
//#endif

	HRESULT hr = m_DS->Connect(credentials, m_hDlg);

	if(SUCCEEDED(hr))
	{
		// goto the connecting icon.
		StatusIcon(hDlg, IDI_WAITING);

		{
 			TCHAR caption[100] ={0}, msg[256] = {0};

			::LoadString(_Module.GetModuleInstance(), IDS_SHORT_NAME,
							caption, 100);

			::LoadString(_Module.GetModuleInstance(), IDS_CONNECTING, 
							msg, 256);

			if(DisplayAVIBox(hDlg, caption, msg, &m_AVIbox) == IDCANCEL)
			{
				g_serviceThread->Cancel();
			}
		}
	}
	else
	{
		// goto the no-connection icon.
		StatusIcon(hDlg, IDI_FAILED);
	}
}

//---------------------------------------------------------------------------
void CGenPage::OnFinishConnected(HWND hDlg, LPARAM lParam)
{
	if(lParam)
	{
		IStream *pStream = (IStream *)lParam;
		IWbemServices *pServices = 0;
		HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
											IID_IWbemServices,
											(void**)&pServices);
		
		m_connected = true;

		SetWbemService(pServices);

		if(ServiceIsReady(NO_UI, 0,0))
		{
			m_DSStatus = m_DS->Initialize(pServices);
		}
		HWND hOK = GetDlgItem(GetParent(hDlg), IDOK);
		EnableWindow(hOK, TRUE);
	}
	else
	{
		HWND hOK = GetDlgItem(GetParent(hDlg), IDOK);
		EnableWindow(hOK, FALSE);
	}

	if(m_AVIbox)
		{
			PostMessage(m_AVIbox, WM_ASYNC_CIMOM_CONNECTED, 0, 0);
			m_AVIbox = 0;
		}
	
	
}	

//---------------------------------------------------------------------------
void CGenPage::MinorError(CHString1 &initMsg, UINT fmtID, 
							HRESULT hr, CHString1 &success)
{
	CHString1 fmt, temp;

	fmt.LoadString(fmtID);

	if(FAILED(hr))
	{
		TCHAR errMsg[256] = {0};
		ErrorStringEx(hr, errMsg, 256);
		temp.Format(fmt, errMsg);
	}
	else
	{
		temp.Format(fmt, success);
	}
	initMsg += temp;
	initMsg += "\r\n";
}

//---------------------------------------------------------------------------
void CGenPage::Refresh(HWND hDlg)
{
	if(m_DS && m_DS->IsNewConnection(&m_sessionID))
	{

		CHString1 initMsg;

		if(m_DS->m_rootThread.m_status != WbemServiceThread::ready)
		{
			TCHAR errMsg[256] = {0};
			CHString1 fmt, name;

			fmt.LoadString(IDS_CONN_FAILED_FMT);
			if(FAILED(m_DS->m_rootThread.m_hr))
			{
				ErrorStringEx(m_DS->m_rootThread.m_hr, errMsg, 256);
			}
			else if(m_DS->m_rootThread.m_status == WbemServiceThread::notStarted)
			{
				::LoadString(_Module.GetModuleInstance(), IDS_STATUS_NOTSTARTED, 
								errMsg, ARRAYSIZE(errMsg));
			}
			else if(m_DS->m_rootThread.m_status == WbemServiceThread::cancelled)
			{
				::LoadString(_Module.GetModuleInstance(), IDS_STATUS_CANCELLED, 
								errMsg, ARRAYSIZE(errMsg));
			}

			if(m_DS->IsLocal())
			{
				name.LoadString(IDS_LOCAL_CONN);
				initMsg.Format(fmt, name, errMsg);
			}
			else
			{
				initMsg.Format(fmt, m_DS->m_whackedMachineName, errMsg);
			}
//			::SetWindowText(GetDlgItem(hDlg, IDC_MACHINE), _T(""));
			m_connected = false;

		}
		else if(FAILED(m_DSStatus))   // major DS failure.
		{
			TCHAR errMsg[256] = {0};
			CHString1 fmt, name;

			fmt.LoadString(IDS_CONN_FAILED_FMT);
			ErrorStringEx(m_DSStatus, errMsg, 256);

			if(m_DS->IsLocal())
			{
				name.LoadString(IDS_LOCAL_CONN);
				initMsg.Format(fmt, name, errMsg);
			}
			else
			{
				initMsg.Format(fmt, m_DS->m_whackedMachineName, errMsg);
			}
			m_connected = false;
		}
		else if(FAILED(m_DS->m_settingHr) ||
				FAILED(m_DS->m_osHr) ||
				FAILED(m_DS->m_cpuHr) ||
				FAILED(m_DS->m_securityHr))   // minor DS failures
		{
			CHString1 success;
				
			success.LoadString(IDS_NO_ERR);
			
			initMsg.LoadString(IDS_PARTIAL_DS_FAILURE);
			initMsg += "\r\n\r\n";

			// format the details into a coherent msg.
			MinorError(initMsg, IDS_CPU_ERR_FMT, m_DS->m_cpuHr, success);
			MinorError(initMsg, IDS_SETTING_ERR_FMT, m_DS->m_settingHr, success);
			MinorError(initMsg, IDS_SEC_ERR_FMT, m_DS->m_securityHr, success);
			MinorError(initMsg, IDS_OS_ERR_FMT, m_DS->m_osHr, success);
			m_connected = false;
		}
		else  // it all worked
		{
			CHString1 temp, label;
			CHString1 szNotRemoteable, szUnavailable;
			HRESULT hr = S_OK;
			BOOL enable = TRUE;

			szNotRemoteable.LoadString(IDS_NOT_REMOTEABLE);
			szUnavailable.LoadString(IDS_UNAVAILABLE);

			// - - - - - - - - - - - - - -
			// computer name:
			label.LoadString(IDS_CONNECTED_TO_LABEL);
			initMsg += label;

			if(m_DS->IsLocal())
			{
				label.LoadString(IDS_LOCAL_CONN);
	#ifndef SNAPIN
//				::SetWindowText(GetDlgItem(hDlg, IDC_MACHINE), label);
	#endif
				initMsg += label;
			}
			else
			{
				initMsg += m_DS->m_whackedMachineName;
	#ifndef SNAPIN
//				SetWindowText(GetDlgItem(hDlg, IDC_MACHINE), 
								(LPCTSTR)m_DS->m_whackedMachineName);
	#endif
			}
			initMsg += "\r\n\r\n";

	#ifdef SNAPIN
			LOGIN_CREDENTIALS *credentials = m_DS->GetCredentials();
			SetUserName(hDlg, credentials);
	#endif
			// - - - - - - - - - - - - - -
			// operating system:
			hr = m_DS->GetCPU(temp);
			
			label.LoadString(IDS_CPU_LABEL);
			initMsg += label;

			if(SUCCEEDED(hr))
			{
				initMsg += temp;
			}
			else //failed
			{
				initMsg += szUnavailable;
			}

			initMsg += "\r\n";

			// - - - - - - - - - - - - - -
			// operating system:
			hr = m_DS->GetOS(temp);

			label.LoadString(IDS_OS_LABEL);
			initMsg += label;

			if(SUCCEEDED(hr))
			{
				initMsg += temp;
			}
			else //failed
			{
				initMsg += szUnavailable;
			}
			initMsg += "\r\n";

			// - - - - - - - - - - - - - - -
			hr = m_DS->GetOSVersion(temp);
			
			label.LoadString(IDS_OS_VER_LABEL);
			initMsg += label;
			
			if(SUCCEEDED(hr))
			{
				initMsg += temp;
			}
			else //failed
			{
				initMsg += szUnavailable;
			}
			initMsg += "\r\n";

			// -------------- Service Pack Number ---------------
			hr = m_DS->GetServicePackNumber(temp);

			if(SUCCEEDED(hr))
			{
				label.LoadString(IDS_OS_SERVICE_PACK_LABEL);
				initMsg += label;
				initMsg += temp;
				initMsg += "\r\n";
			}
			// - - - - - - - - - - - - - -
			// wmi build number:
			hr = m_DS->GetBldNbr(temp);

			label.LoadString(IDS_WMI_VER_LABEL);
			initMsg += label;

			if(SUCCEEDED(hr))
			{
				initMsg += temp;
			}
			else //failed
			{
				initMsg += szUnavailable;
			}

			initMsg += "\r\n";

			// - - - - - - - - - - - - - -
			// wmi install dir:
			hr = m_DS->GetInstallDir(temp);

			label.LoadString(IDS_WMI_INSTALL_DIR);
			initMsg += label;

			if(SUCCEEDED(hr))
			{
				initMsg += temp;
			}
			else //failed
			{
				initMsg += szUnavailable;
			}

			m_connected = true;

		} //endif ServiceIsReady() 

		// - - - - - - - - - - - - - -
		SetWindowText(GetDlgItem(hDlg, IDC_STATUS), initMsg);

		if(m_DS->IsLocal() == TRUE)
		{
			EnableWindow(GetDlgItem(hDlg,IDC_CHANGE),FALSE);
		}
		else
		{
			EnableWindow(GetDlgItem(hDlg,IDC_CHANGE),TRUE);
		}
	}
}

//------------------------------------------------------------------------
void CGenPage::SetUserName(HWND hDlg, LOGIN_CREDENTIALS *credentials)
{
    // intentionally left blank
}

//------------------------------------------------------------------------
BOOL CGenPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

	case WM_ASYNC_CIMOM_CONNECTED:
//		if(!m_connected)
		{
			OnFinishConnected(hDlg, lParam);
			Refresh(hDlg);   // doesnt get a PSN_SETACTIVE from this.
		}
		break;

	case WM_CIMOM_RECONNECT:
			m_DS->Disconnect();
			OnConnect(hDlg, m_DS->GetCredentials());
		break;

    case WM_NOTIFY:
        {
            switch(((LPNMHDR)lParam)->code)
            {
			case PSN_SETACTIVE:
				Refresh(hDlg);
				break;

/********************************

            this code essentially blocks us from moving off the first page
            when the connection to WMI failed.  Removed the block per RAID 509070.
            I'm leaving the code in because I'm afraid that something may break.
            (It's been well tested - I'm paranoid)

			case PSN_KILLACTIVE:
				// dont switch away if the connection didn't work.
				if(m_connected)
				{
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
					return FALSE;
				}
				else
				{
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
					return TRUE;
				}

				break;
********************************/

			case PSN_HELP:
				HTMLHelper(hDlg);
				break;

            }
        }
        break;

    case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_CHANGE:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				TCHAR name[MAX_PATH + 1] = {0};
				bool isLocal = m_DS->IsLocal();
				LOGIN_CREDENTIALS *credentials = m_DS->GetCredentials();
#ifdef SNAPIN
				if(DisplayLoginDlg(hDlg, credentials) == IDOK)
				{
					SetUserName(hDlg, credentials);

					// reconnect with new credentials.
					m_DS->Disconnect(false);
					OnConnect(hDlg, credentials);

				} //endif DisplayLoginDlg()
#else
				INT_PTR x = DisplayCompBrowser(hDlg, name, 
											sizeof(name)/sizeof(name[0]), 
											&isLocal, credentials);
				if(x == IDOK)
				{
                    if (m_DS)
                        m_DS->ClosePropSheet();        

					if(isLocal)
					{
						// an empty string will cause a local connection.
						name[0] = '\0';
					}
					m_DS->SetMachineName(CHString1(name));
					OnConnect(hDlg, credentials);
				}
#endif
			} //endif HIWORD
		
	        break;
		default: break;
		} //endswitch
		break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
			//WIERD: for some reaon, I'm getting this msg after closing the
			// connect dlg.
			WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
					c_HelpFile,
					HELP_WM_HELP,
					(ULONG_PTR)genPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)genPageHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\logpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __LOGGINGPAGE__
#define __LOGGINGPAGE__

#include "UIHelpers.h"
#include "DataSrc.h"

class CLogPage : public CUIHelpers
{
private:

public:
    CLogPage(DataSource *ds, bool htmlSupport) :
		CUIHelpers(ds, &(ds->m_rootThread), htmlSupport){}
    virtual ~CLogPage(void);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitDlg(HWND hDlg);
	void Refresh(HWND hDlg);
    void OnApply(HWND hDlg, bool bClose);
	BOOL OnValidate(HWND hDlg);
	bool GoodPathSyntax(LPCTSTR path);

	DataSource::LOGSTATUS m_oldStatus;  //original logging status.
};

#endif __LOGGINGPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\nspicker.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef _NSPICKER_H_
#define _NSPICKER_H_
#pragma once

#include "resource.h"
#include "sshWbemHelpers.h"

//-----------------------------------------------------------------------------
class CNSPicker : public CUIHelpers
{
private:
	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSelChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	LRESULT OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	CWbemServices m_WbemService;
	HTREEITEM m_hSelectedItem;

public:
	CNSPicker(CWbemServices &root);
	~CNSPicker(void);

	int DoModal(HWND hDlg);
	BOOL CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

	TCHAR m_path[MAX_PATH];
};

BOOL CALLBACK StaticPickerDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif _NSPICKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\nspage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __NAMESPACEPAGE__
#define __NAMESPACEPAGE__

#include "UIHelpers.h"
#include "CHString1.h"
#include <commctrl.h>

class DataSource;
class CNamespacePage : public CUIHelpers
{
private:

public:
    CNamespacePage(DataSource *ds, bool htmlSupport);
    virtual ~CNamespacePage(void);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitDlg(HWND hDlg);
    void OnApply(HWND hDlg, bool bClose);
	void Refresh(HWND hDlg);
	void OnProperties(HWND hDlg);
	HPROPSHEETPAGE CreateSecurityPage(struct NSNODE *node);
	
	int m_NSflag;
	HINSTANCE m_HWNDAlcui;
	bool m_connected;
	HTREEITEM m_hSelectedItem;
};


#endif __NAMESPACEPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\nspicker.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "NSPicker.h"

// Help IDs
/*DWORD aAdvancedHelpIds[] = {
    IDC_ADV_PERF_ICON,             (IDH_ADVANCED + 0),
    0, 0
};
*/

//------------------------------------------------------
CNSPicker::CNSPicker(CWbemServices &root) :
						m_WbemService(root)
{
}

//------------------------------------------------------
CNSPicker::~CNSPicker(void)
{
}

//----------------------------------------------
LRESULT CNSPicker::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
//	PopulateTree(m_hWnd, IDC_NSTREE, m_WbemService);
	return TRUE;
}

//----------------------------------------------
LRESULT CNSPicker::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
/*	::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
				_T("sysdm.hlp"),
				HELP_WM_HELP,
				(DWORD)(LPSTR)aAdvancedHelpIds);
*/
	return TRUE;
}

//----------------------------------------------
LRESULT CNSPicker::OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	switch(wID)
	{
	case IDOK:
		{
			// save the currently selected fullpath name.
			HWND hTree = ::GetDlgItem(m_hWnd, IDC_NSTREE);
			TV_ITEM item;
			item.mask = TVIF_PARAM;
			item.hItem = m_hSelectedItem;
			BOOL x = TreeView_GetItem(hTree, &item);

			_tcsncpy(m_path, ((ITEMEXTRA *)item.lParam)->fullPath, MAX_PATH);
		}
		EndDialog(IDOK);
		break;

	case IDCANCEL:
		EndDialog(IDCANCEL);
		break;
	}

    return TRUE;
}

//----------------------------------------------
LRESULT CNSPicker::OnSelChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    switch(pnmh->code)
    {
	case TVN_SELCHANGED:
		if(pnmh->idFrom == IDC_NSTREE)
		{
			LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)pnmh;
			m_hSelectedItem = pnmtv->itemNew.hItem;
		}
		break;
    }
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\mofstr.inc ===
#if 0
Copyright (c) 1997-1999 Microsoft Corporation
#endif

#define CLASSMOF "instance of __Win32provider as $P{\n\
Name = \"RegPropProv\";\n\
Clsid = \"{72967901-68EC-11d0-B729-00AA0062CBB7}\";\n\
ImpersonationLevel = 1;\n\
PerUserInitialization = TRUE;};\n\
instance of __PropertyProviderRegistration {\n\
Provider = $P;\n\
SupportsGet = TRUE;\n\
SupportsPut = TRUE;};\n\
[DYNPROPS, singleton] class Win32_WMISetting{\n\
[read] string InstallationDirectory;\n\
[read] string BuildVersion;\n\
[read, write] uint32 AutoStartWin9X;\n\
[read, write] boolean EnableAnonWin9xConnections;\n\
[read, write] string MaxLogFileSize;\n\
[read, write] string LoggingLevel;\n\
[read, write] string LoggingDirectory;\n\
[read] string DatabaseDirectory;\n\
[read, write] string BackupInterval;\n\
[read, write] boolean ASPScriptEnabled;\n\
[read, write] string ASPScriptDefaultNamespace = \"\\\\\\\\root\\\\cimv2\";};"

#define INSTMOF "[DYNPROPS]instance of Win32_WMISetting{\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem|Installation Directory\")] \n\
InstallationDirectory;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem|Build\")] \n\
BuildVersion;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|Log File Max Size\")]\n\
MaxLogFileSize;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|Logging\")]\n\
LoggingLevel;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|Logging Directory\")]\n\
LoggingDirectory;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|Repository Directory\")]\n\
DatabaseDirectory;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|Backup Interval Threshold\")]\n\
BackupInterval;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\Scripting|Enable for ASP\")]\n\
ASPScriptEnabled;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\Scripting|Default Namespace\")]\n\
ASPScriptDefaultNamespace;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|AutostartWin9X\")]\n\
AutoStartWin9X;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|EnableAnonConnections\")]\n\
EnableAnonWin9xConnections;};"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\mofsec.inc ===
#if 0
Copyright (c) 1997-1999 Microsoft Corporation
#endif

#define SECMOF "instance of __NTLMUser{\n\
GroupType = 0;Name = \"Administrators\";\n\
Authority = \".\";Enabled = TRUE;Permissions = 2;ExecuteMethods = TRUE;EditSecurity = TRUE;};\n\
instance of __NTLMUser{\n\
GroupType = 0;Name = \"Everybody\";\n\
Authority = \".\";Enabled = TRUE;Permissions = 0;ExecuteMethods = FALSE;EditSecurity = FALSE;};"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\nspage.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright (c) 1997-1999 Microsoft Corporation
/**********************************************************************/


#include "precomp.h"
#include "NSPage.h"
#include "resource.h"
#include "CHString1.h"
#include "wbemerror.h"
#include "RootSecPage.h"
#include "ErrorSecPage.h"
#include "DataSrc.h"
#include "WMIHelp.h"
#include <cominit.h>
#include <stdio.h>

const static DWORD nsPageHelpIDs[] = {  // Context Help IDs
	IDC_NS_PARA,	-1,
	IDC_NSTREE,		IDH_WMI_CTRL_SECURITY_NAMESPACE_BOX,
	IDC_PROPERTIES, IDH_WMI_CTRL_SECURITY_SECURITY_BUTTON,
    0, 0
};

//-------------------------------------------------------------------------
CNamespacePage::CNamespacePage(DataSource *ds, bool htmlSupport) :
						CUIHelpers(ds, &(ds->m_rootThread), htmlSupport),
						m_HWNDAlcui(0)

{
	m_connected = false;
	m_hSelectedItem = 0;
}

//-------------------------------------------------------------------------
CNamespacePage::~CNamespacePage(void)
{
	if(m_HWNDAlcui)
	{
		FreeLibrary(m_HWNDAlcui);
		m_HWNDAlcui = NULL;
	}
}

//---------------------------------------------------------------------------
void CNamespacePage::InitDlg(HWND hDlg)
{
	m_hDlg = hDlg;
	m_DS->SetControlHandles(GetDlgItem(hDlg,IDC_ENUM_STATIC),GetDlgItem(hDlg,IDC_CANCEL_ENUM));
	Refresh(m_hDlg);
}

//---------------------------------------------------------------------------
typedef HPROPSHEETPAGE (WINAPI *CREATEPAGE_PROC) (LPSECURITYINFO);

HPROPSHEETPAGE CNamespacePage::CreateSecurityPage(struct NSNODE *node)
/*												  CWbemServices &ns,
												  _bstr_t path,
												  _bstr_t display)
*/
{
    HPROPSHEETPAGE hPage = NULL;

	// NOTE: (si == NULL) means the target is pre-M3 (RootSecStyle).
	ISecurityInformation *si = m_DS->GetSI(node);

	// NS_MethodStyle on NT....this is full ACL security.
	if(si != NULL)
	{
		// try to load aclui.
		if(m_HWNDAlcui == NULL)
		{
			m_HWNDAlcui = LoadLibrary(_T("aclui.dll"));
		}

		// client has a aclui
		if(m_HWNDAlcui != NULL)
		{
			// create aclui with full si.
			CREATEPAGE_PROC createPage = (CREATEPAGE_PROC)GetProcAddress(m_HWNDAlcui, "CreateSecurityPage");
			if(createPage)
			{
				si->AddRef();
				hPage = createPage(si);
			}
			else 
			{
				// couldnt get the exported routines.
				CErrorSecurityPage *pPage = new CErrorSecurityPage(IDS_NO_CREATE_SEC);
				hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_SEC_ERROR));
			}
		}
		else  // no editor dude. Upgrade the client to atleast nt4sp4.
		{
			// cant run aclui from here.
			CErrorSecurityPage *pPage = NULL;
			if(IsNT())
			{
				pPage = new CErrorSecurityPage(IDS_NO_ACLUI);
			}
			else
			{
				pPage = new CErrorSecurityPage(IDS_NO_98TONT_SEC);
			}
			if(pPage)
			{
				hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_SEC_ERROR));
			}
		}
	}
/*	else // not new NT
	{ 
		// RootSecStyle on 9x or NT (basically pre-M3 on anything)
		if(m_DS->IsAncient())
		{
			// must use internal editor for schema security.
			CRootSecurityPage *pPage = new CRootSecurityPage(	ns,
																CPrincipal::RootSecStyle, path,
																m_htmlSupport,
																m_DS->m_OSType);

			hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_9XSEC));
		}
		else // NS_MethodStyle on 9x...
		{
			// must use internal editor for schema security.
			CRootSecurityPage *pPage = new CRootSecurityPage(ns, CPrincipal::NS_MethodStyle, path,
																m_htmlSupport,
																m_DS->m_OSType);

			hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_9XSEC));
		}
	}
*/
	return hPage;
}

//--------------------------------------------------------------------
void CNamespacePage::OnProperties(HWND hDlg)
{
    HPROPSHEETPAGE hPage;
    UINT cPages = 0;
    BOOL bResult = FALSE;

	// get the selected item.
	HWND treeHWND = GetDlgItem(hDlg, IDC_NSTREE);
	TV_ITEM item;
	item.mask = TVIF_PARAM;
	if(!m_hSelectedItem)
	{
		m_hSelectedItem = TreeView_GetRoot(treeHWND);
		TreeView_SelectItem(treeHWND,m_hSelectedItem);
	}
	
	item.hItem = m_hSelectedItem;
	BOOL x = TreeView_GetItem(treeHWND, &item);

	if ( FALSE == x )
	    return;
	
	struct NSNODE *node = ((ITEMEXTRA *)item.lParam)->nsNode;
	//TreeView_SelectItem(TreeView_GetRoot(treeHWND))
/*	_bstr_t relName(node->fullPath);

	// WARNING: [5] ignores the 'root\' part cuz this call is relative to
	// the 'root' namespace anyway. If the root name changes length, this
	// assumption will break.
	CWbemServices ns;

	_bstr_t tempName = m_DS->m_whackedMachineName;
	if(tempName.length() > 0)
	{
		tempName += L"\\";
	}
	tempName += relName;

	if(m_DS->IsAncient())
	{
		ns = m_DS->RootSecNS();
		tempName += L"\\security";


		// VERY WIERD HACK: if I dont 'exercise' it here, it will hang later on
		// when connected to a wmi 698 build.
		IEnumWbemClassObject *users = NULL;
		HRESULT hr = ns.CreateInstanceEnum(L"__NTLMUser", 0, &users);
		users->Release();
		users = 0;
	}
	else
	{
		ns.ConnectServer(tempName, m_DS->GetCredentials());
	}

*/	// - - - - - - - - - - - - - - - - 
	// build the sheet.
//	if((bool)ns)
//	{
		hPage = CreateSecurityPage(node);
		if(hPage)
		{
			// Build dialog title string
			TCHAR szTitle[MAX_PATH + 20] = {0};
			LoadString(_Module.GetModuleInstance(), IDS_NS_PROP_TITLE, 
							szTitle, ARRAYSIZE(szTitle));

			struct NSNODE *node = ((ITEMEXTRA *)item.lParam)->nsNode;
			if(node)
			{
				lstrcat(szTitle, node->fullPath);
			}

			PROPSHEETHEADER psh = {0};
			psh.dwSize = sizeof(psh);
			psh.dwFlags = PSH_DEFAULT;
			psh.hwndParent = hDlg;
			psh.hInstance = _Module.GetModuleInstance();
			psh.pszCaption = szTitle;
			psh.nPages = 1;
			psh.nStartPage = 0;
			psh.phpage = &hPage;

		    bResult = (BOOL)(PropertySheet(&psh) + 1);
		}
//	}
}

//---------------------------------------------------------------------------
void CNamespacePage::Refresh(HWND hDlg)
{
	if(m_DS && m_DS->IsNewConnection(&m_sessionID))
	{
		// 9x machines cant manage security on NT machines.
		bool is9xToNT = (IsNT() == false) && (m_DS->m_OSType == OSTYPE_WINNT);

		EnableWindow(GetDlgItem(hDlg, IDC_NSTREE), !is9xToNT);
		EnableWindow(GetDlgItem(hDlg, IDC_PROPERTIES), !is9xToNT);

		CHString1 para;
		
		if(is9xToNT)
		{
			para.LoadString(IDS_NO_98TONT_SEC);
			SetWindowText(GetDlgItem(hDlg, IDC_NS_PARA), para);
			return;  // early.
		}
		else
		{
			para.LoadString(IDS_NS_PARA);
			SetWindowText(GetDlgItem(hDlg, IDC_NS_PARA), para);
		}


		CHString1 initMsg;
		if(m_DS->m_rootThread.m_status == WbemServiceThread::ready)
		{
			HWND hTree = GetDlgItem(hDlg, IDC_NSTREE);
			TreeView_DeleteAllItems(hTree);
			m_DS->DeleteAllNodes();
		//	bool hideMfls = false;  //TODO

			m_NSflag = SHOW_ALL;

			// old targets only use the the root node for security.
			if(m_DS->IsAncient())
			{
				m_NSflag = ROOT_ONLY;
				// TODO: hide the 'hide mfls' checkbox. Moot point on old targets.
			}
		//	else if(hideMfls)
		//	{
		//		m_NSflag = DataSource::HIDE_SOME;
		//	}

			m_DS->LoadImageList(hTree);
			m_DS->LoadNode(hTree, TVI_ROOT, m_NSflag);
		}
		else
		{
			::EnableWindow(GetDlgItem(hDlg, IDC_NSTREE), FALSE);
			::EnableWindow(GetDlgItem(hDlg, IDC_PROPERTIES), FALSE);
		} //endif ServiceIsReady() 
	}
}

//------------------------------------------------------------------------
void CNamespacePage::OnApply(HWND hDlg, bool bClose)
{
	::SendMessage(GetParent(hDlg), PSM_UNCHANGED, (WPARAM)hDlg, 0L);
}

//------------------------------------------------------------------------
BOOL CNamespacePage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	HWND hTree = GetDlgItem(hDlg,IDC_NSTREE);
	struct NSNODE *node;
	LPNMTREEVIEW  pnm = (LPNMTREEVIEW)lParam;
	TCHAR strTemp[1024];

    switch(uMsg)
    {
    case WM_INITDIALOG:
//		OutputDebugString(_T("Inside InitDialog!!!!\n"));
        InitDlg(hDlg);
        break;

	case WM_ASYNC_CIMOM_CONNECTED:
		if(!m_connected)
		{
			m_connected = true;
			Refresh(hDlg);
		}
		break;

    case WM_NOTIFY:
        {
			if(pnm->hdr.code == NM_CUSTOMDRAW)
			{
				LPNMTREEVIEW  pnm = (LPNMTREEVIEW)lParam;
				LPNMLVCUSTOMDRAW lplvcd = (LPNMLVCUSTOMDRAW)lParam;

				switch(lplvcd->nmcd.dwDrawStage)
				{
					case CDDS_PREPAINT :
					
						SetWindowLong(hDlg,DWLP_MSGRESULT,CDRF_NOTIFYITEMDRAW);
						return CDRF_NOTIFYITEMDRAW;
						break;	
					case CDDS_ITEMPREPAINT:
					{
						if(lplvcd->nmcd.uItemState != CDIS_SELECTED)
						{
							ITEMEXTRA *pExtra = (ITEMEXTRA *)lplvcd->nmcd.lItemlParam;
							node = pExtra->nsNode;
							if(node->sType == TYPE_DYNAMIC_CLASS)
							{
								lplvcd->clrText = RGB(128,128,128);
								SetWindowLong(hDlg,DWLP_MSGRESULT,CDRF_NEWFONT);
								return CDRF_NEWFONT;
							}
						}
						break;
					}
					case CDDS_SUBITEM | CDDS_ITEMPREPAINT :
					{
						if(lplvcd->nmcd.uItemState != CDIS_SELECTED)
						{
							node = (struct NSNODE *)lplvcd->nmcd.lItemlParam;
							if(node->sType == TYPE_DYNAMIC_CLASS)
							{
								lplvcd->clrText = RGB(128,128,128);
								SetWindowLong(hDlg,DWLP_MSGRESULT,CDRF_NEWFONT);
								return CDRF_NEWFONT;
							}
						}
						break;
					}
					default:
//						_stprintf(strTemp,_T("*********************** Default : %x *****************\n"),lplvcd->nmcd.dwDrawStage);
//						OutputDebugString(strTemp);
						break;
				}	

			}
			else
			{
				switch(((LPNMHDR)lParam)->code)
				{
					// TODO: this one's more complex.
					case PSN_SETACTIVE:
						Refresh(hDlg);
						break;

					case PSN_HELP:
						HTMLHelper(hDlg);
						break;

					case PSN_APPLY:
						OnApply(hDlg, (((LPPSHNOTIFY)lParam)->lParam == 1));
						break;

					case TVN_SELCHANGED:
						if(((LPNMHDR)lParam)->idFrom == IDC_NSTREE)
						{
							ITEMEXTRA *extra;
							// remember the selection change for OnProperties()
							LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)lParam;
							m_hSelectedItem = pnmtv->itemNew.hItem;
							extra = (ITEMEXTRA *)pnmtv->itemNew.lParam;
							if((extra->nsNode->sType == TYPE_STATIC_CLASS) || 
							   (extra->nsNode->sType == TYPE_DYNAMIC_CLASS) || 
							   (extra->nsNode->sType == TYPE_SCOPE_CLASS))
							{
								//Disable the Security Button
								EnableWindow(GetDlgItem(hDlg,IDC_PROPERTIES),FALSE);
							}
							else
							{
								//In all other cases,enable the Security Button
								EnableWindow(GetDlgItem(hDlg,IDC_PROPERTIES),TRUE);
							}
						}
						break;

					case TVN_ITEMEXPANDING:
						if(((LPNMHDR)lParam)->idFrom == IDC_NSTREE)
						{
							// expand the node.
							LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)lParam;
							if(pnmtv->action == TVE_EXPAND)
							{
								HWND hTree = GetDlgItem(hDlg, IDC_NSTREE);
								m_DS->LoadNode(hTree, pnmtv->itemNew.hItem, m_NSflag);
							}
						}
						break;
				}

			}
        }
        break;

    case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_PROPERTIES:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				OnProperties(hDlg);
				SetFocus(GetDlgItem(hDlg, IDC_NSTREE));
			}
			break;
		case IDC_CANCEL_ENUM:
			{
				m_DS->CancelAllAsyncCalls();
				break;
			}
		default: break;
		};

        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)nsPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)nsPageHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\precomp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7F2AAB5C_A5AD_11D2_886A_00104B2AFB46__INCLUDED_)
#define AFX_STDAFX_H__7F2AAB5C_A5AD_11D2_886A_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#undef STRICT
#define STRICT


#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
};
extern CExeModule _Module;

#include <commdlg.h>
#include <commctrl.h>
#include <atlcom.h>

#define IS_BITSET(x, y) 	((x & y) == y)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7F2AAB5C_A5AD_11D2_886A_00104B2AFB46__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\pagebase.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright (c) 1997-1999 Microsoft Corporation
/**********************************************************************/

/*

    PAGEBASE.CPP

    This file contains the implementation of the CBasePage base class.

*/

#include "precomp.h"
#include "pagebase.h"
#include "ServiceThread.h"
#include "resource.h"
#include <commctrl.h>
#include "DataSrc.h"
#include <commdlg.h>
#include <cominit.h>
//#include <afxres.h>
#include "WMIHelp.h"

#ifdef SNAPIN
const TCHAR c_HelpFile2[] = _T("newfeat1.hlp");
#else
const TCHAR c_HelpFile2[] = _T("WbemCntl.hlp");
#endif


//-------------------------------------------------------------------
CBasePage::CBasePage(DataSource *ds, WbemServiceThread *serviceThread) :
	m_DS(ds), 
	m_userCancelled(false),
	m_hDlg(NULL), 
	m_alreadyAsked(false), 
	m_service(NULL), 
	g_serviceThread(serviceThread)
{
	if((g_serviceThread != 0) && 
		g_serviceThread->m_status == WbemServiceThread::ready)
	{
		m_WbemServices = g_serviceThread->m_WbemServices;
		m_WbemServices.GetServices(&m_service);
		m_WbemServices.SetBlanket(m_service);
	}
	if (m_DS)
	{
		m_DS->AddRef();
	}
}

//-------------------------------------------------------------------
CBasePage::CBasePage(CWbemServices &service) :
	m_DS(NULL), 
	m_userCancelled(false),
	m_hDlg(NULL), 
	m_alreadyAsked(false), 
	m_service(NULL), 
	g_serviceThread(NULL)
{
	m_WbemServices = service;
}

//-------------------------------------------------------------------
CBasePage::~CBasePage( void )
{
	if(m_service)
	{
		m_service->Release();
		m_service = 0;
	}
	m_WbemServices.DisconnectServer();
	m_alreadyAsked = false;
	if (m_DS)
	{		
		m_DS->Release();
	}
}

//-------------------------------------------------------------------
HPROPSHEETPAGE CBasePage::CreatePropSheetPage(LPCTSTR pszDlgTemplate, 
												LPCTSTR pszDlgTitle,
												DWORD moreFlags)
{
    PROPSHEETPAGE psp;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USECALLBACK | moreFlags;
    psp.hInstance   = _Module.GetModuleInstance();
    psp.pszTemplate = pszDlgTemplate;
    psp.pszTitle    = pszDlgTitle;
    psp.pfnDlgProc  = CBasePage::_DlgProc;
    psp.lParam      = (LPARAM)this;
    psp.pfnCallback = CBasePage::_PSPageCallback;

    if (pszDlgTitle != NULL)
        psp.dwFlags |= PSP_USETITLE;

    return CreatePropertySheetPage(&psp);
}

//-------------------------------------------------------------------
UINT CBasePage::PSPageCallback(HWND hwnd,
                              UINT uMsg,
                              LPPROPSHEETPAGE ppsp)
{
    return S_OK;
}

//-------------------------------------------------------------------
INT_PTR CALLBACK CBasePage::_DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBasePage *pThis = (CBasePage *)GetWindowLongPtr(hDlg, DWLP_USER);

    // The following messages arrive before WM_INITDIALOG
    // which means pThis is NULL for them.  We don't need these
    // messages so let DefDlgProc handle them.
    //
    // WM_SETFONT
    // WM_NOTIFYFORMAT
    // WM_NOTIFY (LVN_HEADERCREATED)

    if (uMsg == WM_INITDIALOG)
    {
        pThis = (CBasePage *)(((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pThis);
    }

    if (pThis != NULL) return pThis->DlgProc(hDlg, uMsg, wParam, lParam);

    return FALSE;
}

//-------------------------------------------------------------------
UINT CALLBACK CBasePage::_PSPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    CBasePage *pThis = (CBasePage *)ppsp->lParam;

    if (pThis)
    {
        UINT nResult = pThis->PSPageCallback(hWnd, uMsg, ppsp);

        switch (uMsg)
        {
        case PSPCB_CREATE:
            break;
        case PSPCB_RELEASE:
        	ppsp->lParam = NULL;
            delete pThis;
            break;
        }
    }

    //
    // Always return non-zero or else our tab will disappear and whichever
    // property page becomes active won't repaint properly.  Instead, use
    // the m_bAbortPage flag during WM_INITDIALOG to disable the page if
    // the callback failed.
    //
    return 1;
}

//---------------------------------------------------------
typedef struct {
	LOGIN_CREDENTIALS *credentials;
} LOGIN_CFG;

//------------------------------------------------------------------------
size_t CredentialUserLen3(LOGIN_CREDENTIALS *credentials)
{
	return credentials->authIdent->UserLength;
}

//------------------------------------------------------------------------
void CredentialUser3(LOGIN_CREDENTIALS *credentials, LPTSTR *user)
{
	bstr_t trustee = _T("");
	if ((TCHAR *)trustee == NULL)
		return;

	if(credentials->authIdent->DomainLength > 0)
	{
		trustee += credentials->authIdent->Domain;
		trustee += _T("\\");
		trustee += credentials->authIdent->User;
	}
	else
	{
		trustee = credentials->authIdent->User;
		if ((TCHAR *)trustee == NULL)
			return;
	}

#ifdef UNICODE
	if(credentials->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
	{
		size_t size = mbstowcs(NULL, trustee, 0);
		*user = new wchar_t[size+1];
		if(*user != NULL)
			mbstowcs(*user, trustee, size+1);
	}
	else   // already UNICODE
	{
		size_t size = wcslen(trustee);
		*user = new wchar_t[size+1];
		if(*user != NULL)
			wcscpy(*user, trustee);
	}
#else
	if(credentials->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
	{
		size_t size = strlen(trustee);
		*user = new char[size+1];
		if(*user != NULL)
			strcpy(*user, (char *)trustee);
	}
	else   // convert the UNICODE
	{
		size_t size = wcstombs(NULL, trustee, 0);
		*user = new char[size+1];
		if(*user != NULL)
			wcstombs(*user, trustee, size+1);
	}
#endif
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void SetCurrentUser2(HWND hDlg, bool currUser)
{
	Button_SetCheck(GetDlgItem(hDlg, IDC_CHECKCURRENTUSER), 
						(currUser? BST_CHECKED:BST_UNCHECKED));

	BOOL enable = (currUser? FALSE: TRUE);

	::EnableWindow(GetDlgItem(hDlg, IDC_EDITUSERNAME), enable);
	::EnableWindow(GetDlgItem(hDlg, IDC_EDITPASSWORD), enable);
	::EnableWindow(GetDlgItem(hDlg, IDC_USER_LABEL), enable);
	::EnableWindow(GetDlgItem(hDlg, IDC_PW_LABEL), enable);

}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const static DWORD logonHelpIDs[] = {  // Context Help IDs
	IDC_CHECKCURRENTUSER, IDH_WMI_CTRL_GENERAL_WMILOGIN_CHECKBOX,
	IDC_USER_LABEL, IDH_WMI_CTRL_GENERAL_WMILOGIN_USERNAME,
	IDC_EDITUSERNAME, IDH_WMI_CTRL_GENERAL_WMILOGIN_USERNAME,
	IDC_PW_LABEL, IDH_WMI_CTRL_GENERAL_WMILOGIN_PASSWORD,
	IDC_EDITPASSWORD, IDH_WMI_CTRL_GENERAL_WMILOGIN_PASSWORD,
    0, 0
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
INT_PTR CALLBACK LoginDlgProc2(HWND hwndDlg,
							 UINT uMsg,
							 WPARAM wParam,
							 LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{ //BEGIN
			SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
			LOGIN_CFG *data = (LOGIN_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

			SetCurrentUser2(hwndDlg, data->credentials->currUser);

		} //END
		retval = TRUE;
		break;

	case WM_COMMAND:
		{
			LOGIN_CFG *data = (LOGIN_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

			switch(LOWORD(wParam))
			{
			case IDC_CHECKCURRENTUSER:
				{
					if(HIWORD(wParam) == BN_CLICKED)
					{
						bool currUser = (IsDlgButtonChecked(hwndDlg, IDC_CHECKCURRENTUSER) == BST_CHECKED ?true:false);
						// toggle and respond.
						SetCurrentUser2(hwndDlg, currUser);
					}
				}
				break;

			case IDOK:
				{
					if(HIWORD(wParam) == BN_CLICKED)
					{
						data->credentials->currUser = (IsDlgButtonChecked(hwndDlg, IDC_CHECKCURRENTUSER) == BST_CHECKED ?true:false);

						if(data->credentials->currUser == false)
						{
							TCHAR user[100] = {0}, pw[100] = {0};
							GetWindowText(GetDlgItem(hwndDlg, IDC_EDITUSERNAME), user, 100);
							GetWindowText(GetDlgItem(hwndDlg, IDC_EDITPASSWORD), pw, 100);
							
							BSTR bDomUser, bUser = NULL, bDomain = NULL, bAuth = NULL;
//#ifdef SNAPIN
							wchar_t *temp = pw;
							bDomUser = SysAllocString(user);
/*#else
							wchar_t temp[100] = {0};
							mbstowcs(temp, user, 100);
							bDomUser = SysAllocString(temp);
							mbstowcs(temp, pw, 100);
#endif*/
							if (bDomUser != NULL &&
                                SUCCEEDED(DetermineLoginType(bDomain,
                                                             bUser,
                                                             bAuth,
                                                             bDomUser)))
							{
								if(data->credentials->authIdent != 0)
								{
									if(data->credentials->fullAcct)
									{
										data->credentials->fullAcct[0] = 0;
									}
									WbemFreeAuthIdentity(data->credentials->authIdent);
									data->credentials->authIdent = 0;
								}

								if (SUCCEEDED(WbemAllocAuthIdentity(bUser,
                                                                    temp,
                                                                    bDomain, 
                                            &(data->credentials->authIdent))))
                                {
                                    _tcscpy(data->credentials->fullAcct,
                                            user);
                                }
							}
						}

						EndDialog(hwndDlg, IDOK);
					}
				}
				break;

			case IDCANCEL:
				{
					if(HIWORD(wParam) == BN_CLICKED)
					{
						EndDialog(hwndDlg, IDCANCEL);
					}
				}
				break;

			default:
				return(FALSE);
			} // switch
			break;
		} // - - - - - - - - endswitch LOWORD()
		break;

    case WM_HELP:
        if(IsWindowEnabled(hwndDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile2,
                    HELP_WM_HELP,
                    (ULONG_PTR)logonHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if(IsWindowEnabled(hwndDlg))
        {
            WinHelp(hwndDlg, c_HelpFile2,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)logonHelpIDs);
        }
        break;

	default: break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
INT_PTR CBasePage::DisplayLoginDlg(HWND hWnd, 
								LOGIN_CREDENTIALS *credentials)
{
	LOGIN_CFG cfg;

	cfg.credentials = credentials;

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_LOGIN), 
							hWnd, LoginDlgProc2, 
							(LPARAM)&cfg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\principal.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __PRINCIPAL_H
#define __PRINCIPAL_H


// "generic" definition combining the perms from old and new security strategies.
#define ACL_ENABLE				0x1		//NS_MethodStyle
#define ACL_METHOD_EXECUTE		0x2		//NS_MethodStyle
#define ACL_FULL_WRITE			0x4		//NS_MethodStyle
#define ACL_PARTIAL_WRITE		0x8		//NS_MethodStyle
#define ACL_PROVIDER_WRITE		0x10	//NS_MethodStyle
#define ACL_REMOTE_ENABLE		0x20	//NS_MethodStyle
#define ACL_READ_CONTROL		0x20000	//NS_MethodStyle

#define ACL_WRITE_DAC			0x40000	//NS_MethodStyle & RootSecStyle:Edit Security

#define ACL_INSTANCE_WRITE		0x40	//RootSecStyle
#define ACL_CLASS_WRITE			0x80	//RootSecStyle

#define ACL_MAX_BIT	ACL_WRITE_DAC

#define VALID_NSMETHOD_STYLE (ACL_ENABLE | ACL_METHOD_EXECUTE | ACL_FULL_WRITE | \
								ACL_PARTIAL_WRITE | ACL_PROVIDER_WRITE | ACL_READ_CONTROL | \
								ACL_WRITE_DAC)

#define VALID_ROOTSEC_STYLE (ACL_INSTANCE_WRITE |\
								ACL_CLASS_WRITE | ACL_WRITE_DAC)

#define ALLOW_COL 1
#define DENY_COL 2

#include "DataSrc.h"
//------------------------------------------------------------------------
class CPrincipal
{
public:
	typedef enum {
		RootSecStyle,		// pre-M3
		NS_MethodStyle		// M3+		
	} SecurityStyle;

	// for initializing.
	CPrincipal(CWbemClassObject &userInst, SecurityStyle secStyle);
	
	// move m_perms into the checkboxes
	void LoadChecklist(HWND list, int OSType);

	// move the checkboxes into m_perms.
	void SaveChecklist(HWND list, int OSType);
	HRESULT Put(CWbemServices &service, CWbemClassObject &userInst);

	bool Changed(void) 
		{ 
			return (m_origPerms != m_perms); 
		};
	int GetImageIndex(void);
	void AddAce(CWbemClassObject &princ);

	HRESULT DeleteSelf(CWbemServices &service);  // M1 targets only.

	TCHAR m_name[100];
	TCHAR m_domain[100];
	SecurityStyle m_secStyle;
	UINT m_SidType;
	bool m_editable;

	// perms mask for this principal (aka account)
	DWORD m_perms, m_origPerms, m_inheritedPerms;
};

//------------------------------------------------------------------------
// An instance is attached to each item in the permissions list so they
// can be matched up reliably.
typedef struct 
{
	// Identifies the "generic" perm bit. Only set ONE bit.
	DWORD m_permBit;
} CPermission;

#endif __PRINCIPAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\pagebase.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef _PAGEBASE_H_
#define _PAGEBASE_H_

#include "..\common\sshWbemHelpers.h"
#include <windowsx.h>

// supports the page coordinating routines.
#define PB_LOGGING 0
#define PB_BACKUP 1
#define PB_ADVANCED 2
#define PB_LASTPAGE 2


class WbemServiceThread;
class DataSource;

class CBasePage
{
public:
    CBasePage(DataSource *ds, WbemServiceThread *serviceThread);
    CBasePage(CWbemServices &service);
    virtual ~CBasePage( void );

    HPROPSHEETPAGE CreatePropSheetPage(LPCTSTR pszDlgTemplate, 
										LPCTSTR pszDlgTitle = NULL,
										DWORD moreFlags = 0);
	DataSource *m_DS;

protected:
    virtual BOOL DlgProc(HWND, UINT, WPARAM, LPARAM) { return FALSE; }
    virtual UINT PSPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
    static INT_PTR CALLBACK _DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK _PSPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

	INT_PTR DisplayLoginDlg(HWND hWnd, 
						LOGIN_CREDENTIALS *credentials);

	HWND m_hDlg;
	bool m_alreadyAsked;
	WbemServiceThread *g_serviceThread;
	CWbemServices m_WbemServices;

	IWbemServices *m_service;
	bool m_userCancelled; // the connectServer() thread.
};


#endif  /* _PAGEBASE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\rootsecpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#if !defined(AFX_ROOTSECPAGE_H__CF09EE6C_BA3F_11D2_887F_00104B2AFB46__INCLUDED_)
#define AFX_ROOTSECPAGE_H__CF09EE6C_BA3F_11D2_887F_00104B2AFB46__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RootSecPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRootSecurityPage dialog
#include "UIHelpers.h"
#include "ChkListHandler.h"
#include "Principal.h"
#include "simplearray.h"
#include "CHString1.h"
#include <commctrl.h>

class DataSource;

class CRootSecurityPage : public CUIHelpers
{
// Construction
public:
	CRootSecurityPage(CWbemServices &ns, 
						CPrincipal::SecurityStyle secStyle, 
						_bstr_t path,
						bool htmlSupport,
						int OSType);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
	void InitDlg(HWND hDlg);
	HRESULT LoadSecurity(HWND hDlg);
	void LoadPermissionList(HWND hDlg);
    void OnApply(HWND hDlg, bool bClose);
	BOOL OnNotify(HWND hDlg, WPARAM idCtrl, LPNMHDR pnmh);
	void OnRemovePrincipal(HWND hDlg);
	bool AddPrincipal(HWND hPrinc, CWbemClassObject &princ,
						CPrincipal::SecurityStyle secStyle,
						int &iItem);
	HRESULT AddPrincipalsFromArray(HWND hPrinc, variant_t &vValue);
	HIMAGELIST LoadImageList(HINSTANCE hInstance, LPCTSTR pszBitmapID);
	CPrincipal *GetSelectedPrincipal(HWND hDlg, int *pIndex);
	void EnablePrincipalControls(HWND hDlg, BOOL fEnable);
	void OnSelChange(HWND hDlg);
	void CommitCurrent(HWND hDlg, int iPrincipal = -1 );
	void HandleCheckList(HWND hwndList,
						CPrincipal *pPrincipal,
						CPermission *perm,
						int iItem, DWORD_PTR *dwState);

	//typedef CSimpleArray<CHString1> USERLIST;
	void OnAddPrincipal(HWND hDlg);
	bool GetUser(HWND hDlg, CHString1 &user);
	HRESULT ParseLogon(CHString1 &domUser,
						  CHString1 &domain,
						  CHString1 &user);


	CCheckListHandler m_chkList;
	CPrincipal::SecurityStyle m_secStyle;
	_bstr_t m_path;
	int m_OSType;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ROOTSECPAGE_H__CF09EE6C_BA3F_11D2_887F_00104B2AFB46__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\principal.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "chklist.h"
#include "Principal.h"
#include "CHString1.h"

//-------------------------------------------------------------
CPrincipal::CPrincipal(CWbemClassObject &userInst, SecurityStyle secStyle) :
						m_secStyle(secStyle), 
						m_perms(0),
						m_inheritedPerms(0),
						m_editable(true)
{
	//------------------------------------------------
	// figure out what security strategy we're dealing with and load it
	// into my "generic" definition.

	memset(m_name, 0, 100 * sizeof(TCHAR));
	_tcsncpy(m_name, (LPCTSTR)userInst.GetString("Name"), 100);

	memset(m_domain, 0, 100 * sizeof(TCHAR));
	_tcsncpy(m_domain, (LPCTSTR)userInst.GetString("Authority"), 100);

	// if pre-M3 security...
	if(m_secStyle == RootSecStyle)
	{
		// this is the only instance for this guy so save it.

		// convert the convoluted "bits" into my real "generic" bits.
		m_perms |= (userInst.GetBool("EditSecurity") ? ACL_WRITE_DAC : 0);
		m_perms |= (userInst.GetBool("Enabled") ? ACL_ENABLE : 0);
		m_perms |= (userInst.GetBool("ExecuteMethods") ? ACL_METHOD_EXECUTE : 0);

		// NOTE: each "level" implies all the levels below so I INTENTIONALLY 
		// left out the 'breaks' so the bits would fall through and accumulate.
		switch(userInst.GetLong("Permissions"))
		{
		case 2:		// class write
			m_perms |= ACL_CLASS_WRITE;

		case 1:		// instance write
			m_perms |= ACL_INSTANCE_WRITE;
		}

		// remember for dirty bit processing later.
		m_origPerms = m_perms;
	}
	else  //new M3+ security
	{
		// ACL bits perfectly match m_perms.
		// NOTE: this securityStyle can have multiple aces per principal.
		AddAce(userInst);
	}
}

//------------------------------------------
// move m_perms into the checkboxes
void CPrincipal::LoadChecklist(HWND list, int OSType)
{
	INT_PTR itemCount = CBL_GetItemCount(list);
	CPermission *permItem = 0;
	UINT state;

	::EnableWindow(list, m_editable);

	// for each permission item...
	for(INT_PTR x = 0; x < itemCount; x++)
	{
		// which permission item is this
		permItem = (CPermission *)CBL_GetItemData(list, x);

		state = BST_UNCHECKED; // and enabled (local)

		// if its a local perm...
		if(IS_BITSET(m_perms, permItem->m_permBit))
		{
			// local perms override inherited perms.
			state = BST_CHECKED;
		}
		else if(IS_BITSET(m_inheritedPerms, permItem->m_permBit))
		{
			// you got it from your parent.
			state = CLST_CHECKDISABLED;
		}
		// set it.
		CBL_SetState(list, x, ALLOW_COL, state);
	} //endfor
}

//------------------------------------------
// move the checkboxes into m_perms.
void CPrincipal::SaveChecklist(HWND list, int OSType)
{
	INT_PTR itemCount = CBL_GetItemCount(list);
	CPermission *permItem = 0;
	LPARAM state = 0, state1 = 0;

	// clear this principal's perm bits.
	m_perms = 0;

	// for each perm...
	for(INT_PTR x = 0; x < itemCount; x++)
	{
		// get permission item.
		permItem = (CPermission *)CBL_GetItemData(list, x);

		// what's the check state?
		state = CBL_GetState(list, x, ALLOW_COL);

		// if its enabled (local) & checked, set the matching bit.
		// NOTE: This "explicit compare will eliminate CLST_DISABLEDed states which
		// shouldn't be saved off.
		if((state == BST_CHECKED) ||
		  ((state == CLST_CHECKDISABLED) && (OSType != OSTYPE_WINNT)))
		{
			m_perms |= permItem->m_permBit;
		}
	} //endfor
}

//------------------------------------------
// WARNING: this logic assumes it will only be called when the principal is
// being read in. If you want to add aces interactively, its a whole different
// game.
void CPrincipal::AddAce(CWbemClassObject &princ)
{
	DWORD flags = princ.GetLong("Flags");

	// if inherited...
	if(IS_BITSET(flags, INHERITED_ACE))
	{
		// simply accumulate bits.
		m_inheritedPerms |= princ.GetLong("Mask");
		m_editable = false;
	}
	else if(flags == CONTAINER_INHERIT_ACE)
	{
		m_perms |= princ.GetLong("Mask");

		// this is the first local ace, we can edit it so save the source instance.
		// NOTE: Any additional "local" aces that exactly match CONTAINER_INHERIT_ACE
		// will be merged in but the the ClassObject will be tossed.
		//if(!(bool)m_userInst)
		//{
	//		m_userInst = princ;
	//	}

		// remember for dirty bit processing later.
		m_origPerms = m_perms;
	}
	else
	{
		// this will disable the checklist control for this principal.
		m_editable = false;
	}
}

//------------------------------------------
HRESULT CPrincipal::DeleteSelf(CWbemServices &service)
{
	HRESULT hr = S_OK;

	if(m_secStyle == RootSecStyle)
	{
		CHString1 path, fmt("__NTLMuser.Name=\"%s\",Authority=\"%s\"");
		path.Format(fmt, m_name, m_domain);

		hr = service.DeleteInstance((LPCTSTR)path);
	}
	return hr;
}

//------------------------------------------
// move m_perms into the checkboxes
HRESULT CPrincipal::Put(CWbemServices &service, CWbemClassObject &userInst)
{
	HRESULT hr = E_FAIL;
	
	if(m_editable)
	{
		// if pre-M3 security...
		if(m_secStyle == RootSecStyle)
		{
			DWORD perm = 0;
			// convert my "generic" bits back to convoluted "bits".
			userInst = service.CreateInstance("__NTLMUser");
			userInst.Put("Name", (bstr_t)m_name);
			userInst.Put("Authority", (bstr_t)m_domain);
			userInst.Put("EditSecurity", (bool)((m_perms & ACL_WRITE_DAC) != 0));
			userInst.Put("Enabled", (bool)((m_perms & ACL_ENABLE) != 0));
			userInst.Put("ExecuteMethods", (bool)((m_perms & ACL_METHOD_EXECUTE) != 0));

			if(m_perms & ACL_CLASS_WRITE)
			{
				perm = 2;
			}
			else if(m_perms & ACL_INSTANCE_WRITE)
			{
				perm = 1;
			}
			else
			{
				perm = 0;
			}
			userInst.Put("Permissions", (long)perm);

			hr = service.PutInstance(userInst);
		}
		else  //new M3+ security
		{
			// ACL bits perfectly match m_perms.
			userInst = service.CreateInstance("__NTLMUser9x");
			userInst.Put("Name", (bstr_t)m_name);
			userInst.Put("Authority", (bstr_t)m_domain);
			userInst.Put("Flags", (long)CONTAINER_INHERIT_ACE);
			userInst.Put("Mask", (long)m_perms);
			userInst.Put("Type", (long)ACCESS_ALLOWED_ACE_TYPE);
			hr = S_OK;
		}
	}

	return hr;
}

//-----------------------------------------------------------------------------
// Indexes into the SID image list IDB_SID_ICONS.
#define IDB_GROUP                       0
#define IDB_USER                        1
#define IDB_ALIAS                       2
#define IDB_UNKNOWN                     3
#define IDB_SYSTEM                      4
#define IDB_REMOTE                      5
#define IDB_WORLD                       6
#define IDB_CREATOR_OWNER               7
#define IDB_NETWORK                     8
#define IDB_INTERACTIVE                 9
#define IDB_DELETEDACCOUNT              10

//TODO: match the magic strings when provider catches up.

int CPrincipal::GetImageIndex(void)
{
	UINT idBitmap = 0;
	return IDB_USER;
/*
	switch (m_SidType)
	{
	case SidTypeUser:
		return IDB_USER;
		break;

	case SidTypeGroup:
		return IDB_GROUP;
		break;

	case SidTypeAlias:
		return IDB_ALIAS;
		break;

	case SidTypeWellKnownGroup:
		if(_tcsicmp(m_name, _T("Everyone")) == 0)
		{
			return IDB_WORLD;
		}
		else if(_tcsicmp(m_name, _T("Creator Owner")) == 0)
		{
			return IDB_CREATOR_OWNER;
		}
		else if(_tcsicmp(m_name, _T("NETWORK")) == 0)
		{
			return IDB_NETWORK;
		}
		else if(_tcsicmp(m_name, _T("INTERACTIVE")) == 0)
		{
			return IDB_INTERACTIVE;
		}
		else if(_tcsicmp(m_name, _T("SYSTEM")) == 0)
		{
			return IDB_SYSTEM;
		}
		else
		{
			// wasn't that well known afterall  :)
			return IDB_GROUP;
		}
		break;

	case SidTypeDeletedAccount:
		return IDB_DELETEDACCOUNT;
		break;

	case SidTypeInvalid:
	case SidTypeUnknown:
		return IDB_UNKNOWN;
		break;

	case SidTypeDomain:
	default:
		// Should never get here.
		return IDB_UNKNOWN;
		break;
	}
	return IDB_UNKNOWN;
	*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\rootsecpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// RootSecPage.cpp : implementation file
//

#include "precomp.h"
#include "RootSecPage.h"
#include "resource.h"
#include "DataSrc.h"
#include <cominit.h>
#include "WMIHelp.h"

const static DWORD rootSecPageHelpIDs[] = {  // Context Help IDs
    IDC_SPP_PRINCIPALS, IDH_WMI_CTRL_SECURITY_NAMEBOX,
    IDC_SPP_ADD,        IDH_WMI_CTRL_SECURITY_ADD_BUTTON,
    IDC_SPP_REMOVE,     IDH_WMI_CTRL_SECURITY_REMOVE_BUTTON,
    IDC_SPP_ACCESS,     IDH_WMI_CTRL_SECURITY_PERMISSIONSLIST,
    IDC_SPP_ALLOW,      IDH_WMI_CTRL_SECURITY_PERMISSIONSLIST,
    IDC_SPP_PERMS,      IDH_WMI_CTRL_SECURITY_PERMISSIONSLIST,
    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CRootSecurityPage dialog


CRootSecurityPage::CRootSecurityPage(CWbemServices &ns, 
                                     CPrincipal::SecurityStyle secStyle,
                                     _bstr_t path, bool htmlSupport,
                                     int OSType) :
                            CUIHelpers(ns, htmlSupport), 
                            m_secStyle(secStyle), 
                            m_path(path),
                            m_OSType(OSType)
{
}

//---------------------------------------------------------------------------
#define MAX_COLUMN_CHARS    100

void CRootSecurityPage::InitDlg(HWND hDlg)
{
    m_hDlg = hDlg;
    HWND hPrinc = GetDlgItem(m_hDlg, IDC_SPP_PRINCIPALS);
    RECT rc;
    LV_COLUMN col;
    TCHAR szBuffer[MAX_COLUMN_CHARS] = {0};

    ListView_SetImageList(hPrinc,
                          LoadImageList(_Module.GetModuleInstance(), 
                          MAKEINTRESOURCE(IDB_SID_ICONS)),
                          LVSIL_SMALL);

    GetClientRect(hPrinc, &rc);

    LoadString(_Module.GetModuleInstance(), IDS_NAME, szBuffer, ARRAYSIZE(szBuffer));
    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.pszText = szBuffer;
    col.iSubItem = 0;
    col.cx = rc.right;
    int x = ListView_InsertColumn(hPrinc, 0, &col);

    // pre-load the appropriate permissions.
    LoadPermissionList(hDlg);
    HRESULT hr = LoadSecurity(hDlg);

    if(m_OSType != OSTYPE_WINNT)
    {
        ::ShowWindow(::GetDlgItem(hDlg, IDC_MSG), SW_SHOWNA);
    }
}

//-----------------------------------------------------------------------------
typedef struct {
    UINT ID;
    DWORD permBit;
} PERM_DEF;

PERM_DEF rootSecPerms[] = 
{
    {IDS_WBEM_GENERIC_EXECUTE,  ACL_METHOD_EXECUTE},
    {IDS_WBEM_INSTANCE_WRITE,   ACL_INSTANCE_WRITE},
    {IDS_WBEM_CLASS_WRITE,      ACL_CLASS_WRITE},
    {IDS_WBEM_ENABLE,           ACL_ENABLE},
    {IDS_WBEM_EDIT_SECURITY,    ACL_WRITE_DAC}
};

PERM_DEF NSMethodPerms[] = 
{
    {IDS_WBEM_GENERIC_EXECUTE,  ACL_METHOD_EXECUTE},
    {IDS_WBEM_FULL_WRITE,       ACL_FULL_WRITE},
    {IDS_WBEM_PARTIAL_WRITE,    ACL_PARTIAL_WRITE},
    {IDS_WBEM_PROVIDER_WRITE,   ACL_PROVIDER_WRITE},
    {IDS_WBEM_ENABLE,           ACL_ENABLE},
    {IDS_WBEM_REMOTE_ENABLE,    ACL_REMOTE_ENABLE},
    {IDS_WBEM_READ_SECURITY,    ACL_READ_CONTROL},
    {IDS_WBEM_EDIT_SECURITY,    ACL_WRITE_DAC}
};

#define FULL_WRITE_IDX 1
#define PARTIAL_WRITE_IDX 2
#define PROVIDER_WRITE_IDX 3

#define PERM_LABEL_SIZE 100

void CRootSecurityPage::LoadPermissionList(HWND hDlg)
{
    HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PERMS);    // checklist window
    HRESULT hr = S_OK;
    PERM_DEF *currRights = (m_secStyle == CPrincipal::RootSecStyle ? 
                                rootSecPerms : 
                                NSMethodPerms);

    int permCount = (m_secStyle == CPrincipal::RootSecStyle ? 5:8);

    TCHAR label[PERM_LABEL_SIZE] = {0};
    CPermission *permItem = NULL;

	for(int x = 0; x < permCount; x++)
	{
		UINT len = ::LoadString(_Module.GetModuleInstance(), 
								currRights[x].ID, label, PERM_LABEL_SIZE);
		if(len != 0)
		{
			permItem = new CPermission;
			if(permItem == NULL)
				return;
			permItem->m_permBit = currRights[x].permBit;

            SendMessage(hwndList, CLM_ADDITEM, (WPARAM)label, (LPARAM)permItem);
        }
    }
}

//----------------------------------------------------------------
HRESULT CRootSecurityPage::LoadSecurity(HWND hDlg)
{
    HRESULT hr = WBEM_E_NOT_AVAILABLE;  // bad IWbemServices ptr.
    HWND hPrinc = GetDlgItem(m_hDlg, IDC_SPP_PRINCIPALS);
    IWbemClassObject *inst = NULL;  // NTLMUser instance when enumerating.

    if((bool)m_WbemServices)
    {
        int iItem;
        bool fPageModified = false;

        if(m_secStyle == CPrincipal::NS_MethodStyle)  // M3
        {
            // call the method..
            CWbemClassObject _in;
            CWbemClassObject _out;

            hr = m_WbemServices.GetMethodSignatures("__SystemSecurity", "Get9XUserList",
                                                    _in, _out);

            if(SUCCEEDED(hr))
            {
                hr = m_WbemServices.ExecMethod("__SystemSecurity", "Get9XUserList",
                                                _in, _out);

                if(SUCCEEDED(hr))
                {
                    HRESULT hr1 = HRESULT_FROM_NT(_out.GetLong("ReturnValue"));
                    if(FAILED(hr1))
                    {
                        hr = hr1;
                        // and fall out.
                    }
                    else
                    {
                        _variant_t userList;
                        HRESULT hr3 = _out.Get("ul", userList);
                        if(SUCCEEDED(hr3))
                        {
                            hr3 = AddPrincipalsFromArray(hPrinc, userList);
                            if(SUCCEEDED(hr3))
                            {
                                fPageModified = true;
                            }
                            else if(hr3 == WBEM_E_NOT_FOUND)
                            {
                                // no principals-- disable the checklist.
                                EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), FALSE);
                                EnableWindow(GetDlgItem(hDlg, IDC_SPP_REMOVE), FALSE);
                            }
                            else
                            {
                                hr = hr3;
                            }
                        }
                        else
                        {
                            hr = hr3;
                        }
                    }
                }
            }
        }
        else    //rootSecStyle  M1
        {
            IEnumWbemClassObject *users = NULL;
            ULONG uReturned = 0;

            // NOTE: m_WbemServices better be the root\security ns.
            hr = m_WbemServices.CreateInstanceEnum(L"__NTLMUser", 0, &users);

            if(SUCCEEDED(hr))
            {
                // walk __NTLMUser
                while((SUCCEEDED(hr = users->Next(-1, 1, &inst, &uReturned))) &&
                      (uReturned > 0))
                {
                    CWbemClassObject princ(inst);
                    fPageModified |= AddPrincipal(hPrinc, princ, CPrincipal::RootSecStyle, iItem);

                    // release our copy.
                    inst->Release();
                    inst = NULL;

                } //endwhile

                // cleanup
                users->Release();
            }

        } //endif m_secStyle

        int count = ListView_GetItemCount(hPrinc);
        // no principals-- disable the checklist.
        EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), (count != 0? TRUE: FALSE));
        EnableWindow(GetDlgItem(hDlg, IDC_SPP_REMOVE), (count != 0? TRUE: FALSE));

        if(fPageModified)
        {
            PropSheet_Changed(GetParent(hDlg), hDlg);
            ListView_SetItemState(hPrinc, iItem, LVIS_SELECTED, LVIS_SELECTED);
        }

    } //endif (bool)m_WbemServices

    return hr;
}

//--------------------------------------------------------------------------
HRESULT CRootSecurityPage::AddPrincipalsFromArray(HWND hPrinc, 
                                                  variant_t &vValue)
{
    IUnknown *pVoid = NULL;
    SAFEARRAY* sa;
    HRESULT hr = E_FAIL;

	// if got a BYTE array back....
	if((vValue.vt & VT_ARRAY) &&
		(vValue.vt & VT_UNKNOWN))
	{
		// get it out.
		sa = V_ARRAY(&vValue);

        long lLowerBound = 0, lUpperBound = 0 ;

        SafeArrayGetLBound(sa, 1, &lLowerBound);
        SafeArrayGetUBound(sa, 1, &lUpperBound);

        if(lUpperBound != -1)
        {
            int iItem;
            long ix[1];
            for(long x = lLowerBound; x <= lUpperBound; x++)
            {
                ix[0] = x;
                hr = SafeArrayGetElement(sa, ix, &pVoid);
                if(SUCCEEDED(hr))
                {
                    CWbemClassObject princ((IWbemClassObject *)pVoid);

                    //load principals.
                    iItem = x;
                    AddPrincipal(hPrinc, princ, CPrincipal::NS_MethodStyle, iItem);
                }
                else
                {
                    ATLASSERT(false);
                }
            }
            hr = S_OK;
        }
        else
        {
            hr = WBEM_E_NOT_FOUND;
        }
    }
    return hr;
}

//----------------------------------------------------------------
bool CRootSecurityPage::AddPrincipal(HWND hPrinc, 
                                    CWbemClassObject &princ,
                                    CPrincipal::SecurityStyle secStyle,
                                    int &iItem)
{
    bool fPageModified = false;
    CPrincipal *pPrincipal = NULL;
    int idx = - 1;
    bstr_t name;

    name = princ.GetString("Authority");
    name += _T("\\");
    name += princ.GetString("Name");
    
    // if methodStyle security, its possible to get more than 1 ace
    // per user so see if the principal already exists.
    // NOTE: Otherwise the idx = -1 will force into the "new principal" code.
    if(secStyle == CPrincipal::NS_MethodStyle)
    {
        LVFINDINFO findInfo;
        findInfo.flags = LVFI_STRING;
        findInfo.psz = (LPCTSTR)name;

        idx = ListView_FindItem(hPrinc, -1, &findInfo);
    }

    // if not already there...
    if(idx == -1)
    {
    // addref when CPrincipal takes a copy.
        pPrincipal = new CPrincipal(princ, secStyle);

        LV_ITEM lvItem;
        // initialize the variable parts.
        lvItem.mask = LVIF_TEXT | LVIF_PARAM|LVIF_IMAGE;
        lvItem.iItem = iItem;
        lvItem.iSubItem = 0;
        lvItem.pszText = CloneString(name);
        if (lvItem.pszText)
        {
            lvItem.cchTextMax = _tcslen(lvItem.pszText);
            lvItem.iImage = pPrincipal->GetImageIndex();
            lvItem.lParam = (LPARAM)pPrincipal;
            lvItem.iIndent = 0;

            // Insert principal into list.
            if((iItem = ListView_InsertItem(hPrinc, &lvItem)) != -1)
            {
                ATLTRACE(_T("ListView_InsertItem %d\n"), iItem);
                fPageModified = TRUE;
            }
        }

        if (!fPageModified) // it failed
        {
            delete pPrincipal;
            pPrincipal = NULL;
        }
    }
    else  // add it to the existing principal.
    {
        // get the existing principal instance.
        LVITEM item;
        item.mask = LVIF_PARAM;
        item.iItem = idx;
        item.iSubItem = 0;
        item.lParam = NULL;
        ListView_GetItem(hPrinc, &item);
        
        ATLTRACE(_T("extra ace\n"));

        pPrincipal = (CPrincipal *)item.lParam;

        // add the new ace to the existing principal.
        if(pPrincipal != NULL)
        {
            pPrincipal->AddAce(princ);
        } //endif pPrincipal
    }

    return fPageModified;
}

//----------------------------------------------------------------
void CRootSecurityPage::OnApply(HWND hDlg, bool bClose)
{
    CPrincipal *pPrincipal = NULL;
    
    VARIANT userList;
    SAFEARRAYBOUND rgsabound[1];
    SAFEARRAY *psa;

    CommitCurrent(hDlg);

    HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);

    int count = ListView_GetItemCount(hwndList);
    LVITEM item;
    item.mask = LVIF_PARAM;

    // M3-9x will need an object array. Get ready.
    if(m_secStyle == CPrincipal::NS_MethodStyle)
    {
        VariantInit(&userList);
        rgsabound[0].lLbound = 0;
        rgsabound[0].cElements = count;
        psa = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);    
    }

    // all principal, put their bits back into their instance.
    for(long i = 0; i < count; i++)
    {
        item.iItem = i;
        item.iSubItem = 0;
        item.lParam = NULL;
        ListView_GetItem(hwndList, &item);

        pPrincipal = (CPrincipal *)item.lParam;

        if(pPrincipal != NULL)
        {
            CWbemClassObject userInst;
            if(SUCCEEDED(pPrincipal->Put(m_WbemServices, userInst)))
            {
                // for M3-9x, also add it to an array of objects.
                if(m_secStyle == CPrincipal::NS_MethodStyle)
                {
                    VARIANT v;
                    VariantInit(&v);

                    v.vt = VT_UNKNOWN;
                    IWbemClassObject *pCO = userInst;
                    v.punkVal = pCO;

                    SafeArrayPutElement(psa, &i, pCO);
                }

            } //SUCCEEDED()

        } //endif pPrincipal

    } //endfor

    // M3-9x also needs an execMethod.
    if(m_secStyle == CPrincipal::NS_MethodStyle)
    {
        CWbemClassObject _in;
        CWbemClassObject _out;

        V_VT(&userList) = VT_UNKNOWN | VT_ARRAY; 
        V_ARRAY(&userList) = psa;

        HRESULT hr = m_WbemServices.GetMethodSignatures("__SystemSecurity", "Set9XUserList",
                                                        _in, _out);

        if(SUCCEEDED(hr))
        {
            hr = _in.Put("ul", userList);
            
            hr = m_WbemServices.ExecMethod("__SystemSecurity", "Set9XUserList",
                                            _in, _out);
            if(SUCCEEDED(hr))
            {
                HRESULT hr1 = HRESULT_FROM_NT(_out.GetLong("ReturnValue"));
                if(FAILED(hr1))
                {
                    hr = hr1;
                }
            }

            VariantClear(&userList);
        }
        // HACK: because of how the core caches/uses security, I have to close &
        // reopen my connection because GetSecurity() will be immediately called
        // to refresh the UI. If I dont do this, GetSecurity() will return to old
        // security settings even though they're really saved. 
        m_WbemServices.DisconnectServer();
        m_WbemServices.ConnectServer(m_path);
    } //endif NS_MethodStyle
}

//------------------------------------------------------------------------
HRESULT CRootSecurityPage::ParseLogon(CHString1 &domUser,
                                      CHString1 &domain,
                                      CHString1 &user)
{

    int slashPos = -1;
    int len = domUser.GetLength();

    for(int x = 0; x < len; x++)
    {
        if(domUser[x] == _T('\\'))
        {
            slashPos = x;
            break;
        }
    }


	// no slash??
	if(slashPos == -1)
	{
//		domain = _T('.');
		domain = _T(".");
		user = domUser;
	}
	else if(slashPos == 0)  // leading slash...
	{
//		domain = _T('.');
		domain = _T(".");
		TCHAR *strTemp = (LPTSTR)(LPCTSTR)domUser;
		strTemp++;
		user = strTemp;
//		user = domUser[1];
	}
	else   //    domain\user
	{
		TCHAR buf[256] = {0}, buf2[256] = {0};
		domain = _tcsncpy(buf, domUser, slashPos);
		_tcscpy(buf, domUser);
		user = _tcscpy(buf2, &buf[slashPos+1]);
	}
    return S_OK;
}

//------------------------------------------------------------------------
void CRootSecurityPage::OnAddPrincipal(HWND hDlg)
{
    CHString1 domUser, domain, user;

    // Commit any outstanding bit changes.
    CommitCurrent(hDlg);

    // put up the user picker.
    if(GetUser(hDlg, domUser))
    {
        CWbemClassObject inst;
        HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);

        ParseLogon(domUser, domain, user);

        // build default ace for the new guy.
        if(m_secStyle == CPrincipal::RootSecStyle)
        {
            inst = m_WbemServices.CreateInstance("__NTLMUser");
            inst.Put("Name", (bstr_t)user);
            inst.Put("Authority", (bstr_t)domain);
            inst.Put("EditSecurity", false);
            inst.Put("Enabled", true);
            inst.Put("ExecuteMethods", false);
            inst.Put("Permissions", (long)0);
        }
        else
        {
            inst = m_WbemServices.CreateInstance("__NTLMUser9x");
            inst.Put("Name", (bstr_t)user);
            inst.Put("Authority", (bstr_t)domain);
            inst.Put("Flags", (long)CONTAINER_INHERIT_ACE);
            inst.Put("Mask", (long)0);
            inst.Put("Type", (long)ACCESS_ALLOWED_ACE_TYPE);
        } //endif m_secStyle

        int iItem;
        if(AddPrincipal(hwndList, inst, m_secStyle, iItem))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), TRUE);

            // Tell the property sheet that we've changed.
            PropSheet_Changed(GetParent(hDlg), hDlg);
        }

        // if SOMETHING happened...
        if(iItem != -1)
        {
            // Select the already existing principal, or the last one inserted.
            ListView_SetItemState(hwndList, iItem, LVIS_SELECTED, LVIS_SELECTED);
            // NOTE: this should cause OnSelect() to be called to populate the 
            // Permissions list.
        }

        int cItems = ListView_GetItemCount(hwndList);
        // no principals-- disable the checklist.
        EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), (cItems != 0? TRUE: FALSE));
        EnableWindow(GetDlgItem(hDlg, IDC_SPP_REMOVE), (cItems != 0? TRUE: FALSE));
    }
}

//------------------------------------------------------------------------
bool CRootSecurityPage::GetUser(HWND hDlg, CHString1 &user)
{
    TCHAR userName[100] = {0};
    bool retval = false;
    if(DisplayEditDlg(hDlg, IDS_USERPICKER_TITLE, IDS_USERPICKER_MSG,
                        userName, 100) == IDOK)
    {
        user = CHString1(userName);
        retval = true;
    }
    return retval;
}

//------------------------------------------------------------------------
void CRootSecurityPage::OnRemovePrincipal(HWND hDlg)
{
    HWND hwndList;
    int iIndex;
    CPrincipal *pPrincipal;
    bool doit = false;

    hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    pPrincipal = GetSelectedPrincipal(hDlg, &iIndex);

    if(pPrincipal != NULL)
    {
        if(m_secStyle == CPrincipal::RootSecStyle)
        {
            CHString1 caption, msg;
            caption.LoadString(IDS_SHORT_NAME);
            msg.Format(MAKEINTRESOURCE(IDS_REMOVE_USER_FMT), pPrincipal->m_domain, pPrincipal->m_name);

            if(::MessageBox(hDlg, msg, caption,
                            MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION) == IDYES)
            {
                pPrincipal->DeleteSelf(m_WbemServices);
                doit = true;
            }
        }
        else // MethodStyle can delete as expected.
        {
            doit = true;
        }// endif m_secStyle

        if(doit)
        {
            ListView_DeleteItem(hwndList, iIndex);
            // NOTE: LVN_DELETEITEM will cleanup the CPrincipal.

            // If we just removed the only item, move the focus to the Add button
            // (the Remove button will be disabled in LoadPermissionList).
            int cItems = ListView_GetItemCount(hwndList);
            if(cItems == 0)
            {
                SetFocus(GetDlgItem(hDlg, IDC_SPP_ADD));
            }
            else
            {
                // If we deleted the last one, select the previous one
                if(cItems <= iIndex)
                    --iIndex;

                ListView_SetItemState(hwndList, iIndex, LVIS_SELECTED, LVIS_SELECTED);
            }

            // no principals-- disable the checklist.
            EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), (cItems != 0? TRUE: FALSE));
            EnableWindow(GetDlgItem(hDlg, IDC_SPP_REMOVE), (cItems != 0? TRUE: FALSE));

            PropSheet_Changed(GetParent(hDlg), hDlg);

        } //endif doit      

    } // endif pPrincipal != NULL
}

//---------------------------------------------------------------------------------
#define IDN_CHECKSELECTION 1  // this seems wierd.

BOOL CRootSecurityPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        m_chkList.Attach(hDlg, IDC_SPP_PERMS);
        InitDlg(hDlg);
        break;

    case WM_NOTIFY:
        OnNotify(hDlg, wParam, (LPNMHDR)lParam);
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDC_SPP_ADD:
            if(HIWORD(wParam) == BN_CLICKED)
                OnAddPrincipal(m_hDlg);

            break;

        case IDC_SPP_REMOVE:
            if(HIWORD(wParam) == BN_CLICKED)
                OnRemovePrincipal(m_hDlg);

            break;

    //    case IDC_SPP_ADVANCED:
    //      if(HIWORD(wParam) == BN_CLICK)
    //            OnAdvanced(m_hDlg);
    //        break;

        case IDC_SPP_PRINCIPALS:
            if(HIWORD(wParam) == IDN_CHECKSELECTION)
            {
                // See if we have gotten a new selection. If not, then the
                // user must have clicked inside the listview but not on an item,
                // thus causing the listview to remove the selection. In that
                // case, disable the other controls.
                if(ListView_GetSelectedCount(GET_WM_COMMAND_HWND(wParam, lParam)) == 0)
                {
                    EnablePrincipalControls(m_hDlg, FALSE);
                }
            }
            break;

        default: return FALSE;  // Command not handled.
        }
        break;


    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)rootSecPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)rootSecPageHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CRootSecurityPage::OnNotify(HWND hDlg, WPARAM idCtrl, LPNMHDR pnmh)
{
    LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)pnmh;

    // Set default return value.
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

    switch (pnmh->code)
    {
    case LVN_ITEMCHANGED:
        if(pnmlv->uChanged & LVIF_STATE)
        {
            // item *gaining* selection
            if((pnmlv->uNewState & LVIS_SELECTED) &&
                !(pnmlv->uOldState & LVIS_SELECTED))
            {
                // set bits based on principal.
                OnSelChange(hDlg);
            }
            // item *losing* selection
            else if(!(pnmlv->uNewState & LVIS_SELECTED) &&
                     (pnmlv->uOldState & LVIS_SELECTED))
            {
                // put bits back into the principal.
                CommitCurrent(hDlg, pnmlv->iItem);

                // Post ourselves a message to check for a new selection later.
                // If we haven't gotten a new selection by the time we process
                // this message, then assume the user clicked inside the listview
                // but not on an item, thus causing the listview to remove the
                // selection.  In that case, disable the combobox & Remove button.
                //
                // Do this via WM_COMMAND rather than WM_NOTIFY so we don't
                // have to allocate/free a NMHDR structure.
                PostMessage(hDlg, WM_COMMAND,
                            GET_WM_COMMAND_MPS(pnmh->idFrom, 
                                                pnmh->hwndFrom, 
                                                IDN_CHECKSELECTION));
            }
        }
        break;

    case LVN_DELETEITEM:
        {
//          LPNMLISTVIEW pnmv = (LPNMLISTVIEW)pnmh;
//          int pIndex = pnmv->iItem;
//          CPrincipal *pPrincipal = GetSelectedPrincipal(hDlg, &pIndex);
//          delete pPrincipal;
        }
        break;

    case LVN_KEYDOWN:
        if(((LPNMLVKEYDOWN)pnmh)->wVKey == VK_DELETE)
        {
            OnRemovePrincipal(hDlg);
        }
        break;

    case CLN_CLICK:
        if(pnmh->idFrom == IDC_SPP_PERMS)
        {
            // ASSUMPTION: You wont see and disable change from this msg.
            PNM_CHECKLIST pnmc = (PNM_CHECKLIST)pnmh;
            CPermission *perm = (CPermission *)pnmc->dwItemData;
            int pIndex = pnmc->iItem;
            HWND hwndList = pnmc->hdr.hwndFrom;
            //HWND hPrinc = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
            DWORD_PTR workingState = pnmc->dwState;

            // get the current principal.
            int cPrinc = -1;
            CPrincipal *pPrincipal = GetSelectedPrincipal(hDlg, &cPrinc);

			if(pPrincipal == NULL)
				break;

			HandleCheckList(hwndList, pPrincipal, perm, pnmc->iItem, &workingState);

            // if FULL_WRITE turned enabled & ON...
            // NOTE: if its DISABLED & ON, it must have been ENABLED & on before therefore
            // the partials would already be ENABLED & ON.
            if((perm->m_permBit == ACL_FULL_WRITE) &&
                (workingState == CLST_CHECKED))
            {
                CBL_SetState(hwndList, PARTIAL_WRITE_IDX, ALLOW_COL, CLST_CHECKED);
                CBL_SetState(hwndList, PROVIDER_WRITE_IDX, ALLOW_COL, CLST_CHECKED);
            }
            else if((perm->m_permBit == ACL_PARTIAL_WRITE) ||
                    (perm->m_permBit == ACL_PROVIDER_WRITE))
            {
                // partials turned DISABLED & ON but FULL_WRITE inherits...
                if((workingState == CLST_CHECKDISABLED) &&
                   (IS_BITSET(pPrincipal->m_inheritedPerms, ACL_FULL_WRITE)))
                {
                    // turn FULL_WRITE DISABLED & ON.
                    CBL_SetState(hwndList, FULL_WRITE_IDX, ALLOW_COL, CLST_CHECKDISABLED);
                }
                // if (ENABLED & OFF) or (DISABLED & ON without FULL_WRITE inherited)...
                else if(workingState != CLST_CHECKED)
                {
                    // turn off FULL_WRITE.
                    CBL_SetState(hwndList, FULL_WRITE_IDX, ALLOW_COL, CLST_UNCHECKED);
                }
            }

            PropSheet_Changed(GetParent(hDlg), hDlg);
        }
        break;

    case PSN_HELP:
        HTMLHelper(hDlg);
        break;

    case PSN_APPLY:
        OnApply(hDlg, (((LPPSHNOTIFY)pnmh)->lParam == 1));
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
void CRootSecurityPage::HandleCheckList(HWND hwndList,
                                        CPrincipal *pPrincipal,
                                        CPermission *perm,
                                        int iItem, DWORD_PTR *dwState)
{

    // was ENABLED & ON, now turning OFF.
    if(*dwState == CLST_UNCHECKED)
    {
        // is there a inherited perm to shine through?
        if(IS_BITSET(pPrincipal->m_inheritedPerms, perm->m_permBit))
        {
            // yup, DISABLE & ON the checkbox.
            CBL_SetState(hwndList, iItem, ALLOW_COL, CLST_CHECKDISABLED);
            *dwState = CLST_CHECKDISABLED;
        }
        // else nothing extra to do.
    }
    // was DISABLED & ON, now turning OFF
    else if(*dwState == CLST_DISABLED)
    {
        // ENABLE & ON the checkbox.
        CBL_SetState(hwndList, iItem, ALLOW_COL, CLST_CHECKED);
        *dwState = CLST_CHECKED;
    }
}

//-----------------------------------------------------------------------------
void CRootSecurityPage::OnSelChange(HWND hDlg)
{
    BOOL bDisabled = FALSE; ///m_siObjectInfo.dwFlags & SI_READONLY;

    // If the principal list is empty or there is no selection, then we need
    // to disable all of the controls that operate on items in the listbox.

    // Get the selected principal.
    CPrincipal *pPrincipal = GetSelectedPrincipal(hDlg, NULL);

    if(pPrincipal)
    {
        HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PERMS);
        // set it into the checklist.
        pPrincipal->LoadChecklist(hwndList, m_OSType);

        // Enable/disable the other controls.
        if(!bDisabled)
        {
            EnablePrincipalControls(hDlg, pPrincipal != NULL);
        }
    }

}

//-----------------------------------------------------------------------------
void CRootSecurityPage::CommitCurrent(HWND hDlg, int iPrincipal /* = -1 */)
{
    HWND hwndPrincipalList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    HWND hwndPermList = GetDlgItem(hDlg, IDC_SPP_PERMS);

    // If an index isn't provided, get the index of the currently
    // selected principal.
    if(iPrincipal == -1)
    {
        iPrincipal = ListView_GetNextItem(hwndPrincipalList, 
                                            -1, LVNI_SELECTED);
    }

    // if a principal is selected...
    if(iPrincipal != -1)
    {
        // Get the Principal from the selection.
        LV_ITEM lvItem;
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iPrincipal;
        lvItem.iSubItem = 0;
        lvItem.lParam = 0;

        ListView_GetItem(hwndPrincipalList, &lvItem);
        CPrincipal *pPrincipal = (CPrincipal *)lvItem.lParam;

        if(pPrincipal != NULL)
        {
            // store the bit settings into the principal.
            pPrincipal->SaveChecklist(hwndPermList, m_OSType);

        } //end pPrincipal != NULL
    }
}

//-----------------------------------------------------------------------------
void CRootSecurityPage::EnablePrincipalControls(HWND hDlg, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), fEnable);

    if(!fEnable)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_SPP_MORE_MSG), SW_HIDE);
    }
    EnableWindow(GetDlgItem(hDlg, IDC_SPP_REMOVE), fEnable);
}

//-----------------------------------------------------------------------------
CPrincipal *CRootSecurityPage::GetSelectedPrincipal(HWND hDlg, int *pIndex)
{
    HWND hListView = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);

    int iSelected = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);

     if (iSelected == -1)
        return NULL;

    if (pIndex)
        *pIndex = iSelected;

    LV_ITEM lvi;

    lvi.mask     = LVIF_PARAM;
    lvi.iItem    = iSelected;
    lvi.iSubItem = 0;
    lvi.lParam   = NULL;

    BOOL x = ListView_GetItem(hListView, &lvi);

    return (CPrincipal *)lvi.lParam;
}

//-------------------------------------------------------------------------------------
HIMAGELIST CRootSecurityPage::LoadImageList(HINSTANCE hInstance, LPCTSTR pszBitmapID)
{
    HIMAGELIST himl = NULL;
    HBITMAP hbm = LoadBitmap(hInstance, pszBitmapID);

    if (hbm != NULL)
    {
        BITMAP bm;
        GetObject(hbm, sizeof(bm), &bm);

        himl = ImageList_Create(bm.bmHeight,    // height == width
                                bm.bmHeight,
                                ILC_COLOR | ILC_MASK,
                                bm.bmWidth / bm.bmHeight,
                                0);  // don't need to grow
        if (himl != NULL)
            ImageList_AddMasked(himl, hbm, CLR_DEFAULT);

        DeleteObject(hbm);
    }

    return himl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\shlwapi2.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation

#include "precomp.h"
#include "shlwapi2.h"
#include <platform.h>

//---------------------------------------------------------
#ifdef UNICODE
//***   FAST_CharNext -- fast CharNext for path operations
// DESCRIPTION
//  when we're just stepping thru chars in a path, a simple '++' is fine.
#define FAST_CharNext(p)    (DBNotNULL(p) + 1)

#ifdef DEBUG
LPWSTR WINAPI DBNotNULL(LPCWSTR lpszCurrent)
{
    ATLASSERT(*lpszCurrent);
    return (LPWSTR) lpszCurrent;
}
#else
#define DBNotNULL(p)    (p)
#endif

#else
#define FAST_CharNext(p)    CharNext(p)
#endif

//---------------------------------------------------------
LPTSTR PathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT = pPath;
    
    if(pPath)
    {
        for( ; *pPath; pPath = FAST_CharNext(pPath))
        {
            if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':') || pPath[0] == TEXT('/'))
                && pPath[1] &&  pPath[1] != TEXT('\\')  &&   pPath[1] != TEXT('/'))
                pT = pPath + 1;
        }
    }

    return (LPTSTR)pT;   // const -> non const
}

//---------------------------------------------------------
#ifndef UNICODE
// light weight logic for charprev that is not painful for sbcs
BOOL IsTrailByte(LPCTSTR pszSt, LPCTSTR pszCur)
{
    LPCTSTR psz = pszCur;
    // if the given pointer is at the top of string, at least it's not a trail
    // byte.
    //
    if (psz <= pszSt) return FALSE;

    while (psz > pszSt)
    {
        psz--;
        if (!IsDBCSLeadByte(*psz))
        {
            // This is either a trail byte of double byte char
            // or a single byte character we've first seen.
            // Thus, the next pointer must be at either of a leadbyte
            // or pszCur itself.
            psz++;
            break;
        }
    }
    // Now psz can point to:
    //     1) a leadbyte of double byte character.
    //     2) pszSt
    //     3) pszCur
    //
    // if psz == pszSt, psz should point to a valid double byte char.
    //                  because we didn't hit the above if statement.
    //
    // if psz == pszCur, the *(pszCur-1) was non lead byte so pszCur can't
    //                   be a trail byte.
    //
    // Thus, we can see pszCur as trail byte pointer if the distance from
    // psz is not DBCS boundary that is 2.
    //
    return (BOOL) ((pszCur-psz) & 1);
}
#endif

//----------------------------------------------------------------------
#define LEN_MID_ELLIPSES        4
#define LEN_END_ELLIPSES        3
#define MIN_CCHMAX              LEN_MID_ELLIPSES + LEN_END_ELLIPSES

// PathCompactPathEx
// Output:
//          "."
//          ".."
//          "..."
//          "...\"
//          "...\."
//          "...\.."
//          "...\..."
//          "...\Truncated filename..."
//          "...\whole filename"
//          "Truncated path\...\whole filename"
//          "Whole path\whole filename"
// The '/' might be used instead of a '\' if the original string used it
// If there is no path, but only a file name that does not fit, the output is:
//          "truncated filename..."

BOOL PathCompactPathEx(LPTSTR  pszOut,
						LPCTSTR pszSrc,
						UINT    cchMax,
						DWORD   dwFlags)
{
    if(pszSrc)
    {
        TCHAR * pszFileName, *pszWalk;
        UINT uiFNLen = 0;
        int cchToCopy = 0, n;
        TCHAR chSlash = TEXT('0');

        ZeroMemory(pszOut, cchMax * sizeof(TCHAR));

        if((UINT)lstrlen(pszSrc)+1 < cchMax)
        {
            lstrcpy(pszOut, pszSrc);
            ATLASSERT(pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Determine what we use as a slash - a / or a \ (default \)
        pszWalk = (TCHAR*)pszSrc;
        chSlash = TEXT('\\');
        // Scan the entire string as we want the path separator closest to the end
        // eg. "file://\\Themesrv\desktop\desktop.htm"
        while(*pszWalk)
        {
            if((*pszWalk == TEXT('/')) || (*pszWalk == TEXT('\\')))
                chSlash = *pszWalk;

            pszWalk = FAST_CharNext(pszWalk);
        }

        pszFileName = PathFindFileName(pszSrc);
        uiFNLen = lstrlen(pszFileName);

        // if the whole string is a file name
        if(pszFileName == pszSrc && cchMax > LEN_END_ELLIPSES)
        {
            lstrcpyn(pszOut, pszSrc, cchMax - LEN_END_ELLIPSES);
#ifndef UNICODE
            if(IsTrailByte(pszSrc, pszSrc+cchMax-LEN_END_ELLIPSES))
                *(pszOut+cchMax-LEN_END_ELLIPSES-1) = TEXT('\0');
#endif
            lstrcat(pszOut, TEXT("..."));
            ATLASSERT(pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Handle all the cases where we just use ellipses ie '.' to '.../...'
        if((cchMax < MIN_CCHMAX))
        {
            for(n = 0; n < (int)cchMax-1; n++)
            {
                if((n+1) == LEN_MID_ELLIPSES)
                    pszOut[n] = chSlash;
                else
                    pszOut[n] = TEXT('.');
            }
            ATLASSERT(0==cchMax || pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Ok, how much of the path can we copy ? Buffer - (Lenght of MID_ELLIPSES + Len_Filename)
        cchToCopy = cchMax - (LEN_MID_ELLIPSES + uiFNLen);
        if (cchToCopy < 0)
            cchToCopy = 0;
#ifndef UNICODE
        if (cchToCopy > 0 && IsTrailByte(pszSrc, pszSrc+cchToCopy))
            cchToCopy--;
#endif

        lstrcpyn(pszOut, pszSrc, cchToCopy);

        // Now throw in the ".../" or "...\"
        lstrcat(pszOut, TEXT(".../"));
        pszOut[lstrlen(pszOut) - 1] = chSlash;

        //Finally the filename and ellipses if necessary
        if(cchMax > (LEN_MID_ELLIPSES + uiFNLen))
        {
            lstrcat(pszOut, pszFileName);
        }
        else
        {
            cchToCopy = cchMax - LEN_MID_ELLIPSES - LEN_END_ELLIPSES;
#ifndef UNICODE
            if(cchToCopy >0 && IsTrailByte(pszFileName, pszFileName+cchToCopy))
                cchToCopy--;
#endif
            lstrcpyn(pszOut + LEN_MID_ELLIPSES, pszFileName, cchToCopy);
            lstrcat(pszOut, TEXT("..."));
        }
        ATLASSERT(pszOut[cchMax-1] == TEXT('\0'));
        return TRUE;
    }
    return FALSE;
}

//----------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path.
//
// TRUE
//      "\\foo\bar"
//      "\\foo"         <- careful
//      "\\"
// FALSE
//      "\foo"
//      "foo"
//      "c:\foo"
//
//
bool PathIsUNC(LPCTSTR pszPath)
{
    if(pszPath)
    {
	    return ((pszPath[0] == _T('\\')) && (pszPath[1] == _T('\\')));
    }
    return false;
}

// add a backslash to a qualified path
//
// in:
//  lpszPath    path (A:, C:\foo, etc)
//
// out:
//  lpszPath    A:\, C:\foo\    ;
//
// returns:
//  pointer to the NULL that terminates the path
//
//----------------------------------------------------------------------
LPTSTR PathAddBackslash(LPTSTR lpszPath)
{

    if(lpszPath)
    {
        LPTSTR lpszEnd;

        // perf: avoid lstrlen call for guys who pass in ptr to end
        // of buffer (or rather, EOB - 1).
        // note that such callers need to check for overflow themselves.
        int ichPath = (*lpszPath && !*(lpszPath + 1)) ? 1 : lstrlen(lpszPath);

        // try to keep us from tromping over MAX_PATH in size.
        // if we find these cases, return NULL.  Note: We need to
        // check those places that call us to handle their GP fault
        // if they try to use the NULL!
        if(ichPath >= (_MAX_PATH - 1))
        {
            return(NULL);
        }

        lpszEnd = lpszPath + ichPath;

        // this is really an error, caller shouldn't pass
        // an empty string
        if(!*lpszPath)
            return lpszEnd;

        // Get the end of the source directory
        switch(*CharPrev(lpszPath, lpszEnd))
        {
            case _T(FILENAME_SEPARATOR):
                break;

            default:
                *lpszEnd++ = _T(FILENAME_SEPARATOR);
                *lpszEnd = _T('\0');
        }

        return lpszEnd;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\simplearray.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#if (_ATL_VER < 0x0300)
/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

#ifndef __SIMPLEARRAY__
#define __SIMPLEARRAY__

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aT[nIndex] = t;
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};
#endif __SIMPLEARRAY__

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\resource.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WmiCntl.rc
//
#define IDC_ADV_RECOVERY_ICON           40
#define IDC_ADV_NOW_TEXT                41
#define IDC_ADV_RECOVERY_ICON2          42
#define IDC_ADV_NOW_TEXT2               42
#define IDC_ADV_NOW_TEXT3               43
#define IDI_WMICNTL                     44
#define IDC_RESTORE_BTN                 50
#define IDC_BACKUP_BTN                  51
#define IDC_BACKUP_BTN2                 53
#define IDC_RESTORE_BTN2                54
#define IDC_RESTORE_FM_AUTO             54
#define IDS_CONNECTING                  55
#define IDS_PROJNAME                    56
#define IDB_WMISNAPIN_16                57
#define IDB_WMISNAPIN_32                58
#define IDS_WMISNAPIN_DESC              59
#define IDS_WMISNAPIN_PROVIDER          60
#define IDS_WMISNAPIN_VERSION           61
#define IDR_WMISNAPIN                   62
#define IDS_SNAPIN_TYPE                 63
#define IDS_DESCRIPTION                 64
#define IDD_ABOUTBOX                    100
#define IDD_ANIMATE                     101
#define IDC_ANIMATE                     102
#define IDC_MYICON                      103
#define IDR_MENU_MENU                   103
#define IDC_MSG                         104
#define IDR_AVIWAIT                     105
#define IDR_MAINFRAME                   128
#define IDD_MAINDLG                     129
#define IDS_UNAVAILABLE                 129
#define IDS_NOT_REMOTEABLE              130
#define IDS_LOCAL_CONN                  131
#define IDS_ERROR                       132
#define IDS_SHORT_NAME                  133
#define IDS_BAD_INTERVAL_FMT            134
#define IDS_BAD_INTERVAL                134
#define IDS_WBEM_GENERIC_ALL            135
#define IDS_WBEM_GENERIC_EXECUTE        136
#define IDS_WBEM_GENERIC_READ           137
#define IDS_WBEM_GENERIC_WRITE          138
#define IDS_WBEM_FULL_WRITE             139
#define IDS_WBEM_PARTIAL_WRITE          140
#define IDS_WBEM_PROVIDER_WRITE         141
#define IDS_NONE                        142
#define IDS_WBEM_SYSTEM_WRITE           142
#define IDS_DISPLAY_NAME                143
#define IDS_CANT_LOAD_SEC_DLLS          144
#define IDS_NO_ACLUI                    145
#define IDS_NO_CREATE_SEC               146
#define IDS_DEBUG                       147
#define IDS_OS_LABEL                    148
#define IDS_OS_VER_LABEL                149
#define IDS_CPU_LABEL                   150
#define IDS_WMI_VER_LABEL               151
#define IDS_CONNECTED_TO_LABEL          152
#define IDS_CONN_FAILED_FMT             153
#define IDS_BECAUSE_LABEL               154
#define IDS_WBEM_INSTANCE_WRITE         154
#define IDS_WBEM_CLASS_WRITE            155
#define IDS_WBEM_ENABLE                 156
#define IDS_WBEM_READONLY               157
#define IDS_WBEM_EDIT_SECURITY          158
#define IDS_WBEM_READ_SECURITY          159
#define IDS_WBEM_REMOTE_ENABLE          160
#define IDS_WBEM_NAMESPACE              161
#define IDS_WBEM_NAMESPACE_SUBNAMESPACE 162
#define IDS_WBEM_SUBNAMESPACE_ONLY      163
#define IDS_OS_SERVICE_PACK_LABEL		164
#define IDS_CANNOT_LOG_ON               165
#define IDD_GENERAL                     201
#define IDD_LOGGING                     202
#define IDD_ADVANCED                    203
#define IDD_ADVANCED_NT                 203
#define IDI_LOGGING                     204
#define IDB_LOGGING                     205
#define IDI_WAITING                     207
#define IDI_FAILED                      208
#define IDD_CONNECT                     209
#define IDD_EDITBOX                     211
#define IDD_USER_PICKER                 212
#define IDB_SID_ICONS                   213
#define IDI_CLSD_FOLDER                 214
#define IDI_EARTH                       215
#define IDI_CLSD_CLASS					216
#define IDI_CLSD_INSTANCE				217
#define IDI_CLSD_SCOPEINSTANCE			218
#define IDI_CLSD_SCOPECLASS				219
#define IDD_9XSEC                       250
#define IDC_SPP_PRINCIPALS              251
#define IDD_SEC_ERROR                   251
#define IDC_SPP_ADD                     252
#define IDD_BACKUP                      252
#define IDC_SPP_REMOVE                  253
#define IDC_SPP_RESET                   254
#define IDD_NAMESPACE                   254
#define IDC_SPP_ACCESS                  255
#define IDD_ADVANCED_9X                 255
#define IDC_SPP_ALLOW                   256
#define IDD_ADVANCED_EMPTY              256
#define IDC_SPP_DENY                    257
#define IDD_NS_PICKER                   257
#define IDC_SPP_PERMS                   258
#define IDC_SPP_ADVANCED                259
#define IDC_SPP_MORE_MSG                260
#define IDC_SPP_PROTECT                 262
#define IDC_SPP_NO_SECURITY             263
#define IDS_ERROR_UNKN_ERROR_FMT        264
#define IDS_ERROR_FMT                   265
#define IDS_WMI_INSTALL_DIR             266
#define IDS_NS_PROP_TITLE               267
#define IDS_MINUTES                     268
#define IDS_HOURS                       269
#define IDS_DAYS                        270
#define IDS_BACKUP_THREAT               271
#define IDS_BACKUP_TITLE                272
#define IDS_BACKUP_FMT                  273
#define IDS_RESTORE_TITLE               274
#define IDS_RESTORE_FMT                 275
#define IDS_OPEN_BACKUP                 276
#define IDS_OPEN_RESTORE                277
#define IDS_DIR_DOESNT_EXIST            278
#define IDS_NO_BACKUP_FILE              279
#define IDS_BACKUP_OVERWRITE            280
#define IDS_CANT_BROWSE_REMOTELY        281
#define IDS_OPTIONS_SMALL               282
#define IDS_OPTIONS_BIG                 283
#define IDS_IMP_DELEGATE                284
#define IDS_IMP_IDENTIFY                285
#define IDS_IMP_IMPERSONATE             286
#define IDS_AUTH_CALL                   287
#define IDS_AUTH_CONNECT                288
#define IDS_AUTH_NONE                   289
#define IDS_AUTH_PACKET                 290
#define IDS_AUTH_INTEGRITY              291
#define IDS_AUTH_PRIVACY                292
#define IDS_USERPICKER_TITLE            293
#define IDS_USERPICKER_MSG              294
#define IDS_NAME                        295
#define IDS_REMOVE_USER_FMT             296
#define IDS_CURRENT_USER                297
#define IDS_GEN_PARA_SNAPIN             298
#define IDS_USER_LABEL                  299
#define IDS_ADV_PARA_NT                 300
#define IDS_ADV_PARA_9X                 301
#define IDS_MULTI_INSTANCES             302
#define IDS_WAIT                        303
#define IDS_DIR_EMPTY                   304
#define IDS_SURE                        305
#define IDS_AUTORESTORE                 306
#define IDS_PARTIAL_DS_FAILURE          307
#define IDS_SEC_ERR_FMT                 308
#define IDS_OS_ERR_FMT                  309
#define IDS_CPU_ERR_FMT                 310
#define IDS_SETTING_ERR_FMT             311
#define IDS_NO_ERR                      312
#define IDS_NO_HHCTRL                   313
#define IDS_NO_HELP                     314
#define IDS_LOG_SELECT_FDR              315
#define IDS_LOCAL_COMPUTER              316
#define IDS_NO_UNC                      317
#define IDS_NO_DRIVE_LTR                318
#define IDS_DIRS_ONLY                   319
#define IDS_LOGS_WRONG_DRIVETYPE        320
#define ID_TOP_RECONNECT                321
#define IDS_BAD_LOGSIZE                 322
#define IDS_REC_FILTER                  323
#define IDS_USE_RADIO                   324
#define IDS_POST_RESTORE                325
#define IDS_STATUS_NOTSTARTED           326
#define IDS_STATUS_CANCELLED            327
#define IDS_NO_98TONT_SEC               328
#define IDS_ALL_FILTER                  329
#define IDS_NEED_EXISTING_DIR           330
#define IDS_NS_PARA                     331
#define ID_PERF_COUNTERS                332
#define IDD_WMICTR                      333
#define IDR_SEC_MENU                    334
#define IDC_ERROR_CAPTION               335
#define IDC_ERROR_CONNECT               336
#define IDC_ERROR_ENUM                  337
#define IDC_CONNECTIONS                 338
#define IDC_DELBACKUP                   339
#define IDC_INTERNALOBJS                340
#define IDC_INTERNALSINKS               341
#define IDC_TASKSINPROG                 342
#define IDC_TASKSWAITING                343
#define IDC_TOTALAPICALLS               344
#define IDC_USERS                       345
#define IDS_CONNECTIONS                 346
#define IDS_DELBACKUP                   347
#define IDS_INTERNALOBJS                348
#define IDS_INTERNALSINKS               349
#define IDS_TASKSINPROG                 350
#define IDS_TASKSWAITING                351
#define IDS_TOTALAPICALLS               352
#define IDS_USERS                       353
#define IDD_WMICTR_SYSMON	            354
#define IDC_SYSMON_OCX                  355
#define IDC_RETRY_TEXT					356
#define IDC_ENUM_STATIC					357
#define IDC_CANCEL_ENUM					358
#define IDC_BACKUPINTERVAL              1000
#define IDC_LASTBACKUP                  1001
#define IDC_DISABLELOGGING              1002
#define IDC_ERRORLOGGING                1003
#define IDC_VERBOSELOGGING              1004
#define IDC_MAXFILESIZE                 1005
#define IDC_LOGGINGDIRECTORY            1006
#define IDC_BROWSE                      1007
#define IDC_NORESTART                   1008
#define IDC_ESSRESTART                  1009
#define IDC_ALWAYSAUTORESTART           1010
#define IDC_CIMOMRESTART                1011
#define IDC_9X_ONLY                     1011
#define IDC_VERSION                     1012
#define IDC_COMBO1                      1013
#define IDC_MACHINES                    1013
#define IDC_BACKUP_UNITS                1013
#define IDC_CONNECT                     1014
#define IDC_CHANGE                      1014
#define IDC_ASP                         1015
#define IDC_OS                          1015
#define IDC_STATUS                      1016
#define IDC_STATUSICON                  1017
#define IDC_OS_LABEL                    1018
#define IDC_VERSION_LABEL               1019
#define IDC_STATUS_LABEL                1020
#define IDC_BACKUPINTERVAL_LABEL        1021
#define IDC_LASTBACKUP_LABEL            1022
#define IDC_MAXFILESIZE_LABEL           1023
#define IDC_LOGGINGDIRECTORY_LABEL      1024
#define IDC_STATUS_FRAME                1025
#define IDC_DEFNS                       1026
#define IDC_DEFNS_LABEL                 1027
#define IDC_SCRIPTING_FRAME             1028
#define IDC_OS_VERSION                  1029
#define IDC_LIST2                       1030
#define IDC_NO_SECURITY                 1031
#define IDC_OS_VERSION_LABEL            1032
#define IDC_MACHINE                     1033
#define IDC_RESTART_IIS                 1035
#define IDC_LOCAL                       1036
#define IDC_REMOTE                      1037
#define IDC_NAME                        1038
#define IDC_BACKUP_ENABLED              1039
#define IDC_NSTREE                      1040
#define IDC_PROPERTIES                  1041
#define IDC_9X_ANON_CONNECTION          1044
#define IDC_DB_DIR                      1045
#define IDC_DBDIRECTORY_LABEL           1049
#define IDC_SCRIPT_NS                   1051
#define IDC_CHANGE_SCRIPT_NS            1052
#define IDC_BUTTON1                     1054
#define IDC_LOGON                       1054
#define IDC_ASP_LABEL                   1056
#define IDC_EDIT                        1057
#define IDC_ACCOUNT                     1058
#define IDC_EDIT1                       1059
#define IDC_EDITUSERNAME                1060
#define IDC_COMP_LABEL                  1060
#define IDC_EDITPASSWORD                1061
#define IDC_GEN_PARA                    1061
#define IDC_CHECKCURRENTUSER            1062
#define IDC_ADV_PARA                    1062
#define IDD_LOGIN                       1063
#define IDC_SCRIPT_LABEL                1063
#define IDC_USER_LABEL                  1064
#define IDD_CONNECT_WIZ                 1064
#define IDC_PW_LABEL                    1065
#define IDC_CONN_FRAME                  1066
#define IDC_ACCOUNT_LABEL               1067
#define IDC_LOG_PARA                    1068
#define IDC_NS_PARA                     1069
#define IDC_AUTOMATIC_GROUPBOX			1070
#define IDC_MANUAL_GROUPBOX				1071

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        216
#define _APS_NEXT_COMMAND_VALUE         32773
#define _APS_NEXT_CONTROL_VALUE         1072
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\shlwapi2.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __SHLWAPI2__
#define __SHLWAPI2__


// NOTE: a much hated clone of shlwapi.dll routines.

	// from nt5inc\shlwapi.h.
	BOOL PathCompactPathEx(LPTSTR pszOut, LPCTSTR pszSrc,
							UINT cchMax, DWORD dwFlags = 0);

	bool PathIsUNC(LPCTSTR pszPath);
	LPTSTR PathAddBackslash(LPTSTR lpszPath);

	LPTSTR PathFindFileName(LPCTSTR pPath);
#ifndef UNICODE
	BOOL IsTrailByte(LPCTSTR pszSt, LPCTSTR pszCur);
#endif


#endif __SHLWAPI2__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\wbemerror.h ===
#ifndef __WBEMERROR__
#define __WBEMERROR__
//=============================================================================
//
//                              WbemError.h
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//	Implements string table based, error msgs for all of wbem.
//
//  History:
//
//      a-khint  5-mar-98       Created.
//
//============================================================================= 
#include "precomp.h"
#include "DeclSpec.h"

//---------------------------------------------------------
// ErrorString: Extracts convenient information out of the
//				SCODE (HRESULT). If its not a wbem error,
//				system error msgs will be checked.
// Parms:
//		sc - The error code from any facility.
//		errMsg - pointer to an allocated string buffer for
//					the error msg. Can be NULL.
//		errSize - the size of errMsg in chars.
//
//		facility - pointer to an allocated string buffer for
//					the facility name. Can be NULL.
//		facSize - the size of errMsg in chars.
//
//		sevIcon - ptr to receive the appropriate MB_ICON*
//					value for the sc. Can be NULL. Value
//					should be OR'ed with the MessageBox()
//					uType.
//---------------------------------------------------------
extern "C"
{

// formats the facility part for you too.
POLARITY bool ErrorStringEx(HRESULT hr, 
						   TCHAR *errMsg, UINT errSize,
						   UINT *sevIcon = NULL);

}
#endif __WBEMERROR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\stdafx.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include <precomp.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

LONG CExeModule::Unlock()
{
	LONG l = CComModule::Unlock();

#ifndef SNAPIN
	if (l == 0)
	{
#if _WIN32_WINNT >= 0x0400
		if (CoSuspendClassObjects() == S_OK)
			PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#else
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#endif
	}
#endif

	return l;
}

CExeModule _Module;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=wbemcntl
TARGETPATH=obj

TARGETLIBS= \
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
	$(ATLUICOMMON_LIB) \
	$(UTILLIB_LIB) \
	$(SDK_LIB_PATH)\htmlhelp.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\comctl32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\gdi32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\shell32.lib \
	$(SDK_LIB_PATH)\comdlg32.lib \
	$(SDK_LIB_PATH)\version.lib

INCLUDES=$(INCLUDES); \
	$(ATLUISNAPINS_INC); \
	$(STDLIBRARY_INC); \
	$(ATLUICOMMON_INC)

SOURCES= \
	..\WMICntl.idl \
	..\advPage.cpp \
	..\stdafx.cpp \
	..\BackupPage.cpp \
	..\chklist.cpp \
	..\ChkListHandler.cpp \
	..\DataSrc.cpp \
	..\ErrorSecPage.cpp \
	..\GenPage.cpp \
	..\LogPage.cpp \
	..\NSPage.cpp \
	..\pagebase.cpp \
	..\principal.cpp \
	..\RootSecPage.cpp \
	..\SI.cpp \
	..\UIHelpers.cpp \
	..\WbemError.cpp \
	..\WMICtrSysmonDlg.cpp \
	..\WmiCtrsDlg.cpp \
	..\AsyncObjectSink.cpp

# Next, specify options for the compiler using C_DEFINES.
C_DEFINES=$(C_DEFINES) /DSHARE_SOURCE
WIN32_WINNT_VERSION=0x0501
USE_RTTI=1
USE_NATIVE_EH=ASYNC
USE_VCCOM=1
USE_MSVCRT=1
USE_ATL=1
ATL_VER=30
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\si.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __SECURITYOBJECT__
#define __SECURITYOBJECT__

#include "precomp.h"
#include "..\common\SshWbemHelpers.h"
#include <wbemcli.h>
#include "aclui.h"
#include "DataSrc.h"

struct __declspec(uuid("965FC360-16FF-11d0-91CB-00AA00BBB723")) ISecurityInformation;

// This class just define the interface and creates the aclui tab.
class ATL_NO_VTABLE CSecurityInformation : public ISecurityInformation, 
											public CComObjectRoot
{
protected:
	virtual ~CSecurityInformation();

    DECLARE_NOT_AGGREGATABLE(CSecurityInformation)
    BEGIN_COM_MAP(CSecurityInformation)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

	// *** ISecurityInformation methods ***
	STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo) = 0;

	STDMETHOD(GetSecurity) (THIS_ SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) = 0;

	STDMETHOD(SetSecurity)(SECURITY_INFORMATION SecurityInformation,
						 PSECURITY_DESCRIPTOR pSecurityDescriptor) = 0;

	STDMETHOD(GetAccessRights)(const GUID  *pguidObjectType,
							  DWORD       dwFlags,
							  PSI_ACCESS  *ppAccess,
							  ULONG       *pcAccesses,
							  ULONG       *piDefaultAccess) = 0;

	STDMETHOD(MapGeneric)(const GUID  *pguidObjectType,
						  UCHAR       *pAceFlags,
						  ACCESS_MASK *pMask) = 0;

	STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE  *ppInheritTypes,
								ULONG *pcInheritTypes) = 0;

	STDMETHOD(PropertySheetPageCallback)(HWND hwnd, 
									  UINT uMsg, 
									  SI_PAGE_TYPE  uPage);

};


//==========================================================
// This class handles the security descriptors directly. (Nova M3 and later)
class CSDSecurity : public CComObject<CSecurityInformation>
{
public:
	CSDSecurity(struct NSNODE *nsNode,
						 _bstr_t server,
						 bool local);

	// *** ISecurityInformation methods ***
	STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);

    STDMETHOD(GetSecurity) (THIS_ SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );

	STDMETHOD(SetSecurity)(SECURITY_INFORMATION SecurityInformation,
						 PSECURITY_DESCRIPTOR pSecurityDescriptor);

	STDMETHOD(GetAccessRights)(const GUID  *pguidObjectType,
							  DWORD       dwFlags,
							  PSI_ACCESS  *ppAccess,
							  ULONG       *pcAccesses,
							  ULONG       *piDefaultAccess);

	STDMETHOD(MapGeneric)(const GUID  *pguidObjectType,
						  UCHAR       *pAceFlags,
						  ACCESS_MASK *pMask);

	STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE  *ppInheritTypes,
								ULONG *pcInheritTypes);

	HRESULT InitializeOwnerandGroup(PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
protected:
/*	CWbemServices m_WbemServices;
	_bstr_t m_path;					// for the reconnect trick.
	_bstr_t m_display;
*/	_bstr_t m_server;

	struct NSNODE *m_nsNode;
	bool m_local;
	LPWSTR CloneWideString(_bstr_t pszSrc);
	void ProtectACLs(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD);
	SID *m_pSidOwner;
	SID *m_pSidGroup;
	DWORD m_nLengthOwner;
	DWORD m_nLengthGroup;
	BOOL m_bOwnerDefaulted;
	BOOL m_bGroupDefaulted;
};


#endif __SECURITYOBJECT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\si.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include <winioctl.h>
#include "si.h"
#include "resource.h"
#include <cguid.h>
#include <stdio.h>

//-----------------------------------------------------------------------------
CSecurityInformation::~CSecurityInformation() 
{
}

#define HINST_THISDLL   _Module.GetModuleInstance()
//-----------------------------------------------------------------------------
HRESULT CSecurityInformation::PropertySheetPageCallback(HWND hwnd, 
												  UINT uMsg, 
												  SI_PAGE_TYPE uPage)
{
    return S_OK;
}


//======================================================================
//------------------- ISECURITYINFORMATION follows ---------------------------
//EXTERN_C const GUID IID_ISecurityInformation =
//	{ 0x965fc360, 0x16ff, 0x11d0, 0x91, 0xcb, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x23 };

#define WBEM_ENABLE             ( 0x0001 )   
#define WBEM_METHOD_EXECUTE     ( 0x0002 )   
#define WBEM_FULL_WRITE_REP     ( 0x001c )   
#define WBEM_PARTIAL_WRITE_REP  ( 0x0008 )   
#define WBEM_WRITE_PROVIDER     ( 0x0010 )   
#define WBEM_REMOTE_ENABLE      ( 0x0020 )   

#define WBEM_GENERAL_WRITE     (WBEM_FULL_WRITE_REP|WBEM_PARTIAL_WRITE_REP|WBEM_WRITE_PROVIDER)   

#define WBEM_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED  |\
							SYNCHRONIZE            |\
							WBEM_ENABLE            |\
							WBEM_METHOD_EXECUTE    |\
							WBEM_FULL_WRITE_REP    |\
							WBEM_PARTIAL_WRITE_REP |\
							WBEM_WRITE_PROVIDER)

#define WBEM_GENERIC_READ         (STANDARD_RIGHTS_READ     |\
                                   WBEM_ENABLE)


#define WBEM_GENERIC_WRITE        (STANDARD_RIGHTS_WRITE    |\
                                   WBEM_FULL_WRITE_REP      |\
                                   WBEM_PARTIAL_WRITE_REP   |\
                                   WBEM_WRITE_PROVIDER)


#define WBEM_GENERIC_EXECUTE      (STANDARD_RIGHTS_EXECUTE  |\
                                   WBEM_METHOD_EXECUTE)

// The following array defines the permission names for WMI.
SI_ACCESS siWMIAccesses[] = 
{
    { &GUID_NULL, WBEM_METHOD_EXECUTE,		MAKEINTRESOURCEW(IDS_WBEM_GENERIC_EXECUTE), SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, WBEM_FULL_WRITE_REP,		MAKEINTRESOURCEW(IDS_WBEM_FULL_WRITE),		SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, WBEM_PARTIAL_WRITE_REP,	MAKEINTRESOURCEW(IDS_WBEM_PARTIAL_WRITE),	SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, WBEM_WRITE_PROVIDER,		MAKEINTRESOURCEW(IDS_WBEM_PROVIDER_WRITE),  SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, WBEM_ENABLE,				MAKEINTRESOURCEW(IDS_WBEM_ENABLE),			SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, WBEM_REMOTE_ENABLE,		MAKEINTRESOURCEW(IDS_WBEM_REMOTE_ENABLE),	SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, READ_CONTROL,				MAKEINTRESOURCEW(IDS_WBEM_READ_SECURITY),   SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, WRITE_DAC,				MAKEINTRESOURCEW(IDS_WBEM_EDIT_SECURITY),   SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, 0,						MAKEINTRESOURCEW(IDS_NONE),                 0 }
};
#define iWMIDefAccess      4   // FILE_GENERAL_READ_EX

SI_ACCESS siWMIAccessesAdvanced[] = 
{
    { &GUID_NULL, WBEM_METHOD_EXECUTE,		MAKEINTRESOURCEW(IDS_WBEM_GENERIC_EXECUTE), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WBEM_FULL_WRITE_REP,		MAKEINTRESOURCEW(IDS_WBEM_FULL_WRITE),		SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WBEM_PARTIAL_WRITE_REP,	MAKEINTRESOURCEW(IDS_WBEM_PARTIAL_WRITE),	SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WBEM_WRITE_PROVIDER,		MAKEINTRESOURCEW(IDS_WBEM_PROVIDER_WRITE),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WBEM_ENABLE,				MAKEINTRESOURCEW(IDS_WBEM_ENABLE),			SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WBEM_REMOTE_ENABLE,		MAKEINTRESOURCEW(IDS_WBEM_REMOTE_ENABLE),	SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,				MAKEINTRESOURCEW(IDS_WBEM_READ_SECURITY),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,				MAKEINTRESOURCEW(IDS_WBEM_EDIT_SECURITY),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,						MAKEINTRESOURCEW(IDS_NONE),                 0 }
};
#define iWMIDefAccessAdvanced      4   // FILE_GENERAL_READ_EX

SI_INHERIT_TYPE siWMIInheritTypes[] =
{
    &GUID_NULL, 0,                                        MAKEINTRESOURCEW(IDS_WBEM_NAMESPACE),
    &GUID_NULL, CONTAINER_INHERIT_ACE,                    MAKEINTRESOURCEW(IDS_WBEM_NAMESPACE_SUBNAMESPACE),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE, MAKEINTRESOURCEW(IDS_WBEM_SUBNAMESPACE_ONLY),
};

GENERIC_MAPPING WMIMap =
{
    WBEM_GENERIC_READ,
    WBEM_GENERIC_WRITE,
    WBEM_GENERIC_EXECUTE,
    WBEM_ALL_ACCESS
};


//---------------------------------------------------------------
CSDSecurity::CSDSecurity(struct NSNODE *nsNode,
						 _bstr_t server,
						 bool local)
									  : m_nsNode(nsNode),
									    m_server(server),
										m_local(local),
										m_pSidOwner(NULL),
										m_pSidGroup(NULL)
{
}

//------------------ Accessors to the above arrays---------------
//---------------------------------------------------------------
HRESULT CSDSecurity::MapGeneric(const GUID *pguidObjectType,
								  UCHAR *pAceFlags,
								  ACCESS_MASK *pMask)
{
    *pAceFlags &= ~OBJECT_INHERIT_ACE;
    MapGenericMask(pMask, &WMIMap);

	return S_OK;
}

//-----------------------------------------------------------------------------
HRESULT CSDSecurity::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
										ULONG *pcInheritTypes)
{
    *ppInheritTypes = siWMIInheritTypes;
    *pcInheritTypes = ARRAYSIZE(siWMIInheritTypes);

	return S_OK;
}

//---------------------------------------------------
LPWSTR CSDSecurity::CloneWideString(_bstr_t pszSrc ) 
{
    LPWSTR pszDst = NULL;

    pszDst = new WCHAR[(lstrlen(pszSrc) + 1)];
    if (pszDst) 
	{
        wcscpy( pszDst, pszSrc );
    }

    return pszDst;
}


//-----------------------------------------------------------------------------
HRESULT CSDSecurity::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
//    ATLASSERT(pObjectInfo != NULL &&
//             !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo)));

	pObjectInfo->dwFlags = SI_EDIT_PERMS | /*SI_EDIT_OWNER |*/	// dacl, owner pages.
							SI_ADVANCED | SI_CONTAINER | 
							SI_NO_TREE_APPLY | SI_NO_ACL_PROTECT;

	USES_CONVERSION;

	// NOTE: This weirdness is so nt4sp5+ can put up the 
	//    user browser for Add User.
	if(m_local)
	{
		pObjectInfo->pszServerName = NULL;
	}
	else
	{
		// NOTE: NT4 seems to want the "\\" and w2k doesn't care.
		bstr_t temp(_T("\\\\"));
		temp += m_server;
		pObjectInfo->pszServerName = CloneWideString(temp);
	}
    pObjectInfo->hInstance = HINST_THISDLL;
    pObjectInfo->pszObjectName = CloneWideString(m_nsNode->display);

    return S_OK;
}

//-----------------------------------------------------------------------------

HRESULT CSDSecurity::GetAccessRights(const GUID *pguidObjectType,
									  DWORD dwFlags,
									  PSI_ACCESS *ppAccess,
									  ULONG *pcAccesses,
									  ULONG *piDefaultAccess)
{
	// dwFlags is zero if the basic security page is being initialized,
	// Otherwise, it is a combination of the following values:
	//    SI_ADVANCED  - Advanced sheet is being initialized.
	//    SI_EDIT_AUDITS - Advanced sheet includes the Audit property page.
	//    SI_EDIT_PROPERTIES - Advanced sheet enables editing of ACEs that
	//                         apply to object's properties and property sets

	// We only currently support '0' or 'SI_ADVANCED'
	ATLASSERT(0 == dwFlags || SI_ADVANCED == dwFlags);
	if(0 == dwFlags)
	{
		*ppAccess = siWMIAccesses;
		*pcAccesses = ARRAYSIZE(siWMIAccesses);
		*piDefaultAccess = iWMIDefAccess;
	}
	else
	{
		*ppAccess = siWMIAccessesAdvanced;
		*pcAccesses = ARRAYSIZE(siWMIAccessesAdvanced);
		*piDefaultAccess = iWMIDefAccessAdvanced;
	}

	return S_OK;
}

//------------------ Real workers -------------------------------
//---------------------------------------------------------------
#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))
#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

/*  Commenting out since winbase.h makes one available for 0x0500 and above

BOOL WINAPI SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR psd,
										 SECURITY_DESCRIPTOR_CONTROL wControlMask,
										 SECURITY_DESCRIPTOR_CONTROL wControlBits)
{
    DWORD dwErr = NOERROR;
    PISECURITY_DESCRIPTOR pSD = (PISECURITY_DESCRIPTOR)psd;

    if (pSD)
        pSD->Control = (pSD->Control & ~wControlMask) | wControlBits;
    else
        dwErr = ERROR_INVALID_PARAMETER;

    return dwErr;
}
*/

void CSDSecurity::ProtectACLs(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    SECURITY_DESCRIPTOR_CONTROL wSDControl;
    DWORD dwRevision;
    PACL pAcl;
    BOOL bDefaulted;
    BOOL bPresent;
    PACE_HEADER pAce;
    UINT cAces;


    if (0 == si || NULL == pSD)
        return;   // Nothing to do

    // Get the ACL protection control bits
    GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision);
    wSDControl &= SE_DACL_PROTECTED | SE_SACL_PROTECTED;

    if ((si & DACL_SECURITY_INFORMATION) && !(wSDControl & SE_DACL_PROTECTED))
    {
        wSDControl |= SE_DACL_PROTECTED;
        pAcl = NULL;
        GetSecurityDescriptorDacl(pSD, &bPresent, &pAcl, &bDefaulted);

        // Theoretically, modifying the DACL in this way can cause it to be
        // no longer canonical.  However, the only way this can happen is if
        // there is an inherited Deny ACE and a non-inherited Allow ACE.
        // Since this function is only called for root objects, this means
        // a) the server DACL must have a Deny ACE and b) the DACL on this
        // object must have been modified later.  But if the DACL was
        // modified through the UI, then we would have eliminated all of the
        // Inherited ACEs already.  Therefore, it must have been modified
        // through some other means.  Considering that the DACL originally
        // inherited from the server never has a Deny ACE, this situation
        // should be extrememly rare.  If it ever does happen, the ACL
        // Editor will just tell the user that the DACL is non-canonical.
        //
        // Therefore, let's ignore the possibility here.

        if (NULL != pAcl)
        {
            for (cAces = pAcl->AceCount, pAce = (PACE_HEADER)FirstAce(pAcl);
                 cAces > 0;
                 --cAces, pAce = (PACE_HEADER)NextAce(pAce))
            {
                pAce->AceFlags &= ~INHERITED_ACE;
            }
        }
    }

    if ((si & SACL_SECURITY_INFORMATION) && !(wSDControl & SE_SACL_PROTECTED))
    {
        wSDControl |= SE_SACL_PROTECTED;
        pAcl = NULL;
        GetSecurityDescriptorSacl(pSD, &bPresent, &pAcl, &bDefaulted);

        if (NULL != pAcl)
        {
            for (cAces = pAcl->AceCount, pAce = (PACE_HEADER)FirstAce(pAcl);
                 cAces > 0;
                 --cAces, pAce = (PACE_HEADER)NextAce(pAce))
            {
                pAce->AceFlags &= ~INHERITED_ACE;
            }
        }
    }

    SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED | SE_SACL_PROTECTED, wSDControl);
}

//---------------------------------------------------------------
HRESULT CSDSecurity::GetSecurity(THIS_ SECURITY_INFORMATION RequestedInformation,
									PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
									BOOL fDefault )
{
//    ATLASSERT(ppSecurityDescriptor != NULL);

    HRESULT hr = E_FAIL;

    *ppSecurityDescriptor = NULL;

    if(fDefault)
	{
        ATLTRACE(_T("Default security descriptor not supported"));
		return E_NOTIMPL;
	}

	// does it want something?
    if(RequestedInformation != 0)
    {
		if(m_pSidOwner != NULL)
		{
			BYTE *p = (LPBYTE)m_pSidOwner;
			delete []p;
			m_pSidOwner = NULL;
		}

		if(m_pSidGroup != NULL)
		{
			BYTE *p = (LPBYTE)m_pSidGroup;
			delete []p;
			m_pSidGroup = NULL;
		}

		switch(m_nsNode->sType)
		{
			case TYPE_NAMESPACE:
			{

				CWbemClassObject _in;
				CWbemClassObject _out;

				hr = m_nsNode->ns->GetMethodSignatures("__SystemSecurity", "GetSD",
														_in, _out);

				if(SUCCEEDED(hr))
				{
					hr = m_nsNode->ns->ExecMethod("__SystemSecurity", "GetSD",
													_in, _out);

					if(SUCCEEDED(hr))
					{
						HRESULT hr1 = HRESULT_FROM_NT(_out.GetLong("ReturnValue"));
						if(FAILED(hr1))
						{
							hr = hr1;
						}
						else
						{
							_out.GetBLOB("SD", (LPBYTE *)ppSecurityDescriptor);
							hr = InitializeOwnerandGroup(ppSecurityDescriptor);
						}
					}
				}
				break;
			}
			case TYPE_STATIC_INSTANCE:
			{
				m_nsNode->pclsObj->GetBLOB("__SD",(LPBYTE *)ppSecurityDescriptor);
				hr = InitializeOwnerandGroup(ppSecurityDescriptor);
				break;
			}
		}

    }
    else
    {
        *ppSecurityDescriptor = LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if(*ppSecurityDescriptor)
            InitializeSecurityDescriptor(*ppSecurityDescriptor, 
											SECURITY_DESCRIPTOR_REVISION);
        else
            hr = E_OUTOFMEMORY;
    }

	//ProtectACLs(RequestedInformation, *ppSecurityDescriptor);
    return hr;
}

//-----------------------------------------------------------------------------
#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))
#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

HRESULT CSDSecurity::SetSecurity(SECURITY_INFORMATION SecurityInformation,
									PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    HRESULT hr = E_FAIL;

	// dont pass the SI_OWNER_RECURSE bit to wbem.
//    SecurityInformation &= ~(OWNER_SECURITY_INFORMATION | SI_OWNER_RECURSE);

	// if something was changed...
    if(SecurityInformation != 0)
	{
		// set the CONTAINER_INHERIT_ACE bit.
		if(SecurityInformation & DACL_SECURITY_INFORMATION)
		{
			PACL pAcl = NULL;
			BOOL bDefaulted;
			BOOL bPresent;
			PACE_HEADER pAce;
			UINT cAces;

			GetSecurityDescriptorDacl(pSecurityDescriptor, &bPresent, &pAcl, &bDefaulted);

			if(NULL != pAcl)
			{
				for(cAces = pAcl->AceCount, pAce = (PACE_HEADER)FirstAce(pAcl);
					 cAces > 0;
					 --cAces, pAce = (PACE_HEADER)NextAce(pAce))
				{
						 // Make sure we don't get 'object inherit'
						 // This happens when creating a new ace from advance page
						 pAce->AceFlags &= ~OBJECT_INHERIT_ACE; 
				}
			}
		}

		SECURITY_DESCRIPTOR *pSD = NULL;

		// ACLUI sends absolute format so change to self-relative so the
		// PutBLOB() has contiguous memory to copy.
		DWORD srLen = 0;
		SetLastError(0);
		BOOL bCheck;
		if(m_pSidOwner != NULL)
		{
			bCheck = SetSecurityDescriptorOwner(pSecurityDescriptor,m_pSidOwner,m_bOwnerDefaulted);
			if(bCheck == FALSE)
			{
				return E_FAIL;
			}
		}

		if(m_pSidGroup != NULL)
		{
			bCheck = SetSecurityDescriptorGroup(pSecurityDescriptor,m_pSidGroup,m_bGroupDefaulted);

			if(bCheck == FALSE)
			{
				return E_FAIL;
			}
		}			

		// get the size needed.
		BOOL x1 = MakeSelfRelativeSD(pSecurityDescriptor, NULL, &srLen);

		DWORD eee = GetLastError();

		pSD = (SECURITY_DESCRIPTOR *)LocalAlloc(LPTR, srLen);
			
		if(pSD)
		{
			BOOL converted = MakeSelfRelativeSD(pSecurityDescriptor, pSD, &srLen);
			hr = S_OK;
		}
		else
		{
			hr = E_OUTOFMEMORY;
			return hr;
		}

		switch(m_nsNode->sType)
		{
			case TYPE_NAMESPACE:
			{
				CWbemClassObject _in;
				CWbemClassObject _out;

				hr = m_nsNode->ns->GetMethodSignatures("__SystemSecurity", "SetSD",
												_in, _out);
				if(SUCCEEDED(hr))
				{
					_in.PutBLOB("SD", (LPBYTE)pSD, GetSecurityDescriptorLength(pSD));

					hr = m_nsNode->ns->ExecMethod("__SystemSecurity", "SetSD",
											_in, _out);
					if(SUCCEEDED(hr))
					{
						HRESULT hr1 = HRESULT_FROM_NT(_out.GetLong("ReturnValue"));
						if(FAILED(hr1))
						{
							hr = hr1;
						}
					}
				}
        		// HACK: because of how the core caches/uses security, I have to close &
		        // reopen my connection because GetSecurity() will be immediately called
		        // to refresh the UI. If I dont do this, GetSecurity() will return to old
		        // security settings even though they're really saved. 

				m_nsNode->ns->DisconnectServer();
                CHString1 path;
                // if we've got a server, here - append it.
                if (((BSTR)m_server != NULL) && wcslen(m_server))
                    path = CHString1("\\\\") + CHString1((BSTR)m_server) + CHString1("\\") + CHString1((BSTR)m_nsNode->fullPath);
                else
                    path = m_nsNode->fullPath;

				m_nsNode->ns->ConnectServer(_bstr_t((const WCHAR*)path));
				
                break;
			}
			case TYPE_STATIC_INSTANCE:
			{
				m_nsNode->pclsObj->PutBLOB("__SD",(LPBYTE)pSD, GetSecurityDescriptorLength(pSD));
				//Now put the instance back
				hr = m_nsNode->ns->PutInstance(*(m_nsNode->pclsObj)/*,flag*/);
				delete m_nsNode->pclsObj;
				*(m_nsNode->pclsObj) = m_nsNode->ns->GetObject(m_nsNode->relPath/*,flag*/);
				break;
			}
		}
		if(m_pSidOwner != NULL)
		{
			BYTE *p = (LPBYTE)m_pSidOwner;
			delete []p;
			m_pSidOwner = NULL;
		}

		if(m_pSidGroup != NULL)
		{
			BYTE *p = (LPBYTE)m_pSidGroup;
			delete []p;
			m_pSidGroup = NULL;
		}
	}

    return hr;
}

HRESULT CSDSecurity::InitializeOwnerandGroup(PSECURITY_DESCRIPTOR *ppSecurityDescriptor)
{

	SID *pSid;
	BOOL bDefaulted;

    BOOL bCheck = GetSecurityDescriptorOwner(*ppSecurityDescriptor,
                                        (void **)&pSid,&m_bOwnerDefaulted);
	if(bCheck == TRUE)
	{
        if (pSid != NULL)
        {
		    m_nLengthOwner = GetSidLengthRequired(pSid->SubAuthorityCount);

		    if(m_pSidOwner != NULL)
		    {
			    BYTE *p = (LPBYTE)m_pSidOwner;
			    delete []p;
			    m_pSidOwner = NULL;
		    }

		    m_pSidOwner = (SID *)new BYTE[m_nLengthOwner];

		    if(m_pSidOwner == NULL ||
               CopySid(m_nLengthOwner,m_pSidOwner,pSid) == FALSE)
		    {
                delete m_pSidOwner;
			    m_pSidOwner = NULL;
			    m_nLengthOwner = -1;
			    return E_FAIL;
		    }
        }
        else
        {
            m_pSidOwner    = NULL;
            m_nLengthOwner = 0;
        }
	}
	else
	{
		m_pSidOwner = NULL;
		m_nLengthOwner = -1;
		return E_FAIL;
	}

	SID *pGroup;

    bCheck = GetSecurityDescriptorGroup(*ppSecurityDescriptor,
                                    (void **)&pGroup,&m_bGroupDefaulted);

	if(bCheck == TRUE)
	{
        if (pGroup != NULL)
        {
		    m_nLengthGroup = GetSidLengthRequired(pGroup->SubAuthorityCount);

		    if(m_pSidGroup != NULL)
		    {
			    BYTE *p = (LPBYTE)m_pSidGroup;
			    delete []p;
			    m_pSidGroup = NULL;
		    }

		    m_pSidGroup = (SID *)new BYTE[m_nLengthGroup];

		    if(m_pSidGroup == NULL ||
               CopySid(m_nLengthGroup,m_pSidGroup,pGroup) == FALSE)
		    {
                delete m_pSidGroup;
			    m_pSidGroup = NULL;
			    m_nLengthGroup = -1;
			    return E_FAIL;
            }
        }
        else
        {
            m_pSidGroup    = NULL;
            m_nLengthGroup = 0;
        }
	}
	else
	{
		m_pSidGroup = NULL;
		m_nLengthGroup = -1;
		return E_FAIL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\uihelpers.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef _UIHELPERS_H_
#define _UIHELPERS_H_

#include "..\common\sshWbemHelpers.h"
#include <windowsx.h>
#include "PageBase.h"

// supports the page coordinating routines.
#define PB_LOGGING 0
#define PB_BACKUP 1
#define PB_ADVANCED 2
#define PB_LASTPAGE 2


extern const TCHAR c_HelpFile[];


typedef struct {
	LPTSTR lpName;
	UINT cName;
	bool *local;
	LOGIN_CREDENTIALS *credentials;
} CONN_NAME;


class WbemServiceThread;
class DataSource;

void CredentialUserA(LOGIN_CREDENTIALS *credentials, char **user);
void CredentialUserW(LOGIN_CREDENTIALS *credentials, wchar_t **user);

#ifdef UNICODE
#define CredentialUser CredentialUserW
#else
#define CredentialUser CredentialUserA
#endif

// 0 means any version of NT will do.
bool IsNT(DWORD ver = 0);

//-------------------------------------------------------------------
// NOTE: These 'sid' routines came from \winmgmt\common\wbemntsec.*.
class CNtSid
{
    PSID    m_pSid;
    LPTSTR  m_pMachine;
    LPTSTR  m_pDomain;
    DWORD   m_dwStatus;

public:
    enum {NoError, Failed, NullSid, InvalidSid, InternalError, AccessDenied = 0x5};

    enum SidType {CURRENT_USER, CURRENT_THREAD};

    CNtSid(SidType st);
   ~CNtSid();

    BOOL IsValid() { return (m_pSid && IsValidSid(m_pSid)); }
        // Checks the validity of the internal SID.
    
    int GetInfo(LPTSTR *pRetAccount,        // Account, use operator delete
				LPTSTR *pRetDomain,         // Domain, use operator delete
				DWORD  *pdwUse);            // See SID_NAME_USE for values
				
};


class CUIHelpers : public CBasePage
{
public:
    CUIHelpers(DataSource *ds, WbemServiceThread *serviceThread, bool htmlSupport);
    CUIHelpers(CWbemServices &service, bool htmlSupport);
    virtual ~CUIHelpers( void );

	CONN_NAME m_cfg;
	bool m_ImaWizard;
	static INT_PTR DisplayCompBrowser(HWND hWnd,
						           LPTSTR lpName, UINT cName,
						           bool *local, LOGIN_CREDENTIALS *credentials);

protected:

	void SetWbemService(IWbemServices *pServices);
	long m_sessionID;

	void HTMLHelper(HWND hDlg);
	bool m_htmlSupport;

#define NO_UI 0  // for uCaption
	bool ServiceIsReady(UINT uCaption, 
						UINT uWaitMsg,
						UINT uBadMsg);

#ifndef SNAPIN
	INT_PTR DisplayLoginDlg(HWND hWnd, 
						LOGIN_CREDENTIALS *credentials);
#endif

	INT_PTR DisplayNSBrowser(HWND hWnd,
							LPTSTR lpName, UINT cName);

	INT_PTR DisplayEditDlg(HWND hWnd,
						UINT idCaption,
						UINT idMsg,
						LPTSTR lpEdit,
						UINT cEdit);

	bool BrowseForFile(HWND hDlg, 
						UINT idTitle,
						LPCTSTR lpstrFilter,
						LPCTSTR initialFile,
						LPTSTR pathFile,
						UINT pathFileSize,
						DWORD moreFlags = 0);

	LPTSTR CloneString( LPTSTR pszSrc );

	HWND m_AVIbox;
	INT_PTR DisplayAVIBox(HWND hWnd,
						LPCTSTR lpCaption,
						LPCTSTR lpClientMsg,
						HWND *boxHwnd,
						BOOL cancelBtn = TRUE);


	// call when a control changes. It sends the PSM_CHANGED for you.
	void PageChanged(int page, bool needToPut);

	// call from OnApply(). Caches property Puts into one PutInstance.
	// It sends the PSM_UNCHANGED for you.
	HRESULT NeedToPut(int page, BOOL refresh);

private:
	static int m_needToPut[3];
	bool m_userCancelled; // the connectServer() thread.

};

//===========================================================
class ConnectPage : public CUIHelpers
{
public:
	ConnectPage(DataSource *ds, bool htmlSupport);
	~ConnectPage(void);

private:
	virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
	bool m_isLocal;
};


#endif  /* _UIHELPERS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\snapin\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\uihelpers.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "UIHelpers.h"
#include "DataSrc.h"
#include "resource.h"
#include <cominit.h>
#include "WMIHelp.h"
#include <HTMLHelp.h>
#include <prsht.h>
#include "WbemError.h"
#include <util.h>

#ifdef SNAPIN
const TCHAR c_HelpFile[] = _T("newfeat1.hlp");
#else
const TCHAR c_HelpFile[] = _T("WbemCntl.hlp");
#endif


//-------------------------------------------------------------------
bool IsNT(DWORD  ver /* = 0 */)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

	if(os.dwPlatformId != VER_PLATFORM_WIN32_NT)
	{
		return false;
	}
	else if(ver == 0)
	{
		// any version of NT will do.
		return true;
	}
	else
	{
		return (os.dwMajorVersion == ver);
	}
}


//-------------------------------------------------------------------
CNtSid::CNtSid(SidType st)
{
    m_pSid = 0;
    m_dwStatus = InternalError;
    m_pMachine = 0;

    if(st == CURRENT_USER ||st == CURRENT_THREAD)
    {
        HANDLE hToken;
		if(st == CURRENT_USER)
		{
			if(!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken))
	            return;
		}
		else
		{
			if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
	            return;
		}

        // Get the user sid
        // ================

        TOKEN_USER tu;
        DWORD dwLen = 0;
        GetTokenInformation(hToken, TokenUser, &tu, sizeof(tu), &dwLen);

        if(dwLen == 0)
        {
            CloseHandle(hToken);
            return;
        }

        BYTE* pTemp = new BYTE[dwLen];
        if (!pTemp)
        {
            CloseHandle(hToken);
            return;
        }

        DWORD dwRealLen = dwLen;
        if(!GetTokenInformation(hToken, TokenUser, pTemp, dwRealLen, &dwLen))
        {
            CloseHandle(hToken);
            delete [] pTemp;
            return;
        }

        CloseHandle(hToken);

        // Make a copy of the SID
        // ======================

        PSID pSid = ((TOKEN_USER*)pTemp)->User.Sid;
        DWORD dwSidLen = GetLengthSid(pSid);
        m_pSid = new BYTE[dwSidLen];
        CopySid(dwSidLen, m_pSid, pSid);
        delete [] pTemp;
        m_dwStatus = 0;
    }
    return;
}

//-------------------------------------------------------------------
CNtSid::~CNtSid()
{
    if (m_pSid)
        delete [] m_pSid;
    if (m_pMachine)
        delete [] m_pMachine;
}

//-------------------------------------------------------------------
int CNtSid::GetInfo(LPTSTR *pRetAccount,       // Account, use operator delete
						LPTSTR *pRetDomain,    // Domain, use operator delete
						DWORD  *pdwUse)        // See SID_NAME_USE for values
{
    if(pRetAccount)
        *pRetAccount = 0;

    if(pRetDomain)
        *pRetDomain = 0;
    
	if(pdwUse)
        *pdwUse = 0;

    if(!m_pSid || !IsValidSid(m_pSid))
        return InvalidSid;

    DWORD  dwNameLen = 0;
    DWORD  dwDomainLen = 0;
    LPTSTR pUser = 0;
    LPTSTR pDomain = 0;
    SID_NAME_USE Use;


    // Do the first lookup to get the buffer sizes required.
    // =====================================================

    BOOL bRes = LookupAccountSid(m_pMachine,
									m_pSid,
									pUser,
									&dwNameLen,
									pDomain,
									&dwDomainLen,
									&Use);

    DWORD dwLastErr = GetLastError();

    if(dwLastErr != ERROR_INSUFFICIENT_BUFFER)
    {
        return Failed;
    }

    // Allocate the required buffers and look them up again.
    // =====================================================

    pUser = new TCHAR[dwNameLen + 1];
    pDomain = new TCHAR[dwDomainLen + 1];

    bRes = LookupAccountSid(m_pMachine,
								m_pSid,
								pUser,
								&dwNameLen,
								pDomain,
								&dwDomainLen,
								&Use);

    if(!bRes)
    {
        delete[] pUser;
        delete[] pDomain;
        return Failed;
    }

    if(pRetAccount)
        *pRetAccount = pUser;
    else
        delete[] pUser;

    if(pRetDomain)
        *pRetDomain  = pDomain;
    else
        delete[] pDomain;

    if(pdwUse)
        *pdwUse = Use;

    return NoError;
}

//-------------------------------------------------------------------
CUIHelpers::CUIHelpers(DataSource *ds, WbemServiceThread *serviceThread,
					   bool htmlSupport) :
					CBasePage(ds, serviceThread), m_sessionID(0),
					m_htmlSupport(htmlSupport), m_ImaWizard(false)
{
}

//-------------------------------------------------------------------
CUIHelpers::CUIHelpers(CWbemServices &service,
					   bool htmlSupport) :
					CBasePage(service), m_sessionID(0), m_htmlSupport(htmlSupport),
						m_ImaWizard(false)
{
}

//-------------------------------------------------------------------
CUIHelpers::~CUIHelpers( void )
{
}

//---------------------------------------------------
LPTSTR CUIHelpers::CloneString( LPTSTR pszSrc ) 
{
    LPTSTR pszDst = NULL;

    if (pszSrc != NULL) 
	{
        pszDst = new TCHAR[(lstrlen(pszSrc) + 1)];
        if (pszDst) 
		{
            lstrcpy( pszDst, pszSrc );
        }
    }

    return pszDst;
}

//--------------------------------------------------------------
void CUIHelpers::SetWbemService(IWbemServices *pServices)
{
	g_serviceThread->m_realServices = pServices;		//VINOTH
	m_WbemServices = pServices;
}

//--------------------------------------------------------------
bool CUIHelpers::ServiceIsReady(UINT uCaption, 
									UINT uWaitMsg,
									UINT uBadMsg)
{
	switch(g_serviceThread->m_status)
	{
	// its already there.
	case WbemServiceThread::ready:
		{
		ATLTRACE(_T("start marshal\n"));
		for(int i = 0; (i < 5); i++)
		{
			// if "Object is not connected to server"
			if(g_serviceThread->m_hr == 0x800401fd)
			{
				// lost my connection,
				ATLTRACE(_T("Reconnecting to cimom!!!!!!!!!!!\n"));
				g_serviceThread->ReConnect();
				ATLTRACE(_T("new service status: %d\n"), g_serviceThread->m_status);
				continue;
			}
			else if(FAILED(g_serviceThread->m_hr))
			{
				// some other problem.
				g_serviceThread->m_status = WbemServiceThread::error;
			}

			ATLTRACE(_T("marshalled ok\n"));
			break;  //for

		} //endfor

		if(m_AVIbox)
		{
			PostMessage(m_AVIbox, 
						WM_ASYNC_CIMOM_CONNECTED, 
						0, 0);
			m_AVIbox = 0;
		}

		// it marshaled, must still be connected/useable.
		return true;
		}
		break;

	// its coming.
	case WbemServiceThread::notStarted:
	case WbemServiceThread::locating:
	case WbemServiceThread::connecting:
		{
			if(m_alreadyAsked)
			{
				return false;
			}

			// let me know when its there.
			g_serviceThread->NotifyWhenDone(m_hDlg);

			// also kill the cancel box at that time.
			m_AVIbox = 0;
			g_serviceThread->NotifyWhenDone(m_AVIbox);

			m_alreadyAsked = true;

			if(uCaption != NO_UI)
			{
				TCHAR caption[100] ={0}, msg[256] = {0};

				::LoadString(_Module.GetModuleInstance(), uCaption, 
								caption, 100);

				::LoadString(_Module.GetModuleInstance(), uWaitMsg, 
								msg, 256);

                m_userCancelled = false;

				if(DisplayAVIBox(m_hDlg, caption, msg, &m_AVIbox) == IDCANCEL)
				{
					g_serviceThread->Cancel();
					m_userCancelled = true;
				}
			}
		}
		return false;
		break;

	case WbemServiceThread::error:			// cant connect.
	case WbemServiceThread::threadError:	// cant start that thread.
	default:
		m_AVIbox = 0;
		if(uCaption != NO_UI)
		{
//			DisplayUserMessage(m_hDlg, HINST_THISDLL,
//								uCaption, uBadMsg, 
//								g_serviceThread->m_hr, 
//								MB_ICONSTOP);
		}
			return false;

	}; //endswitch 
	return false;
}

//---------------------------------------------------
#define PB_NOTHING_PENDING 0
#define PB_PENDING 1
#define PB_COMMIT 2

// STATIC INITIALIZE
int CUIHelpers::m_needToPut[3] = {PB_NOTHING_PENDING,
								 PB_NOTHING_PENDING,
								 PB_NOTHING_PENDING};

void CUIHelpers::PageChanged(int page, bool needToPut)
{
	if(needToPut)
	{
		::SendMessage(GetParent(m_hDlg), PSM_CHANGED, (WPARAM)m_hDlg, 0L);
		m_needToPut[page] = PB_PENDING;
		ATLTRACE(_T("%d pending now\n"), page);
	}
	else
	{
		m_needToPut[page] = PB_NOTHING_PENDING;
	}
}

//---------------------------------------------------
HRESULT CUIHelpers::NeedToPut(int page, BOOL refresh)
{
	bool allPagesReady = true;
	int x;
	HRESULT hr = S_OK;

	switch(m_needToPut[page])
	{
	case PB_NOTHING_PENDING:
	case PB_COMMIT:
		return S_OK;      // unnecessary call.
		break;
	case PB_PENDING:
		m_needToPut[page] = PB_COMMIT;   // lets do it.
		ATLTRACE(_T("%d committed now\n"), page);

		break;
	}
	
	// it that the last one?
	for(x = 0; x <= PB_LASTPAGE; x++)
	{
		// somebody hasn't committed yet.
		// NOTE: ignoring the PB_NOTHING_PENDING's.
		if(m_needToPut[x] == PB_PENDING)
		{
			// wait awhile longer.
			allPagesReady = false;
			break;
		}
	}

	if(allPagesReady)
	{
		hr = m_DS->PutWMISetting(refresh);
		if(FAILED(hr))
		{
			CHString1 caption;
			TCHAR errMsg[256] = {0};
			caption.LoadString(IDS_SHORT_NAME);

			ErrorStringEx(hr, errMsg, 256);

			MessageBox(m_hDlg, errMsg, caption, MB_OK|MB_ICONWARNING);
		}

		ATLTRACE(_T("PUTINSTANCE now\n"));

		// clear the flags.
		for(x = 0; x <= PB_LASTPAGE; x++)
		{
			m_needToPut[x] = PB_NOTHING_PENDING;
		}
	}

	::SendMessage(GetParent(m_hDlg), PSM_UNCHANGED, (WPARAM)m_hDlg, 0L);

	return hr;
}


//------------------------------------------------------------------------
bool CUIHelpers::BrowseForFile(HWND hDlg, 
								UINT idTitle,
								LPCTSTR lpstrFilter,
								LPCTSTR initialFile,
								LPTSTR pathFile,
								UINT pathFileSize,
								DWORD moreFlags /*= 0*/)
{
	bool retval = false;

	if(m_DS->IsLocal())
	{
		OPENFILENAME OpenFileName;
		CHString1 title;
		title.LoadString(idTitle);

		OpenFileName.lStructSize       = sizeof(OPENFILENAME);
		OpenFileName.hwndOwner         = hDlg;
		OpenFileName.hInstance         = 0;
		OpenFileName.lpstrFilter       = lpstrFilter;
		OpenFileName.lpstrCustomFilter = NULL;
		OpenFileName.nMaxCustFilter    = 0;
		OpenFileName.nFilterIndex      = 0;
		OpenFileName.lpstrFile         = pathFile;
		OpenFileName.nMaxFile          = pathFileSize;
		OpenFileName.lpstrFileTitle    = NULL;
		OpenFileName.nMaxFileTitle     = 0;
		OpenFileName.lpstrInitialDir   = initialFile;
		OpenFileName.lpstrTitle        = (LPCTSTR)title;
		OpenFileName.nFileOffset       = 0;
		OpenFileName.nFileExtension    = 0;
		OpenFileName.lpstrDefExt       = _T("rec");
		OpenFileName.lCustData         = NULL;
		OpenFileName.lpfnHook 		   = NULL;
		OpenFileName.lpTemplateName    = NULL;
	#if (_WIN32_WINNT >= 0x0500)
		OpenFileName.Flags             = OFN_HIDEREADONLY|OFN_DONTADDTORECENT;
	#else
		OpenFileName.Flags             = OFN_HIDEREADONLY;
	#endif
		//Adding OFN_NOCHANGEDIR here so that the Open File dialog doesn't hold on to the directory - otherwise
		//the recovery fails because it needs to rename the dir.
		OpenFileName.Flags             |= moreFlags | OFN_NOCHANGEDIR;


		// Call the common dialog function.
		if(GetOpenFileName(&OpenFileName))
		{
			retval = true;
		}
		else
   		{
			DWORD x = CommDlgExtendedError();
			retval = false;
		}

   	}
	else // remote connection
	{
		retval = (DisplayEditDlg(hDlg, idTitle, IDS_CANT_BROWSE_REMOTELY,
								pathFile, pathFileSize) == IDOK);
	}

	return retval;
}

//---------------------------------------------------------
typedef struct {
	LPCTSTR lpCaption;
	LPCTSTR lpClientMsg;
	UINT uAnim;
	HWND *boxHwnd;
	BOOL cancelBtn;
} ANIMCONFIG;

INT_PTR CALLBACK AnimDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{//BEGIN
			//lParam = ANIMCONFIG *

			ANIMCONFIG *cfg = (ANIMCONFIG *)lParam;
			*(cfg->boxHwnd) = hwndDlg;

			::ShowWindow(hwndDlg, SW_SHOW);
			if(cfg->cancelBtn == FALSE)
			{
				::ShowWindow(::GetDlgItem(hwndDlg, IDCANCEL), SW_HIDE);
			}
			
				

			// save this pointer for the WM_DESTROY.
			SetWindowLongPtr(hwndDlg, DWLP_USER, (LPARAM)cfg->boxHwnd);

			HWND hAnim = GetDlgItem(hwndDlg, IDC_ANIMATE);
			HWND hMsg = GetDlgItem(hwndDlg, IDC_MSG);

			Animate_Open(hAnim, MAKEINTRESOURCE(cfg->uAnim));

			SetWindowText(hwndDlg, cfg->lpCaption);
			SetWindowText(hMsg, cfg->lpClientMsg);

			retval = TRUE;
		}//END
		break;

	case WM_ASYNC_CIMOM_CONNECTED:
		// the client has completed 'whatever' and I should
		// claim victory and go away now.
		EndDialog(hwndDlg, IDOK);
		break;

	case WM_COMMAND:
		// they're only one button.
		if(HIWORD(wParam) == BN_CLICKED)
		{
			// I'm going away now so anybody that has a ptr to my
			// hwnd (which I gave out in my WM_INITDIALOG) shouldn't
			// use it anymore.
			HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			*me = 0;
			EndDialog(hwndDlg, IDCANCEL);
		}
		retval = TRUE; // I processed it.
		break;

	case WM_DESTROY:
		{// BEGIN
			// I'm going away now so anybody that has a ptr to my
			// hwnd (which I gave out in my WM_INITDIALOG) shouldn't
			// use it anymore.
			HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			*me = 0;
			retval = TRUE; // I processed it.
		} //END
		break;

	default:
		retval = FALSE; // I did NOT process this msg.
		break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
INT_PTR CUIHelpers::DisplayAVIBox(HWND hWnd,
							LPCTSTR lpCaption,
							LPCTSTR lpClientMsg,
							HWND *boxHwnd,
							BOOL cancelBtn)
{
	ANIMCONFIG cfg = {lpCaption, lpClientMsg, IDR_AVIWAIT, boxHwnd, cancelBtn};

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_ANIMATE), 
							hWnd, AnimDlgProc, 
							(LPARAM)&cfg);
}

//---------------------------------------------------------
typedef struct {
	LPTSTR lpName;
	UINT cName;
	DataSource *ds;
	HTREEITEM hSelectedItem;
} PICK_CFG;

INT_PTR CALLBACK NSPickDlgProc(HWND hwndDlg,
							 UINT uMsg,
							 WPARAM wParam,
							 LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{ //BEGIN
			SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
			PICK_CFG *data = (PICK_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			HWND hTree = GetDlgItem(hwndDlg, IDC_NSTREE);
			data->ds->LoadImageList(hTree);
			data->ds->LoadNode(hTree, TVI_ROOT, HIDE_SOME);

		} //END
		retval = TRUE;
		break;

    case WM_NOTIFY:
        {
			PICK_CFG *data = (PICK_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

            switch(((LPNMHDR)lParam)->code)
            {
			case TVN_SELCHANGED:
				if(((LPNMHDR)lParam)->idFrom == IDC_NSTREE)
				{
					LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)lParam;
					data->hSelectedItem = pnmtv->itemNew.hItem;
				}
				break;
			case TVN_ITEMEXPANDING:
				if(((LPNMHDR)lParam)->idFrom == IDC_NSTREE)
				{
					// expand the node.
					LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)lParam;
					if(pnmtv->action == TVE_EXPAND)
					{
						HWND hTree = GetDlgItem(hwndDlg, IDC_NSTREE);
						data->ds->LoadNode(hTree, pnmtv->itemNew.hItem, HIDE_SOME);
					}
				}
				break;
            }
        }
		retval = TRUE;
        break;

	case WM_COMMAND:
		// they're only one button.
		switch(LOWORD(wParam))
		{
		case IDOK:
			{
				PICK_CFG *data = (PICK_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

				// save the currently selected fullpath name.
				HWND hTree = ::GetDlgItem(hwndDlg, IDC_NSTREE);
				TV_ITEM item;
				item.mask = TVIF_PARAM;
				item.hItem = data->hSelectedItem;
				BOOL x = TreeView_GetItem(hTree, &item);

				struct NSNODE *node = ((ITEMEXTRA *)item.lParam)->nsNode;

				if(node && data)
					_tcsncpy(data->lpName, node->fullPath, data->cName);

				EndDialog(hwndDlg, IDOK);
			}
			break;

		case IDCANCEL:
			{
				EndDialog(hwndDlg, IDCANCEL);
			}
			break;

		default:
			return(FALSE);
		} // switch
        break;

	default:
		retval = FALSE; // I did NOT process this msg.
		break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
INT_PTR CUIHelpers::DisplayNSBrowser(HWND hWnd,
									LPTSTR lpName,
									UINT cName)
{
	PICK_CFG cfg;
	cfg.lpName = lpName;
	cfg.cName = cName;
	cfg.ds = m_DS;
	cfg.hSelectedItem = 0;

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_NS_PICKER), 
							hWnd, NSPickDlgProc, 
							(LPARAM)&cfg);
}

//---------------------------------------------------------
typedef struct {
	LPCTSTR lpCaption;
	LPCTSTR lpMsg;
	LPTSTR lpEdit;
	UINT cEdit;
} EDIT_CFG;

const static DWORD nsBrowseHelpIDs[] = {  // Context Help IDs
	IDC_NSTREE, IDH_WMI_CTRL_ADVANCED_CHANGE_NAMESPACE,
	65535, -1,
    0, 0
};

INT_PTR CALLBACK EditDlgProc(HWND hwndDlg,
							 UINT uMsg,
							 WPARAM wParam,
							 LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{ //BEGIN
			SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
			EDIT_CFG *data = (EDIT_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			if(data->lpMsg)
			{
				::SetWindowText(GetDlgItem(hwndDlg, IDC_MSG), data->lpMsg);
			}
			if(data->lpCaption)
			{
				SetWindowText(hwndDlg, data->lpCaption);
			}

			::SendMessage(GetDlgItem(hwndDlg, IDC_EDIT), EM_LIMITTEXT, data->cEdit-1, 0);


		} //END
		retval = TRUE;
		break;

	case WM_COMMAND:
		// they're only one button.
		switch(LOWORD(wParam))
		{
		case IDC_EDIT:
			if(HIWORD(wParam) == EN_CHANGE)
			{
				HWND hwnd = GetDlgItem(hwndDlg, IDOK);
				int len = GetWindowTextLength((HWND)lParam);

				::EnableWindow(hwnd, (len > 0));
			}
			break;

		case IDOK:
			{
				EDIT_CFG *data = (EDIT_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

				if(data->lpEdit)
				{
					::GetWindowText(GetDlgItem(hwndDlg, IDC_EDIT), 
									data->lpEdit, data->cEdit);
				}
				EndDialog(hwndDlg, IDOK);
			}
			break;

		case IDCANCEL:
			{
				EndDialog(hwndDlg, IDCANCEL);
			}
			break;

		default:
			return(FALSE);
		} // switch
        break;

    case WM_HELP:
        if (IsWindowEnabled(hwndDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)nsBrowseHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hwndDlg))
        {
            WinHelp(hwndDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)nsBrowseHelpIDs);
        }
        break;

	default:
		retval = FALSE; // I did NOT process this msg.
		break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
INT_PTR CUIHelpers::DisplayEditDlg(HWND hWnd,
								UINT idCaption,
								UINT idMsg,
								LPTSTR lpEdit,
								UINT cEdit)
{
	CHString1 caption, msg;
	caption.LoadString(idCaption);
	msg.LoadString(idMsg);

	EDIT_CFG cfg = {(LPCTSTR)caption, (LPCTSTR)msg, lpEdit, cEdit};

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_EDITBOX), 
							hWnd, EditDlgProc, 
							(LPARAM)&cfg);
}

//---------------------------------------------------------
typedef struct {
	LOGIN_CREDENTIALS *credentials;
} LOGIN_CFG;


//------------------------------------------------------------------------
void CredentialUserA(LOGIN_CREDENTIALS *credentials, char **user)
{
	//Take twice the length because if they are in Unicode, each unicode char can translate to 2 bytes in multi-byte.
	UINT finalSize = (credentials->authIdent->DomainLength + 
						credentials->authIdent->UserLength) * 2 + 2; //one for terminating '0' and one for the '\'

	*user = new char[finalSize];
	if(*user == NULL)
		return;

	memset(*user, 0, finalSize * sizeof(char));

	if(credentials->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
	{
		if(credentials->authIdent->DomainLength > 0)
		{
			strcpy(*user, (char *)credentials->authIdent->Domain);
			strcat(*user, "\\");
			strcat(*user, (char *)credentials->authIdent->User);
		}
		else
		{
			strcpy(*user, (char *)credentials->authIdent->User);
		}
	}
	else   // convert the UNICODE
	{
		if(credentials->authIdent->DomainLength > 0)
		{
			char temp[100] = {0};
			//Note we allow twice the length, because assuming the length is in # of characters, each wchar
			//could potentially result in 2 bytes for the multi-byte character.
			wcstombs(*user, credentials->authIdent->Domain,
								credentials->authIdent->DomainLength * 2);
			
			strcat(*user, "\\");

			wcstombs(temp, credentials->authIdent->User,
								credentials->authIdent->UserLength * 2);

			strcat(*user, temp);
		}
		else
		{
			wcstombs(*user, credentials->authIdent->User,
							credentials->authIdent->UserLength * 2);
		}
	}
}

//------------------------------------------------------------------------
void CredentialUserW(LOGIN_CREDENTIALS *credentials, wchar_t **user)
{
	UINT finalSize = credentials->authIdent->DomainLength + 
						credentials->authIdent->UserLength + 2; //one for terminating '0' and one for the '\'

	*user = new wchar_t[finalSize];
	if(*user == NULL)
		return;
	memset(*user, 0, finalSize * sizeof(wchar_t));

	if(credentials->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
	{
		if(credentials->authIdent->DomainLength > 0)
		{
			wchar_t temp[100] = {0};
			mbstowcs(*user, (const char *)credentials->authIdent->Domain,
								credentials->authIdent->DomainLength);

			wcscat(*user, L"\\");
			
			mbstowcs(temp, (const char *)credentials->authIdent->User,
								credentials->authIdent->UserLength);

			wcscat(*user, temp);
		}
		else
		{
			mbstowcs(*user, (const char *)credentials->authIdent->User,
								credentials->authIdent->UserLength);
		}
	}
	else   //
	{
		if(credentials->authIdent->DomainLength > 0)
		{
			wcscpy(*user, credentials->authIdent->Domain);
			wcscat(*user, L"\\");
			wcscat(*user, credentials->authIdent->User);
		}
		else
		{
			wcscpy(*user, credentials->authIdent->User);
		}
	}
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void SetCurrentUser(HWND hDlg, bool currUser)
{
	Button_SetCheck(GetDlgItem(hDlg, IDC_CHECKCURRENTUSER), 
						(currUser? BST_CHECKED:BST_UNCHECKED));

	BOOL enable = (currUser? FALSE: TRUE);

	::EnableWindow(GetDlgItem(hDlg, IDC_EDITUSERNAME), enable);
	::EnableWindow(GetDlgItem(hDlg, IDC_EDITPASSWORD), enable);
	::EnableWindow(GetDlgItem(hDlg, IDC_USER_LABEL), enable);
	::EnableWindow(GetDlgItem(hDlg, IDC_PW_LABEL), enable);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const static DWORD logonHelpIDs[] = {  // Context Help IDs
	IDC_CHECKCURRENTUSER, IDH_WMI_CTRL_GENERAL_WMILOGIN_CHECKBOX,
	IDC_USER_LABEL, IDH_WMI_CTRL_GENERAL_WMILOGIN_USERNAME,
	IDC_EDITUSERNAME, IDH_WMI_CTRL_GENERAL_WMILOGIN_USERNAME,
	IDC_PW_LABEL, IDH_WMI_CTRL_GENERAL_WMILOGIN_PASSWORD,
	IDC_EDITPASSWORD, IDH_WMI_CTRL_GENERAL_WMILOGIN_PASSWORD,
    0, 0
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
INT_PTR CALLBACK LoginDlgProc(HWND hwndDlg,
							 UINT uMsg,
							 WPARAM wParam,
							 LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{ //BEGIN
			SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
			LOGIN_CFG *data = (LOGIN_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

			SetCurrentUser(hwndDlg, data->credentials->currUser);

		} //END
		retval = TRUE;
		break;

	case WM_COMMAND:
		{
			LOGIN_CFG *data = (LOGIN_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

			switch(LOWORD(wParam))
			{
			case IDC_CHECKCURRENTUSER:
				{
					if(HIWORD(wParam) == BN_CLICKED)
					{
						bool currUser = (IsDlgButtonChecked(hwndDlg, IDC_CHECKCURRENTUSER) == BST_CHECKED ?true:false);
						// toggle and respond.
						SetCurrentUser(hwndDlg, currUser);
					}
				}
				break;

			case IDOK:
				{
					if(HIWORD(wParam) == BN_CLICKED)
					{
						data->credentials->currUser = (IsDlgButtonChecked(hwndDlg, IDC_CHECKCURRENTUSER) == BST_CHECKED ?true:false);

						if(data->credentials->currUser == false)
						{
							TCHAR user[100] = {0}, pw[100] = {0};
							GetWindowText(GetDlgItem(hwndDlg, IDC_EDITUSERNAME), user, 100);
							GetWindowText(GetDlgItem(hwndDlg, IDC_EDITPASSWORD), pw, 100);
							
							BSTR bDomUser, bUser = NULL, bDomain = NULL, bAuth = NULL;
//#ifdef SNAPIN
							wchar_t *temp = pw;
							bDomUser = SysAllocString(user);
/*#else
							wchar_t temp[100] = {0};
							mbstowcs(temp, user, 100);
							bDomUser = SysAllocString(temp);
							mbstowcs(temp, pw, 100);
#endif*/
							if(SUCCEEDED(DetermineLoginType(bDomain, bUser, bAuth, bDomUser)))
							{
								if(data->credentials->authIdent != 0)
								{
									if(data->credentials->fullAcct)
									{
										data->credentials->fullAcct[0] = 0;
									}
									WbemFreeAuthIdentity(data->credentials->authIdent);
									data->credentials->authIdent = 0;
								}

								HRESULT hr = WbemAllocAuthIdentity(bUser, temp, bDomain, 
																	&(data->credentials->authIdent));

								_tcscpy(data->credentials->fullAcct, user);
							}
						}

						EndDialog(hwndDlg, IDOK);
					}
				}
				break;

			case IDCANCEL:
				{
					if(HIWORD(wParam) == BN_CLICKED)
					{
						EndDialog(hwndDlg, IDCANCEL);
					}
				}
				break;

			default:
				return(FALSE);
			} // switch
			break;
		} // - - - - - - - - endswitch LOWORD()
		break;

    case WM_HELP:
        if(IsWindowEnabled(hwndDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)logonHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if(IsWindowEnabled(hwndDlg))
        {
            WinHelp(hwndDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)logonHelpIDs);
        }
        break;

	default: break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
INT_PTR DisplayLoginDlg(HWND hWnd, 
					LOGIN_CREDENTIALS *credentials)
{
	LOGIN_CFG cfg;

	cfg.credentials = credentials;

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_LOGIN), 
							hWnd, LoginDlgProc, 
							(LPARAM)&cfg);
}
//---------------------------------------------------------
void SetUserAccount(HWND hwndDlg, 
					LOGIN_CREDENTIALS *credentials)
{

	HWND hwnd = GetDlgItem(hwndDlg, IDC_ACCOUNT);
	if(credentials->currUser)
	{
		CHString1 name;
		name.LoadString(IDS_CURRENT_USER);
		SetWindowText(hwnd, (LPCTSTR)name);
	}
	else if(credentials->authIdent != 0 &&
			credentials->authIdent->UserLength != 0)
	{
		LPTSTR temp;
		CredentialUser(credentials, &temp);
		SetWindowText(hwnd, (LPCTSTR)temp);
	}
}


//---------------------------------------------------------
void WarnAboutLocalMachine(HWND hwndDlg)
{
	TCHAR caption[50] = {0}, threat[100] = {0};
	HWND hwnd = GetDlgItem(hwndDlg, IDC_NAME);

	::LoadString(_Module.GetResourceInstance(),
					IDS_SHORT_NAME, caption, 50);
	::LoadString(_Module.GetResourceInstance(),
					IDS_USE_RADIO, threat, 100);

	MessageBox(hwndDlg, threat, caption, 
				MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

	SendMessage(hwnd, EM_SETSEL, 0, -1);
	SendMessage(hwnd, EM_REPLACESEL, 0, (LPARAM)"");
	SendMessage(hwnd, EM_SETSEL, -1, 0);

	CheckRadioButton(hwndDlg, IDC_LOCAL, IDC_REMOTE, IDC_LOCAL);

	hwnd = GetDlgItem(hwndDlg, IDC_LOCAL);

	SendMessage(hwndDlg, WM_COMMAND, 
					MAKEWPARAM(IDC_LOCAL, BN_CLICKED),
					(LPARAM)hwnd);
	SetFocus(hwnd);
}

//---------------------------------------------------------
bool LocalMachineName(LPCTSTR buf)
{
	TCHAR name[64] = {0};
	DWORD size = 64;
	bool retval = false;
	UINT len = _tcslen(buf);

	if(GetComputerName(name, &size))
	{
		if((_tcslen(buf) >= 2) && 
		   (buf[1] == _T('\\')))
		{
			// ignore the leading whacks.
			retval = (_tcsicmp(&buf[2], name) == 0);
		}
		else if( ((len == 1) && (buf[0] == _T('.'))) ||
			((len == 3) && (buf[2] == _T('.')))
		  )
		{
			retval = true;
		}
		else
		{
			retval = (_tcsicmp(buf, name) == 0);
		}
	}
	return retval;
}

//---------------------------------------------------------
const static DWORD connDlgHelpIDs[] = {  // Context Help IDs
	IDC_CONN_FRAME,		IDH_WMI_EXE_GENERAL_CHGCOMP_CONNECTTO,
	IDC_LOCAL,			IDH_WMI_EXE_GENERAL_CHGCOMP_CONNECTTO,
	IDC_REMOTE,			IDH_WMI_EXE_GENERAL_CHGCOMP_CONNECTTO,
	IDC_NAME,			IDH_WMI_EXE_GENERAL_CHGCOMP_CONNECTTO,
	IDC_LOGON,			IDH_WMI_CTRL_GENERAL_CHANGE_BUTTON,
    0, 0};

INT_PTR CALLBACK ConnDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{ //BEGIN
			CUIHelpers *me = (CUIHelpers *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			CONN_NAME *name = 0;

			if(me == 0)
			{
				me = (CUIHelpers *)lParam;
				SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
			}

			name = (CONN_NAME *)&(me->m_cfg);

			if(me->m_ImaWizard)
			{
				::PropSheet_SetWizButtons(::GetParent(hwndDlg), PSWIZB_FINISH);
			}

            BOOL local = *(name->local);

    		::EnableWindow(GetDlgItem(hwndDlg, IDC_LOCAL),TRUE);
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_REMOTE),TRUE);
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_NAME), !local);

	

			CheckRadioButton(hwndDlg, IDC_LOCAL, IDC_REMOTE, 
								(local ? IDC_LOCAL : IDC_REMOTE));			
			HWND hName = GetDlgItem(hwndDlg, IDC_NAME);
			SendMessage(hName, EM_LIMITTEXT, MAXCOMPUTER_NAME, 0);
			SetWindowText(hName, name->lpName);
			
            
				BOOL enableOK = (GetWindowTextLength(hName) != 0);
				::EnableWindow(GetDlgItem(hwndDlg, IDOK), enableOK);

				// deal with the user account.
				SetUserAccount(hwndDlg, name->credentials);

				if(!local)
				{
					::SetFocus(GetDlgItem(hwndDlg, IDC_NAME));
					return FALSE;
				}
		} //END
		retval = TRUE;
		break;

	case WM_NOTIFY:
		{
			switch(((NMHDR FAR *) lParam)->code) 
			{
			case PSN_WIZFINISH:
				{
					CUIHelpers *me = (CUIHelpers *)GetWindowLongPtr(hwndDlg, DWLP_USER);
					CONN_NAME *name = (CONN_NAME *)&(me->m_cfg);

					*(name->local) = (IsDlgButtonChecked(hwndDlg, IDC_LOCAL) == BST_CHECKED ?true:false);

					if(*(name->local) == false)
					{
						GetWindowText(GetDlgItem(hwndDlg, IDC_NAME), name->lpName, name->cName);
					}
				}
				break;

			default: break;
			}
		}
		break;

	case WM_COMMAND:
		{
			// they're only one button.
			CUIHelpers *me = (CUIHelpers *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			CONN_NAME *name = (CONN_NAME *)&(me->m_cfg);

			switch(LOWORD(wParam))
			{
			case IDC_LOCAL:
				{
					::EnableWindow(GetDlgItem(hwndDlg, IDC_NAME), FALSE);
//					::EnableWindow(GetDlgItem(hwndDlg, IDC_LOGON), FALSE);
					BOOL local = (IsDlgButtonChecked(hwndDlg, IDC_LOCAL) == BST_CHECKED);
					int len = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_NAME));
					BOOL enableOK = local || (len != 0);
					::EnableWindow(GetDlgItem(hwndDlg, IDOK), enableOK);
				}
				break;

			case IDC_REMOTE:
				{
					::EnableWindow(GetDlgItem(hwndDlg, IDC_NAME), TRUE);
//					::EnableWindow(GetDlgItem(hwndDlg, IDC_LOGON), TRUE);
					BOOL local = (IsDlgButtonChecked(hwndDlg, IDC_LOCAL) == BST_CHECKED);
					int len = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_NAME));
					BOOL enableOK = local || (len != 0);
					::EnableWindow(GetDlgItem(hwndDlg, IDOK), enableOK);
				}
				break;

			case IDC_NAME:
					switch(HIWORD(wParam))
					{
					case EN_CHANGE:
						{
							BOOL local = (IsDlgButtonChecked(hwndDlg, IDC_LOCAL) == BST_CHECKED);
							int len = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_NAME));
							BOOL enableOK = local || (len != 0);
							if(len)
							{
								TCHAR buf[MAXCOMPUTER_NAME + 1] = {0};
								HWND hwnd = GetDlgItem(hwndDlg, IDC_NAME);
								GetWindowText(hwnd, buf, MAXCOMPUTER_NAME + 1);
							}
							::EnableWindow(GetDlgItem(hwndDlg, IDOK), enableOK);
						}
						break;

					default: break;
					} //end switch HIWORD(wParam)
				break;

        /*********************
        disabling third party logon
             case IDC_LOGON:
				if(DisplayLoginDlg(hwndDlg, name->credentials) == IDOK)
				{
					HWND hwnd = GetDlgItem(hwndDlg, IDC_ACCOUNT);
					if(name->credentials->currUser)
					{
						CHString1 name;
						name.LoadString(IDS_CURRENT_USER);
						SetWindowText(hwnd, (LPCTSTR)name);
					}
					else if(name->credentials->authIdent->UserLength != 0)
					{
						LPTSTR temp;
						CredentialUser(name->credentials, &temp);
						if(_tcslen(temp) > 0)
						{
							SetWindowText(hwnd, (LPCTSTR)temp);
						}
					}
				} //endif DisplayLoginDlg()
				break;
        *******************/
			case IDOK:

				*(name->local) = (IsDlgButtonChecked(hwndDlg, IDC_LOCAL) == BST_CHECKED ?true:false);

				if(*(name->local) == false)
				{
					HWND hwnd = GetDlgItem(hwndDlg, IDC_NAME);
					GetWindowText(hwnd, name->lpName, name->cName);

					if(LocalMachineName(name->lpName))
					{
						WarnAboutLocalMachine(hwndDlg);
						return TRUE;
					}
				}
				else
				{
					name->credentials->currUser = true;

					WbemFreeAuthIdentity(name->credentials->authIdent);
					name->credentials->authIdent = 0;
					memset(name->credentials->fullAcct, 0, 100 * sizeof(TCHAR));
				}
				EndDialog(hwndDlg, IDOK);
				break;

			case IDCANCEL:
				EndDialog(hwndDlg, IDCANCEL);
				break;

			default:
				return(FALSE);
			} // switch
		}
        break;

    case WM_HELP:
        if(IsWindowEnabled(hwndDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)connDlgHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if(IsWindowEnabled(hwndDlg))
        {
            WinHelp(hwndDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)connDlgHelpIDs);
        }
        break;

	default:
		retval = FALSE; // I did NOT process this msg.
		break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
INT_PTR CUIHelpers::DisplayCompBrowser(HWND hWnd,
									LPTSTR lpName,
									UINT cName,
									bool *local,
									LOGIN_CREDENTIALS *credentials)
{
	CUIHelpers dummy(NULL, NULL, false);
	dummy.m_cfg.lpName = lpName;
	dummy.m_cfg.cName = cName;
	dummy.m_cfg.local = local;
	dummy.m_cfg.credentials = credentials;

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_CONNECT), 
							hWnd, ConnDlgProc, 
							(LPARAM)&dummy);
}

//=======================================================================
ConnectPage::ConnectPage(DataSource *ds, bool htmlSupport) :
				CUIHelpers(ds, &(ds->m_rootThread), htmlSupport)
{
	m_isLocal = true;
	m_ImaWizard = true;

    std::auto_ptr<TCHAR> AutoTchar (new TCHAR[256]);
	m_cfg.lpName = AutoTchar.get();

    if( m_cfg.lpName ) {
        memset(m_cfg.lpName, 0, 256 * sizeof(TCHAR));
	    m_cfg.cName = 256;
        std::auto_ptr<bool> AutoBool (new bool);
        m_cfg.local = AutoBool.get();
        if(m_cfg.local) {
	        *m_cfg.local = m_isLocal;
        }
        AutoBool.release();
	    m_cfg.credentials = m_DS->GetCredentials();
    }
    AutoTchar.release();
}

//-------------------------------------------------------------------------
ConnectPage::~ConnectPage(void)
{
	if(m_cfg.lpName)
	{
		delete m_cfg.lpName;
	}
}

//------------------------------------------------------------------------
BOOL ConnectPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL retval = false;

	retval = (BOOL)ConnDlgProc(hDlg, uMsg, wParam, lParam);

	if((uMsg == WM_NOTIFY && 
		((NMHDR FAR *) lParam)->code == PSN_WIZFINISH))
	{
		if(*m_cfg.local)
		{
			// an empty string will cause a local connection.
			m_cfg.lpName[0] = '\0';
		}
		m_DS->SetMachineName(CHString1(m_cfg.lpName));
	}
	return retval;
}

//=======================================================================
void CUIHelpers::HTMLHelper(HWND hDlg)   
{
	if(m_htmlSupport)
	{
		TCHAR helpDir[_MAX_PATH+100] = {0}; //make room for additions below

		if(GetWindowsDirectory(helpDir, _MAX_PATH+1) != 0)
		{
			_tcscat(helpDir, _T("\\Help"));

#ifdef SNAPIN
			_tcscat(helpDir, _T("\\newfeat1.chm::wmi_control_overview.htm"));
#else
			_tcscat(helpDir, _T("\\WbemCntl.chm::wmi_control_overview.htm"));
#endif

			HWND hwnd = HtmlHelp(NULL, helpDir, HH_DISPLAY_TOPIC, NULL);
			if(hwnd == 0)
			{
				CHString1 caption, threat;
				caption.LoadString(IDS_SHORT_NAME);
				threat.LoadString(IDS_NO_HELP);
				MessageBox(hDlg, threat, caption, MB_OK|MB_ICONWARNING);
			}
		}
	}
	else
	{
		CHString1 caption, threat;
		caption.LoadString(IDS_SHORT_NAME);
		threat.LoadString(IDS_NO_HHCTRL);
		MessageBox(hDlg, threat, caption, MB_OK|MB_ICONWARNING);

	} //endif m_htmlSupport
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\wbemerror.cpp ===
//=============================================================================
//
//                              WbemError.cpp
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//	Implements string table based, error msgs for all of wbem.
//
//  History:
//
//      a-khint  5-mar-98       Created.
//
//============================================================================= 
#include "precomp.h"
#include "WbemError.h"
#include "resource.h"
#include <wbemcli.h>
#include <stdio.h>

//--------------PUBLIC-----------------------------
#define TEMP_BUF 512

POLARITY bool ErrorStringEx(HRESULT hr, 
						   TCHAR *errMsg, UINT errSize,
						   UINT *sevIcon)
{
    TCHAR szError[TEMP_BUF] = {0};
	TCHAR szFacility[TEMP_BUF] = {0};
    TCHAR szFormat[100] = {0};
	IWbemStatusCodeText * pStatus = NULL;

    // initialize buffers.
	errMsg[0] = 0;
	szFacility[0] = 0;
	szError[0] = 0;

	HRESULT hr1 = CoInitialize(NULL);
	SCODE sc1 = CoCreateInstance(CLSID_WbemStatusCodeText, 
								0, CLSCTX_INPROC_SERVER,
								IID_IWbemStatusCodeText, 
								(LPVOID *) &pStatus);

	// loaded OK?
	if(sc1 == S_OK)
	{
		BSTR bstr = 0;
		sc1 = pStatus->GetErrorCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
#ifdef UNICODE
			wcsncpy(szError, bstr, TEMP_BUF-1);
			size_t x = wcslen(szError);
#else
			size_t x = wcstombs(szError, bstr, TEMP_BUF-1);
#endif
			szError[x-2] = _T('\0');
			SysFreeString(bstr);
			bstr = 0;
		}

		sc1 = pStatus->GetFacilityCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
#ifdef UNICODE
			wcsncpy(szFacility, bstr, TEMP_BUF-1);
			size_t x = wcslen(szFacility);
#else
			wcstombs(szFacility, bstr, TEMP_BUF-1);
#endif
			SysFreeString(bstr);
			bstr = 0;
		}

		// RELEASE
		pStatus->Release();
		pStatus = NULL;
	}
	else
	{
		::MessageBox(NULL, _T("WMI error features not available. Upgrade WMI to a newer build."),
					 _T("Internal Error"), MB_ICONSTOP|MB_OK);
	}

	// if not msgs returned....
	if(_tcslen(szFacility) == 0 || _tcslen(szError) == 0)
	{
		// format the error nbr as a reasonable default.
		LoadString(_Module.GetModuleInstance(), IDS_ERROR_UNKN_ERROR_FMT, szFormat, 99);
		_stprintf(errMsg, szFormat, hr);
	}
	else
	{
		// format a readable msg.
		LoadString(_Module.GetModuleInstance(), IDS_ERROR_FMT, szFormat, 99);
		_stprintf(errMsg, szFormat, szFacility, szError);
	}

	// want an icon recommendation with that?
	if(sevIcon)
	{
		switch(SCODE_SEVERITY(hr))
		{
		case 0: // - Success
			*sevIcon = MB_ICONINFORMATION;
			break;
		case 1: //- Failed
			*sevIcon = MB_ICONEXCLAMATION;
			break;
		} //endswitch severity

	} //endif sevIcon

	if(hr1 == S_OK)
		CoUninitialize();

	return (SUCCEEDED(sc1) && SUCCEEDED(hr1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\wmictrsdlg.cpp ===
// WmiCtrsDlg.cpp : implementation file
//

#include "precomp.h"
#include "WmiCtrsDlg.h"
#include "resource.h"
#include <process.h>
#include <util.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

WCHAR g_szCounters[][40] = {	L"Connections",
								L"DeliveryBackupBytes",
								L"InternalObjects",
								L"InternalSinks",
								L"TasksInProgress",
								L"TasksWaiting",
								L"TotalAPIcalls",
								L"Users"
							};

UINT g_uCtrIds[] =			{	IDC_CONNECTIONS,  
								IDC_DELBACKUP,   
								IDC_INTERNALOBJS, 
								IDC_INTERNALSINKS,
								IDC_TASKSINPROG,  
								IDC_TASKSWAITING, 
								IDC_TOTALAPICALLS,
								IDC_USERS        
							};

/////////////////////////////////////////////////////////////////////////////
// WmiCtrsDlg dialog

CWmiCtrsDlg::CWmiCtrsDlg()
{
	m_pCredentials = NULL;
	_tcscpy(m_szMachineName,_T(""));
	m_pDlg = NULL;
	m_hWndBusy = NULL;
}

CWmiCtrsDlg::CWmiCtrsDlg(LPCTSTR szMachineName, LOGIN_CREDENTIALS *pCredentials)
{
	m_pCredentials = pCredentials;
	_tcsncpy(m_szMachineName,szMachineName,ARRAYSIZE(m_szMachineName));
	m_pDlg = NULL;
	m_hWndBusy = NULL;
}

CWmiCtrsDlg::~CWmiCtrsDlg()
{
	if(m_pDlg != NULL)
		delete m_pDlg;
	
	if(m_hWndBusy != NULL)
	{
		//Now close the busy Dialog
		SendMessage(*(m_hWndBusy),WM_CLOSE_BUSY_DLG,0,0);
		delete m_hWndBusy;
	}
}

INT_PTR CWmiCtrsDlg::DoModal(HWND hWnd)
{
	m_bRun = true;
	INT_PTR retVal = DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_WMICTR), 
							hWnd, CtrDlgProc, 
							(LPARAM)this);

	m_bRun = false;
	return retVal;
}

INT_PTR CALLBACK CtrDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
	INT_PTR retVal = TRUE;
	CWmiCtrsDlg *pDlg = (CWmiCtrsDlg *)lParam;
	switch(uMsg)
	{
		case WM_INITDIALOG:
		{ 
			pDlg->InitDlg(hwndDlg);
			break;
		}
		case WM_COMMAND :
		{
			switch(LOWORD(wParam))
			{
				case IDOK:
				{
					EndDialog(hwndDlg, IDOK);
					break;
				}
				case IDCANCEL:
				{
					EndDialog(hwndDlg, IDCANCEL);
					break;
				}
				default:
					retVal = FALSE;
			}
			break;
		}
		default:
		{
			retVal = FALSE;
			break;
		}
	}
	return retVal;
}

/////////////////////////////////////////////////////////////////////////////
// CWmiCtrsDlg message handlers

DWORD WINAPI CountersThread(LPVOID lpParameter)
{
	CoInitialize(NULL);
	
	CWmiCtrsDlg *pDlg = (CWmiCtrsDlg *)lpParameter;

	CWbemServices Services;

	TCHAR nameSpace[1024];

	// if machine is whacked already...
	if(_tcsncmp(pDlg->m_szMachineName, _T("\\"), 1) == 0)
	{
		// use it.
		_tcscpy(nameSpace,pDlg->m_szMachineName);
		_tcscat(nameSpace,_T("\\root\\CimV2"));
	}
	else if(_tcslen(pDlg->m_szMachineName) > 0)
	{
		// whack it myself.
		_tcscpy(nameSpace,_T("\\\\"));
		_tcscat(nameSpace,pDlg->m_szMachineName);
		_tcscat(nameSpace,_T("\\root\\CimV2"));
	}
	else
	{
		_tcscpy(nameSpace,_T("root\\CimV2"));
	}

	HRESULT hr = Services.ConnectServer(nameSpace,pDlg->m_pCredentials);

	if(FAILED(hr))
	{
		//Display a MessageBox to the user that the connection has been failed
		pDlg->DisplayErrorMessage(IDC_ERROR_CONNECT);
		return 0;
	}
	
	//Now try to Get the instances of the class Win32_PerfRawData_WinMgmt_WINMGMTCounters
	IEnumWbemClassObject *Enum = NULL;
	ULONG uReturned;
	
	IWbemClassObject *pInst = NULL;
	hr = Services.CreateInstanceEnum(L"Win32_PerfRawData_WinMgmt_WINMGMTCounters",
													WBEM_FLAG_SHALLOW,
													&Enum);

	if(SUCCEEDED(hr))
	{
		// get the first and only instance.
		Enum->Next(-1, 1, &pInst, &uReturned);
		Enum->Release();
	}
	else
	{
		pDlg->DisplayErrorMessage(IDC_ERROR_ENUM);
		return 0;
	}

	if(pDlg->m_hWndBusy != NULL)
	{
		//Now close the nusy Dialog
		SendMessage(*(pDlg->m_hWndBusy),WM_CLOSE_BUSY_DLG,0,0);
	}

	int i;
	VARIANT vt;
	TCHAR strVal[1024];
	VariantInit(&vt);

	while(pDlg->m_bRun == true)
	{
		for(i=0; i < NUM_COUNTERS; i++)
		{
			VariantClear(&vt);
			hr = pInst->Get(g_szCounters[i],0,&vt,NULL,NULL);
/*			if(FAILED(hr))
			{
				::MessageBox(NULL,_T("error"),_T("Unable to get"),MB_OK);
			}
*/			_itot(vt.lVal,strVal,10);
			SetWindowText(pDlg->m_hWndCounters[i],strVal);
		}

		Sleep(900);
	}

	Services.DisconnectServer();

	return 1;
}

void CWmiCtrsDlg::InitDlg(HWND hDlg)
{
	DWORD dwThreadId;
	
	//Do the member Initializations
	m_pDlg = new HWND;
	if (!m_pDlg)
    		return;
	*m_pDlg = hDlg;
	m_hWndBusy = new HWND;
	::LoadString(_Module.GetModuleInstance(), IDC_ERROR_CAPTION, m_szError, 100);

	for(int i=0;i < NUM_COUNTERS; i++)
	{
		m_hWndCounters[i] = GetDlgItem(hDlg,g_uCtrIds[i]);
	}

	m_hThread = CreateThread(NULL,0,CountersThread,(LPVOID)this,0,&dwThreadId);

	//Now Display the "Connecting to WMI" Dialog
	DisplayBusyDialog(hDlg);
}

void CWmiCtrsDlg::DisplayErrorMessage(UINT ErrorId)
{

	TCHAR szErrorText[1024];
	if(m_hWndBusy != NULL)
	{
		//Now close the busy Dialog
		SendMessage(*(m_hWndBusy),WM_CLOSE_BUSY_DLG,0,0);
	}
	::LoadString(_Module.GetModuleInstance(), ErrorId, szErrorText, 1024);
	EndDialog(*m_pDlg,IDCANCEL);
	::MessageBox(NULL,szErrorText,m_szError,MB_OK);
}	

INT_PTR CALLBACK BusyDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
		case WM_INITDIALOG:
		{//BEGIN
			//lParam = ANIMCONFIG *
			CWmiCtrsDlg *pDlg = (CWmiCtrsDlg *)lParam;
			SetWindowLongPtr(hwndDlg, DWLP_USER, (LPARAM)pDlg);
			*(pDlg->m_hWndBusy) = hwndDlg;

			HWND hAnim = GetDlgItem(hwndDlg, IDC_ANIMATE);
			HWND hMsg = GetDlgItem(hwndDlg, IDC_MSG);

			Animate_Open(hAnim, MAKEINTRESOURCE(IDR_AVIWAIT));

			TCHAR caption[100] = {0}, msg[256] = {0};

			::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, caption, 100);

			::LoadString(_Module.GetModuleInstance(), IDS_CONNECTING, msg, 256);

			SetWindowText(hwndDlg, caption);
			SetWindowText(hMsg, msg);

			retval = TRUE;
			break;
		}
		case WM_CLOSE_BUSY_DLG:
		{
			HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			*me = 0;
			EndDialog(hwndDlg, IDCANCEL);
			break;
		}
		case WM_COMMAND:
		{
			// they're only one button.
			if(HIWORD(wParam) == BN_CLICKED)
			{
				// I'm going away now so anybody that has a ptr to my
				// hwnd (which I gave out in my WM_INITDIALOG) shouldn't
				// use it anymore.
				HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
				*me = 0;
				EndDialog(hwndDlg, IDCANCEL);
			}
			retval = TRUE; // I processed it.
			break;
		}
		case WM_DESTROY:
		{// BEGIN
			// I'm going away now so anybody that has a ptr to my
			// hwnd (which I gave out in my WM_INITDIALOG) shouldn't
			// use it anymore.
			HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			*me = 0;
			retval = TRUE; // I processed it.
			break;
		} //END
		default:
		{
			retval = FALSE; // I did NOT process this msg.
			break;
		}
	} //endswitch uMsg

	return retval;
}

INT_PTR CWmiCtrsDlg::DisplayBusyDialog(HWND hWnd)
{
	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_ANIMATE), 
							NULL, BusyDlgProc, 
							(LPARAM)this);
}

void CWmiCtrsDlg::CloseBusyDialog()
{
	if(m_hWndBusy != NULL)
	{
		//Now close the nusy Dialog
		SendMessage(*(m_hWndBusy),WM_CLOSE_BUSY_DLG,0,0);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\wmictrsdlg.h ===
#if !defined(AFX_WMICTRSDLG_H__676668D2_5328_47AA_B52D_C85A39D60E7D__INCLUDED_)
#define AFX_WMICTRSDLG_H__676668D2_5328_47AA_B52D_C85A39D60E7D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WmiCtrsDlg.h : header file
//
#include "SshWbemHelpers.h"

#define NUM_COUNTERS	8
#define WM_CLOSE_BUSY_DLG	WM_USER+1976

INT_PTR CALLBACK CtrDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

DWORD WINAPI CountersThread(LPVOID lpParameter);

INT_PTR CALLBACK BusyDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

typedef struct {
	bool currUser;
	COAUTHIDENTITY *authIdent;
	TCHAR fullAcct[100];
} CREDENTIALS;

class CWmiCtrsDlg
{
// Construction
public:
	CWmiCtrsDlg();
    CWmiCtrsDlg(LPCTSTR szMachineName, LOGIN_CREDENTIALS *credentials);
    virtual ~CWmiCtrsDlg(void);

	friend INT_PTR CALLBACK CtrDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

	friend DWORD WINAPI CountersThread(LPVOID lpParameter);

	friend INT_PTR CALLBACK BusyDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

	INT_PTR DoModal(HWND hWnd);

	INT_PTR DisplayBusyDialog(HWND hWnd);
	void CloseBusyDialog();

protected:
    void InitDlg(HWND hDlg);
	void DisplayErrorMessage(UINT ErrorId);

	bool m_bRun;
	HANDLE m_hThread;
	TCHAR m_szMachineName[MAX_COMPUTERNAME_LENGTH + 2]; //just in case it doesn't include wacks
	LOGIN_CREDENTIALS *m_pCredentials;
	HWND *m_pDlg;
	HWND *m_hWndBusy;
	TCHAR m_szError[1024];
	HWND m_hWndCounters[NUM_COUNTERS];
};

#endif // !defined(AFX_WMICTRSDLG_H__676668D2_5328_47AA_B52D_C85A39D60E7D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\wmictrsysmondlg.h ===
// WMICtrSysmonDlg.h : Declaration of the CWMICtrSysmonDlg

#ifndef __WMICTRSYSMONDLG_H_
#define __WMICTRSYSMONDLG_H_

#include "resource.h"       // main symbols
#include <atlwin.h>
#include <util.h>
#include "sysmon.tlh"	//#import "d:\\winnt\\system32\\sysmon.ocx"
#include "WmiCtrsDlg.h"
using namespace SystemMonitor;

enum eStatusInfo
{
	Status_CounterNotFound,
	Status_Success
};

/////////////////////////////////////////////////////////////////////////////
// CWMICtrSysmonDlg
class CWMICtrSysmonDlg : 
	public CAxDialogImpl<CWMICtrSysmonDlg>
{
protected:
	TCHAR m_strMachineName[MAX_COMPUTERNAME_LENGTH + 2];
	eStatusInfo m_eStatus;
	HANDLE m_hThread;
public:
	HWND *m_hWndBusy;

	CWMICtrSysmonDlg();
	CWMICtrSysmonDlg(LPCTSTR strMachName);
	~CWMICtrSysmonDlg();

	enum { IDD = IDD_WMICTR_SYSMON };

	BEGIN_MSG_MAP(CWMICtrSysmonDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER(IDOK, OnOK)
		COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	END_MSG_MAP()

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	eStatusInfo GetStatus() { return m_eStatus; }

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	friend INT_PTR CALLBACK BusyAVIDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

	friend DWORD WINAPI BusyThread(LPVOID lpParameter);

	void DisplayBusyDialog();
	void CloseBusyDialog();

};

#endif //__WMICTRSYSMONDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\wmihelp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//Map file for WMI Control tabs and dialog boxes

//GENERAL tab
#define IDH_WMI_CTRL_GENERAL_CONNECTED_AS	7101
#define IDH_WMI_CTRL_GENERAL_CHANGE_BUTTON	7102
#define IDH_WMI_CTRL_GENERAL_DISPLAY_INFO	7103

//GENERAL tab for exe
#define IDH_WMI_EXE_GENERAL_CONNECTED_TO	7105
#define IDH_WMI_EXE_GENERAL_CHANGE_BUTTON	7106
#define IDH_WMI_EXE_GENERAL_CHGCOMP_CONNECTTO	7111

//WMI Login dialog
#define IDH_WMI_CTRL_GENERAL_WMILOGIN_CHECKBOX	7121
#define IDH_WMI_CTRL_GENERAL_WMILOGIN_USERNAME	7122
#define IDH_WMI_CTRL_GENERAL_WMILOGIN_PASSWORD	7123

//LOGGING tab
#define IDH_WMI_CTRL_LOGGING_LOGGING_LEVEL	7201
#define IDH_WMI_CTRL_LOGGING_MAX_SIZE		7202
#define IDH_WMI_CTRL_LOGGING_LOCATION		7203
#define IDH_WMI_CTRL_LOGGING_BROWSE		7204

//BACKUP/RESTORE tab
#define IDH_WMI_CTRL_BACKUP_AUTOMATIC_CHECKBOX	7301
#define IDH_WMI_CTRL_BACKUP_TIME		7302
#define IDH_WMI_CTRL_BACKUP_MINUTES_HOURS	7303
#define IDH_WMI_CTRL_BACKUP_LAST		7304
#define IDH_WMI_CTRL_BACKUP_RESTORE_AUTO	7305
#define IDH_WMI_CTRL_BACKUP_BACKUP_MANUAL	7306
#define IDH_WMI_CTRL_BACKUP_RESTORE_MANUAL	7307

//SECURITY tab
#define IDH_WMI_CTRL_SECURITY_NAMESPACE_BOX	7401
#define IDH_WMI_CTRL_SECURITY_SECURITY_BUTTON	7402

//Security dialog
#define IDH_WMI_CTRL_SECURITY_NAMEBOX		7411
#define IDH_WMI_CTRL_SECURITY_ADD_BUTTON	7412
#define IDH_WMI_CTRL_SECURITY_REMOVE_BUTTON	7413
#define IDH_WMI_CTRL_SECURITY_PERMISSIONSLIST	7414

//ADVANCED tab
#define IDH_WMI_CTRL_ADVANCED_REPOSITORY_LOC	7501
#define IDH_WMI_CTRL_ADVANCED_SCRIPTING_PATH	7502
#define IDH_WMI_CTRL_ADVANCED_CHANGE_BUTTON	7503
#define IDH_WMI_CTRL_ADVANCED_ASP_ACCESS	7504
#define IDH_WMI_CTRL_ADVANCED_ENABLE_CONNECT	7505
#define IDH_WMI_CTRL_ADVANCED_RESTART_BOX	7506

//Browser for Namespace dialog
#define IDH_WMI_CTRL_ADVANCED_CHANGE_NAMESPACE	7511
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\wmictrsysmondlg.cpp ===
// WMICtrSysmonDlg.cpp : Implementation of CWMICtrSysmonDlg
#include "precomp.h"
#include "WMICtrSysmonDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CWMICtrSysmonDlg

CWMICtrSysmonDlg::CWMICtrSysmonDlg()
{
	_tcscpy(m_strMachineName,_T(""));
	m_eStatus = Status_Success;
	m_hWndBusy = new HWND;
}

CWMICtrSysmonDlg::CWMICtrSysmonDlg(LPCTSTR strMachName)
{
	_tcsncpy(m_strMachineName,strMachName, ARRAYSIZE(m_strMachineName));
	m_eStatus = Status_Success;
	m_hWndBusy = new HWND;
}

CWMICtrSysmonDlg::~CWMICtrSysmonDlg()
{
	if(m_hWndBusy != NULL)
	{
		SendMessage(*(m_hWndBusy),WM_CLOSE_BUSY_DLG,0,0);
		delete m_hWndBusy;
	}
}

LRESULT CWMICtrSysmonDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	CWmiCtrsDlg pDlg;
	DisplayBusyDialog();
	TCHAR strCtr[1024];
	ISystemMonitor *pSysMon = NULL;
	HRESULT hr = GetDlgControl(IDC_SYSMON_OCX,__uuidof(ISystemMonitor)/*IID_ISystemMonitor*/,(void **)&pSysMon);
	if(SUCCEEDED(hr))
	{
		ICounters *pCounters = NULL;
		pCounters = pSysMon->GetCounters();
		try
		{
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Connections"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Delivery Backup (Bytes)"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Internal Objects"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Internal Sinks"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Tasks In Progress"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Tasks Waiting"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Total API calls"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Users"));
			pCounters->Add(strCtr);
			CloseBusyDialog();
		}
		catch(...)
		{
			m_eStatus = Status_CounterNotFound;
			CloseBusyDialog();
			EndDialog(0);
		}
	}
/*	else
	{
		MessageBox(_T("Could not get the Interface Pointer"),_T("Failure"));
	}
*/
	return 1;  // Let the system set the focus
}

LRESULT CWMICtrSysmonDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	EndDialog(wID);
	return 0;
}

LRESULT CWMICtrSysmonDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	EndDialog(wID);
	return 0;
}

void CWMICtrSysmonDlg::DisplayBusyDialog()
{
	DWORD dwThreadId;
	m_hThread = CreateThread(NULL,0,BusyThread,(LPVOID)this,0,&dwThreadId);

}

DWORD WINAPI BusyThread(LPVOID lpParameter)
{
	CWMICtrSysmonDlg *pDlg = (CWMICtrSysmonDlg *)lpParameter;

	INT_PTR ret = DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_ANIMATE), 
							NULL, BusyAVIDlgProc, 
							(LPARAM)pDlg);

	return (DWORD) ret;
}
void CWMICtrSysmonDlg::CloseBusyDialog()
{
	if(m_hWndBusy != NULL)
	{
		//Now close the busy Dialog
		::SendMessage(*(m_hWndBusy),WM_CLOSE_BUSY_DLG,0,0);
	}

	::SetForegroundWindow(this->m_hWnd);
}

INT_PTR CALLBACK BusyAVIDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
		case WM_INITDIALOG:
		{//BEGIN
			//lParam = ANIMCONFIG *
			CWMICtrSysmonDlg *pDlg = (CWMICtrSysmonDlg *)lParam;
			SetWindowLongPtr(hwndDlg, DWLP_USER, (LPARAM)pDlg);
			*(pDlg->m_hWndBusy) = hwndDlg;

			HWND hAnim = GetDlgItem(hwndDlg, IDC_ANIMATE);
			HWND hMsg = GetDlgItem(hwndDlg, IDC_MSG);

			Animate_Open(hAnim, MAKEINTRESOURCE(IDR_AVIWAIT));

			TCHAR caption[100] = {0}, msg[256] = {0};

			::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, caption, 100);

			::LoadString(_Module.GetModuleInstance(), IDS_CONNECTING, msg, 256);

			SetWindowText(hwndDlg, caption);
			SetWindowText(hMsg, msg);

			retval = TRUE;
			break;
		}
		case WM_CLOSE_BUSY_DLG:
		{
			EndDialog(hwndDlg, IDCANCEL);
			break;
		}
		case WM_COMMAND:
		{
			// they're only one button.
			if(HIWORD(wParam) == BN_CLICKED)
			{
				EndDialog(hwndDlg, IDCANCEL);
			}
			retval = TRUE; // I processed it.
			break;
		}
		case WM_DESTROY:
		{// BEGIN
			retval = TRUE; // I processed it.
			break;
		} //END
		default:
		{
			retval = FALSE; // I did NOT process this msg.
			break;
		}
	} //endswitch uMsg

	return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\snapin\wmicntl.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// WMICntl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f WMICntlps.mk in the project directory.

#include "precomp.h"
#include "..\resource.h"
#include <initguid.h>
#include "WMICntl.h"

#include "WMICntl_i.c"
#include "WMISnapin.h"


//CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WMISnapin, CWMISnapin)
OBJECT_ENTRY(CLSID_WMISnapinAbout, CWMISnapinAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
		CSnapInItem::Init();
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\precomp.h ===
#pragma warning (disable : 4786)
// #include <windows.h>
#include <objidl.h>
extern long g_cLock;
extern long g_cObj;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\snapin\wmisnapin.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __WMISNAPIN_H_
#define __WMISNAPIN_H_
#include "..\resource.h"
#include "atlwin.h"
#include "atlsnap.h"
#include "CHString1.h"
#include "UIHelpers.h"
#include "..\datasrc.h"
#include "WMICtrSysmonDlg.h"
#include "WmiCtrsDlg.h"
#include <util.h>

#define DBG_PRINTFA( a ) { char pBuff[256]; sprintf a ; OutputDebugStringA(pBuff); }

class CWMISnapinExtData;
class CWMISnapinExtData;

class CWMISnapinData : public CSnapInItemImpl<CWMISnapinData>,
						public CComObject<CSnapInDataObjectImpl>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;
	bool m_extension;
	DataSource *g_DS;
	wchar_t m_initMachineName[MAXCOMPUTER_NAME + 1];
	TCHAR m_MachineName[MAXCOMPUTER_NAME + 1];


	CWMISnapinData(bool extension = false);

	~CWMISnapinData()
	{
		if(g_DS)
		{
			g_DS->Release();
            g_DS = NULL;
		}
	}

	SNAPINMENUID(IDR_MENU_MENU);

/*	const UINT GetMenuID()
	{ 
		return m_MenuId; 
	}

	void SetMenuID(UINT menuId)
	{
		m_MenuId = menuId;
	}
*/
	STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
							long *pInsertionAllowed,
							DATA_OBJECT_TYPES type)
	{
		if(m_myID == 0 || m_extension)
		{
			//return CSnapInItemImpl<CWMISnapinData>::AddMenuItems(piCallback, pInsertionAllowed,type);
			return S_OK;
		}
		else
		{
			return CSnapInItemImpl<CWMISnapinData>::AddMenuItems(piCallback, pInsertionAllowed,type);
		}
	}

    STDMETHOD(Command)(long lCommandID,		
						CSnapInObjectRootBase* pObj,		
						DATA_OBJECT_TYPES type)
	{
		HRESULT hr = S_OK;
		if(type == CCT_SCOPE)
		{
			switch(lCommandID)
			{
			case ID_TOP_RECONNECT:
				{
					if(m_myID == 0)
					{
					}
					else
					{
						TCHAR name[MAXCOMPUTER_NAME + 1] = {0};
						bool isLocal = g_DS->IsLocal();
						LOGIN_CREDENTIALS *credentials = g_DS->GetCredentials();


						INT_PTR x = CUIHelpers::DisplayCompBrowser(NULL,
							                                    name, 
													            sizeof(name)/sizeof(name[0]), 
													            &isLocal, 
													            credentials);
						if(x == IDOK)
						{
    	                    if (g_DS)
							{
                                g_DS->ClosePropSheet();        
								g_DS->Disconnect();
							}
                            
                            if(isLocal)
							{
								// an empty string will cause a local connection.
								name[0] = '\0';
							}
							_tcscpy(m_MachineName,name);
							g_DS->SetMachineName(CHString1(name));

							CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_spConsole);
							SCOPEDATAITEM scope;
							TCHAR name[MAXCOMPUTER_NAME + 40] = {0};
							BuildRootNodeName(name);

							memset(&scope, 0, sizeof(SCOPEDATAITEM));
							scope.mask = SDI_STR;
							scope.displayname = name;
							scope.ID = m_myID;

							HRESULT z = spConsoleNameSpace->SetItem(&scope);
						}
					}
				}
				break;

			case ID_PERF_COUNTERS:
			{
				try
				{
					CWMICtrSysmonDlg *test;
					test = new CWMICtrSysmonDlg((LPCTSTR)g_DS->m_whackedMachineName);
					test->DoModal();
					eStatusInfo st = test->GetStatus();
					if(st == Status_CounterNotFound)
					{
						TCHAR strTemp[1024];
						if(::LoadString(_Module.GetModuleInstance(),IDC_RETRY_TEXT,strTemp,1024) <= 0)
						{
							_tcscpy(strTemp,_T("Could Not Connect to WMI Using Logged on User. WMIControl will try to display the counters as Text"));
						}

						TCHAR strHead[1024];
						if(::LoadString(_Module.GetModuleInstance(),IDC_ERROR_CAPTION,strHead,1024) <= 0)
						{
							_tcscpy(strHead,_T("WMIControl - Error"));
						}

						MessageBox(NULL,strTemp,strHead,MB_OK);
						CWmiCtrsDlg *CtrsDlg;	//g_DS
						CtrsDlg = new CWmiCtrsDlg((LPCTSTR)g_DS->m_whackedMachineName,g_DS->GetCredentials());
						CtrsDlg->DoModal(NULL);
					}
				}
				catch(...)
				{
					MessageBox(NULL,_T("Error Occured"),_T("Exception"),MB_OK);
				}
			}
			default: break;
			}
		}
		return hr;
	}
    
	STDMETHOD (BuildRootNodeName)(TCHAR *name)
	{
		HRESULT hr = E_FAIL;

		LoadString(_Module.GetResourceInstance(), 
					IDS_DISPLAY_NAME, 
					name, MAXCOMPUTER_NAME + 40);
		if(g_DS)
		{
			if(g_DS->IsLocal())
			{
				TCHAR local[20] = {0};
				LoadString(_Module.GetResourceInstance(), 
							IDS_LOCAL_COMPUTER, 
							local, 20);

				_tcscat(name, local);
			}
			else
			{
				TCHAR machine[MAXCOMPUTER_NAME + 1] = {0};
				_tcscpy(machine, (LPCTSTR)g_DS->m_whackedMachineName);

				_tcsupr(machine);
				_tcscat(name, _T(" ("));

				// NOTE: skip the leading whacks
				_tcscat(name, (LPCTSTR)&machine[2]);
				_tcscat(name, _T(")"));
			}
			hr = S_OK;
		}

		return hr;
	}



	STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
	{
		HRESULT hr = DV_E_CLIPFORMAT;

		if(cf == m_CCF_DISPLAY_NAME)
		{
			ULONG uWritten;
			TCHAR name[MAXCOMPUTER_NAME + 20] = {0};

			BuildRootNodeName(name);

			hr = pStream->Write(name, (ocslen((OLECHAR*)name) + 1) * sizeof(OLECHAR), &uWritten);
		}
		else
		{
			hr = CSnapInItemImpl<CWMISnapinData>::FillData(cf, pStream);
		}
		return hr;
	}

	STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);

	STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);

    STDMETHOD(GetResultViewType)(LPOLESTR *ppViewType,
							        long *pViewOptions)
	{
		*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

		LPOLESTR psz = NULL;
		StringFromCLSID(CLSID_MessageView, &psz);
		
		*ppViewType = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(lstrlen(psz)+1));
		if (!*ppViewType)
			return E_OUTOFMEMORY;
		lstrcpy(*ppViewType, psz);
		return S_OK;
  	}

	STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
						LPARAM arg,
						LPARAM param,
						IComponentData* pComponentData,
						IComponent* pComponent,
						DATA_OBJECT_TYPES type);

	LPOLESTR GetResultPaneColInfo(int nCol);

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
									LONG_PTR handle, 
									IUnknown* pUnk,
									DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		return S_OK;
	}


	CWMISnapinExtData *m_parent;
	CComPtr<IConsole> m_spConsole;
	LPPROPERTYSHEETCALLBACK m_lpProvider;

	wchar_t m_nodeType[50];
	wchar_t m_nodeDesc[100];
	wchar_t m_descBar[100];
	HSCOPEITEM m_myID;
	UINT m_MenuId;


};

class CWMISnapinExtData : public CSnapInItemImpl<CWMISnapinExtData, TRUE>,
							public CComObject<CSnapInDataObjectImpl>
{
private:
	wchar_t m_nodeName[50];
	CWMISnapinData *m_pScopeItem;

public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	CWMISnapinExtData() 
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
		m_scopeDataItem.displayname = MMC_CALLBACK;
		m_scopeDataItem.nImage = IDI_WMICNTL; 		// May need modification
		m_scopeDataItem.nOpenImage = IDI_WMICNTL; 	// May need modification
		m_scopeDataItem.lParam = (LPARAM) this;

		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
		m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
		m_resultDataItem.str = MMC_CALLBACK;
		m_resultDataItem.nImage = IDI_WMICNTL;		// May need modification
		m_resultDataItem.lParam = (LPARAM) this;

		m_pScopeItem = NULL;
		memset(m_nodeName, 0, 50 * sizeof(wchar_t));
		if(::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, m_nodeName, 50) == 0)
		{
			wcscpy(m_nodeName, L"WMI Control");
		}
	}

	~CWMISnapinExtData()
	{
	}

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		return S_OK;
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
						LPARAM arg,
						LPARAM param,
						IComponentData* pComponentData,
						IComponent* pComponent,
						DATA_OBJECT_TYPES type);

	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium);
	wchar_t* MachineName();
	wchar_t m_MachineName[255];

};

class CWMISnapin;

class CWMISnapinComponent : public CComObjectRootEx<CComSingleThreadModel>,
							public CSnapInObjectRoot<2, CWMISnapin >,
							public IExtendPropertySheetImpl<CWMISnapinComponent>,
							public IComponentImpl<CWMISnapinComponent>
{
public:
BEGIN_COM_MAP(CWMISnapinComponent)
	COM_INTERFACE_ENTRY(IComponent)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()


public:
	CWMISnapinComponent()
	{
	}

	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
	{
		if (lpDataObject != NULL && lpDataObject != DOBJ_CUSTOMOCX)
			return IComponentImpl<CWMISnapinComponent>::Notify(lpDataObject, event, arg, param);
		// TODO : Add code to handle notifications that set lpDataObject == NULL.
		return E_NOTIMPL;
	}

};

class CWMISnapin : public CComObjectRootEx<CComSingleThreadModel>,
					public CSnapInObjectRoot<1, CWMISnapin>,
					public IComponentDataImpl<CWMISnapin, CWMISnapinComponent>,
					public IExtendPropertySheetImpl<CWMISnapin>,
					public IExtendContextMenuImpl<CWMISnapin>,
					public CComCoClass<CWMISnapin, &CLSID_WMISnapin>,
					public IPersistStream,
					public ISnapinHelp
{
public:
	CWMISnapin() : m_bDirty(false)

	{
		m_pNode = new CWMISnapinData;
		_ASSERTE(m_pNode != NULL);
		m_pComponentData = this;
	}

	~CWMISnapin()
	{
		delete m_pNode;
		m_pNode = NULL;
	}

EXTENSION_SNAPIN_DATACLASS(CWMISnapinExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CWMISnapin)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CWMISnapinExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()


BEGIN_COM_MAP(CWMISnapin)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(ISnapinHelp)
	COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

// NOTE: using UpdateRegistry() directly so I can localize for "PRETTYNAME".
//DECLARE_REGISTRY_RESOURCEID(IDR_WMISNAPIN)

DECLARE_NOT_AGGREGATABLE(CWMISnapin)

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		HRESULT hr;
		TCHAR pName[100] = {0};
		if(::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, 
							pName, 100) <= 0)
		{
			wcscpy(pName, _T("WMI Control"));
		}

		TCHAR dispName[_MAX_PATH+102] = {0};
        TCHAR szModule[_MAX_PATH+1];
        szModule[_MAX_PATH] = 0;
        ::GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
        _stprintf( dispName,_T("@%s,-%d"), szModule, IDS_DISPLAY_NAME);

		
		_ATL_REGMAP_ENTRY regMap[] = {{ OLESTR("PRETTYNAME"), pName },
										{ OLESTR("NAMESTRINGINDIRECT"),dispName},
										{ 0, 0 }};

		hr = _Module.UpdateRegistryFromResourceD(IDR_WMISNAPIN, TRUE, regMap);

		return hr;
	}

	STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}

    STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile)
	{
		if(lpCompiledHelpFile == NULL)
			return E_POINTER;    

		wchar_t helpDir[_MAX_PATH + 50];
		memset(helpDir, 0, (_MAX_PATH + 50) * sizeof(wchar_t));

		if(GetSystemWindowsDirectory(helpDir, _MAX_PATH+1) != 0)
		{
			wcscat(helpDir, L"\\Help");
			wcscat(helpDir, L"\\newfeat1.chm");

			*lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(
										CoTaskMemAlloc((wcslen(helpDir) + 1) * 
															sizeof(wchar_t)));

			if(*lpCompiledHelpFile == NULL)        
				return E_OUTOFMEMORY;

			USES_CONVERSION;
			wcscpy(*lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)helpDir));
			return S_OK;
		}
		return E_UNEXPECTED;
	}

	// IPersistStream methods
	STDMETHOD(GetClassID)(CLSID *pClassID);
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)(IStream *pStm);
	STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
								LPDATAOBJECT lpDataObjectB)
	{
		CSnapInItem *alpha = NULL, *beta = NULL;
		DATA_OBJECT_TYPES able, baker;

		HRESULT hr = GetDataClass(lpDataObjectA, &alpha, &able);
		hr = GetDataClass(lpDataObjectB, &beta, &baker);
		return (alpha == beta ? S_OK : S_FALSE);
	}

private:
	HRESULT ReadStream(IStream *pStm, void *data, ULONG *size);
	bool m_bDirty;  // for the IPersistStream

	HRESULT LoadIcon(CComPtr<IImageList> &spImageList, 
					   UINT resID);

};

class ATL_NO_VTABLE CWMISnapinAbout : public ISnapinAbout,
										public CComObjectRoot,
										public CComCoClass< CWMISnapinAbout, &CLSID_WMISnapinAbout>
{
public:
	DECLARE_REGISTRY(CWMISnapinAbout, _T("WMISnapinAbout.1"), _T("WMISnapinAbout.1"), IDS_WMISNAPIN_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CWMISnapinAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_WMISNAPIN_DESC, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_WMISNAPIN_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_WMISNAPIN_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		*hAppIcon = LoadIcon(_Module.GetResourceInstance(),
								MAKEINTRESOURCE(IDI_WMICNTL));
		return S_OK;
	}

	STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
									HBITMAP *hSmallImageOpen,
									HBITMAP *hLargeImage,
									COLORREF *cMask)
	{
		*hSmallImageOpen = LoadBitmap(_Module.GetResourceInstance(), 
										MAKEINTRESOURCE(IDB_WMISNAPIN_16));
		
		*hSmallImage = LoadBitmap(_Module.GetResourceInstance(), 
									MAKEINTRESOURCE(IDB_WMISNAPIN_16));
		
		*hLargeImage = LoadBitmap(_Module.GetResourceInstance(), 
									MAKEINTRESOURCE(IDB_WMISNAPIN_32));
		*cMask = RGB(255,255,255);
		return S_OK;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\shell\atlui\wmicntl\snapin\wmisnapin.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "WMICntl.h"
#include "WMISnapin.h"
#include "..\common\util.h"
#include "..\GenPage.h"
#include "..\LogPage.h"
#include "..\BackupPage.h"
#include "..\NSPage.h"
#include "..\AdvPage.h"
#include "..\chklist.h"
#include "..\DataSrc.h"

/////////////////////////////////////////////////////////////////////////////
// CWMISnapinComponentData
static const GUID CWMISnapinGUID_NODETYPE = 
{ 0x5c659259, 0xe236, 0x11d2, { 0x88, 0x99, 0x0, 0x10, 0x4b, 0x2a, 0xfb, 0x46 } };
const GUID*  CWMISnapinData::m_NODETYPE = &CWMISnapinGUID_NODETYPE;
const OLECHAR* CWMISnapinData::m_SZNODETYPE = OLESTR("5C659259-E236-11D2-8899-00104B2AFB46");
const OLECHAR* CWMISnapinData::m_SZDISPLAY_NAME = OLESTR("WMISnapin2222");
const CLSID* CWMISnapinData::m_SNAPIN_CLASSID = &CLSID_WMISnapin;

static const GUID CWMISnapinExtGUID_NODETYPE = 
{ 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
const GUID*  CWMISnapinExtData::m_NODETYPE = &CWMISnapinExtGUID_NODETYPE;
const OLECHAR* CWMISnapinExtData::m_SZNODETYPE = OLESTR("476e6449-aaff-11d0-b944-00c04fd8d5b0");
const OLECHAR* CWMISnapinExtData::m_SZDISPLAY_NAME = OLESTR("WMISnapin33333");
const CLSID* CWMISnapinExtData::m_SNAPIN_CLASSID = &CLSID_WMISnapin;



//-------------------------------------------------------------
CWMISnapinData::CWMISnapinData(bool extension)
							: m_extension(extension),
							m_parent(0)
{
	// Image indexes may need to be modified depending on the images specific to 
	// the snapin.
//	SetMenuID(IDR_MENU_MENU);
	memset(m_MachineName, 0, (MAXCOMPUTER_NAME + 1) * sizeof(TCHAR));
	memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
	m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM|SDI_CHILDREN;
	m_scopeDataItem.displayname = MMC_CALLBACK;
	m_scopeDataItem.nImage = IDI_WMICNTL; 		// May need modification
	m_scopeDataItem.nOpenImage = IDI_WMICNTL; 	// May need modification
	m_scopeDataItem.cChildren = 0; 				// May need modification
	m_scopeDataItem.lParam = (LPARAM) this;

	memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	m_resultDataItem.str = MMC_CALLBACK;
	m_resultDataItem.nImage = IDI_WMICNTL;		// May need modification
	m_resultDataItem.lParam = (LPARAM) this;
	memset(m_nodeType, 0, 50 * sizeof(wchar_t));

	if(::LoadString(_Module.GetModuleInstance(), IDS_SNAPIN_TYPE, m_nodeType, 50) == 0)
	{
		wcscpy(m_nodeType, L"Snapin Extension");
	}

	memset(m_nodeDesc, 0, 100 * sizeof(wchar_t));
	if(::LoadString(_Module.GetModuleInstance(), IDS_DESCRIPTION, m_nodeDesc, 100) == 0)
	{
		wcscpy(m_nodeDesc, L"<unavailable>");
	}

	memset(m_descBar, 0, 100 * sizeof(wchar_t));
	if(::LoadString(_Module.GetModuleInstance(), IDS_PROJNAME, m_descBar, 100) == 0)
	{
		wcscpy(m_descBar, L"WMI Control");
	}

	m_spConsole = NULL;
	m_lpProvider = NULL;
	m_myID = 0;
	g_DS = NULL;
	memset(m_initMachineName, 0, (MAXCOMPUTER_NAME + 1) * sizeof(wchar_t));
}


//-------------------------------------------------------------
HRESULT CWMISnapinData::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
	if (pScopeDataItem->mask & SDI_STR)
		pScopeDataItem->displayname = m_bstrDisplayName;
	if (pScopeDataItem->mask & SDI_IMAGE)
		pScopeDataItem->nImage = m_scopeDataItem.nImage;
	if (pScopeDataItem->mask & SDI_OPENIMAGE)
		pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
	if (pScopeDataItem->mask & SDI_PARAM)
		pScopeDataItem->lParam = m_scopeDataItem.lParam;
	if (pScopeDataItem->mask & SDI_STATE )
		pScopeDataItem->nState = m_scopeDataItem.nState;

	// TODO : Add code for SDI_CHILDREN 
	return S_OK;
}

//-------------------------------------------------------------
HRESULT CWMISnapinData::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
	if (pResultDataItem->bScopeItem)
	{
		if (pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
		}
		if (pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_scopeDataItem.nImage;
		}
		if (pResultDataItem->mask & RDI_PARAM)
		{
			pResultDataItem->lParam = m_scopeDataItem.lParam;
		}

		return S_OK;
	}

	if (pResultDataItem->mask & RDI_STR)
	{
		pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
	}
	if (pResultDataItem->mask & RDI_IMAGE)
	{
		pResultDataItem->nImage = m_resultDataItem.nImage;
	}
	if (pResultDataItem->mask & RDI_PARAM)
	{
		pResultDataItem->lParam = m_resultDataItem.lParam;
	}
	if (pResultDataItem->mask & RDI_INDEX)
	{
		pResultDataItem->nIndex = m_resultDataItem.nIndex;
	}

	return S_OK;
}

//------------------------------------------------------------------
LPOLESTR CWMISnapinData::GetResultPaneColInfo(int nCol)
{
	switch(nCol)
	{
	case 0:
		return m_bstrDisplayName;
		break;
	case 1:
		return m_nodeType;
		break;
	case 2:
		return m_nodeDesc;
		break;
	} //endswitch nCol

	return OLESTR("missed one in CWMISnapinData::GetResultPaneColInfo");
}

//------------------------------------------------------------------
HRESULT CWMISnapinData::Notify( MMC_NOTIFY_TYPE event,
								LPARAM arg,
								LPARAM param,
								IComponentData* pComponentData,
								IComponent* pComponent,
								DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.
	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.
	HRESULT hr = E_NOTIMPL;

	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
	if (pComponentData != NULL)
		m_spConsole = ((CWMISnapin*)pComponentData)->m_spConsole;
	else
	{
		m_spConsole = ((CWMISnapinComponent*)pComponent)->m_spConsole;
		spHeader = m_spConsole;
	}

	switch(event)
	{
	case MMCN_CONTEXTHELP:
		{
			WCHAR topic[128] = L"newfeat1.chm::wmi_control_overview.htm";
			CComQIPtr<IDisplayHelp, &IID_IDisplayHelp> displayHelp(m_spConsole);

			LPOLESTR lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(
										CoTaskMemAlloc((wcslen(topic) + 1) * 
															sizeof(wchar_t)));

			if(lpCompiledHelpFile == NULL)
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				USES_CONVERSION;
				wcscpy(lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)topic));
				hr = displayHelp->ShowTopic(lpCompiledHelpFile);
			}
		}
		break;

	case MMCN_SHOW:
		{
			// if we are showing
            if (arg)
            {
                CComQIPtr<IResultData, &IID_IResultData> spResultData(m_spConsole);
			    LPUNKNOWN pUnk = 0;
			    if(SUCCEEDED(m_spConsole->QueryResultView(&pUnk)))
			    {
				    CComQIPtr<IMessageView, &IID_IMessageView> spMsg(pUnk);
				    if(spMsg)
				    {
					    TCHAR title[100] = {0}, desc[256] = {0};
					    ::LoadString(_Module.GetResourceInstance(), IDS_PROJNAME,
									    title, 100);

					    ::LoadString(_Module.GetResourceInstance(), IDS_DESCRIPTION,
									    desc, 256);

					    spMsg->SetTitleText(title);
					    spMsg->SetBodyText(desc);
					    spMsg->SetIcon(Icon_Information);
				    }
				    pUnk->Release();
			    }
            }
            else // else we are hiding.  Clean up...
            {
                HWND hMainWin;
                if (SUCCEEDED(m_spConsole->GetMainWindow(&hMainWin)))
                {
                    // if we've got a property sheet up, we want to close it
                }
            }

			hr = S_OK;
			break;
		}
	case MMCN_EXPAND:
		{
			m_myID = (HSCOPEITEM)param;
			hr = S_OK;
			break;
		}
	case MMCN_SELECT:
		{
			CComQIPtr<IResultData, &IID_IResultData> spResultData(m_spConsole);
			spResultData->SetDescBarText(m_descBar);

			if(g_DS && wcslen(m_initMachineName) != 0)
			{
				g_DS->SetMachineName(CHString1(m_initMachineName));
				memset(m_initMachineName, 0, (MAXCOMPUTER_NAME + 1) * sizeof(wchar_t));
			}

			IConsoleVerb *menu = NULL;
			if(SUCCEEDED(m_spConsole->QueryConsoleVerb(&menu)))
			{
				menu->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
				menu->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
				if(m_myID)
				{
					menu->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
					menu->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
				}
				else
				{
					menu->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
					menu->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
				}
				menu->Release();
			}
			hr = S_OK;
		}
		break;

	case MMCN_DBLCLICK:
		hr = S_FALSE; // do the default verb. (Properties)
		break;

	case MMCN_ADD_IMAGES:
		{
			// Add Images
			IImageList* pImageList = (IImageList*) arg;
			hr = E_FAIL;
			// Load bitmaps associated with the scope pane
			// and add them to the image list
			// Loads the default bitmaps generated by the wizard
			// Change as required
			if(g_DS == 0)
			{
				g_DS = new DataSource;

				if(g_DS == NULL)
				{
					return E_OUTOFMEMORY;
				}

				WCHAR CompName[MAX_COMPUTERNAME_LENGTH + 1 ];
				WCHAR * pCompName;
				if (NULL == m_parent)
				{
				    DWORD dwSize = sizeof(CompName)/sizeof(TCHAR);
				    GetComputerNameEx(ComputerNamePhysicalNetBIOS,CompName,&dwSize);
				    pCompName = CompName;
				}
				else
				{
				    pCompName = m_parent->m_MachineName;
				}
				g_DS->SetMachineName(CHString1(pCompName));
			}

			HICON icon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_WMICNTL));
			if(icon != NULL)
			{
				hr = pImageList->ImageListSetIcon((LONG_PTR*)icon, IDI_WMICNTL);
				if(FAILED(hr))
					ATLTRACE(_T("CLogDriveScopeNode::ImageListSetIcon failed\n"));
			}
			break;

		}
	}
	return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWMISnapinData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
											LONG_PTR handle, 
											IUnknown* pUnk,
											DATA_OBJECT_TYPES type)
{
	HRESULT hr = E_UNEXPECTED;
	bool htmlSupport = false;

	switch(type)
	{
	case CCT_SCOPE:
		{
			bstr_t temp;
			HPROPSHEETPAGE hPage;
			BOOL bResult = FALSE;
			
			if(g_DS == 0)
			{
				g_DS = new DataSource;
				if(g_DS == NULL)
				{
					return E_OUTOFMEMORY;
				}

				g_DS->SetMachineName(CHString1(L""));
			}

			// General tab.
			CGenPage *pPage = new CGenPage(g_DS, htmlSupport);
			if(pPage)
			{
				hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_GENERAL));
				lpProvider->AddPage(hPage);
			}

			// Logging Tab.
			CLogPage *pPage1 = new CLogPage(g_DS, htmlSupport);
			if(pPage1)
			{
				hPage = pPage1->CreatePropSheetPage(MAKEINTRESOURCE(IDD_LOGGING));
				lpProvider->AddPage(hPage);
			}

			// Backup Tab.
			CBackupPage *pPage2 = new CBackupPage(g_DS, htmlSupport);
			if(pPage2)
			{
				hPage = pPage2->CreatePropSheetPage(MAKEINTRESOURCE(IDD_BACKUP));
				lpProvider->AddPage(hPage);
			}

			// Security Tab.
			CNamespacePage *pPage3 = new CNamespacePage(g_DS, htmlSupport);
			if(pPage3)
			{
				hPage = pPage3->CreatePropSheetPage(MAKEINTRESOURCE(IDD_NAMESPACE));
				lpProvider->AddPage(hPage);
			}
			CAdvancedPage *pPage4 = new CAdvancedPage(g_DS, htmlSupport);
			if(pPage4)
			{
				hPage = pPage4->CreatePropSheetPage(MAKEINTRESOURCE(IDD_ADVANCED_9X));
				lpProvider->AddPage(hPage);
			}
			hr = S_OK;

		}
		break;

	case CCT_SNAPIN_MANAGER: 
		{
			HPROPSHEETPAGE hPage;
			if(g_DS == 0)
			{
				g_DS = new DataSource;
			}

			if(g_DS == NULL)
			{
				return E_OUTOFMEMORY;
			}

			ConnectPage *connPg = new ConnectPage(g_DS, htmlSupport);
			if(connPg)
			{
				hPage = connPg->CreatePropSheetPage(MAKEINTRESOURCE(IDD_CONNECT_WIZ));
				lpProvider->AddPage(hPage);
			}

			hr = S_OK;
		}
		break;

	default: break;
	} //endswitch

	return hr;
}


//==============================================================
//=================== SERVER NODE being extended===============
HRESULT CWMISnapinExtData::Notify(MMC_NOTIFY_TYPE event,
									LPARAM arg,
									LPARAM param,
									IComponentData* pComponentData,
									IComponent* pComponent,
									DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.
	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.
	HRESULT hr = E_NOTIMPL;
	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComPtr<IConsole> spConsole;
	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
	if (pComponentData != NULL)
		spConsole = ((CWMISnapin*)pComponentData)->m_spConsole;
	else
	{
		spConsole = ((CWMISnapinComponent*)pComponent)->m_spConsole;
		spHeader = spConsole;
	}

//	Snitch(L"Storage", event);

	switch(event)
	{
	case MMCN_REFRESH:
			hr = S_OK;
			break;

	case MMCN_EXPAND:
		{
			// NOTE: I dont enum in the scope.
			CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
			if(m_pScopeItem == NULL)
			{
				CWMISnapinData* p = new CWMISnapinData(true);

				p->m_scopeDataItem.relativeID = param;
				p->m_scopeDataItem.lParam = (LPARAM)p;
				p->m_bstrDisplayName = m_nodeName;
				p->m_parent = this;
				hr = spConsoleNameSpace->InsertItem(&p->m_scopeDataItem);

				ATLTRACE(L"!!!!!!!!!!!!!!!!!!!!!scope using %x\n", this);

				MachineName();
				if(p->g_DS)
					p->g_DS->SetMachineName(CHString1(MachineName()));

				m_pScopeItem = p;
			}
			hr = S_OK;
			break;
		}

	case MMCN_REMOVE_CHILDREN:
		{
            // we're changing shopes,
            // if the prop sheet is open now, we want to close it.
            if (m_pScopeItem && m_pScopeItem->g_DS)
                m_pScopeItem->g_DS->ClosePropSheet();
            
            CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);

			delete m_pScopeItem;
			m_pScopeItem = NULL;

			hr = spConsoleNameSpace->DeleteItem(arg, false);

		}
		break;

	case MMCN_ADD_IMAGES:
		{
			// Add Images
			IImageList* pImageList = (IImageList*) arg;
			hr = E_FAIL;

			CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
			spResultData->DeleteAllRsltItems();

			HICON icon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_WMICNTL));
			if(icon != NULL)
			{
				hr = pImageList->ImageListSetIcon((LONG_PTR*)icon, IDI_WMICNTL);
				if(FAILED(hr))
					ATLTRACE(_T("CLogDriveScopeNode::ImageListSetIcon failed\n"));
			}
			break;
		}
	}
	return hr;
}

//----------------------------------------------------------------
HRESULT CWMISnapinExtData::GetDataHere(FORMATETC* pformatetc, STGMEDIUM* pmedium)
{
	ATLTRACE(_T("SnapInDataObjectImpl::GetDataHere\n"));
	if (pmedium == NULL)
		return E_POINTER;

	CLIPFORMAT MACHINE_NAME = (CLIPFORMAT) RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");
	ULONG uWritten = 0;
	HRESULT hr = DV_E_TYMED;
	
	// Make sure the type medium is HGLOBAL
	if (pmedium->tymed == TYMED_HGLOBAL)
	{
		// Create the stream on the hGlobal passed in
		CComPtr<IStream> spStream;
		hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
		if(SUCCEEDED(hr))
		{
			if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
			{
				hr = DV_E_CLIPFORMAT;
				ULONG uWritten;
				hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
			}
			else if (pformatetc->cfFormat == MACHINE_NAME)
			{
				hr = spStream->Write(m_MachineName, (wcslen(m_MachineName) + 1) * sizeof(OLECHAR), &uWritten);
			}
			else
			{
				hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
			}
		}
	}
	return hr;
}

//--------------------------------------------------------------------------------
wchar_t* CWMISnapinExtData::MachineName()
{
	Extract(m_pDataObject, L"MMC_SNAPIN_MACHINE_NAME", m_MachineName);
    return m_MachineName;
}

//==============================================================
//=================== STATIC NODE ==============================
HRESULT CWMISnapin::LoadIcon(CComPtr<IImageList> &spImageList, 
							   UINT resID)
{
	HRESULT hr = 0;
	HICON icon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(resID));
	if(icon != NULL)
	{
		hr = spImageList->ImageListSetIcon((LONG_PTR*)icon, resID);
		if(FAILED(hr))
			ATLTRACE(_T("CLogDriveScopeNode::ImageListSetIcon failed\n"));
	}
	return hr;
}

//----------------------------------------------------------------
HRESULT CWMISnapin::Initialize(LPUNKNOWN pUnknown)
{
#if (_WIN32_IE >= 0x0300)
	INITCOMMONCONTROLSEX iccx;
	iccx.dwSize = sizeof(iccx);
	iccx.dwICC = ICC_BAR_CLASSES | ICC_USEREX_CLASSES|ICC_LISTVIEW_CLASSES;
	::InitCommonControlsEx(&iccx);
#else
	::InitCommonControls();
#endif

	RegisterCheckListWndClass();

	HRESULT hr = IComponentDataImpl<CWMISnapin, CWMISnapinComponent>::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if(m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_WMISNAPIN_16));
	if (hBitmap16 == NULL)
		return S_OK;

	HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_WMISNAPIN_32));
	if(hBitmap32 == NULL)
		return S_OK;

	if(spImageList->ImageListSetStrip((LONG_PTR*)hBitmap16, 
		(LONG_PTR*)hBitmap32, IDI_WMICNTL, RGB(0, 128, 128)) != S_OK)
	{
		ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		return E_UNEXPECTED;
	}
	return S_OK;
}

//----------------------------------------------------------------
HRESULT CWMISnapin::GetClassID(CLSID *pClassID)
{

    HRESULT hr = E_POINTER;
	ATLTRACE(_T("ClassID******\n"));

    if(NULL != pClassID)
    {
      // Use overloaded '=' operator to copy the Class ID.
      *pClassID = CLSID_WMISnapin;
      hr = S_OK;
    }

    return hr;
}	

//----------------------------------------------------------------
HRESULT CWMISnapin::IsDirty()
{
	ATLTRACE(_T("Dirty******\n"));
	return (m_bDirty == true)? S_OK : S_FALSE;
//	return S_OK;
}

//----------------------------------------------------------------
HRESULT CWMISnapin::ReadStream(IStream *pStm, void *data, ULONG *size)
{
	HRESULT hr = E_FAIL;
    ULONG ulToRead = *size, ulReadIn = 0;

	// read the version nbr like a good boy.
	hr = pStm->Read((void *)data, ulToRead, &ulReadIn);

	if(SUCCEEDED(hr))
	{
		if(ulReadIn <= *size)
		{
			*size = ulReadIn;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	return hr;
}

//----------------------------------------------------------------
HRESULT CWMISnapin::Load(IStream *pStm)
{
	HRESULT hr = E_POINTER;

	ULONG size = 0;
	BYTE version = 0;
	short machineLength = 0;
	ATLTRACE(_T("Load******\n"));

    if(NULL != pStm)
    {
		size = 1;
		if(SUCCEEDED(hr = ReadStream(pStm, (void *)&version, &size)))
		{
			// Deal with the differentversions.
			switch (version)
			{
			case 1:
				size = sizeof(short);
				if(SUCCEEDED(hr = ReadStream(pStm, (void *)&machineLength, &size)))
				{
					size = (ULONG)machineLength;
					if (size > MAXCOMPUTER_NAME+1) //validate size
					{
						hr = E_FAIL;
						break;
					}
					hr = ReadStream(pStm, 
									(void *)((CWMISnapinData *)m_pNode)->m_initMachineName,
									&size);
				}

				break;
			default:
				hr = E_FAIL;  // Bad version.
				break;

			} //endswitch

		} //endif ReadStream(version)
    }

    return hr;
}

//----------------------------------------------------------------
HRESULT CWMISnapin::Save(IStream *pStm, BOOL fClearDirty)
{
	HRESULT hr = E_POINTER;
    ULONG ulToWrite, ulWritten;
	short data = 1;

	ATLTRACE(_T("Save******\n"));

    if(NULL != pStm)
    {
		ulToWrite = 1;
		hr = pStm->Write(&data, ulToWrite, &ulWritten);

		if(SUCCEEDED(hr) && ulToWrite != ulWritten)
		{
			hr = STG_E_CANTSAVE;
		}
		// NOTE: g_DS == 0 when we're an extension and we dont need to save the machine name anyway.
		else if(SUCCEEDED(hr) && ((CWMISnapinData *)m_pNode)->g_DS)
		{
			ulToWrite = sizeof(short);
			ulWritten = 0;
			data = (short)sizeof(wchar_t) * (((CWMISnapinData *)m_pNode)->g_DS->m_whackedMachineName.GetLength() + 1);

			hr = pStm->Write(&data, ulToWrite, &ulWritten);

			if(SUCCEEDED(hr) && ulToWrite != ulWritten)
			{
				hr = STG_E_CANTSAVE;
			}
			else if(SUCCEEDED(hr))
			{
				LPBYTE str = new BYTE[data * sizeof(wchar_t)];
				if (!str)
					return E_OUTOFMEMORY;
				memset(str, 0, data * sizeof(wchar_t));
				ulToWrite = (ULONG)data;
				ulWritten = 0;
				wcscpy((wchar_t *)str, (LPCTSTR)((CWMISnapinData *)m_pNode)->g_DS->m_whackedMachineName);

				hr = pStm->Write((void *)str, ulToWrite, &ulWritten);

				delete[] str;

				if(SUCCEEDED(hr) && ulToWrite != ulWritten)
				{
					hr = STG_E_CANTSAVE;
				}
				else if(SUCCEEDED(hr))
				{
					// Clear this COM object's dirty flag if instructed. Otherwise,
					// preserve its content.
					if(fClearDirty)
						m_bDirty = false;
				}
			}
		}

	}
    return hr;
}

//----------------------------------------------------------------
HRESULT CWMISnapin::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
	HRESULT hr = E_POINTER;
	ATLTRACE(_T("GetSizeMax******\n"));

	if(NULL != pcbSize)
    {
		ULISet32(*pcbSize, (256 * sizeof(wchar_t)) + sizeof(short) + 1);
		hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\stdafx.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.CPP

History:

--*/

// stdafx.cpp : source file that includes just the standard includes
//	WMIparse.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information
#include "precomp.h"
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
#ifndef _STDAFX_H_
#define _STDAFX_H_

// #define PSH_WIZARD97 PSH_WIZARD
// #define RBBS_GRIPPERALWAYS 0

#undef _WINDOWS_

#include <afxres.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>			// MFX Ole stuff
#include <afxtempl.h>	    // MFC template collection classes.

#include <parser.h>

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESOURCE.H

History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WMIPARSE.RC
//
#define IDS_WMI_DESC                    12700
#define IDS_WMI_NO_ERROR                12701
#define IDS_WMI_OOM                     12702
#define IDS_WMI_CANT_LOAD_SOURCE        12703
#define IDS_WMI_CANT_OPEN_TARGET        12704
#define IDS_WMI_NO_OPEN_FILE            12705
#define IDS_WMI_NOT_MOF_FILE            12706
#define IDS_WMI_CANT_WRITE_FILE         12707
#define IDS_WMI_SYNTAX                  12708
#define IDS_WMI_HANDLER_ERROR           12709
#define IDS_WMI_UNKNOWN_ERROR           12710
#define IDS_WMI_PARSER_DESC             12711
#define IDS_WMI_BAD_FILE                12712
#define IDS_WMI_NO_MEMORY               12713
#define IDS_WMI_UNICODE_ERROR           12714
#define IDS_WMI_EXCEPTION               12715
#define IDS_WMI_GENERIC_LOCATION        12716
#define IDS_WMI_FULL_CONTEXT            12717
#define IDS_WMI_LINE_ERROR              12718
#define IDS_WMI_VAL_HOTKEY              12750
#define IDS_WMI_VAL_BAD_CHARS           12751
#define IDS_OPT_DESC                    12752
#define IDS_OPT_HELP                    12753
#define IDS_DISABLE_WATERMARKING_BOOL   12754
#define IDS_DISABLE_WATERMARKING_BOOL_HELP 12755

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\wmiclass.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMICLASS.CPP

History:

--*/

//  
//  Implementation file for the WMI MOF parser IClassFactory object.
//  
#include "precomp.h"
#include "stdafx.h"


#include "WMIparse.h"
#include "resource.h"
#include "WMIlprs.h"

#include "WMIclass.h"


CWMILocClassFactory::CWMILocClassFactory()
{
	m_uiRefCount = 0;

	AddRef();
	IncrementClassCount();
}


#ifdef _DEBUG

void
CWMILocClassFactory::AssertValid(void)
		const
{
	CLObject::AssertValid();
}



void
CWMILocClassFactory::Dump(
		CDumpContext &dc)
		const
{
	CLObject::Dump(dc);
}

#endif // _DEBUG


ULONG
CWMILocClassFactory::AddRef(void)
{
	return ++m_uiRefCount;
}



ULONG
CWMILocClassFactory::Release(void)
{
	LTASSERT(m_uiRefCount != 0);
	
	m_uiRefCount--;
	
	if (m_uiRefCount == 0)
	{
		delete this;
		return 0;
	}

	return m_uiRefCount;
}



HRESULT
CWMILocClassFactory::QueryInterface(
		REFIID iid,
		LPVOID *ppvObj)
{
	SCODE sc = E_NOINTERFACE;

	*ppvObj = NULL;
	
	if (iid == IID_IUnknown)
	{
		*ppvObj = (IUnknown *)this;
		sc = S_OK;
	}
	else if (iid == IID_IClassFactory)
	{
		*ppvObj = (IClassFactory *)this;
		sc = S_OK;
	}
	
	if (sc == S_OK)
	{
		AddRef();
	}
	return ResultFromScode(sc);
}



HRESULT
CWMILocClassFactory::CreateInstance(
		LPUNKNOWN pUnknown,
		REFIID iid,
		LPVOID *ppvObj)
{
	SCODE sc = E_UNEXPECTED;

	*ppvObj = NULL;
	
	if (pUnknown != NULL)
	{
		sc = CLASS_E_NOAGGREGATION;
	}
	else
	{
		try
		{
			CWMILocParser *pParser;

			pParser = new CWMILocParser;

			sc = pParser->QueryInterface(iid, ppvObj);

			pParser->Release();
		}
		catch (CMemoryException *pMemoryException)
		{
			sc = E_OUTOFMEMORY;
			pMemoryException->Delete();
		}
	}

	return ResultFromScode(sc);
}



HRESULT
CWMILocClassFactory::LockServer(
		BOOL)
{
	return E_NOTIMPL;
}



CWMILocClassFactory::~CWMILocClassFactory()
{
	LTASSERT(m_uiRefCount == 0);
	DEBUGONLY(AssertValid());

	DecrementClassCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\wmiclass.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMICLASS.H

History:

--*/


#ifndef WMICLASS_H
#define WMICLASS_H

class CWMILocClassFactory : public IClassFactory, public CLObject
{
public:
	CWMILocClassFactory();

#ifdef _DEBUG
	void AssertValid(void) const;
	void Dump(CDumpContext &) const;
#endif
	
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)(); 
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);

	STDMETHOD(CreateInstance)(THIS_ LPUNKNOWN, REFIID, LPVOID *);
	STDMETHOD(LockServer)(THIS_ BOOL);

	~CWMILocClassFactory();
	
private:
	UINT m_uiRefCount;
	
};


#endif // WMICLASS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\wmilfile.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMILFILE.CPP

Abstract:

    Implementation of CWmiLocFile, the MOF parser for Localization Studio

History:

--*/
#include "precomp.h"
#include "stdafx.h"
#include <buildnum.h>
#include <helpids.h>

#include "WMIparse.h"
#include "resource.h"
#include "WMIlprs.h"


#include "WMIlfile.h"

#include <malloc.h>

//*****************************************************************************
//
//  CWMILocFile::CWMILocFile
//
//*****************************************************************************

CWMILocFile::CWMILocFile(
		ILocParser *pParentClass)
{
	//
	// C.O.M. initialization
	//
	m_pParentClass = pParentClass;
    m_sCurrentNamespace = "";
	m_ulRefCount = 0;

	//
	//  WMI file initialization
	//
	m_uiLineNumber = 0;
	m_pOpenSourceFile = NULL;
	m_pOpenTargetFile = NULL;

	AddRef();
	IncrementClassCount();
}

//*****************************************************************************
//
//  CWMILocFile::GetFileDescriptions
//
//*****************************************************************************

void CWMILocFile::GetFileDescriptions(
		CEnumCallback &cb)
{
	EnumInfo eiFileInfo;
	CLString strDesc;
	
	eiFileInfo.szAbbreviation = NULL;

	LTVERIFY(strDesc.LoadString(g_hDll, IDS_WMI_DESC));

	eiFileInfo.szDescription = (const TCHAR *)strDesc;
	eiFileInfo.ulValue = ftWMIFileType;

	cb.ProcessEnum(eiFileInfo);
}

//*****************************************************************************
//
//  CWMILocFile::AddRef
//
//*****************************************************************************

ULONG CWMILocFile::AddRef(void)
{
	if (m_pParentClass != NULL)
	{
		m_pParentClass->AddRef();
	}
	
	return m_ulRefCount++;
}

//*****************************************************************************
//
//  CWMILocFile::Release
//
//*****************************************************************************

ULONG CWMILocFile::Release(void)
{
	LTASSERT(m_ulRefCount != 0);

	if (m_pParentClass != NULL)
	{
		
		m_pParentClass->Release();
	}

	m_ulRefCount--;
	if (m_ulRefCount == 0)
	{
		delete this;
		return 0;
	}
	
	return m_ulRefCount;
}

//*****************************************************************************
//
//  CWMILocFile::QueryInterface
//
//*****************************************************************************

HRESULT CWMILocFile::QueryInterface(
		REFIID iid,
		LPVOID *ppvObj)
{
	if (m_pParentClass != NULL)
	{
		return m_pParentClass->QueryInterface(iid, ppvObj);
	}
	else
	{
		SCODE scRetVal = E_NOINTERFACE;

		*ppvObj = NULL;
		
		if (iid == IID_IUnknown)
		{
			*ppvObj = (IUnknown *)this;
			scRetVal = S_OK;
		}
		else if (iid == IID_ILocFile)
		{
			*ppvObj = (ILocFile *)this;
			scRetVal = S_OK;
		}

		if (scRetVal == S_OK)
		{
			AddRef();
		}
		return ResultFromScode(scRetVal);
	}
}

//*****************************************************************************
//
//  CWMILocFile::AssertValidInterface
//
//*****************************************************************************

void CWMILocFile::AssertValidInterface(void)
		const
{
	AssertValid();
}

//*****************************************************************************
//
//  CWMILocFile::OpenFile
//
//*****************************************************************************

BOOL CWMILocFile::OpenFile(
		const CFileSpec &fsFile,
		CReporter &Reporter)
{
	LTTRACEPOINT("OpenFile()");
	
	BOOL fRetCode;
	
	LTASSERT(m_pOpenTargetFile == NULL);
	fRetCode = FALSE;

	m_didFileId = fsFile.GetFileId();
	m_pstrFileName = fsFile.GetFileName();
	
	if (m_pOpenSourceFile != NULL)
	{
        fclose(m_pOpenSourceFile);
		m_pOpenSourceFile = NULL;
	}

    // We are just going to open the file.
    // and save the handle.
    // ===================================
	
	try
	{

		m_pOpenSourceFile = fopen(_T(m_pstrFileName), "rb");

		if (!m_pOpenSourceFile)
		{			
			fclose(m_pOpenSourceFile);
			m_pOpenSourceFile = NULL;
		}
        else
        {           
            fRetCode = TRUE;
        }

    }
	catch (CMemoryException *pMemoryException)
	{
		CLString strContext;

		strContext.LoadString(g_hDll, IDS_WMI_GENERIC_LOCATION);
		
		Reporter.IssueMessage(esError, strContext, g_hDll, IDS_WMI_NO_MEMORY,
				g_locNull);

		pMemoryException->Delete();
	}
	return fRetCode;
}

//*****************************************************************************
//
//  CWMILocFile::GetFileType
//
//*****************************************************************************

FileType CWMILocFile::GetFileType(void)
		const
{
	//
	//  Just return some number that isn't ftUnknown...
	//
	return ftWMIFileType;
}

//*****************************************************************************
//
//  CWMILocFile::GetFileTypeDescription
//
//*****************************************************************************

void CWMILocFile::GetFileTypeDescription(
		CLString &strDesc)
		const
{
	LTVERIFY(strDesc.LoadString(g_hDll, IDS_WMI_DESC));
	
	return;
}


//*****************************************************************************
//
//  CWMILocFile::GetAssociatedFiles
//
//*****************************************************************************

BOOL CWMILocFile::GetAssociatedFiles(
		CStringList &lstFiles)
		const
{
	LTASSERT(lstFiles.GetCount() == 0);
	
	lstFiles.RemoveAll();
	return FALSE;
}

//*****************************************************************************
//
//  CWMILocFile::EnumerateFile
//
//*****************************************************************************

BOOL CWMILocFile::EnumerateFile(
		CLocItemHandler &ihItemHandler,
		const CLocLangId &lid,
		const DBID &dbidFileId)
{
    BOOL bRet = TRUE;
    DBID dbidThisId = dbidFileId;

	LTTRACEPOINT("EnumerateFile()");
	
	if (m_pOpenSourceFile == NULL)
	{
		return FALSE;
	}

    // Enumerate file will need to:
    // * Parse the MOF.
    // * Walk through all qualifiers.  For each "Amended" qualifier, 
    //   send back a CLocItem whose key is namespace, class, property and qualifier name.
    // * Fail if the language ID does not match that of LocaleID.
    // * Parent objects are namespaces, classes
    // =============================================================

	m_cpSource = lid.GetCodePage(cpAnsi);
    m_wSourceId = lid.GetLanguageId();

    ihItemHandler.SetProgressIndicator(0);	

    bRet = ReadLines(ihItemHandler, dbidFileId, FALSE);

	return bRet;
}

//*****************************************************************************
//
//  CWMILocFile::GenerateFile
//
//*****************************************************************************

BOOL CWMILocFile::GenerateFile(
		const CPascalString &pstrTargetFile,
		CLocItemHandler &ihItemHandler,
		const CLocLangId &lidSource,
		const CLocLangId &lidTarget,
		const DBID &dbidParent)
{
	LTASSERT(m_pOpenTargetFile == NULL);
	BOOL fRetVal = TRUE;

	if (m_pOpenSourceFile== NULL)
	{
		return FALSE;
	}
    // Generate File needs to:
    // * Parse the MOF.
    // * Walk through all qualifiers.  For each "Amended" qualifier,
    //   send back a CLocItem whose key is namespace, class, property and qualifier name.
    // * Replace all Amended qualifiers with localized text
    // * Replace all occurrences of the locale ID in namespaces and qualifiers
    //   with the new one.
    // =================================================================================
    
	m_cpSource = lidSource.GetCodePage(cpAnsi);
	m_cpTarget = lidTarget.GetCodePage(cpAnsi);

    m_wSourceId = lidSource.GetLanguageId();
    m_wTargetId = lidTarget.GetLanguageId();
    	
	try
	{
		CFileException excFile;
		fRetVal = FALSE;
		
		if (m_pOpenTargetFile != NULL)
		{
			fclose(m_pOpenTargetFile);
			m_pOpenTargetFile = NULL;
		}

        char FileName[255];
        strcpy(FileName, _bstr_t(_T(pstrTargetFile)));

        // This file must be in Unicode.
        HANDLE hFile = CreateFile(FileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL,
            CREATE_ALWAYS, 0, NULL);
	    if(hFile != INVALID_HANDLE_VALUE)
	    {
		    unsigned char cUnicodeHeader[2] = {0xff, 0xfe};
		    DWORD dwWrite;
            WriteFile(hFile, cUnicodeHeader, 2, &dwWrite, NULL);
            CloseHandle(hFile);
	    }      
	
		m_pOpenTargetFile = fopen(FileName, "ab");

		if (!m_pOpenTargetFile)
		{			
			fclose(m_pOpenTargetFile);
			m_pOpenTargetFile = NULL;
		}
        else
        {
            fRetVal = TRUE;
        }
	}
	catch (CMemoryException *pMemoryException)
	{
		CLString strContext;
		GetFullContext(strContext);
		
		ihItemHandler.IssueMessage(esError, strContext, g_hDll, IDS_WMI_NO_MEMORY,
				g_locNull);

		pMemoryException->Delete();
	}
	catch (CFileException *pFileException)
	{		
		fclose(m_pOpenTargetFile);
		fRetVal = FALSE;

		ReportFileError((const WCHAR *)pstrTargetFile, m_didFileId, pFileException, ihItemHandler);

		pFileException->Delete();
	}

	if (!fRetVal)
	{
		return fRetVal;
	}
			
	fRetVal = ReadLines(ihItemHandler, dbidParent, TRUE);
	
	fclose(m_pOpenTargetFile);

	if (!fRetVal)
	{
		DeleteFileW (pstrTargetFile);
	}

	return fRetVal;
}

//*****************************************************************************
//
//  CWMILocFile::GenerateItem
//
//*****************************************************************************

BOOL CWMILocFile::GenerateItem(
		CLocItemHandler &ihItemHandler,
		CLocItemSet &isItemSet,
        wchar_t **pOutBuffer,
        UINT &uiStartingPos)
{

	BOOL fRetVal = TRUE;
    UINT uiLength;

    wchar_t *pTemp = *pOutBuffer;

    _bstr_t sQualifierValue;

    // If nothing has changed, we can just
    // ignore this line.

    fRetVal = GetQualifierValue(pTemp, uiStartingPos, sQualifierValue, uiLength);
    if (fRetVal)
    {
        fRetVal = ihItemHandler.HandleItemSet(isItemSet);
		if (fRetVal)
		{
            sQualifierValue = "";
            for (int i = 0; i < isItemSet.GetSize(); i++)
            {			
				CVC::ValidationCode vcRetVal;
				CLocItem *pLocItem = isItemSet[i];
				CLString strContext;
 				CLocation loc;
				
				GetFullContext(strContext);
				loc.SetGlobalId(
						CGlobalId(pLocItem->GetMyDatabaseId(), otResource));
				loc.SetView(vTransTab);
				
				CPascalString pstrId, pstrText;
			
				pLocItem->GetUniqueId().GetResId().GetId(pstrId);
				pstrText = pLocItem->GetLocString().GetString();
                
                if (i > 0)
                    sQualifierValue += L"\",\"";

                sQualifierValue += (const wchar_t *)pstrText;
            }

            // Set it live in the buffer.  We are not going to 
            // write it to the file until the very end.

            fRetVal = SetQualifierValue(pTemp, pOutBuffer, uiStartingPos, sQualifierValue, uiLength);				
            pTemp = *pOutBuffer;

        }

    }		
    
	return fRetVal;
}
	


//*****************************************************************************
//
//  CWMILocFile::EnumerateItem
//
//*****************************************************************************

BOOL CWMILocFile::EnumerateItem(
		CLocItemHandler &ihItemHandler,
		CLocItemSet &isItemSet)
{
	BOOL fRetVal;
	
	if (isItemSet.GetSize() != 0)
	{
		fRetVal = ihItemHandler.HandleItemSet(isItemSet);
	}
	else
	{
		fRetVal = TRUE;
	}

	return fRetVal;
}



#ifdef _DEBUG

//*****************************************************************************
//
//  CWMILocFile::AssertValid
//
//*****************************************************************************

void CWMILocFile::AssertValid(void)
		const
{
	CLObject::AssertValid();
}

//*****************************************************************************
//
//  CWMILocFile::Dump
//
//*****************************************************************************

void CWMILocFile::Dump(
		CDumpContext &dc)
		const
{
	CLObject::Dump(dc);
}

#endif

//*****************************************************************************
//
//  CWMILocFile::~CWMILocFile
//
//*****************************************************************************

CWMILocFile::~CWMILocFile()
{
	DEBUGONLY(AssertValid());

	if (m_pOpenSourceFile != NULL)
	{
        fclose(m_pOpenSourceFile);
		m_pOpenSourceFile = NULL;
	}

	DecrementClassCount();
}

//*****************************************************************************
//
//  CWMILocFile::SetFlags
//
//*****************************************************************************

void CWMILocFile::SetFlags(
		CLocItem *pItem,
		CLocString &lsString)
		const
{
	ULONG ulItemType;

	pItem->SetFDevLock(FALSE);
	pItem->SetFUsrLock(FALSE);
	pItem->SetFExpandable(FALSE);
	
	LTVERIFY(pItem->GetUniqueId().GetTypeId().GetId(ulItemType));
	
	switch (ulItemType)
	{
	case wltNamespaceName:
		pItem->SetFDisplayable(TRUE);
		pItem->SetFNoResTable(TRUE);
		break;

	case wltClassName:
	case wltPropertyName:
		pItem->SetFDisplayable(FALSE);
		pItem->SetFNoResTable(FALSE);
		lsString.SetCodePageType(cpAnsi);
		lsString.SetStringType(CST::Text);
		break;

	default:
		LTASSERT(FALSE && "Unexpected item type!");
	}
}

//*****************************************************************************
//
//  CWMILocFile::ReadLines
//
//*****************************************************************************

BOOL CWMILocFile::ReadLines(
		CLocItemHandler &ihItemHandler,
		const DBID &dbidFileId,
		BOOL fGenerating)
{
	DBID dbidSectionId;
	BOOL fRetVal = TRUE;
	wchar_t *pstrNamespaceName;
    _bstr_t pstrClassName;
    UINT uiStartPos = 0;

	UINT uiCommentNum;
	UINT uiReadingOrder;

	dbidSectionId = dbidFileId;
	m_uiLineNumber = 0;
    BOOL bPendingObj = FALSE;

	
	try
	{
		UINT uiOldPercentage = 0, uiNewPercentage = 0;
        UINT uiBytesRead, uiCurrPos = 1;

        ihItemHandler.SetProgressIndicator(uiOldPercentage);
   
        fseek(m_pOpenSourceFile, 0, SEEK_END);
        long lSize = ftell(m_pOpenSourceFile) + 6;
        fseek(m_pOpenSourceFile, 0, SEEK_SET);

        // Check for UNICODE source file.
        // ==============================

        BYTE UnicodeSignature[2];
        BOOL bUnicode = FALSE;        

        if (fread(UnicodeSignature, sizeof(BYTE), 2, m_pOpenSourceFile) != 2)
        {
            fRetVal = FALSE;
            return fRetVal;
        }
        if ((UnicodeSignature[0] == 0xFF && UnicodeSignature[1] == 0xFE) ||
            (UnicodeSignature[0] == 0xFE && UnicodeSignature[1] == 0xFF))
        {
            bUnicode = TRUE;
            lSize *= 2;
        }
        if (!bUnicode)
            fseek(m_pOpenSourceFile, 0, SEEK_SET);

        wchar_t *pBuff = (wchar_t *)new wchar_t[lSize+1];        
        if (!pBuff)
        {
            fRetVal = FALSE;
            return fRetVal;
        }
        memset(pBuff,0,lSize*sizeof(wchar_t));

        // If this is not a Unicode file,
        // we need to perform a conversion.
        // =====================================

        if (bUnicode)
            uiBytesRead = fread(pBuff, sizeof(wchar_t), lSize, m_pOpenSourceFile);           
        else
        {
            char *pCharBuff = new char[lSize+1];
            if (pCharBuff)
            {
                uiBytesRead = fread(pCharBuff, sizeof(char), lSize, m_pOpenSourceFile);
                pCharBuff[lSize] = '\0';
                swprintf(pBuff, L"%S", pCharBuff);
                delete pCharBuff;
            }
        }
        pBuff[lSize] = '\0';

        if (uiBytesRead != 0)
        {
            wchar_t *pOutBuffer = NULL;
            uiCurrPos += uiBytesRead;
		    fRetVal = TRUE;
		    
		    pstrNamespaceName = NULL;
            m_sCurrentNamespace = L"";
            pstrClassName = L"";

		    uiCommentNum = 0;
		    uiReadingOrder = 1;
	
			WMIFileError wmiRet;
			CLocItemSet isItemSet;
            UINT uiTemp = 0;
            DWORD dwCount = 0;
			
            // If we are generating a file, make a copy
            // of the outbound buffer.

            if (fGenerating)
                pOutBuffer = pBuff;

            while (GetNextQualifierPos(L"amended", pBuff, uiTemp, uiTemp) && !bPendingObj)
            {			    
                // If we have found the "amended" keyword,
                // we want to find the namespace,
                // class, and property if applicable, and
                // generate the object as appropriate.
                // ======================================

                pstrNamespaceName = GetCurrentNamespace(pBuff, uiTemp);
                if (!pstrNamespaceName || !wcslen(pstrNamespaceName))
                {
                    delete pBuff;
                    return FALSE;
                }
                if (wcscmp(pstrNamespaceName, m_sCurrentNamespace))
                {
                    // We need to generate this object,
                    // and set it up as the current parent.
                    // ====================================

                    CLocItem *pNewItem = new CLocItem;
                    CPascalString sId;

                    if (pNewItem)
                    {

               			CLocUniqueId uid;
                        sId = (const WCHAR *)pstrNamespaceName;

                        uid.GetResId().SetId(sId);	
			            uid.GetTypeId().SetId(wltNamespaceName);
                        uid.SetParentId(dbidFileId);
            			pNewItem->SetUniqueId(uid);
			
			            CLocString lsString;
			
			            pNewItem->SetIconType(CIT::String);			            
                        CPascalString pstrComment, pstrText;
                       		
                        pNewItem->SetInstructions(pstrComment);
                        lsString.SetString(pstrText);

			            SetFlags(pNewItem, lsString);
			            pNewItem->SetLocString(lsString);
			            
			            isItemSet.Add(pNewItem);

					    uiReadingOrder = (uiReadingOrder + 999)/1000*1000;
				        isItemSet[0]->SetDisplayOrder(uiReadingOrder);
				        uiReadingOrder++;

                        fRetVal = EnumerateItem(ihItemHandler,
                        	isItemSet);

				        dbidSectionId.Clear();			        
				        dbidSectionId = isItemSet[0]->GetMyDatabaseId();
                        isItemSet.ClearItemSet();
                        uiTemp += 1;

                    }

                    m_sCurrentNamespace = pstrNamespaceName;
                    delete pstrNamespaceName; 


                }

                // For the class name, this is trickier.
                // If there are one or more qualifiers
                // on the class itself, we need to read ahead
                // to find the class name, and then
                // generate all the qualifier objects at once.
                // ==========================================

                wmiRet = GetNextItemSet(dwCount, pBuff, isItemSet, dbidSectionId, uiStartPos);
                while (wmiRet == WMINoError)
                {
                    // For each item, we want to set its key,
                    // and push it or write it as appropriate.
                    // ========================================

                    dwCount++;
                    ULONG ulItemType;
				    CLocUniqueId &rUid = isItemSet[0]->GetUniqueId();
				    
				    rUid.GetTypeId().GetId(ulItemType);
				    //if (ulItemType == wltClassName)
				    //{
					//   uiCommentNum = 0;
					//    uiReadingOrder = (uiReadingOrder + 999)/1000*1000;
				    //}
                    for (int i = 0; i < isItemSet.GetSize(); i++)
                    {
				        isItemSet[i]->SetDisplayOrder(uiReadingOrder);
				        uiReadingOrder++;
                    }

			        if (fGenerating)
                    {
                        fRetVal = GenerateItem(ihItemHandler,
                            isItemSet, &pOutBuffer, uiStartPos);

                        if (pBuff != pOutBuffer)
                        {
                            delete pBuff;
                            pBuff = NULL;
                            pBuff = pOutBuffer; // The old memory has already been deleted.
                        }
                        else
                        {
                            fRetVal = FALSE;
                        }
                    }
                    else
			        {
				        fRetVal = EnumerateItem(ihItemHandler,
				        	isItemSet);
			        }

                    isItemSet.ClearItemSet();
                    uiTemp += 1;

                    if (!fRetVal)
                    {
                        fRetVal = TRUE;
                        break;
                    }

                    wmiRet = GetNextItemSet(dwCount, pBuff, isItemSet, dbidSectionId, uiStartPos);
                    if (uiStartPos > uiTemp)
                        uiTemp = uiStartPos;

                    if (dwCount%20 == 0)
                    {
                        if (uiNewPercentage < 100)
                            uiNewPercentage++;
                        ihItemHandler.SetProgressIndicator(uiNewPercentage);				
                    }                             
                }

                // If we were generating the file,
                // we're done.
                // ==============================
                if (fGenerating)
                    break;

                if (uiNewPercentage < 100)
                    uiNewPercentage++;
                ihItemHandler.SetProgressIndicator(uiNewPercentage);				
               
            } 
        
            uiTemp = 0;

            // Now, we get to search and replace the locale IDs,
            // and actually write out the file.
            // =================================================

            if (fRetVal && fGenerating)
            {
                fRetVal = WriteNewFile(pOutBuffer);
            }

		}

        if (pBuff)
            delete pBuff;

        ihItemHandler.SetProgressIndicator(100);

	}
	catch (CFileException *pFileException)
	{
		fRetVal = FALSE;

		ReportFileError(m_pstrFileName, m_didFileId, pFileException, ihItemHandler);

		pFileException->Delete();
	}
	catch (CUnicodeException *pUnicodeException)
	{
		CLocation loc;

		loc.SetGlobalId(CGlobalId(m_didFileId, otFile));
		loc.SetView(vProjWindow);
		
		ReportUnicodeError(pUnicodeException, ihItemHandler, loc);

		pUnicodeException->Delete();
		fRetVal = FALSE;
	}
	catch (CMemoryException *pMemoryException)
	{
		CLString strContext;
		
		ihItemHandler.IssueMessage(esError, strContext,
				g_hDll, IDS_WMI_NO_MEMORY, g_locNull);
		
		fRetVal = FALSE;

		pMemoryException->Delete();
	}
	catch (CException *pException)
	{
		CLocation loc;

		loc.SetGlobalId(CGlobalId(m_didFileId, otFile));
		loc.SetView(vProjWindow);
		
		ReportException(pException, ihItemHandler, loc);

		pException->Delete();
		fRetVal = FALSE;
	}
	return fRetVal;
}



//*****************************************************************************
//
//  CWMILocFile::WriteWaterMark
//
//*****************************************************************************

void CWMILocFile::WriteWaterMark()
{
	LTASSERT(NULL != m_pOpenTargetFile);

	LTASSERT(NULL != m_pOpenSourceFile);

    // Do we need to support this?

}

//*****************************************************************************
//
//  CWMILocFile::GetNextQualifierPos
//
//*****************************************************************************

BOOL CWMILocFile::GetNextQualifierPos(const wchar_t *wTmp, const wchar_t *pBuff, UINT &uiNewPos, UINT uiStartingPos) 
{
    BOOL bRet = FALSE;
    UINT uiPos = uiStartingPos;
    BOOL bComment = FALSE;

    if (pBuff && wcslen(pBuff) < uiStartingPos)
        return FALSE;

    wchar_t *pTemp = (wchar_t *)pBuff;
    pTemp += uiStartingPos;

    while (TRUE)
    {
        wchar_t *pszTest2 = NULL;

        pszTest2 = wcsstr(pTemp, L":");
        if (pszTest2)
        {
            uiPos = pszTest2 - pBuff + 1;

            // Look for the "amended" keyword.
            // ==============================

			WCHAR temp = pszTest2[0];
            while(temp == L' ' || temp == L'\0' || temp == L':')
            {
                pszTest2++;
				temp = pszTest2[0];
            }

            if (temp != L'\0')
            {
                wchar_t wTmp2[8];
                wcsncpy(wTmp2, pszTest2, 7);
				wTmp2[7] = '\0';
                if (!_wcsicmp(wTmp2, wTmp))
                {
                    bRet = TRUE;
                }
            }

            // If here, we found a non-match, so try again.
            // ============================================

            if (!bRet)
                pTemp = pszTest2 + 1;
            else
                break;
        }
        else
        {
            break;
        }
    }
   
    if (bRet)
        uiNewPos = uiPos;    

    return bRet;

}

//*****************************************************************************
//
//  CWMILocFile::GetCurrentNamespace
//
//*****************************************************************************

wchar_t *CWMILocFile::GetCurrentNamespace(wchar_t *pstr, UINT uPos)
{
    wchar_t *pTemp = pstr;
    _bstr_t pstrNamespace = m_sCurrentNamespace;
    UINT uiCurrPos = 0;
    BOOL bComment = FALSE;
    
    wchar_t wTmp[] = L"#pragma namespace";
    int iHCLen = wcslen(wTmp);

    // Find the first occurrence of the namespace
    // before the current position.

    if (pstrNamespace.length() > 0)
        pTemp = wcsstr(pTemp, pstrNamespace);   // Jump directly to the existing one.

    while (uiCurrPos < uPos)
    {
        wchar_t *pszTest2 = NULL;

        pszTest2 = wcsstr(pTemp, L"#");
        if (pszTest2)
        {
            // First, go back and make sure this isn't a comment line.
            // =======================================================            
            bComment = FALSE;

            wchar_t *pComment = pszTest2;
            while (pComment > pstr)
            {
                if (pComment[0] == L'\n' || pComment[0] == L'\r')
                {
                    if (pComment[1] == L'/' && pComment[2] == L'/')
                    {
                        bComment = TRUE;
                    }
                    else
                    {
                        bComment = FALSE;
                    }
                    break;
                }
                pComment--;
            }

            if (!bComment)
            {

                wchar_t wTmp2[100];
                wcsncpy(wTmp2, pszTest2, 17);
				wTmp2[17] = '\0';
                if (!_wcsicmp(wTmp2, wTmp))
                {
                    uiCurrPos += (pszTest2 - pTemp);
                    wchar_t *pszTest3 = wcschr(pszTest2, L')');

                    int iLen = (pszTest3 - pszTest2);                    
                    wchar_t *pszTmpNS = new wchar_t[iLen*2+1];
                    if (pszTmpNS)
                    {
                        pszTest2 += iHCLen + 2; // skip quote and open parent.
                        wcsncpy(pszTmpNS, pszTest2, iLen - 2); // strip quotes.
                        pszTmpNS[iLen-iHCLen-3] = '\0';
                        pstrNamespace = pszTmpNS;

                        pTemp = pszTest2 + 1;
                        delete pszTmpNS;
                    }
                }
                else
                {
                    pTemp = pszTest2 + 1;
                }
            }
            else
            {
                pTemp = pszTest2 + 1;
            }
        }
        else
        {
            break;
        }
    }

    int iLen = wcslen(pstrNamespace) ;

    wchar_t *pNew = new wchar_t[iLen*2+1];
    if (pNew)
    {
        wcsncpy(pNew, (const wchar_t *)pstrNamespace, iLen);
        pNew[iLen] = '\0';
    }

    return pNew;

}

//*****************************************************************************
//
//  CWMILocFile::GetNextItemSet
//
//*****************************************************************************

CWMILocFile::WMIFileError CWMILocFile::GetNextItemSet(
		DWORD dwCurrPos,
        const _bstr_t &pstrCurrentLine,
		CLocItemSet &aNewItem,
		const DBID &dbidSection,
        UINT &uiStartPos)		
{

    // In this function, we know there is an
    // "amended" keyword in here somewhere.
    // We want to know to which class and/or
    // property does it belong?  If we don't
    // have enough data to figure it out,
    // we need to send back a WMIIncompleteObj
    // code.  
    // ======================================
    UINT uiCurrPos = 0;
    WMIFileError feRetCode = WMINoError;
    _bstr_t sQualifierName, sRawValue, sPropName, sClassName;
    BOOL bClass = FALSE;
    int iLen = pstrCurrentLine.length() + 1;
    iLen *= 2;

    // Get the position of the keyword
    // "amended" in this chunk of text.

    wchar_t *wTemp = new wchar_t[iLen+1];
    if (!wTemp)
    {
        feRetCode = WMIOOM;
        return feRetCode;
    }

    if (GetNextQualifierPos(L"amended", pstrCurrentLine, uiCurrPos, uiStartPos))
    {
        BOOL bArray = FALSE;

        uiStartPos = uiCurrPos;
    
        // Find the qualifier name and value.   
        // wTemp = Top of File
        // wTmp2 = "Amended" keyword
        // wQfrVal = Opening bracket
        // wBkwd = floating pointer.

        wchar_t *wTmp2 = NULL, *wBkwd = NULL, *wQfrVal = NULL;

        wcscpy(wTemp, pstrCurrentLine);
        wTemp[iLen] = '\0';

        wTmp2 = wTemp;
        wTmp2 += (uiCurrPos - 1); // the "Amended" keyword.
        
        wQfrVal = FindTop(wTmp2, wTemp, bArray);

        if (!wQfrVal) // Make sure we had an open parenth
        {
            feRetCode = WMISyntaxError;
            delete wTemp;
            return feRetCode;
        }

        // Find the beginning of the qualifier name.
        wBkwd = wQfrVal;

        while (wBkwd[0] != L',' && wBkwd[0] != L'[' && wBkwd >= wTemp)
        {
            wBkwd--;
        }

        if (wBkwd[0] != L',' && wBkwd[0] != L'[') // Make sure we had a valid qualifier name.
        {
            feRetCode = WMISyntaxError;
            delete wTemp;
            return feRetCode;
        }       

        WCHAR *token;
        UINT uiLen;

        wBkwd += 1;
        
        wchar_t wTmpBuff[256];
        wcsncpy(wTmpBuff, wBkwd, wQfrVal - wBkwd);   
        wTmpBuff[wQfrVal - wBkwd] = '\0';
        sQualifierName = wTmpBuff;

        GetQualifierValue(wTemp, uiStartPos, sRawValue, uiLen);

        // Finally, populate the CLocItem.
        // ===============================
    
	    LTASSERT(aNewItem.GetSize() == 0);
	    
	    if (feRetCode == WMINoError)
	    {
		    CLocItem *pNewItem;
		    
		    try
		    {
                // Now we have a value, but it may be an 
                // array.  If so, we need to add one CLocItem
                // for each value in the array.

                VectorString arrValues;
                if (bArray)
                    ParseArray(sRawValue, arrValues);
                else
                    arrValues.push_back(sRawValue);

                for (int i = 0; i < arrValues.size(); i++)
                {               
                    wchar_t szTmp[20];
                    swprintf(szTmp, L"%ld", dwCurrPos);

                    _bstr_t sValue = arrValues.at(i);

			        pNewItem = new CLocItem;

			        CLocUniqueId uid;

                    CPascalString sTempString;

                    sTempString = sQualifierName;
                    sTempString += szTmp;
                               
			        uid.GetResId().SetId(sTempString) ;

			        if (bClass)
			            uid.GetTypeId().SetId(wltClassName);
                    else
                        uid.GetTypeId().SetId(wltPropertyName);

                    uid.SetParentId(dbidSection);				
			        pNewItem->SetUniqueId(uid);
			        
			        CLocString lsString;
                    CPascalString pstrComment, pstrText;

                    pstrText = sValue;                
                
			        pNewItem->SetIconType(CIT::String);
                    pNewItem->SetInstructions(pstrComment);
			        
                    lsString.SetString(pstrText);
			        SetFlags(pNewItem, lsString);
			        pNewItem->SetLocString(lsString);
			        
			        aNewItem.Add(pNewItem);
                }

		    }
		    catch (CMemoryException *pMemoryException)
		    {
			    feRetCode = WMIOOM;
			    
			    pMemoryException->Delete();
		    }
	    }
	    else
	    {
		    LTTRACE("Unable to process line '%ls'",
				    (const WCHAR *)pstrCurrentLine);
	    }
       
    }
    else
    {
        feRetCode = WMINoMore;
    }
    uiStartPos = uiCurrPos;


    delete wTemp;
	return feRetCode;
}

const UINT WMI_MAX_CONTEXT = 256;

//*****************************************************************************
//
//  CWMILocFile::GetFullContext
//
//*****************************************************************************

void CWMILocFile::GetFullContext(
		CLString &strContext)
		const
{
	CLString strFormat;

	strFormat.LoadString(g_hDll, IDS_WMI_FULL_CONTEXT);

	strContext.Empty();

	_sntprintf(strContext.GetBuffer(WMI_MAX_CONTEXT), WMI_MAX_CONTEXT,
			(const TCHAR *)strFormat,
			(const WCHAR *)m_pstrFileName, (UINT)m_uiLineNumber);
	strContext.ReleaseBuffer();
	
}

//*****************************************************************************
//
//  CWMILocFile::ReportFileError
//
//*****************************************************************************

void CWMILocFile::ReportFileError(
		const _bstr_t &pstrFileName,
		const DBID &didFileId,
		CFileException *pFileException,
		CReporter &Reporter)
		const
{
	CLString strContext;
	CLString strMessage;
	const UINT MAX_MESSAGE = 256;
	TCHAR szFileErrorMessage[MAX_MESSAGE];
	CLocation loc;
	
	pFileException->GetErrorMessage(szFileErrorMessage, MAX_MESSAGE);
	
	strMessage.Format(g_hDll, IDS_WMI_BAD_FILE, (const WCHAR *)pstrFileName,
			szFileErrorMessage);

	GetFullContext(strContext);
	loc.SetGlobalId(CGlobalId(didFileId, otFile));
	loc.SetView(vProjWindow);
	
	Reporter.IssueMessage(esError, strContext, strMessage, loc);
}

//*****************************************************************************
//
//  CWMILocFile::ReportUnicodeError
//
//*****************************************************************************

void CWMILocFile::ReportUnicodeError(
		CUnicodeException *pUnicodeException,
		CReporter &Reporter,
		const CLocation &Location)
		const
{
	CLString strContext;
	CLString strMessage;
	const UINT MAX_MESSAGE = 256;
	TCHAR szUnicodeErrorMessage[MAX_MESSAGE];
	CLocation loc;
	
	pUnicodeException->GetErrorMessage(szUnicodeErrorMessage, MAX_MESSAGE);
	
	strMessage.Format(g_hDll, IDS_WMI_UNICODE_ERROR, szUnicodeErrorMessage);
	GetFullContext(strContext);
	
	Reporter.IssueMessage(esError, strContext, strMessage, Location,
			IDH_UNICODE_CONV);
}

//*****************************************************************************
//
//  CWMILocFile::ReportException
//
//*****************************************************************************

void CWMILocFile::ReportException(
		CException *pException,
		CReporter &Reporter,
		const CLocation &Location)
		const
{
	CLString strContext;
	CLString strMessage;
	const UINT MAX_MESSAGE = 256;
	TCHAR szErrorMessage[MAX_MESSAGE];
	
	pException->GetErrorMessage(szErrorMessage, MAX_MESSAGE);
	
	strMessage.Format(g_hDll, IDS_WMI_EXCEPTION, szErrorMessage);
	GetFullContext(strContext);

	Reporter.IssueMessage(esError, strContext, strMessage, Location);
}

//
//  This function estimates the size of a buffer
//  required to hold a string up to something like __"}__ or __")__
//  invalid combinations are \"} and \") (there is the escape)
//  but double \\"} or \\") are valid
//

//
//
//  we will consider \\ and \" as special
//  white spaces are \r \n \t \x20
//  array of strings { "" , "" }
//  ("")

// states of the FSA modelling the parser

#define BEFORE_PAREN  0
#define AFTER_PAREN   1
#define	OPEN_QUOTE    2
#define	CLOSE_QUOTE   3
#define COMMA         4
#define	CLOSE_PAREN   5
#define	BAD           6
#define	LAST_STATE    7

// classes of characters

#define QUOTE		0
#define PAREN_OPEN  1
#define	SPACES      2
#define	PAREN_CLOSE 3
#define	COMMA_CHAR  4
#define OTHER	    5
#define	LAST_CLASS  6


DWORD g_pTable[LAST_STATE][LAST_CLASS] =
{
	/* BEFORE_PAREN */ {BAD        , AFTER_PAREN, BEFORE_PAREN, BAD,         BAD,        BAD        },
    /* AFTER_PAREN  */ {OPEN_QUOTE , BAD,         AFTER_PAREN,  BAD,         BAD,        BAD        },
	/* OPEN_QUOTE   */ {CLOSE_QUOTE, OPEN_QUOTE,  OPEN_QUOTE,   OPEN_QUOTE,  OPEN_QUOTE, OPEN_QUOTE },
	/* CLOSE_QUOTE  */ {BAD,         BAD,         CLOSE_QUOTE,  CLOSE_PAREN, COMMA,      BAD        },
	/* COMMA        */ {OPEN_QUOTE , BAD,         COMMA,        BAD,         BAD,        BAD},
	/* CLOSE_PAREN  */ {BAD, BAD,BAD,BAD,BAD,BAD },
	/* BAD          */ {BAD, BAD,BAD,BAD,BAD,BAD },
};

ULONG_PTR
Estimate(WCHAR * pBuff,BOOL * pbOK, DWORD InitState)
{
	DWORD State = InitState; 

	ULONG_PTR i=0;

	while (pBuff[i])
	{
	    switch(pBuff[i])
		{
		case L'{':
		case L'(':
			State = g_pTable[State][PAREN_OPEN];
            break;
		case L'}':
		case L')':
			State = g_pTable[State][PAREN_CLOSE];
            break;
		case L'\t':
		case L'\r':
		case L'\n':
		case L' ':
            State = g_pTable[State][SPACES];
			break;
		case L'\"':
            State = g_pTable[State][QUOTE];
            break;
		case L',':
            State = g_pTable[State][COMMA_CHAR];
            break;
		case L'\\':
			if ((pBuff[i+1] == L'\"' ||
				pBuff[i+1] == L'\\' ||
				pBuff[i+1] == L'r'  ||
				pBuff[i+1] == L'n'  ||
				pBuff[i+1] == L't' ) &&
				(State == OPEN_QUOTE)){
				i++;
            };  
			State = g_pTable[State][OTHER];
            break;
		default:
            State = g_pTable[State][OTHER];
		};
		i++;
		if (State == CLOSE_PAREN){			
			*pbOK = TRUE;
			break;
		}
	    if (State == BAD)
		{
			*pbOK = FALSE;
			//
			// get the next ) or }, and take the most far
			//
			ULONG_PTR NextClose1 = (ULONG_PTR)wcschr(&pBuff[i],L'}');
			ULONG_PTR NextClose2 = (ULONG_PTR)wcschr(&pBuff[i],L')');
			ULONG_PTR Res = (NextClose1<NextClose2)?NextClose2:NextClose1;
			if (Res){
                i = 1+(Res-(ULONG_PTR)pBuff);
				i /= sizeof(WCHAR);
			}
			break;
		}
	}

    /*
    {
      char pBuffDbg[64];
      wsprintfA(pBuffDbg,"pBuff %p Size %d\n",pBuff,(DWORD)i);
      OutputDebugStringA(pBuffDbg);
    }
    */

	return i+4;
}


//*****************************************************************************
//
//  CWMILocFile::GetQualifierValue
//
//*****************************************************************************

BOOL CWMILocFile::GetQualifierValue(wchar_t *pBuffer, UINT &uiPos, _bstr_t &sValue, UINT &uiPhysLen)
{

    // This needs to read up the text of the qualifier,
    // strip out the quotes and carriage returns, and
    // return it and its *physical* length-in-file.

    BOOL fRetVal = FALSE;
    BOOL bArray = FALSE;

    wchar_t *pTemp = pBuffer;

    pTemp += uiPos;

    pTemp = FindTop(pTemp, pBuffer, bArray);
    if (pTemp)
    {

        BOOL bOK = FALSE;
        ULONG_PTR dwSize = Estimate(pTemp,&bOK,BEFORE_PAREN);
        wchar_t * tempBuff = new WCHAR[dwSize+1];

        if (tempBuff == NULL){
            return FALSE;
        }
        
        int iCount = 0;

        pTemp++;    // Step past this character.
        uiPhysLen = 0;

        WCHAR *token = pTemp;
        BOOL bEnd = FALSE;
        while (!bEnd)
        {
            uiPhysLen++;    // Count every character.
            WCHAR *Test;

            switch(*token)
            {
            case L'\0':
                bEnd = TRUE;
                break;
            case L'\n':
            case L'\r':
            case L'\t':
                break;
            case L'\"':
                if (!iCount)
                    break;
            case L')':
            case L'}': 
                Test = token - 1;
                while (TRUE)                    
                {
                    if (*Test == L' ' || *Test == L'\r' || *Test == L'\n' || *Test == L'\t')
                    {
                        Test--;
                        continue;
                    }
                    if (*Test == L'\"')
                    {
                        Test--;
                        if (*Test != L'\\')
                        {
                            bEnd = TRUE;
                            break;
                        }
                        else
                        {
                            Test--;
                            if (*Test == L'\\')
                            {
                                bEnd = TRUE;
                                break;
                            }
                        }
                    }
                    tempBuff[iCount] = *token;
                    iCount++;
                    break;
                }
                break;
            default:
                tempBuff[iCount] = *token;
                iCount++;
                break;

            }
            token++;
        }
        if (tempBuff[iCount-1] == L'\"')
            tempBuff[iCount-1] = '\0';
        else
            tempBuff[iCount] = '\0';
        sValue = tempBuff;

        delete [] tempBuff;
        
        fRetVal = TRUE;
    }
    uiPhysLen -= 1; // We want to keep the closing parenth.

    return fRetVal;

}

//*****************************************************************************
//
//  CWMILocFile::SetQualifierValue
//
//*****************************************************************************

BOOL CWMILocFile::SetQualifierValue(wchar_t *pIn, wchar_t **pOut, UINT &uiPos, _bstr_t &sValue, UINT &uiLen, BOOL bQuotes)
{
    // This needs to write the localized qualifier value
    // and erase *uiLen* characters.
    // uiPos will need to be updated with the *new*
    // position of this qualifier.
    
    BOOL fRetVal = FALSE;
    wchar_t *pStart = pIn + uiPos;
    BOOL bArray = FALSE;

    pStart = FindTop(pStart, pIn, bArray);
    if (pStart)
    {
        int iNewLen = wcslen(sValue);
        int iLen = wcslen(pIn) + 3;
        if (iNewLen > uiLen)                // The length of the new buffer
            iLen += (iNewLen - uiLen);      // If the new value is longer, add it.

        pStart++;                                     // jump past the '(' character.  uiLen starts now.
        int iPos = pStart-pIn;                        // The current position.

        iLen *= 2;
        wchar_t *pNew = new wchar_t[iLen+3];

        if (pNew)
        {
            int iTempPos = 0;

            wcsncpy(pNew, pIn, iPos);       // Copy the initial part of the file.
            if (bQuotes)
                pNew[iPos] = '\"';             
            pNew[iPos+1] = '\0';            // Null terminate

            wcscat(pNew, sValue);           // Add the new value.

            iPos += 1 + wcslen(sValue);     // Jump past the value
            if (bQuotes)
                pNew[iPos] = '\"';
            pNew[iPos+1] = '\0';            // Null terminate the value.

            pStart += uiLen;                // Jump past the current value.
            
            iTempPos = iPos;
            iPos = wcslen(pIn) - (pStart-pIn);  // Calculate the length of the rest of the file.
            
            wcsncat(pNew, pStart, iPos);        // Append the rest of the file to the new buffer.

            pStart = pNew + iLen;
            pStart = FindPrevious(pStart, L";", pNew);
            pStart[1] = L'\r';
            pStart[2] = L'\n';
            pStart[3] = L'\0';
                      
            *pOut = pNew;

            fRetVal = TRUE;
        }
    }

    // Adjust the position.

    int iNewLen = wcslen(sValue);
    if (iNewLen < uiLen)
        uiPos -= (uiLen - iNewLen);
    else
        uiPos += (iNewLen - uiLen);
    uiPos += 3;

    return fRetVal;
}

//*****************************************************************************
//
//  CWMILocFile::WriteNewFile
//
//*****************************************************************************

BOOL CWMILocFile::WriteNewFile(wchar_t *pBuffer)
{
    // This needs to seek and replace all instances of the 
    // original Locale with the new one.
    // ===================================================

    BOOL fRetVal = FALSE, fSuccess = TRUE;
    UINT uiPos = 0, uiStartingPos = 0;
    int uiLen = wcslen(pBuffer);

    _bstr_t sThisLocale, sTargetLocale;
    wchar_t wOldCodePage[30], wNewCodePage[30];
    swprintf(wOldCodePage, L"_%X", m_wSourceId );
    swprintf(wNewCodePage, L"_%X", m_wTargetId );

    if (m_wSourceId != m_wTargetId)
    {

        wchar_t *pLocale = wcsstr(pBuffer, wOldCodePage);
        while (pLocale != NULL)
        {
            for (int i = 0; i < wcslen(wOldCodePage); i++)
            {
                pLocale[i] = wNewCodePage[i];
            }
        
            pLocale = wcsstr(pLocale, wOldCodePage);
        }

        // Now look for the locale if 
        // it was converted to a decimal.
        // ==============================

        swprintf(wOldCodePage, L"(0x%X)", m_wSourceId );
        swprintf(wNewCodePage, L"(0x%X)", m_wTargetId );

        pLocale = wcsstr(pBuffer, wOldCodePage);
        while (pLocale != NULL)
        {
            for (int i = 0; i < wcslen(wOldCodePage); i++)
            {
                pLocale[i] = wNewCodePage[i];
            }
        
            pLocale = wcsstr(pLocale, wOldCodePage);
        }

        // Now look for the locale if 
        // it was converted to a decimal.
        // ==============================

        swprintf(wOldCodePage, L"(%ld)", m_wSourceId );
        swprintf(wNewCodePage, L"(%ld)", m_wTargetId );

        pLocale = wcsstr(pBuffer, wOldCodePage);
        while (pLocale != NULL)
        {
            for (int i = 0; i < wcslen(wOldCodePage); i++)
            {
                pLocale[i] = wNewCodePage[i];
            }
        
            pLocale = wcsstr(pLocale, wOldCodePage);
        }
    }

    if (fSuccess)
    {
        fRetVal = TRUE;

        // Finally, write out the buffer to a brand new file
        // =================================================

        while (uiLen >= 0)
        {
            if (fwrite(pBuffer, sizeof(wchar_t), (uiLen > 4096) ? 4096: uiLen, m_pOpenTargetFile) < 0)
            {
                fRetVal = FALSE;
                break;
            }
            else
            {
                fRetVal = TRUE;
                pBuffer += 4096;
                uiLen -= 4096;
            }

            fflush(m_pOpenTargetFile);
        }
    }

    return fRetVal;

}

//*****************************************************************************
//
//  CWMILocFile::FindPrevious
//
//*****************************************************************************

wchar_t *CWMILocFile::FindPrevious(wchar_t *pBuffer, const wchar_t *pFind, const wchar_t *pTop)
{

    wchar_t *pRet = NULL;
    WCHAR t1, t2;
    int iLen = wcslen(pFind);
    BOOL bFound = FALSE;

    pRet = pBuffer;
    while (pRet >= pTop)
    {
        t2 = pRet[0];
        for (int i = 0; i < iLen; i++)
        {
            t1 = pFind[i];

            if (t1 == t2)
            {
                bFound = TRUE;
                break;
            }
        }
        
        if (bFound)
            break;

        pRet--;
    }

    if (pRet <= pTop)
        pRet = NULL;

    return pRet;
}

//*****************************************************************************
//
//  CWMILocFile::FindTop
//
//*****************************************************************************

wchar_t *CWMILocFile::FindTop(wchar_t *wTmp2, wchar_t *wTop, BOOL &bArray)
{

    wchar_t *wQfrVal = FindPrevious(wTmp2, L"({", wTop);        

    while (wQfrVal)
    {
        WCHAR *pQT = wQfrVal + 1;
        BOOL bFound = FALSE;

        while (TRUE)
        {
            if (*pQT != L' ' && *pQT != L'\t' && *pQT != L'\r' && *pQT != L'\n')
            {
                if (*pQT == L'\"')
                {
                    bFound = TRUE;
                }
                break;
            }
            pQT++;
        }
        
        if (!bFound)
        {
            wQfrVal --;
            wQfrVal = FindPrevious(wQfrVal, L"({", wTop);        
        }
        else
            break;
    }

    if (wQfrVal)
    {
        if (wQfrVal[0] == L'{')
            bArray = TRUE;
    }

    return wQfrVal;

}

//*****************************************************************************
//
//  CWMILocFile::ParseArray
//
//*****************************************************************************

void CWMILocFile::ParseArray(wchar_t *pIn, VectorString &arrOut)
{
    
    wchar_t *pLast = pIn;
    if (*pLast == L'\"')
        pLast++;

    BOOL bOK = FALSE;
    BOOL bAlloc = FALSE;
    ULONG_PTR qwSize = Estimate(pLast,&bOK,OPEN_QUOTE);

    wchar_t * Buff = new WCHAR[(DWORD)qwSize]; 

    if(Buff == NULL){
        Buff = (WCHAR *)_alloca((DWORD)qwSize);
    } else {
        bAlloc = TRUE;
    }
        
    wchar_t *pFind = wcsstr(pIn, L"\",");

    arrOut.clear();

    while (pFind)
    {
        wchar_t temp = pFind[-1];
        if (temp == '\\')
        { 
            pFind++;
            pFind = wcsstr(pFind, L"\",");
            continue;
        }

        wcsncpy(Buff, pLast, pFind-pLast);
        Buff[pFind-pLast] = '\0';

        arrOut.push_back(_bstr_t(Buff));

        // Now move pFind to the next valid char.

        while (pFind[0] == L'\n' || 
            pFind[0] == L'\r' ||
            pFind[0] == L' ' ||
            pFind[0] == L',' ||
            pFind[0] == L'\"' )
            pFind++;

        pLast = pFind ;
        pFind = wcsstr(pFind, L"\",");
    }

    wcscpy(Buff, pLast);
    
    if (Buff[wcslen(Buff)-1] == L'\"')
        Buff[wcslen(Buff)-1] = L'\0';   // strip off that trailing quote.
    else
        Buff[wcslen(Buff)] = L'\0';   // strip off that trailing quote.
    arrOut.push_back(_bstr_t(Buff));

    if (bAlloc) {
        delete [] Buff;
    }
    
    return;
}

//*****************************************************************************
//
//  CVC::ValidateString
//
//*****************************************************************************

CVC::ValidationCode ValidateString(
		const CLocTypeId &,
		const CLocString &clsOutputLine,
		CReporter &repReporter,
		const CLocation &loc,
		const CLString &strContext)
{
	CVC::ValidationCode vcRetVal = CVC::NoError;
	CLString strMyContext = strContext;

	if (strMyContext.GetLength() == 0)
	{
		strMyContext.LoadString(g_hDll, IDS_WMI_GENERIC_LOCATION);
	}

    loc; repReporter; clsOutputLine;
	
/*
	if (clsOutputLine.HasHotKey())
	{
		vcRetVal = CVC::UpgradeValue(vcRetVal, CVC::Warning);
		repReporter.IssueMessage(esWarning, strMyContext, g_hDll,
				IDS_WMI_VAL_HOTKEY, loc);
	}
	
	_bstr_t pstrBadChars;
	UINT uiBadPos;

	pstrBadChars.SetString(L"\n\ra", (UINT)3);
	
	if (pstrOutput.FindOneOf(pstrBadChars, 0, uiBadPos))
	{
		vcRetVal = CVC::UpgradeValue(vcRetVal, CVC::Error);

		repReporter.IssueMessage(esError, strMyContext, g_hDll,
				IDS_WMI_VAL_BAD_CHARS, loc);
	}
    */
	return vcRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\wmilprs.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMILPRS.H

History:

--*/

#ifndef WMIPARSE_H
#define WMIPARSE_H

#define OPT_DISABLE_WATERMARKING "DisableWatermarking"

class CWMILocParser : public CPULocParser
{
public:
	CWMILocParser();
	~CWMILocParser();

// Overrides
public:
	// ILocParser
	virtual HRESULT OnInit(IUnknown *);
	virtual HRESULT OnCreateFileInstance(ILocFile * &, FileType);
	virtual void OnGetParserInfo(ParserInfo &) const;
	virtual void OnGetFileDescriptions(CEnumCallback &) const;

	// ILocVersion
	virtual void OnGetParserVersion(DWORD &dwMajor,	DWORD &dwMinor, BOOL &fDebug) const;

	// ILocStringValidation
	virtual CVC::ValidationCode OnValidateString(const CLocTypeId &ltiType,
			const CLocTranslation &trTrans, CReporter *pReporter,
			const CContext &context);

// Implementation
protected:
	void GetDefaultExtensionList(CLocExtensionList & elExtList) const;

private:
	void RegisterOptions();
	void UnRegisterOptions();

	BOOL m_fOptionInit;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\wmiparse.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMIPARSE.H

History:

--*/

void IncrementClassCount(void);
void DecrementClassCount(void);

extern HMODULE g_hDll;
extern PUID g_puid;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\wmiparse.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMIPARSE.CPP

History:

--*/
#include "precomp.h"
#include "stdafx.h"

#include "WMIclass.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

LONG g_lActiveClasses = 0;
HMODULE g_hDll;
PUID g_puid(pidWMI, pidNone);

static AFX_EXTENSION_MODULE WMIparseDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	UNREFERENCED_PARAMETER(lpReserved);
	
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("WMIPARSE.DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(WMIparseDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(WMIparseDLL);
		g_hDll = hInstance;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("WMIPARSE.DLL Terminating!\n");

		//
		//  If there are active classes, they WILL explode badly once the
		//  DLL is unloaded...
		//
		LTASSERT(DllCanUnloadNow() == S_OK);
		AfxTermExtensionModule(WMIparseDLL);
	}
	return 1;   // ok
}





// {74FCE960-7F7F-11ce-8311-00AA00383930}
static const CLSID ciWMIParserCLSID =
{ 0x74fce960, 0x7f7f, 0x11ce, { 0x83, 0x11, 0x0, 0xaa, 0x0, 0x38, 0x39, 0x30 } };


STDAPI_(void)
DllGetParserCLSID(
		CLSID &ciParserCLSID)
{
	ciParserCLSID = ciWMIParserCLSID;
}



STDAPI
DllRegisterParser(void)
{
	return S_OK;//RegisterParser(g_hDll);
}



STDAPI
DllUnregisterParser(void)
{
	return S_OK; //UnregisterParser(pidWMI, pidNone);
}


	
STDAPI
DllGetClassObject(
		REFCLSID cidRequestedClass,
		REFIID iid,
		LPVOID *ppClassFactory)
{
	SCODE sc = E_UNEXPECTED;

	*ppClassFactory = NULL;

	if (cidRequestedClass != ciWMIParserCLSID)
	{
		sc = CLASS_E_CLASSNOTAVAILABLE;
	}
	else
	{
		try
		{
			CWMILocClassFactory *pClassFactory;

			pClassFactory = new CWMILocClassFactory;

			sc = pClassFactory->QueryInterface(iid, ppClassFactory);

			pClassFactory->Release();
		}
		catch (CMemoryException *pMemoryException)
		{
			sc = E_OUTOFMEMORY;
			pMemoryException->Delete();
		}
	}
	
	return ResultFromScode(sc);
}

void
IncrementClassCount(void)
{
	InterlockedIncrement(&g_lActiveClasses);
}



void
DecrementClassCount(void)
{
	LTASSERT(g_lActiveClasses != 0);
	
	InterlockedDecrement(&g_lActiveClasses);
}

	   

STDAPI
DllCanUnloadNow(void)
{
	SCODE sc;
	
	sc = (g_lActiveClasses == 0) ? S_OK : S_FALSE;

	return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\wmilfile.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMILFILE.H

Abstract:

    Header file for CWmiLocFile, the MOF parser for Localization Studio

History:

--*/

#ifndef WMILOCFIL_H
#define WMILOCFIL_H

#include <vector>

const FileType ftWMIFileType = ftUnknown+1;

class CWMILocFile : public ILocFile, public CLObject
{
public:

	CWMILocFile(ILocParser *);

	static void GetFileDescriptions(CEnumCallback &);
	
    typedef std::vector<_bstr_t> VectorString;
protected:
	//
	//  Standard IUnknown methods
	//
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)(); 
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);

	//
	//  Standard Debugging interfaces
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD;

	//
	//  ILocFile methods.
	//
	STDMETHOD_(BOOL, OpenFile)(const CFileSpec REFERENCE,
			CReporter REFERENCE);
	STDMETHOD_(FileType, GetFileType)(void) const;
	STDMETHOD_(void, GetFileTypeDescription)(CLString REFERENCE) const;
	STDMETHOD_(BOOL, GetAssociatedFiles)(CStringList REFERENCE) const;

	STDMETHOD_(BOOL, EnumerateFile)(CLocItemHandler REFERENCE,
			const CLocLangId &, const DBID REFERENCE);
	STDMETHOD_(BOOL, GenerateFile)(const CPascalString REFERENCE,
			CLocItemHandler REFERENCE, const CLocLangId REFERENCE,
			const CLocLangId REFERENCE, const DBID REFERENCE);

	//
	//  CLObect implementation
	//
#ifdef _DEBUG
	void AssertValid(void) const;
	void Dump(CDumpContext &) const;
#endif

private:
	//
	//  Private methods to prevent callers access.
	//
	~CWMILocFile();
	CWMILocFile();
	const CWMILocFile &operator=(const CWMILocFile &);

	//
	//  Private data for C.O.M. implementation
	ILocParser *m_pParentClass;
	ULONG m_ulRefCount;

	//
	//  WMI specific private data.
	//
	enum WMIFileError
	{
		WMINoError,
		WMIOOM,
		WMICantOpenSourceFile,
		WMICantOpenTargetFile,
		WMINoOpenFile,
		WMINotWMIFile,
		WMICantWriteFile,
		WMISyntaxError,
		WMIFileError2,
		WMIHandlerError,
		WMIUnknownError,
        WMIIncompleteObj,
        WMINoMore
	};
	enum WMILineTypes
	{
		wltUnknown,
		wltNamespaceName,
		wltClassName,
		wltPropertyName
	};

	UINT m_uiLineNumber;
	DBID m_didFileId;
	_bstr_t m_pstrFileName;
	_bstr_t m_pstrTargetFile;
    
	FILE *m_pOpenSourceFile;
    FILE *m_pOpenTargetFile;
	
	CodePage m_cpSource;
	CodePage m_cpTarget;

    WORD m_wSourceId;
    WORD m_wTargetId;

    _bstr_t m_sCurrentNamespace;

    BOOL ReadLines(CLocItemHandler &, const DBID &, BOOL);
    WMIFileError GetNextItemSet(DWORD dwCurrPos,const _bstr_t &, CLocItemSet &,
		const DBID &, UINT &uiStartPos) ;
    BOOL GetNextQualifierPos(const wchar_t *, const wchar_t *, UINT &uiPos, UINT uiStartingPos = 0);
    BOOL EnumerateItem(CLocItemHandler &, CLocItemSet &);
	BOOL GenerateItem(CLocItemHandler &, CLocItemSet &, wchar_t **, UINT &uiStartingPos);
    void SetFlags(CLocItem *, CLocString &) const;
	void GetFullContext(CLString &) const;
	void ReportFileError(const _bstr_t &pstrFileName,
			const DBID &didFileId, CFileException *pFileException,
			CReporter &Reporter) const;
	void ReportUnicodeError(CUnicodeException *pUnicodeException,
			CReporter &Reporter, const CLocation &Location) const;
	void ReportException(CException *pException,
			CReporter &Reporter, const CLocation &) const;
    BOOL GetQualifierValue(wchar_t *, UINT &, _bstr_t &, UINT &);
    BOOL SetQualifierValue(wchar_t *, wchar_t **, UINT &, _bstr_t &, UINT &, BOOL bQuotes = TRUE);
    BOOL WriteNewFile(wchar_t *);
    wchar_t *FindPrevious(wchar_t *, const wchar_t *pTop, const wchar_t *);
    wchar_t *GetCurrentNamespace(wchar_t *, UINT uPos);
    wchar_t *FindTop(wchar_t *, wchar_t *, BOOL &);
    void ParseArray(wchar_t *, VectorString &);

    void WriteWaterMark();
	
};

CVC::ValidationCode ValidateString(const CLocTypeId &, const CLocString &clsOutputLine,
		CReporter &repReporter, const CLocation &loc, const CLString &strContext);

#endif // WMILOCFIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\wmilprs.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMILPRS.CPP

History:

--*/
#include "precomp.h"
#include "stdafx.h"
#include "string.h"

#include "WMIParse.h"
#include "resource.h"
#include "WMIlfile.h"
#include "WMIlprs.h"


//*****************************************************************************
//
// CWMILocParser Construction
//
//*****************************************************************************

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Constructor for CWMILocParser.
//
//-----------------------------------------------------------------------------
CWMILocParser::CWMILocParser() : CPULocParser(g_hDll)
{
	m_fOptionInit = FALSE;
	IncrementClassCount();
}


CWMILocParser::~CWMILocParser()
{
	DEBUGONLY(AssertValid());

	DecrementClassCount();

	// Remove any options
	UnRegisterOptions();
}


//*****************************************************************************
//
// CWMILocParser Overrides
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
//
// ILocVersion
//
///////////////////////////////////////////////////////////////////////////////

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Reports the parser version information.
//
//-----------------------------------------------------------------------------
void 
CWMILocParser::OnGetParserVersion(
		DWORD &dwMajor,	
		DWORD &dwMinor, 
		BOOL &fDebug) const
{
	dwMajor = dwCurrentMajorVersion;
	dwMinor = dwCurrentMinorVersion;
	fDebug = fCurrentDebugMode;
}

	
///////////////////////////////////////////////////////////////////////////////
//
// ILocParser
//
///////////////////////////////////////////////////////////////////////////////

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Initializes the parser. Registers options for the WMI parser.
//
//-----------------------------------------------------------------------------
HRESULT
CWMILocParser::OnInit(
		IUnknown * pUnk
		)
{
	UNREFERENCED_PARAMETER(pUnk);

	LTASSERT(!m_fOptionInit);

	RegisterOptions();
	return ERROR_SUCCESS;
}


HRESULT
CWMILocParser::OnCreateFileInstance(
		ILocFile *&pLocFile,
		FileType ft)
{
	SCODE sc = E_INVALIDARG;

	pLocFile = NULL;

	if (ft == ftUnknown ||
		ft == ftWMIFileType)
	{
		try
		{
			pLocFile = new CWMILocFile(NULL);
			sc = S_OK;
		}
		catch (const CMemoryException *)
		{
			sc = E_OUTOFMEMORY;
		}
	}

	return ResultFromScode(sc);
}


void
CWMILocParser::OnGetParserInfo(
		ParserInfo &pi)
		const
{
	LTASSERT(pi.elExtensions.GetCount() == 0);

	pi.aParserIds.SetSize(1);
	pi.aParserIds[0].m_pid = pidWMI;
	pi.aParserIds[0].m_pidParent = pidNone;

	try
	{
		LTVERIFY(pi.strDescription.LoadString(g_hDll, IDS_WMI_PARSER_DESC));
		LTVERIFY(pi.strHelp.LoadString(g_hDll, IDS_OPT_HELP));
		
		pi.elExtensions.AddTail("MOF");
	}
	catch (CMemoryException *pe)
	{
		pi.strDescription.Empty();
		pe->Delete();
	}
}


void
CWMILocParser::OnGetFileDescriptions(
		CEnumCallback &cb)
		const
{
	CWMILocFile::GetFileDescriptions(cb);
}


///////////////////////////////////////////////////////////////////////////////
//
// ILocStringValidation
//
///////////////////////////////////////////////////////////////////////////////

CVC::ValidationCode
CWMILocParser::OnValidateString(
		const CLocTypeId &ltiType,
		const CLocTranslation &trTrans,
		CReporter *pReporter,
		const CContext &context)
{
	CLString strContext;

	DEBUGONLY(ltiType.AssertValid());
	DEBUGONLY(trTrans.AssertValid());
	LTASSERT(pReporter != NULL);
	DEBUGONLY(pReporter->AssertValid());
	
	return ::ValidateString(ltiType, trTrans.GetTargetString(), *pReporter, 
			context.GetLocation(), context.GetContext());
}


//*****************************************************************************
//
// Parser options.
//
//*****************************************************************************

// Reference count the registering of options since these are global to the
// parser.

static INT g_nOptionRegisterCount = 0;

BEGIN_LOC_UI_OPTIONS_BOOL(optsParserBools)
		LOC_UI_OPTIONS_BOOL_ENTRY(OPT_DISABLE_WATERMARKING,
				FALSE, CLocUIOption::etCheckBox,
				IDS_DISABLE_WATERMARKING_BOOL,
				IDS_DISABLE_WATERMARKING_BOOL_HELP,
				NULL, CLocUIOption::stUser | CLocUIOption::stOverride),

	END_LOC_UI_OPTIONS_BOOL();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Register any options for the parser.
//
//-----------------------------------------------------------------------------
void
CWMILocParser::RegisterOptions()
{

	LTASSERT(g_nOptionRegisterCount >= 0);

	if (g_nOptionRegisterCount++ > 0)
	{
		// Already registered
		return;
	}

	SmartRef<CLocUIOptionSet> spOptSet;
	CLocUIOptionImpHelper OptHelp(g_hDll);
	
	spOptSet = new CLocUIOptionSetDef;
	spOptSet->SetGroupName(g_puid.GetName());
	
	OptHelp.SetBools(optsParserBools, COUNTOF(optsParserBools));

	OptHelp.GetOptions(spOptSet.GetInterface(), IDS_OPT_DESC, 
		IDS_OPT_HELP);

	//m_fOptionInit = RegisterParserOptions(spOptSet.GetInterface());

	if (m_fOptionInit)
	{
		spOptSet.Extract();
	}
}

void
CWMILocParser::UnRegisterOptions()
{
	if (m_fOptionInit)
	{
		if (--g_nOptionRegisterCount == 0)
		{
			// UnRegisterParserOptions(g_puid);		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\buildnum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BUILDNUM.H

History:

--*/

//  Build number file.  This converts the SLM build numbers in PRODVER.H
//  to something a little more useful.
//  
//  This is mostly used by version stamp resoruces.  If you want the build
//  numbers, you should PROBABLY use the ones exported in PBASE (if you are
//  a parser), or function GetVersionInfo() in ESPUTIL.
//

#pragma once

#include "prodver\prodver.h"

#define stringize2(x) #x
#define stringize(x) stringize2(x)
#define frmj rmj
#define frmm rmm
#define frup rup
#define prmj rmj
#define prmm rmm
#define prup rup

#define RELEASE 

#if defined(_DEBUG)
#define ProdVerString stringize(prmj.prmm.prup (Debug) RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup (Debug) RELEASE\0)
#else
#define ProdVerString stringize(prmj.prmm.prup RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup RELEASE\0)
#endif

//
//  Common version information
//
#define CompanyNameString "Microsoft Corporation\0"
#define CopyrightString "Copyright \251 1994-1998 Microsoft Corp.\0"
// copyright for command line tools
#define CopyrightStringCMD "Copyright (C) 1994-1998 Microsoft Corp. All rights reserved.\0"
#define ProductNameString "Microsoft Localization Studio\0"
#define TrademarkString  \
"Microsoft is a registered trademark of Microsoft Corporation. \
Windows(TM) is a trademark of Microsoft Corporation.\0"

#define TIMESTAMP stringize(__TIME__\0)
#define DATESTAMP stringize(__DATE__\0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPTUIL.H

History:

--*/

//  
//  Common classes for Espresso
//  
//  

#pragma once

#pragma comment(lib, "esputil.lib")

#ifdef __cplusplus
#include <mitutil.h>
#include <locutil.h>

//
//  Not everybody gets this by default.

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>
#include <loctypes.h>					//  Generic types.
#include ".\esputil\puid.h"			//  Parser Unique ID
#include ".\esputil\espreg.h"
#include ".\esputil\espenum.h"			//  Various enumeration like objects
#include ".\esputil\dbid.h"			//  Database IDs
#include ".\esputil\globalid.h"
#include ".\esputil\location.h"		//  location for Got To functionality
#include ".\esputil\goto.h"
#include ".\esputil\filespec.h"
#include ".\esputil\context.h"			//  Context for messages - string and location

#include ".\esputil\reporter.h"		//  Message reporting mechanism
#include ".\esputil\espopts.h"


#include ".\esputil\clfile.h"			//  Wrapper for CFile
#include ".\esputil\_wtrmark.h"

#include ".\esputil\resid.h"			//  Resource ID class
#include ".\esputil\typeid.h"			//  Type ID class
#include ".\esputil\uniqid.h"			//  Loc item ID
#include ".\esputil\binary.h"			//  LocItem binary data object
#include ".\esputil\interface.h"
#include ".\esputil\locitem.h"			//  Contents of a single loc item.
#include ".\esputil\itemhand.h"		//  Item handler call-back class


#include ".\esputil\LUnknown.h"		//	CLUnknown child IUnknown helper class.

//
//  These pieces are for the Espresso core components only.
//
#ifndef ESPRESSO_AUX_COMPONENT

#pragma message("Including ESPUTIL private components")

//
//  These files are semi-private - Parsers should not see them.
//
#include ".\esputil\SoftInfo.h"		//	Information about Software projects.
#include ".\esputil\_var.h"
#include ".\esputil\_importo.h"			//  Import options object
#include ".\esputil\_globalid.h"
#include ".\esputil\_goto.h"
#include ".\espUtil\_reporter.h"
#include ".\esputil\_errorrep.h"
#include ".\esputil\_espopts.h"
#include ".\esputil\_interface.h"
#endif


#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locking.h ===
/***
*sys/locking.h - flags for locking() function
*
*	Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the flags for the locking() function.
*	[System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCKING
#define _INC_LOCKING

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#define _LK_UNLCK	0	/* unlock the file region */
#ifdef _WIN32
#define _LK_LOCK	1	/* lock the file region */
#endif
#define _LK_NBLCK	2	/* non-blocking lock */
#ifdef _WIN32
#define _LK_RLCK	3	/* lock for writing */
#endif
#define _LK_NBRLCK	4	/* non-blocking lock for writing */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK	_LK_UNLCK
#ifdef _WIN32
#define LK_LOCK 	_LK_LOCK
#endif
#define LK_NBLCK	_LK_NBLCK
#ifdef _WIN32
#define LK_RLCK 	_LK_RLCK
#endif
#define LK_NBRLCK	_LK_NBRLCK
#endif

#endif	/* _INC_LOCKING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\helpids.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    HELPIDS.H

History:

--*/

#pragma once

//
//  We based off 12000 since that is the start of our resource ID range.
//
//  These have to be unique.  ESPPRJ and RESTBL use up the range 12000-12400
//  for their system wide unique resource ID's, so start at 12400.
//
#define IDH_SPELLDIALOG				12400
#define IDH_UNICODE_CONV			12401   
#define IDH_ENUMERATION_UNSUCCESS		12402
#define IDH_DLGLNIT_RESOURCE			12404
//#define IDH_ACME_PAGEFAULT			12406
#define IDH_NO_PARSER_UPDATE			12408
#define IDH_NO_PARSER_UPLOAD			12410
#define IDH_GENERATE_TERMINATED		12412
#define IDH_OSTRMANX_CLEAR			12414
#define IDH_ITEMS_UNMATCHED			12416
#define IDH_MESSAGE_TABLE			12418
//#define IDH_LINKER_OLD			12426
#define IDH_GETROW_ERROR			12428
#define IDH_SDM_DIALOG				12430
#define IDH_ESPGCOMP				12432
#define IDH_ESPGCOMP_OPTIONS			12434
#define IDH_Eraser_Message			12436
#define IDH_SOURCE_SAME_GEN			12438
#define IDH_SOURCE_SAME_UP			12440	



//The following are for the Project Settings and User Settings Tabs
#define IDH_RESOPT_VALIDATION			12442
#define IDH_RESOPT_SPELLING			12444
#define IDH_RESOPT_TRANSLATION		12446
#define IDH_ESPOPT_FILE				12448
#define IDH_ESPOPT_COPY_ACROSS		12450
#define IDH_ESPOPT_ADMIN			12452
#define IDH_ESPOPT_SET_FONT			12454
#define IDH_ESPOPT_RES_ANLY			12456
#define IDH_ESPOPT_CUSTOM			12003
#define IDH_ESPOPT_LOOKUP			12453
#define IDH_ESPOPT_CUSTFIELD_GLO		30536
#define IDH_ESPOPT_CUSTFIELD_PRO		12003
#define IDH_ESPOPT_COLUMNS			12513
#define IDH_ESPOPT_SUGGESTIONS		37692
#define IDH_ESPOPT_PSEUDO			12478

//The following are for the Parser Properties dialog, General and <parser name> tabs
#define IDH_ESPOPT_PARSER_PROP_GEN		12458
#define	IDH_ESPOPT_PARSER_PROP_SPEC	12460

//This provides help @ the output/translation window when the user presses F1 with the focus there...
#define IDH_PROJECT_WINDOW_F_ONE			12462
#define IDH_TRANS_WINDOW_F_ONE				12464
#define IDH_OUTPUT_PLACEHOLDER				12466

//This is for F1-on-error-message-in-output-window-help
#define IDH_UNEXPECTED_NULL_MACSDM		12468

#define IDH_WORKSPACE_WINDOW_GLOSSARY_F_ONE	12470
#define IDH_WORKSPACE_WINDOW_FILTER_F_ONE 	12472
#define IDH_GLOSSARY_TABLE_F_ONE			12474
#define IDH_SUGGESTIONS_F_ONE				12476

#define IDH_ESPOPT_EXTENSIONS				12480
#define IDH_ESPOPT_ACCELERATORS			12482

//File|Open glossary
#define IDH_FILE_OPEN_GLOSSARY	28676
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mitthrow.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITTHROW.H

History:

--*/

#include ".\Mit\inc\MitThrow.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\extension.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    EXTENSION.H

History:

--*/

#pragma once


#include <esputil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\loctypes.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCTYPES.H

History:

--*/

//  This file contains defintions for simple types that have no
//  implementation.  If you have a 'universal' type that requires
//  implementation, put it in the 'esputil' directory.
//  
 

#pragma once

typedef ULONG SequenceNum;
//typedef int CodePage;
typedef ULONG FileId;
typedef ULONG BinaryId;

const BinaryId bidInvalid = 0;

typedef WORD ParserId;
const ParserId pidNone = 0;

typedef CWordArray CLocParserIdArray;

typedef WORD FileType;

//const CodePage cpInvalidCodePage = 0xDEADBEEF;

const FileType ftUnknown = 0; //Global filetype for an unknown type

// maximum number of bytes for strings corresponding to text fields
const size_t MAX_TXT = 255;

//Maximum number of nodes for Espresso szParents fields
const int MAX_PARENT_NODES = 31;
//
//  These values given to us by the VC guys, and are also in shell\ids.h
//
#ifndef MIN_ESPRESSO_RESOURCE_ID
const DWORD MIN_ESPRESSO_RESOURCE_ID  = 12000;
#endif
#ifndef MAX_ESPRESSO_RESOURCE_ID
const DWORD MAX_ESPRESSO_RESOURCE_ID  = 13999;
#endif

//
//  Now partion our range up for UI and non-UI (shared) components.
//
const DWORD MIN_ESP_UI_RESOURCE_ID    = MIN_ESPRESSO_RESOURCE_ID;
const DWORD MAX_ESP_UI_RESOURCE_ID    = MIN_ESPRESSO_RESOURCE_ID + 699;
const DWORD MIN_ESP_NONUI_RESOURCE_ID = MAX_ESP_UI_RESOURCE_ID + 1;
const DWORD MAX_ESP_NONUI_RESOURCE_ID = MAX_ESPRESSO_RESOURCE_ID;


enum VisualEditor
{
	veNone,
	veApstudio,
	veApstudioSubRes,
	veExternalEditor

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mitutil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITUTIL.H

History:

--*/

#include ".\mit\inc\mitutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCUTIL.H

History:

--*/

#ifndef LOCUTIL_H
#define LOCUTIL_H
#pragma once

#pragma comment(lib, "locutil.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <MitWarning.h>				// MIT Template Library warnings
#pragma warning(ZCOM_WARNING_DISABLE)
#include <ComDef.h>
#pragma warning(ZCOM_WARNING_DEFAULT)

#ifndef __AFXOLE_H__
#include <afxole.h>
#pragma message("Warning: <afxole.h> not in pre-compiled header file, including")
#endif

#include <ltapi.h>
#include ".\LocUtil\FieldVal.h"
#include ".\LocUtil\Operator.h"
#include ".\LocUtil\FieldDef.h"
#include ".\LocUtil\FldDefList.h"
#include ".\LocUtil\Schema.h"
#include ".\LocUtil\FldDefHelp.h"

#include ".\LocUtil\locobj.h"
#include ".\LocUtil\locenum.h"
#include ".\LocUtil\espreg.h"			//  Registry and version info

#include ".\LocUtil\goto.h"
#include ".\LocUtil\gotohelp.h"

#include ".\locutil\report.h"
#include ".\LocUtil\progress.h"		//  'Progressive' objects base class
#include ".\LocUtil\cancel.h"			//  Base class for 'Cancelable" objects
#include ".\locutil\logfile.h"
#include ".\LocUtil\locpct.h"			//  Percent helper classes


#include ".\LocUtil\espopts.h"
#include ".\LocUtil\espstate.h"

#include ".\LocUtil\interface.h"
#include ".\LocUtil\product.h"			//	General functions about the Espresso product installed
#include ".\LocUtil\locstr.h"
#include ".\LocUtil\StringHelp.h"		//	String UI helpers
#include ".\LocUtil\ExtList.h"			//	File Extension list
#include ".\LocUtil\lstime.h"

#ifndef ESPRESSO_AUX_COMPONENT

#pragma message("Including LOCUTIL private components")


//  These files are semi-private - Parsers should not see them.
//
#include ".\LocUtil\FileDlg.h"			//  Wrapper for file dialog
#include ".\LocUtil\FileExclDlg.h"			//  Wrapper for file dialog
#include ".\LocUtil\DcsGrid.h"			// Function for DisplayColumn and MIT Grid
#include ".\LocUtil\PasStrMerge.h"

#include ".\LocUtil\_errorrep.h"		//  Error reporting mechanism
#include ".\LocUtil\_pumpidle.h"		//  Mechanism for idle time
#include ".\LocUtil\_username.h"
#include ".\LocUtil\_progress.h"
#include ".\LocUtil\_cancel.h"
#include ".\LocUtil\_locstr.h"
#include ".\LocUtil\_optvalstore.h"
#include ".\LocUtil\_espopts.h"
#include ".\LocUtil\_extension.h"
#include ".\LocUtil\_interface.h"
#include ".\LocUtil\_locenum.h"
#include ".\LocUtil\_report.h"

#include ".\LocUtil\ShowWarnings.h"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\ltapi.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LTAPI.H

History:

--*/

#ifdef LTAPIENTRY
#undef LTAPIENTRY
#endif

#ifdef IMPLEMENT
#define LTAPIENTRY __declspec(dllexport)

#else  // IMPLEMENT
#define LTAPIENTRY __declspec(dllimport)

#endif // IMPLEMENT


#ifndef LTAPI_H
#define LTAPI_H
//
//  Allow the use of C++ reference types and const methods, without
//  breaking the 'C' world.
//
#ifdef __cplusplus
#define REFERENCE &
#define CONST_METHOD const
#else
#define REFERENCE *
#define CONST_METHOD
#endif

#include <MitThrow.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PBASE.H

History:

--*/
 
#pragma once

#pragma comment(lib, "pbase.lib")

#include ".\pbase\locfile.h"
#include ".\pbase\parseapi.h"
#include ".\pbase\pversion.h"
#include ".\pbase\subparse.h"
#include ".\pbase\binary.h"
#include ".\pbase\imgres32.h"
#include ".\pbase\mnemonic.h"
#include ".\pbase\idupdate.h"
#include ".\pbase\updatelog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mitwarning.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITWARNING.H

History:

--*/

#if !defined(MIT_MitWarning)
#define MIT_MitWarning

#define ZCOM_WARNING_DISABLE disable: 473 454 4100 4244 4310 4505 4510 4610
#define ZCOM_WARNING_DEFAULT default: 473 454 4100 4244 4310 4505 4510 4610

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsutil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PARSUTIL.H

History:

--*/

#pragma once

#pragma comment(lib, "parsutil.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>						// Provide interface definitions 

#include ".\parsers\ParsUtil\LocParser.h"
#include ".\parsers\ParsUtil\LocChild.h"
#include ".\parsers\ParsUtil\LocBinary.h"
#include ".\parsers\ParsUtil\LocVersion.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PARSEMAN.H

History:

--*/
 
#pragma once
#pragma comment(lib, "parseman.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>

#include ".\parseman\pinfo.h"
#include ".\parseman\pmanager.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\precenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PRECENUM.H

History:

--*/

#include ".\mit\inc\PreCEnum.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parser.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PARSER.H

History:

--*/

//  
//  Mother of all include files for parsers.  This should be everything that
//  a parser needs.
//  

#pragma once

#define ESPRESSO_AUX_COMPONENT

#include <esputil.h>
#include <pbase.h>
#include <parsutil.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\puser.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PUSER.H

History:

--*/

//  
//  Master include file for components that need to use parsers, but not
//  implement a parser.
//
//  If you are implementing a parser, use PARSER.H instead.
//  
 
#pragma once

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
#include <parseman.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parserid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PARSERID.H

History:

--*/
 
#pragma once

const ParserId pidMac   = 1;
const ParserId pidText  = 2;
const ParserId pidWin32 = 3;
const ParserId pidIni   = 4;
const ParserId pidWin16 = 5;
const ParserId pidTok   = 6;
const ParserId pidInf   = 7;
const ParserId pidRiff  = 8;
const ParserId pidFox   = 9;
const ParserId pidDos7  = 10;
const ParserId pidNet	= 11;
const ParserId pidVxd	= 12;
const ParserId pidScan	= 13;
const ParserId pidMsg   = 14;
const ParserId pidWinboot = 15;
const ParserId pidRPLBoot = 16;
const ParserId pidMacTok = 17;
const ParserId pidPpd   = 18;
const ParserId pidBmpIcon = 19;
const ParserId pidProject = 20;
const ParserId pidSrg = 21;
const ParserId pidHEAT = 22;

const ParserId pidNashville_BEGIN = 23;	
const ParserId pidNashville_END = 32;   

const ParserId pidPegasus_BEGIN = 33;
const ParserId pidPegasus_STR = 33;
const ParserId pidPegasus_END = 47;   

const ParserId pidOPC = 48;
const ParserId pidDAT = 49;

const ParserId pidPublisher_BEGIN = 50;	
const ParserId pidPublisher_DES = 50;
const ParserId pidPublisher_POC = 51;
const ParserId pidPublisher_CAT = 52;
const ParserId pidPublisher_END = 59;

const ParserId pidJavaRB = 60;

const ParserId pidOffice_BEGIN = 61;
const ParserId pidOffice_END = 80;

const ParserId pidAccWiz = 81;
const ParserId pidINX = 82;

const ParserId pidMsi = 83;
const ParserId pidForms3 = 84;
const ParserId pidVbForms = 85;
const ParserId pidMmc = 86;
const ParserId pidMAPIcfg = 87;

const ParserId pidServerApps_BEGIN = 88;
const ParserId pidServerApps_SysMessages = 88;
const ParserId pidServerApps_END = 92;

const ParserId pidProjectLCP = 93;
const ParserId pidExchangeMNC = 94;

const ParserId pidFsfParse = 95;

const ParserId pidCBTParse = 96;
const ParserId pidWMI = 97;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\types.h ===
/***
*sys/types.h - types returned by system level calls for file and time info
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines types used in defining values returned by system
*       level calls for file status and time information.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TYPES
#define _INC_TYPES

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif


#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;          /* i-node number (not used on DOS) */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif

#define _INO_T_DEFINED
#endif


#ifndef _DEV_T_DEFINED

typedef unsigned int _dev_t;            /* device code */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif

#define _DEV_T_DEFINED
#endif


#ifndef _OFF_T_DEFINED

typedef long _off_t;                    /* file offset value */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif

#define _OFF_T_DEFINED
#endif

#endif  /* _INC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\timeb.h ===
/***
*sys/timeb.h - definition/declarations for _ftime()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file define the _ftime() function and the types it uses.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIMEB
#define _INC_TIMEB

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif


/* Structure returned by _ftime system call */

#ifndef _TIMEB_DEFINED
struct _timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#if     !__STDC__

/* Non-ANSI name for compatibility */

struct timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#endif

#define _TIMEB_DEFINED
#endif


/* Function prototypes */

_CRTIMP void __cdecl _ftime(struct _timeb *);

#if     !__STDC__

/* Non-ANSI name for compatibility */

_CRTIMP void __cdecl ftime(struct timeb *);

#endif


#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIMEB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\utime.h ===
/***
*sys/utime.h - definitions/declarations for utime()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the utime routine to set
*       new file access and modification times.  NOTE - MS-DOS
*       does not recognize access time, so this field will
*       always be ignored and the modification time field will be
*       used to set the new time.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_UTIME
#define _INC_UTIME

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif

#ifdef  _WIN32
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif  /* _WIN32 */

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

/* define struct used by _utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };

#if     !__STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };
#endif

#define _UTIMBUF_DEFINED
#endif


/* Function Prototypes */

_CRTIMP int __cdecl _utime(const char *, struct _utimbuf *);
#ifdef _WIN32
_CRTIMP int __cdecl _futime(int, struct _utimbuf *);

/* Wide Function Prototypes */
_CRTIMP int __cdecl _wutime(const wchar_t *, struct _utimbuf *);
#endif /* _WIN32 */

#if     !__STDC__
/* Non-ANSI name for compatibility */
_CRTIMP int __cdecl utime(const char *, struct utimbuf *);
#endif

#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_UTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\stat.h ===
/***
*sys/stat.h - defines structure used by stat() and fstat()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the _stat() and _fstat()
*       routines.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STAT
#define _INC_STAT

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#include <sys/types.h>


#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif


#ifdef _WIN32
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif /* _WIN32 */


/* define structure for returning status information */

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__

/* Non-ANSI names for compatibility */

struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64
struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#endif

#define _STAT_DEFINED
#endif


#define _S_IFMT         0170000         /* file type mask */
#define _S_IFDIR        0040000         /* directory */
#define _S_IFCHR        0020000         /* character special */
#define _S_IFIFO        0010000         /* pipe */
#define _S_IFREG        0100000         /* regular */
#define _S_IREAD        0000400         /* read permission, owner */
#define _S_IWRITE       0000200         /* write permission, owner */
#define _S_IEXEC        0000100         /* execute/search permission, owner */


/* Function prototypes */

_CRTIMP int __cdecl _fstat(int, struct _stat *);
_CRTIMP int __cdecl _stat(const char *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _fstati64(int, struct _stati64 *);
_CRTIMP int __cdecl _stati64(const char *, struct _stati64 *);
#endif

#ifdef _WIN32
#ifndef _WSTAT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
#endif

#define _WSTAT_DEFINED
#endif
#endif /* _WIN32 */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

_CRTIMP int __cdecl fstat(int, struct stat *);
_CRTIMP int __cdecl stat(const char *, struct stat *);

#endif  /* __STDC__ */


#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\binary.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BINARY.H

History:

--*/


#ifndef ESPUTIL_BINARY_H
#define ESPUTIL_BINARY_H


//
//  Base class for binary classes.  This allows serialization
//  of arbitrary data.
//

class CLocVariant;
class CLocItem;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocBinary : public CObject
{
public:
	CLocBinary();

	virtual void AssertValid(void) const;

	//
	//  Serialization routines. Supports serialization withour dynamic creation
	//
	virtual void Serialize(CArchive &archive);  //Afx serialize function

	//
	//  Result code for comparing one binary class from another.
	//
	enum CompareCode
	{
		noChange,		
		partialChange,    //Only non-localizable data changed
		fullChange        //Localizable data changed
	};
	virtual CompareCode Compare (const CLocBinary *) = 0;

	// Called to update the non-localizable data - Used when compare returns
	// partialChange

	virtual void PartialUpdate(const CLocBinary * binSource) = 0;

	enum Alignment
	{
		a_Default,
		a_Left,
		a_Center,
		a_Right,
		a_Top,
		a_VCenter,
		a_Bottom
	};

	//
	//  The universe of possible binary properties that may be queried for.
	//  This order must NOT change, or you may break old parsers!  Put new
	//  properties at the end.
	//
	enum Property
	{
		//
		//  Native formats..
		//
		p_dwXPosition,
		p_dwYPosition,
		p_dwXDimension,
		p_dwYDimension,
		p_dwAlignment,
		p_blbNativeImage,

		p_dwFontSize,
		p_pasFontName,
		p_dwFontWeight,
		p_dwFontStyle,

		//
		//  Interchange formats..
		//
		p_dwWin32XPosition,
		p_dwWin32YPosition,
		p_dwWin32XDimension,
		p_dwWin32YDimension,
		p_dwWin32Alignment,				// Use Alignment enum
		p_dwWin32ExtAlignment,			// Extended - Use Alignment enum
		p_blbWin32Bitmap,
		p_blbWin32DialogInit,
		
		//
		//  Generic - usable both for Native and Interchange
		//
		p_bVisible,						// Is the item visable?
		p_bDisabled,					// Is the item disabled?
		p_bLTRReadingOrder,				// Is the reading order L to R?
		p_bLeftScrollBar,				// Scroll bar on left?

		//
		//	"Styles" tab for dialog controls.
		//
		p_bLeftText,					// Display text to left of control?

	
		p_bWin32LTRLayout,              // WS_EX_LAYOUT_RTL
		p_bWin32NoInheritLayout,        // WS_EX_NOINHERIT_LAYOUT

		p_dwWin32VAlignment,				// Use Alignment enum

		// Insert new entries here
	};

	virtual BOOL GetProp(const Property, CLocVariant &) const;
	virtual BOOL SetProp(const Property, const CLocVariant &);
	
	//
	// Attempts to convert CBinary in CLocItem to same type as this 
	//
	virtual BOOL Convert(CLocItem *);
	virtual BinaryId GetBinaryId(void) const = 0;
	
	virtual ~CLocBinary();

	BOOL NOTHROW GetFBinaryDirty(void) const;
	BOOL NOTHROW GetFPartialUpdateBinary(void) const;
	void NOTHROW SetFBinaryDirty(BOOL);
	void NOTHROW SetFPartialUpdateBinary(BOOL);

protected:
	
private:
	//
	//  Copy constructor and assignment are hidden, since we
	//  shouldn't be copying these things around.
	//
	CLocBinary(const CLocBinary &);
	const CLocBinary& operator=(const CLocBinary &);
	//
	//  These allow a user to determine what parts of the item have been
	//  changed.
	//
	struct Flags
	{
		BOOL m_fBinaryDirty         :1;
		BOOL m_fPartialUpdateBinary :1;
	};

	Flags m_Flags;
};

#pragma warning(default: 4275)

#include "binary.inl"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\binary.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BINARY.INL

History:

--*/
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::GetFBinaryDirty(void)
		const
{
	return m_Flags.m_fBinaryDirty;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function!
//  
//-----------------------------------------------------------------------------
inline
void
CLocBinary::SetFBinaryDirty(
		BOOL f)
{
	m_Flags.m_fBinaryDirty = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - Comment this function.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::GetFPartialUpdateBinary(void)
		const
{
	return m_Flags.m_fPartialUpdateBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - Comment this function!
//  
//-----------------------------------------------------------------------------
inline
void
CLocBinary::SetFPartialUpdateBinary(
		BOOL f)
{
	m_Flags.m_fPartialUpdateBinary = f;
}



//-----------------------------------------------------------------------------
//
//  Default conversion of one Binary to another format - it fails
//
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::Convert(CLocItem *)
{
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\clfile.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CLFILE.H

History:

--*/

//  
//  Wrapper class for CFile.  It allows us to use CPascalString for
//  file names, and does some 'text mode' read/write operations.
//  This class contains a pointer to a CFile but contains most of
//  the CFile methods thus it can be used as a CFile.  CLFile will either
//  use an existing CFile provided at construction time or it will create its
//  own CFile as needed.  In either case, the enbeded CFile is destroyed when
//  the CLFile is destroyed.
//  
 
#ifndef CLFILE_H
#define CLFILE_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLFile : public CObject
{
public:
	CLFile();
	CLFile(CFile *);
	~CLFile();

	void AssertValid(void) const;

//-----------------------------------------------------------------------------
// The following are the CFile methods that are reimplemented 
//-----------------------------------------------------------------------------
	DWORD GetPosition() const;

	DWORD SeekToEnd();
	void SeekToBegin();

	LONG Seek(LONG lOff, UINT nFrom);
	void SetLength(DWORD dwNewLen);
	DWORD GetLength() const;

	UINT Read(void* lpBuf, UINT nCount);
	void Write(const void* lpBuf, UINT nCount);

	void LockRange(DWORD dwPos, DWORD dwCount);
	void UnlockRange(DWORD dwPos, DWORD dwCount);

	void Abort();
	void Flush();
	void Close();

	CLString GetFileName(void) const;

//-----------------------------------------------------------------------------
// The following are all the CLFile methods
//-----------------------------------------------------------------------------


	BOOL Open(const CPascalString &pstrFileName, UINT nOpenFlags,
			CFileException *pError = NULL);

	static void Rename(const CPascalString &pstrFileName,
			const CPascalString &pstrNewName);
	static void Remove(const CPascalString &pstrFileName);

	static void CopyFile(
			const CPascalString &pasSource,
			const CPascalString &pasTarget,
			BOOL fFailIfExist = TRUE,
			CProgressiveObject *pProgress = NULL);
	
	static BOOL GetStatus(const CPascalString &pstrFileName,
			CFileStatus &rStatus);
	static void SetStatus(const CPascalString &pstrFileName,
			const CFileStatus &status);

	UINT ReadLine(CPascalString &pstrLine, CodePage cp);
	UINT ReadLine(CPascalString &pstrLine);

	UINT ReadString(CPascalString &pstrLine, CodePage cp);
	UINT ReadString(CPascalString &pstrLine);

	UINT ReadByte(BYTE &);
	UINT ReadWord(WORD &, BOOL BigEnded = FALSE);
	UINT ReadDWord(DWORD &, BOOL BigEnded = FALSE);

	UINT ReadPascalB(CPascalString &);
	UINT ReadPascalW(CPascalString &);
	UINT ReadPascalD(CPascalString &);

	UINT ReadPascalB(CPascalString &, CodePage);
	UINT ReadPascalW(CPascalString &, CodePage);
	UINT ReadPascalD(CPascalString &, CodePage);

	UINT Read(CPascalString &pstr, UINT nCount, CodePage cp);
	UINT Read(CPascalString &pstr, UINT nCount);

	UINT WriteLine(const CPascalString &pstrLine, CodePage cp);
	UINT WriteLine(const CPascalString &pstrLine);

	UINT WriteString(const CPascalString &pstrString, CodePage cp);
	UINT WriteString(const CPascalString &pstrString);

	UINT WriteByte(const BYTE &);
	UINT WriteWord(const WORD &, BOOL BigEnded = FALSE);
	UINT WriteDWord(const DWORD &, BOOL BigEnded = FALSE);

	UINT WritePascalB(const CPascalString &);
	UINT WritePascalW(const CPascalString &);
	UINT WritePascalD(const CPascalString &);

	UINT WritePascalB(const CPascalString &, CodePage);
	UINT WritePascalW(const CPascalString &, CodePage);
	UINT WritePascalD(const CPascalString &, CodePage);

	UINT Write(const CPascalString &pstrString);
	UINT Write(const CPascalString &pstrString, CodePage cp);

	UINT SkipToBoundary(UINT nBoundary);
	UINT PadToBoundary(UINT nBoundary, BYTE ucPad = 0);
	void Pad(UINT nCount, BYTE ucPad = 0);

	UINT CopyRange(CLFile &Target, UINT uiNumBytes,
			CProgressiveObject *pProgress = NULL);
	
protected:
	CFile *m_pFile;
	BOOL m_bDeleteFile;	//Should we delete m_pFile in our destructor?
};


enum FileStat
{
	fsNoStatus = 0x00,
	fsNotFound = 0x01,
	fsUpToDate = 0x02,
	fsFileNewer = 0x04,
	fsFileOlder = 0x08,
	fsNotReadable = 0x10,
	fsNotWritable = 0x20
};



WORD
LTAPIENTRY LocateFile(
		const CLString &strFileName,
		const COleDateTime &tGmtFileTime);



#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "clfile.inl"
#endif

#endif // CLFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\clfile.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CLFILE.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the CLFile object - we create the CFile
//  
//-----------------------------------------------------------------------------
inline
CLFile::CLFile()
{
	m_pFile = new CFile();
	m_bDeleteFile = TRUE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the CLFile object - user provides a CFile.  User is
//  responsible for the CFile object!
//  
//-----------------------------------------------------------------------------

inline
CLFile::CLFile(
		CFile *pFile)
{
	LTASSERT(pFile != NULL);
	m_pFile = pFile;
	m_bDeleteFile = FALSE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Destructor - also delete contained CFile if not user supplied.
//
//-----------------------------------------------------------------------------

inline
CLFile::~CLFile()
{
	DEBUGONLY(AssertValid());
	if (m_bDeleteFile)
	{
		delete m_pFile;
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Read a byte at the current file position
//
//-----------------------------------------------------------------------------

inline
UINT							//Byte count read 
CLFile::ReadByte(
	BYTE & byte)				//where to place the byte
{
	if (Read(&byte, sizeof(BYTE)) != sizeof(BYTE))
	{
		AfxThrowFileException(CFileException::endOfFile);
	}
	return sizeof(BYTE);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Write a byte at the current file position
//
//-----------------------------------------------------------------------------

inline
UINT							//Byte count written
CLFile::WriteByte(
		const BYTE & byte)
{
	Write(&byte, sizeof(BYTE));
	return sizeof(BYTE);
}


//-----------------------------------------------------------------------------
// The following are the CFile methods that are reimplemented 
//-----------------------------------------------------------------------------
inline
DWORD
CLFile::GetPosition()
		const
{
	return m_pFile->GetPosition();
}

inline
DWORD
CLFile::SeekToEnd()
{
	return m_pFile->SeekToEnd();
}

inline
void
CLFile::SeekToBegin()
{
	m_pFile->SeekToBegin();
}

inline
LONG
CLFile::Seek(
		LONG lOff,
		UINT nFrom)
{
	return m_pFile->Seek(lOff, nFrom);
}

inline
void
CLFile::SetLength(
		DWORD dwNewLen)
{
	m_pFile->SetLength(dwNewLen);
}

inline
DWORD
CLFile::GetLength()
		const
{
	return m_pFile->GetLength();
}

inline
UINT
CLFile::Read(
		void* lpBuf,
		UINT nCount)
{
	return m_pFile->Read(lpBuf, nCount);
}

inline
void
CLFile::Write(
		const void* lpBuf,
		UINT nCount)
{
	m_pFile->Write(lpBuf, nCount);
}

inline
void
CLFile::Flush()
{
	m_pFile->Flush();
}

inline
void
CLFile::Close()
{
 	m_pFile->Close();
}


inline
void
CLFile::Abort()
{
	m_pFile->Abort();
}



inline
CLString
CLFile::GetFileName(void)
		const
{
	return m_pFile->GetFileName();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\dbid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DBID.H

History:

--*/

#ifndef DBID_H
#define DBID_H


//
// represents a database id
//

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY DBID : public CObject
{
public:
	//
	// ctors
	//
	DBID();
	DBID(const DBID& id);
	DBID(long l);
	~DBID();

	//
	// debug methods
	//
	void AssertValid() const;
	//
	// 'get like' methods
	//
	BOOL NOTHROW IsNull() const;
	NOTHROW operator long () const;
	int NOTHROW operator==(const DBID &) const;
	int NOTHROW operator!=(const DBID &) const;

	//
	// 'put like' methods
	//
	void NOTHROW operator=(const DBID&);
	void NOTHROW Set(long);
	void NOTHROW Clear();

protected:
	long m_l;

private:
	DEBUGONLY(static CCounter m_UsageCounter);
};

#pragma warning(default: 4275)

typedef CArray<DBID, DBID &> CDBIDArray;

	
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "dbid.inl"
#endif

const extern LTAPIENTRY DBID g_NullDBID;
  
#endif // DBID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\context.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CONTEXT.H

History:

--*/

#ifndef ESPUTIL_CONTEXT_H
#define ESPUTIL_CONTEXT_H



//
//  This class should NOT be used as a base class.
//
class LTAPIENTRY CContext
{
public:
	CContext();
	CContext(const CContext &);
	CContext(const CLString &);
	CContext(HINSTANCE, UINT uiStringId); 
	CContext(const CLString &, const CLocation &);
	CContext(HINSTANCE, UINT uiStringId, const CLocation &);
	CContext(const CLString &, const DBID &, ObjectType, View,
			TabId = NullTabId, Component = cmpNone);
	CContext(HINSTANCE, UINT uiStringID, const DBID &, ObjectType, View, 
			TabId = NullTabId, Component = cmpNone);
	
	void AssertValid(void) const;

	const CContext &operator=(const CContext &);

	const CLString &GetContext(void) const;
	const CLocation &GetLocation(void) const;

	BOOL operator==(const CContext &);
			
private:

	CLString m_strContext;
	CLocation m_loc;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "context.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\context.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CONTEXT.INL

History:

--*/



inline
CContext::CContext()
{}


inline
CContext::CContext(
		const CContext & context)
	: m_strContext(context.m_strContext), m_loc(context.m_loc)
{}


inline
CContext::CContext(
		const CLString &strContext)
	: m_strContext(strContext)
{}



inline
CContext::CContext(
		HINSTANCE hDll,
		UINT uiStringID)
	: m_strContext(hDll, uiStringID)
{}



inline
CContext::CContext(
		const CLString &strContext,
		const CLocation &loc)
	: m_strContext(strContext), m_loc(loc)
{}

	

inline
CContext::CContext(
		const CLString &strContext,
		const DBID &dbid,
		ObjectType ot,
		View view,
		TabId tabid,
		Component component)
	: m_strContext(strContext), m_loc(dbid, ot, view, tabid, component)
{}



inline
CContext::CContext(
		HINSTANCE hDll,
		UINT uiStringID,
		const CLocation &loc)
	: m_strContext(hDll, uiStringID), m_loc(loc)
{}


inline
CContext::CContext(
		HINSTANCE hDll, 
		UINT uiStringID, 
		const DBID & dbid, 
		ObjectType ot, 
		View view, 
		TabId tabid, 
		Component component)
	: m_strContext(hDll, uiStringID), 
	  m_loc(dbid, ot, view, tabid, component)
{}


inline
const CLString &
CContext::GetContext(void) const
{
	return m_strContext;
}



inline
const CLocation &
CContext::GetLocation(void)
		const
{
	return m_loc;
}



inline
const 
CContext &
CContext::operator=(const CContext & context)
{
	m_strContext	= context.m_strContext;
	m_loc			= context.m_loc;

	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\dbid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DBID.INL

History:

--*/
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// every new DBID is null
//
//-----------------------------------------------------------------------------
inline
DBID::DBID()
{
	m_l = 0;

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// a DBID can be created from a valid LONG
//
//-----------------------------------------------------------------------------
inline
DBID::DBID(
		LONG l)
{
	LTASSERT(l > 0);

	m_l = l;

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// a DBID can be created from a valid other dbid
//
//-----------------------------------------------------------------------------
inline
DBID::DBID(
		const DBID& id)
{
	ASSERT_VALID(&id);

	m_l = id.m_l;

	DEBUGONLY(++m_UsageCounter);
}



inline
DBID::~DBID()
{
	DEBUGONLY(--m_UsageCounter);
}


	
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// sets the DBID to a valid value
// only a null DBID can be set
// any attempt to change a valid DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
void
DBID::Set(
		LONG l)
{
	ASSERT_VALID(this);
	LTASSERT(l > 0);
	LTASSERT(m_l == 0);

	m_l = l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// sets the DBID to a valid value
// only a null DBID can be set
// any attempt to change a valid DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
void
DBID::operator=(
		const DBID& id)
{
	ASSERT_VALID(this);
	LTASSERT(m_l == 0);
	ASSERT_VALID(&id);

	m_l = id.m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// LONG operator, the only way to get the value of a DBID, any attempt to get
// the value of a null DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
DBID::operator LONG ()
		const
{
	ASSERT_VALID(this);
	LTASSERT(m_l > 0);

	return m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the only way to clear (make it null) the dbid must be explicit
//
//-----------------------------------------------------------------------------
inline
void
DBID::Clear()
{
	ASSERT_VALID(this);

	m_l = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the only way to know if a dbid is null
//
//-----------------------------------------------------------------------------
inline
BOOL
DBID::IsNull()
		const
{
	ASSERT_VALID(this);

	return (m_l == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// == operator
//
//-----------------------------------------------------------------------------
inline
int
DBID::operator==(
		const DBID &dbid)
		const
{
	ASSERT_VALID(this);

	return m_l == dbid.m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// != operator
//
//-----------------------------------------------------------------------------
inline
int
DBID::operator!=(
		const DBID &dbid)
		const
{
	ASSERT_VALID(this);

	return m_l != dbid.m_l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\espopts.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPOPTS.H

History:

--*/

LTAPIENTRY BOOL RegisterParserOptions(CLocUIOptionSet*);
LTAPIENTRY void UnRegisterParserOptions(const PUID&);

LTAPIENTRY BOOL GetParserOptionValue(const PUID &, LPCTSTR szName, CLocOptionVal *&);
LTAPIENTRY BOOL GetParserOptionBool(const PUID&, LPCTSTR pszName);
LTAPIENTRY const CPascalString GetParserOptionString(const PUID&, LPCTSTR pszName);
LTAPIENTRY DWORD GetParserOptionNumber(const PUID&, LPCTSTR pszName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\espenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPENUM.H

History:

--*/


#ifndef ESPENUM_H
#define ESPENUM_H



extern const LTAPIENTRY CString ftDescUnknown; //Description for unknown file types


class LTAPIENTRY CIconType
{
public:
	// Special note: these enum value sequence is of vital importance to
	// the GUI components.  Please preserve them.
	enum IconType
	{
		None = 0,
		Project,		// project root icon
		Directory,		// Part of project structure
		File,			// File object in the project
		Expandable,		// Generic Expandable node in a file.
						// Special note: Any value up to Expandable is
						// currently display as a folder in prj window
		Bitmap,			// Bitmap
		Dialog,			// Dialog like items
		Icon,			// Icon resource
		Version,		// Version stamping resources
		String,			// String resources
		Accel,			// Accelerator
		Cursor,			// Cursor resource
		Menu,			// Menu resources
		Custom,			// Custom resources
		Reference		// icon for reference glossary
	};

	NOTHROW static const TCHAR * GetIconName(CIconType::IconType);
	NOTHROW static HBITMAP GetIconBitmap(CIconType::IconType);
	static void Enumerate(CEnumCallback &);
	
private:
	static const TCHAR *const m_szIconNames[];
	CIconType();
};

typedef CIconType CIT;



class LTAPIENTRY CLocStatus
{
public:
	enum LocStatus
	{
		InvalidLocStatus = 0,
		NotLocalized,
		Updated,
		Obsolete_AutoTranslated,  //  Don't use this!  Obsolete!
		Localized = 4,
		NotApplicable,
		InvalidLocStatus2  // used by edbval to determine a invalid status
		                   // a new "valid" status must be entered before this.
	};

	NOTHROW static const TCHAR * GetStatusText(CLocStatus::LocStatus);
	NOTHROW static const TCHAR * GetStatusShortText(CLocStatus::LocStatus);
	NOTHROW static CLocStatus::LocStatus MapShortTextToEnum(const TCHAR *);
	NOTHROW static CLocStatus::LocStatus MapCharToEnum(const TCHAR);
	NOTHROW static CLocStatus::LocStatus MapLongTextToEnum(const TCHAR *szLongName);
	
	static void Enumerate(CEnumCallback &);
	
private:
	struct StatusInfo
	{
		const TCHAR *szStatusShortText;
		const TCHAR *szStatusText;
	};

	static const StatusInfo m_Info[];

	CLocStatus();
};

typedef CLocStatus CLS;




#endif // ESPENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\espreg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPREG.H

History:

--*/
//  
//  Registry and version information for Espresso 2.x
//  
 



//
//  Provided so parsers can register themselves.
//
LTAPIENTRY HRESULT RegisterParser(HMODULE);
LTAPIENTRY HRESULT UnregisterParser(ParserId pid, ParserId pidParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\filespec.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FILESPEC.H

History:

--*/

#ifndef ESPUTIL_FILESPEC_H
#define ESPUTIL_FILESPEC_H

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CFileSpec : public CObject
{
public:
	NOTHROW CFileSpec();
	NOTHROW CFileSpec(const CFileSpec &);
	NOTHROW CFileSpec(const CPascalString &, const DBID &);

	void AssertValid(void) const;

	NOTHROW void SetFileName(const CPascalString &);
	NOTHROW void SetFileId(const DBID &);

	NOTHROW const CPascalString & GetFileName(void) const;
	NOTHROW const DBID & GetFileId(void) const;

	NOTHROW const CFileSpec & operator=(const CFileSpec &);
	
	~CFileSpec();
	
private:
	
	CPascalString m_pasFileName;
	DBID m_didFileId;
};

#pragma warning(default: 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\globalid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GLOBALID.H

History:

--*/

#ifndef ESPUTIL_GLOBALID_H
#define ESPUTIL_GLOBALID_H

enum ObjectType
{
	otNone,
	otFile,
	otResource,
};



///////////////////////////////////////////////////////////////////////////////
//
// global id object, represents what fully qualifies any database item
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 
class LTAPIENTRY CGlobalId: public CObject
{
public:
	//
	// ctor/dtor
	//
	NOTHROW CGlobalId();
	NOTHROW CGlobalId(const DBID &dbid, ObjectType otType);
	NOTHROW CGlobalId(const CGlobalId &id);
	NOTHROW ~CGlobalId();
	
	//
	// operators
	//
	NOTHROW int operator==(const CGlobalId &) const;
	NOTHROW int operator!=(const CGlobalId &) const;

	NOTHROW const CGlobalId & operator=(const CGlobalId &);
	
	NOTHROW const DBID & GetDBID() const;
	NOTHROW ObjectType GetObjType(void) const;
	
protected:
	//
	// debug routines
	//
	virtual void AssertValid() const;

	//
	// data members
	//
	DBID  m_dbid;
	ObjectType  m_otObjType;

	DEBUGONLY(static CCounter m_UsageCounter);
};

#pragma warning(default: 4275)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "globalid.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\goto.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GOTO.H

History:

--*/

#pragma once


LTAPIENTRY CGoto *CreateEspGoto(const CLocation &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\interface.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    INTERFACE.H

History:

--*/

//  
//  Various public interfaces in Espresso.
//  
 
#pragma once


extern const LTAPIENTRY IID IID_ILocStringValidation;

class CLocTranslation;

DECLARE_INTERFACE_(ILocStringValidation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(CVC::ValidationCode, ValidateString)
		(THIS_ const CLocTypeId REFERENCE, const CLocTranslation REFERENCE,
				CReporter *, const CContext &) PURE;
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\globals.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GLOBALS.H

History:

--*/
void GlobalInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\itemhand.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ITEMHAND.H

History:

--*/

//  
//  Declaration for the item handler class.  This encapsulates the call-back
//  functionality for the Parsers during an enumeration.
//  
 

#ifndef ITEMHAND_H
#define ITEMHAND_H


class LTAPIENTRY CLocItemHandler : public CReporter, public CCancelableObject
{
public:
	CLocItemHandler();

	void AssertValid(void) const;
	
	virtual BOOL HandleItemSet(CLocItemSet &) = 0;

	virtual ~CLocItemHandler();
			
private:
};

#endif //  ITEMHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\globalid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GLOBALID.INL

History:

--*/

inline
CGlobalId::CGlobalId()
{
	m_otObjType = otNone;
	
	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ctor
//
//-----------------------------------------------------------------------------
inline
CGlobalId::CGlobalId(
		const DBID &dbid,
		ObjectType ot)
{
	m_dbid = dbid;
	m_otObjType = ot;

	DEBUGONLY(++m_UsageCounter);
}

inline
CGlobalId::CGlobalId(
		const CGlobalId &id)
{
	m_dbid = id.m_dbid;
	m_otObjType = id.m_otObjType;

	DEBUGONLY(++m_UsageCounter);
}



inline
CGlobalId::~CGlobalId()
{
	DEBUGONLY(--m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// == operator
//
//-----------------------------------------------------------------------------
inline
int
CGlobalId::operator==(
		const CGlobalId& id)
		const
{
	return (m_dbid == id.m_dbid && m_otObjType == id.m_otObjType);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// != operator
//
//-----------------------------------------------------------------------------
inline
int
CGlobalId::operator!=(
		const CGlobalId& id)
		const
{
	return !(m_dbid == id.m_dbid && m_otObjType == id.m_otObjType);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Get the dbid
//
//-----------------------------------------------------------------------------

inline
const DBID &
CGlobalId::GetDBID()
		const
{
	return m_dbid;
}


inline
ObjectType
CGlobalId::GetObjType(void)
		const
{
	return m_otObjType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\puid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PUID.H

History:

--*/

#pragma once

struct LTAPIENTRY PUID
{
	PUID();
	PUID(ParserId pid, ParserId pidParent);
	CLString GetName(void) const;
	
	ParserId m_pid;
	ParserId m_pidParent;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "puid.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\lunknown.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LUNKNOWN.H

History:

--*/
#if !defined (EspUtil_LUnknown_h)
#define EspUtil_LUnknown_h


////////////////////////////////////////////////////////////////////////////////
// CLUnknown
//
//	A abstract base class that is designed to help when creating child classes
//	that depend on a parent class.  These classes can not exist by themselves,
//	but instead mearly export different interfaces to the parent class.
//
// Rules:
//	1.	All classes must have a valid, non-NULL parent pointer.
//	2.	The parent class is responsible for AddRef()'ing itself during
//		QueryInterface().
//
////////////////////////////////////////////////////////////////////////////////

class LTAPIENTRY CLUnknown
{
// Construction
public:
	CLUnknown(IUnknown * pParent);
protected:  // Don't allow stack objects
	virtual ~CLUnknown() = 0;

// Data
protected:
	ULONG		m_ulRef;	// Reference count
	IUnknown *	m_pParent;	// Parent of object

// Operations
public:
	ULONG AddRef();
	ULONG Release();
	HRESULT QueryInterface(REFIID iid, LPVOID * ppvObject);
};
////////////////////////////////////////////////////////////////////////////////

#include "LUnknown.inl"

#if !defined(DECLARE_CLUNKNOWN)

#define DECLARE_CLUNKNOWN() \
public: \
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj); \
	STDMETHOD_(ULONG, AddRef)(THIS); \
	STDMETHOD_(ULONG, Release)(THIS);

#endif

#if !defined(IMPLEMENT_CLUNKNOWN)

#define IMPLEMENT_CLUNKNOWN_ADDREF(ObjectClass) \
	STDMETHODIMP_(ULONG) ObjectClass::AddRef(void) \
	{ \
		return CLUnknown::AddRef(); \
	}

#define IMPLEMENT_CLUNKNOWN_RELEASE(ObjectClass) \
	STDMETHODIMP_(ULONG) ObjectClass::Release(void) \
	{ \
		return CLUnknown::Release(); \
	}

#define IMPLEMENT_CLUNKNOWN_QUERYINTERFACE(ObjectClass) \
	STDMETHODIMP ObjectClass::QueryInterface(REFIID riid, LPVOID *ppVoid) \
	{ \
		return (HRESULT) CLUnknown::QueryInterface(riid, ppVoid); \
	}

#define IMPLEMENT_CLUNKNOWN(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_ADDREF(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_RELEASE(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_QUERYINTERFACE(ObjectClass)

#endif




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\location.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCATION.H

History:

--*/

#ifndef ESPUTIL_LOCATION_H
#define ESPUTIL_LOCATION_H



typedef CWnd *TabId;
const TabId NullTabId = 0;

enum View
{
	vNone,
	vTransTab,
	vVisualEditor,
	vProjWindow
};

enum Component
{
	cmpNone,
	cmpSource,
	cmpTarget,
	cmpSourceAndTarget
};
	
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocation : public CObject
{
public:
	NOTHROW CLocation();
	NOTHROW CLocation(const CLocation &);
	NOTHROW CLocation(const CGlobalId &, View, TabId = NullTabId, Component = cmpNone);
	NOTHROW CLocation(const DBID &, ObjectType, View, TabId = NullTabId, Component = cmpNone);
	
#ifdef _DEBUG
	virtual void AssertValid(void) const;
#endif
	
	NOTHROW const CLocation & operator=(const CLocation &);
	NOTHROW int operator==(const CLocation &) const;
	NOTHROW int operator!=(const CLocation &) const;

	NOTHROW const CGlobalId & GetGlobalId(void) const;
	NOTHROW TabId GetTabId(void) const;
	NOTHROW View GetView(void) const;
	NOTHROW Component GetComponent(void) const;
	NOTHROW BOOL IsVisual(void) const;

	NOTHROW void SetGlobalId(const CGlobalId &);
	NOTHROW void SetTabId(const TabId);
	NOTHROW void SetView(View);
	NOTHROW void SetComponent(Component);

	NOTHROW ~CLocation() {};

private:
	NOTHROW void AssignFrom(const CLocation &);
	NOTHROW BOOL Compare(const CLocation &) const;
	
	CGlobalId m_giId;
	TabId m_TabId;
	View m_View;
	Component m_Component;
};

#pragma warning(default: 4275)

const extern LTAPIENTRY CLocation g_locNull;

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "location.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\locitem.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCITEM.INL

History:

--*/

//  
//  Inline functions for the CLocItem class.  This is included by locitem.h.
//  
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns whether or not the item has a localizable string.
//  
//-----------------------------------------------------------------------------
inline                                                                  
BOOL									// TRUE if there's a localizable string
CLocItem::HasLocString(void)
		const
{
	return !GetLocString().GetString().IsNull();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns whether or not the item has binary info.
//  
//-----------------------------------------------------------------------------
inline                                                                  
BOOL									// TRUE if the item has bin. content
CLocItem::HasBinary(void)
		const
{
	return m_pBinary!= NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the database id for the item.  This is internal to the DB, and
//  should not be used except to indicate parent child relationships and for
//  database operations.
//  
//-----------------------------------------------------------------------------
inline
const DBID&								// The database id for the item.
CLocItem::GetMyDatabaseId(void)
		const
{
	return m_dbid;
}





inline
const DBID &
CLocItem::GetPseudoParentId(void)
		const
{
	return m_PseudoParent;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the ID for the item.
//  
//-----------------------------------------------------------------------------
inline
const CLocUniqueId &
CLocItem::GetUniqueId(void)
	const
{
	return m_uid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the ID for the item.
//  
//-----------------------------------------------------------------------------
inline
CLocUniqueId &
CLocItem::GetUniqueId(void)
{
	return m_uid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current localization status for the translation of the item.
//  
//-----------------------------------------------------------------------------
inline
CLS::LocStatus							// Status for the item.
CLocItem::GetTranslationStatus(void)
		const
{
	return m_lsTranslationStatus;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current localization status for the binary part of the item.
//  
//-----------------------------------------------------------------------------
inline
CLS::LocStatus							// Status for the item.
CLocItem::GetBinaryStatus(void)
		const
{
	return m_lsBinaryStatus;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current translation origin for the item.
//  
//-----------------------------------------------------------------------------
inline
CTO::TranslationOrigin							// origin for the item.
CLocItem::GetTranslationOrigin(void)
		const
{
	return m_toTranslationOrigin;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current approval status for the item.
//  
//-----------------------------------------------------------------------------
inline
CAS::ApprovalState							// Status for the item.
CLocItem::GetApprovalStatus(void)
		const
{
	return m_asApprovalStatus;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current auto approval status for the item.
//  
//-----------------------------------------------------------------------------
inline
CAA::AutoApproved 						// Status for the item.
CLocItem::GetAutoApproved(void)
		const
{
	return m_auto_approved;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current confidence level for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetConfidenceLevel(void)
		const
{
	return m_confidence_level;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom1 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom1(void)
		const
{
	return m_custom1;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom2 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom2(void)
		const
{
	return m_custom2;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom3 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom3(void)
		const
{
	return m_custom3;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom4 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom4(void)
		const
{
	return m_custom4;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom5 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom5(void)
		const
{
	return m_custom5;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom6 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom6(void)
		const
{
	return m_custom6;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets the display order for the item. This is used to provide a default
//  ordering of items in the resource table.  Lower values are displayed first.
//  
//-----------------------------------------------------------------------------
inline
UINT									// Display order for the item.
CLocItem::GetDisplayOrder(void)
		const
{
	return m_uiDisplayOrder;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the CLocString for the item.  To determine if it is valid, use
//  HasLocString().  A valid string can be blank!
//  
//-----------------------------------------------------------------------------
inline
const CLocString &						// Current string for the item.
CLocItem::GetLocString(void)
	const
{
	return m_lsString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'intructions' (developer provided comments) for an item.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Developer intructions.
CLocItem::GetInstructions(void)
		const
{
	return m_pstrInstructions;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'term notes' (glossary note) for an item.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Glossary Notes.
CLocItem::GetTermNotes(void)
		const
{
	return m_pstrTermNotes;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'InstrAtt'  for an item.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFInstrAtt(void)
		const
{
	return m_Flags.m_fInstrAtt;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets the binary content for an item.  If this function returns FALSE, the
//  return pointer is set to NULL.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the content is valid.
CLocItem::GetBinary(
		const CLocBinary *&pBinary) // RETURN pointer
		const
{
	pBinary = m_pBinary;
	
	return pBinary != NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	Similar to GetBinary() but after this call
//	the item will no longer have a CLocBinary.
//	By calling this member, the caller gets
//	ownership of the CLocBinary, so he is responsible
//	of either deleting the CLocBinary or assigning
//	it to another CLocItem via the SetBinary() member.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if a CLocBinary was extracted.
CLocItem::ExtractBinary(
		CLocBinary *&pBinary) // RETURN pointer
{
	pBinary = m_pBinary;
	m_pBinary = NULL;
	
	return pBinary != NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the icon type fro the item.
//  
//-----------------------------------------------------------------------------
inline
CIT::IconType
CLocItem::GetIconType(void)
		const
{
	return m_icIconType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the editor for this item (and all it's children!).
//  
//-----------------------------------------------------------------------------
inline
VisualEditor
CLocItem::GetVisualEditor(void)
		const
{
	return m_veEditor;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the database id for the item.  ONLY the database code should use
//  this method.  This may become protected/private in the future!
//
//  The Database id will not allow itself be set twice!
//
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetMyDatabaseId(
		const DBID& dbid)				// New datbase id for this item.
{
	m_dbid = dbid;
}



inline void
CLocItem::SetPseudoParent(
		const DBID &dbid)
{
	m_PseudoParent.Clear();
	
	m_PseudoParent = dbid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the localization status for the translation part of the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTranslationStatus(
		CLS::LocStatus lsNewStatus)		// New status for the item.
{
	m_lsTranslationStatus = lsNewStatus;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the localization status for the binary part of the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetBinaryStatus(
		CLS::LocStatus lsNewStatus)		// New status for the item.
{
	m_lsBinaryStatus = lsNewStatus;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the translation origin for the item.  This is of interest to the
//  Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTranslationOrigin(
		CTO::TranslationOrigin toNewOrigin)		// New origin for the item.
{
	m_toTranslationOrigin = toNewOrigin;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the approval status for the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetApprovalStatus(
		CAS::ApprovalState asNewStatus)		// New status for the item.
{
	m_asApprovalStatus = asNewStatus;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the auto approval status for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetAutoApproved(
		CAA::AutoApproved aaNewStatus)		// New status for the item.
{
	m_auto_approved = aaNewStatus;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the confidence level for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetConfidenceLevel(
		long lConfLevel)		// New confidence level for the item.
{
	m_confidence_level = lConfLevel;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom1 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom1(
		long lCustom1)		
{
	m_custom1 = lCustom1;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom2 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom2(
		long lCustom2)		
{
	m_custom2 = lCustom2;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom3 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom3(
		long lCustom3)		
{
	m_custom3 = lCustom3;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom4 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom4(
		long lCustom4)		
{
	m_custom4 = lCustom4;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom5 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom5(
		long lCustom5)		
{
	m_custom5 = lCustom5;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom6 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom6(
		long lCustom6)		
{
	m_custom6 = lCustom6;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the display order for an item.  This is used to provide a default
//  ordering of items in the resource table.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetDisplayOrder(
		UINT uiNewDisplayOrder)			// New display order for the item.
{
	m_uiDisplayOrder = uiNewDisplayOrder;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the visual editor for the item.  The parser sets this.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetVisualEditor(
		VisualEditor veNewEditor)
{
	m_veEditor = veNewEditor;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set the icon type.  This is displayed bside the item in the Translation
//  table.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetIconType(
		CIT::IconType itNewIconType)
{
	m_icIconType = itNewIconType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the intstructions for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetInstructions(
		const CPascalString &pstrNewInstructions) // New instructions.
{
	if (pstrNewInstructions != m_pstrInstructions)
	{
		m_pstrInstructions = pstrNewInstructions;
		SetFInstructionsDirty(TRUE);
	}
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the term notes for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTermNotes(
		const CPascalString &pstrNewTermNotes) // New Term Notes.
{
	if (pstrNewTermNotes != m_pstrTermNotes)
	{
		m_pstrTermNotes = pstrNewTermNotes;
	}
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the InstrAtt for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFInstrAtt(
		BOOL f)
{
	m_Flags.m_fInstrAtt = f;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clears all the dirty flags for the item and its sub-components.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::ClearDirtyFlags(void)
{
	m_Flags.m_fTargetStringDirty = m_Flags.m_fStringDirty = 
			m_Flags.m_fItemDirty = m_Flags.m_fInstructionsDirty = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clear/Set various internal state flags
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFEqualSrcTgtString(void) const
{
	return m_Flags.m_fEqualSrcTgtString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFEqualSrcTgtString(BOOL f)
{
	m_Flags.m_fEqualSrcTgtString = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFEqualSrcTgtBinary(void) const
{
	return m_Flags.m_fEqualSrcTgtBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFEqualSrcTgtBinary(BOOL f)
{
	m_Flags.m_fEqualSrcTgtBinary = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get and set methods for all the Dirty flags.  Used by the update code.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFStringDirty(void) const
{
	return m_Flags.m_fStringDirty;
}

inline
void
CLocItem::SetFStringDirty(BOOL f)
{
	m_Flags.m_fStringDirty = f;
}

inline
BOOL
CLocItem::GetFTargetStringDirty(void) const
{
	return m_Flags.m_fTargetStringDirty;
}

inline
void
CLocItem::SetFTargetStringDirty(BOOL f)
{
	m_Flags.m_fTargetStringDirty = f;
}

inline
BOOL
CLocItem::GetFItemDirty(void) const
{
	return m_Flags.m_fItemDirty;
}

inline
void
CLocItem::SetFItemDirty(BOOL f)
{
	m_Flags.m_fItemDirty = f;
}

inline
BOOL
CLocItem::GetFInstructionsDirty(void)
		const
{
	return m_Flags.m_fInstructionsDirty;
}

inline
void
CLocItem::SetFInstructionsDirty(
		BOOL f)
{
	m_Flags.m_fInstructionsDirty = f;
}

inline
BOOL
CLocItem::GetFValidTranslation(void) const
{
	return m_Flags.m_fValidTranslation;
}

inline
void
CLocItem::SetFValidTranslation(BOOL f)
{
	m_Flags.m_fValidTranslation = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Global is anything in this CBinary dirty
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::IsAnyDirty()
{
	return m_Flags.m_fItemDirty ||
		m_Flags.m_fStringDirty || 
		m_Flags.m_fTargetStringDirty ||
		m_Flags.m_fInstructionsDirty ||
		(m_pBinary==NULL ? FALSE : m_pBinary->GetFBinaryDirty());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clear/Set various parser flags
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFDevLock(void) const
{
	return m_Flags.m_fDevLock;
}

inline
void
CLocItem::SetFDevLock(BOOL f)
{
	m_Flags.m_fDevLock = f;
}

inline
BOOL
CLocItem::GetFUsrLock(void) const
{
	return m_Flags.m_fUsrLock;
}
inline
void
CLocItem::SetFUsrLock(BOOL f)
{
	m_Flags.m_fUsrLock = f;
}

inline
BOOL
CLocItem::GetFTransLock(void) const
{
	return m_Flags.m_fTransLock;
}
inline
void
CLocItem::SetFTransLock(BOOL f)
{
	m_Flags.m_fTransLock = f;
}


inline
BOOL
CLocItem::GetFExpandable(void) const
{
	return m_Flags.m_fExpandable;
}

inline
void
CLocItem::SetFExpandable(BOOL f)
{
	m_Flags.m_fExpandable = f;
}

inline
BOOL
CLocItem::GetFDisplayable(void) const
{
	return m_Flags.m_fDisplayable;
}

inline
void
CLocItem::SetFDisplayable(BOOL f)
{
	m_Flags.m_fDisplayable = f;
}

inline
BOOL
CLocItem::GetFNoResTable(void) const
{
	return m_Flags.m_fNoResTable;
}

inline
void
CLocItem::SetFNoResTable(BOOL f)
{
	m_Flags.m_fNoResTable = f;
}



inline
void
CLocItem::SetLocString(
		const CLocString &lsNewString)
{
	m_lsString = lsNewString;
}



inline
void
CLocItem::SetUniqueId(
		const CLocUniqueId &uid)
{
	m_uid = uid;
}



inline
void
CLocItem::ClearUniqueId(void)
{
	m_uid.ClearId();
}


	
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the binary content for the item.  If there was a previous binary
//  content, it is deleted.
//  
//-----------------------------------------------------------------------------
inline 
void
CLocItem::SetBinary(
		CLocBinary *pNewBinary)
{
	if (m_pBinary != NULL)
	{
		delete m_pBinary;
	}
	m_pBinary = pNewBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the item editable?
//  
//-----------------------------------------------------------------------------
inline
BOOL 
CLocItem::IsLocked(void) const
{
	return (GetFDevLock() || GetFUsrLock());
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the item ignored by the visual editor
//  
//-----------------------------------------------------------------------------
inline
BOOL CLocItem::GetFVisEditorIgnore(void) const
{
	return m_Flags.m_fVisEditorIgnore;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set if the item is ignored by the visual editor
//  
//-----------------------------------------------------------------------------
inline
void 
CLocItem::SetFVisEditorIgnore(BOOL f)
{
	m_Flags.m_fVisEditorIgnore = f; 
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Needed so that the CMnemonic class can be used as the key of a CMap
//  
//-----------------------------------------------------------------------------
inline
CMnemonic::operator unsigned long() const
{
	return MAKELONG(m_cHotkeyChar, m_nHotkeyScope);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\itemhand.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ITEMHAND.INL

History:

--*/
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Retail versions do nothing.  Debug code is in reporter.cpp
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\locitem.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCITEM.H

History:

--*/
#ifndef LOCITEM_H
#define LOCITEM_H



#pragma warning(disable : 4251)  // Shut up already about _declspec(import)
#pragma warning(disable : 4275)  // Shut up already about _declspec(export)

class CLocItem;


//
//  Class to hold an array of pointers to items.
//
class LTAPIENTRY CLocItemPtrArray : public CTypedPtrArray<CPtrArray, CLocItem *>
{
public:
	NOTHROW CLocItemPtrArray(BOOL fDelete=TRUE);

	void AssertValid(void) const;

	void NOTHROW ClearItemPtrArray(void);
	int NOTHROW Find(DBID, const CLocItem * &, BOOL bLocalizableOnly = FALSE) const;

	virtual ~CLocItemPtrArray();

private:
	CLocItemPtrArray(const CLocItemPtrArray &);
	void operator=(const CLocItemPtrArray &);

	BOOL m_fDelete;
};


//
//  Class to hold an item set.  This is an array of items that all have the
//  same identifier.
//
class LTAPIENTRY CLocItemSet : public CLocItemPtrArray
{
public:
	NOTHROW CLocItemSet(BOOL fDelete=TRUE);

	void AssertValid(void) const;
	
	NOTHROW const CLocUniqueId & GetUniqueId(void) const;
	NOTHROW const DBID & GetPseudoParentId(void) const;

	NOTHROW void ClearItemSet(void);

	NOTHROW void Match(const CLocItemSet &, CMap<int, int, int, int> &);

	NOTHROW int Find(CLocItem * pItem, int nStartAt = 0);
	
	NOTHROW ~CLocItemSet();
	
private:
	static const CLocUniqueId m_luid;     //This is a default last ditch 
	DEBUGONLY(static CCounter m_UsageCounter);
};

//
//  A localizable item. 
//  It represents either source or target data, depending on the context, but not both.
//
class LTAPIENTRY CLocItem : public CObject
{
public:
	NOTHROW CLocItem();

	void AssertValid(void) const;
	
	//
	//  Read-only access members
	//
	NOTHROW BOOL HasLocString(void) const;
	NOTHROW BOOL HasBinary(void) const;
	
	NOTHROW const DBID & GetMyDatabaseId(void) const;
	NOTHROW const CLocUniqueId & GetUniqueId(void) const;
	const DBID &GetPseudoParentId(void) const;
	NOTHROW CLocUniqueId & GetUniqueId(void);
	
	NOTHROW CLS::LocStatus GetTranslationStatus(void) const;
	NOTHROW CLS::LocStatus GetBinaryStatus(void) const;
	NOTHROW CTO::TranslationOrigin GetTranslationOrigin(void) const;
	NOTHROW CAS::ApprovalState GetApprovalStatus(void) const;
	NOTHROW CAA::AutoApproved GetAutoApproved(void) const;
	NOTHROW long GetConfidenceLevel(void) const;
	NOTHROW long GetCustom1(void) const;
	NOTHROW long GetCustom2(void) const;
	NOTHROW long GetCustom3(void) const;
	NOTHROW long GetCustom4(void) const;
	NOTHROW long GetCustom5(void) const;
	NOTHROW long GetCustom6(void) const;

	NOTHROW const CLocString & GetLocString(void) const;
	
	NOTHROW BOOL GetBinary(const CLocBinary *&) const;

	NOTHROW CIT::IconType GetIconType(void) const;
	NOTHROW const CPascalString & GetInstructions(void) const;
	NOTHROW const CPascalString GetInstructions(BOOL) const;
	NOTHROW const CPascalString & GetTermNotes(void) const;
	NOTHROW UINT GetDisplayOrder(void) const;
	NOTHROW VisualEditor GetVisualEditor(void) const;

	NOTHROW BOOL GetFEqualSrcTgtString(void) const;
	NOTHROW void SetFEqualSrcTgtString(BOOL);
	NOTHROW BOOL GetFEqualSrcTgtBinary(void) const;
	NOTHROW void SetFEqualSrcTgtBinary(BOOL);
	NOTHROW BOOL GetFStringDirty(void) const;
	NOTHROW void SetFStringDirty(BOOL);
	NOTHROW BOOL GetFTargetStringDirty(void) const;
	NOTHROW void SetFTargetStringDirty(BOOL);
	NOTHROW BOOL GetFItemDirty(void) const;
	NOTHROW void SetFItemDirty(BOOL);
	NOTHROW BOOL IsAnyDirty(void);
	NOTHROW BOOL IsLocked(void) const;

	NOTHROW BOOL GetFDevLock(void) const;
	NOTHROW void SetFDevLock(BOOL);
	NOTHROW BOOL GetFTransLock(void) const;
	NOTHROW void SetFTransLock(BOOL);
	NOTHROW BOOL GetFUsrLock(void) const;
	NOTHROW void SetFUsrLock(BOOL);
	NOTHROW BOOL GetFExpandable(void) const;
	NOTHROW void SetFExpandable(BOOL);
	NOTHROW BOOL GetFDisplayable(void) const;
	NOTHROW void SetFDisplayable(BOOL);
	NOTHROW BOOL GetFNoResTable(void) const;
	NOTHROW void SetFNoResTable(BOOL);
	NOTHROW BOOL GetFValidTranslation(void) const;
	NOTHROW void SetFValidTranslation(BOOL);
	NOTHROW BOOL GetFVisEditorIgnore(void) const;
	NOTHROW void SetFVisEditorIgnore(BOOL);

	NOTHROW void SetFInstructionsDirty(BOOL);
	NOTHROW BOOL GetFInstructionsDirty(void) const;
	
	NOTHROW void SetFInstrAtt(BOOL);
	NOTHROW BOOL GetFInstrAtt(void) const;

	//
	//  Assignment members.  These set the appropriate dirty flags in the
	//  item.
	//

	NOTHROW void SetMyDatabaseId(const DBID&);
	NOTHROW void SetUniqueId(const CLocUniqueId &);
	NOTHROW void SetPseudoParent(const DBID &);
	NOTHROW void SetLocString(const CLocString &);
	NOTHROW void ClearUniqueId(void);
	NOTHROW void SetTranslationStatus(CLS::LocStatus);
	NOTHROW void SetBinaryStatus(CLS::LocStatus);
	NOTHROW void SetTranslationOrigin(CTO::TranslationOrigin);
	NOTHROW void SetApprovalStatus(CAS::ApprovalState);
	NOTHROW void SetAutoApproved(CAA::AutoApproved);
	NOTHROW void SetConfidenceLevel(long);
	NOTHROW void SetCustom1(long);
	NOTHROW void SetCustom2(long);
	NOTHROW void SetCustom3(long);
	NOTHROW void SetCustom4(long);	
	NOTHROW void SetCustom5(long);
	NOTHROW void SetCustom6(long);
	NOTHROW void SetIconType(CIT::IconType);
	NOTHROW void SetInstructions(const CPascalString &);
	NOTHROW void SetTermNotes(const CPascalString &);
	NOTHROW void SetDisplayOrder(UINT);
	NOTHROW void SetVisualEditor(VisualEditor);


	//
	//  Setting the binary part will delete the
	//  previous one!
	//
	NOTHROW void SetBinary(CLocBinary *);

	NOTHROW BOOL ExtractBinary(CLocBinary *&);

	NOTHROW void TransferBinary(CLocItem *);

	//
	//  Clear ALL the dirty flags for the item.
	//
	NOTHROW void ClearDirtyFlags(void);

	//	Kind of smart assignment
	BOOL UpdateFrom(CLocItem &);

	enum eLocContent
	{
		Source,
		Target
	};

	enum eDataFlow
	{
		FromFileToDb,
		FromDbToFile
	};
	//	Kind of assignment for localizable content only.
	BOOL UpdateLocContentFrom(
		CLocItem & itemInput, 
		eDataFlow nDataFlow, 
		eLocContent nFrom, 
		eLocContent nTo);
	//Used to know how similar is the localizable content between 2 items
	enum eMatchType
	{
		matchEmpty,
		matchBinary,
		matchString,
		matchFull
	};
	int MatchLocContent(const CLocItem &);
	//
	//  Comparisons between localizable items.
	//
	NOTHROW int operator==(const CLocItem &) const;
	NOTHROW int operator!=(const CLocItem &) const;

	NOTHROW BOOL BobsConsistencyChecker(void) const;
	
	virtual ~CLocItem();

protected:
	
	//
	//  Private helper functions.
	//
	NOTHROW BOOL CompareItems(const CLocItem &);
	
private:

	//
	//  Flags that apply to the entire item.  These control the display and
	//  editablity and internal status of an item.
	//
	struct Flags
	{
		BOOL m_fDevLock           :1; // Resource locked (in source file) from parser data
		BOOL m_fUsrLock           :1; // Resource locked (by user) from parser data
		BOOL m_fTransLock         :1; // Resource locked (for the user) from parser data
		BOOL m_fExpandable        :1; // Expandable in project window
		BOOL m_fDisplayable       :1; // Display in project window
		BOOL m_fNoResTable        :1; // Don't display in res table
		BOOL m_fStringDirty       :1; // has the source locstring changed?
		BOOL m_fTargetStringDirty :1; // has the target locstring changed?
		BOOL m_fItemDirty         :1; // has any other part of the item changed?
		BOOL m_fEqualSrcTgtString :1; // are the src&tgt strings equal?
		BOOL m_fEqualSrcTgtBinary :1; // are the src&tgt binaries equal?
		BOOL m_fValidTranslation  :1; // is the target string (the translation) good 
									  // for an autotranslate ?
		BOOL m_fVisEditorIgnore   :1; // is the item ignored in the visual editor?
									  // in memory state only.
		BOOL m_fInstructionsDirty :1;
		BOOL m_fInstrAtt		  :1; // has the instruction changed by Update command?
	};

	//
	//  Prevents the default copy constructor from being called.
	//
	CLocItem(const CLocItem &);
	virtual void Serialize(CArchive &) {}
	const CLocItem &operator=(const CLocItem &);
	
	//
	//  Item data.
	//

	//Language-independent members
	DBID           m_dbid;             //Id of item within the db
	DBID           m_PseudoParent;
	CLocUniqueId   m_uid;
	CLocString     m_lsString;
	CIT::IconType  m_icIconType;       //UI Icon that visually indicates item type
	CPascalString  m_pstrInstructions; //Instructions on how to localize the item
	CPascalString  m_pstrTermNotes;    // glossary notes 
	CLS::LocStatus m_lsTranslationStatus;		// Translation Loc status
	CLS::LocStatus m_lsBinaryStatus;			// Binary Loc status
	CTO::TranslationOrigin m_toTranslationOrigin;	// translation origin
	CAS::ApprovalState	m_asApprovalStatus;
	CAA::AutoApproved m_auto_approved;		// AUTO APPROVED
	long m_confidence_level;				// confidence level
	long m_custom1;							// CUSTOM1
	long m_custom2;							// CUSTOM2
	long m_custom3;							// CUSTOM3
	long m_custom4;							// CUSTOM4
	long m_custom5;							// CUSTOM5
	long m_custom6;							// CUSTOM6
	VisualEditor   m_veEditor;         //Graphical editor used for the item
	Flags          m_Flags;            //Various flags

	//Language-dependent members
	UINT           m_uiDisplayOrder;   //Physical order of item in the file
	CLocBinary    *m_pBinary;        //Parser-specific properties

	DEBUGONLY(static CCounter m_UsageCounter);
};

//
//  Callback class used to provide information about
//  items to the item log.
//
class LTAPIENTRY CItemInfo
{
public:
	CItemInfo() {};
	
	virtual ~CItemInfo() {};

	virtual CLString GetFileName(const CLocItem *) = 0;
	virtual CLString GetItemName(const CLocItem *) = 0;
	
private:
	CItemInfo(const CItemInfo &);
	const CItemInfo & operator=(const CItemInfo &);
};



//Classes used to retrieve mnemonics (aka hotkeys) from parsers
class LTAPIENTRY CMnemonic
{
public:
	NOTHROW operator unsigned long() const;
	WCHAR m_cHotkeyChar;
	WORD m_nHotkeyScope;

};

class LTAPIENTRY CMnemonicsMap : public CMap<CMnemonic, CMnemonic &,
					  CLocItemPtrArray *, CLocItemPtrArray * &>
{
public:
	CMnemonicsMap() 
	{};

	~CMnemonicsMap();

private:
	CMnemonicsMap(const CMnemonicsMap &);
	void operator=(int);
};


#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locitem.inl"
#endif

#endif // LOCITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\location.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCATION.INL

History:

--*/

inline
void
CLocation::AssignFrom(
		const CLocation &other)
{
	m_giId = other.m_giId;
	m_TabId = other.m_TabId;
	m_View = other.m_View;
	m_Component = other.m_Component;
}



inline
BOOL
CLocation::Compare(
		const CLocation &other)
		const
{
	return m_giId == other.m_giId &&
		m_TabId == other.m_TabId &&
		m_View == other.m_View &&
		m_Component == other. m_Component;
}



inline
CLocation::CLocation()
{
	m_TabId = NullTabId;
	m_View = vNone;
	m_Component = cmpNone;
}



inline
CLocation::CLocation(
		const CLocation &Other)
{
	AssignFrom(Other);
}



inline
CLocation::CLocation(
		const CGlobalId &giId,
		View view,
		TabId tabId,
		Component component)
	: m_giId(giId), m_TabId(tabId), m_View(view), m_Component(component)
{}



inline
CLocation::CLocation(
		const DBID &dbid,
		ObjectType ot,
		View view,
		TabId tabId,
		Component component)
	: m_giId(dbid, ot), m_TabId(tabId), m_View(view), m_Component(component)
{}



inline
const CLocation &
CLocation::operator=(
		const CLocation &Other)
{
	AssignFrom(Other);

	return *this;
}



inline
int
CLocation::operator==(
		const CLocation &Other) const
{
	return Compare(Other);
}



inline
int
CLocation::operator!=(
		const CLocation &Other) const
{
	return !Compare(Other);
}



inline
const CGlobalId &
CLocation::GetGlobalId(void)
		const
{
	return m_giId;
}



inline
TabId
CLocation::GetTabId(void)
		const
{
	return m_TabId;
}



inline
View
CLocation::GetView(void)
		const
{
	return m_View;
}



inline
Component
CLocation::GetComponent(void)
		const
{
	return m_Component;
}



inline
BOOL
CLocation::IsVisual(void)
		const
{
	return (m_View == vVisualEditor);
}



inline
void
CLocation::SetGlobalId(
		const CGlobalId &gid)
{
	m_giId = gid;
}



inline
void
CLocation::SetTabId(
		const TabId TabId)
{
	m_TabId = TabId;
}



inline
void
CLocation::SetView(
		View vView)
{
	m_View = vView;
}



inline
void
CLocation::SetComponent(
		Component comp)
{
	m_Component = comp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\lunknown.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    IUNKNOWN.INL

History:

--*/

//*****************************************************************************
//
// CLUnknown Constructions / Destruction
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
inline 
CLUnknown::CLUnknown(
		IUnknown * pParent
		)
{
	LTASSERT(pParent != NULL);

	m_ulRef = 0;
	m_pParent = pParent;
	m_pParent->AddRef();
//	AddRef();  // Don't AddRef() itself.  The caller is expected to do this
}


///////////////////////////////////////////////////////////////////////////////
inline 
CLUnknown::~CLUnknown()
{
	LTASSERT(m_ulRef == 0);

	LTASSERT(m_pParent != NULL);
	m_pParent->Release();	
}


//*****************************************************************************
//
// CLUnknown Operations
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
inline 
ULONG
CLUnknown::AddRef()
{
	return ++m_ulRef;
}


///////////////////////////////////////////////////////////////////////////////
inline 
ULONG
CLUnknown::Release()
{
	LTASSERT(m_ulRef > 0);

	if (--m_ulRef == 0)
	{
		delete this;
		return 0;
	}

	return m_ulRef;
}


///////////////////////////////////////////////////////////////////////////////
inline 
HRESULT
CLUnknown::QueryInterface(REFIID iid, LPVOID * ppvObject)
{
	LTASSERT(ppvObject != NULL);

	return m_pParent->QueryInterface(iid, ppvObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\reporter.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REPORTER.INL

History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\resid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESID.H

History:

--*/

#ifndef RESID_H
#define RESID_H


class LTAPIENTRY CLocResId : public CLocId
{
public:
	NOTHROW CLocResId();

	void AssertValid(void) const;

	const CLocResId &operator=(const CLocResId &);

	int NOTHROW operator==(const CLocResId &) const;
	int NOTHROW operator!=(const CLocResId &) const;

	void Serialize(CArchive &ar);

protected:

private:
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "resid.inl"
#endif

#endif  // RESID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\puid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PUID.INL

History:

--*/

inline
PUID::PUID()
{
	m_pid = pidNone;
	m_pidParent = pidNone;
}



inline
PUID::PUID(
		ParserId pid,
		ParserId pidParent)
{
	m_pid = pid;
	m_pidParent = pidParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma warning(disable : 4663 )
#pragma warning(disable : 4665 )

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#pragma warning(disable : 4664 )
#include <afxtempl.h>

#include <mitutil.h>
#include <locutil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESOURCE.H

History:

--*/
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Espresso.rc
//
#define IDS_NOTE                        12746
#define IDS_WARNING                     12747
#define IDS_ERROR                       12748
#define IDS_ABORT                       12749
#define IDS_SHUTDOWN                    12750
#define IDS_OUTTAB_FILE                 12751
#define IDS_OUTTAB_TEST                 12752
#define IDS_OUTTAB_GBOX                 12753
#define IDS_OUTTAB_LOCK                 12754
#define IDS_OUTTAB_UPDATE               12755
#define IDS_OUTTAB_MESSAGES             12756
#define IDS_SETTINGS_CTX                12766
#define IDS_SETTINGS_INDENT             12767
#define IDS_SETTINGS_SEP                12768
#define IDS_SETTINGS_DEFAULT            12769
#define IDS_SETTINGS_USER               12770
#define IDS_SETTINGS_OVERRIDE           12771
#define IDS_DISP_ICON                   12772
#define IDS_DISP_SOURCE                 12773
#define IDS_DISP_TRANSLATION            12774
#define IDS_DISP_PREVIOUS               12775
#define IDS_DISP_INSTRUCTIONS           12776
#define IDS_DISP_TERM_NOTE              12777
#define IDS_DISP_RESOURCE_ID            12778
#define IDS_DISP_TRANSLATION_STATUS     12779
#define IDS_DISP_BINARY_STATUS          12780
#define IDS_DISP_TRANSLATION_ORIGIN     12781
#define IDS_DISP_STRING_CATEGORY        12782
#define IDS_DISP_APPROVAL               12783
#define IDS_DISP_LOCK                   12784
#define IDS_DISP_SRC_LOCK               12785
#define IDS_DISP_PARSER_ID              12786
#define IDS_DISP_MODIFIED_DATE          12787
#define IDS_DISP_MODIFIED_BY            12788
#define IDS_DISP_CUSTOM1                12789
#define IDS_DISP_CUSTOM2                12790
#define IDS_DISP_CUSTOM3                12791
#define IDS_DISP_CUSTOM4                12792
#define IDS_DISP_CUSTOM5                12793
#define IDS_DISP_CUSTOM6                12794
#define IDS_IconHelp                    12795
#define IDS_SourceTermHelp              12796
#define IDS_TranslationHelp             12797
#define IDS_PreviousSourceHelp          12798
#define IDS_InstructionHelp             12799
#define IDS_TermNoteHelp                12800
#define IDS_ResourceIDHelp              12801
#define IDS_TransStatusHelp             12802
#define IDS_BinStatusHelp               12803
#define IDS_TransOriginHelp             12804
#define IDS_StringCategoryHelp          12805
#define IDS_ApprovalStatusHelp          12806
#define IDS_UserLockHelp                12807
#define IDS_DevLockHelp                 12808
#define IDS_ParserIDHelp                12809
#define IDS_ModifiedDateHelp            12810
#define IDS_ModifiedByHelp              12811
#define IDS_Custom1Help                 12812
#define IDS_Custom2Help                 12813
#define IDS_Custom3Help                 12814
#define IDS_Custom4Help                 12815
#define IDS_Custom5Help                 12816
#define IDS_Custom6Help                 12817
#define IDS_SoftwareDescription         12818
#define IDS_DISP_INSTRUCTIONS_ATT       12819
#define IDS_InstructionAttHelp          12820
#define IDS_DISP_SRC_LEN                12821
#define IDS_SRC_LEN_HELP                12822
#define IDS_DISP_TGT_LEN                12823
#define IDS_TGT_LEN_HELP                12824
#define IDS_TransLockHelp               12825
#define IDS_DISP_TRANS_LOCK             12826
#define IDS_DISP_SRC_HK                 12827
#define IDS_SRC_HK_HELP                 12828
#define IDS_DISP_TGT_HK                 12829
#define IDS_TGT_HK_HELP                 12830
#define IDS_DISP_AUTO_APPROVED          12831
#define IDS_AutoApprovedHelp            12832
#define IDS_DISP_CONFIDENCE_LEVEL       12833
#define IDS_ConfidenceLevelHelp         12834
#define IDS_ConfidenceLevel_Invalid     12835

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12604
#define _APS_NEXT_COMMAND_VALUE         12600
#define _APS_NEXT_CONTROL_VALUE         12608
#define _APS_NEXT_SYMED_VALUE           12602
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\reporter.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REPORTER.H

History:

--*/

//  
//  Mechanism for reporting messages and such to people.
//  
 
#ifndef ESPUTIL_REPORTER_H
#define ESPUTIL_REPORTER_H



//
//  Basic output mechanism for Espresso 2.x.  Allows the caller to uniformly
//  report messages of various severities to the user without worrying about
//  the exact implementation or destination.
//
//  We provide ways of outputting strings, or for loading messages from string
//  tables and outputting those.
//
//  The confidence level allow the caller to tell the Reporter that messages
//  will actually provide meaningful information.  This is used (in particular)
//  in the parsers when a file has not yet ever been parsed.
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CReporter : public CReport
{
public:
	CReporter() {};

	void AssertValid(void) const;


 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL) = 0;
	//
	//  The usage of these versions of IssueMessage is discouraged.  Use the
	//  versions with the CGoto objects instead.
	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, const CLocation &,
			UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity,
			const CPascalString &strContext, const CLString &strMessage,
			const CLocation &, UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			HMODULE hResourceModule, UINT uiStringId, const CLocation &,
			UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity, HMODULE hResourceModule,
			UINT uiContext, const CLString &strMessage ,
			const CLocation &, UINT uiHelpContext = 0);
	
	virtual void IssueMessage(MessageSeverity, HMODULE hResourceModule,
			UINT uiContext, UINT uiStringId, const CLocation &,
			UINT uiHelpContext = 0);


	virtual void IssueMessage(MessageSeverity, const CContext &context,
			const CLString &strMessage, UINT uiHelpId = 0);
	virtual void IssueMessage(MessageSeverity, const CContext &context,
			HMODULE hResourceModule, UINT uiStringId, UINT uiHelpId = 0);
	
	virtual ~CReporter();

private:
	//
	//  Prevent usage of copy constructor or assignment operator.
	//
	CReporter(const CReporter &);
	const CReporter &operator=(const CReporter &);

};

#pragma warning(default: 4275)


#endif // ESPUTIL_REPORTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\softinfo.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SOFTINFO.H

History:

--*/

#if !defined(ESPUTIL_SoftInfo_h_INCLUDED)
#define ESPUTIL_SoftInfo_h_INCLUDED

struct LTAPIENTRY SoftCol
{
	// Unique string names for columns
	static const WCHAR * szIcon;
	static const WCHAR * szSource;
	static const WCHAR * szTarget;
	static const WCHAR * szPreviousSource;
	static const WCHAR * szInstructions;
	static const WCHAR * szInstrAtt;
	static const WCHAR * szNote;
	static const WCHAR * szResourceID;
	static const WCHAR * szTranslationStatus;
	static const WCHAR * szBinaryStatus;
	static const WCHAR * szOrigin;
	static const WCHAR * szCategory;
	static const WCHAR * szApproval;
	static const WCHAR * szLock;
	static const WCHAR * szSourceLock;
	static const WCHAR * szTransLock;
	static const WCHAR * szModifiedDate;
	static const WCHAR * szModifiedBy;
	static const WCHAR * szAutoApproved;
	static const WCHAR * szConfidenceLevel;
	static const WCHAR * szCustom1;
	static const WCHAR * szCustom2;
	static const WCHAR * szCustom3;
	static const WCHAR * szCustom4;
	static const WCHAR * szCustom5;
	static const WCHAR * szCustom6;
	static const WCHAR * szParserID;
	static const WCHAR * szSrcLen;
	static const WCHAR * szTgtLen;
	static const WCHAR * szSrcHotKey;
	static const WCHAR * szTgtHotKey;
	
	// Unique ID's for columns
	//
	// DO NOT 'INSERT' ITEMS.  You will change the ID's and break things.
	
	typedef enum
	{
		FLD_ICON,
		FLD_SOURCE_TERM,
		FLD_TARGET_TERM,
		FLD_PREVIOUS_SOURCE_TERM,
		FLD_INSTRUCTIONS,
		FLD_INSTR_ATT,
		FLD_GLOSSARY_NOTE,
		FLD_UNIQUE_ID,
		FLD_TRANSLATION_STATUS,
		FLD_BINARY_STATUS,
		FLD_TRANSLATION_ORIGIN,
		FLD_STRING_TYPE,
		FLD_APPROVAL_STATE,
		FLD_USR_LOCK,
		FLD_DEV_LOCK,
		FLD_TRANS_LOCK,
		FLD_MODIFIED_DATE,
		FLD_MODIFIED_BY,
		FLD_AUTO_APPROVED,
		FLD_CONFIDENCE_LEVEL,
		FLD_CUSTOM1,
		FLD_CUSTOM2,
		FLD_CUSTOM3,
		FLD_CUSTOM4,
		FLD_CUSTOM5,
		FLD_CUSTOM6,
		//
		//  Add displayable columns here.
		
		FLD_PARSER_ID = 50,
		//
		//  Add non-displayable, RESTBL required columns here

		FLD_SRC_LEN = 100,
		FLD_TGT_LEN,
		FLD_SRC_HK,
		FLD_TGT_HK,
		//
		//  Add non-displayable, non-RESTBL columns here. 
		
		FLD_COUNT = 30					// Make sure this is accurate!
	} FIELD;

	// RAID:  LS42 Bug 46 fixed by MikeL
	// Functions to validate the value of the above
	// column types.  All validate functions must pass
	// two parameters:  1-LPCTSTR. and 2-DWORD
	static BOOL ValidateDefault (LPCTSTR lpszNewText, DWORD dwNewNum);
	static BOOL ValidateConfidenceLevel (LPCTSTR lpszNewText, DWORD dwNewNum);

	// Exported functions
	static void GetSoftwareSchema(CTableSchema * & pSchema);
	static const CLString & GetDisplayName(FIELD col);

	static const CColumnDefinition * GetColumnDefinition(FIELD col);

	static int GetColumnCount();

	static int GetCustomColumnCount();
	static BOOL IsCustomColumn(FIELD col);

// Implementation
protected:
	static void BuildStringCategory(CTableSchema * pSchema);
	static void BuildApprovalState(CTableSchema * pSchema);
};

#endif // ESPUTIL_SoftInfo_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\resid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESID.INL

History:

--*/

//  
//  Inline funxtions for the Resource ID.  This file should ONLY be included
//  by resid.h.
//  
 
//-----------------------------------------------------------------------------
//  
//  File: resid.inl
//
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All methods directed to base class
//  
//-----------------------------------------------------------------------------

inline
CLocResId::CLocResId()
{}



inline
const CLocResId &
CLocResId::operator=(
		const CLocResId & locId)
{
	CLocId::operator=(locId);
	return *this;
}


inline
int
CLocResId::operator==(
		const CLocResId & locId)
		const
{
	return CLocId::operator==(locId);
}


inline
int
CLocResId::operator!=(
		const CLocResId & locId)
		const
{
	return CLocId::operator!=(locId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\typeid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    TYPEID.H

History:

--*/

#ifndef TYPEID_H
#define TYPEID_H


class LTAPIENTRY CLocTypeId : public CLocId
{
public:
	NOTHROW CLocTypeId();

	void AssertValid(void) const;

	const CLocTypeId &operator=(const CLocTypeId &);

	int NOTHROW operator==(const CLocTypeId &) const;
	int NOTHROW operator!=(const CLocTypeId &) const;

	void Serialize(CArchive &ar);

protected:

private:
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "typeid.inl"
#endif

#endif // TYPEID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\uniqid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UNIQID.H

History:

--*/

#ifndef UNIQID_H
#define UNIQID_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUniqueId : public CObject
{
public:
	NOTHROW CLocUniqueId();

	void AssertValid(void) const;

	NOTHROW const DBID & GetParentId(void) const;
	NOTHROW const CLocTypeId & GetTypeId(void) const;
	NOTHROW const CLocResId & GetResId(void) const;

	NOTHROW DBID & GetParentId(void);
	NOTHROW CLocTypeId & GetTypeId(void);
	NOTHROW CLocResId & GetResId(void);
	
	void GetDisplayableUniqueId(CPascalString &) const;	
	
	NOTHROW int operator==(const CLocUniqueId &) const;
	NOTHROW int operator!=(const CLocUniqueId &) const;
	
	const CLocUniqueId &operator=(const CLocUniqueId&);

	void SetParentId(const DBID&);

	NOTHROW void ClearId(void);
	NOTHROW BOOL IsNull();
	
	virtual ~CLocUniqueId();

protected:
	//
	//  Implementation functions.
	//
	NOTHROW BOOL IsEqualTo(const CLocUniqueId &) const;

private:
	
	//
	//  Prevents the default copy constructor from being called.
	//
	CLocUniqueId(const CLocUniqueId &);
	void Serialize(CArchive &ar);

	DBID       m_dbid;
	CLocTypeId m_tid;
	CLocResId  m_rid;
	
	DEBUGONLY(static CCounter m_DisplayCounter);
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uniqid.inl"
#endif

#endif // UNIQID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\uniqid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UNIQID.INL

History:

--*/

//  
//  Inline function definitions for the Espresso Unique ID.  This file should
//  ONLY be included by uniqid.h.
//  
 

inline
const DBID&
CLocUniqueId::GetParentId(void)
		const
{
	return m_dbid;
}



inline
const CLocTypeId &
CLocUniqueId::GetTypeId(void)
		const
{
	return m_tid;
}



inline
const CLocResId &
CLocUniqueId::GetResId(void)
		const
{
	return m_rid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the parent ID for the item.  This portion of the ID is set by the
//  parser.
//  
//-----------------------------------------------------------------------------
inline
DBID&
CLocUniqueId::GetParentId(void)
{
	return m_dbid;
}

inline
CLocTypeId &
CLocUniqueId::GetTypeId(void)
{
	return m_tid;
}

inline
CLocResId &
CLocUniqueId::GetResId(void)
{
	return m_rid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comapre two ID's.  
//  
//-----------------------------------------------------------------------------
inline
int								        //  Zero if different
CLocUniqueId::operator==(
		const CLocUniqueId &uidOther)	// ID to compare to.
		const
{
	return IsEqualTo(uidOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Compare two ID's
//  
//-----------------------------------------------------------------------------
inline
int										// Zero if identical
CLocUniqueId::operator!=(
		const CLocUniqueId &uidOther)	// ID to compare to.
		const
{
	return !IsEqualTo(uidOther);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the Parent ID component of the ID.
//  
//-----------------------------------------------------------------------------
inline
void
CLocUniqueId::SetParentId(
		const DBID& dbidNewId)			// New Parent ID
{
	m_dbid = dbidNewId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\typeid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    TYPEID.INL

History:

--*/

//  
//  Inline functions for the Type ID.  This file should ONLY be included
//  by typeid.h.
//
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All methods directed to base class
//  
//-----------------------------------------------------------------------------

inline
CLocTypeId::CLocTypeId()
{}



inline
const CLocTypeId &
CLocTypeId::operator=(
		const CLocTypeId & locId)
{
	CLocId::operator=(locId);

	return *this;
}

inline
int
CLocTypeId::operator==(
		const CLocTypeId & locId)
		const
{
	return CLocId::operator==(locId);
}



inline
int
CLocTypeId::operator!=(
		const CLocTypeId & locId)
		const
{
	return CLocId::operator!=(locId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_espenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ESPENUM.H

History:

--*/

#ifndef ESPUTIL__ESPENUM_H
#define ESPUTIL__ESPENUM_H


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_errorrep.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ERRORREP.H

History:

--*/

//  
//  Error reporting mechanism for Espresso 2.0
//  
 
#ifndef ESPUTIL__ERRORREP_H
#define ESPUTIL__ERRORREP_H


////////////////////// the new global issuemessage functions.
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		const CLString &strMessage, const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		HINSTANCE hResourceDll, UINT uiStringId, const CLocation &,
		UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		const CLocation &, CException *);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContext, const CLString &strMessage, 
		const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContextId, UINT uiStringId, 
		const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContext, const CLocation &, CException *);

void LTAPIENTRY IssueMessage(MessageSeverity, const CContext &,
		const CLString &, UINT uiHelpId = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CContext &,
		HINSTANCE, UINT, UINT uiHelpId = 0);

void LTAPIENTRY SetErrorReporter(CReporter *, BOOL fBatchMode);
void LTAPIENTRY GetErrorReporter(CReporter *&, BOOL &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_errorrep.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_errorrep.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ERRORREP.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		const CLString &strContext,
		HINSTANCE hResourceDll,
		UINT uiStringId,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strMessage;

	strMessage.LoadString(hResourceDll, uiStringId);
	IssueMessage(sev, strContext, strMessage, loc, uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		const CLString &strMessage,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);

	IssueMessage(sev, strContext, strMessage, loc, uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		UINT uiStringId,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);
	IssueMessage(sev, strContext, hResourceDll, uiStringId, loc,uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		const CLocation &loc, 
		CException *pe)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);
	IssueMessage(sev, strContext, loc, pe);
}




inline
void
IssueMessage(
		MessageSeverity sev,
		const CContext &context,
		const CLString &strMessage,
		UINT uiHelpId)
{
	IssueMessage(sev, context.GetContext(), strMessage, context.GetLocation(),
			uiHelpId);
	
}



inline
void
IssueMessage(
		MessageSeverity sev,
		const CContext &context,
		HINSTANCE hResDll,
		UINT uiStringId,
		UINT uiHelpId)
{
	IssueMessage(sev, context.GetContext(), hResDll, uiStringId,
			context.GetLocation(), uiHelpId);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_espopts.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ESPOPTS.H

History:

--*/


LTAPIENTRY CLocOptionValStore *  GetParserOptionStore(CLocUIOption::StorageType);
LTAPIENTRY void SetParserOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
LTAPIENTRY void UpdateParserOptionValues(void);
LTAPIENTRY CLocUIOptionSet * GetParserOptionSet(const PUID &);

LTAPIENTRY void SummarizeParserOptions(CReport *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_globalid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _GLOBALID.H

History:

--*/

#ifndef ESPUTIL__GLOBALID_H
#define ESPUTIL__GLOBALID_H

///////////////////////////////////////////////////////////////////////////////
//
// global id path object, represents a fully qualified path from the root of
// the project to a specified item
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable : 4275)
class LTAPIENTRY CGlobalIdPath : public CTypedPtrList < CPtrList, CGlobalId * >
{
public:
	int NOTHROW operator==(const CGlobalIdPath &) const;
	const CGlobalIdPath & operator = (const CGlobalIdPath& idPath);
	~CGlobalIdPath();

	void SetIdPath(const CLString &strFilePath, 
					const CLString &strResourcePath);

	void GetStrPath(CLString &strFilePath, CLString &strResourcePath) const;

	void NOTHROW DeleteContents();
};
#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_goto.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _GOTO.H

History:

--*/

#if !defined(ESPUTIL__goto_h_INCLUDED)
#define ESPUTIL__goto_h_INCLUDED
 
class LTAPIENTRY CEspGotoFactory : public CRefCount
{
public:
	CEspGotoFactory() {};
	
	virtual CGoto * CreateGoto(const CLocation &) = 0;

private:
	CEspGotoFactory(const CEspGotoFactory &);
};



void LTAPIENTRY RegisterEspGotoFactory(CEspGotoFactory *);

#endif // ESPUTIL__goto_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_importo.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _IMPORTTO.H

History:

--*/

#ifndef ESPUTIL__IMPORTO_H
#define ESPUTIL__IMPORTO_H


#pragma warning(disable : 4251)			// class 'bar' needs to have dll-
										//interface to be used by clients of
										//class 'Foo'
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocImportOptions : public CObject
{
public:

	CLocImportOptions();
	CLocImportOptions(const CLocImportOptions&);

	enum Option
	{
		coor_size = 0,
		allNonText,
		instructions,
		lockFlag,
		translockFlag,
		stringCategory,
		approvalStatus,
		custom1,
		custom2,
		custom3,
		custom4,
		custom5,
		custom6,
		termNote,
		parserOptions,
		copy,
		MAX_OPTION		//always last in the list
	};

	NOTHROW void Reset();
	NOTHROW BOOL HasOptionSet() const;
	NOTHROW BOOL GetOption(Option opt) const;
	NOTHROW void SetOption(Option opt, BOOL bEnable);

	const CStringArray &GetGroupNames(void) const;
	void AddGroupName(const CString &);
	
	NOTHROW CLocImportOptions& operator=(const CLocImportOptions&);

	virtual void AssertValid(void) const;

protected:
	BYTE m_storage[MAX_OPTION];
	CStringArray m_aOptionGroupNames;
};

struct LTAPIENTRY ImportCount
{
	ImportCount();
	
	ULONG ulResources;
	ULONG ulParserOptions;
	ULONG ulEspressoOptions;
	ULONG ulCustomFields;
};

#pragma warning(default : 4251)
#pragma warning(default: 4275)

#endif //ESPUTIL_IMPORTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_reporter.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _REPORTER.H

History:

--*/

#ifndef ESPUTIL__REPORTER_H
#define ESPUTIL__REPORTER_H


//
//  Throws away ALL messages.
//
class LTAPIENTRY CNullReporter : public CReporter
{
public:
	CNullReporter()	{};

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);
};

		


#pragma warning (disable:4251)

class LTAPIENTRY CBufferReporter : public CReporter
{
public:
	CBufferReporter();

	void AssertValid(void) const;
	

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Clear(void);

	NOTHROW const MessageList & GetNotes(void) const;
	NOTHROW const MessageList & GetWarnings(void) const;
	NOTHROW const MessageList & GetErrors(void) const;
	NOTHROW const MessageList & GetAborts(void) const;

	NOTHROW const MessageList & GetMessages(void) const;
	void DumpTo(CReport *) const;
	
	~CBufferReporter();

	const CBufferReport & GetBufReport(void) const;

private:
	CBufferReport m_bufReport;
};


//
//  This reporter just send all its messages directly to a message box.
//
class LTAPIENTRY CMessageBoxReporter : public CReporter
{
public:
	CMessageBoxReporter();

	void AssertValid(void) const;

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

private:
	CMessageBoxReport m_mbReport;
};



//
//  This reporter is used to send all messages to a file.
//
class LTAPIENTRY CFileReporter : public CReporter
{
public:
	CFileReporter();

	BOOL InitFileReporter(const CLString &strFileName);

	virtual void Clear(void);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CFileReporter();

private:
	CFileReport m_fReport;
};

//
//  This reporter is used for command line utilities.  Output goes to stdout
//
class LTAPIENTRY CStdOutReporter : public CReporter
{
public:

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);
private:
	CStdOutReport m_stReport;
};


//
//  This is used to 'redirect' messages to a single reporter.  It's used
//  when several different reporters are required by the current
//  implementation, but the desired effect is that they all send their messages
//  to a common location.
//
//  This class takes ownership of another Reporter, then uses reference
//  counting semantics to determine when to delete that reporter.
//
class LTAPIENTRY CRedirectReporter : public CReporter
{
public:
	CRedirectReporter();

	virtual void Activate(void);
	virtual void Clear(void);
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	//  Used for initial attachment to a CReporter.
	NOTHROW void RedirectTo(CReport *pReport);

	//  Used to share a single reporter among several CRedirectReporter's.
	NOTHROW void RedirectTo(CRedirectReporter *pReporter);
	
private:
	CRedirectReport m_rdReport;
};


//
//  
//  This class is used to re-direct output through a reporter.  It will
//  automatically call Clear() and Activate() the first time output is sent
//  to the reporter.  If the usre calls Activate first on this reporter, then
//  no action is taken when something is output.
//  
//
class LTAPIENTRY CActivateReporter : public CReporter
{
public:
	CActivateReporter(CReport *);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Activate();
	void Clear();

private:
	CActivateReport m_actReport;
};



//
//  Allows you to use a CReport as a CReporter.
class LTAPIENTRY CReportReporter : public CReporter
{
public:
	CReportReporter(CReport *);

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto,
			CGotoHelp *pGotoHelp);
	virtual void Activate();
	virtual void Clear();
	virtual void SetConfidenceLevel(ConfidenceLevel);
	
	
private:
	CReport *m_pReport;
};


#pragma warning(default:4251)

//
//  The following manage a global 'pool' of reporters that are used by
//  different components in the system.
//  Each reporter has to be distinct.  Once the reporter has been 'added',
//  the global pool *owns* the reporter and will delete it.  This is done by
//  ReleaseAllReporters().
//
NOTHROW LTAPIENTRY void AddReporter(COutputTabs::OutputTabs idx, CReporter *pReporter);
NOTHROW LTAPIENTRY CReporter * GetReporter(COutputTabs::OutputTabs);
NOTHROW LTAPIENTRY void ReleaseAllReporters();

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_reporter.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_interface.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _INTERFACE.H

History:

--*/

#pragma once


struct LOCRESOURCEFILEINFO
{
	CFile *pFile;						// Res32 file
	LangId idLang;						// Language of the file
};

typedef LOCRESOURCEFILEINFO *LPLOCRESOURCEFILEINFO;

struct SProjectInfo
{
	CLString m_strProjPath;
	LangId m_lSource;
	LangId m_lTarget;
};


	
DECLARE_INTERFACE_(ILocExtensionResource, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum ResourceEvent
	{
		reNewFile,
		reUserCancel,
		reMakeSrcResFailed		// RAID: LS42 bug 250 fixed by MikeL (Added)
	};
	
	STDMETHOD_(void, GetOperationInfo)(CLString &strContext,
			COutputTabs::OutputTabs &) CONST_METHOD PURE;
	
	STDMETHOD(Start)(THIS_ CReport *, const SProjectInfo &) PURE;

	STDMETHOD(Stop)(THIS_ CReport *) PURE;

	STDMETHOD(OnEvent)(THIS_ ResourceEvent event, const CLocVariant &var,
			CReport *pReporter) PURE;
	STDMETHOD(Analyze)(THIS_
			const LOCRESOURCEFILEINFO &SourceFileInfo,
			const LOCRESOURCEFILEINFO &pTargetFileInfo,
			const CDBIDArray &aDBID,
			CReport *pReporter,
			const CLString &strContext,
			BOOL &fModifiedTarget) PURE;

	STDMETHOD_(void, SetProjName)(const CLString & strProjName) PURE;
	STDMETHOD_(BOOL, InitReports)() PURE;
};

	
interface __declspec(uuid("{9F9D180F-6F38-11d0-98FD-00C04FC2C6D8}"))
		ILocExtensionResource;


interface ILocTransFields;


DECLARE_INTERFACE_(ILocExtensionTranslation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum TranslationEvent
	{
		teNewFile,
		teUserCancel,
	};
	
	enum StartLocation
	{
		slProjectTree,
		slTranslationWindow
	};

	STDMETHOD_(BOOL, IsReadOnly)() CONST_METHOD PURE;
	STDMETHOD_(void, GetOperationInfo)(CLString &strContext,
			COutputTabs::OutputTabs &) CONST_METHOD PURE;
	
	STDMETHOD(Start)(THIS_ StartLocation slStart,
			CReport *, const SProjectInfo &) PURE;
	
	STDMETHOD(Stop)(THIS_ CReport *) PURE;
	
	STDMETHOD(OnEvent)(THIS_ TranslationEvent event,
			const CLocVariant &var, CReport *pReport) PURE;

	STDMETHOD(ProcessRow)(THIS_ ILocTransFields *pITransFields,
			CReport *, const CLString &strContext) PURE;
};

interface __declspec(uuid("{C35F8B61-FE4D-11d0-A5A1-00C04FC2C6D8}"))
		ILocExtensionTranslation;



DECLARE_INTERFACE_(ILocTransFields, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum PreferredGoto
	{
		pgDefault,
		pgProjWindow,
		pgTransTable,
		pgVisEditor
	};
	
	//
	//  Properties
	STDMETHOD_(CGoto *, GetGoto)(PreferredGoto pg = pgDefault) CONST_METHOD PURE;
	STDMETHOD_(void, GetFullItemName)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetFullFileName)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(BOOL, HasString)() CONST_METHOD PURE;
	STDMETHOD_(BOOL, HasBinary)() CONST_METHOD PURE;
	STDMETHOD_(BOOL, IsStringLocked)() CONST_METHOD PURE;
	STDMETHOD(GetCustomFieldValues)(UINT, CPasStringArray &)
		CONST_METHOD PURE;
	
	//
	//  Data retrieval methods
	STDMETHOD_(void, GetUniqueID)(CLocUniqueId &) CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceString)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTargetString)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetPreviousSource)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetInstructions)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTermNote)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTextStatus)(CLS::LocStatus &) CONST_METHOD PURE;
	STDMETHOD_(void, GetBinaryStatus)(CLS::LocStatus &) CONST_METHOD PURE;
	STDMETHOD_(void, GetStringType)(CST::StringType &) CONST_METHOD PURE;
	STDMETHOD_(void, GetApprovalState)(CAS::ApprovalState &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTranslationOrigin)(CTO::TranslationOrigin &)
		CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceLock)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTgtLockedToSource)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetUserLock)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetAutoApproved)(CAA::AutoApproved & aa) CONST_METHOD PURE;
	STDMETHOD_(void, GetParserId)(ParserId &) CONST_METHOD PURE;
	STDMETHOD_(void, GetLastUpdatedBy)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetLastUpdateTime)(COleDateTime &) CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceBinary)(CLocBinary *&) PURE;
	STDMETHOD_(void, GetTargetBinary)(CLocBinary *&) PURE;
	STDMETHOD_(void, GetInstrAttn)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetConfidenceLevel)(LONG &) CONST_METHOD PURE;
	STDMETHOD(GetCustomFieldValue)(UINT, CPascalString &) CONST_METHOD PURE;

	//
	//  Danger!  Use these, and you can totally destroy user data
	//  MAKE SURE YOU KNOW WHAT YOU ARE DOING!
	STDMETHOD(BeginEdit)() PURE;
	STDMETHOD(EndEdit)(BOOL fCommit) PURE;

	//
	//  NOTE!  Set methods implement 'business logic' - changing an item may
	//  lead to several other changes - for example, changing the target
	//  string may change the localization status.
	STDMETHOD(SetCustomFieldValue)(const UINT, const CPascalString &) PURE;	
 	STDMETHOD(SetInstructions)(const CPascalString &) PURE;
 	STDMETHOD(SetTermNote)(const CPascalString &) PURE;
 	STDMETHOD(SetStringType)(const CST::StringType) PURE;

 	STDMETHOD(SetTranslationOrigin)(const CTO::TranslationOrigin) PURE;

 	STDMETHOD(SetTextStatus)(const CLS::LocStatus) PURE;
 	STDMETHOD(SetApprovalState)(const CAS::ApprovalState) PURE;
 	STDMETHOD(SetTargetString)(const CLocString &) PURE;
 	STDMETHOD(SetTgtLockedToSource)(BOOL) PURE;
 	STDMETHOD(SetUserLock)(BOOL) PURE;
 	STDMETHOD(SetAutoApproved)(const CAA::AutoApproved aa) PURE;
	STDMETHOD(SetInstrAttn)(BOOL) PURE;
	
 	STDMETHOD(RevertString)() PURE;

	STDMETHOD(SetTargetBinary)(const CLocBinary *) PURE;
 	STDMETHOD(SetBinaryStatus)(const CLS::LocStatus) PURE;

};


interface __declspec(uuid("{42C5D1E7-FE50-11d0-A5A1-00C04FC2C6D8}"))
		ILocTransFields;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_wtrmark.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _WTRMARK.INL

History:

--*/

inline
CLocWMCommon::CLocWMCommon(
	const CLString& strSource, 
	const ParserId& pid, 
	const CLString& strParserVer)
{
	m_strSource = strSource;
	m_pid = pid;
	m_strParserVer = strParserVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_wtrmark.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _WTRMARK.H

History:

--*/

#pragma once


const int EWM_MAX_LENGTH = 512;		  // Watermarks should never be longer
                                      // than this	

static TCHAR g_cWMSep = _T('\t');

// All watermarks begin with this string
static TCHAR g_szWMLocString[] = _T("Localized");


//
// This class does not need to be exported as all implementations
// are inline
//
class CLocWMCommon
{
 public:
	CLocWMCommon(const CLString& strSource, const ParserId& pid, 
			const CLString& strParserVer);

	CLString m_strSource;		// Name of the source file
	ParserId m_pid;				// Parser using the watermark
	CLString m_strParserVer;  	// Version of the parser 
};

//
// struct defining the header of watermarks when encoded in binary file types
//
#include <pshpack1.h>

struct EWM_HEADER
{
	BYTE bVersion;	   	// Version of the binary data                            
	WORD wLength;		// Length of the string		
};

#include <poppack.h>

const BYTE EWM_ESP21_VERSION = 0;
const BYTE EWM_ESP30_VERSION = 1;
const BYTE EWM_DEFAULT_VERSION = 1;

//
// This function will retrieve the current date from the system and build the 
// common Espresso WaterMark. A Tab character separates elements of the 
// watermark.
//
void LTAPIENTRY ComposeWaterMark(const CLocWMCommon& wm, 
	CLString& strWaterMark);


//
// This function will encode the watermark into non-readable characters and 
// place the encoded string with the WM_HEADER in baOut.  
//
void LTAPIENTRY EncodeWaterMark(const CLString& strNormal, CByteArray& baOut);

void LTAPIENTRY EnCryptWaterMark(DWORD* pData, int nLength);


#include "_wtrmark.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_reporter.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _REPORTER.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Note' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetNotes(void)
		const
{
	return m_bufReport.GetNotes();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Warning' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetWarnings(void)
		const
{
	return m_bufReport.GetWarnings();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Error' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetErrors(void)
		const
{
	return m_bufReport.GetErrors();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Abort' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetAborts(void)
		const
{
	return m_bufReport.GetAborts();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns ALL the messages issued to the CBufferReporter.  The messages
//  are stored in chronological order.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetMessages(void)
		const
{
	return m_bufReport.GetMessages();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	Returns the CBufferReport object.
//  
//-----------------------------------------------------------------------------
inline
const CBufferReport &
CBufferReporter::GetBufReport(void)
	const
{
	return m_bufReport;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\_var.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _VAR.H

History:

--*/

#ifndef ESPUTIL__VAR_H
#define ESPUTIL__VAR_H


//
// variant object, represents a VARIANT
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY  CVar : public CObject
{
public:
	CVar();
	CVar(const CVar&);
	CVar(VARIANT);
	CVar(const CPascalString&);
	CVar(PWSTR);
	CVar(PCWSTR);
	CVar(PSTR);
	CVar(PCSTR);
	CVar(SHORT);
	CVar(WCHAR);
	CVar(UINT);
	CVar(BOOL);
	CVar(BYTE);
	CVar(LONG);
	CVar(DATE);
	CVar(DWORD);
	CVar(tm*);			// build from a date in tm format
	~CVar();

	NOTHROW const CVar& operator = (const CVar &);
	NOTHROW const CVar& operator = (VARIANT);
	NOTHROW const CVar& operator = (const CPascalString&);
	NOTHROW const CVar& operator = (PWSTR);
	NOTHROW const CVar& operator = (PCWSTR);
	NOTHROW const CVar& operator = (PSTR);
	NOTHROW const CVar& operator = (PCSTR);
	NOTHROW const CVar& operator = (SHORT);
	NOTHROW const CVar& operator = (WCHAR);
	NOTHROW const CVar& operator = (UINT);
	NOTHROW const CVar& operator = (BOOL);
	NOTHROW const CVar& operator = (BYTE);
	NOTHROW const CVar& operator = (LONG);
	NOTHROW const CVar& operator = (DATE);
	NOTHROW const CVar& operator = (DWORD);

	NOTHROW operator COleVariant   (VOID) const;
	NOTHROW operator LPVARIANT     (VOID);
	NOTHROW operator CPascalString (VOID) const;
	NOTHROW operator SHORT         (VOID) const;
	NOTHROW operator WCHAR         (VOID) const;
	NOTHROW operator UINT          (VOID) const;
	NOTHROW operator BOOL          (VOID) const;
	NOTHROW operator BYTE          (VOID) const;
	NOTHROW operator LONG          (VOID) const;
	NOTHROW operator DATE          (VOID) const;
	NOTHROW operator DWORD         (VOID) const;
	NOTHROW operator PSTR          (VOID) const;
	NOTHROW operator PCSTR         (VOID) const;
	NOTHROW operator PWSTR         (VOID) const;
	NOTHROW operator PCWSTR        (VOID) const;

	void AnsiToWide();
	void WideToAnsi();

	void SetBSTR(BSTR);
	
	void SetStringByteLen(const char * sz, unsigned int ui);

	NOTHROW int GetLength();

	NOTHROW BOOL IsNull() const;
	NOTHROW VOID SetNull();
	NOTHROW VOID SetError();

	NOTHROW BOOL operator==(const CVar& v) const;
	NOTHROW BOOL operator!=(const CVar& v) const;

	//
	// debug routines
	//
	virtual void AssertValid() const;

private:
	VARIANT m_var;
};

#pragma warning(default: 4275)


#endif //ESPUTIL_VAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\cancel.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CANCEL.H

History:

--*/


#ifndef ESPUTIL_CANCEL_H
#define ESPUTIL_CANCEL_H



class CCancelDialog;

class LTAPIENTRY CCancelableObject : public CProgressiveObject
{
public:
	CCancelableObject(void);

	virtual void AssertValid(void) const;
	
	virtual BOOL fCancel(void) const = 0;

	virtual ~CCancelableObject();
};



#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "cancel.inl"
#endif

#endif // ESPUTIL_CANCEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\dbhelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DBHELP.H

History:

--*/


#if !defined(ESPUTIL_DbHelp_h_INCLUDED)
#define ESPUTIL_DbHelp_h_INCLUDED

//------------------------------------------------------------------------------
class LTAPIENTRY DbHelp
{
// Operations
public:
	static void GetSecFilePath(CLString & stPathName);
	static BOOL BuildSecFile(CLString & stSystemRegKey);
	static BOOL CreateSecurityFile();
	static BOOL SetupRegistry();

// Data
protected:
	static BOOL		m_fInit;
	static CLString m_stRegKey;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\cancel.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CANCEL.INL

History:

--*/

inline
CCancelableObject::CCancelableObject(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\dcsgrid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DCSGRID.H

History:

--*/

#if !defined(__DcsGrid_h__)
#define __DcsGrid_h__

namespace MitDisplayColumns
{
	interface IOption;
	interface IColumn;
};

//------------------------------------------------------------------------------
class LTAPIENTRY CDcsGrid
{
public:
	static int DisplayOrder(MitDisplayColumns::IOption * pdcOption, 
			long nColumnID, long nOffsetDO);
	static int DisplayOrder(MitDisplayColumns::IColumn * pdcColumn, 
			long nOffsetDO);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\espopts.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPOPTS.H

History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\enumplatform.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ENUMPLATFORM.H

History:

--*/
// Note: This file can be included by both MIDL and C++.  Make sure to #include
// "PreMidlEnum.h" or "PreCEnum.h" before #including this file.

//
//  This order is important: all new values must be added TO THE END, or you 
//  will break old parsers...
//

BEGIN_ENUM(Platform)
	ENUM_ENTRY_(gdo, None, 0)
	ENUM_ENTRY(gdo, Windows)
	ENUM_ENTRY(gdo, WinNT)
	ENUM_ENTRY(gdo, Macintosh)
	ENUM_ENTRY(gdo, DOS)
	ENUM_ENTRY(gdo, Other)
	ENUM_ENTRY(gdo, All)
END_ENUM(Platform)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\espreg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPREG.H

History:

--*/

struct LocVersionInfo
{
	WORD    wVerMajor;
	WORD    wVerMinor;
	WORD    wVerBuild;
	CString strVerString;
};


LTAPIENTRY void NOTHROW GetVersionInfo(LocVersionInfo &);

LTAPIENTRY BOOL NOTHROW OpenEspressoUserKey(HKEY &);

LTAPIENTRY BOOL NOTHROW OpenEspressoUserSubKey(HKEY &, const CLString &);

LTAPIENTRY BOOL NOTHROW EspressoUserSubKeyExists(const CLString &);

LTAPIENTRY BOOL NOTHROW OpenEspressoMachineKey(HKEY &);

LTAPIENTRY BOOL NOTHROW OpenEspressoMachineSubKey(HKEY &, const CLString &);

LTAPIENTRY BOOL NOTHROW EspressoMachineSubKeyExists(const CLString &);

LTAPIENTRY BOOL NOTHROW MyRegDeleteKey(HKEY &, const TCHAR *);

LTAPIENTRY void NOTHROW GetRegistryString(CLString &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\enumstringtype.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ENUMSTRINGTYPE.H

History:

--*/
// Note: This file can be included by both MIDL and C++.  Make sure to #include
// "PreMidlEnum.h" or "PreCEnum.h" before #including this file.

//
//  This order is important - if must change it, make sure you make the
//  corresponding changes in GetTypeName() and GetTypeTLA()!
//  All new values must be added TO THE END, or you will break old
//  parsers...
//

BEGIN_ENUM(StringType)
	ENUM_ENTRY_(gdo, None, 0)
	ENUM_ENTRY(gdo, Text)
	ENUM_ENTRY(gdo, Message)
	ENUM_ENTRY(gdo, ErrorMessage)
	ENUM_ENTRY(gdo, Comment)
	ENUM_ENTRY(gdo, StatusBarText)
	ENUM_ENTRY(gdo, ToolTipText)
	ENUM_ENTRY(gdo, KeyName)
	ENUM_ENTRY(gdo, ArgumentName)
	ENUM_ENTRY(gdo, FunctionName)
	ENUM_ENTRY(gdo, FolderName)
	ENUM_ENTRY(gdo, FontName)
	ENUM_ENTRY(gdo, StaticText)
	ENUM_ENTRY(gdo, DialogTitle)
	ENUM_ENTRY(gdo, TabControl)
	ENUM_ENTRY(gdo, GroupBoxTitle)
	ENUM_ENTRY(gdo, EditBox)
	ENUM_ENTRY(gdo, Button)
	ENUM_ENTRY(gdo, OptionButton)
	ENUM_ENTRY(gdo, CheckBox)
	ENUM_ENTRY(gdo, CustomControl)
	ENUM_ENTRY(gdo, TrackBar)
	ENUM_ENTRY(gdo, ProgressBar)
	ENUM_ENTRY(gdo, DriveLetter)
	ENUM_ENTRY(gdo, Folder)
	ENUM_ENTRY(gdo, MenuItem)
	ENUM_ENTRY(gdo, Accelerator)
	ENUM_ENTRY(gdo, Version)
	ENUM_ENTRY(gdo, Translation)
	ENUM_ENTRY(gdo, ListBox)
	ENUM_ENTRY(gdo, ScrollBar)
	ENUM_ENTRY(gdo, ComboBox)
	ENUM_ENTRY(gdo, RadioButton)
	ENUM_ENTRY(gdo, GroupBox)
	ENUM_ENTRY(gdo, General)
	ENUM_ENTRY(gdo, Unknown)
	ENUM_ENTRY(gdo, Keyword)
	ENUM_ENTRY(gdo, TopicTitle)
	ENUM_ENTRY(gdo, PageTitle)
	ENUM_ENTRY(gdo, Command)
	ENUM_ENTRY(gdo, Address)
	ENUM_ENTRY(gdo, AlternativeText)
	ENUM_ENTRY(gdo, HTMLText)
	ENUM_ENTRY(gdo, HTMLTitle)
	ENUM_ENTRY(gdo, JavaText)
	ENUM_ENTRY(gdo, Number)
	ENUM_ENTRY(gdo, PageInformation)
	ENUM_ENTRY(gdo, Style)
	ENUM_ENTRY(gdo, VBScriptText)
	ENUM_ENTRY(gdo, Property)
	ENUM_ENTRY(gdo, MacroAction)
	ENUM_ENTRY(gdo, FileName)
	ENUM_ENTRY(gdo, Billboards)
	ENUM_ENTRY(gdo, DialogItem)
	ENUM_ENTRY(gdo, Description)
	ENUM_ENTRY(gdo, FeatureTitle)
	ENUM_ENTRY(gdo, FeatureDescription)
	ENUM_ENTRY(gdo, INIFileName)
	ENUM_ENTRY(gdo, INIFileKey)
	ENUM_ENTRY(gdo, INIFileSection)
	ENUM_ENTRY(gdo, INIFileValue)
	ENUM_ENTRY(gdo, AppData)
	ENUM_ENTRY(gdo, RegistryValue)
	ENUM_ENTRY(gdo, ResourceData)
	ENUM_ENTRY(gdo, ShortcutDescription)
	ENUM_ENTRY(gdo, ShortcutName)
	ENUM_ENTRY(gdo, ShortcutHotKey)
	ENUM_ENTRY(gdo, ShortcutArgument)
	ENUM_ENTRY(gdo, Verb)
	ENUM_ENTRY(gdo, Argument)
	ENUM_ENTRY(gdo, ComponentID)
	ENUM_ENTRY(gdo, FileSize)
	ENUM_ENTRY(gdo, Fileversion)
	ENUM_ENTRY(gdo, FileLanguage)
	ENUM_ENTRY(gdo, Documentation)
END_ENUM(StringType)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\espstate.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPSTATE.H

History:

--*/
#pragma once


// *************************************************************************************************
// TEMPORARY: Move to seperate file

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CEspState : public CObject
{
// Construction
public:
	CEspState();

// Enums
public:
	enum eState
	{
		esIdle				= 0,
		esUpdate			= 1,
		esGenerate			= 2,
		esUpload			= 3,
		esCopyData			= 4,
		esImportData		= 5,
		esImportGlossary	= 7,
		esInternal			= 8,
		esMerge				= 9,
		esOther					= 10,
		esOpeningMainTab		= 11,
		esOpeningResEdTab		= 12,
		esSavingResEdChanges	= 13,
		esApplyingFilter		= 14,
		esOpeningEDB            = 15,
		NUM_STATES
	};

// Data
private:
	BOOL		m_fComplete;
	IDispatch * m_pdispCheckTree;
	IDispatch * m_pdispDescBox;
	IDispatch * m_pdispDlgGlosGrid;
	eState		m_nOperation;		// Current operation
	eState		m_nLastOperation;	// Previous operation

// Operations
public:
	eState GetState();
	eState GetLastState();
	BOOL SetState(eState state);
	BOOL StartState(eState state);  // Moves to state and not complete
	BOOL FinishState();				// Moves to idle and complete

	BOOL GetComplete();
	void SetComplete(BOOL fComplete = TRUE);

	// Functions to store the current CheckTree and DescBox.
	//
	// NOTE: These functions do not AddRef() the pointers assigned since they
	// should never hold onto the interface outside of the parent's lifetime.
	//
	IDispatch * GetCurrentCheckTree();
	IDispatch * GetCurrentDescBox();
	IDispatch * GetCurrentDlgGlosGrid();
	void SetCurrentCheckTree(IDispatch * pdisp);
	void SetCurrentDescBox(IDispatch * pdisp);
	void SetCurrentDlgGlosGrid(IDispatch * pdisp);
};


//
//  Sets a state on creation, calls FinishState on destruction
class LTAPIENTRY CEspStateObj
{
public:
	CEspStateObj(CEspState::eState);
	
	~CEspStateObj();

private:
	int foo;
};

	

#pragma warning(default: 4275)

LTAPIENTRY CEspState & GetEspState();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\extlist.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    EXTLIST.H

History:

--*/
#ifndef EXTLIST_H
#define EXTLIST_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLocExtensionList : public CStringList
{
public:
	CLocExtensionList();

	void AssertValid(void) const;
	
	//
	//  Conversion routines to/from CLString's.
	//
	void NOTHROW ConvertToCLString(CLString &) const;
	BOOL NOTHROW ConvertFromCLString(const CLString &);
	
	~CLocExtensionList();
private:
	
};

#pragma warning(default : 4275)

#endif // EXTLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\fieldval.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FIELDVAL.H

History:

--*/

#pragma once

#pragma warning(disable : 4251)
class LTAPIENTRY CColumnVal
{
public:
	CColumnVal();
	explicit CColumnVal(const CColumnVal & val);
	explicit CColumnVal(const CPascalString & pasValue);
	explicit CColumnVal(long nValue);
	explicit CColumnVal(const COleDateTime & dateValue);
	explicit CColumnVal(BOOL fValue);
	
	enum ColumnValType
	{
		cvtNone,
		cvtString,
		cvtLong,
		cvtDate,
		cvtBool,
		cvtStringList,
		cvtLocTerm
	};

	void Serialize(CArchive &);
	
	const CColumnVal & operator=(const CColumnVal & val);
	void SetString(const CPascalString & pasValue);
	void SetLong(const long nValue);
	void SetDate(const COleDateTime & dateValue);
	void SetBool(const BOOL fValue);
	void SetStringIndex(const long nValue);
	
	ColumnValType GetType() const;
	const CPascalString &GetString() const;
	long GetLong() const;
	const COleDateTime & GetDate() const;
	BOOL GetBool() const;
	long GetStringIndex() const;
	
	int operator==(const CColumnVal &);
	int operator!=(const CColumnVal &);
	
#ifdef LTASSERT_ACTIVE
	void AssertValid(void) const;
#endif
	
private:
	BOOL Compare(const CColumnVal & valCompare);
	void AssignFrom(const CColumnVal & valSrc);
	
	ColumnValType m_cvt;
	
	union
	{
		long m_long;
		BOOL m_bool;
	};
	CPascalString m_pasString;
	COleDateTime m_Time;
};

typedef CColumnVal CCV;

#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "FieldVal.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\fielddef.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FIELDDEF.H

History:

--*/ 
#pragma once

#pragma warning(disable:4275)  // Exported classes

//------------------------------------------------------------------------------
struct LTAPIENTRY COLUMN_STRING_ENTRY
{
// Construction
public:
	COLUMN_STRING_ENTRY();
	COLUMN_STRING_ENTRY(const COLUMN_STRING_ENTRY & entry);

// Data
public:
	CLString	st;				// Display String
	long		nID;			// User value (unique ID)

// Operations
public:
	const COLUMN_STRING_ENTRY & operator=(const COLUMN_STRING_ENTRY & entry);
};

typedef CArray<COLUMN_STRING_ENTRY, COLUMN_STRING_ENTRY&> CColStrEntryArray;

//------------------------------------------------------------------------------
class LTAPIENTRY CColumnStrList : public CLocThingList<COLUMN_STRING_ENTRY>
{
// Operations
public:
	BOOL FindDisplayName(long nID, CLString & stName) const;
	BOOL FindID(const CLString &stName,long &nID) const;
};

// RAID:  LS42 Bug 46 fixed by MikeL
// Pointer to a function to allow each column
// type to have its own validation function.
typedef BOOL (* PFNVALIDATE) (LPCTSTR, DWORD);

// RAID:  LS42 Bug 46 fixed by MikeL
// Added m_pfnValidateFunc to allow each column
// type to have its own validation function.
//------------------------------------------------------------------------------
class LTAPIENTRY CColumnDefinition : public CRefCount
{
public:
	CColumnDefinition(const WCHAR * pszInternalName, long nID,
			const CLString &strName, const CLString &strHelp,
			CColumnVal::ColumnValType vt, Operators ops,
			BOOL fDisplayable, BOOL fSortable, BOOL fReadOnly,
			PFNVALIDATE pfnValidateFunc);

	void SetStringList(const CColumnStrList & lstColumnStr);
	
	const CPascalString & GetInternalName() const;
	long GetID() const;
	const CLString & GetDisplayName() const;
	const CLString & GetHelpText() const;
	BOOL IsDisplayable() const;
	BOOL IsSortable() const;
	BOOL IsReadOnly() const;
	
	CColumnVal::ColumnValType GetColumnType() const;
	Operators GetOperators() const;

	const CColumnStrList & GetStringList() const; 

	BOOL Validate (LPCTSTR lpsz, DWORD dw) const;

	
private:
	CPascalString	m_pasInternalName;	// Unique String ID
	long		m_nID;				// Unique Number ID (can be any number)
	CLString	m_strDisplayName;	// Displayed name
	CLString	m_strHelpText;		// Description of column
	CColumnVal::ColumnValType m_vt;	// Type of data
	Operators	m_ops;				// Valid filtering operations
	BOOL		m_fDisplayable;		// Column is displayable
	BOOL		m_fSortable;		// Column is sortable
	BOOL		m_fReadOnly;		// Column is read-only
	PFNVALIDATE	m_pfnValidateFunc;	// Pointer to column value validation func

	CColumnStrList m_lstColumnStr;
};


//------------------------------------------------------------------------------
// CEnumIntoColStrList provides a method of enumerating directly into a list of
// COLUMN_STRING_ENTRY's.
//
class LTAPIENTRY CEnumIntoColStrList : public CEnumCallback
{
// Construction
public:
	CEnumIntoColStrList(CColumnStrList & lstColStr, BOOL fLock = TRUE);
	~CEnumIntoColStrList();

// CEnumCallback implementation
public:
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CColumnStrList & m_lstColStr;
	BOOL	m_fLock;				// Lock list when finished
};


//------------------------------------------------------------------------------
class LTAPIENTRY CColDefUtil
{
// Operations
public:
	static void FillBool(CButton * pbtn, BOOL fValue = TRUE);	
	static void FillBool(CListBox * plbc, BOOL fValue = TRUE, BOOL fEmpty = TRUE);	
	static void FillBool(CComboBox * pcbc, BOOL fValue = TRUE, BOOL fEmpty = TRUE);	

	static void FillStringList(CListBox * plbc, const CColumnStrList & lstColStr,
			long idSelect = -1, BOOL fEmpty = TRUE);	
	static void FillStringList(CComboBox * pcbc, const CColumnStrList & lstColStr,
			long idSelect = -1, BOOL fEmpty = TRUE);


	//------------------------------------------------------------------------------
	class LTAPIENTRY CColDefCB : public CObject
	{
	public:
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CCheckBoxCB : public CColDefCB
	{
	public:
		CCheckBoxCB(CButton * pbtn);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CButton * const m_pbtn;
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CListBoxCB : public CColDefCB
	{
	public:
		CListBoxCB(CListBox * plbc);
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CListBox * const m_plbc;
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CComboBoxCB : public CColDefCB
	{
	public:
		CComboBoxCB(CComboBox * pcbc);
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CComboBox * const m_pcbc;
	};
};

LTAPIENTRY int AddListBoxItem(CListBox * plbc, const CLString & stAdd, DWORD dwItemData);
LTAPIENTRY int AddComboBoxItem(CComboBox * pcbc, const CLString & stAdd, DWORD dwItemData);
LTAPIENTRY int AddListBoxItem(CListBox * plbc, HINSTANCE hDll, UINT nStringID, DWORD dwItemData);
LTAPIENTRY int AddComboBoxItem(CComboBox * pcbc, HINSTANCE hDll, UINT nStringID, DWORD dwItemData);

LTAPIENTRY void GetBoolValue(BOOL fValue, CLString & stValue);

#pragma warning(default:4275)  // Exported classes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\fieldval.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FIELDVAL.INL

History:

--*/

inline
CColumnVal::CColumnVal()
{
	m_cvt = cvtNone;
}



inline
void
CColumnVal::SetString(
		const CPascalString &pas)
{
	m_cvt		= cvtString;
	m_pasString	= pas;
}



inline
void
CColumnVal::SetLong(
		long nValue)
{
	m_cvt	= cvtLong;
	m_long	= nValue;
}



inline
void
CColumnVal::SetDate(
		const COleDateTime &dt)
{
	m_cvt = cvtDate;
	m_Time = dt;
}



inline
void
CColumnVal::SetBool(
		BOOL b)
{
	m_cvt = cvtBool;

	m_bool = b;
}



inline
CColumnVal::CColumnVal(
		const CColumnVal &other)
{
	AssignFrom(other);
}



inline
CColumnVal::CColumnVal(
		const CPascalString &pas)
{
	SetString(pas);
}



inline
CColumnVal::CColumnVal(
		long nValue)
{
	SetLong(nValue);
}



inline
CColumnVal::CColumnVal(
		const COleDateTime &dt)
{
	SetDate(dt);
}



inline
CColumnVal::CColumnVal(
		BOOL b)
{
	SetBool(b);
}

		
		

inline
const CColumnVal &
CColumnVal::operator=(const CColumnVal &other)
{
	AssignFrom(other);
	
	return *this;
}



inline
void
CColumnVal::SetStringIndex(
		long idxValue)
{
	m_cvt	= cvtStringList;
	m_long	= idxValue;
}



inline
CColumnVal::ColumnValType
CColumnVal::GetType()
		const
{
	return m_cvt;
}



inline
const CPascalString &
CColumnVal::GetString()
		const
{
	LTASSERT(m_cvt == cvtString);
	return m_pasString;
}



inline
long
CColumnVal::GetLong()
		const
{
	LTASSERT(m_cvt == cvtLong);
	return m_long;
}



inline
const COleDateTime &
CColumnVal::GetDate()
		const
{
	LTASSERT(m_cvt == cvtDate);
	return m_Time;
}



inline
BOOL
CColumnVal::GetBool()
		const
{
	LTASSERT(m_cvt == cvtBool);
	return m_bool;
}



inline
long
CColumnVal::GetStringIndex()
		const
{
	LTASSERT(m_cvt == cvtStringList);
	return m_long;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\filedlg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FILEDLG.H

History:

--*/

#if !defined(__FileDlg_h__)
#define __FileDlg_h__

#pragma warning(disable : 4275)

class LTAPIENTRY CLFileDialog : public CFileDialog
{
	DECLARE_DYNAMIC(CLFileDialog)

public:
	CLFileDialog(
		BOOL bOpenFileDialog = TRUE, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		LPCTSTR pszTitle = NULL);

// Operations
public:
	CString GetFileFilter();

	virtual int DoModal();

// Attributes
public:
	virtual void SetOkButtonText(TCHAR const * const szOkText);
	virtual void SetOkButtonText(HINSTANCE const hResourceDll,
			UINT const uStringId);

	virtual void SetCancelButtonText(TCHAR const * const szCancelText);
	virtual void SetCancelButtonText(HINSTANCE const hResourceDll,
			UINT const uStringId);

	virtual void SetCheckIfBufferTooSmall(BOOL const bCheckIfBufferTooSmall);

// Data
protected:
	CLString m_strOkButton;				// new OK button text for dialog
	CLString m_strCancelButton;			// new Cancel button text for dialog
	BOOL m_bCheckIfBufferTooSmall;		// should DoModal() checks condition?

// Implementation
protected:
	//{{AFX_MSG(CProjectOpenDlg)
    virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Implementation
protected:
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT * pResult);
};

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\fileexcldlg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FILEEXCLDLG.H

History:

--*/

#if !defined(AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_)
#define AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_

#pragma warning(disable : 4275)
#pragma warning(disable : 4251)


class LTAPIENTRY CLFileExclDlg : public CLFileDialog
{
	DECLARE_DYNAMIC(CLFileExclDlg)

public:
	CLFileExclDlg(
		BOOL bOpenFileDialog = TRUE, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		LPCTSTR pszTitle = NULL);


	BOOL GetExclusivePref( ) const;

// Dialog Data
	//{{AFX_DATA(CLFileExclDlg)
	BOOL m_bExclusive;
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLFileExclDlg)
    public:
    virtual int DoModal();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
	//{{AFX_MSG(CLFileExclDlg)
		// NOTE - the ClassWizard will add and remove member functions here.
    virtual BOOL OnInitDialog();
	afx_msg void OnClickChkExcl();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#pragma warning(default : 4275)
#pragma warning(default : 4251)


#endif // !defined(AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\flddeflist.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FLDDEFLIST.H

History:

--*/
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class CColumnDefinition;

//------------------------------------------------------------------------------
class LTAPIENTRY CColDefList : public CTypedPtrList<CPtrList, CColumnDefinition *>
{
// Construction
public:
	CColDefList();
	CColDefList(const CColDefList &);
	
	~CColDefList();

// Operations
public:
	BOOL FindColumnDefinition(long nSearchID, const CColumnDefinition * & pFoundColDef) const;

// Debugging
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

#pragma warning(default : 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\globals.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GLOBALS.H

History:

--*/

#include "resource.h"
 
extern HINSTANCE g_hLocUtilDll;

void GlobalInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\flddefhelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FLDDEFHELP.H

History:

--*/

// RAID:  LS42 Bug 46 fixed by MikeL
// Pointer to a function to allow each column
// type to have its own validation function.
typedef BOOL (* PFNVALIDATE) (LPCTSTR, DWORD);

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validation function.
//------------------------------------------------------------------------------
struct SBasicColumn
{
	const WCHAR *szInternalName;
	long nID;
	UINT IDSName;
	UINT IDSHelp;
	CColumnVal::ColumnValType vt;
	Operators ops;
	BOOL fDisplay;
	BOOL fSort;
	BOOL fReadOnly;
	PFNVALIDATE pfnValidateFunc;
};


struct SStringListColumn
{
	SBasicColumn sBasic;
	UINT IDSStringList;
};


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CColDefHelper : public CObject
{
public:
	CColDefHelper(HINSTANCE h);

	void SetBasicColumns(const SBasicColumn * pBasic, UINT nCntBasic);
	void SetStringColumns(const SStringListColumn * pStrings, UINT nCntStrings);
	
	CTableSchema * CreateSchema(const SchemaId &, UINT IDSDescription);
	
private:
	HINSTANCE				 m_hInst;
	const SBasicColumn *	 m_pBasicColumns;
	const SStringListColumn *m_pStringColumns;
	UINT					 m_uiBasicCount;
	UINT					 m_uiStringCount;
};


#pragma warning(default : 4275)

const TCHAR COL_PICK_SEPARATOR = _T('\n');

#define BEGIN_BASIC_COLUMN_DEFS(var) \
const SBasicColumn var[] = \
{

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validate function.
#define BASIC_COLUMN_DEF_ENTRY(name, nID, IDSName, IDSHelp, cvt, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc) \
	{name, nID, IDSName, IDSHelp, cvt, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc}

#define END_BASIC_COLUMN_DEFS() \
}

#define BEGIN_STRING_LIST_COLUMN_DEFS(var) \
const SStringListColumn var[] = \
{

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validate function.
#define STRING_LIST_COLUMN_ENTRY(name, nID, IDSName, IDSHelp, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc, IDSList) \
	{ { name, nID, IDSName, IDSHelp, CColumnVal::cvtStringList, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc }, IDSList}

#define END_STRING_LIST_COLUMN_DEFS() \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\gotohelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GOTOHELP.H

History:

--*/
 
class LTAPIENTRY CGotoHelp : public CRefCount
{
public:
	virtual void Edit() = 0;
	
	virtual BOOL GotoHelp() = 0;
	
};



class LTAPIENTRY CEspGotoHelp : public CGotoHelp
{
public:
	explicit CEspGotoHelp(UINT uiHelpId);

	virtual void Edit();
	virtual BOOL GotoHelp();

private:
	UINT m_uiHelpId;
};


class LTAPIENTRY CExternalGotoHelp : public CGotoHelp
{
public:
	CExternalGotoHelp(const TCHAR *szFileName, UINT uiHelpId);

	virtual void Edit();
	virtual BOOL GotoHelp();

private:
	CLString m_strFileName;
	UINT m_uiHelpId;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\interface.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    INTERFACE.H

History:

--*/

//  Various public interfaces in Espresso.
//  
 
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\goto.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GOTO.H

History:

--*/
#pragma once

class LTAPIENTRY CGoto : public CRefCount
{
public:
	CGoto()	{};
	
	virtual void Edit() = 0;
	virtual BOOL Go() = 0;


private:
	CGoto(const CGoto &);
	
};

#pragma warning(disable:4251)

class LTAPIENTRY CShellGoto : public CGoto
{
public:
	CShellGoto(const TCHAR *szFileName);

	virtual void Edit();
	virtual BOOL Go();

private:

	CLString m_strFileName;
};

#pragma warning(default:4251)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\locobj.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCOBJ.H

History:

--*/

//  Defines the mother of all classes for the Espresso 2.0 project.  For now,
//  this just devolved to CObject.  We define it just in case we decide to
//  implement our own mother of all classes.
//  
 
#ifndef LOCOBJ_H
#define LOCOBJ_H


//
//  The compiler worries when you export a class that has a base class
//  that is not exported.  Since I *know* that CObject is exported
//  tell the compliler that this really isn't a problem right here.
//
#pragma warning(disable : 4275)

class LTAPIENTRY CLObject : public CObject
{
public:
	CLObject();

	virtual void AssertValid(void) const;

	virtual void Serialize(CArchive &ar);

	virtual UINT GetSchema(void) const;
	
	virtual ~CLObject();

protected:

private:
};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locobj.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\locenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    :LOCENUM.H

History:

--*/
//------------------------------------------------------------------------------
class LTAPIENTRY CStringType
{
public:
	//
	//  This order is important - if must change it, make sure you make the
	//  corresponding changes in GetTypeName() and GetTypeTLA()!
	//  All new values must be added TO THE END, or you will break old
	//  parsers...
	//
	// NOTE: These #include files define an enumeration.  They MUST be inside this
	// class definition.
	//
#include "PreCEnum.h"
#include "EnumStringType.h"
	
	static int DefaultValue;
	NOTHROW static const TCHAR * GetTypeName(CStringType::StringType);
	NOTHROW static const TCHAR * GetTypeTLA(CStringType::StringType);
	static void Enumerate(CEnumCallback &);
	static const CStringType::StringType GetStringType(const TCHAR * tChIn);
	static const TCHAR * GetDefaultStringTypeText();
	static const CStringType::StringType GetDefaultStringType();
	static bool IsValidStringType(const CStringType::StringType &nIn);
	static bool IsValidStringType(const TCHAR * tChIn);
	
private:
	//
	//  Nobody should actually CONTRUCT one of these.
	//
	CStringType();

	//
	//  Used to store the info about each element in the enum...
	//
	struct StringTypeInfo
	{
		TCHAR szTLA[4];
		const TCHAR * szName;
	};

	static const StringTypeInfo m_Info[];
};

typedef CStringType CST;


//------------------------------------------------------------------------------
class LTAPIENTRY CPlatform
{
public:
	// NOTE: These #include files define an enumeration.  They MUST be inside this
	// class definition.
	//
#include "PreCEnum.h"
#include "EnumPlatform.h"
	
	NOTHROW static const TCHAR * GetPlatformName(CPlatform::Platform);
	static void Enumerate(CEnumCallback &);
	static const CPlatform::Platform CPlatform::GetPlatformType(const TCHAR * tChplat);
	static const TCHAR * GetDefaultPlatformText();
	static const CPlatform::Platform GetDefaultPlatform();
	static bool IsValidPlatform(const CPlatform::Platform &nIn);
	static bool IsValidPlatform(const TCHAR * tChplat);
	
private:
	static int DefaultValue;
	COSPlatform();
	static const TCHAR * const m_szPlatformNames[];
};


//------------------------------------------------------------------------------
class LTAPIENTRY CLocApprovalState
{
public:
	enum ApprovalState
	{
		Invalid = 0,
		Old_Pending,					// OBSOLETE! Do Not Use!
		Approved,
		PreApproved,
		NotReady,
		Failed,
		ForResearch,
		NotApplicable
	};
	static ApprovalState DefaultValue;
	NOTHROW static const TCHAR * GetApprovalText(CLocApprovalState::ApprovalState);
	static void Enumerate(CEnumCallback &);
	static const CLocApprovalState::ApprovalState GetApprovalState(const TCHAR * );
	static const TCHAR * GetDefaultApprovalText();
	static const CLocApprovalState::ApprovalState GetDefaultApprovalState();
	static BOOL IsValidApprovalState(const CLocApprovalState::ApprovalState &nIn);
	static BOOL IsValidApprovalState(const TCHAR * );
	
private:
	struct SStateName
	{
		ApprovalState as;
		const TCHAR *szName;
	};
	
	static const SStateName m_aStateNames[];
	CLocApprovalState();
};

typedef CLocApprovalState CAS;


//------------------------------------------------------------------------------
class LTAPIENTRY CLocAutoApproved
{
// Operations
public:
	enum AutoApproved
	{
		Invalid = 0,
		No,
		Partial,
		Yes,
		NotApplicable
	};

	NOTHROW static TCHAR const * GetAutoApprovedText(AutoApproved const aa);
	static void Enumerate(CEnumCallback & cbEnumCallback);
	static AutoApproved const GetAutoApproved(TCHAR const * const tChIn);
	static TCHAR const * GetDefaultAutoApprovedText();
	static AutoApproved const GetDefaultAutoApproved();
	static bool IsValidAutoApproved(AutoApproved const nIn);
	static bool IsValidAutoApproved(TCHAR const * tChIn);
	
// Construction
private:
	// prevent constructing, copying and assigning
	CLocAutoApproved();
	CLocAutoApproved(CLocAutoApproved const &);
	CLocAutoApproved const & operator=(CLocAutoApproved const &);

// Member Variables
private:
	static TCHAR const * const m_szAutoApprovedNames[];
	static AutoApproved const DefaultValue;
};

typedef CLocAutoApproved CAA;


//------------------------------------------------------------------------------
class LTAPIENTRY CLocTranslationOrigin
{
public:
	enum TranslationOrigin
	{
		Invalid = 0,
		New,
		Uploaded,
		AutoTranslated,
		Copied,
		PreviousVersion,
		NotApplicable
	};

	NOTHROW static const TCHAR * GetOriginText(CLocTranslationOrigin::TranslationOrigin);
	static void Enumerate(CEnumCallback &);
	
private:
	static const TCHAR *const m_szOriginNames[];
	CLocTranslationOrigin();
};

typedef CLocTranslationOrigin CTO;

class LTAPIENTRY COutputTabs
{
public:
	enum OutputTabs
	{
		File,
		Test,
		Messages,
		Update,
		Utility,
		GlobalErrorBox,
		OutputMax
	};

	static void Enumerate(CEnumCallback &);
	
private:
	static const UINT m_nStateNames[];
	COutputTabs();
};



class LTAPIENTRY CValidationCode
{
public:
	enum ValidationCode
	{
		NotHandled,			// for sub-parser use ONLY
		NoError,
		Warning,
		Error
	};

	NOTHROW static ValidationCode UpgradeValue(ValidationCode OldValue,
			ValidationCode NewValue);
	
private:
	CValidationCode();
};

typedef CValidationCode CVC;


//------------------------------------------------------------------------------
class LTAPIENTRY CValidationOptions
{
public:
	CValidationOptions();
	
	enum ValidationOption
	{
		CheckDBCSHotKeyPos = 0,
		CheckDBCSHotKeyChar,
		CheckRemovedHotKey,
		CheckAddedHotKey,
		CheckHotKeyPosition,
		CheckRemovedAccelerator,
		CheckReorderableParams,
		CheckPrintf,
		CheckBlankTarget,
		CheckBlankSource,
		CheckNewLineCount,
		CheckChangedTerminator,
		CheckLeadingPunctuation,
		CheckTrailingPunctuation,
		CheckLeadingSpaces,
		CheckTrailingSpaces,
		CheckTranslationSize,
		CheckNULChanges,
		CheckCharsInCodePage,
		//
		//  Internal value, DO NOT USE
		//
		END_MARKER
	};

	static void Enumerate(CEnumCallback &);
	NOTHROW static void GetText(ValidationOption, CLString &);
	NOTHROW static void GetLongText(ValidationOption vo, CLString &strText);

	NOTHROW void SetFlag(ValidationOption, BOOL);
	NOTHROW BOOL GetFlag(ValidationOption) const;
	NOTHROW const CValidationOptions & operator=(const CValidationOptions &);
	
private:
	DWORD dwFlags;
};

typedef CValidationOptions CVO;


//------------------------------------------------------------------------------
class LTAPIENTRY CAmpKeyword
{
public:
	enum AmpKeyword
	{
		amp = 0,
		lt,
		gt,
	};
	
	static const WCHAR * GetValue(CAmpKeyword::AmpKeyword);
	static unsigned int GetValueLength(CAmpKeyword::AmpKeyword);
	static WCHAR GetEquivalentChar(CAmpKeyword::AmpKeyword);
	static int FindAmpKeyword(const WCHAR * pwszStr, unsigned int nPos);
	
private:
	//
	//  Nobody should actually CONTRUCT one of these.
	//
	CAmpKeyword();

	//
	//  Used to store the info about each element in the enum...
	//
	struct SAmpKeyword
	{
		const WCHAR * m_wszValue;
		WCHAR m_chEquivalentChar;
	};

	static const SAmpKeyword m_aAmpKeywords[];
	static const int m_nNumAmpKeywords;
};

typedef CAmpKeyword CAK;


//------------------------------------------------------------------------------
// CEnumIntoPasStrList provides a method of enumerating directly into a list of
// CPascalString's.
//
// ASSUMPTIONS:
// 1.  Enumerators will send data in proper increasing order
// 2.  No gaps in indicies.
//
class LTAPIENTRY CEnumIntoPasStrList: public CEnumCallback
{
// Construction
public:
	CEnumIntoPasStrList(CPasStringList & lstPasStr, BOOL fLock = TRUE);
	~CEnumIntoPasStrList();

// CEnumCallback implementation
public:
	virtual void SetRange(UINT nStart, UINT nFinish);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CPasStringList & m_lstPasStr;
	UINT	m_nStart;				// Start of range
	UINT	m_nFinish;				// End of range
	UINT	m_nCurrent;				// Check of current item TO retrieve
	BOOL	m_fLock;				// Lock list when finished
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\locobj.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCOBJ.INL

History:

--*/ 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Mother object constructor.  Does nothing, since for now we rely on
//  AFX CObject to do the work for us.
//  
//-----------------------------------------------------------------------------
inline
CLObject::CLObject()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\locpct.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCPCT.H

History:

--*/

#ifndef LOCUTIL__LocPct_H__INCLUDED
#define LOCUTIL__LocPct_H__INCLUDED

// Classes in this header file
class CLocPercentHelper;
class CLocPercentFrame;

//
// The CLocPercentHelper class can help in building acurate
// percentage complete messages for complicated processes.
//
// Here is how the CLocPercentHelper works.
//
// The CLocPercentHelper class deals with "frames" of work.  Each frame
// is 100% of a unit of work.  A CLocPercentHelper will always
// start off with 1 frame.  If you want to use these functions
// you first need to call PercentSetUnits passing a number that will
// represent 100% complete.  For example if you need to process 4 items
// you could set this to 4.  After you process each item you would
// call PercentAddValue.  Correct status messages would be sent
// indicating you are 1/4, 2/4, 3/4, and 4/4 done.

// This processing comes in handy when you break up the work
// in sub functions, or "frames" of work.  Each function only 
// knows about what it needs to do.  

// Say in the resource example you call a function to handle each
// resource.  Each time the handler is called it is given 1/4 
// of the total time.  The handler can break up its time however 
// it likes without knowing how much total time there is.  

// Say the sub function needs to do 10 things.  It calls PercentSetUnits(10).
// It then calls PercentAddValue as each of the 10 things are
// accomplished.  The total percent will reflect that 100% of this
// sub function is really only 1/4 of the total percent.  The sub function
// only needs to worry about what it knows it has to do.  
// The sub function can assign part of its work to other functions
// by creating frames for them.  There is no limit to the number
// of frames.
// 

// Override the virtual function void OnSendPercentage(UINT nPct) 
// in your subclass of CLocPercentHelper to do what you want
// with the percent calculated from the helper.

// Example:

/*

	CLocPercentHelper pctHelp;
	pctHelp.PercentSetUnits(4); //assume 4 items to process
	
	do
	{
		pctHelp.PercentPushFrame(1); //Set up a new Frame equal
		                             //to 1 of my units of work.
									 //In this case 1/4 of the
									 //total time.
									 
									 //All of the Percent... functions
									 //called made now deal with
									 //this new frame.
		
		HandleItem(pctHelp);
		
		pctHelp.PersentPopFrame();	 //Remove the frame created
		                             //and mark the amount 
									 //of time it was equal to
									 //completed.
									 
	  
	}
	while (more items)
	  
-----------------------------------------------------------------------

  HandleItem(CLocPercentHelper& pctHelp) function
  
	pctHelp.PercentSetUnits(10);  //Assume this is a dialog resource
	                              //with 10 controls.  
								  //This function divides up 
								  //the work it needs to do in
								  //a way that makes sence for it.
								  //
								  //When this "frame" is at 100%
								  //the total percentage is still
								  //just 1/4 of the total time
								  //since this frame was given 1/4
								  //of the total time from the caller.
								  
  
	do
	{
					
		// This function can assign part of its processing 
		// to another function by calling PercentPushFrame also.
		
		HandleControl();
		pctHelp.PercentAddValue();	//Send a message to the 
		                            //handler indicating the 
									//current percentage.
									//The object will calculate
									//the total percent based on 
									//the current stack of frames.
	}
	
	while (more controls)  
		
		  
			
*/



//
// CLocPercentFrame represents a working unit of progress.  
// The progress model implemented with the CLocPercentHelper will
// support unlimited levels of work units.  
//
// This class is a helper class used only by CLocPercentHelper
//


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocPercentFrame : public CObject
{
	friend CLocPercentHelper;

protected:
	CLocPercentFrame();
	CLocPercentFrame(CLocPercentFrame* pParent, UINT nValueInParent);
	
	void SetComplete();
	// Force this frame to represent 100%. 
	
	void AddValue(UINT nValue);
	// Add nValue to the internal value.
	// The internal value will never be greater than
	// the internal units.
	
	void SetValue(UINT nValue);
	// Set the internal value.
	// The internal value will never be greater than
	// the internal units.
	
	void SetUnits(UINT nUnits);
	// Set the internal units
	
	UINT m_nUnits;			     //Number that represents 100%
	UINT m_nValue;          	 //Number that represent how far done
	                             //this frame is.
	
	CLocPercentFrame* m_pParent;	 //Pointer to the parent frame
	UINT m_nValueInParent;       //How much this frame is worth
	                             //in the parents context.
	
	void MemberInit();			 
	// Initialize member values 
};

//
// List of frames in the helper
//

class LTAPIENTRY CLocPercentFrameList : public CTypedPtrList<CPtrList, CLocPercentFrame*>
{
};


class LTAPIENTRY CLocPercentHelper : public CObject
{
public:
	
	CLocPercentHelper();

	virtual ~CLocPercentHelper();
	
	void PercentSetUnits(UINT nUnits, BOOL bReport = FALSE);
	// Set the units of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.

	void PercentSetValue(UINT nValue, BOOL bReport = TRUE);
	// Set the value of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.

	void PercentAddValue(UINT nValue = 1, BOOL bReport = TRUE);
	// Add nValue to the value of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentSetComplete(BOOL bReport = TRUE);
	// Set the current frame complete.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentForceAllComplete(BOOL bReport = TRUE);
	// Force all frames complete.
	// Calculate and report 100% done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentPushFrame(UINT nValueInParent = 1);
	// Create a new frame and assign in nValueInParent 
	// All Percent... calls made after this call deal with
	// the new frame.  
	
	void PercentPopFrame(BOOL bReport = TRUE);
	// Set the current frame complete and add the current
	// frames valueInParent to its parent frame. 
	// The current frames parent is now the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentSetStrict(BOOL bOnOff = TRUE);
	// Strict behavior means the helper will ASSERT (_DEBUG only) if 
	// the calculated percent is over 100%.  This can happen
	// if the unit values assigned to frames are not truly what 
	// the process does.  If you are unable to set acurate
	// unit values and the program quesses, you can turn
	// strict off.
	
	BOOL PercentIsStrict();
	// Return TRUE or FALSE if strict is on.
	
protected:

	// Support for Progress Reporting
	CLocPercentFrame m_FrameMain;	        //The main frame always 
	                                    //present.  This frame
	                                    //will never have a parent.
	
	CLocPercentFrameList m_FrameList;      //List of open frames.
	
	CLocPercentFrame* m_pCurrentFrame;     //Pointer to the current
	                                    //frame
	
	BOOL m_bStrict;						//Strict on will ASSERT if 
										//total % gets over 100
	
	
	void SendPercentage();
	// Calculates the percentage based on the current frame
	// Calles OnSendPercentage with the calulated value.
	
	void SafeDeleteFrame(CLocPercentFrame* pFrame);
	// Safely deletes a frame making sure the pFrame is 
	// not m_FrameMain.
	
	virtual void OnSendPercentage(UINT nPct);
	// Callback function for subclasses to do what they
	// want with the percentage.  Default implementation
	// does nothing.
 	
};

#pragma warning(default: 4275)

//
// Helper class with a CProgressiveObject
//
class LTAPIENTRY CLocPctProgress : public CLocPercentHelper
{
public:
	CLocPctProgress();
	CLocPctProgress(CProgressiveObject* pProgObj);

	void SetProgressiveObject(CProgressiveObject* pProgObj);

protected:
	virtual void OnSendPercentage(UINT nPct);

	CProgressiveObject* m_pProgObj;
};

#endif // LOCUTIL__LocPct_H__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\logfile.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOGFILE.H

History:

--*/

#ifndef LOCUTIL_LOGFILE_H
#define LOCUTIL_LOGFILE_H


class LTAPIENTRY CLogFile
{
public:
	CLogFile();
	
	virtual void IssueMessage(const CLString &strFileName, const CLString &strItemId,
			const CLString  &strChange, UINT uiChangeId,
			const CLString &strDetails, CGoto *, CGotoHelp *) = 0;
	
	virtual ~CLogFile();
	

private:
	CLogFile(const CLogFile &);
	const CLogFile &operator=(const CLogFile &);
};



CLString LTAPIENTRY GetLogFileName(const TCHAR *szProjectPath,
		const TCHAR *szAddOn, const TCHAR *szExtension);

#include "logfile.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\logfile.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOGFILE.INL

History:

--*/

inline
CLogFile::CLogFile()
{}



inline
CLogFile::~CLogFile()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\lstime.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LSTIME.H

History:

--*/

VOID
LTAPIENTRY GMTTimeToLocalTime(COleDateTime &);


VOID
LTAPIENTRY LocalTimeToGMTTime(COleDateTime &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\locstr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCSTR.H

History:

--*/

//  Definition of a localizable string.  The following classes are defined:
//      CLocString - all the operations we can do on a localizable string.
 

#ifndef LOCSTR_H
#define LOCSTR_H


interface ILocStringValidation;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocString : public CObject
{
public:
	NOTHROW CLocString();

	void AssertValid(void) const;
	
	//
	//  Information about the localizable string...
	//
	NOTHROW BOOL HasHotKey(void) const;
	NOTHROW WCHAR GetHotKeyChar(void) const;
	NOTHROW UINT GetHotKeyPos(void) const;
	NOTHROW const CPascalString & GetNote(void) const;
	NOTHROW const CPascalString & GetString(void) const;
	
	NOTHROW int operator==(const CLocString &) const;
	NOTHROW int operator!=(const CLocString &) const;
	//
	//  Some useful assigment operators.
	//
 	NOTHROW void SetString(const CPascalString&);
	NOTHROW void SetHotKeyChar(WCHAR);
	NOTHROW void SetHotKeyPos(UINT);
	NOTHROW void ClearHotKey(void);
	NOTHROW void SetNote(const CPascalString &);
	
	// Conversion from/to Windows hot key strings
	// This is also the format used to display strings in edit mode
	NOTHROW int ParseString(const CPascalString & pasStr, WORD langId);
	NOTHROW void ComposeString(CPascalString & pasStr, WORD langId) const;


	NOTHROW CST::StringType GetStringType(void) const;
	NOTHROW CodePageType GetCodePageType(void) const;
	NOTHROW void SetStringType(CST::StringType);
	NOTHROW void SetCodePageType(CodePageType);


	// Conversion from/to displayable string in the resource table.
	void GetDisplayLString(CLString &strDest, LangId langId);
	void GetDisplayPString(CPascalString &strDest, LangId langId, BOOL bReplaceMetaCharacters);
	void GetEditableString(CLString &strDest, LangId langId);
	int ParseEditableString(const CLString &strSrc, LangId langId, CString &strErr);
	int ParseEscapeChar(BOOL bSetHotkeyPos, CPascalString &strErr);
	int ParseAmpersand(LangId langId,BOOL bSetHotkeyPos,CPascalString &strErr);
	
	NOTHROW const CLocString& operator=(const CLocString&);
	
	NOTHROW ~CLocString();

protected:

private:

	//
	//  Private implementation functions.
	//
	NOTHROW void CopyLocString(const CLocString &);
	virtual void Serialize(CArchive &) {}
	
	//
	//  Prevents the default copy constructor from being called.
	//
	CLocString(const CLocString&);

	CPascalString m_pasBaseString;
	CST::StringType m_stStringType;
	WCHAR m_wchHotKeyChar;
	UINT m_uiHotKeyPos;
	CodePageType m_cptCodePageType;		 //  cpAnsi
	CPascalString m_pstrNote;
};



class LTAPIENTRY CLocTranslation : public CObject
{
public:
	CLocTranslation();
	CLocTranslation(const CLocTranslation &);
	CLocTranslation(const CLocString &Source, LangId lidSource,
			const CLocString &Target, LangId lidTarget);

	NOTHROW int operator==(const CLocTranslation &) const;
	NOTHROW int operator!=(const CLocTranslation &) const;

	void AssertValid(void) const;

	NOTHROW void SetTranslation(const CLocString &Source, LangId lidSource,
			const CLocString &Target, LangId lidTarget);
	NOTHROW void SetNote(const CPascalString &);
	NOTHROW void CalculateRanking(const CLocString &);
	
	NOTHROW const CLocString & GetSourceString(void) const;
	NOTHROW const CLocString & GetTargetString(void) const;
	NOTHROW const CPascalString & GetNote(void) const;
	NOTHROW UINT GetRanking(void) const;
	NOTHROW LangId GetSourceLanguage(void) const;
	NOTHROW LangId GetTargetLanguage(void) const;
	
	NOTHROW CVC::ValidationCode ValidateTranslation(
			const CValidationOptions &) const;

	NOTHROW CVC::ValidationCode ValidateTranslation(
			const CValidationOptions &, BOOL,
			const CLString &, CReport *, CGoto *) const;
	
	NOTHROW const CLocTranslation & operator=(const CLocTranslation &);
	
	~CLocTranslation();

private:
	NOTHROW void CopyTranslation(const CLocTranslation &);

	NOTHROW void ReordBuildSig(const CLocString &, CPascalString *) const;
	NOTHROW void PrintfBuildSig(const CLocString &, CPascalString &) const;
	NOTHROW int ReplaceableLength(const CPascalString &, UINT) const;
	
	CLocString      m_lsSource;
	LangId          m_lidSource;
	CLocString      m_lsTarget;
	LangId          m_lidTarget;
	CPascalString   m_pstrGlossaryNote;
	UINT            m_uiRanking;
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locstr.inl"
#endif


#endif //LOCSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\operator.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    OPERATOR.H

History:

--*/

#pragma once

typedef UINT Operators;


class LTAPIENTRY CColumnOp
{
public:
	enum Operator
	{
		None   = 0,
		EQ 	   = 0x00000001,
		NOTEQ  = 0x00000002,
		GT     = 0x00000004,
		LT     = 0x00000008,
		LTEQ   = 0x00000010,
		GTEQ   = 0x00000020,
		WITHIN = 0x00000040,
		BEYOND = 0x00000080,

		CONTAINS     = 0x00000100,
		CONTAINSWORD = 0x00000200,
		STARTWITH    = 0x00000400,
		ENDWITH      = 0x00000800,
	};

	typedef CList<Operator, Operator> COperatorList;

	static CLString GetText(Operator);
	static void GetOperators(const Operators, COperatorList &);


private:
	CColumnOp();
};

typedef CColumnOp CCO;

const Operators NoOps = 0;
const Operators NumericOps = CCO::EQ | CCO::NOTEQ | CCO::GT | CCO::LT;
const Operators SimpStrOps = CCO::EQ | CCO::NOTEQ | CCO::STARTWITH | CCO::ENDWITH;
const Operators CompStrOps = CCO::CONTAINS | CCO::CONTAINSWORD;
const Operators StringOps  = SimpStrOps | CompStrOps;
const Operators StrListOps = CCO::EQ | CCO::NOTEQ;
const Operators DateOps    = CCO::LT | CCO::GT | CCO::EQ | CCO::NOTEQ | CCO::WITHIN | CCO::BEYOND;
const Operators BooleanOps = CCO::EQ | CCO::NOTEQ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\report.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REPORTER.INL

History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\product.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PRODUCT.H

History:

--*/
#pragma once


struct ESP_USER_SETUP_DATA
{
	CLString strName;
	CLString strCompany;
};


BOOL LTAPIENTRY GetEspressoVersion(CLString& strVersion);

BOOL LTAPIENTRY GetEspressoFileVersion(const CLString& strFile, 
	CLString& strVersion);

BOOL LTAPIENTRY GetEspressoFileCopyright(const CLString& strFile, 
	CLString& strCopyright);

BOOL LTAPIENTRY GetSetupUserInfo(ESP_USER_SETUP_DATA& userData);

void LTAPIENTRY GetApplicationDirectory(CLString &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\locstr.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCSTR.INL

History:

--*/

//  Inline functions for the CLocString object.  This file is included by
//  locstr.h, and should never be used directly.
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return the 'generic' type of the string.  
//  
//-----------------------------------------------------------------------------
inline
CST::StringType
CLocString::GetStringType(void)
		const
{
	if (!m_pasBaseString.IsNull())
	{
		return m_stStringType;
	}
	else
	{
		return CST::None;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the 'Base' string.  This is the localizable string, 
//  It is the part that weighs most heavily in auto-translation.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocString::GetString(void)
		const
{
	return m_pasBaseString;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the code page type for the string.
//  
//-----------------------------------------------------------------------------
inline
CodePageType
CLocString::GetCodePageType(void)
		const
{
	return m_cptCodePageType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocString::GetNote(void)
		const
{
	return m_pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the string type.  The parser and database are the only people who
//  should be setting this.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetStringType(
		CST::StringType newType)
{ 
	m_stStringType = newType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the 'Base' string.
//
//  This method can throw the following exceptions:
//      CMemoryException
//
//-----------------------------------------------------------------------------
inline
void
CLocString::SetString(
		const CPascalString &pstrNewBaseString)
{
	m_pasBaseString = pstrNewBaseString;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the code page type for the string.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetCodePageType(
		CodePageType cptNew)
{
	m_cptCodePageType = cptNew;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clears out the hot-key to an uninitialized state.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::ClearHotKey(void)
{
	m_wchHotKeyChar = L'\0';
	m_uiHotKeyPos = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetNote(
		const CPascalString &pstrNote)
{
	m_pstrNote = pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  See if the hotkey has any info in it.  Checks to see if the hotkey is
//  a valid character (ie non-zero).
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if it contains a hotkey
CLocString::HasHotKey(void)
		const
{
	return (m_wchHotKeyChar != L'\0');
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key character.  If the hot-key is not initialized, this
//  returns NUL.
//  
//-----------------------------------------------------------------------------
inline
WCHAR									// Hot key character.
CLocString::GetHotKeyChar(void)
		const
{
	return m_wchHotKeyChar;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key position.  Interpretationb of the position is left up
//  to the caller.  If the hot-key is uninitialized, this returns 0.
//  
//-----------------------------------------------------------------------------
inline
UINT									// Position of the hot key.
CLocString::GetHotKeyPos(void)
		const
{
	return m_uiHotKeyPos;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the hot-key character
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetHotKeyChar(
		WCHAR wchNewHotKeyChar)			// Character to set as hot key.
{
	m_wchHotKeyChar = wchNewHotKeyChar;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the position of the hot-key
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetHotKeyPos(
		UINT uiNewHotKeyPos)			// Position for the hot-key.
{
	m_uiHotKeyPos = uiNewHotKeyPos;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for LocStrings.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocString::operator=(
		const CLocString &lsSource)
{
	CopyLocString(lsSource);

	return *this;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CLocString::operator==(
		const CLocString &lsOtherString) // String to compare
		const
{
	return ((((HasHotKey() && lsOtherString.HasHotKey()) &&
			(GetHotKeyChar() == lsOtherString.GetHotKeyChar()) &&
			(GetHotKeyPos() == lsOtherString.GetHotKeyPos())) ||
			(!HasHotKey() && !lsOtherString.HasHotKey())) &&
			m_pasBaseString == lsOtherString.m_pasBaseString);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CLocString::operator!=(
		const CLocString &lsOtherString) // String to compare
		const
{
	return !(operator==(lsOtherString));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the Translation Object.  Just sets the components to
//  default bad values.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation()
{
	m_lidSource = BAD_LOCALE;
	m_lidTarget = BAD_LOCALE;
	m_uiRanking = 0;
}



//-----------------------------------------------------------------------------
//  
//  Implementation for copying a translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::CopyTranslation(
		const CLocTranslation &Source)
{
	m_lsSource = Source.m_lsSource;
	m_lidSource = Source.m_lidSource;
	m_lsTarget = Source.m_lsTarget;
	m_lidTarget = Source.m_lidTarget;
	m_pstrGlossaryNote = Source.m_pstrGlossaryNote;
	m_uiRanking = Source.m_uiRanking;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Copy constructor for a CLocTranslation
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation(
		const CLocTranslation &Source)
{
	CopyTranslation(Source);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets all the required components of a translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::SetTranslation(
		const CLocString &Source,
		LangId lidSource,
		const CLocString &Target,
 		LangId lidTarget)
{
	m_lsSource = Source;
	m_lidSource = lidSource;
	m_lsTarget = Target;
	m_lidTarget = lidTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the glossary note for the translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::SetNote(
		const CPascalString &pstrNote)
{
	m_pstrGlossaryNote = pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the translation that takes all the required info.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation(
		const CLocString &Source,
		LangId lidSource,
		const CLocString &Target,
 		LangId lidTarget)
{
	SetTranslation(Source, lidSource, Target, lidTarget);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int 
CLocTranslation::operator==(const CLocTranslation &locTran) const
{
	return (
			GetSourceString() == locTran.GetSourceString()
			&& GetSourceString().GetStringType() 
					== locTran.GetSourceString().GetStringType()
			&& GetTargetString() == locTran.GetTargetString()
			&& GetTargetString().GetStringType() 
					== locTran.GetTargetString().GetStringType()
			&& GetNote() == locTran.GetNote()
			&& GetRanking() == locTran.GetRanking()
		   );
}

inline
int 
CLocTranslation::operator!=(const CLocTranslation &locTran) const
{
	return !(operator==(locTran));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the source string of the translation.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocTranslation::GetSourceString(void)
		const
{
	return m_lsSource;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the target string for the translation.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocTranslation::GetTargetString(void)
		const
{
	return m_lsTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the glkossary note for the translation.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocTranslation::GetNote(void)
		const
{
	return m_pstrGlossaryNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the translation ranking for the strnslation.  See
//  CalculateRanking().
//  
//-----------------------------------------------------------------------------
inline
UINT
CLocTranslation::GetRanking(void)
		const
{
	return m_uiRanking;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the embedded source language for the translation.
//  
//-----------------------------------------------------------------------------
inline
LangId
CLocTranslation::GetSourceLanguage(void)
		const
{
	return m_lidSource;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the embedded target language for the translation.
//  
//-----------------------------------------------------------------------------
inline
LangId
CLocTranslation::GetTargetLanguage(void)
		const
{
	return m_lidTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Validates the translation.  This make sure that all the needed components
//  of tghe source string exist in some form in the target string.  This
//  simply returns a validation code.
//  
//-----------------------------------------------------------------------------
inline
CVC::ValidationCode
CLocTranslation::ValidateTranslation(
		const CValidationOptions &Options)
		const
{
	CLString str;
	
	return ValidateTranslation(Options, FALSE, str, NULL, NULL);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for the translation object.
//  
//-----------------------------------------------------------------------------
inline
const CLocTranslation &
CLocTranslation::operator=(
		const CLocTranslation &Source)	// Translation to copy from.
{
	CopyTranslation(Source);
	
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor for the translation.  Nothing interesting happens here.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::~CLocTranslation()
{
	DEBUGONLY(AssertValid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\passtrmerge.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PASSTRMERGE.H

History:

--*/

// Declaration of a class which handles the merge of two Pascal strings.
//
 
#ifndef LOCUTIL_PasStrMerge_h_INCLUDED
#define LOCUTIL_PasStrMerge_h_INCLUDED


class LTAPIENTRY CPascalStringMerge
{
public:
	static BOOL NOTHROW Merge(CPascalString &, const CPascalString &);

	static BOOL NOTHROW Merge(CPascalString & pasDestination,
			CPascalString const & pasSource, UINT const nMaxLength,
			CReport * const pReport, CLString const & strContext,
			CGoto * const pGoto = NULL);

private:
	static BOOL NOTHROW IsParagraph(const CPascalString &, const CPascalString &);

};


#endif	// #ifndef LOCUTIL_PasStrMerge_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\progress.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PROGRESS.H

History:

--*/
#ifndef _ESPUTIL_PROGRESS
#define _ESPUTIL_PROGRESS


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CProgressiveObject : virtual public CObject
{
public:
	CProgressiveObject();

	void AssertValid(void) const;
	
	virtual void SetProgressIndicator(UINT uiPercentage) = 0;
	virtual void SetDescription(HINSTANCE, DWORD);

	~CProgressiveObject();

	virtual void SetCurrentTask(CLString const & strTask) = 0;
	virtual void SetDescriptionString(CLString const & strDescription) = 0;
	
private:
	//
	// Private so nobody will use them...
	//
	CProgressiveObject(const CProgressiveObject &);
	const CProgressiveObject &operator=(const CProgressiveObject &);
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "progress.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\progress.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PROGRESS.INL

History:

--*/

inline
CProgressiveObject::CProgressiveObject()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\report.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REPORT.H

History:

--*/

//  
//  Mechanism for reporting messages and such to people.
//  

enum MessageSeverity
{
	esNote,
	esWarning,
	esError,
	esAbort
};

//
//  Basic output mechanism for Espresso 2.x.  Allows the caller to uniformly
//  report messages of various severities to the user without worrying about
//  the exact implementation or destination.
//
//  We provide ways of outputting strings, or for loading messages from string
//  tables and outputting those.
//
//  The confidence level allow the caller to tell the Reporter that messages
//  will actually provide meaningful information.  This is used (in particular)
//  in the parsers when a file has not yet ever been parsed.
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CReport  // : virtual public CObject
{
public:
	CReport();

	virtual void AssertValid(void) const;

	virtual void Activate(void);
	virtual void Clear(void);

	enum ConfidenceLevel
	{
		Low,
		High
	};
	
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL) = 0;
	
	NOTHROW static const CLString & GetErrorCodeText(MessageSeverity ms);
	
	virtual ~CReport();

private:
	//
	//  Prevent usage of copy constructor or assignment operator.
	//
	CReport(const CReport &);
	const CReport &operator=(const CReport &);

	//
	//  Text for MessageSeverities.
	//
	static CLString strSeverities[4];
	friend void GlobalInitStrings(void);
};

#pragma warning(default: 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_cancel.h ===
//-----------------------------------------------------------------------------
//
// File: _cancel.h
// Copyright (C) 1994-1998 Microsoft Corporation
// All rights reserved.
//
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__CANCEL_H
#define ESPUTIL__CANCEL_H

#pragma once

#pragma warning(disable:4275 4251)

class CCancelDialog;

class LTAPIENTRY CCancelDisplay : public CCancelableObject
{
public:
	CCancelDisplay(CWnd *pParent = NULL);

	//
	//  CCancelableObject methods.
	virtual BOOL fCancel(void) const;

	virtual void SetDescriptionString(const CLString &);
	virtual void SetCurrentTask(const CLString &);

	//
	//  CProgressiveObject methods.
	virtual void SetProgressIndicator(UINT uiPercentage);

	~CCancelDisplay();

	void SetDelay(clock_t);

	enum CancelButtonText { nCancel, nStop, COUNT_OF_ENUM };
	void SetCancelButtonText(CancelButtonText const nCancelButtonText);

	void DisplayDialog(BOOL);

protected:
	friend CCancelDialog;
	void SetCancel(BOOL);
	void ChangeCancelButtonText();

private:
	BOOL m_fCancel;
	CCancelDialog *m_pCancelDialog;
	CLString m_strDescription;
	CLString m_strTask;
	UINT m_uiLastPercentage;
	clock_t m_ctLastTime;
	clock_t m_ctDisplayTime;
	CancelButtonText m_nCancelButtonText;
	BOOL m_fDisplay;
	BOOL	m_fWaitCursor;
	SmartPtr<CInputBlocker>	m_spBlocker;

	CWnd *m_pParent;
};


#pragma warning(default:4275 4251)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_cancel.inl"
#endif

#endif // ESPUTIL__CANCEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESOURCE.H

History:

--*/
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LocUtil.rc
//
#define IDD_CANCELABLE                  12600
#define IDC_CANCEL_CURRENT              12601
#define IDC_TASK                        12602
#define IDD_PROGRESS                    12603
#define IDC_CANCEL_DESCRIPTION          12603
#define IDC_PROGDLG_PROGRESS            12604
#define IDC_OPERATION                   12606
#define IDC_PROGRESS                    12607
#define IDD_WARNINGS                    12608
#define IDC_CHK_EXCL                    12608
#define IDC_WARNINGS_EDT                12609
#define IDD_OPEN_EXCL                   12610
#define IDS_SETTINGS_INDENT             12700
#define IDS_SETTINGS_SEP                12701
#define IDS_SETTINGS_CTX                12702
#define IDS_SETTINGS_DEFAULT            12703
#define IDS_SETTINGS_USER               12704
#define IDS_SETTINGS_OVERRIDE           12705
#define IDS_TRUNCATED_TO_FIT            12706
#define IDS_AMPERSAND_NOT_ALONE         12707
#define IDS_CANT_HAVE_2HOTKEY           12708
#define IDS_AMPERSAND_NO_BLANK          12709
#define IDS_INVALID_HOTKEY_CHAR         12710
#define IDS_OUTTAB_FILE                 12712
#define IDS_OUTTAB_TEST                 12713
#define IDS_OUTTAB_GBOX                 12714
#define IDS_OUTTAB_LOCK                 12715
#define IDS_OUTTAB_UPDATE               12716
#define IDS_OUTTAB_MESSAGES             12717
#define IDS_VAL_BLANK_TARGET            12718
#define IDS_VAL_BLANK_SOURCE            12719
#define IDS_VAL_REMOVE_HK               12720
#define IDS_VAL_ADDED_HK                12721
#define IDS_VAL_LINE_COUNT              12722
#define IDS_VAL_REMOVE_ACCEL            12723
#define IDS_VAL_CHANGED_TERMINATOR      12724
#define IDS_VAL_LEADING_WHITESPACE      12725
#define IDS_VAL_LEADING_PUNCTUATION     12726
#define IDS_VAL_TRAILING_WHITESPACE     12727
#define IDS_VAL_TRAILING_PUNCTUATION    12728
#define IDS_VAL_TRANSLATION_SIZE        12729
#define IDS_VAL_HOTKEY_POSITION         12730
#define IDS_VAL_DBCS_POS                12731
#define IDS_VAL_DBCS_CHAR               12732
#define IDS_VAL_BLANK_TARGET_LONG       12733
#define IDS_VAL_BLANK_SOURCE_LONG       12734
#define IDS_VAL_REMOVE_HK_LONG          12735
#define IDS_VAL_ADDED_HK_LONG           12736
#define IDS_VAL_LINE_COUNT_LONG         12737
#define IDS_VAL_REMOVE_ACCEL_LONG       12738
#define IDS_VAL_CHANGED_TERMINATOR_LONG 12739
#define IDS_VAL_LEADING_WHITESPACE_LONG 12740
#define IDS_VAL_LEADING_PUNCTUATION_LONG 12741
#define IDS_VAL_TRAILING_WHITESPACE_LONG 12742
#define IDS_VAL_TRAILING_PUNCTUATION_LONG 12743
#define IDS_VAL_TRANSLATION_SIZE_LONG   12744
#define IDS_VAL_HOTKEY_POSITION_LONG    12745
#define IDS_VAL_DBCS_POS_LONG           12746
#define IDS_VAL_DBCS_CHAR_LONG          12747
#define IDS_VAL_REORDERABLE             12748
#define IDS_VAL_PRINTF                  12749
#define IDS_VAL_REORDERABLE_LONG        12750
#define IDS_VAL_PRINTF_LONG             12751
#define IDS_VAL_CHECK_NUL               12752
#define IDS_VAL_CHECK_NUL_LONG          12753
#define IDS_VAL_CHECK_CHARS_IN_CP       12754
#define IDS_VAL_CHECK_CHARS_IN_CP_LONG  12755
#define IDS_NOTE                        12756
#define IDS_WARNING                     12757
#define IDS_ERROR                       12758
#define IDS_ABORT                       12759
#define IDS_TOO_MANY_FILES_SELECTED     12760
#define IDS_TRUE                        12761
#define IDS_FALSE                       12762
#define IDS_OUTTAB_UTILITY              12763
#define IDS_EQ                          12764
#define IDS_NOTEQ                       12765
#define IDS_GT                          12766
#define IDS_LT                          12767
#define IDS_LTEQ                        12768
#define IDS_GTEQ                        12769
#define IDS_WITHIN                      12770
#define IDS_BEYOND                      12771
#define IDS_CONTAINS                    12772
#define IDS_EXTENSIONS                  12773
#define IDS_EXTENSIONS_HELP             12774
#define IDS_CONTAINSWORD                12775
#define IDS_CANCEL                      12776
#define IDS_STOP                        12777
#define IDS_STARTWITH                   12778
#define IDS_ENDWITH                     12779

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12611
#define _APS_NEXT_COMMAND_VALUE         12600
#define _APS_NEXT_CONTROL_VALUE         12609
#define _APS_NEXT_SYMED_VALUE           12602
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_)
#define AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include <afxtempl.h>
#include <afxole.h>

#include <mitutil.h>
#include <MitTL.h>

// Import TypeLibs before header files
#include <MitWarning.h>				// MIT Template Library warnings
#pragma warning(ZCOM_WARNING_DISABLE)
#import <TypeLibs\MitDC.tlb> named_guids, raw_method_prefix("raw_")
#pragma warning(ZCOM_WARNING_DEFAULT)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\schema.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SCHEMA.H

History:

--*/
#if !defined(LOCUTIL_Schema_h_INCLUDED)
#define LOCUTIL_Schema_h_INCLUDED

#pragma once

namespace MitDisplayColumns
{
	interface IManager;
	interface IOption;
};

class CColDefList;

//------------------------------------------------------------------------------
class LTAPIENTRY SchemaId : public _GUID
{
public:
	SchemaId();
	SchemaId(const _GUID &);
	
	void Load(CArchive &);
	void Store(CArchive &) const;
	void Serialize(CArchive &);

	const SchemaId & operator=(const SchemaId &);
	const SchemaId & operator=(const _GUID &);
	
	INT operator==(const SchemaId &);
	INT operator!=(const SchemaId &);

private:
	BOOL Compare(const SchemaId &);
};


//------------------------------------------------------------------------------
class LTAPIENTRY CTableSchema : public CRefCount
{
// Construction
public:
	CTableSchema(const SchemaId &, const CLString &, const CColDefList &);
	
// Data
protected:
	SchemaId	m_Schema;
	CLString	m_strDescription;
	CColDefList	m_lstColDefs;

// Attributes
public:
	const SchemaId & GetSchemaId() const;
	const CLString & GetDescription() const;
	const CColDefList & GetColDefList() const;

	int GetDisplayColumnCount() const;

// Operations
public:
	const CColumnDefinition * GetColumnDefinition(long nSearchID) const;
	const CColumnDefinition * GetColumnDefinition(const CLString & stSearchID) const;

// Debugging
#ifdef _DEBUG
	void AssertValid() const;
#endif
};


//------------------------------------------------------------------------------
struct LTAPIENTRY DcsHelp
{
	static void
			BuildDCOption(CTableSchema const * const pSchema, _bstr_t bstrID, 
			MitDisplayColumns::IManager * const pManager, 
			MitDisplayColumns::IOption ** ppOption = NULL);

	static void 
			BuildDCOption(CTableSchema const * const pSchema, _bstr_t bstrID, _bstr_t bstrName, 
			MitDisplayColumns::IManager * const pManager, long rgID[], int cIDs,
			MitDisplayColumns::IOption ** ppOption = NULL);
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "schema.inl"
#endif

#endif // LOCUTIL_Schema_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\showwarnings.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SHOWWARNINGS.H

History:

--*/
#if !defined(PKGUTIL__ShowWarnings_h__INCLUDED)
#define PKGUTIL__ShowWarnings_h__INCLUDED

enum eWarningFilter
{
	wfNote,
	wfWarning,
	wfError,
	wfAbort,
	wfAll
};


int LTAPIENTRY ShowWarnings(const CBufferReport * pBufMsg, LPCTSTR pszTitle = NULL,
		eWarningFilter wf = wfWarning, BOOL fShowContext = FALSE, UINT nMsgBoxFlags = MB_OK);

#endif // PKGUTIL__ShowWarnings_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\stringhelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STRINGHELP.H

History:

--*/
#if !defined(LOCUTIL__StringHelp_h__INCLUDED)
#define LOCUTIL__StringHelp_h__INCLUDED

//------------------------------------------------------------------------------
class LTAPIENTRY CStringHelp
{
// Enums
public:
	enum Mode
	{
		mDisplay,	// Use display-mode logic
		mEdit		// Use edit-mode logic
	};

// Construction
public:
	CStringHelp(Mode mode, CReport * pReport);

// Data
protected:
	Mode		m_mode;
	CReport *	m_pReport;
	int			m_cErrors;
	CLString	m_stContext;

	BOOL			m_fFirstErrorSet;
	CWnd const *	m_pwndError;		// Optional window of first error
	int				m_idxError;			// Optional index of first error

// Attributes
public:
	int GetErrorCount();
	void ResetErrorCount();
	const CLString & GetContext();
	void SetContext(const CLString & stContext);

	BOOL GetFirstError(CWnd const * & pwnd, int & idxError);

// Operations
public:
	void LoadString(const CPascalString & pasSrc, CLString & stDest);
	void LoadString(_bstr_t bstrSrc, CLString & stDest);
	void LoadString(const CPascalString & pasSrc, CEdit * pebc);
	void LoadString(_bstr_t bstrSrc, CEdit * pebc);

	BOOL SaveString(const CLString & stSrc, CPascalString & pasDest);
	BOOL SaveString(const CLString & stSrc, _bstr_t & bstrDest);
	BOOL SaveString(CEdit const * const pebc, CPascalString & pasDest);
	BOOL SaveString(CEdit const * const pebc, _bstr_t & bstrDest);

// Implementation
protected:
	void SetError(CWnd const * pwnd, int idxError);

	BOOL SaveString(const CLString & stSrc, CPascalString & pasDest, CWnd const * pwnd);
	BOOL SaveString(const CLString & stSrc, _bstr_t & bstrDest, CWnd const * pwnd);
};

#endif // LOCUTIL__StringHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\warndlg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WARNDLG.H

History:

--*/

#if !defined(LOCUTIL__WarnDlg_h__INCLUDED)
#define LOCUTIL__WarnDlg_h__INCLUDED

//------------------------------------------------------------------------------
class CWarningsDlg : public CDialog
{
// Construction
public:
	CWarningsDlg(const CBufferReport * pBufMsg, LPCTSTR pszTitle = NULL, 
			eWarningFilter wf = wfWarning, BOOL fShowContext = FALSE, 
			UINT nMsgBoxFlags = MB_OK, CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CWarningsDlg)
	enum { IDD = IDD_WARNINGS };
	CButton	m_btnYes;
	CButton	m_btnCancel;
	CButton	m_btnNo;
	CButton	m_btnOK;
	//}}AFX_DATA

// Data
protected:
	const CBufferReport *	m_pBufMsg;
	CLString				m_stTitle;
	eWarningFilter			m_wf;
	BOOL					m_fShowContext;
	UINT					m_nMsgBoxFlags;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWarningsDlg)
	public:
	virtual int DoModal();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void AddString(CEdit * pebc, const CLString & stAdd, int & len);

	// Generated message map functions
	//{{AFX_MSG(CWarningsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnYes();
	afx_msg void OnNo();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif  // LOCUTIL__WarnDlg_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\schema.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SCHEMA.INL

History:

--*/ 


inline
SchemaId::SchemaId()
	: _GUID(GUID_NULL)
{}

	

inline
SchemaId::SchemaId(
		const _GUID &guid)
	: _GUID(guid)
{}



inline
void
SchemaId::Load(
		CArchive &ar)
{
	if (ar.Read((_GUID *) this, sizeof(_GUID)) != sizeof(_GUID))
	{
		AfxThrowArchiveException(CArchiveException::endOfFile);
	}
}



inline
void
SchemaId::Store(
		CArchive &ar)
		const
{
	ar.Write((_GUID *) this, sizeof(_GUID));
}




inline
void
SchemaId::Serialize(
		CArchive &ar)
{
	if (ar.IsStoring())
	{
		Store(ar);
	}
	else
	{
		Load(ar);
	}
}



inline
const SchemaId &
SchemaId::operator=(
		const SchemaId &other)
{
	return operator=((_GUID &)other);
}



inline
const SchemaId &
SchemaId::operator=(
		const _GUID &other)
{
	(_GUID &)(*this) = other;

	return *this;
}



inline
int
SchemaId::operator==(
		const SchemaId &other)
{
	return Compare(other);
}



inline
int
SchemaId::operator!=(
		const SchemaId &other)
{
	return !Compare(other);
}



inline
BOOL
SchemaId::Compare(
		const SchemaId &other)
{
	return ((_GUID &)*this) == ((_GUID &)other);
}



inline
const SchemaId & 
CTableSchema::GetSchemaId() const
{
	return m_Schema;
}


inline
const CLString & 
CTableSchema::GetDescription() const
{
	return m_strDescription;
}


inline
const CColDefList & 
CTableSchema::GetColDefList() const
{
	return m_lstColDefs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_cancel.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _CANCEL.INL

History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_errorrep.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ERRORREP.H

History:

--*/

#if !defined(LOCUTIL__errorrep_h_INCLUDED)
#define LOCUTIL__errorrep_h_INCLUDED

////////////////////// the new global issuemessage functions.

UINT LTAPIENTRY EspMessageBox(const CLString strMessage, UINT uiType = MB_OK,
		UINT uiDefault=IDOK, UINT uiHelpContext=0);
UINT LTAPIENTRY EspMessageBox(HINSTANCE hResourceDll, UINT uiStringId,
		UINT uiType=MB_OK, UINT uiDefault=IDOK, UINT uiHelp = 0);

class CReport;

void LTAPIENTRY SetErrorReport(CReport *, BOOL fBatchMode);
void LTAPIENTRY GetErrorReport(CReport *&, BOOL &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_errorrep.inl"
#endif

#endif // LOCUTIL__errorrep_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_errorrep.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ERRORREP.INL

History:

--*/
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
UINT
EspMessageBox(
		HINSTANCE hResourceDll,
		UINT uiStringId,
		UINT uiType,
		UINT uiDefault,
		UINT uiHelp)
{
	CLString strMessage;

	strMessage.LoadString(hResourceDll, uiStringId);
	return EspMessageBox(strMessage, uiType, uiDefault, uiHelp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_extension.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _EXTENSION.H

History:

--*/

#pragma once

typedef UUID ExtensionID;
typedef UUID OperationID;

struct LTAPIENTRY LOCEXTENSIONMENU
{
	LOCEXTENSIONMENU();
	
	CLString strMenuName;				// Name of the Menu
	IID      iidProcess;				// IID for the process interface the
										// menu requires
	OperationID    idOp;				// Allows a single DLL to implement
};

typedef CArray<LOCEXTENSIONMENU, LOCEXTENSIONMENU &> CLocMenuArray;


DECLARE_INTERFACE_(ILocExtension, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;


	//
	//  ILocExtension methods
	//

	//
	//  In Initialize, extension will...
	//   Add any menus it needs to the array of menu obejcts
	//   Register any options it has with Espresso
	//   Ignore the IUnknown for now.
	STDMETHOD(Initialize)(IUnknown *) PURE;

	//
	//  Since extensions may have state, we can't use QueryInterface.
	//  This method has similar semantics, except that in most cases
	//  we expect to get a new objects.  Also, QI on a returned
	//  object doesn't have to support ILocExtension.
	STDMETHOD(GetExtension)(const OperationID &, LPVOID FAR*ppvObj) PURE;
	
	//
	//  In UnInitialize the extension will...
	//   UnRegister any of its options.
	STDMETHOD(UnInitialize)(void) PURE;
};

struct __declspec(uuid("{9F9D180E-6F38-11d0-98FD-00C04FC2C6D8}"))
		ILocExtension;

LTAPIENTRY void UUIDToString(const UUID &, CLString &);

LTAPIENTRY void RegisterExtension(const ExtensionID &,
		const TCHAR *szDescription, HINSTANCE,
		const CLocMenuArray &);
LTAPIENTRY void UnRegisterExtension(const ExtensionID &);

LTAPIENTRY BOOL RegisterExtensionOptions(CLocUIOptionSet *);
LTAPIENTRY void UnRegisterExtensionOptions(const TCHAR *szName);


//
//  Extensions need to export the following function:
//  STDAPI GetExtension(ILocExtension *&);
typedef HRESULT (STDAPICALLTYPE *PFNExtensionEntryPoint)(ILocExtension *&);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_espopts.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _ESPOPTS.H

History:

--*/

#if !defined(LOCUTIL__espopts_h_INCLUDED)
#define LOCUTIL__espopts_h_INCLUDED

LTAPIENTRY BOOL RegisterOptions(CLocUIOptionSet *);
LTAPIENTRY void UnRegisterOptions(const TCHAR *szName);
LTAPIENTRY BOOL GetOptionValue(const TCHAR *szName, CLocOptionVal *&);
LTAPIENTRY BOOL GetGroupName(const TCHAR * szName, CLString & strGroup);
LTAPIENTRY BOOL SetOptionDefault(const TCHAR *szName, const CLocVariant &);

LTAPIENTRY const CLocUIOptionSetList &  GetOptions(void);

LTAPIENTRY CLocOptionValStore *  GetOptionStore(CLocUIOption::StorageType);
LTAPIENTRY void SetOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
LTAPIENTRY void UpdateOptionValues(void);

LTAPIENTRY void SummarizeOptions(CReport *);


#pragma warning(disable : 4251) // class 'foo' needs to have dll-interface 
								// to be used by clients of class 'bar' 

class LTAPIENTRY CLocOptionManager
{
public:
	const CLocUIOptionSetList &GetOptions(void);

	CLocOptionValStore *GetOptionStore(CLocUIOption::StorageType);
	void SetOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
	BOOL RegisterOptions(CLocUIOptionSet *);
	void UnRegisterOptions(const TCHAR *szOptSetName);

	BOOL GetOptionValue(const TCHAR *szName, CLocOptionVal *&);
	BOOL GetOptionValue(const TCHAR *szGroupName, const TCHAR *szName,
			CLocOptionVal *&);
	
	void UpdateOptionValues(void);
	void SummarizeOptionValues(CReport *pReport);
	
	BOOL SetOptionDefault(const TCHAR *szName, const
			CLocVariant &varValue);
	void UpdateCurrentValue(CLocUIOption *pOption);
	BOOL GetGroupName(const TCHAR* szName, CLString& strGroup);	
protected:
	void NotifyAll(void);
	void GetCurrentValue(CLocUIOption *, CLocOptionVal *&);
	void DumpOptionSet(CLocUIOptionSet *, UINT, CReport *);
	
private:
	CLocUIOptionSetList m_osOptSetList;
	SmartRef<CLocOptionValStore> m_spUserStore;
	SmartRef<CLocOptionValStore> m_spOverrideStore;
};

#pragma warning(default : 4251)

#endif // LOCUTIL__espopts_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_interface.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _INTERFACE.H

History:

--*/
 
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_locenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _LOCENUM.H

History:

--*/

#if !defined(LOCUTIL__locenum_h_INCLUDED)
#define LOCUTIL__locenum_h_INCLUDED
 
//
//  This class is used in UI. SetSel() is used to set the initial
//	selection in the combo box
//
class LTAPIENTRY CEnumIntoComboBox: public CEnumCallback
{
public:
	CEnumIntoComboBox(CComboBox *pLB=NULL, DWORD val=0, BOOL bAbbrev=FALSE);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CComboBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
};

class LTAPIENTRY CEnumIntoListBox: public CEnumCallback
{
public:
	CEnumIntoListBox(CListBox *pLB=NULL, 
				DWORD val=0, BOOL bAbbrev=FALSE, LPCTSTR lpszPrefix=NULL);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CListBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	LPCTSTR		m_lpszPrefix;
};


class LTAPIENTRY CWEnumIntoComboBox: public CWEnumCallback
{
public:
	CWEnumIntoComboBox(CComboBox *pLB=NULL, BOOL bForEdit = TRUE, DWORD val=0, BOOL bAbbrev=FALSE);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const WEnumInfo &);

protected:
	CComboBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	BOOL		m_bForEdit;   // If this flag is true, the strings in the Combo box are displayed in Editing mode
};


class LTAPIENTRY CWEnumIntoListBox: public CWEnumCallback
{
public:
	CWEnumIntoListBox(CListBox *pLB=NULL, 
				BOOL bForEdit = TRUE, DWORD val=0, BOOL bAbbrev=FALSE, LPCTSTR lpszPrefix=NULL);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const WEnumInfo &);

protected:
	CListBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	LPCTSTR		m_lpszPrefix;
	BOOL		m_bForEdit;		// If this flag is true, the strings in the Listbox are displayed in Editing mode
};

#endif  // LOCUTIL__locenum_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_locstr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _LOCSTR.H

History:

--*/


#ifndef ESPUTIL__LOCSTR_H
#define ESPUTIL__LOCSTR_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 
class LTAPIENTRY CLocTranslationArray : public CArray<CLocTranslation, CLocTranslation &>
{
public:

protected:
	 NOTHROW void SwapElements(UINT, UINT);
};


#pragma warning(disable : 4251)	// class 'foo' needs to have dll-interface to be
							    // used by clients of class 'bar' 

class LTAPIENTRY CLocCrackedString : public CObject
{
public:
	CLocCrackedString();
			
	void AssertValid(void) const;
	
	const CLocCrackedString &operator=(const CLocCrackedString &);

	NOTHROW int operator==(const CLocCrackedString &) const;
	NOTHROW int operator!=(const CLocCrackedString &) const;

	NOTHROW void CrackLocString(const CLocString &, BOOL fAsSource);
	NOTHROW UINT GetRanking(const CLocCrackedString &) const;

	NOTHROW BOOL HasExtension(void) const;
	NOTHROW BOOL HasControl(void) const;
	NOTHROW BOOL HasHotKey() const;

	NOTHROW const CPascalString & GetBaseString(void) const;
	NOTHROW const CPascalString & GetExtension(void) const;
	NOTHROW const CPascalString & GetControl(void) const;
	NOTHROW WCHAR GetHotKeyChar(void) const;
	NOTHROW UINT GetHotKeyPos(void) const;
	NOTHROW CST::StringType GetStringType(void) const;
	
	void SetBaseString(const CPascalString &pasBaseString);
	void SetHotKey(WCHAR cHotKeyChar, UINT uiHotKeyPos);
	
	void MergeCrackedStrings(const CLocCrackedString &, LangId,
			BOOL fMergeAccel);

	NOTHROW void ConvertToLocString(CLocString &) const;

	static void SetModifiers(const CPasStringList &);
	static void SetKeyNames(const CPasStringList &);
	static WCHAR m_cKeyNameSeparator;
	
	~CLocCrackedString();

private:
	CLocCrackedString(const CLocCrackedString &);

	NOTHROW BOOL Compare(const CLocCrackedString &) const;
	NOTHROW void ClearCrackedString(void);
	NOTHROW static BOOL IsControl(const CPascalString &, BOOL fAsSource);
	NOTHROW static void TranslateControl(CPascalString &);
	void SetDefaultModifierNames();
	void SetDefaultKeyNames();
	
	NOTHROW static BOOL IsTerminator(const CPascalString &);
	static CPasStringArray m_psaModifiersSource;
	static CPasStringArray m_psaKeyNamesSource;
	static CPasStringArray m_psaModifiersTarget;
	static CPasStringArray m_psaKeyNamesTarget;
	static BOOL m_fModifiersInitialized;
	static BOOL m_fKeyNamesInitialized;
	
	CPascalString m_pstrBaseString;
	CPascalString m_pstrExtension;
	CPascalString m_pstrControl;
	WCHAR m_cControlLeader;
	WCHAR m_cHotKeyChar;
	UINT m_uiHotKeyPos;
	CST::StringType m_stStringType;
};

#pragma warning(default : 4275)
#pragma warning(default : 4251)	

LTAPIENTRY const CValidationOptions & GetValidationOptions(void);
LTAPIENTRY void SetValidationOptions(const CValidationOptions &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_locstr.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_optvalstore.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _OPTVALSTORE.H

History:

--*/

#pragma once



#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionValStore : public CRefCount, public CObject
{ public: CLocOptionValStore() {};

	void AssertValid(void) const;

	virtual CLocOptionValSet *GetOptions(const CLString &strOptionGroup)
			= 0;

	virtual BOOL RemoveOption(const CLString &strOptionGroup,
 			const CLString &strOptionName) = 0;
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLocOptionVal *);
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLString &strName, const CLocVariant &) = 0;
	virtual BOOL RemoveOptions(const CLString &strOptionGroup) = 0;

private:
	CLocOptionValStore(const CLocOptionValStore &);
	void operator=(int);
};
	

class LTAPIENTRY CLocOptionValRegStore : public CLocOptionValStore
{
public:
	CLocOptionValRegStore();

	void AssertValid(void) const;
	
	BOOL SetRegistryKeyName(const TCHAR *);

	virtual CLocOptionValSet *GetOptions(const CLString &strOptionGroup);

	virtual BOOL RemoveOption(const CLString &strOptionGroup,
			const CLString &strOptionName);
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLString &strName, const CLocVariant &);
	virtual BOOL RemoveOptions(const CLString &strOptionGroup);

	virtual ~CLocOptionValRegStore();

private:
	HKEY m_hkRegStorage;
	CLocOptionValSetList m_oslCache;

	void PurgeOptionCache(void);
};



#pragma warning(default: 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_pumpidle.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _PUMPIDLE.H

History:

--*/

#ifndef ESPUTIL__PUMPIDLE_H
#define ESPUTIL__PUMPIDLE_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CPumpAndIdle : public CObject
{
public:
	CPumpAndIdle(BOOL fDelete);
	
	virtual BOOL PumpAndIdle(long lCount) = 0;

	void Delete(void);
	
private:
	CPumpAndIdle();
	CPumpAndIdle(const CPumpAndIdle &);
	void operator=(const CPumpAndIdle &);

	BOOL m_fDelete;
};

#pragma warning(default: 4275)

class LTAPIENTRY CTimerPump : public CPumpAndIdle
{
public:
	CTimerPump(BOOL fDelete, UINT uiSeconds);

	BOOL PumpAndIdle(long lCount);

	virtual void OnTimeout(void)  = 0;
	
private:
	UINT m_uiTimeout;
	clock_t m_tLastRun;
};



void LTAPIENTRY NOTHROW AddPumpClass(CPumpAndIdle *);
BOOL LTAPIENTRY NOTHROW RemovePumpClass(CPumpAndIdle *);

BOOL LTAPIENTRY PumpAndIdle(long lCount);
void LTAPIENTRY PumpAndIdle(void);

class CProgressDialog;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CInputBlocker : public CObject
{
public:
	CInputBlocker(CWnd* pParent = NULL);

	~CInputBlocker();

private:
	CInputBlocker(const CInputBlocker &);
	void operator=(const CInputBlocker &);

	CProgressDialog *pDlg;
	
};

#pragma warning(default: 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_progress.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _PROGRESS.H

History:

--*/

#ifndef ESPUTIL__PROGRESS_H
#define ESPUTIL__PROGRESS_H

class CProgressDialog;
class CInputBlocker;

#pragma warning(disable:4251)

class LTAPIENTRY CProgressDisplay : public CProgressiveObject
{
public:
	CProgressDisplay(CWnd *pParent = NULL);

	void SetDelay(clock_t);
	void DisplayDialog(BOOL);

	void SetProgressIndicator(UINT uiPercentage);

	void SetTitle(const CLString &);
	void SetTitle(HINSTANCE, DWORD);
	~CProgressDisplay();

	virtual void SetCurrentTask(CLString const & strTask);
	virtual void SetDescriptionString(CLString const & strDescription);

private:
	CProgressDialog *m_pDialog;
	UINT m_uiLastPercentage;
	clock_t m_ctLastTime;
	clock_t         m_ctDisplayTime;
	BOOL	m_fDisplay;
	BOOL	m_fWaitCursor;
	SmartPtr<CInputBlocker>	m_spBlocker;

	CLString m_strTitle;
	CLString m_strDescription;

	CWnd *m_pParent;
};

#pragma warning(default:4251)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_locstr.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _LOCSTR.INL

History:

--*/


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Swaps two elements of the translation array.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslationArray::SwapElements(
		UINT iOne,						// First index to swap
		UINT iTwo)						// Second index to swap
{
	CLocTranslation Temp;
	
	LTASSERT(iOne <= (UINT)GetSize());
	LTASSERT(iTwo <= (UINT)GetSize());

	Temp = (*this)[iOne];
	(*this)[iOne] = (*this)[iTwo];
	(*this)[iTwo] = Temp;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for cracked strings.
//  
//-----------------------------------------------------------------------------
inline
const CLocCrackedString &
CLocCrackedString::operator=(
		const CLocCrackedString &csSource)
{
	m_pstrBaseString = csSource.m_pstrBaseString;
	m_pstrExtension = csSource.m_pstrExtension;
	m_pstrControl = csSource.m_pstrControl;
	m_cControlLeader = csSource.m_cControlLeader;
	m_cHotKeyChar = csSource.m_cHotKeyChar;
	m_uiHotKeyPos = csSource.m_uiHotKeyPos;

	return *this;
}



//-----------------------------------------------------------------------------
//  
//  Implementation for comparing two cracked strings.  Language ID and
//  string type are NOT significant!
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocCrackedString::Compare(
		const CLocCrackedString &csOther)
		const
{
	return ((m_uiHotKeyPos    == csOther.m_uiHotKeyPos) &&
			(m_cHotKeyChar    == csOther.m_cHotKeyChar) &&
			(m_pstrControl    == csOther.m_pstrControl) &&
			(m_cControlLeader == csOther.m_cControlLeader) &&
			(m_pstrExtension  == csOther.m_pstrExtension) &&
			(m_pstrBaseString == csOther.m_pstrBaseString));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparision operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocCrackedString::operator==(
		const CLocCrackedString &csOther)
		const
{
	return Compare(csOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparision operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocCrackedString::operator!=(
		const CLocCrackedString &csOther)
		const
{
	return !Compare(csOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests to see if the Cracked string has an 'extension'.  The extension
//  is a sequence of characters ("...", ">>", stc) that indicates that this
//  item leads to another UI element.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the extension is non-null.
CLocCrackedString::HasExtension(void)
		const
{
	return m_pstrExtension.GetStringLength() != 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests to see if the cracked string has a 'control' sequence.  This is
//  usually text describing a shortcut key that invokes the same action as this
//  item, for example "Ctrl + F".
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the control seq. is non-null
CLocCrackedString::HasControl(void)
		const
{
	return m_pstrControl.GetStringLength() != 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Check to see if the cracked string has a hot-key.  This come directly out
//  of the CLocString that was parsed into the Cracked String.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the string has a hot-key.
CLocCrackedString::HasHotKey(void)
		const
{
	return (m_cHotKeyChar != 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the 'base string'.  This is the original string stripped of
//  extension and control sequences, and of the hot-key.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Base string.
CLocCrackedString::GetBaseString(void)
		const
{
	return m_pstrBaseString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the extension component of the string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocCrackedString::GetExtension(void)
		const
{
	return m_pstrExtension;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the constol sequence of the string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocCrackedString::GetControl(void)
		const
{
	return m_pstrControl;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key character for the string.
//  
//-----------------------------------------------------------------------------
inline
WCHAR
CLocCrackedString::GetHotKeyChar(void)
		const
{
	LTASSERT(HasHotKey());
	
	return m_cHotKeyChar;
}



inline
UINT
CLocCrackedString::GetHotKeyPos(void)
		const
{
	LTASSERT(HasHotKey());
	
	return m_uiHotKeyPos;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the string type for the string.
//  
//-----------------------------------------------------------------------------
inline
CST::StringType
CLocCrackedString::GetStringType(void)
		const
{
	return m_stStringType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Cleans out all the components of the cracked string.
//  
//-----------------------------------------------------------------------------
inline
void
CLocCrackedString::ClearCrackedString(void)
{
	m_pstrBaseString.ClearString();
	m_pstrExtension.ClearString();
	m_pstrControl.ClearString();
	m_cControlLeader = L'\0';
	m_cHotKeyChar = L'\0';
	m_uiHotKeyPos = 0;
	m_stStringType = CST::None;
}



inline
void
CLocCrackedString::SetBaseString(
		const CPascalString &pasBase)
{
	m_pstrBaseString = pasBase;
}



inline
void
CLocCrackedString::SetHotKey(
		WCHAR cHotKeyChar,
		UINT uiHotKeyPos)
{
	m_cHotKeyChar = cHotKeyChar;
	m_uiHotKeyPos = uiHotKeyPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_report.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _REPORT.H

History:

--*/
 
#ifndef LOCUTIL_REPORT_H
#define LOCUTIL_REPORT_H

#pragma once

//
//  Throws away ALL messages.
//
class LTAPIENTRY CNullReport : public CReport
{
public:
	CNullReport() {};
	
	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

};


//
//  This stuff is used for an implementation of CReport that will
//  'buffer' messages.  Use CBufferReporter if you don't want to
//  process messages until after the process producing them is done.
//  You can get the messages either by severity, or as a list of all
//  messages as they were issued.
//
struct ReportMessage
{
	MessageSeverity sev;
	CLString strContext;
	CLString strMessage;
	SmartRef<CGoto> spGoto;
	SmartRef<CGotoHelp> spGotoHelp;
};


typedef CTypedPtrList<CPtrList, ReportMessage *> MessageList;

#pragma warning (disable:4251)

class LTAPIENTRY CBufferReport : public CReport
{
public:
	CBufferReport();

	void AssertValid(void) const;
	

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Clear(void);

	NOTHROW const MessageList & GetNotes(void) const;
	NOTHROW const MessageList & GetWarnings(void) const;
	NOTHROW const MessageList & GetErrors(void) const;
	NOTHROW const MessageList & GetAborts(void) const;

	NOTHROW const MessageList & GetMessages(void) const;
	void DumpTo(CReport *) const;
	
	~CBufferReport();

private:

	MessageList m_mlNotes;
	MessageList m_mlWarnings;
	MessageList m_mlErrors;
	MessageList m_mlAborts;

	mutable MessageList m_mlMessages;
};


//
//  This reporter just send all its messages directly to a message box.
//
class LTAPIENTRY CMessageBoxReport : public CReport
{
public:
	CMessageBoxReport();

	void AssertValid(void) const;

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CMessageBoxReport();

private:
	
};



//
//  This reporter is used to send all messages to a file.
//
class LTAPIENTRY CFileReport : public CReport
{
public:
	CFileReport();

	BOOL InitFileReport(const CLString &strFileName);

	virtual void Clear(void);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CFileReport();

private:

	CFile m_OutputFile;
};

//
//  This reporter is used for command line utilities.  Output goes to stdout
//
class LTAPIENTRY CStdOutReport : public CReport
{
public:

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	virtual void SetConfidenceLevel(ConfidenceLevel);

private:
	BOOL m_fEnabled;
};


//
//  This is used to 'redirect' messages to a single reporter.  It's used
//  when several different reporters are required by the current
//  implementation, but the desired effect is that they all send their messages
//  to a common location.
//
//  This class takes ownership of another Reporter, then uses reference
//  counting semantics to determine when to delete that reporter.
//
class LTAPIENTRY CRedirectReport : public CReport
{
public:
	CRedirectReport();

	virtual void Activate(void);
	virtual void Clear(void);
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	//  Used for initial attachment to a CReporter.
	NOTHROW void RedirectTo(CReport *pReport);

	//  Used to share a single reporter among several CRedirectReporter's.
	NOTHROW void RedirectTo(CRedirectReport *pReport);
	
	~CRedirectReport();

private:
	struct RedirectInfo
	{
		SmartPtr<CReport> pReport;
		UINT uiRefCount;
	};

	RedirectInfo *m_pRedirectInfo;
	void NOTHROW Detach(void);
};


//
//  
//  This class is used to re-direct output through a reporter.  It will
//  automatically call Clear() and Activate() the first time output is sent
//  to the reporter.  If the usre calls Activate first on this reporter, then
//  no action is taken when something is output.
//  
//
class LTAPIENTRY CActivateReport : public CReport
{
public:
	CActivateReport(CReport *);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Activate();
	void Clear();

private:
	BOOL m_fActivated;
	CReport *m_pReport;
};



//
//  The following manage a global 'pool' of reporters that are used by
//  different components in the system.
//  Each reporter has to be distinct.  Once the reporter has been 'added',
//  the global pool *owns* the reporter and will delete it.  This is done by
//  ReleaseAllReporters().
//
NOTHROW LTAPIENTRY void AddReport(COutputTabs::OutputTabs idx, CReport *pReport);
NOTHROW LTAPIENTRY CReport * GetReport(COutputTabs::OutputTabs);
NOTHROW LTAPIENTRY void ReleaseAllReports();

#include "_report.inl"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_username.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _USERNAME.H

History:

--*/

#ifndef ESPUTIL__USERNAME_H
#define ESPUTIL__USERNAME_H

LTAPIENTRY const NOTHROW CPascalString &GetCurrentUserName();
LTAPIENTRY void NOTHROW SetUserName(const CPascalString &);
LTAPIENTRY void NOTHROW ResetUserName(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil\_report.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    _REPORT.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Note' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetNotes(void)
		const
{
	return m_mlNotes;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Warning' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetWarnings(void)
		const
{
	return m_mlWarnings;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Error' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetErrors(void)
		const
{
	return m_mlErrors;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Abort' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetAborts(void)
		const
{
	return m_mlAborts;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns ALL the messages issued to the CBufferReport.  The messages
//  are stored in chronological order.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetMessages(void)
		const
{
	return m_mlMessages;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\buildnum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BUILDNUM.H

History:

--*/

#pragma once

#include "prodver\prodver.h"

#define stringize2(x) #x
#define stringize(x) stringize2(x)
#define frmj rmj
#define frmm rmm
#define frup rup
#define prmj rmj
#define prmm rmm
#define prup rup

#define RELEASE 

#if defined(_DEBUG)
#define ProdVerString stringize(prmj.prmm.prup (Debug) RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup (Debug) RELEASE\0)
#else
#define ProdVerString stringize(prmj.prmm.prup RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup RELEASE\0)
#endif

//
//  Common version information
//
#define CompanyNameString "Microsoft Corporation\0"
#define CopyrightString "Copyright \251 1994-1998 Microsoft Corp.\0"
// copyright for command line tools
#define CopyrightStringCMD "Copyright (C) 1994-1998 Microsoft Corp. All rights reserved.\0"
#define ProductNameString "Microsoft Localization Studio\0"
#define TrademarkString  \
"Microsoft is a registered trademark of Microsoft Corporation. \
Windows(TM) is a trademark of Microsoft Corporation.\0"

#define TIMESTAMP stringize(__TIME__\0)
#define DATESTAMP stringize(__DATE__\0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\ltapi.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LTAPI.H

History:

--*/


#ifdef LTAPIENTRY
#undef LTAPIENTRY
#endif

#ifdef IMPLEMENT
#define LTAPIENTRY __declspec(dllexport)

#else  // IMPLEMENT
#define LTAPIENTRY __declspec(dllimport)

#endif // IMPLEMENT


#ifndef LTAPI_H
#define LTAPI_H
//
//  Allow the use of C++ reference types and const methods, without
//  breaking the 'C' world.
//
#ifdef __cplusplus
#define REFERENCE &
#define CONST_METHOD const
#else
#define REFERENCE *
#define CONST_METHOD
#endif

#include <MitThrow.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mitwarning.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITWARNING.H

History:

--*/

#if !defined(MIT_MitWarning)
#define MIT_MitWarning

#define ZCOM_WARNING_DISABLE disable: 473 454 4100 4244 4310 4505 4510 4610
#define ZCOM_WARNING_DEFAULT default: 473 454 4100 4244 4310 4505 4510 4610

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mitthrow.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITTHROW.H

History:

--*/


#if !defined(MIT_MitThrow)
#define MIT_MitThrow

#if !defined(NO_NOTHROW)

#if !defined(NOTHROW)
#define NOTHROW __declspec(nothrow)
#endif

#else

#if defined(NOTHROW)
#undef NOTHROW
#endif

#define NOTHROW

#endif

#endif // MIT_MitThrow
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mitui.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITUI.H

History:

--*/


#pragma once

#pragma comment(lib, "MITUI.LIB")

#include "..\mitui\bumpbox.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mitctrl.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITCTRL.H

History:

--*/

#include "..\mitctrl\mitctrllib.h"

#ifndef MIT_MITCTRL_H
#define MIT_MITCTRL_H

//TODO get this from some other place
const	eventidSelChanged = 1L;
const	eventidCheckStateChange = 2L;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\precenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PRECENUM.H

History:

--*/

#undef BEGIN_ENUM
#define BEGIN_ENUM(name) \
	enum name \
	{

#undef ENUM_ENTRY
#define ENUM_ENTRY(typelib, name) \
	name,

#undef ENUM_ENTRY_
#define ENUM_ENTRY_(typelib, name, number) \
	name = number,

#undef MARK_ENTRY
#define MARK_ENTRY(name, enumconst) \
	name = enumconst,

#undef END_ENUM
#define END_ENUM(name) \
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mittl.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITTL.H

History:

--*/

#if !defined(MIT_TL_INCLUDED)
#define MIT_TL_INCLUDED

// General helpers

#include "..\MitTL\ComHelp.h"

#if defined(__ATLCOM_H__)			// Include ATL helpers if ATL is defined
	#include "..\MitTL\AtlComHelp.h"
#endif

#include "..\MitTL\MapHelp.h"

#include "MitThrow.h"
#include "..\MitTL\SmartPtr.h"

// Shared objects

#if defined(MitTL_UseDispIDCache)
	#include "..\MitTL\DispIDCache.h"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\premidlenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PREMIDLENUM.H

History:

--*/

#undef BEGIN_ENUM
#define BEGIN_ENUM(name) \
	typedef enum \
	{

#undef ENUM_ENTRY
#define ENUM_ENTRY(typelib, name) \
	typelib##name,

#undef ENUM_ENTRY_
#define ENUM_ENTRY_(typelib, name, number) \
	typelib##name = number,

#undef MARK_ENTRY
#define MARK_ENTRY(name, enumconst)

#undef END_ENUM
#define END_ENUM(name) \
	} name;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mitdiff.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITDIFF.H

History:

--*/

#ifndef _MITDIFF_H
#define _MITDIFF_H


#ifdef MITDIFF
#define MITDIFFAPI __declspec(dllexport)
#else
#define MITDIFFAPI __declspec(dllimport)
#endif


//------------------------------------------------------------------------------
//
//	Support routines
//
//------------------------------------------------------------------------------

// Rotating hash from DDJ Sept. 97
inline unsigned
_HashString (const wchar_t *pwch, int cwch)
{
	int h = cwch;
	while (cwch--)
	{
		h = (h << 5) ^ (h >> 27) ^ *pwch++;
	}
	return h;
}


//------------------------------------------------------------------------------
//
//	Define the data types we want to diff
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Encapsulates a _bstr_t
class CBStr
{
public:
	CBStr () { }

	operator unsigned () const;								// Hash
	bool operator== (const CBStr& rhs) const;				// Compare

	_bstr_t m_bstr;
};

inline
CBStr::operator unsigned () const
{
	return _HashString (m_bstr, wcslen (m_bstr));
}

inline bool
CBStr::operator== (const CBStr& rhs) const
{
	return wcscmp (m_bstr, rhs.m_bstr) == 0;
}


//------------------------------------------------------------------------------
// Word (not zero-terminated) including word-class
class CWord
{
public:
	CWord () { }

	operator unsigned () const;								// Hash
	bool operator== (const CWord& rhs) const;				// Compare

	const wchar_t *m_pwchWord;
	int m_cwchWord;

	enum wordclass
	{
		wcWORD, wcSPACE, wcMIXED
	};
	wordclass m_wc;
};

inline
CWord::operator unsigned () const
{
	return _HashString (m_pwchWord, m_cwchWord);
}

inline bool
CWord::operator== (const CWord& rhs) const
{
	return m_wc == rhs.m_wc &&
			m_cwchWord == rhs.m_cwchWord &&
			memcmp (m_pwchWord, rhs.m_pwchWord, m_cwchWord * sizeof (wchar_t)) == 0;
}


//------------------------------------------------------------------------------
// Zero-terminated string + custom data
class CCustomString
{
public:
	CCustomString () { }

	operator unsigned () const;								// Hash
	bool operator== (const CCustomString& rhs) const;		// Compare

	const wchar_t *m_pwsz;
	DWORD m_custdata;
};

inline
CCustomString::operator unsigned () const
{
	return _HashString (m_pwsz, wcslen (m_pwsz));
}

inline bool
CCustomString::operator== (const CCustomString& rhs) const
{
	return m_custdata == rhs.m_custdata &&
			wcscmp (m_pwsz, rhs.m_pwsz) == 0;
}


//------------------------------------------------------------------------------
// Binary data block of size 16
class CBlob16
{
public:
	operator unsigned () const;								// Hash
	bool operator== (const CBlob16& rhs) const;				// Compare

	BYTE m_data[16];
};

inline
CBlob16::operator unsigned () const
{
	return _HashString ((const wchar_t *) m_data, 8);
}

inline bool
CBlob16::operator== (const CBlob16& rhs) const
{
	return memcmp (m_data, rhs.m_data, 16) == 0;
}


//------------------------------------------------------------------------------
//
//	Class holding diff result
//
//------------------------------------------------------------------------------

class CDiffResult
{
public:
	CByteArray m_abChanges1;
	CByteArray m_abChanges2;
	int m_iNumAdditions;
	int m_iNumDeletions;
	int m_iNumSubstitutions;
};


//------------------------------------------------------------------------------
//
//	Exported functions
//
//------------------------------------------------------------------------------

// Diff arrays of CBStr
void MITDIFFAPI Diff (
		const CBStr *aElems1,
		int iNumElems1,
		const CBStr *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CWord
void MITDIFFAPI Diff (
		const CWord *aElems1,
		int iNumElems1,
		const CWord *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CCustomString
void MITDIFFAPI Diff (
		const CCustomString *aElems1,
		int iNumElems1,
		const CCustomString *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CBlob16
void MITDIFFAPI Diff (
		const CBlob16 *aElems1,
		int iNumElems1,
		const CBlob16 *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of wchar_t (no class definition needed)
void MITDIFFAPI Diff (
		const wchar_t *aElems1,
		int iNumElems1,
		const wchar_t *aElems2,
		int iNumElems2,
		CDiffResult *result);


#endif	// !_MITDIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\mitutil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITUTIL.H

History:

--*/


#pragma once

#ifndef IMPLEMENT
#pragma comment(lib, "mitutil.lib")
#endif

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#ifdef __cplusplus


#ifndef __AFXTEMPL_H__
#include <afxtempl.h>
#pragma message("Warning: <afxtempl.h> not in pre-compiled header file, including")
#endif

#ifndef _OLE2_H_
#include <ole2.h>
#pragma message("Warning: <ole2.h> not in pre-compiled header file, including")
#endif

#include <ltapi.h>						// Provide interface definitions
#include "..\mitutil\macros.h"
#include "..\mitutil\ltdebug.h"					//  Espresso debugging facilities
#ifndef MIT_NO_DEBUG
#include "..\mitutil\stacktrace.h"
#include "..\mitutil\counter.h"
#endif

#ifndef MIT_NO_IMAGEHLP
#include <imagehlp.h>
#include "..\mitutil\imagehelp.h"	 	//	Helper class for imagehlp.dll
#endif

#include "..\mitutil\refcount.h"


#ifndef MIT_NO_SMART
#include "..\mitutil\smartptr.h"
#include "..\mitutil\smartref.h"
#endif


#ifndef MIT_NO_STRING
#include "..\mitutil\counter.h"
#include "..\mitutil\clstring.h"		//  Wrapper for CString
#include "..\mitutil\mitenum.h"
#include "..\mitutil\espnls.h"			//  Language Supportxo
#include "..\mitutil\cowblob.h"			//  Copy-on-write Blob class
#include "..\mitutil\passtr.h"			//  Pascal style (counted) strings
#include "..\mitutil\StringBlast.h"
#include "..\mitutil\strlist.h"
#include "..\mitutil\stringtokenizer.h"
#endif

#ifndef MIT_NO_FILE
#include "..\mitutil\loadlib.h"	        //  Wrapper for LoadLibrary
#include "..\mitutil\blobfile.h"
#include "..\mitutil\path.h"
#endif

#ifndef MIT_NO_OPTIONS
#include "..\mitutil\smartref.h"
#include "..\mitutil\locid.h"			//  Espresso ID's
#include "..\mitutil\locvar.h"			//  Variant type for CBinary
#include "..\mitutil\optionval.h"
#include "..\mitutil\optvalset.h"
#include "..\mitutil\uioptions.h"
#include "..\mitutil\uioptset.h"
#include "..\mitutil\uiopthelp.h"
#endif

#ifndef MIT_NO_MISC
#include "..\mitutil\flushmem.h"
#include "..\MitUtil\RegHelp.h"			// Registry helpers
#include "..\MitUtil\EditHelp.h"
#endif

#ifndef MIT_NO_DIFF
#include "..\mitutil\redvisit.h"
#include "..\mitutil\gnudiffalg.h"
#endif

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\inc\profile.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PROFILE.H

History:

--*/


#include "icecap\icapexp.h"

// Marks for profiling

// Note: numbers must be > 1000 

const long MARK_GRIDONPAINT1 = 1001;
const long MARK_GRIDONPAINT2 = 1002;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\blobfile.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BLOBFILE.H

History:

--*/

#ifndef ESPUTIL_BLOBFILE_H
#define ESPUTIL_BLOBFILE_H


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Class CBlobFile is similar to CMemFile, except that it is implemented 
//	with a CLocCOWBlob
//------------------------------------------------------------------------------
//
//  The compiler worries when you export a class that has a base class
//  that is not exported.  Since I *know* that CFile is exported
//  tell the compliler that this really isn't a problem right here.
//
#pragma warning(disable : 4275)

class LTAPIENTRY CBlobFile : public CFile
{
	DECLARE_DYNAMIC(CBlobFile)

public:
	// Constructor
	CBlobFile(UINT nGrowBytes = 0);
	CBlobFile(const CLocCOWBlob &, UINT nGrowBytes = 0);
	
	virtual ~CBlobFile();

	virtual void AssertValid() const;
	UINT GetBlobSize(void) const;

	virtual DWORD GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual DWORD GetLength() const;
	virtual void SetLength(DWORD dwNewLen);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);

	//
	//  These operators can't work on const objects, since they
	//  'fix up' the blob size.
	//
	operator const CLocCOWBlob &(void);
	const CLocCOWBlob &GetBlob(void);
	
	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);

protected:
	// Advanced Overridables
	virtual BYTE* Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource, UINT nBytes);
	virtual void GrowFile(DWORD dwNewLen);

protected:
	// Implementation
	UINT m_nGrowBytes;	//unit of growth of 'm_blobData'
	const UINT cm_nDefaultGrowth; //default unit of growth
	DWORD m_nPosition;	//current position within file
	DWORD m_nFileSize;	//actual number of bytes written to the file
	CLocCOWBlob m_blobData; //file data
	BYTE * m_pBuffer;		//pointer to buffer in blob

};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "blobfile.inl"
#endif

#endif  //  BLOBFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\blobfile.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BLOBFILE.INL

History:

--*/

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Gets the position with in the file. The position can be set (by calling
//	'Seek()') beyond the end of the data in the file, even beyond the space 
//	allocated for the file. In any case, 'Read()' and 'Write()' will deal with
//	that.
//------------------------------------------------------------------------------
inline
DWORD	//Returns current file position 
CBlobFile::GetPosition() const
{
	ASSERT_VALID(this);
	return m_nPosition;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Gets the actual data size in the file, which is what determines the end
//	of file during readings.
//------------------------------------------------------------------------------
inline
DWORD	//Returns the file data length in bytes.
CBlobFile::GetLength() const
{
	ASSERT_VALID(this);
	return m_nFileSize; 
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Since we keep the file in memory always, we don't need to flush.
//------------------------------------------------------------------------------
inline
void CBlobFile::Flush()
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Aborting is like closing.
//------------------------------------------------------------------------------
inline
void CBlobFile::Abort()
{
	ASSERT_VALID(this);

	Close();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline
void CBlobFile::LockRange(DWORD /* dwPos */, DWORD /* dwCount */)
{
	AfxThrowNotSupportedException();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline 
void CBlobFile::UnlockRange(DWORD /* dwPos */, DWORD /* dwCount */)
{
	AfxThrowNotSupportedException();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline
CFile* CBlobFile::Duplicate() const
{
	AfxThrowNotSupportedException();
	return NULL;
}

inline
UINT CBlobFile::GetBlobSize(void) const
{
	ASSERT_VALID(this);
	return m_blobData.GetBlobSize();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	That's the only way to that a caller can have access to the buffer data
//	of the blobfile's internal cowblob.	  
//  
//-----------------------------------------------------------------------------
inline
CBlobFile::operator const CLocCOWBlob &(void)
{
	return GetBlob();
}

inline
const CLocCOWBlob &
CBlobFile::GetBlob(void)
{
 	if (m_pBuffer != NULL)
	{
		m_blobData.ReleasePointer();
		m_pBuffer = NULL;
	}
	//Set correct requested cowblob size before giving access to the data.
	m_blobData.ReallocBlob(m_nFileSize);
	return m_blobData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\counter.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    COUNTER.H

History:

--*/

#ifndef ESPUTIL_COUNTER_H
#define ESPUTIL_COUNTER_H


class LTAPIENTRY CCounter
{
public:
	CCounter(const TCHAR *);
	
	UINT operator++(void);
	UINT operator--(void);
	void operator+=(UINT);
	void operator-=(UINT);
	
	void Dump(void) const;
	
	~CCounter();
	
private:
	UINT m_uiCurCount;
	UINT m_uiMaxCount;
	UINT m_uiTotal;
	
	const TCHAR *m_szDescription;
};


//------------------------------------------------------------------------------
class LTAPIENTRY CSmartCheck
{
public:
	CSmartCheck(DWORD dwFreqMilli = 2000);

	void Reset();
	BOOL Check();

protected:
	DWORD	m_dwFreqMilli;
	DWORD	m_dwCancelTickMin;	// prevents calling fCancel() too often
	DWORD	m_dwCancelTickMax;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\clstring.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CLSTRING.H

History:

--*/


#ifndef CLSTRING_H
#define CLSTRING_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLString : public CString
{
public:
	CLString();
	CLString(const CLString& stringSrc);
	CLString(TCHAR ch, int nRepeat = 1);
	CLString(LPCSTR lpsz);
	CLString(LPCTSTR lpch, int nLength);
	CLString(const unsigned char* psz);
	CLString(HINSTANCE, UINT);
	
	BOOL ReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace, BOOL bMatchCase);

	// overloaded assignment
	NOTHROW const CLString& operator=(const CString& stringSrc);
	
	NOTHROW const CLString& operator=(TCHAR ch);
#ifdef _UNICODE
	NOTHROW const CLString& operator=(char ch);
#endif
	NOTHROW const CLString& operator=(LPCSTR lpsz);
	NOTHROW const CLString& operator=(const unsigned char* psz);

	// string concatenation
	NOTHROW const CLString& operator+=(const CString &);
	NOTHROW const CLString& operator+=(TCHAR ch);
#ifdef _UNICODE
	NOTHROW const CLString& operator+=(char ch);
#endif
	NOTHROW const CLString& operator+=(LPCTSTR lpsz);

	CLString operator+(const CString &) const;
	CLString operator+(LPCTSTR sz) const;

	NOTHROW BOOL LoadString(HMODULE, UINT nId);

	//
	//  The following were copied from CString so we can
	//  'overload' them.

	NOTHROW void Format(LPCTSTR lpszFormat, ...);
	NOTHROW void Format(HMODULE, UINT nFormatID, ...);

	enum ECRLF
	{
		eNone	= 0,
		eCR		= 0x0001,		// '\r'
		eLF		= 0x0002,		// '\n'
		eAll	= eCR | eLF
	};
	void FixCRLF(UINT nCRLF, LPCTSTR pszIndent = NULL);

	DEBUGONLY(~CLString());
protected:

private:
	DEBUGONLY(static CCounter m_UsageCounter);

	//
	//  Evil!  Implicit Unicode conversions!
	CLString(LPCWSTR lpsz);
	NOTHROW const CLString& operator=(LPCWSTR lpsz);
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "clstring.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\clstring.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CLSTRING.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All these methods re-direct to the CString methods.
//  
//-----------------------------------------------------------------------------
inline
CLString::CLString()
		:
		CString()
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		const CLString &stringSrc)
		:
		CString(stringSrc)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		TCHAR ch,
		int nRepeat)
		:
		CString(ch, nRepeat)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		LPCSTR lpsz)
		:
		CString(lpsz)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		LPCTSTR lpch,
		int nLength)
		:
		CString(lpch, nLength)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		const unsigned char * psz)
		:
		CString(psz)
{
	DEBUGONLY(++m_UsageCounter);
}



inline
CLString::CLString(
		HINSTANCE hDll,
		UINT uiStringID)
{
	LTVERIFY(LoadString(hDll, uiStringID));
	DEBUGONLY(++m_UsageCounter);
}



inline 
const CLString &
CLString::operator=(
		const CString& stringSrc)
{
	CString::operator=(stringSrc);

	return *this;
}

inline
const CLString &
CLString::operator=(
		TCHAR ch)
{
	CString::operator=(ch);

	return *this;
}


#ifdef _UNICODE

inline
const CLString &
CLString::operator=(
		char ch)
{
	CString::operator=(ch);

	return *this;
}

#endif //  _UNICODE

inline
const CLString &
CLString::operator=(
		LPCSTR lpsz)
{
	CString::operator=(lpsz);

	return *this;
}

inline
const CLString &
CLString::operator=(
		const unsigned char * psz)
{
	CString::operator=(psz);

	return *this;
}

inline
const CLString &
CLString::operator+=(
		const CString & string)
{
	CString::operator+=(string);

	return *this;
}



inline 
const CLString &
CLString::operator+=(
		TCHAR ch)
{
	CString::operator+=(ch);

	return *this;
}

		

#ifdef _UNICODE

inline
const CLString &
CLString::operator+=(
		char ch)
{
	CString::operator+=(ch);

	return *this;
}

#endif  // _UNICODE

inline
const CLString &
CLString::operator+=(
		LPCTSTR lpsz)
{
	CString::operator+=(lpsz);

	return *this;
}


inline
CLString
CLString::operator+(
		const CString &str)
		const
{
	return CLString(*this)+=str;
}



inline
CLString
CLString::operator+(
		const TCHAR *sz)
		const
{
	return CLString(*this)+=sz;
}



inline
void
CLString::Format(
		LPCTSTR lpszFormat, ...)
{

	//
	//  This stolen from CString::Format()
	//
	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
	
}

inline
void
CLString::Format(
		HMODULE hResourceModule,
		UINT nFormatID, ...)
{
	CLString strFormat;
	strFormat.LoadString(hResourceModule, nFormatID);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}


#ifdef _DEBUG
inline
CLString::~CLString()
{
	DEBUGONLY(--m_UsageCounter);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\cowblob.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    COWBLOB.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the blob.  Set the current size to zero.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::CLocCOWBlob()
{
	m_pBuffer = NULL;
	m_WriteCount = 0;

	m_uiGrowSize = m_uiDefaultGrowSize;

	DEBUGONLY(++m_UsageCounter);
}




#ifdef LTASSERT_ACTIVE
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the number of outstanding GetPointer()'s there are.
//  DEBUGONLY method!
//
//-----------------------------------------------------------------------------
inline
UINT
CLocCOWBlob::GetWriteCount(void)
		const
{
	return m_WriteCount;
}

#endif // _DEBUG



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the granularity for memory allocations.  Memory will always be
//  allocated in amounts that are a multiple of the GrowSize.  This can be
//  useful if you are making small incremental reallocs - by setting a larger
//  grow size, you will allocate memory less often (but some may end up
//  being unused).
//  
//-----------------------------------------------------------------------------
inline
void
CLocCOWBlob::SetGrowSize(
		UINT uiGrowSize)
{
	LTASSERT(uiGrowSize != 0);
	
	if (uiGrowSize == 0)
	{
		m_uiGrowSize = m_uiDefaultGrowSize;
	}
	else
	{
		m_uiGrowSize = uiGrowSize;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Release a writable pointer.  GetPointer and ReleasePointer should be
//  paired.
//  
//-----------------------------------------------------------------------------
inline
void
CLocCOWBlob::ReleasePointer(void)
{
	LTASSERT(m_WriteCount != 0);

	if (m_WriteCount != 0)
	{
		m_WriteCount--;
	}
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return a read only pointer to storage.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::operator const void *(void)
		const
{
	return DataPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor.  Just detaches this blob from the user memory.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::~CLocCOWBlob()
{
	DEBUGONLY(CLocCOWBlob::AssertValid());
	
	Detach();

	DEBUGONLY(--m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the data of this blob NOT equal to the data in the given blob?
//
//-----------------------------------------------------------------------------
inline
int										//TRUE if both blobs are NOT identical
CLocCOWBlob::operator!=(
		const CLocCOWBlob & SourceBlob)
		const
{
	return !Compare(SourceBlob);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the data of this blob IS equal to the data in the given blob?
//
//-----------------------------------------------------------------------------
inline
int										//TRUE if both blobs ARE identical
CLocCOWBlob::operator==(
		const CLocCOWBlob & SourceBlob)
		const
{
	return Compare(SourceBlob);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\cowblob.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    COWBLOB.H

History:

--*/

#ifndef COWBLOB_H
#define COWBLOB_H


class LTAPIENTRY CLocCOWBlob 
{
public:
	CLocCOWBlob();
	CLocCOWBlob(const CLocCOWBlob &);

	void AssertValid(void) const;

	LTASSERTONLY(UINT GetWriteCount(void) const);
	
	UINT GetBlobSize(void) const;
	void SetBlobSize(UINT);
	void ReallocBlob(UINT);
	void SetGrowSize(UINT);
	
	void *GetPointer(void);
	void ReleasePointer(void);
	void SetBuffer(const void *, size_t);
	
	operator const void *(void) const;

	const CLocCOWBlob &operator=(const CLocCOWBlob &);
	void Serialize(CArchive &ar);
	void Load(CArchive &ar);
	void Store(CArchive &ar) const;
	
	~CLocCOWBlob();

	//  Comparison operators
	//
	NOTHROW int operator==(const CLocCOWBlob &) const;
	NOTHROW int operator!=(const CLocCOWBlob &) const;

protected:

private:
	typedef struct
	{
		DWORD RefCount;
		DWORD AllocSize;
		DWORD RequestedSize;
	} BlobHeader;

	NOTHROW void Attach(const CLocCOWBlob &);
	NOTHROW void Detach(void);
	NOTHROW void MakeWritable(void);
	NOTHROW BYTE * DataPointer(void) const;
	NOTHROW BlobHeader * GetBlobHeader(void);
	NOTHROW const BlobHeader * GetBlobHeader(void) const;
	NOTHROW DWORD & GetRefCount(void);
	NOTHROW DWORD GetAllocatedSize(void) const;
	NOTHROW DWORD GetRequestedSize(void) const;
	NOTHROW DWORD CalcNewSize(DWORD) const;
	BOOL Compare(const CLocCOWBlob &) const;
	
	BYTE *m_pBuffer;
	DWORD m_WriteCount;
	UINT m_uiGrowSize;
	static const UINT m_uiDefaultGrowSize;

#ifdef _DEBUG
	static CCounter m_UsageCounter;
	void FillEndZone(void);
	void CheckEndZone();
#endif
	
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "cowblob.inl"
#endif

#endif // COWBLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\dllvars.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DLLVARS.H

History:

--*/
 
#pragma once

extern HINSTANCE g_hMITUtilDll;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\edithelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    EDITHELP.H

History:

--*/

#if !defined(MITUTIL__EditHelp_h__INCLUDED)
#define MITUTIL__EditHelp_h__INCLUDED

//------------------------------------------------------------------------------
struct LTAPIENTRY EditHelp
{
	static BOOL SetTopLine(CEdit * pebc, int iLine);

	static BOOL CanUndo(CEdit * pebc);
	static BOOL CanRedo(CEdit * pebc);
	static BOOL CanCut(CEdit * pebc);
	static BOOL CanClear(CEdit * pebc);
	static BOOL CanPaste(CEdit * pebc);
	static BOOL CanCopy(CEdit * pebc);
	static BOOL CanSelectAll(CEdit * pebc);

	static BOOL Undo(CEdit * pebc);
	static BOOL Redo(CEdit * pebc);
	static void Cut(CEdit * pebc);
	static void Copy(CEdit * pebc);
	static void Clear(CEdit * pebc);
	static void Paste(CEdit * pebc);
	static void SelectAll(CEdit * pebc);
	
	static BOOL IsReadOnly(CEdit * pebc);
	static BOOL IsEnabled(CEdit * pebc, UINT nCmdID);

	static BOOL DoEditCmd(CEdit * pebc, UINT nCmdID);
};

#endif // MITUTIL__EditHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\diff.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DIFF.INL

History:

--*/

inline
CDifference::~CDifference()
{
}

inline
CDelta::~CDelta()
{
}

inline
CDiffAlgorithm::~CDiffAlgorithm()
{
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Calculates the delta following the given algorithm and then traverses
//	the delta and calls back the delta visitor for each difference in the delta.
//------------------------------------------------------------------------------
inline
void 
CDiffEngine::Diff(
	CDiffAlgorithm & diffalg, 
	const wchar_t * seq1, // [in] old sequence
	const wchar_t * seq2, // [in] new sequence
	const CDeltaVisitor & dv)
{
	CDelta * d;
	d = diffalg.CalculateDelta(seq1, seq2);
	d->Traverse(dv);
	delete d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\diff.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DIFF.H

History:

--*/

#ifndef DIFF_H
#define DIFF_H


class CDifference;
class CDeltaVisitor;
class CDelta;
class CDiffAlgorithm;
class CDiffAlgortihmFactory;
class CDiffEngine;

class CDifference // Represents each of the elements in a CDelta object
{
public:
	virtual ~CDifference();
	enum ChangeType
	{
		NoChange,
		Added,
		Deleted
	};
	virtual ChangeType GetChangeType() const = 0;	// types of change that caused the difference
	virtual const wchar_t * GetUnit() const = 0; // comparison unit (0-terminated string)
	virtual int GetOldUnitPosition() const = 0; // 0-based position in old sequence. -1 if Added
	virtual int GetNewUnitPosition() const = 0;	// 0-based position in new sequence. -1 if Deleted
	virtual const wchar_t * GetPrefix() const = 0; //prpend this string to unit string
	virtual const wchar_t * GetSufix() const = 0; //append this string to unit string
	virtual bool IsFirst() const = 0; //is this first difference in delta?
	virtual bool IsLast() const = 0; //is this last difference in delta?
};

class LTAPIENTRY CDeltaVisitor
{
public:
	//called for each element in a CDelta
	virtual void VisitDifference(const CDifference & diff) const = 0; 
};

class CDelta // sequence of CDifference elements
{
public:
	virtual ~CDelta();
	// Starts a visit to all CDifference elements in CDelta
	virtual void Traverse(const CDeltaVisitor & dv) = 0; 
};

class LTAPIENTRY CDiffAlgorithm
{
public:
	virtual ~CDiffAlgorithm();
	// Computes a CDelta object based on a certain diff algorithm
	virtual CDelta * CalculateDelta(
		const wchar_t * seq1, 
		const wchar_t * seq2) = 0; 
};

// Encapsulates the creation of the diff algorithm
class LTAPIENTRY CDiffAlgorithmFactory
{
public:
	virtual CDiffAlgorithm * CreateDiffAlgorithm() = 0;
};



// Generic diff engine that calculates delta and processes each difference in it
class LTAPIENTRY CDiffEngine
{
public:
	static void Diff(CDiffAlgorithm & diffalg, 
		const wchar_t * seq1, 
		const wchar_t * seq2, 
		const CDeltaVisitor & dv);
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "diff.inl"
#endif

#endif  //  DIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\gnudiffalg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GNUDIFFALG.H

History:

--*/

#ifndef GNUDIFFALG_H
#define GNUDIFFALG_H

#include "diff.h"

class LTAPIENTRY CGNUDiffAlgorithm : public CDiffAlgorithm
{
public:
	virtual CDelta * CalculateDelta(
		const wchar_t * seq1, 
		const wchar_t * seq2); 
};

class LTAPIENTRY CGNUDiffAlgFact : public CDiffAlgorithmFactory
{
public:
	virtual CDiffAlgorithm * CreateDiffAlgorithm();
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "gnudiffalg.inl"
#endif

#endif  //  GNUDIFFALG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\flushmem.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FLUSHMEM.H

History:

--*/


#pragma once


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CFlushMemory : public CObject
{
public:
	CFlushMemory(BOOL fDelete);

	virtual void FlushMemory(void) = 0;

	void Delete(void);

private:
	CFlushMemory();
	CFlushMemory(const CFlushMemory &);
	void operator=(const CFlushMemory &);

	BOOL m_fDelete;
};



class LTAPIENTRY CMinWorkSet : public CFlushMemory
{
public:
	CMinWorkSet(BOOL fDelete);
	
	void FlushMemory(void);
};



#pragma warning(default: 4275)

void LTAPIENTRY NOTHROW AddFlushClass(CFlushMemory *);
BOOL LTAPIENTRY NOTHROW RemoveFlushClass(CFlushMemory *);

void LTAPIENTRY FlushMemory(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\espnls.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPNLS.H

History:

--*/


#ifndef ESPUTIL_ESPNLS_H
#define ESPUTIL_ESPNLS_H


typedef int CodePage;
const CodePage cpInvalidCodePage = 0xDEADBEEF;
const CodePage US_ACP = 1252;

typedef WORD LangId;
const int BAD_LOCALE = 0xFFFF;

enum CodePageType
{
	cpUnknown,
	cpAnsi,
	cpDos,
	cpMac,
	cpUnicode
};


struct LanguageInfo
{
	LangId lid;
	CodePage cpAnsi;
	CodePage cpDos;
	CodePage cpMac;
	const TCHAR *szName;
	const TCHAR *szShortName;
	WORD fLangFlags;
};

const WORD lfNoFlags = 0;
const WORD lfDBCSHotKey = 0x0001;

typedef void (*pfnLangHandler)(const LanguageInfo &, void *);

class LTAPIENTRY CLocLangId 
{
public:
	CLocLangId(void);
	
	LTASSERTONLY(void AssertValid(void) const);

	NOTHROW LangId GetLanguageId(void) const;
	NOTHROW CodePage GetCodePage(CodePageType) const;
	NOTHROW void GetLangName(CLString &) const;
	NOTHROW void GetLangShortName(CLString &) const;
	
	NOTHROW BOOL SetLanguageId(LangId);
	NOTHROW const CLocLangId & operator=(const CLocLangId &);
	
	NOTHROW int operator==(const CLocLangId &) const;
	NOTHROW int operator!=(const CLocLangId &) const;
	
	NOTHROW static UINT GetNumLangInfo(void);
	static void EnumerateLanguages(pfnLangHandler, void *);
	static void Enumerate(CEnumCallback &);
	NOTHROW static BOOL IsDBCSHotKey(LangId);
	NOTHROW BOOL IsDBCSHotKey(void) const;
	NOTHROW static BOOL IsValidLangId(LangId lid);
	
	LTASSERTONLY(~CLocLangId());
	
private:
	//
	//  Private implementation.
	//
	NOTHROW static const LanguageInfo & LocateLangInfo(LangId);
	NOTHROW static const LanguageInfo & GetLangInfo(UINT);
	
	//
	//  Private data.
	//
	LangId m_lid;
	const LanguageInfo *m_pLangInfo;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "espnls.inl"
#endif

#endif // ESPUTIL_ESPNLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\espnls.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPNLS.INL

History:

--*/


inline
LangId
CLocLangId::GetLanguageId(void)
		const
{
	return m_lid;
}



inline
void
CLocLangId::GetLangName(
		CLString &strLangName)
		const
{
	LTASSERT(m_lid != 0);
	
	strLangName = m_pLangInfo->szName;
}



inline
void
CLocLangId::GetLangShortName(
		CLString &strLangShortName)
		const
{

	strLangShortName = m_pLangInfo->szShortName;
}



inline
int
CLocLangId::operator==(
		const CLocLangId &lidOther)
		const
{
	return (m_lid == lidOther.GetLanguageId());
}



inline
int
CLocLangId::operator!=(
		const CLocLangId &lidOther)
		const
{
	return !operator==(lidOther);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\listdelta.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LISTDELTA.H

History:

--*/


#ifndef LISTDELTA_H
#define LISTDELTA_H

#include "diff.h"

class CListDelta : public CDelta, public CList<CDifference *, CDifference * &>
{
public:
	virtual ~CListDelta();
	virtual void Traverse(const CDeltaVisitor & dv); 
};

#endif  //  LISTDELTA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\loadlib.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOADLIB.H

History:

--*/

#ifndef ESPUTIL_LOADLIB_H
#define ESPUTIL_LOADLIB_H


#pragma warning(disable : 4251)
class LTAPIENTRY CLoadLibrary
{
public:
	NOTHROW CLoadLibrary(void);
	NOTHROW CLoadLibrary(const CLoadLibrary &);

	NOTHROW BOOL LoadLibrary(const TCHAR *szFileName);
	NOTHROW BOOL FreeLibrary(void);

	NOTHROW void WrapLibrary(HINSTANCE);
	
	NOTHROW void operator=(const CLoadLibrary &);

	NOTHROW HINSTANCE GetHandle(void) const;
	NOTHROW HINSTANCE ExtractHandle(void);
	NOTHROW operator HINSTANCE(void) const;

	NOTHROW FARPROC GetProcAddress(const TCHAR *) const;
	
	NOTHROW const CString & GetFileName(void) const;
	
	NOTHROW ~CLoadLibrary();
	
private:
	CString m_strFileName;
	HINSTANCE m_hDll;
};


#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "loadlib.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\imagehelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    IMAGEHELP.H

Abstract:

    Re-director for imagehlp.dll.

History:

--*/

#ifndef ESPUTIL_IMAGEHLP_H
#define ESPUTIL_IMAGEHLP_H




class LTAPIENTRY CImageHelp
{
public:
	CImageHelp();
	BOOL ImagehlpAvailable(void);
			
	BOOL EnumerateLoadedModules(HANDLE, PENUMLOADED_MODULES_CALLBACK, void *);
	PIMAGE_NT_HEADERS ImageNtHeader(LPVOID);

	LPAPI_VERSION ImagehlpApiVersion(void);
	BOOL StackWalk(
			DWORD                             MachineType,
			HANDLE                            hProcess,
			HANDLE                            hThread,
			LPSTACKFRAME                      StackFrame,
			LPVOID                            ContextRecord,
			PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
			PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
			PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
			PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
		);

	BOOL SymGetModuleInfo(
			IN  HANDLE              hProcess,
			IN  DWORD               dwAddr,
			OUT PIMAGEHLP_MODULE    ModuleInfo
		);
	LPVOID SymFunctionTableAccess(
			HANDLE  hProcess,
			DWORD   AddrBase
		);

	BOOL SymGetSymFromAddr(
			IN  HANDLE              hProcess,
			IN  DWORD               dwAddr,
			OUT PDWORD              pdwDisplacement,
			OUT PIMAGEHLP_SYMBOL    Symbol
		);

	BOOL SymInitialize(
			IN HANDLE   hProcess,
			IN LPSTR    UserSearchPath,
			IN BOOL     fInvadeProcess
		);

	BOOL SymUnDName(
			IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
			OUT LPSTR            UnDecName,         // Buffer to store undecorated name in
			IN  DWORD            UnDecNameLength    // Size of the buffer
		);

	DWORD SymLoadModule(
			IN  HANDLE          hProcess,
			IN  HANDLE          hFile,
			IN  PSTR            ImageName,
			IN  PSTR            ModuleName,
			IN  DWORD           BaseOfDll,
			IN  DWORD           SizeOfDll
		);
	DWORD UnDecorateSymbolName(
			LPSTR    DecoratedName,         // Name to undecorate
			LPSTR    UnDecoratedName,       // If NULL, it will be allocated
			DWORD    UndecoratedLength,     // The maximym length
			DWORD    Flags                  // See IMAGEHLP.H
		);

	DWORD SymGetOptions(void);
	DWORD SymSetOptions(DWORD);
	
	PIMAGE_NT_HEADERS CheckSumMappedFile(
	    LPVOID BaseAddress,
	    DWORD FileLength,
	    LPDWORD HeaderSum,
	    LPDWORD CheckSum
	    );

	BOOL MakeSureDirectoryPathExists(const TCHAR *);
	
private:

	void LoadImageHelp(void);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\gnudiffalg.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GNUDIFFALG.INL

History:

--*/

inline 
CDiffAlgorithm * 
CGNUDiffAlgFact::CreateDiffAlgorithm()
{
	return new CGNUDiffAlgorithm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\locid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCID.H

History:

--*/

//  
//  This is the definition of a localization ID.  It makes up part of the
//  localization unique ID, and is eesentially the implementation for
//  CLocResId and CLocTypeId.
//  
 
#ifndef LOCID_H
#define LOCID_H

#pragma warning(disable : 4275)

class LTAPIENTRY CLocId : public CObject
{
public:
	NOTHROW CLocId();

	void AssertValid(void) const;

	BOOL NOTHROW HasNumericId(void) const;
	BOOL NOTHROW HasStringId(void) const;
	BOOL NOTHROW IsNull(void) const;
	
	BOOL NOTHROW GetId(ULONG &) const;
	BOOL NOTHROW GetId(CPascalString &) const;

	void NOTHROW GetDisplayableId(CPascalString &) const;

	//
	//  These 'set' functions are 'write once'.  Once the ID has been
	//  set, it can't be changed.  Trying to set the ID again will
	//  cause an AfxNotSupportedException to be thrown.
	//
	void SetId(ULONG);
	void SetId(const CPascalString &);
	void SetId(const WCHAR *);
	void SetId(ULONG, const CPascalString &);
	void SetId(ULONG, const WCHAR *);
	
	const CLocId &operator=(const CLocId &);

	void NOTHROW ClearId(void);
	
	int NOTHROW operator==(const CLocId &) const;
	int NOTHROW operator!=(const CLocId &) const;

	virtual void Serialize(CArchive &ar);

	virtual ~CLocId();

protected:
	//
	//  Internal implementation functions.
	//
	BOOL NOTHROW IsIdenticalTo(const CLocId&) const;
	void NOTHROW CheckPreviousAssignment(void) const;
	 
private:
	//
	//  This prevent the default copy constructor from being
	//  called.
	//
	CLocId(const CLocId&);

	ULONG m_ulNumericId;            //  The numeric ID of the resource
	CPascalString m_pstrStringId;   //  The string ID of the resource
	BOOL m_fHasNumericId :1;		//  Indicates if the numeric ID is valid
	BOOL m_fHasStringId  :1;		//  Indicates if the string ID is valid

	DEBUGONLY(static CCounter m_UsageCounter);
	DEBUGONLY(static CCounter m_DisplayCounter);
};
#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locid.inl"
#endif

#endif  //  LOCID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\macros.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MACROS.H

History:

--*/


#define COUNTOF(x) (sizeof(x)/sizeof(*x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\loadlib.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOADLIB.INL

History:

--*/

inline
CLoadLibrary::CLoadLibrary(void)
{
	m_hDll = NULL;
}



inline
HINSTANCE
CLoadLibrary::GetHandle(void)
		const
{
	return m_hDll;
}



inline
CLoadLibrary::operator HINSTANCE(void)
		const
{
	return GetHandle();
}



inline
HINSTANCE
CLoadLibrary::ExtractHandle(void)
{
	HINSTANCE hReturn;

	hReturn = m_hDll;

	m_strFileName.Empty();
	m_hDll = NULL;

	return hReturn;
}

	   

inline
const CString &
CLoadLibrary::GetFileName(void)
		const
{
	return m_strFileName;
}



inline
BOOL
CLoadLibrary::LoadLibrary(
		const TCHAR *szFileName)
{
	LTASSERT(m_hDll == NULL);
	   
	m_strFileName = szFileName;
	m_hDll = AfxLoadLibrary(m_strFileName);

	return (m_hDll != NULL);
}



inline
void
CLoadLibrary::WrapLibrary(
		HINSTANCE hDll)
{
	m_hDll = hDll;
}



inline
CLoadLibrary::CLoadLibrary(
		const CLoadLibrary &llSource)
{
	m_hDll = NULL;

	if (llSource.GetHandle() != NULL)
	{
		LoadLibrary(llSource.GetFileName());
	}
}



inline
void
CLoadLibrary::operator=(
		const CLoadLibrary &llSource)
{
	LTASSERT(m_hDll == NULL);

	if (llSource.GetHandle() != NULL)
	{
		LoadLibrary(llSource.GetFileName());
	}
}



inline
FARPROC
CLoadLibrary::GetProcAddress(
		const TCHAR *szProcName)
		const
{
	FARPROC fpFunction = NULL;
	
	if (m_hDll != NULL)
	{
		fpFunction = ::GetProcAddress(m_hDll, szProcName);
	}

	return fpFunction;
}



inline
BOOL
CLoadLibrary::FreeLibrary(void)
{
	BOOL fRetVal = TRUE;
	
 	if (m_hDll != NULL)
	{
		fRetVal = AfxFreeLibrary(m_hDll);
		m_hDll = NULL;
		m_strFileName.Empty();
	}

	return fRetVal;
}



inline
CLoadLibrary::~CLoadLibrary()
{
	FreeLibrary();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\ltimalloc.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LTIMALLOC.H

History:

--*/

class LTIMallocSpy : public IMallocSpy
{
public:
	LTIMallocSpy();
	~LTIMallocSpy();

	
	//
	// IUnknown interface
	virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
	
	virtual ULONG STDMETHODCALLTYPE AddRef( void);
	
	virtual ULONG STDMETHODCALLTYPE Release( void);
	
private:

	//
	// IMallocSpy methods.
	virtual ULONG STDMETHODCALLTYPE PreAlloc( 
            /* [in] */ ULONG cbRequest);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PostAlloc( 
            /* [in] */ void __RPC_FAR *pActual);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreFree( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual void STDMETHODCALLTYPE PostFree( 
            /* [in] */ BOOL fSpyed);
        
	virtual ULONG STDMETHODCALLTYPE PreRealloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PostRealloc( 
            /* [in] */ void __RPC_FAR *pActual,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreGetSize( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual ULONG STDMETHODCALLTYPE PostGetSize( 
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual int STDMETHODCALLTYPE PostDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual);
        
	virtual void STDMETHODCALLTYPE PreHeapMinimize( void);
        
	virtual void STDMETHODCALLTYPE PostHeapMinimize( void);

	UINT m_uiRefCount;
	CCounter m_IMallocCounter;
	CCounter m_IMallocUsage;

	ULONG m_ulSize;
};


void DumpOutstandingAllocs(void);
void SetTrackingMode(BOOL);

void LTAPIENTRY BreakOnIMalloc(DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\locvar.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCVAR.INL

History:

--*/

//  
//  Inline functions for the variant class.  This should ONLY be included from
//  locvar.h
//  
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Default constructor.  Sets the variant type to none ie no value is in
//  the variant.
//  
//-----------------------------------------------------------------------------
inline
CLocVariant::CLocVariant()
{
	m_VarType = lvtNone;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the type of the data in the variant.
//  
//-----------------------------------------------------------------------------
inline
LocVariantType
CLocVariant::GetVariantType(void)
		const
{
	return m_VarType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the integer data in the variant.  The data must have been set
//  previously as an integer.
//  
//-----------------------------------------------------------------------------
inline
DWORD
CLocVariant::GetDword(void)
		const
{
	LTASSERT(m_VarType == lvtInteger || m_VarType == lvtStringList);

	if (m_VarType == lvtInteger)
	{
		return m_dwInteger;
	}
	else
	{
		return m_StringList.GetIndex();
	}
}



inline
BOOL
CLocVariant::GetBOOL(void)
		const
{
	LTASSERT(m_VarType == lvtBOOL);
	
	return m_fBOOL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the string data in the variant.  The data must have been set
//  previously as an string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocVariant::GetString(void)
		const
{
	LTASSERT(m_VarType == lvtString || m_VarType == lvtFileName);
		
	return m_psString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the dual string/integer data in the variant.  The data must have
//  been set previously as an dual string/integer.
//  
//-----------------------------------------------------------------------------
inline
const CLocId &
CLocVariant::GetIntPlusString(void)
		const
{
	LTASSERT(m_VarType == lvtIntPlusString);

	return m_IntPlusString;
}



inline
const CLocCOWBlob &
CLocVariant::GetBlob(void)
		const
{
	LTASSERT(m_VarType == lvtBlob);

	return m_Blob;
}



inline
const CPasStringList &
CLocVariant::GetStringList(void)
		const
{
	LTASSERT(m_VarType == lvtStringList);

	return m_StringList;
}

inline
const CLString & 
CLocVariant::GetFileExtensions(void) 
	const
{
	LTASSERT(m_VarType == lvtFileName);

	return m_strFileExtensions;
}	


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocVariant::operator==(
		const CLocVariant &lvOther)
		const
{

	return IsEqualTo(lvOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocVariant::operator!=(
		const CLocVariant &lvOther)
		const
{
	return !IsEqualTo(lvOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to an integer value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetDword(
		const DWORD dwNewValue)
{
	m_VarType = lvtInteger;

	m_dwInteger = dwNewValue;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetBOOL(
		const BOOL fNewValue)
{
	m_VarType = lvtBOOL;

	m_fBOOL = fNewValue;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to a CPascalString value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetString(
		const CPascalString &psNewValue)
{
	m_VarType = lvtString;

	m_psString = psNewValue;
}

inline
void 
CLocVariant::SetFileName(
	const CPascalString &psNewValue,
	const CLString & strExtensions)
{
	m_VarType = lvtFileName;

	m_psString = psNewValue;
	m_strFileExtensions = strExtensions;

}	


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to a dual string/integer value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetIntPlusString(
		const CLocId &NewIntPlusString)
{
	m_VarType = lvtIntPlusString;

	m_IntPlusString = NewIntPlusString;
}



inline
void
CLocVariant::SetBlob(
		const CLocCOWBlob &blbNewValue)
{
	m_VarType = lvtBlob;

	m_Blob = blbNewValue;
}



inline
void
CLocVariant::SetStringList(
		const CPasStringList &slNewValue)
{
	m_VarType = lvtStringList;

	m_StringList = slNewValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\locvar.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCVAR.H

History:

--*/


//  Declaration of CLocVariant, our variant class.
//  
 
#ifndef ESPUTIL_LOCVAR_H
#define ESPUTIL_LOCVAR_H


enum LocVariantType
{
	lvtNone,
	lvtInteger,
	lvtString,
	lvtIntPlusString,
	lvtBOOL,
	lvtBlob,
	lvtStringList,
	lvtFileName,			// stores file name and editing extension string
};


typedef CLocThingList<CPascalString> CPasStringList;

UINT StoreToBlob(const CPasStringList &, CLocCOWBlob &, UINT uiOffset);
UINT LoadFromBlob(CPasStringList &, const CLocCOWBlob &, UINT uiOffset);
#pragma warning(disable : 4275 4251)

class LTAPIENTRY CLocVariant : public CObject
{
public:
	NOTHROW CLocVariant();

	void AssertValid(void) const;

	NOTHROW LocVariantType GetVariantType(void) const;
	
	NOTHROW DWORD GetDword(void) const;
	NOTHROW BOOL GetBOOL(void) const;
	NOTHROW const CPascalString & GetString(void) const;
	NOTHROW const CLocId & GetIntPlusString(void) const;
	NOTHROW const CLocCOWBlob & GetBlob(void) const;
	NOTHROW const CPasStringList & GetStringList(void) const;
	NOTHROW const CLString & GetFileExtensions(void) const;
	
	NOTHROW int operator==(const CLocVariant &) const;
	NOTHROW int operator!=(const CLocVariant &) const;
	
	NOTHROW void SetDword(const DWORD);
	NOTHROW void SetBOOL(const BOOL);
	NOTHROW void SetString(const CPascalString &);
	NOTHROW void SetIntPlusString(const CLocId &);
	NOTHROW void SetBlob(const CLocCOWBlob &);
	NOTHROW void SetStringList(const CPasStringList &);
	NOTHROW void SetFileName(const CPascalString &, const CLString &);
	
	NOTHROW const CLocVariant & operator=(const CLocVariant &);
	BOOL ImportVariant(const VARIANT& var);
	BOOL ExportVariant(VARIANT& var) const;

	void Serialize(CArchive &);
	void Load(CArchive &);
	void Store(CArchive &) const;
	
protected:
	NOTHROW BOOL IsEqualTo(const CLocVariant &) const;
	
private:
	CLocVariant(const CLocVariant &);

	
	LocVariantType m_VarType;

	//
	//  Class objects can't be in a union.
	//
	union
	{
		DWORD m_dwInteger;
		BOOL  m_fBOOL;
	};
	CPascalString  m_psString;
	CLocId         m_IntPlusString;
	CLocCOWBlob    m_Blob;
	CPasStringList m_StringList;
	CLString       m_strFileExtensions;
};

#pragma warning(default : 4275 4251)


void Store(CArchive &, const CPasStringList &);
void Load(CArchive &, CPasStringList &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locvar.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\ltdebug.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LTDEBUG.H

History:

--*/


//  
//  Debugging facilities for Espresso 2.x.  Included are augmented TRACE
//  and ASSERT facilities.
//  
 
#ifndef MITUTIL_LtDebug_h_INCLUDED
#define MITUTIL_LtDebug_h_INCLUDED

#pragma once


#if defined(_DEBUG)
#define LTTRACE_ACTIVE
#define LTASSERT_ACTIVE

#define new DEBUG_NEW
#define LTGetAllocNumber() LTGetAllocNumberImpl()

//
//  Executes code only in a DEBUG build.
//
#define DEBUGONLY(x) x

#define LTDebugBreak() LTBreak()

#else  // _DEBUG

#define DEBUGONLY(x) 

#define LTDebugBreak() (void) 0
#define LTGetAllocNumber() 0

#endif  // _DEBUG

#if defined(LTASSERT_ACTIVE) || defined (ASSERT_ALWAYS)
#ifdef ASSERT
#undef ASSERT
#endif
#ifdef VERIFY
#undef VERIFY
#endif
#define ASSERT LTASSERT
#define VERIFY LTVERIFY

#ifndef _DEBUG
#pragma message("Warning: LTASSERT Active in non-debug build")
#endif
//
// The multilevel assert macros ensure that the line numbers get expanded to
// something like "115" instead of "line" or "__LINE__"
//
// This will evaluate the expression only once, UNLESS to ask it to 'Retry'.
// Then it will re-evaluate the expression after the return from the debugger.
//
#define LTASSERTONLY(x) x

#define LTASSERT(x) LTASSERT2(x, TEXT(__FILE__), __LINE__)

#define LTASSERT2(exp, file, line)  \
        while (!(exp) && LTFailedAssert(TEXT(#exp), file, line)) (void) 0

#define LTVERIFY(x) LTASSERT(x)

#else // defined(_DEBUG) || defined(ASSERT_ALWAYS)

#define LTASSERTONLY(x)
#define LTASSERT(x) (void) 0
#define LTVERIFY(x) x

#endif // defined(_DEBUG) || defined(ASSERT_ALWAYS)


#ifndef MIT_NO_DEBUG
//
//  Name of the project
//
#ifndef LTTRACEPROJECT
#define LTTRACEPROJECT "Borg"
#endif

//
//  Default value for the exe name if one was not supplied.
//
#ifndef LTTRACEEXE
#define LTTRACEEXE MSLOC
#endif

//
//  Used to put quotes around the LTTRACEEXE macro.
//
#define __stringify2(x) #x
#define __stringify(x) __stringify2(x)

//
// TODO - find a better place for this

		LTAPIENTRY void CopyToClipboard(const char *szMessage);

		
		
struct LTModuleInfo
{
	UINT uiPreferredLoadAddress;
	UINT uiActualLoadAddress;
	UINT uiModuleSize;
	char szName[MAX_PATH];
};

LTAPIENTRY void LTInitDebug(void);

LTAPIENTRY void LTInstallIMallocTracking();
LTAPIENTRY void LTDumpIMallocs(void);
LTAPIENTRY void LTTrackIMalloc(BOOL f);
LTAPIENTRY void LTRevokeIMallocTracking();

LTAPIENTRY void LTShutdownDebug(void);

LTAPIENTRY BOOL LTSetAssertSilent(BOOL);
LTAPIENTRY BOOL LTFailedAssert(const TCHAR *, const TCHAR *, int);
LTAPIENTRY void LTBreak(void);

LTAPIENTRY LONG LTGetAllocNumberImpl(void);
LTAPIENTRY void LTBreakOnAlloc(const char *szFilename, int nLineNum, long nAllocNum);

LTAPIENTRY BOOL LTCheckBaseAddress(HMODULE);
LTAPIENTRY BOOL LTCheckAllBaseAddresses(void);
LTAPIENTRY void LTCheckPagesFor(HINSTANCE);
LTAPIENTRY void LTCheckPagesForAll(void);

LTAPIENTRY void LTDumpAllModules(void);
LTAPIENTRY BOOL LTLocateModule(DWORD dwAddress, HMODULE *pInstance);
LTAPIENTRY BOOL LTGetModuleInfo(HMODULE, LTModuleInfo *);

LTAPIENTRY UINT LTGenStackTrace(TCHAR *szBuffer, UINT nBuffSize,
		UINT nSkip, UINT nTotal);

LTAPIENTRY void LTSetBoringModules(const char *aszBoring[]);
LTAPIENTRY void LTTrackAllocations(BOOL);
LTAPIENTRY void LTDumpAllocations(void);

LTAPIENTRY BOOL LTCheckResourceRange(HINSTANCE, WORD UniqueStart, WORD UniqueEnd,
		WORD SharedStart, WORD SharedEnd);
LTAPIENTRY BOOL LTCheckAllResRanges(WORD, WORD);

#pragma warning(disable:4275)

class LTAPIENTRY CAssertFailedException : public CException
{
public:
	CAssertFailedException(const TCHAR *);
	CAssertFailedException(const TCHAR *, BOOL);

	BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
			PUINT pnHelpContext = NULL);

	~CAssertFailedException();
	
private:
	CAssertFailedException();
	CAssertFailedException(const CAssertFailedException &);

	TCHAR *m_pszAssert;
};



class LTAPIENTRY LTTracePoint
{
public:
	LTTracePoint(const TCHAR *);

	~LTTracePoint();

private:
	LTTracePoint();

	const TCHAR *m_psz;
};



#pragma warning(default:4275)

//
//  Comment this out to remove ASSERTs from retail builds
//  #define LTASSERT_ACTIVE


#if defined(LTTRACE_ACTIVE)


static const TCHAR *szLTTRACEEXE = TEXT(__stringify(LTTRACEEXE));

//
//  The following let us control the output dynamically.  We use a function
//  pointer to route our debug output, and change the function pointer to
//  enable/disable tracing.
//
static void LTTRACEINIT(const TCHAR *, ...);
static void (*LTTRACE)(const TCHAR *, ...) = LTTRACEINIT;

void LTAPIENTRY LTTRACEOUT(const TCHAR *szFormat, va_list args);
void LTAPIENTRY LTTRACEON(const TCHAR *szFormat, ...);
void LTAPIENTRY LTTRACEOFF(const TCHAR *szFormat, ...);


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  LTTRACE is initialized to point to this function.  When first called, it
//  determines if tracing should be enabled, then routes LTTRACE through the
//  right handler.
//  
//-----------------------------------------------------------------------------
static
void
LTTRACEINIT(
		const TCHAR *szFormat,			//  printf style formatting string
		...)							//  Variable argument list to format 
{
	BOOL fDoTrace = 1;
	va_list args;
	const TCHAR * const szTraceProfile = TEXT("lttrace.ini");

	fDoTrace = GetPrivateProfileInt(
			TEXT("ProjectTracing"),
			TEXT("Default"),
			fDoTrace,
			szTraceProfile);
	
	fDoTrace = GetPrivateProfileInt(
			TEXT("ProjectTracing"),
			TEXT(LTTRACEPROJECT),
			fDoTrace,
			szTraceProfile);
	
	if (fDoTrace)
	{
		fDoTrace = GetPrivateProfileInt(
				TEXT("ExecutableTracing"),
				szLTTRACEEXE,
				fDoTrace,
				szTraceProfile);
	}
	
	if (fDoTrace)
	{
		LTTRACE = LTTRACEON;
		
		va_start(args, szFormat);
		
		LTTRACEOUT(szFormat, args);
	}
	else
	{
		LTTRACE = LTTRACEOFF;
	}
}


#define LTTRACEPOINT(sz) LTTracePoint lttp##__LINE__(TEXT(sz))

#else // defined(LTTRACE_ACTIVE)

//
//  Retail version of the debugging macros.  Everything
//  just 'goes away'.  We use (void) 0 so that these things
//  are statements in both the debug and retail builds.
//

static inline void LTNOTRACE(const TCHAR *, ...) 
{}

#define LTTRACE 1 ? (void) 0 : (void) LTNOTRACE
#define LTTRACEPOINT(x) (void) 0

#endif  // defined(LTTRACE_ACTIVE)


#endif // MIT_NO_DEBUG


#endif // #ifndef MITUTIL_LtDebug_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\locid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCID.INL

History:

--*/


//  In line definitions for the CLocID class.  This fgile should ONLY be
//  included by locid.h
//  
 

//-----------------------------------------------------------------------------
//  
//  Implementation.  Clears the contents of the ID.  Both parts are marked
//  invalid.
//  
//-----------------------------------------------------------------------------
inline
void
CLocId::ClearId(void)
{
	m_fHasNumericId = FALSE;
	m_fHasStringId = FALSE;

	m_ulNumericId = 0;
	m_pstrStringId.ClearString();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constuctor for a localization ID.  Sets it to have no valid ID.
//  
//-----------------------------------------------------------------------------
inline
CLocId::CLocId()
{
	ClearId();

	DEBUGONLY(++m_UsageCounter);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests if the numeric ID is valid.
//  
//-----------------------------------------------------------------------------
inline
BOOL                              //  TRUE means the numeric ID is valid
CLocId::HasNumericId(void)
		const
{
	return m_fHasNumericId;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests if the string ID is valid.
//  
//-----------------------------------------------------------------------------
inline
BOOL							        //  TRUE means the string ID is valid
CLocId::HasStringId(void)
		const
{
	return m_fHasStringId;
}



inline
BOOL
CLocId::IsNull(void)
		const
{
	return
		!HasStringId() &&
		!HasNumericId();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current numeric ID.  If the ID is invalid, the ID will be
//  zero.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE indicates the ID is valid
CLocId::GetId(
		ULONG &ulNumericId)				// Location to put ID
		const
{
	ulNumericId = m_ulNumericId;
	
	return m_fHasNumericId;
}

		

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current string ID.  If the ID is invalid, it will be a NULL
//  string.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE indicates the ID is valid
CLocId::GetId(
		CPascalString &pstrStringId)	// Location to put the ID.
		const
{
	pstrStringId = m_pstrStringId;
	
	return m_fHasStringId;
}


//-----------------------------------------------------------------------------
//  
//  Checks if the ID has been assigned to before.  If it has, throw an
//  exception.
//  
//-----------------------------------------------------------------------------
inline
void
CLocId::CheckPreviousAssignment(void)
		const
{
	if (m_fHasStringId || m_fHasNumericId)
	{
		AfxThrowNotSupportedException();
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Compares two ID's to see if they are the same.  
//  
//-----------------------------------------------------------------------------
inline
int
CLocId::operator==(
		const CLocId &lidOther)			// ID to compare to
		const
{
	return IsIdenticalTo(lidOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Checks for in-equality between two ID's
//  
//-----------------------------------------------------------------------------
inline
int
CLocId::operator!=(
		const CLocId &lidOther)
		const
{
	return !IsIdenticalTo(lidOther);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\mitenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITENUM.H

History:

--*/

#pragma once

//
//  This is the information we enumerate about enumerators.
//
struct EnumInfo
{
	const TCHAR *szDescription;
	const TCHAR *szAbbreviation;
	ULONG ulValue;
};

//
//  This class is used as a base for a call-back class when enumerating
//  enum values.  For each value, the PrecessEnum() method is called.
//
class LTAPIENTRY CEnumCallback 
{
public:
	virtual BOOL ProcessEnum(const EnumInfo &) = 0;
	virtual void SetRange(UINT /* nStart */, UINT /* nFinish */) {}
	inline CEnumCallback() {};

private:
	CEnumCallback(const CEnumCallback &);
	CEnumCallback &operator=(const CEnumCallback &);
};


//
struct WEnumInfo
{
	const WCHAR *szDescription;
	const WCHAR *szAbbreviation;
	ULONG ulValue;
};

//
//  This class is used as a base for a call-back class when enumerating
//  enum values.  For each value, the PrecessEnum() method is called.
//
class LTAPIENTRY CWEnumCallback 
{
public:
	virtual BOOL ProcessEnum(const WEnumInfo &) = 0;
	virtual void SetRange(UINT /* nStart */, UINT /* nFinish */) {}
	inline CWEnumCallback() {};

private:
	CWEnumCallback(const CWEnumCallback &);
	CWEnumCallback &operator=(const CWEnumCallback &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\optionval.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    OPTIONVAL.H

History:

--*/

#pragma once

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionVal : public CRefCount, public CObject
{
public:
	NOTHROW CLocOptionVal();

	void AssertValid(void) const;

	enum OptionCode
	{
		ocNoError,
		ocUnknownOption,
		ocInvalidValue,
		ocInvalidType
	};

	NOTHROW void SetName(const CLString &);
	NOTHROW void SetValue(const CLocVariant &);

	NOTHROW const CLString & GetName(void) const;
	NOTHROW const CLocVariant & GetValue(void) const;

	void Serialize(CArchive &);
	void Load(CArchive &);
	void Store(CArchive &) const;
	
protected:
	virtual ~CLocOptionVal();

private:
	CLString m_strName;
	CLocVariant m_lvValue;

};


class LTAPIENTRY CLocOptionValList :
	public CTypedPtrList<CPtrList, CLocOptionVal *>
{
public:
	NOTHROW CLocOptionValList();

	void AssertValid(void) const;

	NOTHROW ~CLocOptionValList();

private:
	CLocOptionValList(const CLocOptionValList &);

	void operator=(const CLocOptionValList &);
};


#pragma warning(default: 4275)


//
//  Worker function for options upgrade.
LTAPIENTRY void DorkData(BYTE *, DWORD &);


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "optionval.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\optionval.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    OPTIONVAL.INL

History:

--*/

inline
const CLString &
CLocOptionVal::GetName(void)
		const
{
	return m_strName;
}



inline
const CLocVariant &
CLocOptionVal::GetValue(void)
		const
{
	return m_lvValue;
}



inline
void
CLocOptionVal::SetName(
		const CLString &strName)
{
	m_strName = strName;
}



inline
void
CLocOptionVal::SetValue(
		const CLocVariant &lvValue)
{
	m_lvValue = lvValue;

	LTASSERTONLY(AssertValid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\optvalset.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    OPTVALSET.H

History:

--*/

#pragma once



#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionValEnumCallback : public CObject
{
public:
	CLocOptionValEnumCallback() {};

	void AssertValid(void) const;
			
	virtual BOOL ProcessOption(CLocOptionVal *) = 0;
	virtual BOOL ProcessOption(const CLocOptionVal *) = 0;
	
private:
	CLocOptionValEnumCallback(const CLocOptionValEnumCallback &);
	void operator=(int);
};


class LTAPIENTRY CLocOptionValSet;

class LTAPIENTRY CLocOptionValSetList :
	public CTypedPtrList<CPtrList, CLocOptionValSet *>
{
public:
	NOTHROW CLocOptionValSetList() {};

	void AssertValid(void) const;

	NOTHROW void ReleaseAll();
	NOTHROW ~CLocOptionValSetList();

private:
	CLocOptionValSetList(const CLocOptionValSetList &);
	void operator=(const CLocOptionValSetList &);
};

 
class LTAPIENTRY CLocOptionValSet : public CRefCount, public CObject
{
public:
	NOTHROW CLocOptionValSet();

	void AssertValid(void) const;
	
	NOTHROW void AddOption(CLocOptionVal *);
	NOTHROW void AddOptionSet(CLocOptionValSet *);
	NOTHROW void SetName(const CLString &);
	
	NOTHROW const CLocOptionValList & GetOptionList(void) const;
	NOTHROW const CLocOptionValSetList & GetOptionSets(void) const;
	NOTHROW BOOL FindOptionVal(const CLString &, CLocOptionVal *&pOption);
	NOTHROW BOOL FindOptionVal(const CLString &, const CLocOptionVal *&pOption) const;
	NOTHROW const CLString & GetName(void) const;
	
	NOTHROW BOOL IsEmpty(void) const;
	
	BOOL EnumOptions(CLocOptionValEnumCallback *);
	BOOL EnumOptions(CLocOptionValEnumCallback *) const;
	
	//
	//  Escape hatch.
	//
	NOTHROW void * GetPExtra(void) const;
	NOTHROW DWORD GetDWExtra(void) const;
	NOTHROW void SetExtra(void *);
	NOTHROW void SetExtra(DWORD);

protected:
	NOTHROW virtual ~CLocOptionValSet();

private:
	CLocOptionValList m_olOptions;
	CLocOptionValSetList m_oslSubOptions;
	CLString m_strName;
	
	union
	{
		void *m_pExtra;
		DWORD m_dwExtra;
	};
	
	CLocOptionValSet(const CLocOptionValSet &);
	void operator=(const CLocOptionValSet &);
};

#pragma warning(default: 4275)
 
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "optvalset.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\optvalset.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    OPTVALSET.INL

History:

--*/

inline		
void
CLocOptionValSet::AddOption(
		CLocOptionVal *pOption)
{
	m_olOptions.AddTail(pOption);
}



inline
void
CLocOptionValSet::AddOptionSet(
		CLocOptionValSet *pOptionSet)
{
	m_oslSubOptions.AddTail(pOptionSet);
}



inline
void
CLocOptionValSet::SetName(
		const CLString &strName)
{
	m_strName = strName;
}



inline
const CLocOptionValList &
CLocOptionValSet::GetOptionList(void)
		const
{
	return m_olOptions;
}


inline
const CLocOptionValSetList &
CLocOptionValSet::GetOptionSets(void)
		const
{
	return m_oslSubOptions;
}



inline
const CLString &
CLocOptionValSet::GetName(void)
		const
{
	return m_strName;
}



inline
BOOL
CLocOptionValSet::IsEmpty(void)
		const
{
	return m_olOptions.IsEmpty() && m_oslSubOptions.IsEmpty();
}


inline
void *
CLocOptionValSet::GetPExtra(void)
		const
{
	return m_pExtra;
}



inline
DWORD
CLocOptionValSet::GetDWExtra(void)
		const
{
	return m_dwExtra;
}



inline
void
CLocOptionValSet::SetExtra(
		void *pExtra)
{
	m_pExtra = pExtra;
}



inline
void
CLocOptionValSet::SetExtra(
		DWORD dwExtra)
{
	m_dwExtra = dwExtra;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\redvisit.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REDVISIT.H

History:

--*/

#ifndef REDVISIT_H
#define REDVISIT_H

#include "diff.h"

class CRichEditCtrl;

class LTAPIENTRY CRichEditDeltaVisitor : public CDeltaVisitor
{
public:
	CRichEditDeltaVisitor(CRichEditCtrl & red);
	virtual void VisitDifference(const CDifference & diff) const; 

private: 
	CRichEditCtrl & m_red;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "redvisit.inl"
#endif

#endif  //  REDVISIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\passtr.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PASSTR.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Default constructor for a Pascal string.  Sets the length to zero, with
//  no storage.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::CPascalString()
{
	//
	//  The string data class is initialized by it's constructor.
	//
	LTASSERT(m_blbData.GetBlobSize() == 0);

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Casting operator to convert a CPascalString to a blob.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::operator const CLocCOWBlob &(void)
		const
{
	return m_blbData;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator - CPascalString to CPascalString.  
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &                     // Allows a=b=c;
CPascalString::operator=(
		const CPascalString &pstrSource)  // Source string
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData = ((const CLocCOWBlob &)pstrSource);
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Copy constructor for CPascalString's
//  
//-----------------------------------------------------------------------------
inline
CPascalString::CPascalString(
		const CPascalString &pstrSource)
{
	LTASSERT(pstrSource.m_blbData.GetWriteCount() == 0);
	 
	operator=(pstrSource);

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator - Wide character C String to CPascalString.  The string
//  is COPIED into the CPascalString.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &             //  Allows a=b=c;
CPascalString::operator=(
		const WCHAR *wszSource)   //  Source, zero terminated string
{
	SetString(wszSource, wcslen(wszSource));

	return *this;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Appends a CPascalString to the current string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &			        // Allows a=b+=c syntax
CPascalString::operator+=(
		const CPascalString &pstrTail)	// Pascal string to append
{
	AppendBuffer(pstrTail, pstrTail.GetStringLength());
	
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Append a NUL terminated Unicode string to a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Allows a-b+=L"Hi There" syntax
CPascalString::operator+=(
		const WCHAR *szTail)			// NUL terminated string to append
{
	AppendBuffer(szTail, wcslen(szTail));
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Append a Unicode character to a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Allows a-b+=L"Hi There" syntax
CPascalString::operator+=(
		const WCHAR wch)			// WCHAR to append
{
	AppendBuffer(&wch, 1);
	return *this;
}



//-----------------------------------------------------------------------------
//  
//  Comparison function for Pascal strings.
//  
//-----------------------------------------------------------------------------
inline
BOOL                                                // TRUE (1) if the same
CPascalString::IsEqualTo(
		const CPascalString &pstrOtherString) const // String to compare to
{
	return m_blbData == (const CLocCOWBlob &)pstrOtherString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CPascalString::operator==(
		const CPascalString &pstrOtherString) // String to compare
		const
{
	return IsEqualTo(pstrOtherString);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator != - just the negative of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int                                                 // TRUE (1) if *not* equal
CPascalString::operator!=(
		const CPascalString &pstrOtherString) const // String to compare
{

	return !IsEqualTo(pstrOtherString);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator for NUL terminated WCHAR strings.
//  
//-----------------------------------------------------------------------------
inline
int
CPascalString::operator==(
		const WCHAR *pwch)
		const
{
	return (wcscmp(*this, pwch) == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator for NUL termninated WCHAR strings.
//  
//-----------------------------------------------------------------------------
inline int
CPascalString::operator!=(
		const WCHAR *pwch)
		const
{
	return (wcscmp(*this, pwch) != 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is there anything in the string?  This is different from a string of zero
//  length.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CPascalString::IsNull(void)
		const
{
	return ((const void *)m_blbData == NULL);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the length of the pascal string.  If the length is zero, there may be
//  no storage associated with the string.  Use IsNull to check for storage.
//  
//-----------------------------------------------------------------------------
inline
UINT                                         // length of the string.
CPascalString::GetStringLength(void) const
{
	UINT uiBufferSize;

	uiBufferSize = m_blbData.GetBlobSize();
	LTASSERT((uiBufferSize % sizeof(WCHAR)) == 0);
	
	return (uiBufferSize != 0 ? (uiBufferSize/sizeof(WCHAR)-1): 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set the length of the pascal string.  String contents are not preserved
//  
//-----------------------------------------------------------------------------
inline
void                                         // length of the string.
CPascalString::SetStringLength(UINT uNewSize)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.SetBlobSize((uNewSize + 1) * sizeof(WCHAR));
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	*(GetStringPointer() + uNewSize) = L'\0';
	ReleaseStringPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Realloc a string - set true size
//  
//-----------------------------------------------------------------------------
inline
void                                         // length of the string.
CPascalString::ReallocString(UINT uNewSize)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.ReallocBlob((uNewSize +  1) * sizeof(WCHAR));
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	*(GetStringPointer() + uNewSize) = L'\0';
	ReleaseStringPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  As an optimization, the user can ask the Pascal string to reserve some
//  memory for future growth.  This would allow incremental additions to be
//  very efficent.  The reported size of the string is not changed - only the
//  amount of storage reserved for the string.
//
//  If the user requests less space than is already allocated, nothing
//  happens.
//
//-----------------------------------------------------------------------------
inline
void
CPascalString::ReserveStorage(
		UINT nMinSize)					// Size (in chars) to reserve for
{
	if (nMinSize > GetStringLength())
	{
		UINT uiCurSize;

		uiCurSize = GetStringLength();
		ReallocString(nMinSize);
		ReallocString(uiCurSize);
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get a pointer to the storage for the string.  This may be NULL if the
//  string has length 0.  This pointer should be considered INVALID if any
//  other assignment operation is performed on the Pascal string.  Calling
//  this dis-ables teh COW behavior of the CPascalString.
//  
//-----------------------------------------------------------------------------
inline
WCHAR *
CPascalString::GetStringPointer(void)
{
	return (WCHAR *)m_blbData.GetPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Anytime you do a GetStringPointer, use ReleaseStringPointer to allow
//  the PascalString to revert to COW behavior.  Once you call this, the
//  pointer from GetStringPointer is INVALID.
//  
//-----------------------------------------------------------------------------
inline
void
CPascalString::ReleaseStringPointer(void)
{
	m_blbData.ReleasePointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Casting operator version of GetString pointer.  Cast a CPascalString to
//  const WCHAR *, and you get a pointer to the string.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::operator const WCHAR *(void) const
{
	return (const WCHAR *)(const void *)(m_blbData);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Cleanup on the string.  Sets the length to zero, and remove all storage.
//  This is different than assigning a NULL string - that is a string of
//  length 1, consisting of the NUL (zero) character.
//  
//-----------------------------------------------------------------------------
inline
void
CPascalString::ClearString(void)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.SetBlobSize(0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor for a Pascal string.  Frees up the current storage.  After
//  a Pascal string goes out of scope, all pointers to the internal storage
//  are invalid.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::~CPascalString()
{
	LTASSERTONLY(AssertValid());
	DEBUGONLY(--m_UsageCounter);
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Serialize for a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
void CPascalString::Serialize(CArchive &ar)
{
	if (ar.IsStoring())
	{
		Store(ar);
	}
	else
	{
		Load(ar);
	}
}



inline
void
CPascalString::Store(
		CArchive &ar)
		const
{
	LTASSERT(ar.IsStoring());
	LTASSERTONLY(AssertValid());

	//
	//  HACK HACK HACK
	//  Emulate Old Espresso 3.0 serialization.
	m_blbData.Store(ar);
	
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Helper function - comparison operator for a NUL terminated WCHAR string
//  and a CPascalString.
//  
//-----------------------------------------------------------------------------
inline
int
operator==(
		const WCHAR *pwch,
		const CPascalString &pstr)
{
	return (wcscmp(pwch, pstr) == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Helper function - comparison operator for a NUL terminated WCHAR string
//  and a CPascalString.
//  
//-----------------------------------------------------------------------------
inline
int
operator!=(
		const WCHAR *pwch,
		const CPascalString &pstr)
{
	return (wcscmp(pwch, pstr) != 0);
}



inline
int CPascalString::operator!=(
		const _bstr_t &bsOther)
		const
{
	return !(operator==(bsOther));
}



inline
int
operator==(
		const _bstr_t &bsOther,
		const CPascalString &pstr)
{
	return pstr == bsOther;
}



inline
int
operator!=(
		const _bstr_t &bsOther,
		const CPascalString &pstr)
{
	return pstr != bsOther;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\passtr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PASSTR.H

History:

--*/

//  Declaration for a pascal (counted) style wide character string class.
//  The count reflects the number of characters (including NUL characters),
//  not the amount of storage.  Any string in a PascalString is automatically
//  given a NULL terminator, even if it already has one.  This extra terminator
//  is NOT in the count of characters in the string.
//  
 
#ifndef PASSTR_H
#define PASSTR_H


class _bstr_t;

class CUnicodeException : public CSimpleException
{
public:
	enum UnicodeCause
	{
		noCause = 0,
		invalidChar = 1,
		unknownCodePage
	};

	UnicodeCause m_cause;

	NOTHROW CUnicodeException(UnicodeCause);
	NOTHROW CUnicodeException(UnicodeCause, BOOL);
	
	NOTHROW ~CUnicodeException();

	virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError, 
		PUINT pnHelpContext = NULL );
};


void LTAPIENTRY ThrowUnicodeException(CUnicodeException::UnicodeCause);


class LTAPIENTRY CPascalString
{
public:
	NOTHROW CPascalString();
	NOTHROW CPascalString(const CPascalString &);

	void AssertValid(void) const;

	//
	//  The ultimate assignment operator - any random collection
	//  of WIDE characters can be placed in the string.
	//  Also, we can convert any collection of DBCS style strings,
	//  so long as the user provides a code page to work with...
	//
	void SetString(const WCHAR *, UINT);
	void SetString(const char *, UINT, CodePage);
	void SetString(const CLString &, CodePage);
	
	//
	//  Useful assignment operators
	//
	const CPascalString & operator=(const CPascalString &);
	const CPascalString & operator=(const WCHAR *);
	const CPascalString & operator=(const _bstr_t &);
	
	const CPascalString & operator+=(const CPascalString &);
	const CPascalString & operator+=(const WCHAR *);
	const CPascalString & operator+=(const WCHAR);

	void Format(const WCHAR *, ...);

	//
	//  Comparison operators for counted strings.
	//
	NOTHROW int operator==(const CPascalString &) const;
	NOTHROW int operator!=(const CPascalString &) const;

	NOTHROW int operator==(const _bstr_t &) const;
	NOTHROW int operator!=(const _bstr_t &) const;

	NOTHROW int operator==(const WCHAR *) const;
	NOTHROW int operator!=(const WCHAR *) const;
	
	NOTHROW BOOL IsNull(void) const;

	//
	//  Retrieving the data from the string.
	//
	NOTHROW UINT GetStringLength(void) const;
	void SetStringLength(UINT);
	void ReallocString(UINT);
	void ReserveStorage(UINT);

	NOTHROW WCHAR * GetStringPointer(void);
	NOTHROW void ReleaseStringPointer(void);

	NOTHROW operator const WCHAR *(void) const;
	// const BSTR GetBSTR(void) const;

	NOTHROW WCHAR operator[](UINT) const;
	NOTHROW WCHAR & operator[](UINT);

	//
	//  Sub-string extraction
	//
	NOTHROW void Left(CPascalString &, UINT) const;
	NOTHROW void Right(CPascalString &, UINT) const;
	NOTHROW void Mid(CPascalString &, UINT) const;
	NOTHROW void Mid(CPascalString &, UINT, UINT) const;

	//
	//  Locate
	//
	NOTHROW BOOL Find(WCHAR, UINT, UINT &) const;
	NOTHROW BOOL FindOneOf(const CPascalString&, UINT, UINT &) const;
	NOTHROW BOOL FindExcept(const CPascalString &, UINT, UINT &) const;
	NOTHROW BOOL FindSubString(const CPascalString &, UINT, UINT &) const;
	
	NOTHROW BOOL ReverseFind(WCHAR, UINT, UINT &) const;
	NOTHROW BOOL ReverseFindOneOf(const CPascalString &, UINT, UINT &) const;
	NOTHROW BOOL ReverseFindExcept(const CPascalString &, UINT, UINT &) const;
	
	//
	//  Clears the contents of a Pascal string.
	//
	NOTHROW void ClearString(void);

	//
	//  Conversion API's for Pascal style strings.
	//
	enum ConvFlags 
	{
		ConvNoFlags = 0,					// No conversion options
		HexifyDefaultChars = 0x01,			// Hexify chars that convert to the default char
		HexifyNonPrintingChars = 0x02,
		HexifyWhiteSpace = 0x04,
		ConvAddNull = 0x08,
		ConvAllFlags = 0xFF
	};
	
	void ConvertToCLString(CLString &, CodePage, BOOL fHex=FALSE) const;
	void ConvertToMBCSBlob(CLocCOWBlob &, CodePage, DWORD dwFlags = ConvNoFlags) const;
	NOTHROW void MakeUpper(void);
	NOTHROW void MakeLower(void);
	_bstr_t MakeBSTRT() const;
	
	void Serialize(CArchive &ar);
	void Load(CArchive &ar);
	void Store(CArchive &ar) const;
	
	static const char *szUnmappableChar;
	static char cHexLeaderChar;
	
 	static void EscapeBackSlash(const CPascalString &srcStr, 
		CPascalString &destStr);

	int ParseEscapeSequences(CPascalString &pasError);
	
	~CPascalString();
 
protected:
	NOTHROW BOOL IsEqualTo(const CPascalString &) const;
	NOTHROW void AppendBuffer(const WCHAR *, UINT);
	
private:
	void FormatV(const WCHAR *, va_list arglist);
	
	CLocCOWBlob m_blbData;
	operator const CLocCOWBlob &(void) const;

	DEBUGONLY(static CCounter m_UsageCounter);
	DEBUGONLY(static CCounter m_StorageCounter);
};

typedef CArray<CPascalString, CPascalString &> CPasStringArray;
	
//
//  Comparison helper functions.  These should all have the
//  CPascalString as the SECOND arguement.
//
NOTHROW int LTAPIENTRY operator==(const WCHAR *, const CPascalString &);
NOTHROW int LTAPIENTRY operator!=(const WCHAR *, const CPascalString &);

NOTHROW int LTAPIENTRY operator==(const _bstr_t &, const CPascalString &);
NOTHROW int LTAPIENTRY operator!=(const _bstr_t, const CPascalString &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "passtr.inl"
#endif

#endif  //  PASSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\path.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PATH.H

History:

--*/


#ifndef __PATH_H__
#define __PATH_H__

#ifndef _INC_DIRECT
#include <direct.h>
#endif

#ifndef _INC_IO
#include <io.h>
#endif

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

#ifndef _WIN32
#include <ctype.h>
#endif

#ifndef _INC_STAT
#include <stat.h>
#endif

#pragma warning(disable : 4275 4251)


size_t RemoveNewlines(_TCHAR *);

//
// Compatible_GetFileAttributesEx
// g_pGetFileAttributesEx initially points to a function that chooses the new win32 api,
// GetFileAttributesEx if supported, or selects a compatible function that uses FindFirstFile.
//
extern BOOL AFX_DATA (WINAPI *g_pGetFileAttributesEx)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);
__inline BOOL Compatible_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	return (*g_pGetFileAttributesEx)( lpFileName, fInfoLevelId, lpFileInformation);
}


//////////////////////////////////////////////////////////////////////
// Classes defined in this file

// CObject
	class CPath;
	class CDir;
//////////////////////////////////////////////////////////////////////
// Scan a path in see if it contains special charaters that would
// required it to be quoted:
BOOL ScanPathForSpecialCharacters (const TCHAR *pPath);
//////////////////////////////////////////////////////////////////////
// CPath
class LTAPIENTRY CPath : public CObject
{
	DECLARE_DYNAMIC(CPath)

	friend	class		CDir;

	friend	static VOID		ConstructElement(CPath *);
	friend	static VOID		DestructElement(CPath *);

protected:
	// Data
			CString		m_strCanon;
			int		m_ichLastSlash;	// used to quickly extract only dir or filename
			BOOL		m_Flags;
			enum	PathFlags
				{
					eIsActualCase = 1,
					eWantsRelative = 2,
				};
				// Canonicalized representation of pathname.
			static CMapStringToString c_DirCaseMap;
public:
	// Constructors, destructors, initialization methods
	inline				CPath() { m_ichLastSlash = -1; m_Flags = 0;}
	inline				CPath(const CPath & path)
							 {
								 m_strCanon = path.m_strCanon;
								 m_ichLastSlash = path.m_ichLastSlash;
								 m_Flags = path.m_Flags;
							 }
	virtual				~CPath();

	inline	BOOL		GetAlwaysRelative() const { return ((m_Flags & eWantsRelative) != 0); }
	inline	void		SetAlwaysRelative(BOOL bWantsRel = TRUE) { m_Flags =
			(bWantsRel) ? m_Flags | eWantsRelative : m_Flags & ~eWantsRelative;}

	inline	BOOL		IsInit() const { ASSERT(this!=NULL); return (m_ichLastSlash > 0); }

			BOOL		Create(const TCHAR *);
				// Initialize the object, given a filename.  The resulting
				// canonicalized filename will be relative to the current
				// directory.  For example, if the current directory is
				// C:\TEST and the argument is "FOO.C", the resulting
				// canonicalized filename will be "C:\TEST\FOO.C".  If the
				// argument is "..\FOO.C", the resulting canonicalized
				// filename will be "C:\FOO.C".

			BOOL		CreateFromDirAndFilename(const CDir &, const TCHAR *);
				// Initialize the object given a directory (CDir object) and
				// a filename.  This behaves exactly the same as the Create()
				// method, except that the Create() method canonicalizes the
				// filename relative to the CURRENT directory, whereas this
				// method canonicalizes the filename relative to the SPECIFIED
				// directory.

			BOOL		CreateTemporaryName(const CDir &, BOOL fKeep = TRUE);
				// Initialize the object given a directory.  The resulting
				// object will represent a UNIQUE filename in that directory.
				// This is useful for creating temporary filenames.
				//
				// WARNING
				// -------
				// After this method returns, the filename represented by this
				// object will EXIST ON DISK as a zero length file.  This is
				// to prevent subsequent calls to this method from returning
				// the same filename (this method checks to make sure it
				// doesn't return the name of an existing file).  IT IS YOUR
				// RESPONSIBILITY to delete the file one way or another.
				//
				// If you don't want this behavior, pass FALSE for 'fKeep',
				// and the file will not exist on disk.  Be aware, though,
				// that if you do this, subsequent calls to this method may
				// return the same filename.

			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strCanon);
						}
				// Scan the pathname for special character.  We cache this
				// information.

	inline  CPath &		operator =(const CPath & path)
						{
							ASSERT(path.IsInit());
							m_strCanon = path.m_strCanon;
							m_ichLastSlash = path.m_ichLastSlash;
							m_Flags = path.m_Flags;
							return(*this);
						}
				// Assignment operator.

	// Query methods
	inline	const TCHAR * GetFileName() const
					{
						ASSERT(IsInit());
						ASSERT(m_ichLastSlash==m_strCanon.ReverseFind('\\'));
						return ((const TCHAR *)m_strCanon + m_ichLastSlash + 1);
					}

				// Return a pointer to the filename part of the canonicalized
				// pathname, i.e., the filename with no leading drive or path
				// information. Return whole string if no backslash (not init).
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

			VOID		PostFixNumber();
				// Modifies the path by postfixing a number on the end of the path's
				// basename. If there is no number on the end of the path's basename
				// then the number 1 is postfixed. Otherwise if there already is a
				// number on the end of the path's basename then that number is
				// incremented by 1 and postfixed on the end of the basename (less the
				// original number).
				//
				// e.g. foo.cpp -> foo1.cpp -> foo2.cpp -> foo3.cpp
			
			VOID		GetBaseNameString(CString &) const;
				// Creates a CString representing the base name of the fully
				// canonicalized pathname.  For example, the base name of
				// the pathname "C:\FOO\BAR.C" is "BAR".
				//
				// This method can't return a pointer to internal data like
				// some of the other methods since it would have to remove
				// the extension in order to do so.

			VOID  		GetDisplayNameString(
										CString &,
										int cchMax = 16,
										BOOL bTakeAllAsDefault = FALSE
										) const;
				// Creates a CString representing the name of the file
				// shortened to cchMax CHARACTERS (TCHARs, not bytes) or
				// less.  Only the actual characters are counted; the
				// terminating '\0' is not considered, so
				// CString::GetLength() on the result MAY return as much as
				// cchMax.  If cchMax is less than the length of the base
				// filename, the resulting CString will be empty, unless
				// bTakeAllAsDefault is TRUE, in which the base name is
				// copied in, regardless of length.
				//
				// As an example, "C:\SOMEDIR\OTHERDIR\SUBDIR\SPECIAL\FOO.C"
				// will be shortened to "C:\...\SPECIAL\FOO.C" if cchMax is 25.

		inline	const TCHAR * GetExtension() const
					{
						ASSERT(IsInit());
						int iDot = m_strCanon.ReverseFind(_T('.'));
 						if (iDot < m_ichLastSlash)
							iDot = m_strCanon.GetLength();
						const TCHAR * retval = ((const TCHAR *)m_strCanon) + iDot;
 						return retval;
					}

				// Return a pointer to the extension part of the canonicalized
				// pathname.  Returns a pointer to the '.' character of the
				// extension.  If the filename doesn't have an extension,
				// the pointer returned will point to the terminating '\0'.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	const TCHAR * GetFullPath() const { return(m_strCanon); }
				// Return a pointer to the full (canonicalized) pathname.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!
	inline	const TCHAR * GetFullPath(CString & strPath) const { return(strPath = m_strCanon); }

	inline	BOOL		IsActualCase() const { ASSERT(this!=NULL); return ((m_Flags & eIsActualCase)!=0); }
	void GetActualCase(BOOL bEntirePath = FALSE);
				// Adjusts the paths case to match the actual path and filename
				// on disk.
	void SetActualCase(LPCTSTR pszFileCase); 
				// Adjusts the paths case to match the actual path and filename
				// on disk, where pszFileCase already contains the correct case
				// for just the filename portion.
	static void ResetDirMap();

	inline				operator const TCHAR *() const { return(m_strCanon); }
				// Return the fully canonicalized filename as a (const TCHAR *).
				// Same thing as GetFullPath(), but more convenient in some
				// cases.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	BOOL		IsUNC() const { return(m_strCanon[0] == _T('\\')); }
				// Returns TRUE if the pathname is UNC (e.g.,
				// "\\server\share\file"), FALSE if not.

	inline BOOL IsEmpty() const { return (m_strCanon.IsEmpty()); }

	// Comparison methods

			int			operator ==(const CPath &) const;
				// Returns 1 if the two CPaths are identical, 0 if they are
				// different.

	inline	int			operator !=(const CPath & path) const { return(!(operator ==(path))); }
				// Returns 1 if the two CPaths are different, 0 if they are
				// identical.

	// Modification methods

			VOID		ChangeFileName(const TCHAR *);
				// Changes the file name to that specified by the
				// (const TCHAR *) argument.  The directory portion of the
				// pathname remains unchanged.  DO NOT pass in anything
				// other than a simple filename, i.e., do not pass in
				// anything with path modifiers.

			VOID		ChangeExtension(const TCHAR *);
				// Changes the extension of the pathname to be that specified
				// by the (const TCHAR *) argument.  The argument can either be
				// of the form ".EXT" or "EXT".  If the current pathname has
				// no extension, this is equivalent to adding the new extension.

			BOOL 		GetRelativeName (const CDir&, CString&, BOOL bQuote = FALSE, BOOL bIgnoreAlwaysRelative = FALSE) const;
				// Makes the path name relative to the supplied directory and
				// placed the result in strResult.  Function will only go
				// down from the supplied directy (no ..'s).  Returns TRUE if
				// relativization was successful, or FALSE if not (e.g. if
				// string doesn't start with ".\" or ..\ or at least \).
				//
				// Thus, if the base directory is c:\sushi\vcpp32:
				//
				//  s:\sushi\vcpp32\c\fmake.c => s:\sushi\vcpp32\c\fmake.c
				//  c:\sushi\vcpp32\c\fmake.c => .\fmake.c
				//  c:\dolftool\bin\cl.exe    => \dolftool\bin\cl.exe
				//	\\danwhite\tmp\test.cpp   => \\danwhite\tmp\test.cpp

				// Thus, if the base directory is \\danwhite\c$\sushi\vcpp32:
				//
				// \\danwhite\c$\dolftool\bin\cl.exe => \dolftool\bin\cl.exe
				// \\danwhite\tmp\test.cpp           => \\danwhite\tmp\test.cpp

				// If bQuote is true, then quotes are put around the relative
				// file name. (Useful for writing the filename out to a file)

				// If (!bIgnoreAlwaysRelative && GetAlwaysRelative()) is TRUE
				// and if the file is on the same drive we will ALWAYS
				// relativize it. Thus for the base dir c:\sushi\vcpp32
				//  c:\dolftool\bin\cl.exe    => ..\..\dolftool\bin\cl.exe

			BOOL        CreateFromDirAndRelative (const CDir&, const TCHAR *);
				// THIS FUNCTION IS OBSOLETE.  New code should use
				// CreateFromDirAndFilename().  The only difference between
				// that function and this one is that this one will
				// automatically remove quotes from around the relative
				// path name (if present).


	// Miscellaneous methods
	inline	BOOL		IsReadOnlyOnDisk() const
						{
							HANDLE	h;

							ASSERT(IsInit());
							h = CreateFile(m_strCanon, GENERIC_WRITE,
								FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL, NULL);

							if (h == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND)
								return TRUE;

							if (h != INVALID_HANDLE_VALUE)
								CloseHandle(h);

							return FALSE;
						}
				// Returns TRUE if the filename represented by this object
				// is read-only on disk, FALSE if not.  NOT guaranteed to
				// work in all circumstances -- for example, will not return
				// TRUE for a file on a floppy drive that has been write-
				// protected.  I don't know of any way to get this information
				// from NT (GetFileAttributes doesn't work; GetVolumeInformation
				// doesn't work; _access just calls GetFileAttributes; etc.).
				// This method WILL correctly detect:
				//		- Files marked as read-only
				//		- Files on read-only network drives

	inline	BOOL		ExistsOnDisk() const
						{
							ASSERT(IsInit());
							return(_access(m_strCanon, 00) != -1);
						}
				// Returns TRUE if the filename represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CanCreateOnDisk(BOOL fOverwriteOK = FALSE) const
						{
							ASSERT(IsInit());
							if (!fOverwriteOK && ExistsOnDisk())
								return(FALSE);
							int hFile = _creat(m_strCanon, _S_IREAD | _S_IWRITE);
							BOOL fCreate = (hFile != -1);
							if (fCreate)
							{
								VERIFY(_close(hFile) == 0);
								VERIFY(_unlink(m_strCanon) == 0);
							}
							return(fCreate);
						}
				// Returns TRUE if the filename represented by this object
				// can be created on disk, FALSE if not.

	inline	BOOL		DeleteFromDisk() const
						{
							ASSERT(IsInit());
#ifdef _WIN32
							return(DeleteFile((TCHAR *)(const TCHAR *)m_strCanon));
#else
							return(remove(m_strCanon) != -1);
#endif
						}
				// Removes the file represented by this object from the disk.

	BOOL GetFileTime(LPFILETIME lpftLastWrite);
	BOOL GetFileTime(CString& rstrLastWrite, DWORD dwFlags = DATE_SHORTDATE);
	// Returns the last modified time, as either an FILETIME struct or a string
};
//	Creation and destruction functions used by CMapPathToOb:

extern const CString AFX_DATA pthEmptyString;

static inline VOID ConstructElement(CPath * pNewData)
{
	memcpy(&pNewData->m_strCanon, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CPath * pOldData)
{
	pOldData->m_strCanon.Empty();
}


//	File Name Utility Functions
//		These are redundant and could be replaced with use of CPath, but are
//		kept since they are easier to use and already exist in VRES.

// Remove the drive and directory from a file name.
CString StripPath(LPCTSTR szFilePath);

// Remove the name part of a file path.  Return just the drive and directory.
CString StripName(LPCTSTR szFilePath);

// Get only the extension of a file path.
CString GetExtension(LPCTSTR szFilePath);

// Return the path to szFilePath relative to szDirectory.  (e.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
//
CString GetRelativeName(LPCTSTR szFilePath, LPCTSTR szDirectory = NULL);

// Makes a file path look like in MRU.
CString GetDisplayName(LPCTSTR szFilePath, int nMaxDisplayLength,
	LPCTSTR szDirectory = NULL);

BOOL FileExists(LPCTSTR szFilePath);
BOOL IsFileWritable(LPCTSTR szFilePath);

UINT SushiGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);

//////////////////////////////////////////////////////////////////////
// CDir
//
// The CDir object represents a file system directory on some disk.
//
// A CDir object can be created to represent the current directory,
// to represent the directory of a CPath object (i.e., the directory
// in which a file resides), and to represent a temporary directory.
// Note that a CDir object CANNOT be created given an arbitrary string --
// this is intentional, since this should not be necessary.
//
// The string representation of a CDir object (e.g., operator const TCHAR *())
// MAY or MAY NOT end in '\'.  The root directory of a local drive (e.g., C:)
// will end in '\' ("C:\"), while other directories on a local drive will
// not ("C:\OTHERDIR").  The root directory on a REMOTE drive will NOT end
// in '\' ("\\server\share").  Don't make any assumptions about whether or
// not the string representation ends in '\'.
//
// See also several CPath methods which use CDir objects.

class LTAPIENTRY CDir : public CObject
{
	DECLARE_DYNAMIC(CDir)

	friend	class		CPath;

	friend	static VOID		ConstructElement(CDir *);
	friend	static VOID		DestructElement(CDir *);

protected:
			CString		m_strDir;
				// Directory name, including drive letter or
				// server/share.  Do NOT make any assumptions
				// about whether or not this ends in '\'!

			// Creates multi level directories just fine
			BOOL MakeDirectory(LPCTSTR lpszPathName) const;
public:
	// Constructors, destructors, initialization methods
	inline				CDir() {}
	inline				CDir(const CDir & dir) { m_strDir = dir.m_strDir; }
	virtual				~CDir();

			BOOL		CreateFromCurrent();
				// Initialize from the current working directory.  This
				// may fail if the current working directory is unknown
				// or invalid.

			BOOL		CreateFromPath(const CPath &);
				// Initialize based on the directory of the specified
				// CPath object.  That is, if the CPath object represents
				// the file "C:\FOO\BAR\BLIX.C", the resulting directory
				// for this object will be "C:\FOO\BAR".  Returns FALSE
				// on failure.

			BOOL		CreateFromPath(const TCHAR *pszPath);
				// Initialize based on the directory of the specified
				// string.  That is, if the string contains the file name
				// "C:\FOO\BAR\BLIX.C", the generated directory for this
				// string will be "C:\FOO\BAR".  Returns FALSE on failure.

			BOOL		CreateTemporaryName();
				// Initialize this object to represent a temporary directory
				// on disk (e.g., "C:\TMP").

			inline BOOL		CreateFromString(const TCHAR * sz)
					{
						return  CreateFromStringEx(sz, FALSE);
					}	
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!

			BOOL		CreateFromStringEx(const TCHAR * sz, BOOL fRootRelative);
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!
				// same as CreateFromString with minor change. Not treating as bug fix to CFS
				// due to lateness in VC 4.0 project time

				// if fRootRelative true, treat dir ending with colon as relative not root dir 
				// (actual correct handling)


			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strDir);
						}
				// Scan the pathname for special character.  We cache this information.

	inline	CDir &		operator =(const CDir & dir)
						{
							m_strDir = dir.m_strDir;
							return(*this);
						}
				// Assignment operator.

	// Query methods

	inline				operator const TCHAR *() const { return(m_strDir); }
				// Return the directory name as a (const TCHAR *) string.

	inline int GetLength() const { return m_strDir.GetLength(); }
	      // Returns the length of the directory name

	// Miscellaneous methods

	BOOL	MakeCurrent() const;
				// Make this object the current working directory.  May fail
				// if the directory no longer exists (e.g., a floppy drive).

	inline	BOOL		ExistsOnDisk() const
						{
							// Tests if the directory exists.  We return FALSE
							// if <m_strDir> exists but is not a directory
							struct _stat statDir;
							if (_stat(m_strDir, &statDir) == -1)
								return FALSE;		 // Not found.
							else if (!(statDir.st_mode & _S_IFDIR))
								return FALSE;		 // Not a directory.
							else
								return TRUE;
						}
				// Returns TRUE if the directory represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CreateOnDisk() const { return MakeDirectory(m_strDir); }
				// Creates the directory on disk.  If this fails, returns
				// FALSE.  If the directory already existed on disk, returns
				// TRUE (i.e., that is not an error condition).

	inline	BOOL		RemoveFromDisk() const { return RemoveDirectory(m_strDir); }
				// Removes the directory from the disk.  If this fails for
				// any reason (directory does not exist, directory is not
				// empty, etc.), returns FALSE.

			BOOL		IsRootDir() const;
				// Returns TRUE if the directory represented by this object
				// is a root directory (e.g., "C:\"), FALSE if not.  Note that
				// calling this method will NOT tell you whether or not the
				// string representation ends in '\', since "\\server\share"
				// is a root directory, and does not end in '\'.

	inline	BOOL		IsUNC() const { return(m_strDir[0] == _T('\\')); }
				// Returns TRUE if this is a UNC directory, FALSE if not.

			VOID		AppendSubdirName(const TCHAR *);
				// Adds a subdirectory name.  For example, if this object
				// currently represents "C:\FOO\BAR", and the argument is
				// "$AUTSAV$", the resulting object represents
				// "C:\FOO\BAR\$AUTSAV$".
				//
				// WARNING: This method does NO validation of the result --
				// it does not check for illegal characters, or for a
				// directory name that is too long.  In particular, don't
				// pass "DIR1/DIR2" as an argument, since no conversion
				// (of '/' to '\') will occur.

			VOID		RemoveLastSubdirName();
				// Removes the last component of the directory name.  For
				// example, if this object currently represents
				// "C:\FOO\BAR\$AUTSAV$", after this method it will
				// represent "C:\FOO\BAR".  If you try to call this method
				// when the object represents a root directory (e.g., "C:\"),
				// it will ASSERT.

	// Comparison methods

			int			operator ==(const CDir &) const;
				// Returns 1 if the two CDirs are identical, 0 if they are
				// different.

	inline	int			operator !=(const CDir & dir) const { return(!(operator ==(dir))); }
				// Returns 1 if the two CDirs are different, 0 if they are
				// identical.
};

//	Creation and destruction functions used by CMapDirToOb:

static inline VOID ConstructElement(CDir * pNewData)
{
	memcpy(&pNewData->m_strDir, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CDir * pOldData)
{
	pOldData->m_strDir.Empty();
}

///////////////////////////////////////////////////////////////////////////////
//	CCurDir
//		This class is used to switch the current drive/directory during the
//		life of the object and to restore the previous dirve/directory upon
//		destruction.

class LTAPIENTRY CCurDir : CDir
{
public:
	CCurDir(const char* szPath, BOOL bFile = FALSE);
	CCurDir(const CDir& dir);
	CCurDir();	// just saves the current directory and resets it
	~CCurDir();

	CDir m_dir;
};


///////////////////////////////////////////////////////////////////////////////
//	CFileOpenReturn
//		This class represents the return value from the Common Dialogs
//		File.Open.  It handles both single and multiple select types.
//

class LTAPIENTRY CFileOpenReturn : CObject
{
	BOOL		m_bSingle;
	BOOL		m_bBufferInUse;
	BOOL		m_bArrayHasChanged;

	int			m_cbData;
	_TCHAR * 	m_pchData;

	// Multiple Files
	CPtrArray	m_rgszNames;

public:
	CFileOpenReturn (const _TCHAR * szRawString = NULL);
	~CFileOpenReturn ();

	inline BOOL IsSingle () const;
	inline BOOL IsDirty() const;
	inline BOOL BufferOverflow () const;
	//inline int  GetLength () const;

	// GetBuffer gives permission for something else to directly change the buffer
	// ReleaseBuffer signifies that the something else is done with it.
	_TCHAR * GetBuffer (int cbBufferNew);
	inline void ReleaseBuffer ();

	// allows the object to be re-initialized
	void ReInit (const _TCHAR * szRawString);

	// This supports the dynamic file extension update in OnFileNameOK().
	void ChangeExtension (int i, const CString& szExt);

	void CopyBuffer (_TCHAR * szTarget);

	// This is the function to use to get at the user's selections,
	// whether single or multiple.
	BOOL GetPathname (int i, CString& strPath) const;

private:
	void GenArrayFromBuffer ();
	void GenBufferFromArray ();
	void ClearNamesArray ();
	void SetBuffer (const _TCHAR * szRawString);	
};


inline BOOL CFileOpenReturn::IsSingle () const
{
	return m_bSingle;
}

inline BOOL CFileOpenReturn::IsDirty() const
{
	return m_bArrayHasChanged;
}

inline BOOL CFileOpenReturn::BufferOverflow () const
{
	return m_cbData == 2 && m_pchData[0] == '?';
}

///// ReleaseBuffer - Tell object we're done changing the buffer
//
//	Processes the raw string
//
///
inline void CFileOpenReturn::ReleaseBuffer ()
{
	m_bBufferInUse = FALSE;
	GenArrayFromBuffer ();
}

///////////////////////////////////////////////////////////////////////////////
//	Smart case helpers.
//		These functions are used to do smart casing of paths and file extensions.

extern BOOL GetActualFileCase( CString& rFilename, LPCTSTR lpszDir = NULL );
extern LPCTSTR GetExtensionCase( LPCTSTR lpszFilename, LPCTSTR lpszExtension );

extern BOOL GetDisplayFile(CString &rFilename, CDC *pDC, int &cxPels); // truncates from left

/////////////////////////////////////////////////////////////////////////////
#pragma warning(default : 4275 4251)

#endif // __PATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\redvisit.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REDVISIT.INL

History:

--*/

inline
CRichEditDeltaVisitor::CRichEditDeltaVisitor(
	CRichEditCtrl & red) :
	m_red(red)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\refcount.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REFCOUNT.H

History:

--*/

#pragma once



class LTAPIENTRY CRefCount
{
public:
	CRefCount();

	//
	//  Declared as STDMETHOD so as compatible with COM.
	//
	STDMETHOD_(ULONG, AddRef)(void);
	STDMETHOD_(ULONG, Release)(void);

	//
	//
	ULONG AddRef(void) const;
	ULONG Release(void) const;
	
protected:
	
	virtual ~CRefCount() = 0;

private:

	CRefCount(const CRefCount &);
	const CRefCount & operator=(const CRefCount &);
	UINT operator==(const CRefCount &);
	
	mutable UINT m_uiRefCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\reghelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REGHELP.H

History:

--*/

#if !defined(MITUTIL_RegHelp_h_INCLUDED)
#define MITUTIL_RegHelp_h_INCLUDED

#pragma once

//------------------------------------------------------------------------------
class LTAPIENTRY CRegHelp
{
public:
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, CString & stValue);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, DWORD & dwNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, long & nNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, BOOL & fNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, VARIANT_BOOL & fNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, GUID & guid);
};

#endif // MITUTIL_RegHelp_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESOURCE.H

History:

--*/
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mitutil.rc
//
#define IDS_BAD_UNICODE_CHAR            12700
#define IDS_BAD_CODE_PAGE               12701
#define IDS_UIVAL_ON                    12702
#define IDS_UIVAL_OFF                   12703
#define IDS_UIVAL_TRUE                  12704
#define IDS_UIVAL_FALSE                 12705
#define IDS_UIVAL_YES                   12706
#define IDS_UIVAL_NO                    12707
#define IDS_UIVAL_BLOB                  12708
#define IDS_HEX_MUST_BE_4DIGITS         12709
#define IDS_INVALID_ESCAPE              12710

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\smartptr.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SMARTPTR.INL

History:

--*/

template <class T>
SmartPtr< T >::SmartPtr()
{
	m_pObject = NULL;
}



template <class T>
SmartPtr< T >::SmartPtr(
		T *pObject)
{
	m_pObject = pObject;
}



template <class T>
T &
SmartPtr< T >::operator*(void)
		const
{
	LTASSERT(m_pObject != NULL);
	return *m_pObject;
}



template <class T>
T *
SmartPtr< T >::operator->(void)
		const
{
	LTASSERT(m_pObject != NULL);
	
	return m_pObject;
}


template <class  T>
T *
SmartPtr< T >::Extract(void)
{
	T *pObj = m_pObject;
	m_pObject = NULL;

	return pObj;
}



template <class T>
T*
SmartPtr< T >::GetPointer(void)
{
	return m_pObject;
}


template <class T>
const T*
SmartPtr< T >::GetPointer(void) const
{
	return m_pObject;
}


template <class T>
BOOL
SmartPtr< T >::IsNull(void)
		const
{
	return m_pObject == NULL;
}



template <class T>
void
SmartPtr< T >::operator=(
		T *pObject)
{
	LTASSERT(m_pObject == NULL);

	if (m_pObject != NULL)
	{
		delete m_pObject;
	}
	m_pObject = pObject;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  This should only be used to init a smart pointer.
//  
//-----------------------------------------------------------------------------
template <class T>
SmartPtr< T >::operator T * & (void)
{
	LTASSERT(m_pObject == NULL);
	
	return m_pObject;
}


template <class T>
void
SmartPtr< T >::operator delete(
		void *)
{
	LTASSERT(m_pObject != NULL);

	delete m_pObject;
	m_pObject = NULL;
}



template <class T>
SmartPtr< T >::~SmartPtr()
{
	if (m_pObject != NULL)
	{
		delete m_pObject;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\smartptr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SMARTPTR.H

History:

--*/


#ifndef ESPUTIL_SMARTPTR_H
#define ESPUTIL_SMARTPTR_H



template<class T>
class SmartPtr
{
public:
	NOTHROW SmartPtr();
	NOTHROW SmartPtr(T *);

	NOTHROW T & operator*(void) const;
	NOTHROW T * operator->(void) const;
	NOTHROW T* Extract(void);
	NOTHROW T* GetPointer(void);
	NOTHROW const T * GetPointer(void) const;
	NOTHROW BOOL IsNull(void) const;
	
	void operator=(T *);
	operator T* &(void);

	NOTHROW ~SmartPtr();
	
private:
	T *m_pObject;

	SmartPtr(const SmartPtr<T> &);
	void operator=(const SmartPtr<T> &);
	
	//
	//  This hackery prevents Smart Pointer from being on the heap
	//
	void operator delete(void *);
};

#include "smartptr.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\smartref.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SMARTREF.H

History:

--*/
#ifndef ESPUTIL_SmartRef_H
#define ESPUTIL_SmartRef_H


template<class T>
class SmartRef
{
private:
	T *m_pInterface;

public:
	NOTHROW SmartRef()
	{
		m_pInterface = NULL;
	}

	//  Compiler bug, must be inline!
	NOTHROW SmartRef(T *pI) {m_pInterface = pI;};
	NOTHROW SmartRef(const SmartRef<T> &);

	NOTHROW T * operator->(void)
	{
		LTASSERT(m_pInterface != NULL);
		return m_pInterface;
	}
	
	NOTHROW const T * operator->(void) const
	{
		LTASSERT(m_pInterface != NULL);
		return m_pInterface;
	}
	
	NOTHROW T & operator*(void)
	{
		LTASSERT(m_pInterface != NULL);
		return *m_pInterface;
	}
	NOTHROW T * Extract(void)
	{
		return ExtractImpl();
	};
	
	NOTHROW T * GetInterface(BOOL fAddRef = FALSE)	
	{
		return GetInterfaceImpl(fAddRef);
	};

	NOTHROW const T * GetInterface(void) const
	{
		return m_pInterface;
	}
	
	NOTHROW BOOL IsNull(void) const
	{
		return m_pInterface == NULL;
	}
	
	NOTHROW ~SmartRef()
	{
		if (m_pInterface != NULL)
		{
			m_pInterface->Release();
		}
	}

	void operator=(T* pOther)
	{
		opEqImpl(pOther);
	}
	void operator=(const SmartRef<T> &other);

	T ** operator&(void);
	operator T* &(void) {return opTpRef();};
	
private:
	void operator delete(void *);

	NOTHROW T * ExtractImpl(void);
	NOTHROW T * GetInterfaceImpl(BOOL fAddRef);
	NOTHROW T * & opTpRef(void);
	void opEqImpl(T* pOther);

};

#include "SmartRef.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\stacktrace.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STACKTRACE.H

History:

--*/

//  
//  Provides a mechanism for generating stacktraces and converting them to
//  human readable form.
//  
 
#ifndef ESPUTIL_STACKTRACE_H
#define ESPUTIL_STACKTRACE_H


const UINT MODULE_NAME_LEN = 64;
const UINT SYMBOL_NAME_LEN = 128;


//
//  'human readable' form of a stack-frame.  Provides module and function name.
struct SYMBOL_INFO1
{
	DWORD dwAddress;
	DWORD dwOffset;
    TCHAR szModule[MODULE_NAME_LEN];
    TCHAR szSymbol[SYMBOL_NAME_LEN];
	BOOL fSymbolLocated;
};

#pragma warning(disable:4275)

//
//  How we return a complete human readable stack walk.
//
class LTAPIENTRY CSymbolList : public CTypedPtrList<CPtrList, SYMBOL_INFO1 *>
{
public:
	CSymbolList();

	void Clear(void);
	~CSymbolList();

private:
	CSymbolList(const CSymbolList &);
	void operator=(const CSymbolList &);
};

#pragma warning(default:4275)	

//
//  Class for generating stack traces.  Provides both native (compact) data
//  (in case you want to store it for later), and a human (versbose) form.
//
#pragma warning(disable : 4251)
class LTAPIENTRY CStackTrace
{
public:
	CStackTrace();

	~CStackTrace();

	void CreateStackTrace(void);
	void CreateStackTrace(UINT nSkip, UINT nTotal);
	void SetAddresses(const CDWordArray &);
	
	const CDWordArray &GetAddresses(void) const;

	void GetSymbolList(CSymbolList &) const;
	
private:
	CStackTrace(const CStackTrace &);
	void operator=(const CStackTrace &);

	CDWordArray m_adwAddresses;
};
#pragma warning(default : 4251)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_)
#define AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_

#pragma once


// StrigBlast requires the CString implicit conversions.
#ifdef _LS_NO_IMPLICIT
#undef _LS_NO_IMPLICIT
#endif // #ifdef _LS_NO_IMPLICIT

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>
#include <afxdisp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\smartref.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SMARTREF.INL

History:

--*/

template <class T>
SmartRef< T >::SmartRef(
		const SmartRef<T> &other)
{
	m_pInterface = const_cast<T *>(other.m_pInterface);
	m_pInterface->AddRef();
}



template <class T>
void
SmartRef< T >::operator=(
		const SmartRef<T> &pInterface)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
	}
	m_pInterface = ((SmartRef<T> &)pInterface).GetInterface(TRUE);
}



template <class T>
T **
SmartRef< T >::operator&(void)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
		m_pInterface = NULL;
	}

	return &m_pInterface;
}



template <class T>
T *
SmartRef< T >::ExtractImpl(void)
{
	T *pInterface = m_pInterface;
	m_pInterface = NULL;
	return pInterface;
}


template <class T>
T *
SmartRef< T >::GetInterfaceImpl(
	BOOL fAddRef /*= FALSE*/)
{
	// Should never ask to AddRef with a NULL pointer

	LTASSERT(!fAddRef || NULL != m_pInterface);

	if (fAddRef)
	{
		m_pInterface->AddRef();
	}

	return m_pInterface;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
// This should only be used to init a smart pointer.
// 
//-----------------------------------------------------------------------------
template <class T>
T * &
SmartRef< T >::opTpRef(void)
{
	LTASSERT(m_pInterface == NULL);
	
	return m_pInterface;
}


template <class T>
void
SmartRef< T >::opEqImpl(
		T *pOther)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
	}
	m_pInterface = pOther;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\stringblast.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STRINGBLAST.H

History:

--*/

#if !defined(MITUTIL__StringBlast_h__INCLUDED)
#define MITUTIL__StringBlast_h__INCLUDED

//------------------------------------------------------------------------------
struct LTAPIENTRY StringBlast
{
// Fast Win32 conversions
	static CLString MakeString(_bstr_t bstrSrc);
	static CLString MakeString(const CPascalString & pasSrc);
	static CLString MakeStringFromBStr(BSTR bstrSrc);
	static CLString MakeStringFromWide(const wchar_t * szwSrc);

	static _bstr_t MakeBStr(const char * szBuffer);
	static _bstr_t MakeBStrFromWide(const wchar_t * wszBuffer);
	static _bstr_t MakeBStr(const CLString & stSrc);
	static _bstr_t MakeBStrFromBStr(BSTR bstrSrc);
	static _bstr_t MakeBStr(const CPascalString & pasSrc);
	static _bstr_t MakeBStr(HINSTANCE hDll, UINT nStringID);

	// Use these functions when you need to get a raw BSTR
	static BSTR MakeDetachedBStr(const char * szBuffer);
	static BSTR MakeDetachedBStrFromWide(const wchar_t * wszBuffer);
	static BSTR MakeDetachedBStr(const CLString & stSrc);

};

#endif // MITUTIL__StringBlast_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\stringtokenizer.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STRINGTOKENIZER.H

History:

--*/

//
//  This file declares the CStringTokenizer class, which implements simple
//  linear tokenization of a String. The set of delimiters, which defaults
//  to common whitespace characters, may be specified at creation time or on a 
//  per-token basis.
//  Example usage:
//	CString s = "a test string";
//	CStringTokenizer st = new CStringTokenizer(s);
//	while (st.hasMoreTokens())
//  {
//		cout << st.nextToken() << endl;
//	}

#pragma once

#ifndef StringTokenizer_h
#define StringTokenizer_h

class LTAPIENTRY CStringTokenizer 
{
public:
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer with default delimiters
//-----------------------------------------------------------------------------
  CStringTokenizer();
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer with default delimiters
//   str - in, the string to be tokenized
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer
//   str - in, the string to be tokenized
//   delimiters - in, the delimiters; null terminated
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str, const WCHAR* delimiters);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer
//   str - in, the string to be tokenized
//   delimiters - in, the delimiters; null terminated
//   returnTokens - in, TRUE indicates return delimiter as token
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str,
                   const WCHAR* delimiters,
                   BOOL  returnTokens);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// destructs this tokenizer
//-----------------------------------------------------------------------------
  virtual ~CStringTokenizer();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// configure whether return delimiter as token
//   returnTokens - in, TRUE indicates return delimiter as token
//-----------------------------------------------------------------------------
  void setReturnTokens(BOOL returnTokens);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// sets delimiters
//   delimiters - in, the delimiters; null terminated
//-----------------------------------------------------------------------------
  void setDelimiters(const WCHAR* delimiters);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// parse a string to be tokenized
//   str - in, the null terminated string
//-----------------------------------------------------------------------------
  void parse(const WCHAR* str);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// checks whether there are more tokens
//-----------------------------------------------------------------------------
  BOOL hasMoreTokens();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// get next token
//   length - out, the length of the token
//   return the pointer to the begining of the token
//-----------------------------------------------------------------------------
  const WCHAR* nextToken(unsigned int & length);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// count total number of tokens
//-----------------------------------------------------------------------------
  int     countTokens();

private:
  void skipDelimiters();
  int  IsDelimiter(WCHAR ch) const;

  int          m_currentPosition;
  int          m_maxPosition;
  const WCHAR* m_str;
  WCHAR*       m_delimiters;
  int          m_lenDelimiters;
  BOOL         m_retTokens;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\strlist.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STRLIST.INL

History:

--*/

template <class T>
CLocThingList<T>::CLocThingList()
{
	m_fAdditionsAllowed = FALSE;
	m_uiIndex = NO_INDEX;
}


template <class T>
UINT
CLocThingList<T>::GetIndex(void)
		const
{
	return m_uiIndex;
}



template <class T>
const CArray<T, T&> &
CLocThingList<T>::GetStringArray(void)
		const
{
	return m_aThings;
}



template <class T>
BOOL
CLocThingList<T>::AdditionsAllowed(void)
		const
{
	return m_fAdditionsAllowed;
}



template <class T>
void
CLocThingList<T>::SetThingList(
		const CArray<T, T&> &aNewThings)
{
	UINT uiNewSize = aNewThings.GetSize();
	
	m_aThings.SetSize(uiNewSize);

	for (UINT i=0; i<uiNewSize; i++)
	{
		m_aThings[i] = aNewThings[i];
	}
}



template <class T>
inline
UINT
CLocThingList<T>::AddThing(
		T &NewThing)
{
	return m_aThings.Add(NewThing);
}


template <class T>
inline
void
CLocThingList<T>::InsertThing(
		UINT idxInsert, 
		T & tNew
		)
{
	m_aThings.InsertAt(idxInsert, tNew);
}


template <class T>
inline
BOOL
CLocThingList<T>::DeleteThing(
		UINT iIndex)
{
    BOOL fRetVal = FALSE;
	if (iIndex < GetSize())
	{
		m_aThings.RemoveAt(iIndex);
		fRetVal = TRUE;
	}
	return fRetVal;	
}



template <class T>
inline
BOOL
CLocThingList<T>::SetIndex(
		UINT uiNewIndex)
{
	m_uiIndex = uiNewIndex;
	return FALSE;
}



template <class T>
inline
void
CLocThingList<T>::SetAdditionsAllowed(
		BOOL fAllowed)
{
	m_fAdditionsAllowed = fAllowed;
}


template <class T>
inline
UINT
CLocThingList<T>::GetSize()
{
	return m_aThings.GetSize();
}


template <class T>
const CLocThingList<T> &
CLocThingList<T>::operator=(
		const CLocThingList<T>& slOther)
{
	SetThingList(slOther.GetStringArray());
	SetIndex(slOther.GetIndex());

	SetAdditionsAllowed(slOther.AdditionsAllowed());
	
	return *this;
}


template <class T>
CLocThingList<T>::~CLocThingList()
{
	m_aThings.SetSize(0);
}

template <class T>
inline
int 
CLocThingList<T>::operator==(
		const CLocThingList<T>& list)
		const
{
	if (m_uiIndex != list.m_uiIndex
		|| m_fAdditionsAllowed != list.m_fAdditionsAllowed
		|| m_aThings.GetSize() != list.m_aThings.GetSize())
	{
		return 0;
	}

	for (int i=m_aThings.GetUpperBound(); i>=0; i--)
	{
		if (m_aThings[i] != list.m_aThings[i])
		{
			return 0;
		}
	}
	
	return 1;
}

template <class T>
inline
int 
CLocThingList<T>::operator!=(
		const CLocThingList<T>& list)
		const
{
	return !(operator==(list));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\uiopthelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UIOPTHELP.H

History:

--*/

//  Class used to represent a single 'option'.
 
#pragma once

//
// Base structure
//
struct UI_OPTS_BASE
{
	TCHAR* pszName;				   // internal name of the option 
	UINT nDisplayName;			   // string id of the display name
	UINT nDisplayHelp;			   // string id of the help string
	PFNOnValidateUIOption pfnVal;    // function to call during validation. 
	                               // This may be null
	WORD wStorageTypes;			   // storage type of option	
	CLocUIOptionDef::ControlType wReadOnly;	  // ReadOnly value
	CLocUIOptionDef::ControlType wVisible;	  // Visible value
};



// Structures of option data

//
// BOOL options
//

struct UI_OPTS_BOOL
{
	UI_OPTS_BASE base;                // base class data 
	BOOL bDefValue;				   // default value of the option
	CLocUIOption::EditorType et;     // type of BOOL option
};

//
//  PICK options
//

struct UI_OPTS_PICK
{
	UI_OPTS_BASE base;                // base class data 
	DWORD dwDefValue;			   // default value of the option
	BOOL bAdd;					   // allow additions to the list	
	UINT nListEntries;             // list of entries to pick from
	                               // Each entry is separated by \n
	                               // The last entry does not have a \n
};

const TCHAR UI_PICK_TERMINATOR = _T('\n');

// 
// DWORD options

struct UI_OPTS_DWORD
{
	UI_OPTS_BASE base;                // base class data 
	DWORD dwDefValue;			   // default value of the option
	CLocUIOption::EditorType et;     // type of DWORD option
};


//
// String options
//
struct UI_OPTS_STR
{
	UI_OPTS_BASE base;                // base class data 
	UINT nDefValue;				   // string table entry for default value 
	CLocUIOption::EditorType et;
};


//
//  String list options
//

struct UI_OPTS_STRLIST
{
	UI_OPTS_BASE base;					// base class data 
	UINT nDefList;						// Each entry is separated by \n
										// The last entry does not have a \n
};


//
// File Name options
//
struct UI_OPTS_FILENAME
{
	UI_OPTS_BASE base;                // base class data 
	UINT nExtensions;	    		  // The default extensions to the UI
	UINT nDefValue;			  	      // string table entry for default value 
};


//
// Helper class definition
//

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUIOptionImpHelper : public CObject
{
public:

	CLocUIOptionImpHelper(HINSTANCE hInst);

	void GetOptions(CLocUIOptionSet *pOptionSet, UINT nDesc, UINT nHelp);
	
	void SetBools(const UI_OPTS_BOOL* pBools, int nCntBools);
	void SetPicks(const UI_OPTS_PICK* pPicks, int nCntPicks);
	void SetDwords(const UI_OPTS_DWORD* pDwords, int nCntDwords);
	void SetStrs(const UI_OPTS_STR* pStrs, int nCntStrs);
	void SetStrLists(const UI_OPTS_STRLIST* pStrLists, int nCntStrLists);
	void SetFNames(const UI_OPTS_FILENAME* pFNames, int nCntFNames);

	void AssertValid(void) const;

protected:
	HINSTANCE m_hInst;

	const UI_OPTS_BOOL* m_pBools;
	int m_nCntBools;

	const UI_OPTS_PICK* m_pPicks;
	int m_nCntPicks;

	const UI_OPTS_DWORD* m_pDwords;
	int m_nCntDwords;

	const UI_OPTS_STR* m_pStrs;
	int m_nCntStrs;

	const UI_OPTS_STRLIST* m_pStrLists;
	int m_nCntStrLists;

	const UI_OPTS_FILENAME* m_pFNames;
	int m_nCntFNames;

	void GetBoolOptions(CLocUIOptionSet* pOptionSet);
	void GetPicksOptions(CLocUIOptionSet* pOptionSet);
	void GetDwordsOptions(CLocUIOptionSet* pOptionSet);
	void GetStrsOptions(CLocUIOptionSet* pOptionSet);
	void GetStrListsOptions(CLocUIOptionSet* pOptionSet);
	void GetFNamesOptions(CLocUIOptionSet* pOptionSet);

	void GetListFromId(UINT nId, CPasStringList& pasList);
	void GetStringFromId(UINT nId, CPascalString& pas);
};

#pragma warning(default : 4275)

//
// Helper macros for building data structures
//
// The _EXT versions of the macros allow setting the less common
// attributes (readonly and visible)
//


// BOOL
#define BEGIN_LOC_UI_OPTIONS_BOOL(var) \
const UI_OPTS_BOOL var[] =    \
{								 

#define LOC_UI_OPTIONS_BOOL_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, et}

#define LOC_UI_OPTIONS_BOOL_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, et}

#define END_LOC_UI_OPTIONS_BOOL() \
}                             



// Pick
#define BEGIN_LOC_UI_OPTIONS_PICK(var) \
const UI_OPTS_PICK var[] = \
{

#define LOC_UI_OPTIONS_PICK_ENTRY(name, def, add, list, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, add, list}

#define LOC_UI_OPTIONS_PICK_ENTRY_EXT(name, def, add, list, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, add, list}

#define END_LOC_UI_OPTIONS_PICK() \
}


// DWORD
#define BEGIN_LOC_UI_OPTIONS_DWORD(var) \
const UI_OPTS_DWORD var[] =    \
{								 

#define LOC_UI_OPTIONS_DWORD_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault},def, et}

#define LOC_UI_OPTIONS_DWORD_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible},def, et}

#define END_LOC_UI_OPTIONS_DWORD() \
}


// String
#define BEGIN_LOC_UI_OPTIONS_STR(var) \
const UI_OPTS_STR var[] =    \
{								 

#define LOC_UI_OPTIONS_STR_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, et}

#define LOC_UI_OPTIONS_STR_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, et}

#define END_LOC_UI_OPTIONS_STR() \
}


// String List
#define BEGIN_LOC_UI_OPTIONS_STRLIST(var) \
const UI_OPTS_STRLIST var[] =    \
{								 

#define LOC_UI_OPTIONS_STRLIST_ENTRY(name, def, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def}

#define LOC_UI_OPTIONS_STRLIST_ENTRY_EXT(name, def, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def}

#define END_LOC_UI_OPTIONS_STRLIST() \
}

// File Names
#define BEGIN_LOC_UI_OPTIONS_FILENAME(var) \
const UI_OPTS_FILENAME var[] =    \
{								 

#define LOC_UI_OPTIONS_FILENAME_ENTRY(name, def, id, idHelp, idExt, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, idExt, def}

#define LOC_UI_OPTIONS_FILENAME_ENTRY_EXT(name, def, id, idHelp, idExt, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, idExt, def}

#define END_LOC_UI_OPTIONS_FILENAME() \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\strlist.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STRLIST.H

History:

--*/
#ifndef ESPUTIL_STRLIST_H
#define ESPUTIL_STRLIST_H


const UINT NO_INDEX = (DWORD) -1;
	
template<class T>
class CLocThingList
{
	
public:
	NOTHROW CLocThingList();

	UINT NOTHROW GetIndex(void) const;
	const CArray<T, T&> &GetStringArray(void) const;
	BOOL NOTHROW AdditionsAllowed(void) const;

	void SetThingList(const CArray<T, T&> &);
	UINT AddThing(T &);
	void InsertThing(UINT idxInsert, T & tNew);
	BOOL DeleteThing(UINT);
	BOOL NOTHROW SetIndex(UINT);
	void NOTHROW SetAdditionsAllowed(BOOL);
	UINT GetSize();

	const CLocThingList<T> &operator=(const CLocThingList<T> &);
	int NOTHROW operator==(const CLocThingList<T> &) const;
	int NOTHROW operator!=(const CLocThingList<T> &) const;
	
	NOTHROW ~CLocThingList();

private:
	CLocThingList(const CLocThingList<T> &);

	UINT m_uiIndex;
	CArray<T, T&> m_aThings;
	BOOL m_fAdditionsAllowed;
};

#include "strlist.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\uioptions.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UIOPTIONS.H

History:

--*/

#pragma once


class CReport;

#pragma warning(disable : 4251)

class LTAPIENTRY CLocUIOptionData
{
public:

	enum OptVal
	{
		ovCurrent,
		ovDefault,
		ovUser,
		ovOverride
	};
	
	CLocOptionVal *GetOptionValue(OptVal);

	CLocOptionVal *GetOptionValue(OptVal) const;
	
	void SetOptionValue(OptVal, CLocOptionVal *);
	BOOL Purge(void);
	
private:
	SmartRef<CLocOptionVal> m_spCurrentVal;
	SmartRef<CLocOptionVal> m_spUserVal;
	SmartRef<CLocOptionVal> m_spOverrideVal;
};


class CLocUIOptionSet;

class LTAPIENTRY CLocUIOption: public CLocOptionVal
{
public:
	CLocUIOption();

	void AssertValid(void) const;

	//
	//  New editor types should go at the END, so that old parsers
	//  can still use the ENUM without being re-compiled..
	//
	enum EditorType
	{
		etNone,
		etInteger,						// Maps to lvtInteger
		etUINT,							// Maps to lvtInteger
		etString,						// Maps to lvtString
		etFileName,						// Maps to lvtFileName
		etDirName,						// Maps to lvtString
		etStringList,					// Maps to lvtStringList
		etPickOne,						// Maps to lvtStringList
		etCheckBox,						// Maps to lvtBOOL
		etTrueFalse,					// Maps to lvtBOOL
		etYesNo,						// Maps to lvtBOOL
		etOnOff,						// Maps to lvtBOOL
		etCustom,						// Custom editor
	};

	//
	//  Used as bit flags to indicate where the option can be stored.
	enum StorageType
	{
		stUser = 0x0001,
		stOverride = 0x0002
	};

	enum OptionCode
	{
		ocNoError,
		ocUnknownOption,
		ocInvalidValue,
		ocInvalidType
	};

	void NOTHROW SetDescription(const HINSTANCE hDll, UINT nDescriptionID);
	void NOTHROW SetHelpText(const HINSTANCE hDll, UINT nHelpTextId);
	void NOTHROW SetEditor(EditorType);
	void NOTHROW SetStorageTypes(WORD);
	void NOTHROW SetDisplayOrder(UINT);
	
	void NOTHROW GetDescription(CLString &) const;
	void NOTHROW GetHelpText(CLString &) const;
	EditorType NOTHROW GetEditor(void) const;
	WORD NOTHROW GetStorageTypes(void) const;
	UINT NOTHROW GetDisplayOrder(void) const;
	CLocUIOptionData::OptVal GetOptionValLocation(void) const;
	
	virtual BOOL IsReadOnly(void) const = 0;
	virtual BOOL IsVisible(void) const = 0;
	virtual const CLString &GetGroupName(void) const = 0;
	virtual OptionCode ValidateOption(CReport *, 
		const CLocVariant& var) const = 0;
	virtual void FormatDisplayString(const CLocVariant& var, 
		CLString& strOut, BOOL fVerbose = FALSE) = 0;
	virtual void EditCustom(CWnd* pWndParent, CLocVariant& var) = 0;

protected:
	virtual ~CLocUIOption();

	friend class CLocUIOptionSet;
	friend class CLocOptionManager;
	friend class CUpdateOptionValCallback;
	
	void SetParent(CLocUIOptionSet *);
	const CLocUIOptionSet *GetParent(void) const;

	const CLocUIOptionData &GetOptionValues(void) const;
	CLocUIOptionData &GetOptionValues(void);
	
private:
	HINSTANCE m_hDescDll, m_hHelpDll;
	UINT m_idsDesc, m_idsHelp;
	EditorType m_etEditor;
	WORD m_wStorageTypes;
	UINT m_uiDisplayOrder;
	
	CLocUIOptionSet *m_pParent;
	CLocUIOptionData m_Values;
};


// Validate callback function
// This function will be called during the ValidateOption handling.

typedef CLocUIOption::OptionCode (*PFNOnValidateUIOption)
	(const CLocUIOption *pOption, CReport *pReport, const CLocVariant&);
 
class LTAPIENTRY CLocUIOptionDef : public CLocUIOption
{
public:
	CLocUIOptionDef();
	
	enum ControlType
	{
		ctDefault,
		ctAlways,
		ctNever
	};
	
	void SetReadOnly(ControlType);
	void SetVisible(ControlType);
	
	virtual BOOL IsReadOnly(void) const;
	virtual BOOL IsVisible(void) const;
	virtual const CLString &GetGroupName(void) const;
	virtual OptionCode ValidateOption(CReport *, 
		const CLocVariant& var) const;
	virtual void FormatDisplayString(const CLocVariant& var, 
		CLString& strOut, BOOL fVerbose = FALSE);
	virtual void EditCustom(CWnd* pWndParent, CLocVariant& var);

	void SetValidationFunction(PFNOnValidateUIOption);
	
private:
	ControlType m_ctReadOnly;
	ControlType m_ctVisible;
	PFNOnValidateUIOption m_pfnValidate;
};

	

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUIOptionList :
	public CTypedPtrList<CPtrList, CLocUIOption *>
{
public:
	NOTHROW CLocUIOptionList();

	void AssertValid(void) const;

	NOTHROW ~CLocUIOptionList();
 
private:
	CLocUIOptionList(const CLocUIOptionList &);

	void operator=(const CLocUIOptionList &);
};

#pragma warning(default: 4275 4251)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uioptions.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\uioptions.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UIOPTIONS.INL

History:

--*/


inline
CLocUIOption::CLocUIOption()
{
	m_hDescDll = NULL;
	m_hHelpDll = NULL;
	m_idsDesc = 0;
	m_idsHelp = 0;
	m_etEditor = etNone;

	m_wStorageTypes = 0;
	m_uiDisplayOrder = 0;

	m_pParent = NULL;
}



inline
void
CLocUIOption::SetDescription(
		const HINSTANCE hDll,
		UINT nDescriptionID)
{
	m_hDescDll = hDll;
	m_idsDesc = nDescriptionID;
}



inline
void
CLocUIOption::SetHelpText(
		const HINSTANCE hDll,
		UINT nHelpTextId)
{
	m_hHelpDll = hDll;
	m_idsHelp = nHelpTextId;
}



inline
void
CLocUIOption::SetEditor(
		EditorType et)
{
	m_etEditor = et;
}


inline
void
CLocUIOption::SetStorageTypes(
		WORD wStorageTypes)
{
	m_wStorageTypes = wStorageTypes;
}



inline 
CLocUIOption::EditorType
CLocUIOption::GetEditor(void) 
		const
{
	return m_etEditor;
}



inline
void
CLocUIOption::GetDescription(
		CLString &strDesc)
		const
{
	LTASSERT(m_hDescDll != NULL);
	LTASSERT(m_idsDesc != 0);
	
	strDesc.LoadString(m_hDescDll, m_idsDesc);
}



inline
void
CLocUIOption::GetHelpText(
		CLString &strHelp)
		const
{
	LTASSERT(m_hHelpDll != NULL);
	LTASSERT(m_idsHelp != 0);

	strHelp.LoadString(m_hHelpDll, m_idsHelp);
}



inline
WORD
CLocUIOption::GetStorageTypes(void)
		const
{
	return m_wStorageTypes;
}



inline
void
CLocUIOption::SetParent(
		CLocUIOptionSet *pParent)
{
	m_pParent = pParent;
}



inline
const CLocUIOptionSet *
CLocUIOption::GetParent(void)
		const
{
	return m_pParent;
}



inline
const CLocUIOptionData &
CLocUIOption::GetOptionValues(void) const
{
	return m_Values;
}



inline
CLocUIOptionData &
CLocUIOption::GetOptionValues(void)
{
	return m_Values;
}

inline
void CLocUIOptionDef::SetReadOnly(
	ControlType ct)
{
	m_ctReadOnly = ct;		
}	

inline
void CLocUIOptionDef::SetVisible(
	ControlType ct)
{
	m_ctVisible = ct;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\uioptset.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UIOPTSET.INL

History:

--*/

inline		
void
CLocUIOptionSet::AddOption(
		CLocUIOption *pOption)
{
	m_olOptions.AddTail(pOption);

	pOption->SetParent(this);
}



inline
void
CLocUIOptionSet::AddOptionSet(
		CLocUIOptionSet *pOptionSet)
{
	m_oslSubOptions.AddTail(pOptionSet);

	pOptionSet->SetParent(this);
}


inline
const CLocUIOptionList &
CLocUIOptionSet::GetOptionList(void)
		const
{
	return m_olOptions;
}


inline
const CLocUIOptionSetList &
CLocUIOptionSet::GetOptionSets(void)
		const
{
	return m_oslSubOptions;
}



inline
const CLString &
CLocUIOptionSet::GetGroupName(void)
		const
{
	if (GetParent() != NULL)
	{
		return GetParent()->GetGroupName();
	}
	else
	{
		return m_strGroup;
	}
}

inline
UINT 
CLocUIOptionSet::GetDisplayOrder()
	 const
{
	return m_uiDisplayOrder;	
}	


inline
void
CLocUIOptionSet::SetDescription(
		const HINSTANCE hDll,
		UINT idsDesc)
{
	m_strDesc.LoadString(hDll, idsDesc);
}



inline
void
CLocUIOptionSet::SetDescription(
		const CLString &strDesc)
{
	m_strDesc = strDesc;
}


inline
void
CLocUIOptionSet::SetHelpText(
		const HINSTANCE hDll,
		UINT idsHelp)
{
	m_strHelp.LoadString(hDll, idsHelp);
}



inline
void
CLocUIOptionSet::SetHelpID(UINT uiHelpId)
{
	m_idHelp = uiHelpId;
}



inline
void
CLocUIOptionSet::SetGroupName(
		const TCHAR *szGroupName)
{
	m_strGroup = szGroupName;
}




inline
void
CLocUIOptionSet::SetHelpText(
		const CLString &strHelp)
{
	m_strHelp = strHelp;
}



inline
void
CLocUIOptionSet::GetDescription(
		CLString &strDesc)
		const
{
	strDesc = m_strDesc;
}



inline
void
CLocUIOptionSet::GetHelpText(
		CLString &strHelp)
		const
{
	strHelp = m_strHelp;
}



inline
UINT
CLocUIOptionSet::GetHelpID(void)
		const
{
	return m_idHelp;
}



inline
BOOL
CLocUIOptionSet::IsEmpty(void)
		const
{
	return m_olOptions.IsEmpty() && m_oslSubOptions.IsEmpty();
}


inline
void
CLocUIOptionSet::SetParent(
		const CLocUIOptionSet *pParent)
{
	m_pParent = pParent;
}

inline
void 
CLocUIOptionSet::SetDisplayOrder(
	UINT uiDisplayOrder)
{
	m_uiDisplayOrder = uiDisplayOrder;
}	


inline
const
CLocUIOptionSet *
CLocUIOptionSet::GetParent(void)
		const
{
	return m_pParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\worddiff.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WORDDIFF.H

History:

--*/
 
#ifndef WORDDIFF_H
#define WORDDIFF_H

typedef _bstr_t CWordUnit;

class CWordDiff : public CDifference
{
public:
	CWordDiff(ChangeType type, 
		int nOldPos,
		int nNewPos,
		bool bIsFirst,
		bool bIsLast,
		_bstr_t bstrWord,
		const wchar_t * pwszPrefix,
		const wchar_t * pwszSufix);

	virtual ChangeType GetChangeType() const;	// types of change that caused the difference
	virtual const wchar_t * GetUnit() const; // comparison unit (0-terminated string)
	virtual int GetOldUnitPosition() const; // 0-based position in old sequence. -1 if Added
	virtual int GetNewUnitPosition() const;	// 0-based position in new sequence. -1 if Deleted
	virtual const wchar_t * GetPrefix() const; //prpend this string to unit string
	virtual const wchar_t * GetSufix() const; //append this string to unit string
	virtual bool IsFirst() const; //is this first difference in delta?
	virtual bool IsLast() const; //is this last difference in delta?

private:
	ChangeType m_ChangeType;
	CWordUnit m_Word;
	const wchar_t * m_pwszPrefix;
	const wchar_t * m_pwszSufix;
	bool m_bIsFirst;
	bool m_bIsLast;
	int m_nOldPos;
	int m_nNewPos;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "worddiff.inl"
#endif

#endif  //  WORDDIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman\pdesc.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PDESC.H

History:

--*/
 
#ifndef PARSEMAN_PDESC_H
#define PARSEMAN_PDESC_H

typedef CTypedPtrList<CPtrList, EnumInfo *> FileDescriptionList;

//
//  This class is used to gather all the file descriptions before
//  we write them into the registry.  
//
class CFileDescriptionsCallback : public CEnumCallback
{
public:
	CFileDescriptionsCallback();
	
	BOOL ProcessEnum(const EnumInfo &);
	
	const FileDescriptionList &GetFileDescriptions(void) const;
	
	~CFileDescriptionsCallback();
	
private:
	FileDescriptionList m_FileDescriptions;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\uioptset.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UIOPTSET.H

History:

--*/
#pragma once


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class CLocUIOption;
class CLocUIOptionList;

class LTAPIENTRY CLocUIOptionEnumCallback : public CObject
{
public:
	CLocUIOptionEnumCallback() {};

	void AssertValid(void) const;
			
	virtual BOOL ProcessOption(CLocUIOption *) = 0;
	virtual BOOL ProcessOption(const CLocUIOption *) = 0;
	
private:
	CLocUIOptionEnumCallback(const CLocUIOptionEnumCallback &);
	void operator=(int);
};


class LTAPIENTRY CLocUIOptionSet;

class LTAPIENTRY CLocUIOptionSetList :
	public CTypedPtrList<CPtrList, CLocUIOptionSet *>
{
public:
	NOTHROW CLocUIOptionSetList() {};

	void AssertValid(void) const;

	NOTHROW ~CLocUIOptionSetList();

private:
	CLocUIOptionSetList(const CLocUIOptionSetList &);
	void operator=(const CLocUIOptionSetList &);
};


//
//  This is used to control the order of the tabs displayed in the options
//  dialog.
enum OptionSetDisplayOrder
{
	osDefault = 50
};



class LTAPIENTRY CLocUIOptionSet : public CRefCount, public CObject
{
public:
	NOTHROW CLocUIOptionSet();

	void AssertValid(void) const;
	
	NOTHROW void AddOption(CLocUIOption *);
	NOTHROW void AddOptionSet(CLocUIOptionSet *);
	NOTHROW void RemoveOptionSet(const TCHAR *);
	
	NOTHROW const CLocUIOptionList & GetOptionList(void) const;
	NOTHROW const CLocUIOptionSetList & GetOptionSets(void) const;
	NOTHROW BOOL FindUIOption(const TCHAR *, CLocUIOption *&pOption);
	NOTHROW BOOL FindUIOption(const TCHAR *, const CLocUIOption *&pOption) const;
	
	NOTHROW void SetDescription(const HINSTANCE hDescDll, UINT idsDesc);
	NOTHROW void SetDescription(const CLString &);
	NOTHROW void SetHelpText(const HINSTANCE hHelpDll, UINT idsHelp);
	NOTHROW void SetHelpText(const CLString &);
	NOTHROW void SetHelpID(UINT);
	void SetGroupName(const TCHAR *);
	NOTHROW void SetDisplayOrder(UINT);
	
	NOTHROW void GetDescription(CLString &) const;
	NOTHROW void GetHelpText(CLString &) const;
	NOTHROW UINT GetHelpID(void) const;
	NOTHROW BOOL IsEmpty(void) const;
	const CLString &GetGroupName(void) const;
	NOTHROW UINT GetDisplayOrder(void) const;
	
	virtual BOOL IsReadOnly(void) const = 0;
	virtual BOOL IsVisible(void) const = 0;
		
	BOOL EnumOptions(CLocUIOptionEnumCallback *);
	BOOL EnumOptions(CLocUIOptionEnumCallback *) const;
	
	virtual void OnChange(void) const = 0;
	
protected:
	NOTHROW virtual ~CLocUIOptionSet();

	void SetParent(const CLocUIOptionSet *);
	const CLocUIOptionSet *GetParent(void) const;

private:
	CLocUIOptionList m_olOptions;
	CLocUIOptionSetList m_oslSubOptions;
	CLString m_strDesc, m_strHelp;
	UINT m_idHelp;
	const CLocUIOptionSet *m_pParent;
	CLString m_strGroup;
	UINT m_uiDisplayOrder;
	
	CLocUIOptionSet(const CLocUIOptionSet &);
	void operator=(const CLocUIOptionSet &);
};


class LTAPIENTRY CLocUIOptionSetDef : public CLocUIOptionSet
{
public:
	CLocUIOptionSetDef();

	enum ControlType
	{
		ctDefault,
		ctAlways,
		ctNever
	};
	
	void SetReadOnly(ControlType);
	void SetVisible(ControlType);

	virtual BOOL IsReadOnly(void) const;
	virtual BOOL IsVisible(void) const;

	virtual void OnChange(void) const;

	const CLocUIOptionSetDef & operator=(const CLocUIOptionSetDef &);
	
private:
	ControlType m_ctReadOnly;
	ControlType m_ctVisible;
};

#pragma warning(default: 4275)
 
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uioptset.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\mit\mitutil\worddiff.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WORDDIFF.INL

History:

--*/

#include "ltdebug.h"

inline
CWordDiff::CWordDiff(
	CDifference::ChangeType type, 
	int nOldPos,
	int nNewPos,
	bool bIsFirst,
	bool bIsLast,
	_bstr_t bstrWord,
	const wchar_t * pwszPrefix,
	const wchar_t * pwszSufix) :
	m_ChangeType(type), m_Word(bstrWord), m_pwszPrefix(pwszPrefix),
	m_pwszSufix(pwszSufix), m_bIsFirst(bIsFirst), m_bIsLast(bIsLast),
	m_nOldPos(nOldPos), m_nNewPos(nNewPos)

{
	LTASSERT(pwszPrefix != NULL);
	LTASSERT(pwszSufix != NULL);
	LTASSERT(nOldPos >= -1);
	LTASSERT(nNewPos >= -1);
}

inline
CDifference::ChangeType 
CWordDiff::GetChangeType() 
const
{
	return m_ChangeType;
}

inline
const wchar_t * 
CWordDiff::GetUnit() 
const
{
	return m_Word;
}

inline
int 
CWordDiff::GetOldUnitPosition() 
const 
{
	return m_nOldPos;
}

inline
int 
CWordDiff::GetNewUnitPosition() 
const
{
	return m_nNewPos;
}

inline
const wchar_t * 
CWordDiff::GetPrefix() 
const
{
	return m_pwszPrefix;
}

inline
const wchar_t * 
CWordDiff::GetSufix() 
const
{
	return m_pwszSufix;
}

inline
bool 
CWordDiff::IsFirst() 
const
{
	return m_bIsFirst;
}

inline
bool 
CWordDiff::IsLast() 
const
{
	return m_bIsLast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman\pinfo.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PINFO.H

History:

--*/

#ifndef PINFO_H
#define PINFO_H


class CLocParserManager;

class CLocParserInfo;
typedef CTypedPtrList<CPtrList, CLocParserInfo *> CLocParserList;

#pragma warning(disable : 4251)

interface ILocParser;
interface ILocStringValidation;

class LTAPIENTRY CLocParserInfo : public CLObject
{
public:

	void AssertValid(void) const;

	const CLString &GetParserName(void) const;
	const CLString &GetParserDescription(void) const;
	const CLString &GetParserHelp(void) const;
	ParserId GetParserId(void) const;
	BOOL GetDllVersion(CLString &) const;
	const CLocExtensionList &GetExtensionList() const;
	const CLocParserList &GetSubParserList(void) const;

	~CLocParserInfo();

protected:
	friend CLocParserManager;
	
	CLocParserInfo();

	HINSTANCE GetParserHandle(void) const;
	ILocParser * GetParserPointer(void) const;
	ILocStringValidation *GetValidationPointer(void);
	
	BOOL LoadParserDll(void);
	BOOL InitSubParsers(ILocParser *);
	
	BOOL FreeParserDll(void);
	BOOL AttemptUnload(void);
	
	BOOL IsLoaded(void) const;
	
	void SetParserName(const CLString &);
	void SetParserDescription(const CLString &);
	void SetParserHelp(const CLString &);
	
	void SetParserId(ParserId);
	BOOL SetExtensionList(const CLString  &);
	void AddSubParser(CLocParserInfo *);
	void AddExtensions(const CLocExtensionList &);
	CLocParserList &GetSubParserList(void);

	clock_t GetLastAccessTime(void) const;
	
	static BOOL LoadParserDll(const CLString &strFileName,
			CReporter *pReporter, HMODULE &hDll, ILocParser *&pLocParser);
	static BOOL GetParserObjects(CReporter *, CLoadLibrary &, ILocParser *&);
	
private:
	
	CLString m_strParserName;
	CLString m_strParserDescription;
	CLString m_strParserHelp;
	CLocExtensionList m_elExtList;
	ParserId m_pidParserId;
	HINSTANCE m_hParserDll;
	ILocParser *m_pParserObject;
	ILocStringValidation *m_pValidationObject;
	BOOL m_fLoadAttempted;
	BOOL m_fValidationTried;
	UINT m_uiSubParserUsageCount;
	mutable clock_t m_tLastAccess;
	
	CLocParserList m_pSubParsers;
};

#pragma warning(default : 4251)



#endif  // PINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman\pmanager.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PMANAGER.H

History:

--*/

#ifndef PMANAGER_H
#define PMANAGER_H


#pragma warning(disable : 4251)

typedef CTypedPtrMap<CMapWordToPtr, ParserId, CLocParserInfo *> CLocParserMap;
typedef CTypedPtrMap<CMapStringToPtr, CString, CLocParserList *> CLocExtMap;
typedef CTypedPtrList<CPtrList, EnumInfo *> FileDescriptionList;

interface ILocFile;
struct ParserInfo;

class CParserUnloader;

class LTAPIENTRY CLocParserManager : public CLObject
{
	friend CLocParserInfo;
public:
	CLocParserManager();
	
	void AssertValid(void) const;
	
	BOOL InitParserManager(IUnknown *);
	static BOOL ReloadRegistry(void);
	static void UnloadParsers(void);
	static void UnloadUnusedParsers(void);
	
	static void GetManagerVersion(DWORD &dwMajor, DWORD &dwMinor, BOOL &fDebug);
	static BOOL AddParserToSystem(const CLString &);
	static const CLocParserInfo *GetParserInfo(ParserId pid, ParserId pidParent);
	static BOOL RemoveParserFromSystem(ParserId pid, ParserId pidParent);
	static UINT FindParsers(void);
	
	static BOOL GetLocParser(ParserId, ILocParser *&);
	static BOOL GetLocFile(const CFileSpec &, ParserId, FileType,
			ILocFile *&, CReporter &);
	static BOOL FindLocFile(const CPascalString &, CLocParserIdArray &);
	static BOOL GetStringValidation(ParserId, ILocStringValidation *&);
	
	static const CLocParserList &GetParserList(void);

	static void GetParserFilterString(CLString &);

	~CLocParserManager();

protected:
	static void RemoveCurrentInfo(void);
	static BOOL LoadParserInfo(const HKEY &, CLocParserInfo *&);
	static BOOL LoadMasterParserInfo(const HKEY &);
	static BOOL LoadSubParsers(const HKEY &, CLocParserInfo *);
	static BOOL WriteFileTypes(const HKEY &, const FileDescriptionList &);
	
	static BOOL OpenParserSubKey(HKEY &, ParserId, ParserId);
	static BOOL AddParserToRegistry(const CLString &, const ParserInfo &,
			const FileDescriptionList &);

	static void AddToFilter(const CLocParserInfo *, const CLocExtensionList &);

private:
	static LONG             m_lRefCount;    // 
	static CLocParserMap    m_ParserMap;    // Associative map, ID -> Parser.
	static CLocParserList   m_ParserList;   // List of open parser DLL's.
	static CLocParserList   m_SubParserList;// list of all sub-parsers.
	static CLocExtMap       m_ExtensionMap;	// Associative map, extension->parser.
	static CLString         m_strFilter;    // Filter list for parser files.
	static IUnknown *       m_pUnknown;
	static CParserUnloader  m_Unloader;
};


//
//  Undecorated versions of these functions for GetProcAddress users...
//
extern "C"
{
	LTAPIENTRY HRESULT AddParserToSystem(const TCHAR *strFileName);
	LTAPIENTRY HRESULT RemoveParserFromSystem(ParserId pid, ParserId pidParent);
}

		
#pragma warning(default : 4251)

#endif // PMANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>
#include <afxtempl.h>

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESOURCE.H

History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by parseman.rc
//
#define IDS_PARSEMAN_CONTEXT            12700
#define IDS_BAD_VERSION                 12701
#define IDS_FILT_ALL_FILES              12702
#define IDS_DEBUG_MISMATCH              12703

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman\unloader.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UNLOADER.H

History:

--*/
 
#pragma once

class CParserUnloader : public CFlushMemory
{
public:
	CParserUnloader(BOOL fDelete);
	
	void FlushMemory(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\locbinary.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCBINARY.H

History:

--*/
 
#if !defined (PARSUTIL_LOCBINARY_H)
#define PARSUTIL_LOCBINARY_H


#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocBinary : public ILocBinary, public CPULocChild
{
// Construction
public:
	CPULocBinary(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//
	// ILocBinary interface
	//
	BOOL STDMETHODCALLTYPE CreateBinaryObject(BinaryId,	CLocBinary * REFERENCE);
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\locchild.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCCHILD.H

History:

--*/
 
#if !defined (PARSUTIL_LOCCHILD_H)
#define PARSUTIL_LOCCHILD_H


#pragma warning(disable : 4275)


class CPULocParser;

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocChild : public CLUnknown, public CLObject
{
// Construction
public:
	CPULocChild(CPULocParser * pParent);
	virtual ~CPULocChild();

// Data
private:
	CPULocParser * m_pParent;

// Attributes
public:
	CPULocParser * GetParent() const;

// COM Interfaces
public:

// Overrides
public:

// Implementation
protected:

	//  CLObject

	virtual void AssertValid(void) const;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\locparser.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCPARSER.H

History:

--*/
 
#if !defined (PARSUTIL_LOCPARSER_H)
#define PARSUTIL_LOCPARSER_H


#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocParser : public ILocParser, public CLObject
{
// Construction
public:
	CPULocParser(HINSTANCE hDll);
	virtual ~CPULocParser();

// Data
private:
	ULONG				m_ulRefCount;	// COM reference count
	HINSTANCE			m_hInst;		// Instance Handle

	BOOL				m_fEnableVersion;
	BOOL				m_fEnableBinary;
	BOOL				m_fEnableStrVal;

// COM Interfaces
public:

	//  IUnknown standard interface.
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID * ppvObj);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocParser interface implementation
	HRESULT STDMETHODCALLTYPE Init(IUnknown *);
	HRESULT STDMETHODCALLTYPE CreateFileInstance(ILocFile * REFERENCE, FileType);
	void STDMETHODCALLTYPE GetParserInfo(ParserInfo &) const;
	void STDMETHODCALLTYPE GetFileDescriptions(CEnumCallback &) const;

// Operations
public:

// Implementation
protected:
	BOOL EnableInterface(REFIID riid, BOOL fEnable = TRUE);
	virtual BOOL IsInterfaceEnabled(REFIID riid) const;

// Overrides
public:

	// IUnknown
	virtual HRESULT OnQueryInterface(REFIID riid, LPVOID * ppvObj);

	// ILocParser
	virtual HRESULT OnInit(IUnknown *);
	virtual HRESULT OnCreateFileInstance(ILocFile * &, FileType) = 0;
	virtual void OnGetParserInfo(ParserInfo &) const = 0;
	virtual void OnGetFileDescriptions(CEnumCallback &) const = 0;

	// ILocVersion
	virtual void OnGetParserVersion(DWORD &dwMajor,	DWORD &dwMinor,
			BOOL &fDebug) const = 0;

	// ILocBinary
	virtual BOOL OnCreateBinaryObject(BinaryId id, CLocBinary * REFERENCE pBinary);

	// ILocStringValidation
	virtual CVC::ValidationCode OnValidateString(const CLocTypeId &ltiType,
			const CLocTranslation &, CReporter *pReporter,
			const CContext &context) = 0;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\locstrval.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCSTRVAL.H

History:

--*/

#if !defined (PARSUTIL_LOCSTRVAL_H)
#define PARSUTIL_LOCSTRVAL_H

#include "LocChild.h"

#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocStringValidation : public CPULocChild, public ILocStringValidation
{
// Construction
public:
	CPULocStringValidation(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocStringValidation
	CVC::ValidationCode STDMETHODCALLTYPE ValidateString(
			const CLocTypeId &ltiType, const CLocTranslation &trTrans,
			CReporter *pReporter, const CContext &context);
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\locversion.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCVERSION.H

History:

--*/
 
#if !defined (PARSUTIL_LOCVERSION_H)
#define PARSUTIL_LOCVERSION_H

#include "LocChild.h"

#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocVersion : public CPULocChild, public ILocVersion
{
// Construction
public:
	CPULocVersion(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocVersion
	void STDMETHODCALLTYPE GetParserVersion(DWORD &dwMajor, DWORD &dwMinor,
			BOOL &fDebug) const;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESOURCE.H

History:

--*/

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/


#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxcoll.h>		// MFC collection support
#include <afxtempl.h>		// MFC template support

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsers\parsutil\parsutil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PARSUTIL.H

History:

--*/


#if !defined (__ParsUtil_h__)
#define __ParsUtil_h__

void IncrementClassCount();
void DecrementClassCount();

extern HMODULE g_hDll;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\binary.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BINARY.H

Abstract:

    Class to hold 'binary' (non-string) information about a localizable item.

History:

--*/

#ifndef BINARY_H
#define BINARY_H

//
//  Binary interface.  Parsers provide an implementation of this in order
//  to create binary objects for other users.
//
extern const IID IID_ILocBinary;

DECLARE_INTERFACE_(ILocBinary, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(BOOL, CreateBinaryObject)(THIS_ BinaryId, CLocBinary *REFERENCE) PURE;
};



#endif  // BINARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\idupdate.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    IDUPDATE.H

History:

--*/
 
#ifndef PBASE_IDUPDATE_H
#define PBASE_IDUPDATE_H

extern const IID IID_ILocIDUpdate;

DECLARE_INTERFACE_(ILocIDUpdate, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  ID Update methods.
	//
	STDMETHOD_(BOOL, RequiresUpdate)(THIS_ FileType) PURE;
	STDMETHOD_(FileType, GetUpdatedFileType)(THIS_ FileType) PURE;

	STDMETHOD_(BOOL, GetOldUniqueId)(THIS_ CLocUniqueId REFERENCE) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\iresobj.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    IRESOBJ.H

Abstract:

    This interface allows conversion of localizable items of resource into a
    res32 image, and vice-versa.

History:

--*/

#ifndef IRESOBJ_H
#define IRESOBJ_H


class CLocItemPtrArray;
class CFile;
class CResObj;
class CLocItem;

extern const IID IID_ICreateResObj;

DECLARE_INTERFACE_(ICreateResObj, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	// Creates a CResObj for win32 resoruce processing
	//Inputs:
	//	- A pointer to a CLocItem object containing the type and Id of the item
	//	- The size of the resource.
	//	- An void pointer to unknown data to be passed from enumeration to generate
	//Return:
	//	- A CResObj pointer or NULL if the type is not recognized
	STDMETHOD_(CResObj *, CreateResObj)(THIS_ CLocItem * pLocItem,
		DWORD dwSize, void * pvHeader) PURE;
};
#endif  // IRESOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\pstrval.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PSTRVAL.H

History:

--*/

 
#ifndef PBASE_PSTRVAL_H
#define PBASE_PSTRVAL_H

extern const IID IID_ILocStringValidation;

DECLARE_INTERFACE_(ILocStringValidation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(CVC::ValidationCode, ValidateString)
		(THIS_ const CLocTypeId REFERENCE, const CLocString REFERENCE,
				CReporter *) PURE;
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\imgres32.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    IMGRES32.H

History:

--*/

#ifndef IMGRES32_H
#define IMGRES32_H


struct Res32FontInfo
{
	WORD wLength;			//Structure length
	WORD wPointSize;		
	WORD wWeight;
	WORD wStyle;
	CPascalString pasName;
};

class CLocItemPtrArray;
class CFile;

extern const IID IID_ILocRes32Image;

DECLARE_INTERFACE_(ILocRes32Image, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//Builds a Res32 file image of a resource from the resource's CLocItem objects
	//Inputs:
	//	- A pointer to a CLocItemPtrArray object containing the CLocItem objects of
	//	a resource (like a dialog or a menu).
	//	- An array index to the root item of the resource.
	//	- An array index to the selected item of the resource.
	//	- The resource's language id.
	//	- A pointer to an existing empty CFile.
	//  - A pointer to a Res32FontInfo structure
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- The CFile object has the res32 image of the resource.
	//	- The CLocItemPtrArray object has its items ordered by physical
	//	location in the res32 image.	
	//Return:
	//	TRUE if the image was created successfully. FALSE, otherwise.
	STDMETHOD_(BOOL, MakeRes32Image)(THIS_ CLocItemPtrArray *, int, int, 
		LangId, CFile *, Res32FontInfo*, CLocItemHandler *) PURE;

	//Breaks the Res32 image of a resource into the corresponding CLocItem objects.
	//Inputs:
	//	- A pointer to a CFile object containing the res32 image of a resource.
	//	- The resource's language id.
	//	- A pointer to a CLocItemPtrArray containing the CLocItem objects of the
 	//	resource. The items are expected to be ordered by position in the res32 image.
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- The items in the CLocItemPtrArray object are updated with the new data from
 	//	the res32 image.
	//Return:
	//	TRUE if the imaged could be parsed and if the items could be updated successfully.
	//	FALSE, otherwise.
	STDMETHOD_(BOOL, CrackRes32Image)(THIS_ CFile *, LangId, CLocItemPtrArray *, CLocItemHandler *) PURE;
};



#endif  // IMGRES32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\locfile.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCFILE.H

History:

--*/

#ifndef PBASE_LOCFILE_H
#define PBASE_LOCFILE_H


class CLocItemHandler;


extern const IID IID_ILocFile;


DECLARE_INTERFACE_(ILocFile, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  ILocFile methods.
	//
	STDMETHOD_(BOOL, OpenFile)(THIS_ const CFileSpec REFERENCE,
			CReporter REFERENCE) PURE;
	STDMETHOD_(FileType, GetFileType)(THIS) const PURE;
	STDMETHOD_(void, GetFileTypeDescription)(THIS_ CLString REFERENCE)
		const PURE;
	STDMETHOD_(BOOL, GetAssociatedFiles)(THIS_ CStringList REFERENCE)
		const PURE;

	STDMETHOD_(BOOL, EnumerateFile)(THIS_ CLocItemHandler REFERENCE,
			const CLocLangId &, const DBID REFERENCE) PURE;
	STDMETHOD_(BOOL, GenerateFile)(THIS_ const CPascalString REFERENCE,
			CLocItemHandler REFERENCE, const CLocLangId REFERENCE,
			const CLocLangId REFERENCE, const DBID REFERENCE) PURE;
};


#endif //  PBASE_LOCFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\mnemonic.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MNEUMONIC.H

History:

--*/


#ifndef MNEMONIC_H
#define MNEMONIC_H


extern const IID IID_ILocMnemonics;

DECLARE_INTERFACE_(ILocMnemonics, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//Gets the mnemonics (aka hotkeys) in the resource array of locitems.
	//Inputs:
	//	- A pointer to a CLocItemPtrArray object containing the CLocItem objects of
	//	a resource (like a dialog or a menu).
	//	- An array index to the root item of the resource.
	//	- An array index to the selected item of the resource.
	//	- The resource's language id.
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- A 'CHotkeysMap' map containing the mnemonics.
	//Return:
	//	TRUE if the mnemonics could be retrieved successfully. FALSE, otherwise.
	STDMETHOD_(BOOL, GetMnemonics)
			(THIS_ CLocItemPtrArray &, int, int, LangId, CReporter * pReporter, 
			CMnemonicsMap &) PURE;

};



#endif  // MNEMONIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\parseapi.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PARSEAPI.H

History:

--*/

 
#ifndef PARSEAPI_H
#define PARSEAPI_H


extern const IID IID_ILocParser;
extern const IID IID_ILocParser_20;

struct ParserInfo
{
	CArray<PUID, PUID &> aParserIds;
	CLString strDescription;
	CLocExtensionList elExtensions;
	CLString strHelp;
};


DECLARE_INTERFACE_(ILocParser, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  LocParser methods.
	//
	STDMETHOD(Init)(THIS_ IUnknown *) PURE;
	
	STDMETHOD(CreateFileInstance)(THIS_ ILocFile *REFERENCE, FileType) PURE;

	STDMETHOD_(void, GetParserInfo)(THIS_ ParserInfo REFERENCE)
		CONST_METHOD PURE;
	STDMETHOD_(void, GetFileDescriptions)(THIS_ CEnumCallback &)
		CONST_METHOD PURE;
};


//
//  Here for DOCUMENTATION only.  Implementors should export the following
//  functions from every Parser DLL.
//
static const char * szParserEntryPointName = "DllGetParserCLSID";
typedef void (STDAPICALLTYPE *PFNParserEntryPoint)(CLSID REFERENCE);

STDAPI_(void) DllGetParserCLSID(CLSID REFERENCE);


static const char * szParserRegisterEntryPointName = "DllRegisterParser";
typedef HRESULT (STDAPICALLTYPE *PFNParserRegisterEntryPoint)(void);

STDAPI DllRegisterParser(void);


static const char *szParserUnregisterEntryPointName = "DllUnregisterParser";
typedef HRESULT (STDAPICALLTYPE *PFNParserUnregisterEntryPoint)(void);

STDAPI DllUnregisterParser(void);

//
//  Implementors also need to implement the DllGetClassObject function.
//  An optional (but RECOMMENDED) function is DllCanUnloadNow.
//  See the OLE 2 reference manual for details about these functions.
//

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI DllCanUnloadNow(void);


#endif // PARSEAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\sys\locking.h ===
/***
*sys/locking.h - flags for locking() function
*
*	Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the flags for the locking() function.
*	[System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCKING
#define _INC_LOCKING

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#define _LK_UNLCK	0	/* unlock the file region */
#ifdef _WIN32
#define _LK_LOCK	1	/* lock the file region */
#endif
#define _LK_NBLCK	2	/* non-blocking lock */
#ifdef _WIN32
#define _LK_RLCK	3	/* lock for writing */
#endif
#define _LK_NBRLCK	4	/* non-blocking lock for writing */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK	_LK_UNLCK
#ifdef _WIN32
#define LK_LOCK 	_LK_LOCK
#endif
#define LK_NBLCK	_LK_NBLCK
#ifdef _WIN32
#define LK_RLCK 	_LK_RLCK
#endif
#define LK_NBRLCK	_LK_NBRLCK
#endif

#endif	/* _INC_LOCKING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\sys\stat.h ===
/***
*sys/stat.h - defines structure used by stat() and fstat()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the _stat() and _fstat()
*       routines.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STAT
#define _INC_STAT

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#include <sys/types.h>


#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif


#ifdef _WIN32
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif /* _WIN32 */


/* define structure for returning status information */

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__

/* Non-ANSI names for compatibility */

struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64
struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#endif

#define _STAT_DEFINED
#endif


#define _S_IFMT         0170000         /* file type mask */
#define _S_IFDIR        0040000         /* directory */
#define _S_IFCHR        0020000         /* character special */
#define _S_IFIFO        0010000         /* pipe */
#define _S_IFREG        0100000         /* regular */
#define _S_IREAD        0000400         /* read permission, owner */
#define _S_IWRITE       0000200         /* write permission, owner */
#define _S_IEXEC        0000100         /* execute/search permission, owner */


/* Function prototypes */

_CRTIMP int __cdecl _fstat(int, struct _stat *);
_CRTIMP int __cdecl _stat(const char *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _fstati64(int, struct _stati64 *);
_CRTIMP int __cdecl _stati64(const char *, struct _stati64 *);
#endif

#ifdef _WIN32
#ifndef _WSTAT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
#endif

#define _WSTAT_DEFINED
#endif
#endif /* _WIN32 */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

_CRTIMP int __cdecl fstat(int, struct stat *);
_CRTIMP int __cdecl stat(const char *, struct stat *);

#endif  /* __STDC__ */


#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\pversion.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PVERSION.H

History:

--*/
 
#ifndef PVERSION_H
#define PVERSION_H

extern const IID IID_ILocVersion;

extern const DWORD dwCurrentMajorVersion;
extern const DWORD dwCurrentMinorVersion;
#ifdef _DEBUG
const BOOL fCurrentDebugMode = TRUE;
#else
const BOOL fCurrentDebugMode = FALSE;
#endif

DECLARE_INTERFACE_(ILocVersion, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//
	//
	STDMETHOD_(void, GetParserVersion)(
			THIS_ DWORD REFERENCE dwMajor,
			DWORD REFERENCE dwMinor,
			BOOL REFERENCE fDebug)
		CONST_METHOD PURE;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\sys\timeb.h ===
/***
*sys/timeb.h - definition/declarations for _ftime()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file define the _ftime() function and the types it uses.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIMEB
#define _INC_TIMEB

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif


/* Structure returned by _ftime system call */

#ifndef _TIMEB_DEFINED
struct _timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#if     !__STDC__

/* Non-ANSI name for compatibility */

struct timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#endif

#define _TIMEB_DEFINED
#endif


/* Function prototypes */

_CRTIMP void __cdecl _ftime(struct _timeb *);

#if     !__STDC__

/* Non-ANSI name for compatibility */

_CRTIMP void __cdecl ftime(struct timeb *);

#endif


#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIMEB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\sys\types.h ===
/***
*sys/types.h - types returned by system level calls for file and time info
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines types used in defining values returned by system
*       level calls for file status and time information.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TYPES
#define _INC_TYPES

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif


#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;          /* i-node number (not used on DOS) */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif

#define _INO_T_DEFINED
#endif


#ifndef _DEV_T_DEFINED

typedef unsigned int _dev_t;            /* device code */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif

#define _DEV_T_DEFINED
#endif


#ifndef _OFF_T_DEFINED

typedef long _off_t;                    /* file offset value */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif

#define _OFF_T_DEFINED
#endif

#endif  /* _INC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\sys\utime.h ===
/***
*sys/utime.h - definitions/declarations for utime()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the utime routine to set
*       new file access and modification times.  NOTE - MS-DOS
*       does not recognize access time, so this field will
*       always be ignored and the modification time field will be
*       used to set the new time.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_UTIME
#define _INC_UTIME

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif

#ifdef  _WIN32
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif  /* _WIN32 */

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

/* define struct used by _utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };

#if     !__STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };
#endif

#define _UTIMBUF_DEFINED
#endif


/* Function Prototypes */

_CRTIMP int __cdecl _utime(const char *, struct _utimbuf *);
#ifdef _WIN32
_CRTIMP int __cdecl _futime(int, struct _utimbuf *);

/* Wide Function Prototypes */
_CRTIMP int __cdecl _wutime(const wchar_t *, struct _utimbuf *);
#endif /* _WIN32 */

#if     !__STDC__
/* Non-ANSI name for compatibility */
_CRTIMP int __cdecl utime(const char *, struct utimbuf *);
#endif

#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_UTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\prodver\prodver.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PRODVER.H

Abstract:

    Product versions

History:

--*/

#define rmj 4
#define rmm 2
#define rup 169
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\subparse.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    SUBPARSE.H

History:

--*/


#ifndef PBASE_SUBPARSE_H
#define PBASE_SUBPARSE_H


extern const IID IID_ILocSubParserManager;

typedef CTypedPtrArray<CPtrArray, ILocParser *> ILocSubParserArray;

DECLARE_INTERFACE_(ILocSubParserManager, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD(InitSubParsers)(THIS_ ILocSubParserArray REFERENCE)
		CONST_METHOD PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase\updatelog.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    UPDATELOG.H

History:

--*/
 
#ifndef PBASE_UPDATELOG_H
#define PBASE_UPDATELOG_H


extern const IID IID_ILocUpdateLog;

DECLARE_INTERFACE_(ILocUpdateLog, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(BOOL, ReportItemDifferences)
		(THIS_ const CLocItem *pOldItem, const CLocItem *pNewItem,
				CItemInfo *, CLogFile *) PURE;
};


struct __declspec(uuid("{6005AF23-EE76-11d0-A599-00C04FC2C6D8}")) ILocUpdateLog;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\cmdalias.cpp ===
/*****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CmdAlias.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: The CmdAlias class encapsulates the 
							  functionality for retrieving alias information.
Revision History			: 
		Last Modified By	: C V Nandi
		Last Modified Date	: 16th-March-2001
*****************************************************************************/
#include "Precomp.h"
#include "GlobalSwitches.h"
#include "CommandSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "CmdAlias.h"
#include "CmdTokenizer.h"
#include "ErrorInfo.h"
#include "WMICliXMLLog.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "FormatEngine.h"
#include "WmiCmdLn.h"

/*----------------------------------------------------------------------------
   Name				 :CCmdAlias
   Synopsis	         :This function initializes the member variables when an 
					  object of the class type is instantiated.
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
----------------------------------------------------------------------------*/
CCmdAlias::CCmdAlias()
{
	m_pIAliasNS			= NULL;
	m_pILocalizedNS		= NULL;
	m_bTrace			= FALSE;
	m_eloErrLogOpt		= NO_LOGGING;
}

/*----------------------------------------------------------------------------
   Name				 :~CCmdAlias
   Synopsis	         :This function uninitializes the member variables when an
					  object of the class type goes out of scope.
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
----------------------------------------------------------------------------*/
CCmdAlias::~CCmdAlias()
{
	SAFEIRELEASE(m_pIAliasNS);
	SAFEIRELEASE(m_pILocalizedNS);
}

/*----------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables when 
					  the execution of a command string issued on the command 
					  line is completed.
   Type	             :Member Function
   Input Parameter(s):
			bFinal	- boolean value which when set indicates that the program
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Uninitialize(bFinal)
   Notes             :None
----------------------------------------------------------------------------*/
void CCmdAlias::Uninitialize(BOOL bFinal)
{
	m_bTrace = FALSE;
	// If end of program 
	if (bFinal)
	{
		SAFEIRELEASE(m_pILocalizedNS);
		SAFEIRELEASE(m_pIAliasNS);
	}
}

/*----------------------------------------------------------------------------
   Name				 :ConnectToAlias
   Synopsis          :This function connects to WMI namespace on the specified
					  machine using the information available CParsedInfo 
					  class object.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - reference to CParsedInfo class object.
		pIWbemLocator - IWbemLocator object for connecting to WMI .						
   Output parameter(s):
		rParsedInfo   - reference to CParsedInfo class object.
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :ConnectToAlias(rParsedInfo,pIWbemLocator)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::ConnectToAlias(CParsedInfo& rParsedInfo, 
								  IWbemLocator* pIWbemLocator)
{
	// Get current thread for logging the success or failure of the command.
	DWORD	dwThreadId	= GetCurrentThreadId();
	HRESULT hr			= S_OK;

	// Set the trace flag 
	m_bTrace		= rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();
	m_eloErrLogOpt	= rParsedInfo.GetErrorLogObject().GetErrLogOption();

	try
	{
		// If the /ROLE has been changed since last invocation
		if (rParsedInfo.GetGlblSwitchesObject().GetRoleFlag() == TRUE)
		{
			SAFEIRELEASE(m_pIAliasNS);
			CHString chsMsg;
			
			// Connect to the specified namespace of Windows Management on the
			// local computer using the locator object. 
			hr = Connect(pIWbemLocator, &m_pIAliasNS,
					_bstr_t(rParsedInfo.GetGlblSwitchesObject().GetRole()),
					NULL, NULL,	_bstr_t(rParsedInfo.GetGlblSwitchesObject().
					GetLocale()), rParsedInfo);

			// If /TRACE is ON
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format( 
						 L"IWbemLocator::ConnectServer(L\"%s\", NULL, NULL, "
						 L"L\"%s\", 0L, L\"%s\", NULL, -)",
						rParsedInfo.GetGlblSwitchesObject().GetRole(),
						rParsedInfo.GetGlblSwitchesObject().GetLocale(),
						(rParsedInfo.GetAuthorityPrinciple()) ?
							rParsedInfo.GetAuthorityPrinciple() : L"<null>");

				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			
			// Set the interface level security
			hr = 
				SetSecurity(m_pIAliasNS, NULL, NULL, NULL, NULL,
				 rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				 rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());

			// If /TRACE is ON
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
							L"RPC_C_AUTHZ_NONE, NULL, %d, %d, -, EOAC_NONE)",
				 rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				 rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());

				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									dwThreadId, rParsedInfo, m_bTrace);
			}
			
			ONFAILTHROWERROR(hr);
			rParsedInfo.GetGlblSwitchesObject().SetRoleFlag(FALSE);
			
		}

		// Connect to the localized Namespace
		hr = ConnectToLocalizedNS(rParsedInfo, pIWbemLocator);
		ONFAILTHROWERROR(hr);
	}

	catch(_com_error& e)
	{
		// Set the COM error
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}

	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainAliasInfo
   Synopsis          :Obtains the following info of the alias specified.
					  1. alias PWhere expression
					  2. alias target string
					  3. alias description
					  from the alias definition and updates the information in
					  the CParsedInfo object passed as reference.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - The parsed info from command line input.
   Output parameter(s):
   		rParsedInfo   - The parsed info from command line input.		
   Return Type       :RETCODE  
   Global Variables  :None
   Calling Syntax    :ObtainAliasInfo(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CCmdAlias::ObtainAliasInfo(CParsedInfo& rParsedInfo)
{
	// Variables being used in this function.
	IWbemClassObject	*pIWbemObj			= NULL;
	IUnknown			*pIUnknown			= NULL;
	IWbemClassObject	*pIEmbedObj			= NULL;
	HRESULT				hr					= S_OK;
	RETCODE				retCode				= PARSER_CONTINUE;
	DWORD				dwThreadId			= GetCurrentThreadId();

	// Variants to save the properties and also for the embedded objects.
	VARIANT	vtProp, vtEmbedProp;
	VariantInit(&vtProp);
	VariantInit(&vtEmbedProp);

	try
	{
		_bstr_t			bstrResult;
		CHString		chsMsg;
		// Object path of the required alias.
		_bstr_t bstrPath = _bstr_t("MSFT_CliAlias.FriendlyName='") +
							_bstr_t(rParsedInfo.GetCmdSwitchesObject().
								GetAliasName()) + _bstr_t(L"'");

		//Retrieving the object from the namespace in m_pIAliasNS
		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, &pIWbemObj, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								dwThreadId, rParsedInfo, m_bTrace);
		}
		// To set errata code that indicates a more user friendly error
		// message to the user.
		if ( FAILED ( hr ) )
		{
			// Don't set com error in catch block.
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
													   IDS_E_ALIAS_NOT_FOUND);
		}
		ONFAILTHROWERROR(hr);

		//1. Retrieve the value of 'Target' property object
		hr = pIWbemObj->Get(_bstr_t(L"Target"), 0, &vtProp, 0, 0 );
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Target\", 0, -, 0, 0)");
			GetBstrTFromVariant(vtProp, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							   (LPCWSTR)chsMsg, dwThreadId, rParsedInfo,
							   m_bTrace, 0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if (vtProp.vt != VT_NULL && vtProp.vt != VT_EMPTY)
		{
			if(!rParsedInfo.GetCmdSwitchesObject().SetAliasTarget(
													(_TCHAR*)vtProp.bstrVal))
			{
				rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(OUT_OF_MEMORY);
				retCode = PARSER_OUTOFMEMORY;
			}
		}
		if(retCode != PARSER_OUTOFMEMORY)
		{
			VARIANTCLEAR(vtProp);

			//2. Retrieve the value of 'PWhere' property object
			VariantInit(&vtProp);
			hr = pIWbemObj->Get(_bstr_t(L"PWhere"), 0, &vtProp, 0, 0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Get(L\"PWhere\", 0, -,"
																    L"0, 0)");
				GetBstrTFromVariant(vtProp, bstrResult);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									dwThreadId, rParsedInfo, m_bTrace,
									0, bstrResult);
			}
			ONFAILTHROWERROR(hr);

			if (vtProp.vt != VT_NULL && vtProp.vt != VT_EMPTY)
			{
				if(!rParsedInfo.GetCmdSwitchesObject().SetPWhereExpr(
													(_TCHAR*)vtProp.bstrVal))
				{
					rParsedInfo.GetCmdSwitchesObject().
												SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
				}
			}
			if(retCode != PARSER_OUTOFMEMORY)
			{
				VARIANTCLEAR(vtProp);

				// Retrieve the  "Connection" property value
				VariantInit(&vtProp);
				hr = pIWbemObj->Get(_bstr_t(L"Connection"), 0, &vtProp, 0, 0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Connection\","
															  L"0, -, 0, 0)");
					GetBstrTFromVariant(vtProp, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										dwThreadId, rParsedInfo, m_bTrace,
										 0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				if (vtProp.vt != VT_NULL && vtProp.vt != VT_EMPTY)
				{
					pIUnknown = vtProp.punkVal;
					hr = pIUnknown->QueryInterface(IID_IWbemClassObject,
													(void**)&pIEmbedObj);

					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"QueryInterface("
												 L"IID_IWbemClassObject, -)");
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											(LPCWSTR)chsMsg, dwThreadId, 
											rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);

					retCode = 
						   ObtainAliasConnectionInfo(rParsedInfo, pIEmbedObj);

					//Releasing the embedded object.
					SAFEIRELEASE(pIEmbedObj);
					VARIANTCLEAR(vtProp);
				}
			}
		}

		// Obtain the alias description
		if (retCode != PARSER_OUTOFMEMORY)
		{
			_bstr_t bstrDesc;
			hr = GetDescOfObject(pIWbemObj, bstrDesc, rParsedInfo, TRUE);
			ONFAILTHROWERROR(hr);
		
			if(!rParsedInfo.GetCmdSwitchesObject().
											  SetAliasDesc((_TCHAR*)bstrDesc))
			{
				rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
				retCode = PARSER_OUTOFMEMORY;
			}
		}
		SAFEIRELEASE(pIWbemObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		VARIANTCLEAR(vtProp);
		VARIANTCLEAR(vtEmbedProp);

		// No errata code then set com error. 
		if ( rParsedInfo.GetCmdSwitchesObject().GetErrataCode() == 0 )
			rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		retCode = PARSER_ERRMSG;
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		VARIANTCLEAR(vtProp);
		VARIANTCLEAR(vtEmbedProp);
		retCode = PARSER_ERRMSG;
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainAliasConnectionInfo
   Synopsis          : Obtain the alias connection information like
					   1. namespace		2. user		3. password
					   4. locale		5. server	6. authority
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo  - The parsed info from command line input.		
		pIEmbedObj	 - Pointer to the IWbem class object
   Output parameter(s):
   		rParsedInfo   - The parsed info from command line input.		
   Return Type       :RETCODE
   Global Variables  :None
   Calling Syntax    :ObtainAliasConnectionInfo(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CCmdAlias::ObtainAliasConnectionInfo(CParsedInfo& rParsedInfo,
											 IWbemClassObject* pIEmbedObj)
{
	RETCODE retCode				= PARSER_CONTINUE;
	HRESULT	hr					= S_OK;
	UINT	uConnFlag			= 0;
	DWORD	dwThreadId			= GetCurrentThreadId();
	
	VARIANT vtEmbedProp;
	VariantInit(&vtEmbedProp);
	
	uConnFlag = rParsedInfo.GetGlblSwitchesObject().GetConnInfoFlag();

	try
	{
		CHString chsMsg;
		_bstr_t bstrResult;
		if (!(uConnFlag & NAMESPACE))
		{
			// retrieve the value of 'Namespace' property
			hr = pIEmbedObj->Get(_bstr_t(L"Namespace"), 0, &vtEmbedProp, 0,0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Get(L\"Namespace\", 0, -,"
																	L"0, 0)");
				GetBstrTFromVariant(vtEmbedProp, bstrResult);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									dwThreadId, rParsedInfo, m_bTrace,
								    0, bstrResult);
			}
			ONFAILTHROWERROR(hr);

			if (vtEmbedProp.vt != VT_NULL && vtEmbedProp.vt != VT_EMPTY)
			{
				if(!rParsedInfo.GetCmdSwitchesObject().SetAliasNamespace(
												(_TCHAR*)vtEmbedProp.bstrVal))
				{
					rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
				}
				VARIANTCLEAR(vtEmbedProp);
			}
		}
		if(retCode != PARSER_OUTOFMEMORY)
		{
			if (!(uConnFlag & LOCALE))
			{
				// retrieve the value of 'Locale' property
				hr = pIEmbedObj->Get(_bstr_t(L"Locale"), 0, &vtEmbedProp,0,0);

				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Locale\", 0,"
																 L"-, 0, 0)");
					GetBstrTFromVariant(vtEmbedProp, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
										dwThreadId, rParsedInfo, m_bTrace,
										0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				if (vtEmbedProp.vt != VT_NULL && vtEmbedProp.vt != VT_EMPTY)
				{
					if(!rParsedInfo.GetCmdSwitchesObject().SetAliasLocale(
												(_TCHAR*)vtEmbedProp.bstrVal))
					{
						rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
						retCode = PARSER_OUTOFMEMORY;
					}
					VARIANTCLEAR(vtEmbedProp);
				}
			}

			if(retCode != PARSER_OUTOFMEMORY)
			{
				if (!(uConnFlag & USER))
				{
					// retrieve the value of 'User' property
					hr = 
					  pIEmbedObj->Get(_bstr_t(L"User"), 0, &vtEmbedProp, 0,0);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Get(L\"User\", 0,"
																 L"-, 0, 0)");
					    GetBstrTFromVariant(vtEmbedProp, bstrResult);
						WMITRACEORERRORLOG( hr, __LINE__, __FILE__, 
											(LPCWSTR)chsMsg, dwThreadId, 
											rParsedInfo, m_bTrace,
										    0, bstrResult );
					}
					ONFAILTHROWERROR(hr);

					if (vtEmbedProp.vt != VT_NULL && 
						vtEmbedProp.vt != VT_EMPTY)
					{
						if(!rParsedInfo.GetCmdSwitchesObject().SetAliasUser(
											    (_TCHAR*)vtEmbedProp.bstrVal))
						{
							rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
							retCode = PARSER_OUTOFMEMORY;
						}
						VARIANTCLEAR(vtEmbedProp);
					}
				}
				
				if(retCode != PARSER_OUTOFMEMORY)
				{
					if (!(uConnFlag & PASSWORD))
					{
						// retrieve the value of 'Password' property
						hr = pIEmbedObj->Get(_bstr_t(L"Password"), 
											 0, &vtEmbedProp, 0,0);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IWbemClassObject::Get"
											  L"(L\"Password\", 0, -, 0, 0)");
							GetBstrTFromVariant(vtEmbedProp, bstrResult);
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
											   (LPCWSTR)chsMsg, dwThreadId, 
											   rParsedInfo, m_bTrace,
											   0, bstrResult);
						}
						ONFAILTHROWERROR(hr);

						if (vtEmbedProp.vt != VT_NULL && 
							vtEmbedProp.vt != VT_EMPTY)
						{
							if(!rParsedInfo.GetCmdSwitchesObject().
							   SetAliasPassword((_TCHAR*)vtEmbedProp.bstrVal))
							{
								rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
								retCode = PARSER_OUTOFMEMORY;
							}
							VARIANTCLEAR(vtEmbedProp);
						}
					}
					if(retCode != PARSER_OUTOFMEMORY)
					{
						if (!(uConnFlag & NODE))
						{
							// retrieve the value of 'Server' property
							hr = pIEmbedObj->Get(_bstr_t(L"Server"),
												 0, &vtEmbedProp, 0,0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
												L"(L\"Server\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtEmbedProp, bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							if (vtEmbedProp.vt != VT_NULL && 
								vtEmbedProp.vt != VT_EMPTY)
							{
								if(!rParsedInfo.GetCmdSwitchesObject().
								   SetAliasNode((_TCHAR*)vtEmbedProp.bstrVal))
								{
									rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
									retCode = PARSER_OUTOFMEMORY;
								}
								VARIANTCLEAR(vtEmbedProp);
							}
						}

						if (retCode != PARSER_OUTOFMEMORY)
						{
							// retrieve the value of 'Authority' property
							hr = pIEmbedObj->Get(_bstr_t(L"Authority"),
												 0, &vtEmbedProp, 0,0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
											 L"(L\"Authority\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtEmbedProp, bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							if (vtEmbedProp.vt != VT_NULL && 
								vtEmbedProp.vt != VT_EMPTY)
							{
								if(!rParsedInfo.GetCmdSwitchesObject().
								   SetAliasAuthorityPrinciple((_TCHAR*)vtEmbedProp.bstrVal))
								{
									rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
									retCode = PARSER_OUTOFMEMORY;
								}
								VARIANTCLEAR(vtEmbedProp);
							}
						}
					}
				}
			}
		}
	}
	catch(_com_error& e)
	{	
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		retCode = PARSER_OUTOFMEMORY;
		VARIANTCLEAR(vtEmbedProp);
	}
	catch(CHeap_Exception)
	{
		retCode = PARSER_OUTOFMEMORY;
		VARIANTCLEAR(vtEmbedProp);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return retCode;
}


/*----------------------------------------------------------------------------
   Name				 :ObtainAliasVerbDetails
   Synopsis          :Obtains the verbs and their details associated with the 
					  alias object and updates the CCommandSwitches  of 
					  CParsedInfo object passed to it.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - The parsed info from command line input.
   Output parameter(s):
   		rParsedInfo   - The parsed info from command line input.		
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :ObtainAliasVerbDetails(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::ObtainAliasVerbDetails(CParsedInfo& rParsedInfo)
{
	// variables being used in this function.
	IWbemClassObject	*pIWbemObj			= NULL;
	IWbemClassObject	*pIEmbedObj			= NULL;
	IWbemClassObject	*pIEmbedObj2		= NULL;
	HRESULT				hr					= S_OK;
	_TCHAR				szNumber[BUFFER512] = NULL_STRING; 
	DWORD				dwThreadId			= GetCurrentThreadId();
	VARIANT				vtVerbs,	vtVerbName, vtParameters, 
						vtParaId,	vtParaType,	vtVerbType, 
						vtVerbDerivation, vtDefaultParamValue;	
	VariantInit(&vtVerbs);
	VariantInit(&vtVerbName);
	VariantInit(&vtParameters);
	VariantInit(&vtParaId);
	VariantInit(&vtParaType);
	VariantInit(&vtVerbType);
	VariantInit(&vtVerbDerivation);
	VariantInit(&vtDefaultParamValue);
	try
	{
		CHString chsMsg;
		_bstr_t             bstrResult;
		// Initialize methDetMap each time.
		rParsedInfo.GetCmdSwitchesObject().GetMethDetMap().clear();

		_bstr_t bstrPath = _bstr_t("MSFT_CliAlias.FriendlyName='") + 
				   _bstr_t(rParsedInfo.GetCmdSwitchesObject().GetAliasName())+
				   _bstr_t(L"'");

		//Retrieving the object from the namespace in m_pIAliasNS
		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, &pIWbemObj, NULL);

		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Obtain verb name and method name to get info of verb name
		// or method name only if they are specified.
		_TCHAR* pVerbName = rParsedInfo.GetCmdSwitchesObject().GetVerbName();
		_TCHAR* pMethodName = rParsedInfo.GetCmdSwitchesObject().
															  GetMethodName();

		BOOL bCompareVerb = FALSE, bCompareMethod = FALSE;
		if ( pVerbName != NULL &&
			CompareTokens(pVerbName,CLI_TOKEN_CALL) &&
			pMethodName != NULL )
			bCompareMethod = TRUE;
		else if ( pVerbName != NULL &&
				  !CompareTokens(pVerbName,CLI_TOKEN_CALL))
				  bCompareVerb = TRUE;

		// Get "Verbs" property.
		hr = pIWbemObj->Get(_bstr_t(L"Verbs"), 0, &vtVerbs, 0, 0) ;
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Verbs\", 0, -, 0, 0)"); 
			GetBstrTFromVariant(vtVerbs, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
							   dwThreadId, rParsedInfo, m_bTrace,
							   0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if ( vtVerbs.vt != VT_EMPTY && vtVerbs.vt != VT_NULL)
		{
			// Get lower and upper bounds of Verbs array
			LONG lUpper = 0, lLower = 0;
			hr = SafeArrayGetLBound(vtVerbs.parray, vtVerbs.parray->cDims,
									&lLower);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(vtVerbs.parray, vtVerbs.parray->cDims,
									&lUpper);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
			{
				pIEmbedObj = NULL;
				// Get "Name" property.
				hr = SafeArrayGetElement(vtVerbs.parray,&lIndex,&pIEmbedObj);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
									   dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);
	
				hr = pIEmbedObj->Get(_bstr_t(L"Name"),0,&vtVerbName,0,0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Name\", 0, -,"
																    L"0, 0)");
					GetBstrTFromVariant(vtVerbName, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				// if user defined verb or method is specified then get info
				// of only related to user defined or method name.
				BOOL bContinue = FALSE;
				if ( bCompareMethod == TRUE &&
					 !CompareTokens(pMethodName,
								  (_TCHAR*)_bstr_t(vtVerbName.bstrVal) ) )
					bContinue = TRUE;
				else if ( bCompareVerb == TRUE &&
						 !CompareTokens(pVerbName,
										(_TCHAR*)_bstr_t(vtVerbName.bstrVal)))
					bContinue = TRUE;

				if ( bContinue == TRUE )
				{
					SAFEIRELEASE(pIEmbedObj);
					continue;
				}

				_bstr_t bstrDesc;
				hr = GetDescOfObject(pIEmbedObj, bstrDesc, rParsedInfo);
				ONFAILTHROWERROR(hr);
				
				//  Obtaining the input parameters and thier type.
				// Get "Parameters" property.
				hr = pIEmbedObj->Get(_bstr_t(L"Parameters"), 
									 0, &vtParameters, 0, 0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Parameters\","
															  L"0, -, 0, 0)");
					GetBstrTFromVariant(vtParameters, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				if ( vtVerbName.vt != VT_EMPTY && vtVerbName.vt != VT_NULL )
				{
					if ( bCompareVerb == TRUE || bCompareMethod == TRUE)
					{
						// Get "VerbType" property.
						hr = pIEmbedObj->Get(_bstr_t(L"VerbType"),
											 0, &vtVerbType, 0, 0);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IWbemClassObject::Get"
											  L"(L\"VerbType\", 0, -, 0, 0)");
							GetBstrTFromVariant(vtVerbType, bstrResult);
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId,
											   rParsedInfo, m_bTrace, 
											   0, bstrResult );
						}
						ONFAILTHROWERROR(hr);

						if ( vtVerbType.vt == VT_I4 )
						{
							rParsedInfo.GetCmdSwitchesObject().SetVerbType(
												 VERBTYPE(V_I4(&vtVerbType)));
						}
						else
						{
							rParsedInfo.GetCmdSwitchesObject().SetVerbType(
																	NONALIAS);
						}
						
						// Get "Derivation" property.
						hr = pIEmbedObj->Get(_bstr_t(L"Derivation"), 0,
											 &vtVerbDerivation, 0, 0);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IWbemClassObject::Get"
											L"(L\"Derivation\", 0, -, 0, 0)");
							GetBstrTFromVariant(vtVerbDerivation, bstrResult);
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId,
											   rParsedInfo, m_bTrace,
											   0, bstrResult);
					
						}
						ONFAILTHROWERROR(hr);

						if ( vtVerbDerivation.vt == VT_BSTR )
							rParsedInfo.GetCmdSwitchesObject().
										SetVerbDerivation(
										 _bstr_t(vtVerbDerivation.bstrVal));
					}

					METHODDETAILS mdMethDet;
					mdMethDet.Description = bstrDesc;
					if ( vtParameters.vt != VT_EMPTY && 
						 vtParameters.vt != VT_NULL )
					{
						// Get lower and upper bounds of Descriptions array
						LONG lUpper = 0, lLower = 0;
						hr = SafeArrayGetLBound(vtParameters.parray,
									vtParameters.parray->cDims, &lLower);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetLBound(-, -, -)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId, 
											   rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						hr = SafeArrayGetUBound(vtParameters.parray,
										 vtParameters.parray->cDims, &lUpper);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId,
											   rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
						{
							hr = SafeArrayGetElement(vtParameters.parray,
													 &lIndex, &pIEmbedObj2);
							if ( m_eloErrLogOpt )
							{
								chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, FALSE);
							}
							ONFAILTHROWERROR(hr);
							
							// Get "ParaId" property.
							hr = pIEmbedObj2->Get(_bstr_t(L"ParaId"),
												  0, &vtParaId, 0, 0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
												L"(L\"ParaId\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtParaId, bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							// Get "Type" property.
							hr = pIEmbedObj2->Get(_bstr_t(L"Type"), 0,
												  &vtParaType, 0, 0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
												  L"(L\"Type\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtParaType, bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							// Get "Default" property.
							hr = pIEmbedObj2->Get(_bstr_t(L"Default"), 0,
												  &vtDefaultParamValue, 0, 0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
											   L"(L\"Default\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtDefaultParamValue, 
													bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							if ( vtParaId.vt != VT_EMPTY && 
								 vtParaId.vt != VT_NULL )
							{
								PROPERTYDETAILS pdPropDet;

								pdPropDet.InOrOut = UNKNOWN;
								hr = GetQualifiers(pIEmbedObj2, pdPropDet,
												   rParsedInfo);

								if ( vtParaType.vt == VT_BSTR )
									pdPropDet.Type = vtParaType.bstrVal;
								else
									pdPropDet.Type = _bstr_t("Not Available");

								if ( vtDefaultParamValue.vt == VT_BSTR )
									pdPropDet.Default = vtDefaultParamValue.
														bstrVal;

								// Making bstrPropName begin with numbers to 
								// maintain the order of method arguments in
								// map. while displaying remove numbers and 
								// display the parameters in case of help only

								// Also for named paramlist and cmdline 
								// utility processing.
								_bstr_t bstrNumberedPropName; 
								if ( rParsedInfo.GetGlblSwitchesObject().
															  GetHelpFlag() ||
									 rParsedInfo.GetCmdSwitchesObject().
													GetVerbType() == CMDLINE )
								{
									_TCHAR szMsg[BUFFER512];
									_ltot(lIndex, szNumber, 10);
									_stprintf(szMsg, _T("%-5s"), szNumber);
									bstrNumberedPropName = _bstr_t(szMsg) +
													_bstr_t(vtParaId.bstrVal);
								}
								else
									bstrNumberedPropName = 
													_bstr_t(vtParaId.bstrVal);

								mdMethDet.Params.insert(
									PROPDETMAP::value_type(
											bstrNumberedPropName, pdPropDet));
							}
							
							VARIANTCLEAR(vtParaId);
							VARIANTCLEAR(vtParaType);
							VARIANTCLEAR(vtDefaultParamValue);
							SAFEIRELEASE(pIEmbedObj2);
						}
					}

					rParsedInfo.GetCmdSwitchesObject().AddToMethDetMap
											  (vtVerbName.bstrVal, mdMethDet);
				}

				VARIANTCLEAR(vtVerbName);
				VARIANTCLEAR(vtVerbType);
				VARIANTCLEAR(vtVerbDerivation);
				VARIANTCLEAR(vtParameters);
				SAFEIRELEASE(pIEmbedObj);
				if ( bCompareVerb == TRUE || bCompareMethod == TRUE)
					break;
			}
		}	
		VARIANTCLEAR(vtVerbs);
		SAFEIRELEASE(pIWbemObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		VARIANTCLEAR(vtVerbs);
		VARIANTCLEAR(vtVerbName);
		VARIANTCLEAR(vtVerbType);
		VARIANTCLEAR(vtVerbDerivation);
		VARIANTCLEAR(vtDefaultParamValue);
		hr = e.Error();
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		VARIANTCLEAR(vtVerbs);
		VARIANTCLEAR(vtVerbName);
		VARIANTCLEAR(vtVerbType);
		VARIANTCLEAR(vtVerbDerivation);
		VARIANTCLEAR(vtDefaultParamValue);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainAliasFriendlyNames
   Synopsis          :Obtains all the Friendly Names and descriptions in the 
					  CmdAlias and updates it in the CCommandSwitches of 
					  CParsedInfo object passed to it.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - The parsed info from command line input.		
   Output parameter(s):
   		rParsedInfo   - The parsed info from command line input.		
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :ObtainAliasFriendlyNames(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::ObtainAliasFriendlyNames(CParsedInfo& rParsedInfo)
{
	// variables being used in this function.
	HRESULT hr = S_OK;
	IEnumWbemClassObject		*pIEnumObj			= NULL;
	IWbemClassObject			*pIWbemObj			= NULL;
	DWORD						dwThreadId			= GetCurrentThreadId();
	VARIANT						vtName;
	VariantInit(&vtName);
	
	try
	{
		CHString chsMsg;
		_bstr_t						bstrResult;
		// Get alias object
		hr = m_pIAliasNS->ExecQuery(_bstr_t(L"WQL"), 
									_bstr_t(L"SELECT * FROM MSFT_CliAlias"),
									WBEM_FLAG_FORWARD_ONLY|
									WBEM_FLAG_RETURN_IMMEDIATELY,
									NULL, &pIEnumObj);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\"," 
					  L"L\"SELECT * FROM MSFT_CliAlias\","
					  L"WBEM_FLAG_FORWARD_ONLY|WBEM_FLAG_RETURN_IMMEDIATELY,"
					  L"NULL, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Set the security
		hr = SetSecurity(pIEnumObj, NULL, NULL, NULL, NULL,
				rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());

		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format( 
				L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,"
				L"NULL, %d,   %d, -, EOAC_NONE)",
				rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		ULONG ulReturned = 0; 
		
	 	// Obtain the object starting at the current position in the
		// enumeration and loop through the instance list.
		while(((hr=pIEnumObj->Next(WBEM_INFINITE,1,&pIWbemObj,&ulReturned))==
												   S_OK) && (ulReturned == 1))
		{
			VariantInit(&vtName);

			// Gets "FriendlyName" array property of alias object
			hr = pIWbemObj->Get(_bstr_t(L"FriendlyName"), 0, &vtName, 0, 0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Get(L\"FriendlyName\", 0,"
	     														 L"-, 0, 0)");
		        GetBstrTFromVariant(vtName, bstrResult);		
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace,
								   0, bstrResult);
			}
			ONFAILTHROWERROR(hr);

			if (vtName.vt != VT_NULL && vtName.vt != VT_EMPTY)
			{
				_bstr_t bstrFriendlyName = vtName.bstrVal;
				_bstr_t bstrDesc;
				hr = GetDescOfObject(pIWbemObj, bstrDesc, rParsedInfo, TRUE);
				ONFAILTHROWERROR(hr);

				//Add the "FriendlyName" to FriendlyName Map
				rParsedInfo.GetCmdSwitchesObject().
						AddToAlsFrnNmsOrTrnsTblMap(CharUpper(bstrFriendlyName)
												   ,bstrDesc);
			}
			VARIANTCLEAR(vtName);
			SAFEIRELEASE(pIWbemObj);
		}
		SAFEIRELEASE(pIEnumObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtName);
		hr = e.Error();
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtName);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainAliasFormat
   Synopsis          :Obtains the Derivation of the properties for the Format 
					  associated with the alias object and updates the 
					  CCommandSwitches of CParsedInfo object passed to it.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - The parsed info from command line input.		
   Output parameter(s):
   		rParsedInfo   - The parsed info from command line input.		
   Return Type       :BOOL : TRUE - if valid format is not present
							 FALSE - if invalid format
   Global Variables  :None
   Calling Syntax    :ObtainAliasFormat(rParsedInfo)
   Notes             :If bCheckForListFrmsAvail == TRUE then functions checks 
					  only for availibilty of list formats with the alias.
----------------------------------------------------------------------------*/
BOOL CCmdAlias::ObtainAliasFormat(CParsedInfo& rParsedInfo,
								  BOOL bCheckForListFrmsAvail)
{
	// variables being used in this function.
	HRESULT				hr					= S_OK;
	IWbemClassObject	*pIWbemObj			= NULL;
	IWbemClassObject	*pIEmbedObj			= NULL;
	IWbemClassObject	*pIEmbedObj2		= NULL;
	BOOL				bExist				= FALSE;
	DWORD				dwThreadId			= GetCurrentThreadId();
	VARIANT				vtFormats, vtFormatName, 
						vtProperties, vtPropertyName, vtPropertyDerivation ;
	BOOL				bHelp				= rParsedInfo.
											  GetGlblSwitchesObject().
											  GetHelpFlag();
	// Initializing all Variants variables being used in this function.
	VariantInit(&vtFormats);
	VariantInit(&vtFormatName);
	VariantInit(&vtProperties);
	VariantInit(&vtPropertyName);
	VariantInit(&vtPropertyDerivation);

	try
	{
		CHString			chsMsg;
		_bstr_t				bstrResult;
		_bstr_t bstrPath = 	_bstr_t("MSFT_CliAlias.FriendlyName='") + 
				 _bstr_t(rParsedInfo.GetCmdSwitchesObject().GetAliasName())+
				 _bstr_t(L"'");

		// Get alias object
		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, &pIWbemObj, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Get Formats array property of alias object
		hr = pIWbemObj->Get(_bstr_t(L"Formats"), 0, &vtFormats, 0, 0);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Formats\", 0, -,0, 0)");
			GetBstrTFromVariant(vtFormats, bstrResult);		
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace,
							   0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if ( vtFormats.vt != VT_NULL && vtFormats.vt != VT_EMPTY 
			 && bCheckForListFrmsAvail == FALSE)
		{
			// Get lower and upper bounds of Formats array
			LONG lUpper = 0, lLower = 0;
			hr = SafeArrayGetLBound(vtFormats.parray, vtFormats.parray->cDims,
									&lLower);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(vtFormats.parray, vtFormats.parray->cDims,
									&lUpper);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			// Iterate through the Formats array property
			for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
		    {
				// Get this property.
				hr =SafeArrayGetElement(vtFormats.parray,&lIndex,&pIEmbedObj);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
									   dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				hr = pIEmbedObj->Get(_bstr_t(L"Name"),0,&vtFormatName,0,0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Name\", 0,"
																 L"-, 0, 0)");
					GetBstrTFromVariant(vtFormatName, bstrResult);		
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				//Comparing the specified Format in the alias against the
				//formats available for the specified alias.
				if(CompareTokens(_bstr_t(rParsedInfo.GetCmdSwitchesObject().
						GetListFormat()), _bstr_t(vtFormatName.bstrVal)))
				{
					bExist = TRUE;

					VARIANT vtFormat;
					VariantInit(&vtFormat);
					//Getting the "Format" property.
					hr = pIEmbedObj->Get(_bstr_t(L"Format"),0, 
										 &vtFormat, 0, 0);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format( L"IWbemClassObject::Get(L\"Format\","
															  L"0, -, 0, 0)");
						GetBstrTFromVariant(vtFormat, bstrResult);		
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										   (LPCWSTR)chsMsg, dwThreadId, 
										   rParsedInfo, m_bTrace,
										   0, bstrResult);
					}
					ONFAILTHROWERROR(hr);

					if ( vtFormat.vt != VT_EMPTY && vtFormat.vt != VT_NULL  )
					{
						if (rParsedInfo.GetCmdSwitchesObject(). 
											GetXSLTDetailsVector().empty())
						{
							_bstr_t bstrFileName ;
							
							// If _T("") is the value, it should be treated as 
							// equivalent to <empty>
							if (CompareTokens(vtFormat.bstrVal, _T("")))
							{
								FrameFileAndAddToXSLTDetVector	(
																	XSL_FORMAT_TABLE,
																	CLI_TOKEN_TABLE,
																	rParsedInfo
																);
							}
							else
							{
								g_wmiCmd.GetFileFromKey(vtFormat.bstrVal, bstrFileName);

								XSLTDET xdXSLTDet;
								xdXSLTDet.FileName = bstrFileName;
								FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
																rParsedInfo);
							}
						}
					}
					VariantClear(&vtFormat);

					//Getting the "Properties" property.
					hr=pIEmbedObj->Get(_bstr_t(L"Properties"), 
									   0, &vtProperties, 0, 0);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Get(L\"Properties\","
															  L"0, -, 0, 0)");
						GetBstrTFromVariant(vtProperties, bstrResult);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										   (LPCWSTR)chsMsg, dwThreadId, 
										   rParsedInfo, m_bTrace,
										   0, bstrResult);
					}
					ONFAILTHROWERROR(hr);

					if ( vtProperties.vt != VT_NULL )
					{
						LONG lILower = 0, lIUpper = 0;
						hr = SafeArrayGetLBound(vtProperties.parray,
										vtProperties.parray->cDims, &lILower);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetLBound(-, -, -)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId, 
											   rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						hr = SafeArrayGetUBound(vtProperties.parray,
										vtProperties.parray->cDims, &lIUpper);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetUBound(-, -, -)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId,
											   rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						// Iterate through the Properties array property
						for(LONG lIIndex = lILower; 
							lIIndex <= lIUpper; 
							lIIndex++)
						{
							// Get this property.
							hr = SafeArrayGetElement(vtProperties.parray, 
													  &lIIndex, &pIEmbedObj2);

							if ( m_eloErrLogOpt )
							{
								chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg, dwThreadId,
												   rParsedInfo, FALSE);
							}
							ONFAILTHROWERROR(hr);

							//Getting the "Name" property
							hr = pIEmbedObj2->Get(_bstr_t(L"Name"), 0,
												  &vtPropertyName,0,0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
												  L"(L\"Name\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtPropertyName,
													bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
												   (LPCWSTR)chsMsg, dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							//Getting the "Derivation" property
							hr = pIEmbedObj2->Get(_bstr_t(L"Derivation"), 0,
												  &vtPropertyDerivation,0,0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
										    L"(L\"Derivation\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtPropertyDerivation,
													bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
												   (LPCWSTR)chsMsg, dwThreadId,
												   rParsedInfo, m_bTrace,
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							_bstr_t bstrPropName;
							if ( bHelp )
							{
								if ( vtPropertyName.vt == VT_BSTR )
									bstrPropName = vtPropertyName.bstrVal;
							}
							else
							{
								if ( vtPropertyDerivation.vt == VT_BSTR )
									bstrPropName = vtPropertyDerivation.bstrVal;
								else if ( vtPropertyName.vt == VT_BSTR )
									bstrPropName = vtPropertyName.bstrVal;
							}

							//Add propertyderivation to property list in 
							// rParsedInfo
							if((!bstrPropName == FALSE) &&
								!rParsedInfo.GetCmdSwitchesObject().
									   AddToPropertyList(
									   (_TCHAR*)bstrPropName))
							{
								rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
								bExist = FALSE;
								VARIANTCLEAR(vtPropertyDerivation);
								break;
							}
							
							// Add propertyname to property list in
							// rParsedInfo only to avail information of Name 
							// and Derivation of list properties for XML 
							// logging.
							PROPERTYDETAILS pdPropDet;
							if ( vtPropertyDerivation.vt == VT_BSTR )
								pdPropDet.Derivation = 
												 vtPropertyDerivation.bstrVal;
							else
								pdPropDet.Derivation = _bstr_t(TOKEN_NA);

							rParsedInfo.GetCmdSwitchesObject().
									AddToPropDetMap(
									   vtPropertyName.bstrVal, pdPropDet);

							VARIANTCLEAR(vtPropertyName);
							VARIANTCLEAR(vtPropertyDerivation);
							// Release pIEmbedObj2
							SAFEIRELEASE(pIEmbedObj2);
						}
					}
					// Release memory held by vtProperties 
					VARIANTCLEAR(vtProperties);
					// Free memory held by vtFormatName
					VARIANTCLEAR(vtFormatName);
					// Release pIEmbedObj
					SAFEIRELEASE(pIEmbedObj);
					break;
				}
				// Free memory held by vtFormatName
				VARIANTCLEAR(vtFormatName);
				// Release pIEmbedObj
				SAFEIRELEASE(pIEmbedObj);
			}
			// Release memory held by vtFormats
			VARIANTCLEAR(vtFormats);
		}
		else if ( vtFormats.vt != VT_NULL && vtFormats.vt != VT_EMPTY )
		{
			bExist = TRUE;
		}
		// Release pIWbem object
		SAFEIRELEASE(pIWbemObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		SAFEIRELEASE(pIEmbedObj2);
		VARIANTCLEAR(vtFormats);
		VARIANTCLEAR(vtFormatName);
		VARIANTCLEAR(vtProperties);
		VARIANTCLEAR(vtPropertyName);
		VARIANTCLEAR(vtPropertyDerivation);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bExist = FALSE;
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		SAFEIRELEASE(pIEmbedObj2);
		VARIANTCLEAR(vtFormats);
		VARIANTCLEAR(vtFormatName);
		VARIANTCLEAR(vtProperties);
		VARIANTCLEAR(vtPropertyName);
		VARIANTCLEAR(vtPropertyDerivation);
		bExist = FALSE;
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return bExist;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainAliasPropDetails
   Synopsis          :Obtains the details of the properties for the Format 
					  associated with the alias object and updates the 
					  CCommandSwitches of CParsedInfo object passed to it.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - The parsed info from command line input.		
   Output parameter(s):
   		rParsedInfo   - The parsed info from command line input.		
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :ObtainAliasPropDetails(rParsedInfo)
   Notes             :pbCheckWritePropsAvailInAndOut == TRUE then function 
					  checks for availibility of properties and returns in 
					  the same pbCheckWritePropsAvailInAndOut parameter.
					  pbCheckFULLPropsAvailInAndOut == TRUE then function
					  checks for availibility of alias properties i.e in FULL
					  list format.
					  Imp : Any one of the input pointers can only be 
							specified.
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::ObtainAliasPropDetails(CParsedInfo& rParsedInfo,
										 BOOL *pbCheckWritePropsAvailInAndOut,
										 BOOL *pbCheckFULLPropsAvailInAndOut)
{ 
	// variables being used in this function.
	HRESULT				hr					= S_OK;
	IWbemClassObject	*pIWbemObj			= NULL;
	IWbemClassObject	*pIEmbedObj			= NULL;
	IWbemClassObject	*pIEmbedObj2		= NULL;
	BOOL				bPropList			= FALSE;
	_TCHAR				*pszVerbName		= NULL;
	DWORD				dwThreadId			= GetCurrentThreadId();
	VARIANT				vtFormats, vtFormatName, 
						vtProperties, vtPropertyName, vtPropertyDerivation;
	// Initializing all Variants variables being used in this function.
	VariantInit(&vtFormats);
	VariantInit(&vtFormatName);
	VariantInit(&vtProperties);
	VariantInit(&vtPropertyName);
	VariantInit(&vtPropertyDerivation);
	CHARVECTOR cvPropList;  

	if ( pbCheckWritePropsAvailInAndOut != NULL )
		*pbCheckWritePropsAvailInAndOut = FALSE;

	if ( pbCheckFULLPropsAvailInAndOut != NULL )
		*pbCheckFULLPropsAvailInAndOut = FALSE;

	try
	{
		CHString			chsMsg;
		_bstr_t				bstrResult;
		pszVerbName = rParsedInfo.GetCmdSwitchesObject().GetVerbName();

		cvPropList = rParsedInfo.GetCmdSwitchesObject().GetPropertyList();
		if ( cvPropList.size() != 0 )
			bPropList = TRUE;

		_bstr_t bstrPath = _bstr_t("MSFT_CliAlias.FriendlyName='") + 
				_bstr_t(rParsedInfo.GetCmdSwitchesObject().GetAliasName())+
				_bstr_t(L"'");

		// Get alias object
		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, &pIWbemObj, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format( L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Get Formats array property of alias object
		hr = pIWbemObj->Get(_bstr_t(L"Formats"), 0, &vtFormats, 0, 0);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Formats\", 0,"
																 L"-, 0, 0)");
			GetBstrTFromVariant(vtFormats, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace,
							   0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		BOOL bSetVerb = pszVerbName != NULL && 
					    CompareTokens(pszVerbName,CLI_TOKEN_SET);

		if ( vtFormats.vt != VT_NULL && vtFormats.vt != VT_EMPTY )
		{
			// Get lower and upper bounds of Formats array
			LONG lUpper = 0, lLower = 0;
			hr = SafeArrayGetLBound(vtFormats.parray, vtFormats.parray->cDims,
									&lLower);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(vtFormats.parray,vtFormats.parray->cDims,
									&lUpper);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			// Iterate through the Formats array property
			for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
		    {
				// Get this property.
				hr=SafeArrayGetElement(vtFormats.parray,&lIndex,&pIEmbedObj);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				hr = pIEmbedObj->Get(_bstr_t(L"Name"),0,&vtFormatName,0,0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Name\", 0,"
															     L"-, 0, 0)");
					GetBstrTFromVariant(vtFormatName, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				BOOL bGetProps = FALSE;

				if ( pbCheckWritePropsAvailInAndOut != NULL)
					bGetProps = CompareTokens(_bstr_t(vtFormatName.bstrVal),
															_T("WRITEABLE"));
				else if ( pbCheckFULLPropsAvailInAndOut != NULL)
					bGetProps = CompareTokens(_bstr_t(vtFormatName.bstrVal),
															_T("FULL"));
				else
				{
					bGetProps = (bSetVerb) ? 
					 ((rParsedInfo.GetHelpInfoObject().GetHelp(SETVerb)) ? 
					 CompareTokens(_bstr_t(vtFormatName.bstrVal),
															 _T("WRITEABLE")):
					 CompareTokens(_bstr_t(vtFormatName.bstrVal),
																_T("FULL")) ):
					 CompareTokens(_bstr_t(vtFormatName.bstrVal),_T("FULL"));
				}

				//Comparing the specified Format in the alias against
				//the formats available for the specified alias.
				if( bGetProps )
				{
					//Getting the "Properties" property.
					hr=pIEmbedObj->Get(_bstr_t(L"Properties"),0,
									   &vtProperties, 0, 0);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Get"
											L"(L\"Properties\", 0, -, 0, 0)");
						GetBstrTFromVariant(vtProperties, bstrResult);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										   (LPCWSTR)chsMsg, dwThreadId,
										   rParsedInfo, m_bTrace,
										   0, bstrResult);
					}
					ONFAILTHROWERROR(hr);

					if ( vtProperties.vt != VT_NULL )
					{
						LONG lILower = 0, lIUpper = 0;
						hr = SafeArrayGetLBound(vtProperties.parray,
										vtProperties.parray->cDims, &lILower);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetLBound(-, -, -)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											   (LPCWSTR)chsMsg, dwThreadId,
											   rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);


						hr = SafeArrayGetUBound(vtProperties.parray,
										vtProperties.parray->cDims, &lIUpper);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetUBound(-, -, -)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											  (LPCWSTR)chsMsg, dwThreadId,
											  rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);
					
						// Iterate through the Properties array property
						for(LONG lIIndex=lILower; lIIndex<=lIUpper; lIIndex++)
						{
							// Get this property.
							hr = SafeArrayGetElement(vtProperties.parray,
													  &lIIndex, &pIEmbedObj2);
							if ( m_eloErrLogOpt ) 
							{
								chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, FALSE);
							}
							ONFAILTHROWERROR(hr);

							//Getting the "Name" property
							hr = pIEmbedObj2->Get(_bstr_t(L"Name"),	0,
												  &vtPropertyName,0,0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
												  L"(L\"Name\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtPropertyName,
													bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
												   (LPCWSTR)chsMsg,dwThreadId,
												   rParsedInfo, m_bTrace, 
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);
							
							//Getting the "Derivation" property
							hr = pIEmbedObj2->Get(_bstr_t(L"Derivation"),	0,
												  &vtPropertyDerivation,0,0);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IWbemClassObject::Get"
										    L"(L\"Derivation\", 0, -, 0, 0)");
								GetBstrTFromVariant(vtPropertyDerivation,
													bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
												   (LPCWSTR)chsMsg,dwThreadId, 
												   rParsedInfo, m_bTrace, 
												   0, bstrResult);
							}
							ONFAILTHROWERROR(hr);

							if (vtPropertyName.vt == VT_BSTR)
							{
								CHARVECTOR::iterator tempIterator;
								if ( bPropList == TRUE &&
									 !Find(cvPropList, 
										  _bstr_t(vtPropertyName.bstrVal),
										  tempIterator) )
								{
									SAFEIRELEASE(pIEmbedObj2)
									continue;
								}

								if ( pbCheckWritePropsAvailInAndOut != NULL)
								{
									*pbCheckWritePropsAvailInAndOut = TRUE;
									SAFEIRELEASE(pIEmbedObj2);
									break;
								}

								if ( pbCheckFULLPropsAvailInAndOut != NULL)
								{
									*pbCheckFULLPropsAvailInAndOut = TRUE;
									SAFEIRELEASE(pIEmbedObj2);
									break;
								}

								_bstr_t bstrDesc;
								hr = GetDescOfObject(pIEmbedObj2, bstrDesc, 
																 rParsedInfo);
								ONFAILTHROWERROR(hr);

								PROPERTYDETAILS pdPropDet;
								if (vtPropertyDerivation.vt == VT_BSTR)
									pdPropDet.Derivation = 
												 vtPropertyDerivation.bstrVal;
								else
									pdPropDet.Derivation = _bstr_t(TOKEN_NA);

								if (bstrDesc != _bstr_t(""))
									pdPropDet.Description = bstrDesc;
								else
									pdPropDet.Description = _bstr_t(TOKEN_NA);


								hr = GetQualifiers(pIEmbedObj2, pdPropDet,
												   rParsedInfo);
								if (!pdPropDet.Type)
									pdPropDet.Type = _bstr_t(TOKEN_NA);

								if (!pdPropDet.Operation)
									pdPropDet.Operation = _bstr_t(TOKEN_NA);
								// Add propertyname to property list in
								// rParsedInfo
								rParsedInfo.GetCmdSwitchesObject().
										AddToPropDetMap(
										   vtPropertyName.bstrVal, pdPropDet);
								VARIANTCLEAR(vtPropertyName);
								VARIANTCLEAR(vtPropertyDerivation);
							}
							SAFEIRELEASE(pIEmbedObj2)
						}
					}
					// Release memory held by vtProperties 
					VARIANTCLEAR(vtProperties);
					// Free memory held by vtFormatName
					VARIANTCLEAR(vtFormatName);
					// Release pIEmbedObj
					SAFEIRELEASE(pIEmbedObj);
					break;
				}
				// Free memory held by vtFormatName
				VARIANTCLEAR(vtFormatName);
				// Release pIEmbedObj
				SAFEIRELEASE(pIEmbedObj);
			}
			// Release memory held by vtFormats
			VARIANTCLEAR(vtFormats);
		}
		SAFEIRELEASE(pIWbemObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		SAFEIRELEASE(pIEmbedObj2);
		VARIANTCLEAR(vtFormats);
		VARIANTCLEAR(vtFormatName);
		VARIANTCLEAR(vtProperties);
		VARIANTCLEAR(vtPropertyName);
		VARIANTCLEAR(vtPropertyDerivation);
		hr = e.Error();
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEmbedObj);
		SAFEIRELEASE(pIEmbedObj2);
		VARIANTCLEAR(vtFormats);
		VARIANTCLEAR(vtFormatName);
		VARIANTCLEAR(vtProperties);
		VARIANTCLEAR(vtPropertyName);
		VARIANTCLEAR(vtPropertyDerivation);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :GetDescOfObject
   Synopsis          :Get the Localized description from alias definition.
   Type	             :Member Function
   Input parameter(s):
		pIWbemClassObject	- IWbemLocator object
		rParsedInfo			- The parsed info from command line input.		
   Output parameter(s):
		bstrDescription		- Localized description 
   		rParsedInfo`		- The parsed info from command line input.	
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :GetDescOfObject(pIObject, bstrDescription,
										rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::GetDescOfObject(IWbemClassObject* pIObject, 
								  _bstr_t& bstrDescription, 
								  CParsedInfo& rParsedInfo,
								  BOOL bLocalizeFlag)
{
	HRESULT					hr					= S_OK;
	DWORD					dwThreadId			= GetCurrentThreadId();	
	VARIANT					vtDesc, vtRelPath;	
	VariantInit(&vtDesc);
	VariantInit(&vtRelPath);
	try
	{
		CHString	chsMsg;		
		_bstr_t		bstrRelPath;
		_bstr_t     bstrResult;
		if (!bLocalizeFlag)
		{
			// Get "Description" property.
			hr = pIObject->Get(_bstr_t(L"Description"), 0, &vtDesc, 0, 0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Get(L\"Description\", 0,"
																 L"-, 0, 0)");
				GetBstrTFromVariant(vtDesc, bstrResult);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace,
								   0 ,bstrResult);
			}
			ONFAILTHROWERROR(hr);

			if (vtDesc.vt == VT_BSTR )
				bstrDescription = vtDesc.bstrVal;

			VARIANTCLEAR(vtDesc);
		}
		else // Get the localized description
		{
			// Get the __RELPATH
			hr = pIObject->Get(_bstr_t(L"__RELPATH"), 0, &vtRelPath, 0, 0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Get(L\"__RELPATH\", 0,"
																 L"-, 0, 0)");
				GetBstrTFromVariant(vtRelPath, bstrResult);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace,
								   0, bstrResult);
			}
			ONFAILTHROWERROR(hr);
		
			if ((vtRelPath.vt != VT_NULL) && (vtRelPath.vt != VT_EMPTY))
			{
				// Get localized description of the  property.
				hr = GetLocalizedDesc(vtRelPath.bstrVal, 
									  bstrDescription, rParsedInfo);
				if(FAILED(hr))
				{
					hr = S_OK;
					WMIFormatMessage(IDS_E_NO_DESC, 0, bstrDescription, NULL);
				}
			}
			VARIANTCLEAR(vtRelPath);
		}
	}
	catch (_com_error& e)
	{
		VARIANTCLEAR(vtRelPath);
		VARIANTCLEAR(vtDesc);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(vtRelPath);
		VARIANTCLEAR(vtDesc);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainTranslateTableEntries
   Synopsis          :Obtain the translate table information from the alias
					  definition
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo	 - The parsed info from command line input.		
   Output parameter(s):
   		rParsedInfo  - The parsed info from command line input.	
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :ObtainTranslateTableEntries(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CCmdAlias::ObtainTranslateTableEntries(CParsedInfo& rParsedInfo)
{
	BOOL					bSuccess				= TRUE;
	HRESULT					hr						= S_OK;
	IWbemClassObject		*pIWbemObjOfTable		= NULL,
							*pIWbemObjOfTblEntry	= NULL;
	DWORD					dwThreadId				= GetCurrentThreadId();
	VARIANT					vtTblEntryArr, vtFromValue, vtToValue;
	VariantInit(&vtTblEntryArr);
	VariantInit(&vtFromValue);
	VariantInit(&vtToValue);

	try
	{
		CHString chsMsg;
		_bstr_t  bstrResult;
		_bstr_t  bstrPath = 	_bstr_t("MSFT_CliTranslateTable.Name='") + 
		  _bstr_t(rParsedInfo.GetCmdSwitchesObject().GetTranslateTableName())+
		  _bstr_t(L"'");

		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, 
									&pIWbemObjOfTable, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		// do not add ONFAILTHROWERROR(hr) here, as following statement checks
		// for validity

		if ( pIWbemObjOfTable != NULL )
		{
			VariantInit(&vtTblEntryArr);
			hr = pIWbemObjOfTable->Get(_bstr_t(L"Tbl"), 0, 
									   &vtTblEntryArr, 0, 0 );
			if ( vtTblEntryArr.vt != VT_NULL && vtTblEntryArr.vt != VT_EMPTY )
			{
				LONG lUpper = 0, lLower = 0;
				hr = SafeArrayGetLBound(vtTblEntryArr.parray,
										vtTblEntryArr.parray->cDims,
										&lLower);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);
				
				hr = SafeArrayGetUBound(vtTblEntryArr.parray,
										vtTblEntryArr.parray->cDims,
										&lUpper);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
									   dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);


				for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
				{
					pIWbemObjOfTblEntry = NULL;
					hr = SafeArrayGetElement(vtTblEntryArr.parray,&lIndex,
											 &pIWbemObjOfTblEntry);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					VariantInit(&vtFromValue);
					VariantInit(&vtToValue);
					hr = pIWbemObjOfTblEntry->Get(_bstr_t(L"FromValue"), 0, 
												  &vtFromValue, 0, 0 );
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Get(L\"FromValue\","
															  L"0, -, 0, 0)");
						GetBstrTFromVariant(vtFromValue, bstrResult);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										   (LPCWSTR)chsMsg, dwThreadId, 
										   rParsedInfo, m_bTrace,
										   0, bstrResult);
					}
					ONFAILTHROWERROR(hr);

					hr = pIWbemObjOfTblEntry->Get(_bstr_t(L"ToValue"),
												  0, &vtToValue, 0, 0 );
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Get(L\"ToValue\", "
															  L"0, -, 0, 0)");
						GetBstrTFromVariant(vtToValue, bstrResult);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										   (LPCWSTR)chsMsg, dwThreadId,
										   rParsedInfo, m_bTrace,
										   0 , bstrResult);
					}
					ONFAILTHROWERROR(hr);

					rParsedInfo.GetCmdSwitchesObject().
					   AddToAlsFrnNmsOrTrnsTblMap( 
												 _bstr_t(vtFromValue.bstrVal),
												 _bstr_t(vtToValue.bstrVal) );
					VARIANTCLEAR(vtFromValue);
					VARIANTCLEAR(vtToValue);
					SAFEIRELEASE(pIWbemObjOfTblEntry);
				}
			}
			else
				bSuccess = FALSE;

			SAFEIRELEASE(pIWbemObjOfTable);
			VARIANTCLEAR(vtTblEntryArr);
		}
		else
			bSuccess = FALSE;
	}

	catch(_com_error& e)
	{
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bSuccess = FALSE;
		SAFEIRELEASE(pIWbemObjOfTable);
		VARIANTCLEAR(vtTblEntryArr);
		VARIANTCLEAR(vtFromValue);
		VARIANTCLEAR(vtToValue);
		SAFEIRELEASE(pIWbemObjOfTblEntry);
	}
	catch(CHeap_Exception)
	{
		bSuccess = FALSE;
		SAFEIRELEASE(pIWbemObjOfTable);
		VARIANTCLEAR(vtTblEntryArr);
		VARIANTCLEAR(vtFromValue);
		VARIANTCLEAR(vtToValue);
		SAFEIRELEASE(pIWbemObjOfTblEntry);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return bSuccess;
}

/*----------------------------------------------------------------------------
   Name				 :PopulateAliasFormatMap
   Synopsis          :populate the alias format map with the available formats
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :PopulateAliasFormatMap(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::PopulateAliasFormatMap(CParsedInfo& rParsedInfo)
{
	// variables being used in this function.
	HRESULT				hr					= S_OK;
	IWbemClassObject	*pIWbemObj			= NULL;
	IWbemClassObject	*pIEmbedObj			= NULL;
	VARIANT				vtFormats, vtFormatName;
	
	// Initializing all Variants variables being used in this function.
	VariantInit(&vtFormats);
	VariantInit(&vtFormatName);
	DWORD dwThreadId = GetCurrentThreadId();
	
	try
	{
		CHString 	chsMsg;
		_bstr_t		bstrResult;
		_bstr_t bstrPath = _bstr_t("MSFT_CliAlias.FriendlyName='") + 
				  _bstr_t(rParsedInfo.GetCmdSwitchesObject().GetAliasName()) +
				  _bstr_t(L"'");

		// Get alias object
		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, &pIWbemObj, NULL);

		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Get Formats array property of alias object
		hr = pIWbemObj->Get(_bstr_t(L"Formats"), 0, &vtFormats, 0, 0);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Formats\", 0,"
																 L"-, 0, 0)");
			GetBstrTFromVariant(vtFormats, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace,
							   0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if ( vtFormats.vt != VT_NULL && vtFormats.vt != VT_EMPTY )
		{
			// Get lower and upper bounds of Formats array
			LONG lUpper = 0, lLower = 0;
			hr = SafeArrayGetLBound(vtFormats.parray, vtFormats.parray->cDims,
									&lLower);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);
		    
			hr = SafeArrayGetUBound(vtFormats.parray, vtFormats.parray->cDims,
									&lUpper);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);
			
			// Iterate through the Formats array property
			for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
		    {
				VariantInit(&vtFormatName);

				// Get this property.
				hr =SafeArrayGetElement(vtFormats.parray,&lIndex,&pIEmbedObj);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
									   dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);
				
				hr = pIEmbedObj->Get(_bstr_t(L"Name"),0,&vtFormatName,0,0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"Name\", 0,"
																 L"-, 0, 0)");
					GetBstrTFromVariant(vtFormatName, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);
				
				// To obtain properties from alias associated with the format
				rParsedInfo.GetCmdSwitchesObject().SetListFormat(
											   _bstr_t(vtFormatName.bstrVal));

				if ( ObtainAliasFormat(rParsedInfo) == TRUE )
				{
					CHARVECTOR cvProps = rParsedInfo.GetCmdSwitchesObject().
															GetPropertyList();
					CHARVECTOR::iterator cvIterator;
					BSTRVECTOR bvProps;
					for ( cvIterator = cvProps.begin();
						  cvIterator != cvProps.end();
						  cvIterator++ )
					{
						bvProps.push_back(_bstr_t(*cvIterator));
					}

					//Add format name to format list in rParsedInfo
					rParsedInfo.GetCmdSwitchesObject().
						AddToAliasFormatDetMap(vtFormatName.bstrVal, bvProps);

					rParsedInfo.GetCmdSwitchesObject().ClearPropertyList();
				}

				SAFEIRELEASE(pIEmbedObj);
			}
			// Release memory held by vtFormats
			VARIANTCLEAR(vtFormats);
		}
		// Release pIWbem object
		SAFEIRELEASE(pIWbemObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIEmbedObj);
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtFormats);
		VARIANTCLEAR(vtFormatName);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIEmbedObj);
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtFormats);
		VARIANTCLEAR(vtFormatName);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainTranslateTables
   Synopsis          :Obtain the information about translate tables available
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo   - reference to CParsedInfo class object
   Output parameter(s):
   		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :ObtainTranslateTables(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::ObtainTranslateTables(CParsedInfo& rParsedInfo)
{
	// variables being used in this function.
	HRESULT hr = S_OK;
	IEnumWbemClassObject		*pIEnumObj			= NULL;
	IWbemClassObject			*pIWbemObj			= NULL;
	DWORD						dwThreadId			= GetCurrentThreadId();
	VARIANT						vtName;
	VariantInit(&vtName);
	
	try
	{
		CHString	chsMsg;
		_bstr_t		bstrResult;
		// Get alias object
		hr = m_pIAliasNS->ExecQuery(_bstr_t(L"WQL"), 
							_bstr_t(L"SELECT * FROM MSFT_CliTranslateTable"),
							WBEM_FLAG_FORWARD_ONLY|
							WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pIEnumObj);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\"," 
					   L"L\"SELECT * FROM MSFT_CliTranslateTable\","
					   L"WBEM_FLAG_FORWARD_ONLY|WBEM_FLAG_RETURN_IMMEDIATELY,"
					   L"NULL, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Set the security
		hr = SetSecurity(pIEnumObj, NULL, NULL, NULL, NULL,
				rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());

		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format( 
				  L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,"
				  L"NULL, %d,   %d, -, EOAC_NONE)",
				rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		ULONG ulReturned = 0; 
		
		hr=pIEnumObj->Next(WBEM_INFINITE,1,&pIWbemObj,&ulReturned);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IEnumWbemClassObject->Next"
				L"(WBEM_INFINITE, 1, -, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

	 	// Obtain the object starting at the current position in the
		// enumeration and loop through the instance list.
		while(ulReturned == 1)
		{
			VariantInit(&vtName);

			// Gets "FriendlyName" array property of alias object
			hr = pIWbemObj->Get(_bstr_t(L"Name"), 0, &vtName, 0, 0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Get(L\"Name\", 0,"
						  L"-, 0, 0)"); 
				GetBstrTFromVariant(vtName, bstrResult);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__,  (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, m_bTrace,
								   0, bstrResult);
			}
			ONFAILTHROWERROR(hr);

			if (vtName.vt != VT_NULL && vtName.vt != VT_EMPTY)
			{
				rParsedInfo.GetCmdSwitchesObject().
										  AddToTrnsTablesList(vtName.bstrVal);
			}
			VARIANTCLEAR(vtName);
			SAFEIRELEASE(pIWbemObj);

			// Move to next instance in the enumeration.
			hr = pIEnumObj->Next(WBEM_INFINITE, 1, &pIWbemObj, &ulReturned);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(
					L"IEnumWbemClassObject->Next(WBEM_INFINITE, 1, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
					dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
		}
		SAFEIRELEASE(pIEnumObj);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtName);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtName);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ConnectToLocalizedNS
   Synopsis          :This function connects to localized WMI namespace 
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo  - reference to CParsedInfo class object.
		pIWbemLocator- IWbemLocator object for connecting to WMI.						
   Output parameter(s):
		rParsedInfo  - reference to CParsedInfo class object.
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :ConnectToLocalizedNS(rParsedInfo,pIWbemLocator)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::ConnectToLocalizedNS(CParsedInfo& rParsedInfo, 
								        IWbemLocator* pIWbemLocator)
{
	DWORD	dwThreadId	= GetCurrentThreadId();
	HRESULT hr			= S_OK;

	// If the /LOCALE value has been changed since last invocation
	if (rParsedInfo.GetGlblSwitchesObject().GetLocaleFlag())
	{
		SAFEIRELEASE(m_pILocalizedNS);
		
		try
		{
			CHString	chsMsg;
			_bstr_t bstrNS = _bstr_t(rParsedInfo.GetGlblSwitchesObject().
																   GetRole())
							+ _bstr_t(L"\\") 
							+ _bstr_t(rParsedInfo.GetGlblSwitchesObject().
																 GetLocale());

			// Connect to the specified namespace of Windows Management on the
			// local computer using the locator object. 
			hr = Connect(pIWbemLocator, &m_pILocalizedNS,
						 bstrNS,	NULL, NULL,	
						 _bstr_t(rParsedInfo.GetGlblSwitchesObject().
						 GetLocale()), rParsedInfo);

            if(FAILED(hr)){

                TCHAR msdeflocale[] = _T("ms_409");

			    if (m_bTrace || m_eloErrLogOpt)
			    {
				    chsMsg.Format( 
						    L"IWbemLocator::ConnectServer(L\"%s not found. Connecting to ms_409\", NULL, "
						    L"NULL, L\"%s\", 0L, L\"%s\", NULL, -)", 
						    (WCHAR*) bstrNS,
						    rParsedInfo.GetGlblSwitchesObject().GetLocale(),
						    (rParsedInfo.GetAuthorityPrinciple()) ?
							    rParsedInfo.GetAuthorityPrinciple() : L"<null>");
				    WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								    dwThreadId, rParsedInfo, m_bTrace);
			    }

                
                rParsedInfo.GetGlblSwitchesObject().SetLocale(msdeflocale);

			    _bstr_t bstrNS = _bstr_t(rParsedInfo.GetGlblSwitchesObject().
																    GetRole())
							    + _bstr_t(L"\\") 
							    + _bstr_t(rParsedInfo.GetGlblSwitchesObject().
																    GetLocale());

			    // Connect to the specified namespace of Windows Management on the
			    // local computer using the locator object. 
			    hr = Connect(pIWbemLocator, &m_pILocalizedNS,
						    bstrNS,	NULL, NULL,	
						    _bstr_t(rParsedInfo.GetGlblSwitchesObject().
						    GetLocale()), rParsedInfo);

            }


			// If /TRACE is ON
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format( 
						L"IWbemLocator::ConnectServer(L\"%s\", NULL, "
						L"NULL, L\"%s\", 0L, L\"%s\", NULL, -)", 
						(WCHAR*) bstrNS,
						rParsedInfo.GetGlblSwitchesObject().GetLocale(),
						(rParsedInfo.GetAuthorityPrinciple()) ?
							rParsedInfo.GetAuthorityPrinciple() : L"<null>");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);
			}

			ONFAILTHROWERROR(hr);
			
			// If /TRACE is ON
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format( 
				 L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
				 L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, EOAC_NONE)",
				 rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				 rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			rParsedInfo.GetGlblSwitchesObject().SetLocaleFlag(FALSE);
		}
		catch(_com_error& e)
		{
			// Set the COM error
			rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
			hr = e.Error();
		}
		catch(CHeap_Exception)
		{
			// Set the COM error
			hr = WBEM_E_OUT_OF_MEMORY;
			_com_issue_error(hr);
		}
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :GetLocalizedDesc
   Synopsis          :This function retrieves the localized description for 
					  the object with given relative path, 
   Type	             :Member Function
   Input parameter(s):
		bstrRelPath	 - relativepath of the object for which
						localized description has to be retrieved.
		rParsedInfo  - reference to CParsedInfo class object.
   Output parameter(s):
   		bstrDesc	 - localized description
		rParsedInfo  - reference to CParsedInfo class object.
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :GetLocalizedDesc(bstrRelPath, bstrDesc, rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::GetLocalizedDesc(_bstr_t bstrRelPath, 
									_bstr_t& bstrDesc,
									CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	IWbemClassObject		*pIObject			= NULL;
	DWORD					dwThreadId			= GetCurrentThreadId();
	VARIANT					vtDesc, vtTemp;
	VariantInit(&vtDesc);
	VariantInit(&vtTemp);
	
	try
	{
		CHString	chsMsg;
		_bstr_t		bstrResult;
		CHString	sTemp((WCHAR*)bstrRelPath);

		// Substitue escape characters i.e. replace '\"' with '\\\"'
		SubstituteEscapeChars(sTemp, L"\"");

		// Object path
		_bstr_t bstrPath = 
					   _bstr_t(L"MSFT_LocalizablePropertyValue.ObjectLocator=\"\",PropertyName=")		
					   + _bstr_t(L"\"Description\",RelPath=\"")
					   + _bstr_t(sTemp) + _bstr_t(L"\"");

		// Retrieve the object 
		hr = m_pILocalizedNS->GetObject(bstrPath, 0, NULL, &pIObject, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format( 
					  L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
					  (WCHAR*) bstrPath);		
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Get localized description of the  property.
		hr = pIObject->Get(_bstr_t(L"Text"), 0, &vtDesc, 0, 0);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Text\", 0, -, 0, 0)");
			GetBstrTFromVariant(vtDesc, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace,
							   0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if (vtDesc.vt != VT_EMPTY && vtDesc.vt != VT_NULL)
		{
			// Get lower and upper bounds of 'Text' array
			LONG lUpper = 0, lLower = 0;
			hr = SafeArrayGetLBound(vtDesc.parray, vtDesc.parray->cDims,
									&lLower);
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(vtDesc.parray, vtDesc.parray->cDims,
									&lUpper);
			ONFAILTHROWERROR(hr);

			// Iterate through the Formats array property
			for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++)
			{
				BSTR bstrTemp = NULL;
				hr = SafeArrayGetElement(vtDesc.parray, &lIndex, &bstrTemp);
				ONFAILTHROWERROR(hr);
				if (bstrTemp)
					bstrDesc += bstrTemp;
			}
		}
		VariantClear(&vtDesc);
		SAFEIRELEASE(pIObject);
	}
	catch (_com_error& e)
	{
		VariantClear(&vtTemp);
		VariantClear(&vtDesc);
		SAFEIRELEASE(pIObject);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		VariantClear(&vtTemp);
		VariantClear(&vtDesc);
		SAFEIRELEASE(pIObject);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :GetQualifiers
   Synopsis          :This function retrieves the qualifiers associated with 
					  propety/parameter referred by pIWbemClassObject
   Type	             :Member Function
   Input parameter(s):
		pIWbemClassObject	- pointer to IWbemClassObject
		rPropDet			- reference to PROPERTYDETAILS object
		rParsedInfo			- reference to CParsedInfo class object.
   Output parameter(s):
		rPropDet			- reference to PROPERTYDETAILS object
		rParsedInfo			- reference to CParsedInfo class object.
   Return Type       :HRESULT  
   Global Variables  :None
   Calling Syntax    :GetQualifiers(pIObj, rPropDet, rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CCmdAlias::GetQualifiers(IWbemClassObject *pIWbemClassObject,
								 PROPERTYDETAILS& rPropDet,
								 CParsedInfo& rParsedInfo)
{
	IWbemClassObject	*pIWbemQualObject	= NULL;
	HRESULT				hr					= S_OK;
	DWORD				dwThreadId			= GetCurrentThreadId();
	VARIANT				vtQualifiers, vtQualName, vtQualValues;
	VariantInit(&vtQualifiers);
	VariantInit(&vtQualName);
	VariantInit(&vtQualValues);
	try
	{
		CHString	chsMsg;
		_bstr_t		bstrResult;
		//Getting the "Qualifiers" property.
		hr=pIWbemClassObject->Get(_bstr_t(L"Qualifiers"), 0,
								  &vtQualifiers, 0, 0);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get"
						  L"(L\"Qualifiers\", 0, -, 0, 0)"); 
			GetBstrTFromVariant(vtQualifiers, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							  (LPCWSTR)chsMsg, dwThreadId, 
							  rParsedInfo, m_bTrace, 0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if ( vtQualifiers.vt != VT_NULL && vtQualifiers.vt != VT_EMPTY )
		{
			LONG lLower = 0, lUpper = 0;
			hr = SafeArrayGetLBound(vtQualifiers.parray,
							vtQualifiers.parray->cDims, &lLower);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(vtQualifiers.parray,
									vtQualifiers.parray->cDims, &lUpper);
			if ( m_eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								   dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			// Iterate through the Properties array property
			for(LONG lIndex=lLower; lIndex<=lUpper; lIndex++)
			{
				pIWbemQualObject = NULL;
				// Get this property.
				hr = SafeArrayGetElement(vtQualifiers.parray, 
										 &lIndex, &pIWbemQualObject);
				if ( m_eloErrLogOpt ) 
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg,
						dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				//Getting the "Name" property
				hr = pIWbemQualObject->Get(_bstr_t(L"Name"), 0,
										   &vtQualName,0,0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get"
												  L"(L\"Name\", 0, -, 0, 0)");
					GetBstrTFromVariant(vtQualName, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				//Getting the "QualifierValue" property.
				hr=pIWbemQualObject->Get(_bstr_t(L"QualifierValue"),0,
										 &vtQualValues, 0, 0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get"
								  L"(L\"QualifierValue\", 0, -, 0, 0)"); 
					GetBstrTFromVariant(vtQualValues, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace,
									   0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				BSTRVECTOR bvQualValues;
				if ( vtQualValues.vt != VT_NULL && 
					 vtQualValues.vt != VT_EMPTY )
				{
					LONG lILower = 0, lIUpper = 0;
					hr = SafeArrayGetLBound(vtQualValues.parray,
									vtQualValues.parray->cDims, &lILower);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetLBound(-, -, -)");
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__,(LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					hr = SafeArrayGetUBound(vtQualValues.parray,
									vtQualValues.parray->cDims, &lIUpper);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										   (LPCWSTR)chsMsg, dwThreadId,
										   rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					BOOL bIsType = FALSE;
					BOOL bIsRead = FALSE;
					BOOL bIsWrite = FALSE;
					BOOL bIsIn = FALSE;
					BOOL bIsOut = FALSE;
					if (CompareTokens((WCHAR*)vtQualName.bstrVal, 
   									  _T("CIMTYPE")))
					{
						bIsType = TRUE;
					}
					else if (CompareTokens((WCHAR*)vtQualName.bstrVal, 
											_T("read")))
					{
						bIsRead = TRUE;
					}
					else if (CompareTokens((WCHAR*)vtQualName.bstrVal, 
											_T("write")))
					{
						bIsWrite = TRUE;
					}
					else if (CompareTokens((WCHAR*)vtQualName.bstrVal, 
											_T("In")))
					{
						bIsIn = TRUE;
					}
					else if (CompareTokens((WCHAR*)vtQualName.bstrVal, 
											_T("Out")))
					{
						bIsOut = TRUE;
					}

					// Iterate through the Properties array property
					for(LONG lIIndex=lILower; lIIndex<=lIUpper; lIIndex++)
					{
						BSTR bstrQualValue = NULL;
						// Get this property.
						hr = SafeArrayGetElement(vtQualValues.parray, 
												  &lIIndex, &bstrQualValue);
						if ( m_eloErrLogOpt ) 
						{
							chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											  (LPCWSTR)chsMsg, dwThreadId,
											  rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						if (bstrQualValue)
							bvQualValues.push_back(bstrQualValue);

						if ( lIIndex == 0 )
						{
							if ( bIsType == TRUE )
							{
								rPropDet.Type = bstrQualValue;
							}
							else if ( bIsRead == TRUE &&
							 CompareTokens((WCHAR*)bstrQualValue, _T("true")))
							{
								if (!rPropDet.Operation)
									rPropDet.Operation += _bstr_t("Read");
								else
									rPropDet.Operation += _bstr_t("/Read");
							}
							else if ( bIsWrite == TRUE &&
							 CompareTokens((WCHAR*)bstrQualValue, _T("true")))
							{
								if (!rPropDet.Operation)
									rPropDet.Operation += _bstr_t("Write");
								else
									rPropDet.Operation += _bstr_t("/Write");
							}
							else if ( bIsIn == TRUE &&
							 CompareTokens((WCHAR*)bstrQualValue, _T("true")))
							{
								 rPropDet.InOrOut = INP;
							}
							else if ( bIsOut == TRUE &&
							 CompareTokens((WCHAR*)bstrQualValue, _T("true")))
							{
								 rPropDet.InOrOut = OUTP;
							}
						}
					}
					VARIANTCLEAR(vtQualValues);
				}

				rPropDet.QualDetMap.insert
				   (QUALDETMAP::value_type(vtQualName.bstrVal, bvQualValues));

				VARIANTCLEAR(vtQualName);
				SAFEIRELEASE(pIWbemQualObject);
			}

			VARIANTCLEAR(vtQualifiers);
		}
	}
	catch (_com_error& e)
	{
		VARIANTCLEAR(vtQualValues);
		VARIANTCLEAR(vtQualName);
		VARIANTCLEAR(vtQualifiers);

		SAFEIRELEASE(pIWbemQualObject);
		
		hr = e.Error();
		// Set the COM error
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(vtQualValues);
		VARIANTCLEAR(vtQualName);
		VARIANTCLEAR(vtQualifiers);

		SAFEIRELEASE(pIWbemQualObject);
		
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :AreMethodsAvailable
   Synopsis          :Checks whether method are available with alias or not.
   Type	             :Member Function
   Input parameter(s):
		rParsedInfo	 - reference to CParsedInfo class object.
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AreMethodsAvailable(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CCmdAlias::AreMethodsAvailable(CParsedInfo& rParsedInfo)
{
	BOOL				bMethAvail	=	TRUE;
	HRESULT				hr			=	S_OK;
	IWbemClassObject	*pIWbemObj	=	NULL;
	DWORD				dwThreadId			= GetCurrentThreadId();
	VARIANT				vtVerbs;
	VariantInit(&vtVerbs);

	try
	{
		CHString	chsMsg;
		_bstr_t		bstrResult;
		_bstr_t bstrPath = _bstr_t("MSFT_CliAlias.FriendlyName='") + 
				   _bstr_t(rParsedInfo.GetCmdSwitchesObject().GetAliasName())+
				   _bstr_t(L"'");

		//Retrieving the object from the namespace in m_pIAliasNS
		hr = m_pIAliasNS->GetObject(bstrPath, 0, NULL, &pIWbemObj, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)",
														   (WCHAR*) bstrPath);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
								dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Get "Verbs" property.
		hr = pIWbemObj->Get(_bstr_t(L"Verbs"), 0, &vtVerbs, 0, 0) ;
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"Verbs\", 0, -, 0, 0)"); 
			GetBstrTFromVariant(vtVerbs, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							   dwThreadId, rParsedInfo, m_bTrace,
							   0, bstrResult);
		}
		ONFAILTHROWERROR(hr);

		if ( vtVerbs.vt == VT_NULL || vtVerbs.vt == VT_EMPTY )
			bMethAvail	= FALSE;

		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtVerbs);

	}
	catch(_com_error& e)
	{
		bMethAvail	= FALSE;
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtVerbs);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bMethAvail = FALSE;
	}
	catch(CHeap_Exception)
	{
		bMethAvail	= FALSE;
		SAFEIRELEASE(pIWbemObj);
		VARIANTCLEAR(vtVerbs);
		bMethAvail = FALSE;
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return	bMethAvail;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\cmdtokenizer.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CmdTokenizer.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: The CCmdTokenizer class provides with the 
							  functionality for tokenizing a command entered
							  as input on the command line, following the 
							  pre-defined rules for tokenizing.
Revision History			: 
		Last Modified By	: P. Sashank
		Last Modified Date	: 10th-April-2001
****************************************************************************/ 
#include "Precomp.h"
#include "CmdTokenizer.h"

/*------------------------------------------------------------------------
   Name				 :CCmdTokenizer
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CCmdTokenizer::CCmdTokenizer()
{
	m_nTokenOffSet		= 0;
	m_nTokenStart		= 0;
	m_pszCommandLine	= NULL;
	m_bEscapeSeq		= FALSE;
	m_bFormatToken		= FALSE;
}

/*------------------------------------------------------------------------
   Name				 :~CCmdTokenizer
   Synopsis	         :This function uninitializes the member variables 
					  when an object of the class type goes out of scope.
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CCmdTokenizer::~CCmdTokenizer()
{
	Uninitialize();
}

/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables 
					  when the execution of a command string issued on the
					  command line is completed.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
------------------------------------------------------------------------*/
void CCmdTokenizer::Uninitialize()
{
	m_nTokenOffSet		= 0;
	m_nTokenStart		= 0;
	m_bEscapeSeq		= FALSE;
	SAFEDELETE(m_pszCommandLine);
	CleanUpCharVector(m_cvTokens);
}

/*------------------------------------------------------------------------
   Name				 :TokenizeCommand
   Synopsis	         :This function tokenizes the command string entered 
					  as input based on the pre-identified delimiters and
					  stores the tokens in the list of m_cvTokens.
   Type	             :Member Function
   Input parameter   :
	pszCommandInpout - Command line Input
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :TokenizeCommand(pszCommandInput)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCmdTokenizer::TokenizeCommand(_TCHAR* pszCommandInput) throw(WMICLIINT)
{
	BOOL bResult = TRUE;
	// Free the memory pointed by the member variable m_pszCommandLine
	// if the pointer is not NULL.
	SAFEDELETE(m_pszCommandLine);
	
	if(pszCommandInput)
	{
		try
		{
			// Allocate the memory for the command line string.
			m_pszCommandLine = new _TCHAR [lstrlen(pszCommandInput) + 1];
			if (m_pszCommandLine != NULL)
			{
				// Copy the contents to the member variable m_pszCommandLine
				lstrcpy(m_pszCommandLine, pszCommandInput);

				// Set the token-offset and token-start counters to '0'
				m_nTokenOffSet = 0;
				m_nTokenStart = 0;

				WMICLIINT nCmdLength = lstrlen(m_pszCommandLine);
				// Tokenize the command string.
				while (m_nTokenOffSet < nCmdLength)
				{
					NextToken();
				}
			}
			else
				throw OUT_OF_MEMORY;
		}	
		catch(...)
		{
			bResult = FALSE;
		}
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :NextToken
   Synopsis	         :This function dissects the command string entered
					  as input, and adjusts the the token-offset and 
					  token-start positions, and call the  Token()
					  function for extracting the token out of the
					  input string.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :NextToken
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCmdTokenizer::NextToken()
{
	WMICLIINT nCmdLength         = lstrlen(m_pszCommandLine);

	// step over leading whitespace(s)
	while ((m_pszCommandLine[m_nTokenOffSet] == _T(' ') ||
		    m_pszCommandLine[m_nTokenOffSet] == _T('\t'))
			&& (m_nTokenOffSet < nCmdLength))
	{
		m_nTokenOffSet++;
	}
    m_nTokenStart = m_nTokenOffSet;

	CHARVECTOR::iterator theIterator;
	theIterator = m_cvTokens.end();

    //step up to next delimiter i.e '/', '-' or '?'
	if ((m_pszCommandLine[m_nTokenOffSet] == _T('/')) 
		|| (m_pszCommandLine[m_nTokenOffSet] == _T('-')) 
		|| (m_pszCommandLine[m_nTokenOffSet] == _T(','))
		|| (m_pszCommandLine[m_nTokenOffSet] == _T('('))
		|| (m_pszCommandLine[m_nTokenOffSet] == _T(')'))
		|| (m_pszCommandLine[m_nTokenOffSet] == _T('=') &&
		   !CompareTokens(*(theIterator-1), CLI_TOKEN_WHERE) &&
		   !CompareTokens(*(theIterator-1), CLI_TOKEN_PATH)))
	{
		// To handle optional parenthesis with WHERE
		if (m_pszCommandLine[m_nTokenOffSet] == _T('('))
		{
			if (m_cvTokens.size())
			{
				//Check whether the previous token is "WHERE"
				if ( CompareTokens(*(theIterator-1), CLI_TOKEN_WHERE) ||
					CallSetOrCreatePresent() )
				{
					m_nTokenOffSet++;
					while ((m_nTokenOffSet < nCmdLength) 
						&& (m_pszCommandLine[m_nTokenOffSet] != _T(')')))
					{
						m_nTokenOffSet++;		
					}
				}
			}
		}
		m_nTokenOffSet++;
	}
	else
	{
		while (m_nTokenOffSet < nCmdLength)
		{
			if ((m_pszCommandLine[m_nTokenOffSet] == _T('/')) 
				|| (m_pszCommandLine[m_nTokenOffSet] == _T('-'))
				|| (m_pszCommandLine[m_nTokenOffSet] == _T(' '))
				|| (m_pszCommandLine[m_nTokenOffSet] == _T('\t'))
				|| (m_pszCommandLine[m_nTokenOffSet] == _T(','))
				|| (m_pszCommandLine[m_nTokenOffSet] == _T('('))
				|| (m_pszCommandLine[m_nTokenOffSet] == _T(')'))
				|| (m_pszCommandLine[m_nTokenOffSet] == _T('=') &&
					!CompareTokens(*(theIterator-1), CLI_TOKEN_WHERE) &&
					!CompareTokens(*(theIterator-1), CLI_TOKEN_PATH)))
			{
				break;
			}

            // if the command option is specified in quotes
            if (m_pszCommandLine[m_nTokenOffSet] == _T('"'))
            {
                m_nTokenOffSet++;

                // To include " within an quoted string it should
                // be preceded by \ 
                while (m_nTokenOffSet < nCmdLength) 
                {
                    if (m_pszCommandLine[m_nTokenOffSet] == _T(',')){ m_nTokenOffSet--; break; }
                    if (m_pszCommandLine[m_nTokenOffSet] == _T('"'))
                    {
                        if (m_pszCommandLine[m_nTokenOffSet-1] == _T('\\'))
                        {
                            m_bEscapeSeq = TRUE;
                        }
                        else
                            break;
                    }
                    m_nTokenOffSet++;		
                }
            } else if (m_pszCommandLine[m_nTokenOffSet] == _T('\'')){

                m_nTokenOffSet++;

                // To include " within an quoted string it should
                // be preceded by \ 
                while (m_nTokenOffSet < nCmdLength) 
                {
                    if (m_pszCommandLine[m_nTokenOffSet] == _T(',')){ m_nTokenOffSet--; break; }
                    if (m_pszCommandLine[m_nTokenOffSet] == _T('\''))
                    {
                        if (m_pszCommandLine[m_nTokenOffSet-1] == _T('\\'))
                        {
                            m_bEscapeSeq = TRUE;
                        }
                        else
                            break;
                    }
                    m_nTokenOffSet++;		
                }
            }

			m_nTokenOffSet++;	
		}
	}
	return Token();
}

/*------------------------------------------------------------------------
   Name				 :Token
   Synopsis	         :This function extracts the portion of the command
					  string using the token-start and token-offset value.
					  If the token is not NULL, adds it to the list of 
					  tokens in the token vector.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :Token()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCmdTokenizer::Token() throw(WMICLIINT)
{

	WMICLIINT	nLength = (m_nTokenOffSet - m_nTokenStart);
	_TCHAR* sToken	= NULL;
	CHARVECTOR::iterator theIterator = NULL;

	if (nLength > 0)
	{
		// Allocate the memory for the new token.
		sToken = new _TCHAR [nLength + 1];
		if (sToken)
		{
			try
			{
				WMICLIINT nLoop = 0;
				WMICLIINT nInd = 0;
				BOOL bSpecialChar = FALSE;
				BOOL bPush = TRUE;
								
				// Form the token(s).
				while(nInd < nLength)
				{	
					BOOL bPush = TRUE;
					while (nInd < nLength)
					{
						//If the character is ':'
						if(m_pszCommandLine[nInd + m_nTokenStart] == _T(':') &&
					 		bSpecialChar == FALSE)
						{
							_TCHAR*    sToktemp = NULL;
							sToktemp  = new _TCHAR [nLoop + 1];

							if (sToktemp == NULL)
								throw OUT_OF_MEMORY;

							if(nInd > 0)
							{
								lstrcpyn(sToktemp,sToken,nLoop + 1);
								sToktemp[nLoop] = _T('\0');
								
								//if ':' is preceeded by ASSOC token
								if(CompareTokens(sToktemp,CLI_TOKEN_ASSOC))								
								{
									
									bSpecialChar = TRUE;
									bPush = FALSE;
									SAFEDELETE(sToktemp);	
									break;

								}
								//if ':' is preceded by FORMAT token 
								else if(CompareTokens(sToktemp,CLI_TOKEN_FORMAT))
										
								{	theIterator = m_cvTokens.end();
									if((theIterator - 1) >= m_cvTokens.begin() &&
									   IsOption(*(theIterator - 1)))
									{
										m_bFormatToken = TRUE;
										bSpecialChar = TRUE;
										bPush = FALSE;
										SAFEDELETE(sToktemp);
										break;
									}
								}
								SAFEDELETE(sToktemp);
							}
							if (!m_cvTokens.empty())
							{

								theIterator = m_cvTokens.end();

								//if ':' is present previous token is '/' 
								//(case arises when ':' 
								//is specified without space after a switch)
								if( (theIterator - 1) >= m_cvTokens.begin() &&
									IsOption(*(theIterator - 1)))
								{
									bSpecialChar = TRUE;
									bPush = FALSE;
									break;
								}
								//if ':' is first character in the new token
								//(case arises when ':' is preceded by blank space)
								else if(m_nTokenStart != 0 && 
									m_pszCommandLine[m_nTokenStart] == _T(':'))
								{
									bSpecialChar = TRUE;
									bPush = FALSE;
									break;
								}
								//if ':' is encountered after format switch 
								//and previous token is ':' or a ',' 
								//(case arises for specifying format switch)
								else if(m_bFormatToken == TRUE && 
										(CompareTokens(*(theIterator - 1),_T(":"))) ||
										(IsOption(*(theIterator - 1))))
								{
										bSpecialChar = TRUE;
										bPush = FALSE;
										break;
								}
								//if ':' is preceded by '?' and '?' in turn 
								//is preceded by '/'
								//(case arises for specifying help option)
								else 
								{		
									theIterator = m_cvTokens.end();
									if(theIterator &&
										(theIterator - 2) >= m_cvTokens.begin() &&
										(CompareTokens(*(theIterator - 1),_T("?"))) &&
										(IsOption(*(theIterator - 2))))
									{
										bSpecialChar = TRUE;
										bPush = FALSE;
										break;
									}
								}
							}
						}
						//if character is '?'(for help switch)
						else if(m_pszCommandLine[nInd + m_nTokenStart] == 
											_T('?') && bSpecialChar == FALSE)
						{
							if (!m_cvTokens.empty())
							{
								theIterator = m_cvTokens.end();

								//if character is '?' and preceded by '/'(for help switch)
								if( (theIterator - 1) >= m_cvTokens.begin() &&
									IsOption(*(theIterator - 1)))
								{
									bSpecialChar = TRUE;
									bPush = FALSE;
									break;						
								}
							}
						}
						
						sToken[nLoop] = m_pszCommandLine[nInd + m_nTokenStart];
						nLoop++;
						nInd++;

						if(m_pszCommandLine[nInd - 1 + m_nTokenStart] == _T('"'))
						{
							while(nInd < nLength)
							{
								sToken[nLoop] = m_pszCommandLine[
														nInd + m_nTokenStart];
								nLoop++;
								nInd++;

								if(nInd < nLength &&
									m_pszCommandLine[nInd + m_nTokenStart] 
																== _T('"'))
								{
									if(m_pszCommandLine[nInd - 1 + m_nTokenStart] 
																	== _T('\\'))
									{
                                        if (0 == nInd)
                                        {
										    m_bEscapeSeq = TRUE;
                                        }
									}
									else
									{
										sToken[nLoop] = m_pszCommandLine[
														nInd + m_nTokenStart];
										nLoop++;
										nInd++;
										break;
									}
								}														
								
							}
						}

					}

					// terminate the string with '\0' 
					sToken[nLoop] = _T('\0');
					UnQuoteString(sToken);
					
					// If Escape sequence flag is set
					if (m_bEscapeSeq)
					{
						try
						{
							CHString	sTemp((WCHAR*)sToken);
							/* Remove the escape sequence character i.e \ */
							RemoveEscapeChars(sTemp);
							lstrcpy(sToken, sTemp);
							m_bEscapeSeq = FALSE;
						}
						catch(CHeap_Exception)
						{
							throw OUT_OF_MEMORY;
						}
						catch(...)
						{
							throw OUT_OF_MEMORY;		
						}
					}

					_TCHAR* sTokenTemp = NULL;

					sTokenTemp = new _TCHAR[nLoop + 1];
					if (sTokenTemp == NULL)
						throw OUT_OF_MEMORY;
					lstrcpy(sTokenTemp,sToken);

					if(bPush == TRUE || lstrlen(sTokenTemp) > 0)
						m_cvTokens.push_back(sTokenTemp);
					else
						SAFEDELETE(sTokenTemp);

					//reset m_FormatToken if next switch is expected
					if(m_bFormatToken == TRUE && IsOption(sTokenTemp))
						m_bFormatToken = FALSE;
					
					//if the character is found to be a special character
					if(bSpecialChar == TRUE)
					{
						sToken[0] = m_pszCommandLine[nInd + m_nTokenStart];
						sToken[1] = _T('\0');
						sTokenTemp = new _TCHAR[2];
						if (sTokenTemp == NULL)
							throw OUT_OF_MEMORY;
						lstrcpy(sTokenTemp,sToken);
						bSpecialChar = FALSE;
						nLoop = 0;
						nInd++;
						m_cvTokens.push_back(sTokenTemp);
						bPush = TRUE;
						theIterator++;
											
					}
				}
				SAFEDELETE(sToken);
			}
			catch(...)
			{
				SAFEDELETE(sToken);
				throw OUT_OF_MEMORY;
			}
		}
		else
			throw OUT_OF_MEMORY;
	}
	return sToken;
}
/*------------------------------------------------------------------------
   Name				 :GetTokenVector
   Synopsis	         :This function returns a reference to the token 
					  vector
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHARVECTOR&
   Global Variables  :None
   Calling Syntax    :GetTokenVector()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CCmdTokenizer::GetTokenVector()
{
	return m_cvTokens;
}

/*------------------------------------------------------------------------
   Name				 :CallSetOrCreatePresent
   Synopsis	         :This function checks whether CALL or SET or CREATE
						is present in the tokens vector.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :CallSetOrCreatePresent()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCmdTokenizer::CallSetOrCreatePresent()
{
	BOOL		bRet = FALSE;
	WMICLIINT	nSizeOfVector = m_cvTokens.size();

	// Check is there any CALL or SET verbs in the vector
	for(WMICLIINT i=0; i<nSizeOfVector; ++i)
	{
		if( CompareTokens(m_cvTokens[i], CLI_TOKEN_CALL) ||
			CompareTokens(m_cvTokens[i], CLI_TOKEN_SET)  ||
			CompareTokens(m_cvTokens[i], CLI_TOKEN_CREATE) )
		{
			bRet = TRUE;
			break;
		}
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\cmdalias.h ===
/*****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CmdAlias.h 
Project Name				: WMI Command Line
Author Name					: Ch.Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CmdAlias
Revision History			: None
		Last Modified By	: C V Nandi
		Last Modified Date	: 16-March-2001
*****************************************************************************/

/*----------------------------------------------------------------------------
 Class Name			: CCmdAlias
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed for
					  accessing the alias information from the WMI.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : WMI COM Interfaces
 ---------------------------------------------------------------------------*/
// Forward declaration of the classes
class CParsedInfo;

class CCmdAlias
{
public:
	// Construction
	CCmdAlias();

	// Destruction
	~CCmdAlias();

	// Restrict Assignment
	CCmdAlias& operator=(CCmdAlias& rAliasObj);

// Attributes
private:
	// Points to the alias definitions namespace.
	IWbemServices* m_pIAliasNS;

	// Pointer to localized Namespace.
	IWbemServices* m_pILocalizedNS;

	// Trace flag.
	BOOL m_bTrace;

	// Error log option.
	ERRLOGOPT m_eloErrLogOpt;

// Operations
private:
	// Obtain the alias connection information like
	// 1. namespace		2. user		3. password
	// 4. locale		5. server	6. authority
	RETCODE ObtainAliasConnectionInfo(CParsedInfo& rParsedInfo,
									  IWbemClassObject* pIObj);

	// Obtain Qualifiers associated with the IWbemClassObject.
	HRESULT GetQualifiers(IWbemClassObject *pIWbemClassObject,
						  PROPERTYDETAILS& rPropDet,
						  CParsedInfo& rParsedInfo);	

public:
	// Obtains all the Friendly Names and descriptions 
	HRESULT ObtainAliasFriendlyNames(CParsedInfo& rParsedInfo);

	// Obtains the verbs and their details
	// associated with the alias object
	HRESULT ObtainAliasVerbDetails(CParsedInfo& rParsedInfo);

	// Obtains the verbs and their descriptions
	// associated with the alias object
	// pbCheckWritePropsAvailInAndOut == TRUE then functions checks for 
	// availibility of properties and returns in the same  
	// pbCheckWritePropsAvailInAndOut parameter.
	HRESULT ObtainAliasPropDetails(CParsedInfo& rParsedInfo,
								  BOOL *pbCheckWritePropsAvailInAndOut = NULL,
								  BOOL *pbCheckFULLPropsAvailInAndOut = NULL);
	
	// Obtains the properties for the Format associated with the alias object.
	// If bCheckForListFrmsAvail == TRUE then functions checks only for 
	// availibilty of list formats with the alias.
	BOOL ObtainAliasFormat(CParsedInfo& rParsedInfo,
						   BOOL bCheckForListFrmsAvail = FALSE);

	// Obtains the formats available for a given alias.
	HRESULT PopulateAliasFormatMap(CParsedInfo& rParsedInfo);
	
	// Connects to WMI with alias namespace .
	HRESULT ConnectToAlias(CParsedInfo& rParsedInfo, 
						 IWbemLocator* pIWbemLocator);
	
	// Obtain the alias information like
	// 1. alias PWhere expression value
	// 2. alias Target string
	RETCODE ObtainAliasInfo(CParsedInfo& rParsedInfo);

	// Get Description from object.
	HRESULT GetDescOfObject(IWbemClassObject* pIWbemClassObject,
						    _bstr_t& bstrDescription,
							CParsedInfo& rParsedInfo,
							BOOL bLocalizeFlag = FALSE);

	// Obtains the Translate Table Entries.
	BOOL	ObtainTranslateTableEntries(CParsedInfo& rParsedInfo);

	// Obtains translate table entries from alias definition.
	HRESULT ObtainTranslateTables(CParsedInfo& rParsedInfo);

	// Get the localized description values
	HRESULT GetLocalizedDesc(_bstr_t bstrRelPath, 
							 _bstr_t& bstrDesc,
							 CParsedInfo& rParsedInfo);

	// Connect to the localized namespace.
	HRESULT	ConnectToLocalizedNS(CParsedInfo&, IWbemLocator* pILocator);

	// Checks whether method are available with alias or not. 
	BOOL	AreMethodsAvailable(CParsedInfo& rParsedInfo);

	//Uninitializes the the member variables 
	void Uninitialize(BOOL bFinal = FALSE);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\cmdtokenizer.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CmdTokenizer.h 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CmdTokenizer
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 23th-February-2001
****************************************************************************/ 
/*-------------------------------------------------------------------
 Class Name			: CCmdTokenizer
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for tokenizing the command line string passed as
					  input to the wmic.exe
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/
/////////////////////////////////////////////////////////////////////////////
// CCmdTokenizer
class CCmdTokenizer
{
public:
// Construction
	CCmdTokenizer();

// Destruction
	~CCmdTokenizer();

// Restrict Assignment
   CCmdTokenizer& operator=(CCmdTokenizer& rCmdTknzr); 

// Attributes
private:
	// command string
	_TCHAR*			m_pszCommandLine;
	
	// token-offset counter
	WMICLIINT		m_nTokenOffSet;
	
	// token-start counter
	WMICLIINT		m_nTokenStart;
	
	// token vector	
	CHARVECTOR		m_cvTokens;

	// Escape sequence flag
	BOOL			m_bEscapeSeq;

	// Format switch
	BOOL			m_bFormatToken;

// Operations
private:
	//Extracts token and adds it to the token vector.
	_TCHAR*			Token(); 

	//Identify the Next token to be extracted by adjusting
	//m_nTokenStart and m_nTokenOffset
	_TCHAR*			NextToken();

	// This function checks whether CALL or SET is present 
	// in the tokens vector.
	BOOL			CallSetOrCreatePresent();

public:
	// returns the reference to token vector.
	CHARVECTOR&		GetTokenVector();

	// tokenize the command using the pre-defined 
	// delimiters
	BOOL			TokenizeCommand(_TCHAR* pszCommandInput);

	// Free the member variables
	void			Uninitialize();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\errorinfo.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ErrorInfo.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: The CErrorInfo class provides the functionality 
							  for providing error information given the error
							  object.  
Private						: None							  
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy
	Last Modified date		: 16th-January-2001
****************************************************************************/ 
// ErrorInfo.cpp : implementation file

#include "Precomp.h"
#include "ErrorInfo.h"

/*------------------------------------------------------------------------
   Name				 :CErrorInfo
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CErrorInfo::CErrorInfo()
{
	m_pIStatus		= NULL;
	m_bWMIErrSrc	= TRUE;
	m_pszErrStr		= NULL;
}

/*------------------------------------------------------------------------
   Name				 :~CErrorInfo
   Synopsis	         :This function uninitializes the member variables 
					  when an object of the class type goes out of scope.
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type		 :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CErrorInfo::~CErrorInfo()
{
	Uninitialize();
}

/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables. 
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void 
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
------------------------------------------------------------------------*/
void CErrorInfo::Uninitialize()
{
	SAFEIRELEASE(m_pIStatus);
	SAFEDELETE(m_pszErrStr);
	m_bWMIErrSrc	= TRUE;
}

/*------------------------------------------------------------------------
   Name				 :GetErrorString
   Synopsis	         :This function takes the error code as input and returns
					  an error string
   Type				 :Member Function
   Input parameter   :
			hr		- hresult value
			bTrace	- trace flag
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetErrorString(hr)
   Notes             :None
------------------------------------------------------------------------*/
void CErrorInfo::GetErrorString(HRESULT hr, BOOL bTrace, _bstr_t& bstrErrDesc,
									_bstr_t& bstrFacility) 
{
	try
	{
		// Get the text description of the error code
		GetWbemErrorText(hr, FALSE, bstrErrDesc, bstrFacility);

		// If the error source subsystem is 'Wbem' and the 
		// TRACE is ON (get elaborated description from the
		// string table for the error code)
		if (m_bWMIErrSrc && bTrace)
		{
			m_pszErrStr = new _TCHAR[MAX_BUFFER];
			if (m_pszErrStr != NULL)
			{	
				switch (hr)
				{
					case WBEM_NO_ERROR:
						LoadString(NULL, IDS_I_WBEM_NO_ERROR, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_ACCESS_DENIED:
						LoadString(NULL, IDS_E_WBEM_E_ACCESS_DENIED, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_ALREADY_EXISTS:
						LoadString(NULL, IDS_E_WBEM_E_ALREADY_EXISTS, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_CANNOT_BE_KEY:
						LoadString(NULL, IDS_E_WBEM_E_CANNOT_BE_KEY, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_CANNOT_BE_SINGLETON:
						LoadString(NULL, IDS_E_WBEM_E_CANNOT_BE_SINGLETON, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_CLASS_HAS_CHILDREN:
						LoadString(NULL, IDS_E_WBEM_E_CLASS_HAS_CHILDREN, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_CLASS_HAS_INSTANCES:
						LoadString(NULL, IDS_E_WBEM_E_CLASS_HAS_INSTANCES, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_CRITICAL_ERROR:
						LoadString(NULL, IDS_E_WBEM_E_CRITICAL_ERROR, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_FAILED:
						LoadString(NULL, IDS_E_WBEM_E_FAILED, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_ILLEGAL_NULL:
						LoadString(NULL, IDS_E_WBEM_E_ILLEGAL_NULL, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_ILLEGAL_OPERATION:
						LoadString(NULL, IDS_E_WBEM_E_ILLEGAL_OPERATION, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INCOMPLETE_CLASS:
						LoadString(NULL, IDS_E_WBEM_E_INCOMPLETE_CLASS, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INITIALIZATION_FAILURE:
						LoadString(NULL, IDS_E_WBEM_E_INITIALIZATION_FAILURE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_CIM_TYPE:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_CIM_TYPE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_CLASS:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_CLASS, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_CONTEXT:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_CONTEXT, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_METHOD:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_METHOD, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_METHOD_PARAMETERS:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_METHOD_PARAMETERS, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_NAMESPACE:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_NAMESPACE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_OBJECT:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_OBJECT, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_OPERATION:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_OPERATION, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_PARAMETER:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_PARAMETER, 
									m_pszErrStr, MAX_BUFFER);
 						break;

					case WBEM_E_INVALID_PROPERTY_TYPE:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_PROPERTY_TYPE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_PROVIDER_REGISTRATION:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_PROVIDER_REGISTRATION, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_QUALIFIER_TYPE:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_QUALIFIER_TYPE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_QUERY:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_QUERY, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_QUERY_TYPE:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_QUERY_TYPE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_STREAM:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_STREAM, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_SUPERCLASS:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_SUPERCLASS, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_INVALID_SYNTAX:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_SYNTAX, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_NONDECORATED_OBJECT:
						LoadString(NULL, IDS_E_WBEM_E_NONDECORATED_OBJECT, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_NOT_AVAILABLE:
						LoadString(NULL, IDS_E_WBEM_E_NOT_AVAILABLE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_NOT_FOUND:
						LoadString(NULL, IDS_E_WBEM_E_NOT_FOUND, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_NOT_SUPPORTED:
						LoadString(NULL, IDS_E_WBEM_E_NOT_SUPPORTED, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_OUT_OF_MEMORY:
						LoadString(NULL, IDS_E_WBEM_E_OUT_OF_MEMORY, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_OVERRIDE_NOT_ALLOWED:
						LoadString(NULL, IDS_E_WBEM_E_OVERRIDE_NOT_ALLOWED, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_PROPAGATED_PROPERTY:
						LoadString(NULL, IDS_E_WBEM_E_PROPAGATED_PROPERTY, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_PROPAGATED_QUALIFIER:
						LoadString(NULL, IDS_E_WBEM_E_PROPAGATED_QUALIFIER, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_PROVIDER_FAILURE:
						LoadString(NULL, IDS_E_WBEM_E_PROVIDER_FAILURE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_PROVIDER_LOAD_FAILURE:
						LoadString(NULL, IDS_E_WBEM_E_PROVIDER_LOAD_FAILURE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_PROVIDER_NOT_CAPABLE:
						LoadString(NULL, IDS_E_WBEM_E_PROVIDER_NOT_CAPABLE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_PROVIDER_NOT_FOUND:
						LoadString(NULL, IDS_E_WBEM_E_PROVIDER_NOT_FOUND, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_QUERY_NOT_IMPLEMENTED:
						LoadString(NULL, IDS_E_WBEM_E_QUERY_NOT_IMPLEMENTED, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_READ_ONLY:
						LoadString(NULL, IDS_E_WBEM_E_READ_ONLY, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_TRANSPORT_FAILURE:
						LoadString(NULL, IDS_E_WBEM_E_TRANSPORT_FAILURE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_TYPE_MISMATCH:
						LoadString(NULL, IDS_E_WBEM_E_TYPE_MISMATCH, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_UNEXPECTED:
						LoadString(NULL, IDS_E_WBEM_E_UNEXPECTED, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_E_VALUE_OUT_OF_RANGE:
						LoadString(NULL, IDS_E_WBEM_E_VALUE_OUT_OF_RANGE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_ALREADY_EXISTS:
						LoadString(NULL, IDS_S_WBEM_S_ALREADY_EXISTS, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_DIFFERENT:
						LoadString(NULL, IDS_S_WBEM_S_DIFFERENT, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_FALSE:
						LoadString(NULL, IDS_S_WBEM_S_FALSE, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_NO_MORE_DATA:
						LoadString(NULL, IDS_S_WBEM_S_NO_MORE_DATA, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_PENDING:
						LoadString(NULL, IDS_S_WBEM_S_PENDING, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_RESET_TO_DEFAULT:
						LoadString(NULL, IDS_S_WBEM_S_RESET_TO_DEFAULT, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEM_S_TIMEDOUT:
						LoadString(NULL, IDS_S_WBEM_S_TIMEDOUT, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEMESS_E_REGISTRATION_TOO_BROAD:
						LoadString(NULL, IDS_E_WBEMESS_E_REGISTRATION_TOO_BROAD, 
									m_pszErrStr, MAX_BUFFER);
						break;

					case WBEMESS_E_REGISTRATION_TOO_PRECISE:
						LoadString(NULL, IDS_E_WBEMESS_E_REGISTRATION_TOO_PRECISE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_S_OPERATION_CANCELLED:
						LoadString(NULL, IDS_S_WBEM_S_OPERATION_CANCELLED, 
									m_pszErrStr, MAX_BUFFER);
						break;
					
				   case WBEM_S_DUPLICATE_OBJECTS:
						LoadString(NULL, IDS_S_WBEM_S_DUPLICATE_OBJECTS, 
									m_pszErrStr, MAX_BUFFER);
						break;
					
				   case WBEM_S_ACCESS_DENIED:
						LoadString(NULL, IDS_S_WBEM_S_ACCESS_DENIED, 
									m_pszErrStr, MAX_BUFFER);
						break;
				
				   case WBEM_S_PARTIAL_RESULTS:
						LoadString(NULL, IDS_S_WBEM_S_PARTIAL_RESULTS, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_SYSTEM_PROPERTY:
						LoadString(NULL, IDS_E_WBEM_E_SYSTEM_PROPERTY, 
									m_pszErrStr, MAX_BUFFER);
						break;
				
				   case WBEM_E_INVALID_PROPERTY:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_PROPERTY, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_CALL_CANCELLED:
						LoadString(NULL, IDS_E_WBEM_E_CALL_CANCELLED, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_SHUTTING_DOWN:
						LoadString(NULL, IDS_E_WBEM_E_SHUTTING_DOWN, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_PROPAGATED_METHOD:
						LoadString(NULL, IDS_E_WBEM_E_PROPAGATED_METHOD, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNSUPPORTED_PARAMETER:
						LoadString(NULL, IDS_E_WBEM_E_UNSUPPORTED_PARAMETER, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_MISSING_PARAMETER_ID:
						LoadString(NULL, IDS_E_WBEM_E_MISSING_PARAMETER_ID, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_INVALID_PARAMETER_ID:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_PARAMETER_ID, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_NONCONSECUTIVE_PARAMETER_IDS:
						LoadString(NULL, IDS_E_WBEM_E_NONCONSECUTIVE_PARAMETER_IDS, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_PARAMETER_ID_ON_RETVAL:
						LoadString(NULL, IDS_E_WBEM_E_PARAMETER_ID_ON_RETVAL, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_INVALID_OBJECT_PATH:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_OBJECT_PATH, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_OUT_OF_DISK_SPACE:
						LoadString(NULL, IDS_E_WBEM_E_OUT_OF_DISK_SPACE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_BUFFER_TOO_SMALL:
						LoadString(NULL, IDS_E_WBEM_E_BUFFER_TOO_SMALL, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNSUPPORTED_PUT_EXTENSION:
						LoadString(NULL, IDS_E_WBEM_E_UNSUPPORTED_PUT_EXTENSION, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNKNOWN_OBJECT_TYPE:
						LoadString(NULL, IDS_E_WBEM_E_UNKNOWN_OBJECT_TYPE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNKNOWN_PACKET_TYPE:
						LoadString(NULL, IDS_E_WBEM_E_UNKNOWN_PACKET_TYPE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_MARSHAL_VERSION_MISMATCH:
						LoadString(NULL, IDS_E_WBEM_E_MARSHAL_VERSION_MISMATCH, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_MARSHAL_INVALID_SIGNATURE:
						LoadString(NULL, IDS_E_WBEM_E_MARSHAL_INVALID_SIGNATURE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_INVALID_QUALIFIER:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_QUALIFIER, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_INVALID_DUPLICATE_PARAMETER:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_DUPLICATE_PARAMETER, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_TOO_MUCH_DATA:
						LoadString(NULL, IDS_E_WBEM_E_TOO_MUCH_DATA, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_SERVER_TOO_BUSY:
						LoadString(NULL, IDS_E_WBEM_E_SERVER_TOO_BUSY, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_INVALID_FLAVOR:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_FLAVOR, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_CIRCULAR_REFERENCE:
						LoadString(NULL, IDS_E_WBEM_E_CIRCULAR_REFERENCE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNSUPPORTED_CLASS_UPDATE:
						LoadString(NULL, IDS_E_WBEM_E_UNSUPPORTED_CLASS_UPDATE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE:
						LoadString(NULL, IDS_E_WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE:
						LoadString(NULL, IDS_E_WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_TOO_MANY_PROPERTIES:
						LoadString(NULL, IDS_E_WBEM_E_TOO_MANY_PROPERTIES, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UPDATE_TYPE_MISMATCH:
						LoadString(NULL, IDS_E_WBEM_E_UPDATE_TYPE_MISMATCH, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED:
						LoadString(NULL, IDS_E_WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UPDATE_PROPAGATED_METHOD:
						LoadString(NULL, IDS_E_WBEM_E_UPDATE_PROPAGATED_METHOD, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_METHOD_NOT_IMPLEMENTED:
						LoadString(NULL, IDS_E_WBEM_E_METHOD_NOT_IMPLEMENTED, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_METHOD_DISABLED:
						LoadString(NULL, IDS_E_WBEM_E_METHOD_DISABLED, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_REFRESHER_BUSY:
						LoadString(NULL, IDS_E_WBEM_E_REFRESHER_BUSY, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNPARSABLE_QUERY:
						LoadString(NULL, IDS_E_WBEM_E_UNPARSABLE_QUERY, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_NOT_EVENT_CLASS:
						LoadString(NULL, IDS_E_WBEM_E_NOT_EVENT_CLASS, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_MISSING_GROUP_WITHIN:
						LoadString(NULL, WBEM_E_MISSING_GROUP_WITHIN, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_MISSING_AGGREGATION_LIST:
						LoadString(NULL, IDS_E_WBEM_E_MISSING_AGGREGATION_LIST, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_PROPERTY_NOT_AN_OBJECT:
						LoadString(NULL, IDS_E_WBEM_E_PROPERTY_NOT_AN_OBJECT, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_AGGREGATING_BY_OBJECT:
						LoadString(NULL, IDS_E_WBEM_E_AGGREGATING_BY_OBJECT, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY:
						LoadString(NULL, IDS_E_WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING:
						LoadString(NULL, IDS_E_WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_QUEUE_OVERFLOW:
						LoadString(NULL, IDS_E_WBEM_E_QUEUE_OVERFLOW, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_PRIVILEGE_NOT_HELD:
						LoadString(NULL, IDS_E_WBEM_E_PRIVILEGE_NOT_HELD, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_INVALID_OPERATOR:
						LoadString(NULL, IDS_E_WBEM_E_INVALID_OPERATOR, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_LOCAL_CREDENTIALS:
						LoadString(NULL, IDS_E_WBEM_E_LOCAL_CREDENTIALS, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_CANNOT_BE_ABSTRACT:
						LoadString(NULL, IDS_E_WBEM_E_CANNOT_BE_ABSTRACT, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_AMENDED_OBJECT:
						LoadString(NULL, IDS_E_WBEM_E_AMENDED_OBJECT, 
									m_pszErrStr, MAX_BUFFER);
						break;

				   case WBEM_E_CLIENT_TOO_SLOW:
						LoadString(NULL, IDS_E_WBEM_E_CLIENT_TOO_SLOW, 
									m_pszErrStr, MAX_BUFFER);
						break;
				   default:
   						LoadString(NULL, IDS_E_UNKNOWN_WBEM_ERROR, 
									m_pszErrStr, MAX_BUFFER);
						break;
				}
			}
			else
				throw OUT_OF_MEMORY;
			bstrErrDesc = m_pszErrStr;
			SAFEDELETE(m_pszErrStr);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetWbemErrorText
   Synopsis	         :This function takes the error code as input and returns
					  an error string
   Type				 :Member Function
   Input parameter   :
			hr		- (error code) hresult value
			bXML	- Flag to indicate whether error is required in XML form
   Output parameters :
		bstrError	- String to containg error info in XML form
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetErrorString(hr)
   Notes             :None
------------------------------------------------------------------------*/
void CErrorInfo::GetWbemErrorText(HRESULT hr, BOOL bXML, _bstr_t& bstrError,
								  _bstr_t& bstrFacilityCode)
{
	try
	{
		CHString sTemp;
		if (bXML)
		{
			sTemp.Format(L"<HRESULT>0x%x</HRESULT>", hr);
		}
		bstrError += _bstr_t(sTemp);


		if (m_pIStatus == NULL)
		{
			if (SUCCEEDED(CreateStatusCodeObject()))
			{
				BSTR bstrErr = NULL, bstrFacility = NULL;

				// Get the text string description associated with 
				// the error code.
				if(SUCCEEDED(m_pIStatus->GetErrorCodeText(hr, 0, 0, &bstrErr)))
				{
					if (bXML)
					{
						bstrError += L"<DESCRIPTION>";
						bstrError += bstrErr;
						bstrError += L"</DESCRIPTION>";
					}
					else
					{
						bstrError = bstrErr;
					}

					// Get the subsystem where the error occured
					if(SUCCEEDED(m_pIStatus->GetFacilityCodeText(hr, 0, 0, 
									&bstrFacility)))
					{
						if (bstrFacility)
						{
							if (bXML)
							{
								bstrError += L"<FACILITYCODE>";
								bstrError += bstrFacility;
								bstrError += L"</FACILITYCODE>";
							}
							else
							{
								bstrFacilityCode = bstrFacility;
							}

							// If the subsystem is not Winmgmt ('Wbem') 
							// i.e. anyone of the "Windows" | "SSIP" | "RPC" set 
							// the m_bWMIErrSrc to FALSE
							if ((CompareTokens(_T("Wbem"), (_TCHAR*) bstrFacility)) ||
								(CompareTokens(_T("WMI"), (_TCHAR*) bstrFacility)))
							{
								m_bWMIErrSrc = TRUE;
							}
							else
								m_bWMIErrSrc = FALSE;
						}
					}
					SAFEBSTRFREE(bstrErr);
					SAFEBSTRFREE(bstrFacility);
				}
				else
				{
					if (bXML)
					{
						bstrError += 
						L"<DESCRIPTION>\"Unknown WBEM Error\"</DESCRIPTION>";
						bstrError += L"<FACILITYCODE/>";
					}
					m_bWMIErrSrc = FALSE;
				}
				SAFEIRELEASE(m_pIStatus);
			}
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*------------------------------------------------------------------------
   Name				 :CreateStatusCodeObject()
   Synopsis	         :This function creates the single uninitialized 
					  object of the class associated with the CLSID
					  CLSID_WbemStatusCodeText
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateStatusCodeObject()
   Notes             :None
-------------------------------------------------------------------*/
HRESULT CErrorInfo::CreateStatusCodeObject()
{
	// Create the single uninitialized object of the 
	// class associated with the CLSID CLSID_WbemStatusCodeText
	return CoCreateInstance(CLSID_WbemStatusCodeText, 
					0, CLSCTX_INPROC_SERVER,
					IID_IWbemStatusCodeText, 
					(LPVOID*) &m_pIStatus);
}


/*-------------------------------------------------------------------------
   Name				 :GetErrorFragment
   Synopsis	         :Frames the XML string for error info
   Type	             :Member Function
   Input parameters  :
		hr			- HResult Parameter
   Output parameters :
		bstrError	- String to containg error info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetErrorFragment()
-------------------------------------------------------------------------*/
void CErrorInfo::GetErrorFragment(HRESULT hr, _bstr_t& bstrError)
{
	try
	{
		_bstr_t bstrFacility;
		bstrError = L"<ERROR>";
		GetWbemErrorText(hr, TRUE, bstrError, bstrFacility);
		bstrError += L"</ERROR>";
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\commandswitches.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CommandSwitches.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality needed
							  for accessing and storing the command switches 
							  information, which will be used by Parsing, 
							  Execution and Format Engines depending upon the 
							  applicability. 
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 20th-March-2001
****************************************************************************/ 
#include "Precomp.h"
#include "CommandSwitches.h"

/////////////////////////////////////////////////////////////////////////////
/*------------------------------------------------------------------------
   Name				 :CCommandSwitches
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CCommandSwitches::CCommandSwitches()
{
	m_pszCommandInput			= NULL;
	m_pszAliasName				= NULL;
	m_pszAliasDesc				= NULL;
	m_pszClassPath				= NULL;
	m_pszPathExpr				= NULL;
	m_pszWhereExpr				= NULL;
	m_pszVerb					= NULL;
	m_pszMethodName				= NULL;
	m_pszAliasTarget			= NULL;
	m_bstrXML					= NULL;
	m_hResult					= S_OK;
	m_bSuccess					= TRUE;
	m_ulInterval				= 0;
	m_pszTransTableName			= NULL;
	m_nInteractiveMode			= DEFAULTMODE;
	m_pComError					= NULL;
	m_pszListFormat				= NULL;
	m_pszPWhereExpr             = NULL;
	m_uInformationCode			= 0;	
	m_pIMethOutParam			= NULL;
	m_pszUser					= NULL;
	m_pszPassword				= NULL;
	m_pszNamespace				= NULL;
	m_pszNode					= NULL;
	m_pszLocale					= NULL;
	m_pszAuthority				= NULL;
	m_pszVerbDerivation			= NULL;
	m_vtVerbType				= NONALIAS;
	m_bCredFlag					= FALSE;
	m_bExplicitWhereExpr		= FALSE;
	m_uErrataCode				= 0;	
	m_bTranslateFirst			= TRUE;
	m_pszResultClassName        = NULL;
	m_pszResultRoleName         = NULL;
	m_pszAssocClassName         = NULL;
	m_ulRepeatCount				= 0;
	m_bMethAvail				= FALSE;
	m_bWritePropsAvail			= FALSE;
	m_bLISTFrmsAvail			= FALSE;
	m_bNamedParamList			= FALSE;
	m_bEverySwitch              = FALSE;
	m_bOutputSwitch             = FALSE;
	m_bstrFormedQuery           = NULL;
	m_bSysProp					= FALSE;
	ClearXSLTDetailsVector();
}

/*------------------------------------------------------------------------
   Name				 :~CCommandSwitches
   Synopsis	         :This function Uninitializes the member variables when
                      an object of the class type is destructed.
   Type	             :Destructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CCommandSwitches::~CCommandSwitches()
{
	Uninitialize();
}

/*------------------------------------------------------------------------
   Name				 :SetCommandInput
   Synopsis	         :This function Assigns the parameter passed to m_psz
                      CommandInput
   Type	             :Member Function
   Input parameter   :
    pszCommandinput  -String type, Contains the command string
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetCommandInput (pszCommandInput)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetCommandInput(const _TCHAR* pszCommandInput)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszCommandInput);
	if (pszCommandInput)
	{
		m_pszCommandInput = new _TCHAR [lstrlen(pszCommandInput)+1];
		if(m_pszCommandInput)
			lstrcpy(m_pszCommandInput, pszCommandInput);	
		else
			bResult=FALSE;
	}	
	return bResult;
};

/*------------------------------------------------------------------------
   Name				 :SetAliasName
   Synopsis	         :This function assigns the parameters 
					  passed to m_pszAliasName.
   Type	             :Member Function
   Input parameter   :
     pszAliasName    -String type,Contains the alias name
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasName(pszAliasName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasName(const _TCHAR* pszAliasName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszAliasName);
	if (pszAliasName)
	{
		m_pszAliasName = new _TCHAR [lstrlen(pszAliasName)+1];
		if(m_pszAliasName)
			lstrcpy(m_pszAliasName, pszAliasName);	
		else
			bResult = FALSE;
	}
	return bResult;
};

/*------------------------------------------------------------------------
   Name				 :SetAliasDesc
   Synopsis	         :This function sets the alias description
   Type	             :Member Function
   Input parameter   :
     pszAliasName    -String type,Contains the alias description
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasDesc(pszAliasDesc)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasDesc(const _TCHAR* pszAliasDesc)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszAliasDesc);
	if (pszAliasDesc)
	{
		m_pszAliasDesc = new _TCHAR [lstrlen(pszAliasDesc)+1];
		if(m_pszAliasDesc)
			lstrcpy(m_pszAliasDesc, pszAliasDesc);	
		else
			bResult = FALSE;
	}
	return bResult;
};

/*------------------------------------------------------------------------
   Name				 :SetClassPath
   Synopsis	         :This function Assigns the parameter passed to 
					  m_pszClassPath.
   Type	             :Member Function
   Input parameter   :
     pszClassPath    -String type,Contains the class path in the command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetClassPath(pszClassPath)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetClassPath(const _TCHAR* pszClassPath)
{
	BOOL bResult = TRUE;
    SAFEDELETE(m_pszClassPath);
	if (pszClassPath)
	{
		m_pszClassPath = new _TCHAR [lstrlen(pszClassPath)+1];
		if(m_pszClassPath)
			lstrcpy(m_pszClassPath, pszClassPath);	
		else
			bResult = FALSE;
	}
	return bResult;

}

/*------------------------------------------------------------------------
   Name				 :SetPathExpression
   Synopsis	         :This function Assigns the parameter passed to m_psz
                      PathExpr.
   Type	             :Member Function
   Input parameter   :
       pszPathExpr   -String type, Contains the path value in the command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetPathExpression(pszPathExpr)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetPathExpression(const _TCHAR* pszPathExpr)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszPathExpr);
	if (pszPathExpr)
	{
		m_pszPathExpr = new _TCHAR [lstrlen(pszPathExpr)+1];
		if(m_pszPathExpr)
			lstrcpy(m_pszPathExpr, pszPathExpr);	
		else
			bResult = FALSE;
	}		
	return bResult;

}

/*------------------------------------------------------------------------
   Name				 :SetWhereExpression
   Synopsis	         :This function Assigns the parameter passed to 
                      m_pszWhereExpr.
   Type	             :Member Function
   Input parameter   :
      pszWhereExpr   -String type,Contains the where value in the command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetWhereExpression(pszWhereExpr)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetWhereExpression(const _TCHAR* pszWhereExpr)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszWhereExpr);
	if (pszWhereExpr)
	{
		m_pszWhereExpr = new _TCHAR [lstrlen(pszWhereExpr)+1];
		if(m_pszWhereExpr)
			lstrcpy(m_pszWhereExpr, pszWhereExpr);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetMethodName
   Synopsis	         :This function Assigns the parameter passed to 
                      m_pszMethodName.
   Type	             :Member Function
   Input parameter   :
     pszMethodName   -String type,Contains the method specified for the
	                  class 
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetMethodName(pszMethodName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetMethodName(const _TCHAR* pszMethodName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszMethodName);
	if (pszMethodName)
	{
		m_pszMethodName = new _TCHAR [lstrlen(pszMethodName)+1];
		if(m_pszMethodName)
			lstrcpy(m_pszMethodName, pszMethodName);	
		else
			bResult = FALSE;
	}	
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :AddToXSLTDetailsVector
   Synopsis	         :This function adds a XSLTDET structure to 
					  m_xdvXSLTDetVec vector.
   Type	             :Member Function
   Input parameter   :
		xdXSLTDet    - XSLTDET type specifies the details of XSL transform.
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :AddToXSLTDetailsVector(xdXSLTDet)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::AddToXSLTDetailsVector(XSLTDET xdXSLTDet)
{
	try
	{
		CHString sTemp(LPWSTR(xdXSLTDet.FileName));
		CHString sLastFour = sTemp.Right(4);
		CHString sXslExt(_T(".xsl"));

		WMICLIINT nPos = sLastFour.CompareNoCase(sXslExt);
		if (nPos != 0)
		{
			xdXSLTDet.FileName += _T(".xsl");
		}
	}
	catch(CHeap_Exception)
	{
		throw OUT_OF_MEMORY;
	}
	catch(...)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	m_xdvXSLTDetVec.push_back(xdXSLTDet);
}

/*------------------------------------------------------------------------
   Name				 :SetVerbName
   Synopsis	         :This function Assigns the parameter passed to 
                      m_pszVerbName.
   Type	             :Member Function
   Input parameter   :
       pszVerbName   -String type,Contains the Verbname in the command
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetVerbName( pszVerbName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetVerbName(const _TCHAR* pszVerbName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszVerb);
	if (pszVerbName)
	{
		m_pszVerb = new _TCHAR [lstrlen(pszVerbName)+1];
		if(m_pszVerb)
			lstrcpy(m_pszVerb, pszVerbName);	
		else
			bResult = FALSE;
	}
	return bResult;
};

/*------------------------------------------------------------------------
   Name				 :SetAliasTarget
   Synopsis	         :This function Assigns the parameter passed to 
                      m_pszAliasTarget.
   Type	             :Member Function
   Input parameters  :
     pszAliasTarget  -String type,the namespace where alias to 
					  operate against 
	                  are available.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasTarget(pszAliasTarget)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasTarget(const _TCHAR* pszAliasTarget)
{
	BOOL bResult = TRUE; 
	SAFEDELETE(m_pszAliasTarget);
	if (pszAliasTarget)
	{
		m_pszAliasTarget = new _TCHAR [lstrlen(pszAliasTarget)+1];
		if(m_pszAliasTarget)
			lstrcpy(m_pszAliasTarget, pszAliasTarget);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :AddToPropertyList
   Synopsis	         :This function Adds string that is passed 
					  through parameter to m_cvproperties, which 
					  is a data member of type BSTRMAP.
   Type	             :Member Function
   Input parameter   :
       pszProperty   -String type,Used for storing properties 
	                  associated with an alias object.  
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToPropertyList(pszProperty)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToPropertyList(_TCHAR* const pszProperty)
{
	BOOL bRet = TRUE;
	if (pszProperty)
	{
		try
		{
			_TCHAR* pszTemp = NULL;
			pszTemp = new _TCHAR [lstrlen(pszProperty)+1];
			if ( pszTemp != NULL )
			{
				lstrcpy(pszTemp, pszProperty);
				m_cvProperties.push_back(pszTemp);
			}
			else
				bRet = FALSE;
		}
		catch(...)
		{
			bRet = FALSE;
		}
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :AddToPWhereParamsList
   Synopsis	         :This function Stores the parameter passed into
					  m_cvPWhereParams map array.
   Type	             :Member Function
   Input parameter   :
      pszParameter   -string type, Used to store parameters associated 
	                  with the verbs
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToPWhereParamsList(pszParameter)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToPWhereParamsList(_TCHAR* const pszParameter)
{
	BOOL bRet= TRUE;
	if (pszParameter)
	{
		try
		{
			_TCHAR* pszTemp = new _TCHAR [lstrlen(pszParameter)+1];
			if ( pszTemp != NULL )
			{
				lstrcpy(pszTemp, pszParameter);
				m_cvPWhereParams.push_back(pszTemp);
			}
			else
				bRet = FALSE;
		}
		catch(...)
		{
			bRet = FALSE;
		}
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :AddToParameterMap
   Synopsis	         :This function Adds bstrKey and bstrValue passed as 
                      parameters to m_bmParameters, which is type of
					  BSTRMAP data structure.
   Type	             :Member Function
   Input parameter   :
   bstrKey           -bstr type contains a key value used in MAP file  
   bstrValue         -bstr type contains a value associated with the key
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToParameterMap(bstrKey,bstrValue)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToParameterMap(_bstr_t bstrKey, _bstr_t bstrValue)
{
	BOOL bResult = TRUE;
	try
	{
		m_bmParameters.insert(BSTRMAP::value_type(bstrKey, bstrValue));
	}
	catch(...)
	{
		bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :AddToAliasFormatDetMap
   Synopsis	         :This function Adds bstrKey and bstrValue passed as 
                      parameters to m_bmAliasForamt, which is type of
					  BSTRMAP data structure.
   Type	             :Member Function
   Input parameter   :
   bstrKey           -bstr type contains a key value used in MAP file  
   bstrValue         -bstr type contains a value associated with the key
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToAliasFormatDetMap(bstrKey,bvProps)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToAliasFormatDetMap(_bstr_t bstrKey, BSTRVECTOR bvProps)
{
	BOOL bResult = TRUE;
	try
	{
		m_afdAlsFmtDet.insert(ALSFMTDETMAP::value_type(bstrKey, bvProps));
	}
	catch(...)
	{
		bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :UpdateParameterValue
   Synopsis	         :This function Updates bstrKey and bstrValue 
					  passed as parameters to m_bmParameters, which 
					  is type of BSTRMAP data structure.
   Type	             :Member Function
   Input parameter   :
    bstrKey          -bstr type contains a key value used in MAP file  
    bstrValue        -bstr type contains a value associated with the key
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :UpdateParameterValue(bstrKey,bstrValue)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::UpdateParameterValue(_bstr_t bstrKey, _bstr_t bstrValue)
{
	BOOL bResult = TRUE;
	try
	{
		m_bmParameters[bstrKey] = bstrValue;
	}
	catch(...)
	{
		bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :AddToAlsFrnNmsOrTrnsTblMap
   Synopsis	         :This function Adds bstrKey and bstrValue passed 
                      as parameters to m_bmAlsFrnNmsDesOrTrnsTblEntrs, 
					  which is type of BSTRMAP.
   Type	             :Member Function
   Input parameter   :
          bstrKey    -bstr type contains a key value used in MAP file  
          bstrValue  -bstr type contains a value associated with the key
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToAlsFrnNmsOrTrnsTblMap(bstrKey,bstrValue)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToAlsFrnNmsOrTrnsTblMap(_bstr_t bstrKey, 
												 _bstr_t bstrValue)
{
	BOOL bResult = TRUE;
	try
	{
		m_bmAlsFrnNmsDesOrTrnsTblEntrs.
				insert(BSTRMAP::value_type(bstrKey, bstrValue));
	}
	catch(...)
	{
		bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :AddToMethDetMap
   Synopsis	         :This function Adds bstrKey and mdMethDet passed as 
                      parameters to m_mdmMethDet, which is type of METHDETMAP.
   Type	             :Member Function
   Input parameter   :
           bstrKey   -bstr type contains a key value used in MAP file  
         mdMethDet   -METTHODDETAILS type contains the method attributes.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToMethDetMap(bstrKey,mdMethDet)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToMethDetMap(_bstr_t bstrKey, 
										METHODDETAILS mdMethDet)
{
	BOOL bResult = TRUE;
	try
	{
		m_mdmMethDet.insert(METHDETMAP::value_type(bstrKey, mdMethDet));
	}
	catch(...)
	{
		bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :AddToPropDetMap
   Synopsis	         :This function Adds bstrKey and pdPropDet passed as 
                      parameters to m_pdmPropDet,
					  which is type of PROPDETMAP.
   Type	             :Member Function
   Input parameter   :
           bstrKey   - bstr type contains a key value used in MAP file  
         pdPropDet   - PROPERTYDETAILS type contains a value associated with 
					   the key
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToPropDetMap(bstrKey,pdPropDet)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToPropDetMap(_bstr_t bstrKey, 
										PROPERTYDETAILS pdPropDet)
{
	BOOL bResult = TRUE;
	try
	{
		m_pdmPropDet.insert(PROPDETMAP::value_type(bstrKey, pdPropDet));
	}
	catch(...)
	{
		bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetXMLResultSet
   Synopsis	         :This function Assigns the parameter passed to 
                      m_bstrXML.
   Type	             :Member Function
   Input parameter   :
   bstrXMLResultSet  -BSTR type,XML file name containing result set.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetXMLResultSet(bstrXMLResultSet)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetXMLResultSet(const BSTR bstrXMLResultSet)
{
	BOOL bResult = TRUE;
	SAFEBSTRFREE(m_bstrXML);
	if (bstrXMLResultSet != NULL)
	{
		try
		{
			m_bstrXML = SysAllocString(bstrXMLResultSet);

			if (m_bstrXML == NULL)
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
		catch(CHeap_Exception)
		{
			bResult = FALSE;
		}
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetSuccessFlag
   Synopsis	         :This function Assigns the Boolean variable to 
					  m_bSuccess.
   Type	             :Member Function
   Input parameter   :
          bSuccess   -Boolean type,Specifies whether success or failure
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetSuccessFlag(bSuccess)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetSuccessFlag(BOOL bSuccess)
{
	m_bSuccess = bSuccess;
	
}

/*------------------------------------------------------------------------
   Name				 :SetRetrievalInterval
   Synopsis	         :This function Assigns the integer value to m_nInterval.
   Type	             :Member Function
   Input parameter   :
         ulInterval   - unsigned long type,Specifies the time interval 
					  given by the EVERY switch in  GET verb.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetRetrievalInterval(lInterval)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetRetrievalInterval(const ULONG ulInterval)
{
	m_ulInterval = ulInterval;

	// Reset the repeat count
	m_ulRepeatCount = 0;
	return TRUE;
}

/*------------------------------------------------------------------------
   Name				 :SetTranslateTableName
   Synopsis	         :This function Assigns the string variable to 
                      m_pszTransTableName.
   Type	             :Member Function
   Input parameter   :
    pszTransTableName - String type,Specifies the occurrence of 
		              TRANSLATE switch and TABLE Name in the command for GET
					  verb.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetTranslateTableName(pszTranstableName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetTranslateTableName(const _TCHAR* pszTransTableName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszTransTableName);
	if (pszTransTableName)
	{
		m_pszTransTableName = new _TCHAR [lstrlen(pszTransTableName)+1];
		if(m_pszTransTableName)
			lstrcpy(m_pszTransTableName,pszTransTableName);
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetListFormat
   Synopsis	         :This function Assigns the parameter value to
                      m_pszListFormat.
   Type	             :Member Function
   Input parameter   :
     pszListFormat   -LISTFORMAT type, Specifies the list format
	                  specified in the command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetListFormat(pszListFormat)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetListFormat(const _TCHAR *pszListFormat)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszListFormat);
	if (pszListFormat)
	{
		m_pszListFormat = new _TCHAR [lstrlen(pszListFormat)+1];
		if(m_pszListFormat)
			lstrcpy(m_pszListFormat,pszListFormat);
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetInteractiveMode
   Synopsis	         :This function sets the verb execution interactive mode 
   Type	             :Member Function
   Input parameter   :
   bInteractiveMode  -integer, sets or resets the verb execution interactive 
					  mode 
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetInteractiveMode(nInteractiveMode)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetInteractiveMode(WMICLIINT nInteractiveMode)
{
	m_nInteractiveMode = nInteractiveMode;
	
}

/*------------------------------------------------------------------------
   Name				 :SetErrataCode
   Synopsis	         :This function sets the error code.
   Type	             :Member Function
   Input parameter   :
		uErrataCode  -Unsignedinttype, specifies the error code.
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetErrataCode(uErrataCode)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetErrataCode(const UINT uErrataCode)
{
	m_uErrataCode = uErrataCode;
	
}

/*------------------------------------------------------------------------
   Name				 :SetRepeatCount
   Synopsis	         :This function sets the repeat count.
   Type	             :Member Function
   Input parameter   :
		uRepCount  - Unsigned inttype, specifies the repeat count.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetRepeatCount(uRepCount)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetRepeatCount(const ULONG ulRepCount)
{
	m_ulRepeatCount = ulRepCount;
	return TRUE;
}

/*------------------------------------------------------------------------
   Name				 :SetInformationCode
   Synopsis	         :This function sets the message code.
   Type	             :Member Function
   Input parameter   :
	uInformationCode -Unsignedinttype, specifies the information code.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetInformationCode(uInformationCode)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetInformationCode(const UINT uInformationCode)
{
	m_uInformationCode = uInformationCode;
	
}

/*------------------------------------------------------------------------
   Name				 :SetPWhereExpr
   Synopsis	         :This function Assigns the parameter passed to 
					  m_pszPWhereExpr that represents Alias's PWhere string
   Type	             :Member Function
   Input parameter   :
     pszPWhereExpr    -String type,Contains the PWhere expr.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetPWhereExpr(pszPWhereExpr)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetPWhereExpr(const _TCHAR* pszPWhereExpr)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszPWhereExpr);
	if (pszPWhereExpr)
	{
		m_pszPWhereExpr = new _TCHAR [lstrlen(pszPWhereExpr)+1];
		if(m_pszPWhereExpr)
			lstrcpy(m_pszPWhereExpr, pszPWhereExpr);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetCOMError
   Synopsis	         :This function Assigns the parameter passed to 
					  m_pComError that consist of error info
   Type	             :Member Function
   Input parameter   :
     rComError	     -object of _com_error which consist of error info
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetCOMError(rComError)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetCOMError(_com_error& rComError)
{
	BOOL bResult = TRUE;
	FreeCOMError();
	m_pComError = new _com_error(rComError);

	// memory allocation failed.
	if (m_pComError == NULL)
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
}

/*------------------------------------------------------------------------
   Name				 :SetAliasUser
   Synopsis	         :This function sets the alias user 
   Type	             :Member Function
   Input parameter   :
			pszUser - user name.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasUser()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasUser(const _TCHAR* pszUser)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszUser);
	if (pszUser)
	{
		m_pszUser = new _TCHAR [lstrlen(pszUser)+1];
		if(m_pszUser)
			lstrcpy(m_pszUser, pszUser);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAliasAuthorityPrinciple
   Synopsis	         :This function sets the alias authority
   Type	             :Member Function
   Input parameter   :
			pszAuthority - authority type associated with alias connection
					  info.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasAuthorityPrinciple()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasAuthorityPrinciple(const _TCHAR* pszAuthority)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszAuthority);
	if (pszAuthority)
	{
		m_pszAuthority = new _TCHAR [lstrlen(pszAuthority)+1];
		if(m_pszAuthority)
			lstrcpy(m_pszAuthority, pszAuthority);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAliasNode
   Synopsis	         :This function sets the alias node 
   Type	             :Member Function
   Input parameter   :
				pszNode - node name.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasNode()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasNode(const _TCHAR* pszNode)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszNode);
	if (pszNode)
	{
		m_pszNode = new _TCHAR [lstrlen(pszNode)+1];
		if(m_pszNode)
			lstrcpy(m_pszNode, pszNode);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAliasPassword
   Synopsis	         :This function sets the alias password
   Type	             :Member Function
   Input parameter   :
				pszPassword - password
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasPassword()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasPassword(const _TCHAR* pszPassword)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszPassword);
	if (pszPassword)
	{
		m_pszPassword = new _TCHAR [lstrlen(pszPassword)+1];
		if(m_pszPassword)
			lstrcpy(m_pszPassword, pszPassword);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAliasLocale
   Synopsis	         :This function sets the alias locale
   Type	             :Member Function
   Input parameter   :
				pszLocale - locale value
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasLocale()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasLocale(const _TCHAR* pszLocale)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszLocale);
	if (pszLocale)
	{
		m_pszLocale = new _TCHAR [lstrlen(pszLocale)+1];
		if(m_pszLocale)
			lstrcpy(m_pszLocale, pszLocale);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAliasNamespace
   Synopsis	         :This function sets the alias namespace 
   Type	             :Member Function
   Input parameter   :
				pszNamespace - namespace
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAliasNamespace()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAliasNamespace(const _TCHAR* pszNamespace)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszNamespace);
	if (pszNamespace)
	{
		m_pszNamespace = new _TCHAR [lstrlen(pszNamespace)+1];
		if(m_pszNamespace)
			lstrcpy(m_pszNamespace, pszNamespace);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetMethExecOutParam
   Synopsis	         :This function sets the parameter
					  m_pIMethExecOutParam.
   Type	             :Member Function
   Input parameter   :
	IWbemClassObject*-pIMethOutputParam 
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetMethExecOutParam(pIMethOutParam)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetMethExecOutParam(IWbemClassObject* pIMethOutParam)
{
	BOOL bSuccess = TRUE;
	SAFEIRELEASE(m_pIMethOutParam);
	if (pIMethOutParam)
	{
		try
		{
			m_pIMethOutParam = pIMethOutParam;
			m_pIMethOutParam->AddRef();
		}
		catch(...)
		{
			bSuccess = FALSE;
		}
	}
	return bSuccess;
}

/*------------------------------------------------------------------------
   Name				 :SetVerbType
   Synopsis	         :This function sets the parameter
					  m_vtVerbType.
   Type	             :Member Function
   Input parameter   :
		vtVerbType   - vtVerbType 
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetVerbType(vtVerbType)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetVerbType(VERBTYPE vtVerbType)
{
	m_vtVerbType = vtVerbType;
}

/*------------------------------------------------------------------------
   Name				 :SetVerbDerivation
   Synopsis	         :This function sets the verb derivation
   Type	             :Member Function
   Input parameter   :
    pszVerbDerivation - Derivation associated with the verb.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :CCmdAlias::ObtainAliasVerbDetails()
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetVerbDerivation(const _TCHAR* pszVerbDerivation)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszVerbDerivation);
	if (pszVerbDerivation)
	{
		m_pszVerbDerivation = new _TCHAR [lstrlen(pszVerbDerivation)+1];
		if(m_pszVerbDerivation)
			lstrcpy(m_pszVerbDerivation, pszVerbDerivation);	
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :GetCommandInput
   Synopsis	         :This function Returns the command input held by
                      the Command Switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetCommandInput()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetCommandInput()
{
	return m_pszCommandInput;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasName()
   Synopsis	         :This function Returns the alias name held by the 
					  command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasName()
{
	return m_pszAliasName;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasDesc()
   Synopsis	         :This function Returns the alias description
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasDesc()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasDesc()
{
	return m_pszAliasDesc;
}

/*------------------------------------------------------------------------
   Name				 :GetClassPath
   Synopsis	         :This function Returns the class path held by the 
					  command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetClassPath()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetClassPath()
{
	return m_pszClassPath;
}

/*------------------------------------------------------------------------
   Name				 :GetPathExpression
   Synopsis	         :This function Returns the path expression held
                      by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetPathExpression()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetPathExpression()
{
	return m_pszPathExpr;
}

/*------------------------------------------------------------------------
   Name				 :GetWhereExpression
   Synopsis	         :This function Returns the where expression 
                      held by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetWhereExpression()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetWhereExpression()
{
	return m_pszWhereExpr;
}

/*------------------------------------------------------------------------
   Name				 :GetMethodName()
   Synopsis	         :This function Returns the method name held by the 
					  command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetMethodName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetMethodName()
{
	return m_pszMethodName;
}

/*------------------------------------------------------------------------
   Name				 :GetXSLTDetailsVector
   Synopsis	         :This function Returns the XSLTDETVECTOR held by 
                      the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :XSLTDETVECTOR
   Global Variables  :None
   Calling Syntax    :GetXSLTDetailsVector()
   Notes             :None
------------------------------------------------------------------------*/
XSLTDETVECTOR& CCommandSwitches::GetXSLTDetailsVector()
{
	return m_xdvXSLTDetVec;
}

/*------------------------------------------------------------------------
   Name				 :GetVerbName
   Synopsis	         :This function Returns the verb name held by the 
					  command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetVerbName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetVerbName()
{
	return m_pszVerb;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasTarget
   Synopsis	         :This function Returns the alias target held by 
                      the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasTarget()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasTarget()
{
	return m_pszAliasTarget;
}

/*------------------------------------------------------------------------
   Name				 :GetXMLResultSet
   Synopsis	         :This function Returns the XML result set 
                      held by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BSTR
   Global Variables  :None
   Calling Syntax    :GetXMLResultSet()
   Notes             :None
------------------------------------------------------------------------*/
BSTR CCommandSwitches::GetXMLResultSet()
{
	return m_bstrXML;
}

/*------------------------------------------------------------------------
   Name				 :GetPropertyList
   Synopsis	         :This function Returns the property held by the 
					  command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHARVECTOR&
   Global Variables  :None
   Calling Syntax    :GetPropertyList()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CCommandSwitches::GetPropertyList()
{
	return m_cvProperties;
}

/*------------------------------------------------------------------------
   Name				 :GetPWhereParamsList
   Synopsis	         :This function Returns the PWhereParameters list held
					  by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHARVECTOR&
   Global Variables  :None
   Calling Syntax    :GetPWhereParamsList()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CCommandSwitches::GetPWhereParamsList()
{
	return m_cvPWhereParams;
}

/*------------------------------------------------------------------------
   Name				 :GetAlsFrnNmsOrTrnsTblMap
   Synopsis	         :This function Returns the alias friendly names map 
                      held by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BSTRMAP&
   Global Variables  :None
   Calling Syntax    :GetAlsFrnNmsOrTrnsTblMap()
   Notes             :None
------------------------------------------------------------------------*/
BSTRMAP& CCommandSwitches::GetAlsFrnNmsOrTrnsTblMap()
{
	return m_bmAlsFrnNmsDesOrTrnsTblEntrs;
}

/*------------------------------------------------------------------------
   Name				 :GetMethDetMap
   Synopsis	         :This function Returns the method or verb details
                      map held by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :METHDETMAP&
   Global Variables  :None
   Calling Syntax    :GetMethDetMap()
   Notes             :None
------------------------------------------------------------------------*/
METHDETMAP& CCommandSwitches::GetMethDetMap()
{
	return m_mdmMethDet;
}

/*------------------------------------------------------------------------
   Name				 :GetPropDetMap
   Synopsis	         :This function Returns the prop details map held by
					  the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :PROPDETMAP&
   Global Variables  :None
   Calling Syntax    :GetPropDetMap()
   Notes             :None
------------------------------------------------------------------------*/
PROPDETMAP& CCommandSwitches::GetPropDetMap()
{
	return m_pdmPropDet;
}

/*------------------------------------------------------------------------
   Name				 :GetParameterMap
   Synopsis	         :This function Returns the parameter map containing
                      both key and value held by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BSTRMAP&
   Global Variables  :None
   Calling Syntax    :GetParameterMap()
   Notes             :None
------------------------------------------------------------------------*/
BSTRMAP& CCommandSwitches::GetParameterMap()
{
	return m_bmParameters;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasFormatDetMap
   Synopsis	         :This function Returns the alias formats available
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :ALSFMTDETMAP&
   Global Variables  :None
   Calling Syntax    :GetAliasFormatDetMap()
   Notes             :None
------------------------------------------------------------------------*/
ALSFMTDETMAP& CCommandSwitches::GetAliasFormatDetMap()
{
	return m_afdAlsFmtDet;
}

/*------------------------------------------------------------------------
   Name				 :GetSuccessFlag
   Synopsis	         :This function Returns the success flag held by 
                      the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetSuccessFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::GetSuccessFlag()
{
	return m_bSuccess;
}

/*------------------------------------------------------------------------
   Name				 :GetRetrievalInterval
   Synopsis	         :This function Returns the value of m_ulInterval held 
					  by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :ULONG
   Global Variables  :None
   Calling Syntax    :GetRetrievalInterval()
   Notes             :None
------------------------------------------------------------------------*/
ULONG CCommandSwitches::GetRetrievalInterval()
{
	return m_ulInterval;
}

/*------------------------------------------------------------------------
   Name				 :GetTranslateTableName
   Synopsis	         :This function Returns the content of m_pszTransTableName
					  held by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetTranslateTableName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetTranslateTableName()
{
	return m_pszTransTableName;
}

/*------------------------------------------------------------------------
   Name				 :GetListFormat
   Synopsis	         :This function Returns the list format type 
					  m_pszListFormat held by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetListFormat()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetListFormat()
{
	return m_pszListFormat;
}

/*------------------------------------------------------------------------
   Name				 :GetInteractiveMode
   Synopsis	         :This function Returns the interactive mode flag 
                      m_bInteractiveMode held by the command switches object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :WMICLINT
   Global Variables  :None
   Calling Syntax    :GetInteractiveMode()
   Notes             :None
------------------------------------------------------------------------*/
WMICLIINT CCommandSwitches::GetInteractiveMode()
{
	return m_nInteractiveMode;
}

/*------------------------------------------------------------------------
   Name				 :GetClassOfAliasTarget
   Synopsis	         :This function gets the class of Alias
   Type	             :Member Function
   Input parameter   :Reference to bstrClassName
   Output parameters :bstrClassName
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetClassOfAliasTarget(bstrClassName)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::GetClassOfAliasTarget(_bstr_t& bstrClassName)
{
	_TCHAR *pszTemp;
	try
	{
		if (m_pszAliasTarget != NULL )
		{
			pszTemp = new _TCHAR[lstrlen(m_pszAliasTarget)+1];
			if ( pszTemp != NULL )
			{
				lstrcpy(pszTemp, m_pszAliasTarget);
				_TCHAR* pszToken = NULL;

				pszToken = _tcstok(pszTemp, CLI_TOKEN_SPACE);
				while (pszToken != NULL)
				{
					bstrClassName = _bstr_t(pszToken);
					pszToken = _tcstok(NULL, CLI_TOKEN_SPACE);

					if(CompareTokens(pszToken,CLI_TOKEN_FROM))
					{
						bstrClassName = _bstr_t(pszToken);
						pszToken = _tcstok(NULL, CLI_TOKEN_SPACE);
						if (pszToken != NULL)
						{
							bstrClassName = _bstr_t(pszToken);	
							break;
						}
					}
				}
				SAFEDELETE(pszTemp);
			}
			else
				_com_issue_error(WBEM_E_OUT_OF_MEMORY);
		}
	}
	catch(_com_error& e)
	{
		SAFEDELETE(pszTemp);
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetErrataCode
   Synopsis	         :This function returns the error code
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :UINT
   Global Variables  :None
   Calling Syntax    :GetErrataCode()
   Notes             :None
------------------------------------------------------------------------*/
UINT CCommandSwitches::GetErrataCode()
{
	return m_uErrataCode;
}

/*------------------------------------------------------------------------
   Name				 :GetRepeatCount
   Synopsis	         :This function returns the repeat count.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :ULONG
   Global Variables  :None
   Calling Syntax    :GetRepeatCount()
   Notes             :None
------------------------------------------------------------------------*/
ULONG CCommandSwitches::GetRepeatCount()
{
	return m_ulRepeatCount;
}

/*------------------------------------------------------------------------
   Name				 :GetInformationCode
   Synopsis	         :This function returns the message code
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :UINT
   Global Variables  :None
   Calling Syntax    :GetInformationCode()
   Notes             :None
------------------------------------------------------------------------*/
UINT CCommandSwitches::GetInformationCode()
{
	return m_uInformationCode;
}

/*------------------------------------------------------------------------
   Name				 :GetPWhereExpr
   Synopsis	         :This function returns the PWhere string
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :UINT
   Global Variables  :None
   Calling Syntax    :GetPWhereExpr()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetPWhereExpr()
{
	return m_pszPWhereExpr;
}

/*------------------------------------------------------------------------
   Name				 :GetCOMError
   Synopsis	         :This function returns the COMError object
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_com_error*
   Global Variables  :None
   Calling Syntax    :GetCOMError()
   Notes             :None
------------------------------------------------------------------------*/
_com_error* CCommandSwitches::GetCOMError()
{
	return m_pComError;
}

/*------------------------------------------------------------------------
   Name				 :GetMethExecOutParam
   Synopsis	         :This function returns the parameter
					  m_pIMethExecOutParam.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :Pointer to IWbemClassObject
   Global Variables  :None
   Calling Syntax    :GetMethExecOutParam()
   Notes             :None
------------------------------------------------------------------------*/
IWbemClassObject* CCommandSwitches::GetMethExecOutParam()
{
	return m_pIMethOutParam;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasUser
   Synopsis	         :This function returns the alias user 
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasUser()
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasUser()
{
	return m_pszUser;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasPassword
   Synopsis	         :This function returns the alias password
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasPassword()
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasPassword()
{
	return m_pszPassword;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasNode
   Synopsis	         :This function returns the alias node
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasNode()
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasNode()
{
	return m_pszNode;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasLocale
   Synopsis	         :This function returns the alias locale
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasLocale()
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasLocale()
{
	return m_pszLocale;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasNamespace
   Synopsis	         :This function returns the alias namespace
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasNamespace()
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasNamespace()
{
	return m_pszNamespace;
}

/*------------------------------------------------------------------------
   Name				 :GetAliasAuthorityPrinciple
   Synopsis	         :This function returns the alias authority type.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAliasAuthorityPrinciple()
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAliasAuthorityPrinciple()
{
	return m_pszAuthority;
}

/*------------------------------------------------------------------------
   Name				 :GetVerbType
   Synopsis	         :This function returns type of the verb
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :VERBTYPE
   Global Variables  :None
   Calling Syntax    :CParserEngine::ParseMethodInfo()
------------------------------------------------------------------------*/
VERBTYPE CCommandSwitches::GetVerbType()
{
	return m_vtVerbType;
}

/*------------------------------------------------------------------------
   Name				 :GetVerbDerivation
   Synopsis	         :This function Returns the derivation associated with
					  the verb.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetVerbDerivation()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetVerbDerivation()
{
	return m_pszVerbDerivation;
}

/*------------------------------------------------------------------------
   Name				 :Initialize
   Synopsis	         :This function initializes the necessary member 
					  variables.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Initialize()
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::Initialize() throw(WMICLIINT)
{
	static BOOL bFirst		= TRUE;
	m_uErrataCode			= 0;	
	m_uInformationCode		= 0;	
	m_vtVerbType			= NONALIAS;
	m_bCredFlag				= FALSE;
	m_bExplicitWhereExpr	= FALSE;
	m_bTranslateFirst		= TRUE;

	if (bFirst)
	{
		// Default list format is assumed as FULL
		m_pszListFormat	= new _TCHAR [BUFFER32];

		if (m_pszListFormat == NULL)
			throw OUT_OF_MEMORY;
		lstrcpy(m_pszListFormat, _T("FULL"));
		bFirst = FALSE;
	}
}


/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables 
					  when the execution of a command string issued on the
					  command line is completed.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::Uninitialize()
{
	SAFEDELETE(m_pszCommandInput);
	SAFEDELETE(m_pszAliasName);
	SAFEDELETE(m_pszAliasDesc);
	SAFEDELETE(m_pszClassPath);
	SAFEDELETE(m_pszPathExpr);
	SAFEDELETE(m_pszWhereExpr);
	SAFEDELETE(m_pszVerb);
	SAFEDELETE(m_pszMethodName);
	ClearXSLTDetailsVector();
	SAFEDELETE(m_pszAliasTarget);
	SAFEDELETE(m_pszUser);
	SAFEDELETE(m_pszLocale);
	SAFEDELETE(m_pszAuthority);
	SAFEDELETE(m_pszPassword);
	SAFEDELETE(m_pszNamespace);
	SAFEDELETE(m_pszNode);
	SAFEDELETE(m_pszVerbDerivation);
	SAFEDELETE(m_pszListFormat);
	SAFEDELETE(m_pszPWhereExpr);
	FreeCOMError();
	SAFEDELETE(m_pszTransTableName);

	CleanUpCharVector(m_cvProperties);
	CleanUpCharVector(m_cvInteractiveProperties);
	CleanUpCharVector(m_cvPWhereParams);
	CleanUpCharVector(m_cvTrnsTablesList);
	m_bmParameters.clear();
	m_afdAlsFmtDet.clear();
	m_bmAlsFrnNmsDesOrTrnsTblEntrs.clear();
	m_mdmMethDet.clear();
	m_pdmPropDet.clear();

	m_hResult				= S_OK;
	m_bSuccess				= TRUE;
	m_uInformationCode		= 0;	
	m_ulInterval				= 0;
	m_vtVerbType			= NONALIAS;
	m_bCredFlag				= FALSE;
	m_bExplicitWhereExpr	= FALSE;
	m_nInteractiveMode		= DEFAULTMODE;
	m_bTranslateFirst		= TRUE;
	SAFEIRELEASE(m_pIMethOutParam);
	SAFEBSTRFREE(m_bstrXML);
	SAFEDELETE(m_pszResultClassName);
	SAFEDELETE(m_pszResultRoleName);
	SAFEDELETE(m_pszAssocClassName);
	m_ulRepeatCount				= 0;
	m_bMethAvail				= FALSE;
	m_bWritePropsAvail			= FALSE;
	m_bLISTFrmsAvail			= FALSE;
	m_bNamedParamList			= FALSE;
	m_bEverySwitch              = FALSE; // do not put m_bOutputSwitch here.
	SAFEBSTRFREE(m_bstrFormedQuery);
	m_bSysProp					= FALSE;
}

/*------------------------------------------------------------------------
   Name				 :SetCredentialsFlag
   Synopsis	         :This function sets the credential flag status
   Type	             :Member Function
   Input parameter   :
				bCredFlag - credential flag value
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetCredentialsFlag()
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetCredentialsFlag(BOOL bCredFlag)
{
	m_bCredFlag = bCredFlag;
}

/*------------------------------------------------------------------------
   Name				 :SetExplicitWhereExprFlag
   Synopsis	         :This function sets the explicit where expression flag
   Type	             :Member Function
   Input parameter   :
				bWhereFlag - explicit where flag
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetExplicitWhereExprFlag()
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetExplicitWhereExprFlag(BOOL bWhereFlag)
{
	m_bExplicitWhereExpr = bWhereFlag;
}


/*------------------------------------------------------------------------
   Name				 :GetCredentialsFlagStatus
   Synopsis	         :This function returns the credential flag status
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetCredentialsFlagStatus()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::GetCredentialsFlagStatus()
{
	return m_bCredFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetExplicitWhereExprFlag
   Synopsis	         :This function returns the explicit where flag status
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetExplicitWhereExprFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::GetExplicitWhereExprFlag()
{
	return m_bExplicitWhereExpr;
}

/*------------------------------------------------------------------------
   Name				 :FreeCOMError
   Synopsis	         :This function deletes the previously assigned 
					  error
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :FreeCOMError(rComError)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::FreeCOMError()
{
	if (m_pComError != NULL)
	{
		delete m_pComError;
		m_pComError = NULL;
	}
}

/*------------------------------------------------------------------------
   Name				 :GetTrnsTablesList
   Synopsis	         :This function add the newly specified table name to 
					  the list of available translate table entries
   Type	             :Member Function
   Input parameter   :
			pszTableName - name of the translate table
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToTrnsTablesList(pszTableName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToTrnsTablesList(_TCHAR* const pszTableName)
{
	BOOL bRet = TRUE;
	if (pszTableName)
	{
		try
		{
			_TCHAR* pszTemp = NULL;
			pszTemp = new _TCHAR [lstrlen(pszTableName)+1];
			if ( pszTemp != NULL )
			{
				lstrcpy(pszTemp, pszTableName);
				m_cvTrnsTablesList.push_back(pszTemp);
			}
			else
				bRet = FALSE;
		}
		catch(...)
		{
			bRet = FALSE;
		}
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :GetTrnsTablesList
   Synopsis	         :This function returns the populated translate table
					  information.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :
			reference to CHARVECTOR
   Global Variables  :None
   Calling Syntax    :GetTrnslTablesList()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CCommandSwitches::GetTrnsTablesList()
{
	return m_cvTrnsTablesList;
}

/*------------------------------------------------------------------------
   Name				 :SetTranslateFirstFlag
   Synopsis	         :This function sets the the order of the format and 
					  translate switch flag
   Type	             :Member Function
   Input parameter   :
		bTranslateFirst - order of the format and translate switch flag
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetTranslateFirstFlag(bTranslateFirst)
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::SetTranslateFirstFlag(BOOL bTranslateFirst)
{
	m_bTranslateFirst = bTranslateFirst;
}

/*------------------------------------------------------------------------
   Name				 :GetTranslateFirstFlag
   Synopsis	         :This function returns the order of the format and 
					  translate switch flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetTranslateFirstFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::GetTranslateFirstFlag()
{
	return m_bTranslateFirst;
}

/*------------------------------------------------------------------------
   Name				 :ClearPropertyList
   Synopsis	         :This function clears the property list held by 
					  m_cvProperties. 
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :ClearPropertyList()
   Notes             :None
------------------------------------------------------------------------*/
void CCommandSwitches::ClearPropertyList()
{
	CleanUpCharVector(m_cvProperties);
}

/*------------------------------------------------------------------------
   Name				 :SetResultClassName
   Synopsis	         :This function Assigns the string variable to 
                      m_pszTransTableName.
   Type	             :Member Function
   Input parameter   :
    pszTransTableName - String type,Specifies the occurrence of 
		              TRANSLATE switch and TABLE Name in the command for GET
					  verb.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetTranslateTableName(pszTranstableName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetResultClassName(const _TCHAR* pszResultClassName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszResultClassName);
	if (pszResultClassName)
	{
		m_pszResultClassName = new _TCHAR [lstrlen(pszResultClassName)+1];
		if(m_pszResultClassName)
			lstrcpy(m_pszResultClassName,pszResultClassName);
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetResultRoleName
   Synopsis	         :This function Assigns the string variable to 
                      m_pszTransTableName.
   Type	             :Member Function
   Input parameter   :
    pszTransTableName - String type,Specifies the occurrence of 
		              TRANSLATE switch and TABLE Name in the command for GET
					  verb.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetTranslateTableName(pszTranstableName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetResultRoleName(const _TCHAR* pszResultRoleName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszResultRoleName);
	if (pszResultRoleName)
	{
		m_pszResultRoleName = new _TCHAR [lstrlen(pszResultRoleName)+1];
		if(m_pszResultRoleName)
			lstrcpy(m_pszResultRoleName,pszResultRoleName);
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAssocClassName
   Synopsis	         :This function Assigns the string variable to 
                      m_pszAssocClassName.
   Type	             :Member Function
   Input parameter   :
    pszAssocClassName - String type,Specifies the occurrence of 
		              TRANSLATE switch and TABLE Name in the command for GET
					  verb.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAssocClassName(pszAssocClassName)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetAssocClassName(const _TCHAR* pszAssocClassName)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszAssocClassName);
	if (pszAssocClassName)
	{
		m_pszAssocClassName = new _TCHAR [lstrlen(pszAssocClassName)+1];
		if(m_pszAssocClassName)
			lstrcpy(m_pszAssocClassName,pszAssocClassName);
		else
			bResult = FALSE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetMethodsAvailable
   Synopsis	         :This function sets the methods available flag 
					  m_bMethAvail, according to passed parameter.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetMethodsAvailable(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetMethodsAvailable(BOOL bFlag)
{
	m_bMethAvail = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetResultClassName
   Synopsis	         :This function Returns the content of m_pszResultClassName
					  held by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetResultClassName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetResultClassName()
{
	return m_pszResultClassName;
}

/*------------------------------------------------------------------------
   Name				 :GetResultRoleName
   Synopsis	         :This function Returns the content of m_pszResultRoleName
					  held by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetResultRoleName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetResultRoleName()
{
	return m_pszResultRoleName;
}

/*------------------------------------------------------------------------
   Name				 :GetAssocClassName
   Synopsis	         :This function Returns the content of m_pszAssocClassName
					  held by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAssocClassName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CCommandSwitches::GetAssocClassName()
{
	return m_pszAssocClassName;
}

/*------------------------------------------------------------------------
   Name				 :GetMethodsAvailable
   Synopsis	         :This function Returns the boolean value of 
					  m_bMethAvail.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetMethodsAvailable()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetMethodsAvailable()
{
	return m_bMethAvail;
}

/*------------------------------------------------------------------------
   Name				 :SetWriteablePropsAvailable
   Synopsis	         :This function sets writable properties available flag,
					  m_bWritePropsAvail.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetWriteablePropsAvailable(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetWriteablePropsAvailable(BOOL bFlag)
{
	m_bWritePropsAvail = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetWriteablePropsAvailable
   Synopsis	         :This function returns writable properties available 
					  flag, m_bWritePropsAvail.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetWriteablePropsAvailable()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetWriteablePropsAvailable()
{
	return m_bWritePropsAvail;
}

/*------------------------------------------------------------------------
   Name				 :SetLISTFormatsAvailable
   Synopsis	         :This function sets LIST Formats available flag,
					  m_bLISTFrmsAvail.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetLISTFormatsAvailable(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetLISTFormatsAvailable(BOOL bFlag)
{
	m_bLISTFrmsAvail = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetLISTFormatsAvailable
   Synopsis	         :This function returns LIST Formats available flag,
					  m_bLISTFrmsAvail.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetLISTFormatsAvailable()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetLISTFormatsAvailable()
{
	return m_bLISTFrmsAvail;
}

/*------------------------------------------------------------------------
   Name				 :AddToPropertyList
   Synopsis	         :This function Adds string that is passed 
					  through parameter to m_cvInteractiveProperties, 
					  which is a data member of type BSTRMAP.
   Type	             :Member Function
   Input parameter   :
       pszProperty   -String type,Used for storing properties 
	                  associated with an alias object.  
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :AddToPropertyList(pszProperty)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::AddToInteractivePropertyList(_TCHAR* const pszProperty)
{
	BOOL bRet = TRUE;
	if (pszProperty)
	{
		try
		{
			_TCHAR* pszTemp = NULL;
			pszTemp = new _TCHAR [lstrlen(pszProperty)+1];
			if ( pszTemp != NULL )
			{
				lstrcpy(pszTemp, pszProperty);
				m_cvInteractiveProperties.push_back(pszTemp);
			}
			else
				bRet = FALSE;
		}
		catch(...)
		{
			bRet = FALSE;
		}
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :GetPropertyList
   Synopsis	         :This function Returns the interactive property held 
						by the command switches object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHARVECTOR&
   Global Variables  :None
   Calling Syntax    :GetPropertyList()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CCommandSwitches::GetInteractivePropertyList()
{
	return m_cvInteractiveProperties;
}

/*------------------------------------------------------------------------
   Name				 :SetNamedParamListFlag
   Synopsis	         :This function sets m_bNamedParamList member variable.
   Type	             :Member Function
   Input parameter(s):None
   Output parameter(s):
			bFlag	 - Boolean value.
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetNamedParamListFlag(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetNamedParamListFlag(BOOL bFlag)
{
	m_bNamedParamList = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetNamedParamListFlag
   Synopsis	         :This function returns the the boolean value held by 
					  m_bNamedParamList.
   Type	             :Member Function
   Input parameter(s):None
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetNamedParamListFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetNamedParamListFlag()
{
	return m_bNamedParamList;
}

/*------------------------------------------------------------------------
   Name				 :ClearXSLTDetailsVector
   Synopsis	         :Clears or nullifies XSL Details vector.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :ClearXSLTDetailsVector()
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::ClearXSLTDetailsVector()
{
	m_xdvXSLTDetVec.clear();
}

/*------------------------------------------------------------------------
   Name				 :SetEverySwitchFlag
   Synopsis	         :This function sets m_bEverySwitch member variable.
   Type	             :Member Function
   Input parameter(s):None
   Output parameter(s):
			bFlag	 - Boolean value.
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetEverySwitchFlag(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetEverySwitchFlag(BOOL bFlag)
{
	m_bEverySwitch = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetEverySwitchFlag
   Synopsis	         :This function returns the the boolean value held by 
					  m_bEverySwitch.
   Type	             :Member Function
   Input parameter(s):None
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetEverySwitchFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetEverySwitchFlag()
{
	return m_bEverySwitch;
}

/*------------------------------------------------------------------------
   Name				 :SetOutputSwitchFlag
   Synopsis	         :This function sets m_bOutputSwitch member variable.
   Type	             :Member Function
   Input parameter(s):None
   Output parameter(s):
			bFlag	 - Boolean value.
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetOutputSwitchFlag(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetOutputSwitchFlag(BOOL bFlag)
{
	m_bOutputSwitch = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetOutputSwitchFlag
   Synopsis	         :This function returns the the boolean value held by 
					  m_bOutputSwitch.
   Type	             :Member Function
   Input parameter(s):None
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetOutputSwitchFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetOutputSwitchFlag()
{
	return m_bOutputSwitch;
}
/*------------------------------------------------------------------------
   Name				 :SetFormedQuery
   Synopsis	         :This function Assigns the parameter passed to 
                      m_bstrFormedQuery..
   Type	             :Member Function
   Input parameter   :
   bstrFormedQuery  -BSTR type,It is the query formed for the given command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetFormedQuery(bstrFormedQuery)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CCommandSwitches::SetFormedQuery(const BSTR bstrFormedQuery)
{
	BOOL bResult = TRUE;
	SAFEBSTRFREE(m_bstrFormedQuery);
	if (bstrFormedQuery!= NULL)
	{
		try
		{
			m_bstrFormedQuery = SysAllocString(bstrFormedQuery);
			if (m_bstrFormedQuery == NULL)
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
		catch(CHeap_Exception)
		{
			bResult = FALSE;
		}
	}
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :GetFormedQuery
   Synopsis	         :This function Returns query formed for the given 
					  command.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BSTR
   Global Variables  :None
   Calling Syntax    :GetFormedQuery()
   Notes             :None
------------------------------------------------------------------------*/
BSTR CCommandSwitches::GetFormedQuery()
{
	return m_bstrFormedQuery;
}

/*------------------------------------------------------------------------
   Name				 :GetSysPropFlag
   Synopsis	         :This function returns the status of the system 
					  properties flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetSysPropFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CCommandSwitches::GetSysPropFlag()
{
	return m_bSysProp;
}

/*------------------------------------------------------------------------
   Name				 :SetSysPropFlag
   Synopsis	         :This function sets the system properties flag, if 
					  the GET or LIST property list contains the system
					  property(s)
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetSysPropFlag(bSysProp)
   Notes             :None
------------------------------------------------------------------------*/
void	CCommandSwitches::SetSysPropFlag(BOOL bSysProp)
{
	m_bSysProp = bSysProp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\commandswitches.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CommandSwitches.h 
Project Name				: WMI Command Line
Author Name					: Ch.Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CommandSwitches
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 20th-March-2001
****************************************************************************/ 

// CommandSwitches.h : header file
//
/*-------------------------------------------------------------------
 Class Name			: CCommandSwitches
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for accessing and storing the command switches 
					  information, which will be used by Parsing, 
					  Execution and Format Engines depending upon the 
					  applicability.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/
#pragma once

/////////////////////////////////////////////////////////////////////////////
// CCommandSwitches
class CCommandSwitches
{
public:
// Construction
	CCommandSwitches();

// Destruction
	~CCommandSwitches();

// Restrict Assignment
   CCommandSwitches& operator=(CCommandSwitches& rCmdSwitches);

// Attributes
private:
	//command string
	_TCHAR				*m_pszCommandInput;

	//alias name
	_TCHAR				*m_pszAliasName;

	//alias description
	_TCHAR				*m_pszAliasDesc;

    //class path
	_TCHAR				*m_pszClassPath;

    //path expression
	_TCHAR				*m_pszPathExpr;

    //where expression
	_TCHAR				*m_pszWhereExpr;

    //verb name - standard|userdefined verb 
	_TCHAR				*m_pszVerb;

    //method name
	_TCHAR				*m_pszMethodName;

    //XSLT details vector.
	XSLTDETVECTOR		m_xdvXSLTDetVec;

    //alias target class
	_TCHAR				*m_pszAliasTarget;

    //XML stream 
	BSTR				m_bstrXML;

    //session success - flag.
	BOOL				m_bSuccess;

    //HRESULT 
	HRESULT				m_hResult;

    //friendly names|trasnlate tables - map
	BSTRMAP				m_bmAlsFrnNmsDesOrTrnsTblEntrs;

    //property(s) details - map
	PROPDETMAP			m_pdmPropDet;

    //method(s) details - map
	METHDETMAP			m_mdmMethDet;

    //input property(s) - vector
	CHARVECTOR			m_cvProperties;

	//PWhere param(s) - vector
	CHARVECTOR			m_cvPWhereParams;

	//Translate table entry(s) - vector
	CHARVECTOR			m_cvTrnsTablesList;

    //input method param(s) - map
	BSTRMAP				m_bmParameters;

    //verb interactive mode
	WMICLIINT			m_nInteractiveMode;

    ///EVERY interval value
	ULONG				m_ulInterval;

    ///tablename - TRANSLATE:<tablename> 
	_TCHAR				*m_pszTransTableName;

    //listformat - LISTFORMAT type
	_TCHAR				*m_pszListFormat;

	// Errata code
	UINT				m_uErrataCode;

	// Message code
	UINT				m_uInformationCode;
	
	// Credentials flag
	BOOL				m_bCredFlag;

	// parameterized string with '#' as place holder(s) for input value(s)  
	_TCHAR				*m_pszPWhereExpr;

	// COM error object
	_com_error			*m_pComError;

	// IWbemClassObject, to store output parameters of method execution.
	IWbemClassObject	*m_pIMethOutParam;

	// alias connection information
	// alias user name
	_TCHAR				*m_pszUser;

	// alias user password
	_TCHAR				*m_pszPassword;

	// alias node
	_TCHAR				*m_pszNode;

	// alias locale
	_TCHAR				*m_pszLocale;

	// alias namespace
	_TCHAR				*m_pszNamespace;

	// alias authority type.
	_TCHAR				*m_pszAuthority;

	// Type of the verb ( CLASSMETHOD/STDVERB/CMDLINE ).
	VERBTYPE			m_vtVerbType;

	// Verb derivation string
	_TCHAR				*m_pszVerbDerivation;

	// flag to check that WHERE is specified explicitly
	BOOL				m_bExplicitWhereExpr;

	ALSFMTDETMAP		m_afdAlsFmtDet;

	BOOL				m_bTranslateFirst;

	// /RESULTCLASS switch value of ASSOC verb
	_TCHAR				*m_pszResultClassName;
     
	// /RESULTROLE  switch value of ASSOC verb
	_TCHAR				*m_pszResultRoleName;

	// /ASSOCCLASS switch value of ASSOC verb
	_TCHAR				*m_pszAssocClassName;

	// count for /REPEAT:N
	ULONG				m_ulRepeatCount;

	// Flag for availibility of methods.
	BOOL				m_bMethAvail;

	// Flag for availibility of writable properties.
	BOOL				m_bWritePropsAvail;

	// Flag for availibility list formats.
	BOOL				m_bLISTFrmsAvail;

    //input property(s) - vector
	CHARVECTOR			m_cvInteractiveProperties;

	// Flag to specify Named Parameter List.
	BOOL				m_bNamedParamList;

	// Flag to check if every switch is specified.
	BOOL                m_bEverySwitch ;     

	// Flag to check if output switch is specified.
	BOOL                m_bOutputSwitch ;   
	
	//the query formed of the given command .
	BSTR				m_bstrFormedQuery;

	BOOL				m_bSysProp;

	// Operations
public:

	//Assigns the parameter passed to m_pszCommandInput
	BOOL	SetCommandInput(const _TCHAR* pszCommandInput);

    //Assigns the parameter passed to m_pszAliasName that represents 
    //Alias object.
	BOOL	SetAliasName(const _TCHAR* pszAliasName);

	// Sets the alias description
	BOOL	SetAliasDesc(const _TCHAR* pszAliasDesc);

	// Sets the alias credentials information
	BOOL	SetAliasUser(const _TCHAR* pszUserName);
	BOOL	SetAliasNode(const _TCHAR* pszNode);
	BOOL	SetAliasPassword(const _TCHAR* pszPassword);
	BOOL	SetAliasLocale(const _TCHAR* pszLocale);
	BOOL	SetAliasNamespace(const _TCHAR* pszNamespace);
	BOOL    SetAliasAuthorityPrinciple(const _TCHAR* pszAuthority);

    //Assigns the parameter passed to m_pszClassPath.
	BOOL	SetClassPath(const _TCHAR* pszClassPath);

    //Assigns the parameter passed to m_pszPathExpr.
	BOOL	SetPathExpression(const _TCHAR* pszPathExpr);

    //Assigns the parameter passed to m_pszWhereExpr
	BOOL	SetWhereExpression(const _TCHAR* pszWhereExpr);

    //Assigns the parameter passed to m_pszMathodName.
	BOOL	SetMethodName(const _TCHAR* pszMethodName);

    //Adds to vector held by m_xdvXSLDetVec.
	void	AddToXSLTDetailsVector(XSLTDET xdXSLTDet);

    //Assigns the parameter passed to m_pszVerbName.
	BOOL	SetVerbName(const _TCHAR* pszVerbName);

    //Assigns the parameter passed to m_pszSesionFilePath
	BOOL	SetSessionFilePath(const _TCHAR* pszSessionFilePath);

    //Assigns the parameter passed to m_bstrXML, is used to store XML file 
	//Name that contains result set.
	BOOL	SetXMLResultSet(const BSTR bstrXMLResultSet);

    //Assigns the parameter passed to m_pszAliasTarget, is used in Parsing
	//Engine to avail the alias object informations.
	BOOL	SetAliasTarget(const _TCHAR* pszAliasTarget);

    //Adds string that passed through parameter to m_bmParameters, which is 
    //a data member of type BSTRMAP
	BOOL	AddToPropertyList(_TCHAR* const pszProperty);

	BOOL	AddToTrnsTablesList(_TCHAR* const pszTableName);

    //Adds bstrKey and bstrValue passed as parameters to m_bmParameters,which 
    //is type of BSTRMAP data structure
	BOOL	AddToParameterMap(_bstr_t bstrKey, _bstr_t bstrValue);

    //Adds bstrKey and bstrValue passed as parameters to m_bmParameters,which 
    //is type of ALSFMTDETMAP data structure
	BOOL	AddToAliasFormatDetMap(_bstr_t bstrKey, BSTRVECTOR bvProps);

    //Adds bstrKey and bstrValue passed as parameters to 
	//m_bmAlsFrnNmsDesOrTrnsTblEntrs,
    //which is type of BSTRMAP
	BOOL	AddToAlsFrnNmsOrTrnsTblMap(_bstr_t bstrKey, _bstr_t bstrValue);

    //Adds bstrKey and mdMethDet passed as parameters to m_mdmMethDet,
	//which is type of METHDETMAP.
	BOOL	AddToMethDetMap(_bstr_t bstrKey, METHODDETAILS mdMethDet);

    //Adds bstrKey and pdPropDet passed as parameters to m_pdmPropDet,
	//which is type of PROPERTYDETALS
	BOOL	AddToPropDetMap(_bstr_t bstrKey, PROPERTYDETAILS pdPropDet);

    //Assigns the Boolean variable to m_bSuccess
	void	SetSuccessFlag(BOOL bSuccess);
	
    //Assigns the string variable to m_pszTransTableName.
	BOOL	SetTranslateTableName(const _TCHAR* pszTransTableName);

    //Assigns the integer value to m_nInterval 
  	BOOL	SetRetrievalInterval(const ULONG lInterval);

    //Assigns the parameter value to m_ListFormat
	BOOL	SetListFormat(const _TCHAR *pszListFormat);

    //Set|Reset the verb interactive mode
	void	SetInteractiveMode(WMICLIINT nInteractiveMode);

    //Stores the parameter in map array
	BOOL	AddToPWhereParamsList(_TCHAR* const pszParameter);

    //Assigns the value to m_uErrataCode
	void	SetErrataCode(const UINT uErrataCode);

	//Assigns the value to m_uInformationCode
	void	SetInformationCode(const UINT uInformationCode);

	// Assigns the string to m_pszPWhereExpr
	BOOL	SetPWhereExpr(const _TCHAR* pszPWhereExpr);

	// Assigns the parameter passed to m_pComError that consist of 
	// error info
	void	SetCOMError(_com_error& rComError);

	// Set m_pIMethExecOutParam.
	BOOL	SetMethExecOutParam(IWbemClassObject* pIMethOutParam);

	// Set m_vtVerbType to passed flag.
	void	SetVerbType( VERBTYPE vtVerbType);

	// Set m_pszVerbDerivation.
	BOOL	SetVerbDerivation( const _TCHAR* pszVerbDerivation );

	//Set the credential flag status
	void	SetCredentialsFlag(BOOL bCredFlag);

	// Set the explicit where flag
	void	SetExplicitWhereExprFlag(BOOL bWhere);

	//Assigns the string variable to m_pszResultClassName.
	BOOL	SetResultClassName(const _TCHAR* pszResultClassName);

	//Assigns the string variable to m_pszResultRoleName.
	BOOL	SetResultRoleName(const _TCHAR* pszResultRoleName);
     
	//Assigns the string variable to m_pszAssocClassName.
	BOOL	SetAssocClassName(const _TCHAR* pszAssocClassName);

	// Set repeat count.
	BOOL	SetRepeatCount(const ULONG lRepCount);

	// Set methods available.
	void	SetMethodsAvailable(BOOL bFlag);

	// Retruns the alias description
	_TCHAR*	GetAliasDesc();

    //Returns the alias name held by the object	
	_TCHAR*	GetAliasName();

    //Returns the class path held by the object
	_TCHAR*	GetClassPath();

	// Return the alias credentials information.
	_TCHAR*	GetAliasUser();
	_TCHAR*	GetAliasNode();
	_TCHAR*	GetAliasPassword();
	_TCHAR*	GetAliasLocale();
	_TCHAR* GetAliasNamespace();
	_TCHAR* GetAliasAuthorityPrinciple();

    //Returns the path expression held by the object
	_TCHAR*	GetPathExpression();

    //Returns the where expression held by the object
	_TCHAR*	GetWhereExpression();

    //Returns the method name held by the object
	_TCHAR*	GetMethodName();

    //Returns the XSLTDetVec held by the object.
	XSLTDETVECTOR&	GetXSLTDetailsVector();

    //Returns the verb name held by the object
	_TCHAR*	GetVerbName();

    //Returns the session file path held by the object
 	_TCHAR*	GetSessionFilePath();

    //Returns the alias target held by the object
	_TCHAR*	GetAliasTarget();

    //Returns the command input held by the object
	_TCHAR*	GetCommandInput();

    //Returns the XML result set held by the object.
	BSTR	GetXMLResultSet();

    //Returns the property held by the object.
	CHARVECTOR& GetPropertyList();

    //Returns the tables held by the object.
	CHARVECTOR& GetTrnsTablesList();

    //Returns the parameter map containing both key and value
	BSTRMAP&    GetParameterMap();

	//Returns the alias formats map
	ALSFMTDETMAP&	GetAliasFormatDetMap();

    //Returns the alias friendly names map held by the object
	BSTRMAP&	GetAlsFrnNmsOrTrnsTblMap();

    //Returns the method details map held by the object
	METHDETMAP&	GetMethDetMap();

    //Returns the alias property details map held by the object
	PROPDETMAP&	GetPropDetMap();

    //Returns the success flag held by the object
	BOOL	GetSuccessFlag();

    //Returns the value of m_ulInterval.
	ULONG	GetRetrievalInterval();

    //Returns the value of m_pszTransTableName.
 	_TCHAR*	GetTranslateTableName();

   //Returns the list format type m_ListFormat
	_TCHAR*	GetListFormat();

    //Returns the name of XSL file used for specifying format for dumping.
	_TCHAR*	GetDumpXSLFormat();

    //returns the verb interactive mode
	WMICLIINT	GetInteractiveMode();

    //Returns the PWhereParameters list
	CHARVECTOR& GetPWhereParamsList();

    //This function gets the class of Alias
	void	GetClassOfAliasTarget(_bstr_t& bstrClassName);

    //returns the error code
	UINT	GetErrataCode();

	//returns the information code
	UINT	GetInformationCode();

	// returns the PWhere expression - m_pszPWhereExpr
	_TCHAR*    GetPWhereExpr();

	// Get m_pIMethExecOutParam.
	IWbemClassObject* GetMethExecOutParam();

	// Get m_vtVerbType.
	VERBTYPE	GetVerbType();

	// Get m_pszVerbDerivation.
	_TCHAR*	GetVerbDerivation();

	// Returns the credential flag status
	BOOL	GetCredentialsFlagStatus();

	// Returns the explicit where flag status		
	BOOL	GetExplicitWhereExprFlag();

	// Get m_uRepeatCount count.
	ULONG	GetRepeatCount();

	// This function returns the COMError object
	_com_error* CCommandSwitches::GetCOMError();

	// Update the parameter value
	BOOL	UpdateParameterValue(_bstr_t bstrKey, _bstr_t bstrValue);

	// Free the COM error
	void	FreeCOMError();

	// Clear cvPropertyList.
	void	ClearPropertyList();

	// Initiliaze the necessary member variables
	void	Initialize();

    // Free the member variables
	void	Uninitialize();

	// This function sets the the order of the format and 
	// translate switch flag
	void SetTranslateFirstFlag(BOOL bTranslateFirst);

	// This function returns the order of the format and 
	// translate switch flag
	BOOL GetTranslateFirstFlag();

	//Returns the value of m_pszResultClassName.
	_TCHAR*	GetResultClassName();

	//Returns the value of  m_pszResultRoleName.
	_TCHAR*	GetResultRoleName();
     
	//Returns the value of  m_pszAssocClassName.
	_TCHAR*	GetAssocClassName();

	// Get methods available.
	BOOL	GetMethodsAvailable();

	// Set writable properties available flag.
	void	SetWriteablePropsAvailable(BOOL bFlag);

	// Get writable properties available flag.
	BOOL	GetWriteablePropsAvailable();

	// Set LIST Formats available flag.
	void	SetLISTFormatsAvailable(BOOL bFlag);

	// Get LIST Formats Available flag.
	BOOL	GetLISTFormatsAvailable();

	BOOL AddToInteractivePropertyList(_TCHAR* const pszProperty);

	CHARVECTOR& GetInteractivePropertyList();

	// Set m_bNamedParamList flag.
	void	SetNamedParamListFlag(BOOL bFlag);

	// Get m_bNamedParamList flag.
	BOOL	GetNamedParamListFlag();

	// Clear or nullify XSL Details vector.
	void	ClearXSLTDetailsVector();

	//every 
	// Set m_bEverySwitch flag.
	void	SetEverySwitchFlag(BOOL bFlag);

	// Get m_bEverySwitch  flag.
	BOOL	GetEverySwitchFlag();

	// Set m_bOutputSwitch flag.
	void	SetOutputSwitchFlag(BOOL bFlag);

	// Get m_bOutputSwitch  flag.
	BOOL	GetOutputSwitchFlag();

 	//Sets the m_bstrFormedQuery
	BOOL	SetFormedQuery(const BSTR bstrFormedQuery);
	
	//Returns the query formed for the given command.
	BSTR	GetFormedQuery();

	// Get the status of sytem properties flag
	BOOL	GetSysPropFlag();

	// Sets the status of system properties flag
	void	SetSysPropFlag(BOOL bSysProp);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\execengine.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ExecEngine.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality of    
							  Execution Engine. Obtains the needed information
							  from CGlobalSwitches and CCommandSwitches of 
							  CParsedInfo and executes needed WMI operations.
							  The result is sent to Format Engine via 
							  CGlobalSwitches and CCommandSwicthes 
							  of CParsedInfo.
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 20th-March-2001
****************************************************************************/ 

// include files
#include "Precomp.h"
#include "GlobalSwitches.h"
#include "CommandSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "ErrorInfo.h"
#include "WmiCliXMLLog.h"
#include "FormatEngine.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "WmiCmdLn.h"

/*------------------------------------------------------------------------
   Name				  :CExecEngine
   Synopsis	          :Constructor, This function initializes the necessary
					  member variables. 	
   Type	              :Constructor 
   Input Parameter(s) :None
   Output Parameter(s):None
   Return Type		  :None
   Global Variables   :None
   Calling Syntax     :None
   Notes              :None
------------------------------------------------------------------------*/
CExecEngine::CExecEngine()
{
	m_pITextSrc		= NULL;
	m_pIWbemLocator = NULL;
	m_pITargetNS	= NULL;
	m_pIContext		= NULL;
	m_bTrace		= FALSE;
	m_bNoAssoc		= FALSE;
}

/*------------------------------------------------------------------------
   Name				  :~CExecEngine
   Synopsis	          :Destructor, This function call Uninitialize() which 
					  frees memory held by the object. 	
   Type	              :Destructor
   Input Parameter(s) :None
   Output Parameter(s):None
   Return Type        :None
   Global Variables   :None
   Calling Syntax     :None
   Notes              :None
------------------------------------------------------------------------*/
CExecEngine::~CExecEngine()
{
	SAFEIRELEASE(m_pITextSrc);
	SAFEIRELEASE(m_pIContext);
	SAFEIRELEASE(m_pIWbemLocator);
	Uninitialize();
}

/*------------------------------------------------------------------------
   Name				  :Uninitialize
   Synopsis	          :This function uninitializes the member variables. 
   Type	              :Member Function
   Input Parameter(s):
			bFinal	- boolean value which when set indicates that the 
					  program
   Output Parameter(s):None
   Return Type        :void 
   Global Variables   :None
   Calling Syntax     :Uninitialize()
   Notes              :None
------------------------------------------------------------------------*/
void CExecEngine::Uninitialize(BOOL bFinal)
{
	SAFEIRELEASE(m_pITargetNS);
	m_bTrace		= FALSE;
	m_eloErrLogOpt	= NO_LOGGING;
	m_bNoAssoc		= FALSE;
	if (bFinal)
	{
		SAFEIRELEASE(m_pITextSrc);
		SAFEIRELEASE(m_pIContext);
		SAFEIRELEASE(m_pIWbemLocator);
	}
}

/*------------------------------------------------------------------------
   Name				 :SetLocatorObject
   Synopsis	         :Sets the locator object passed via parameter to member 
					  of the class.
   Type	             :Member Function
   Input Parameter(s):
	   pILocator - Pointer to IWbemLocator
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetLocatorObject(pILocator)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::SetLocatorObject(IWbemLocator* pILocator)
{
	static BOOL bFirst = TRUE;
	BOOL bRet = TRUE;
	if (bFirst)
	{
		if (pILocator != NULL)
		{
			SAFEIRELEASE(m_pIWbemLocator);
			m_pIWbemLocator = pILocator;
			m_pIWbemLocator->AddRef();
		}
		else
			bRet = FALSE;
		bFirst = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ExecuteCommand
   Synopsis	         :Executes the command referring to information 
					  available with the CParsedInfo object.
					  Stores the results in the CParsedInfo object.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ExecuteCommand(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ExecuteCommand(CParsedInfo& rParsedInfo)
{
	BOOL			bRet			= TRUE;
	HRESULT			hr				= S_OK;
	_TCHAR			*pszVerb		= NULL;
	BOOL			bContinue		= TRUE;
	DWORD			dwThreadId		= GetCurrentThreadId();
	try
	{

		// Obtain the TRACE flag
		m_bTrace = rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

		// Obtain the Logging mode
		m_eloErrLogOpt = rParsedInfo.GetErrorLogObject().GetErrLogOption();

		// Enable|Disable the privileges
		hr = ModifyPrivileges(rParsedInfo.GetGlblSwitchesObject().
												GetPrivileges());
		if ( m_eloErrLogOpt )
		{
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
				_T("ModifyPrivileges(-)"), dwThreadId,	rParsedInfo, FALSE);
		}
		ONFAILTHROWERROR(hr);
		

		// Obtian the verb name
		pszVerb = rParsedInfo.GetCmdSwitchesObject().GetVerbName();

		if (pszVerb != NULL)
		{
			// If GET | LIST verb is specified.
			if (CompareTokens(pszVerb, CLI_TOKEN_GET) || 
				CompareTokens(pszVerb, CLI_TOKEN_LIST))
			{
				bRet = ProcessSHOWInfo(rParsedInfo);
			}
			// If SET verb is specified.
			else if (CompareTokens(pszVerb, CLI_TOKEN_SET))
			{
				bRet = ProcessSETVerb(rParsedInfo);
			}
			// If CALL verb is specified.
			else if (CompareTokens(pszVerb, CLI_TOKEN_CALL))
			{
				bRet = ProcessCALLVerb(rParsedInfo);
			}
			// If ASSOC verb is specified.
			else if (CompareTokens(pszVerb, CLI_TOKEN_ASSOC))
			{
				bRet = ProcessASSOCVerb(rParsedInfo);
			}
			// If CREATE verb is specified.
			else if (CompareTokens(pszVerb, CLI_TOKEN_CREATE))
			{
				bRet = ProcessCREATEVerb(rParsedInfo);
			}
			// If DELETE verb is specified.
			else if (CompareTokens(pszVerb, CLI_TOKEN_DELETE))
			{
				bRet = ProcessDELETEVerb(rParsedInfo);
			}
			// If user defined verb is specified.
			else
				bRet = ProcessCALLVerb(rParsedInfo);
		} 
		// If no verb is specified, (default behavior is assumed to be that of
		// GET i.e a command like 'w class Win32_Process' go ahead with 
		// displaying the instance information.
		else 
		{
			if (rParsedInfo.GetCmdSwitchesObject().
								SetVerbName(_T("GET")))
			{
				bRet = ProcessSHOWInfo(rParsedInfo);
			}
			else
				bRet = FALSE;
		}
	}
	catch(_com_error& e)
	{
		// To check unhandled exceptions thrown by _bstr_t objects etc..
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ObtainXMLResultSet
   Synopsis	         :Executes query and obtain the result in XML file format. 
					  Refers data in the CCommnadSwicthes object of 
					  CParsedInfo object. 
   Type	             :Member Function
   Input Parameter(s):
		bstrQuery    - WQL query 
		rParsedInfo  - reference to CParsedInfo class object
		bstrXML		 - reference to XML result set obtained
		bSysProp	 - boolean flag indicating the presence of system 
					   properties.
		bNotAssoc	 - boolean flag indicating whether the query cotains
						ASSOCIATORS OF {xxxx} (or) SELECT * FROM xxx form.
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :ObtainXMLResultSet(bstrQuery, rParsedInfo, bstrXML,
						bSysProp, bNotAssoc);
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CExecEngine::ObtainXMLResultSet(BSTR bstrQuery,
									    CParsedInfo& rParsedInfo,
										_bstr_t& bstrXML,
										BOOL bSysProp,
										BOOL bNotAssoc)
{
	IWbemClassObject		*pIObject			= NULL;
	HRESULT					hr					= S_OK;
	IEnumWbemClassObject	*pIEnum				= NULL;
	ULONG					ulReturned			= 0;
	BSTR					bstrInstXML			= NULL;
	BOOL					bInstances			= FALSE;
	CHString				chsMsg;
	DWORD					dwThreadId			= GetCurrentThreadId();
	VARIANT					vSystem;
	
	try
	{
		VariantInit(&vSystem);
		if ( g_wmiCmd.GetBreakEvent() == FALSE )
		{
			// Add the <CIM> or <ASSOC.OBJECTARRAY> to the beginning of the 
			// XML result. This is to facilitate storing of mutiple object 
			// instances information.
			bstrXML		=  (bNotAssoc) ? MULTINODE_XMLSTARTTAG : 
							MULTINODE_XMLASSOCSTAG1;

			// Create the IWbemContext object, used for suppressing
			// the system properties.
			if (m_pIContext == NULL)
			{
				hr = CreateContext(rParsedInfo);
				if ( m_eloErrLogOpt )
				{
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						_T("CreateContext(rParsedInfo)"), dwThreadId, 
						rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);
			}

			// Execute the WQL query
			// WBEM_FLAG_FORWARD_ONLY flag Increases the speed of execution
			// WBEM_FLAG_RETURN_IMMEDIATELY flag makes semisynchronous call
			// Setting these flags in combination saves time, space, and
			// improves responsiveness.enumerators can be polled for the
			// results of the call.
			hr = m_pITargetNS->ExecQuery(_bstr_t(L"WQL"), bstrQuery, 
										WBEM_FLAG_FORWARD_ONLY |
										WBEM_FLAG_RETURN_IMMEDIATELY, 
										NULL, &pIEnum); 
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\", L\"%s\", "
							L"0, NULL, -)", (LPWSTR) bstrQuery);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			// If no system properties are specified adjust the context to 
			// filter out the system properties.
			vSystem.vt		= VT_BOOL;
			
			// Filterout the system properties.
			if (!bSysProp)
				vSystem.boolVal = VARIANT_TRUE;
			// Don't filter the system properties.
			else
				vSystem.boolVal = VARIANT_FALSE;

			hr = m_pIContext->SetValue(_bstr_t(EXCLUDESYSPROP), 0, &vSystem);
			if (m_bTrace || m_eloErrLogOpt)
			{
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
					 _T("IWbemContext::SetValue(L\"ExcludeSystemProperties\","
					 L"0, -)"), dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			VARIANTCLEAR(vSystem);

			// Set the interface level security for the IEnumWbemClass object.
			hr = SetSecurity(pIEnum, 
					 rParsedInfo.GetAuthorityPrinciple(),
					 rParsedInfo.GetNode(),
					 rParsedInfo.GetUser(),
					 rParsedInfo.GetPassword(),
					 rParsedInfo.GetGlblSwitchesObject().
							GetAuthenticationLevel(),
					 rParsedInfo.GetGlblSwitchesObject().
							GetImpersonationLevel());
			if (m_bTrace || m_eloErrLogOpt)
			{
				_TCHAR* pszAuthority = rParsedInfo.GetAuthorityPrinciple();

				if( pszAuthority != NULL &&
					_tcslen(pszAuthority) > 9 &&
					_tcsnicmp(pszAuthority, _T("KERBEROS:"), 9) == 0)
				{

					BSTR	bstrPrincipalName = ::SysAllocString(&pszAuthority[9]);

					chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_GSS_KERBEROS,"
							L"RPC_C_AUTHZ_NONE, %s, %d,   %d, -, EOAC_NONE)",
							(LPWSTR)bstrPrincipalName,	
							rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
							rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());

					SAFEBSTRFREE(bstrPrincipalName);
				}
				else
				{
					chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT,"
							L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, EOAC_NONE)",
							rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
							rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());
				}
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			// Loop through the available instances 
			hr = pIEnum->Next(WBEM_INFINITE, 1, &pIObject, &ulReturned);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IEnumWbemClassObject->Next"
					L"(WBEM_INFINITE, 1, -, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
					dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			while(ulReturned == 1)
			{
				// Set the instances flag to TRUE
				bInstances = TRUE;

				// Call the IWbemObjectTextSrc::GetText method, with 
				// IWbemClassObject as one of the arguments.
				hr = m_pITextSrc->GetText(0, pIObject, 
						WMI_OBJ_TEXT_CIM_DTD_2_0, m_pIContext, &bstrInstXML);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemObjectTextSrc::GetText(0, -, "
							L"WMI_OBJECT_TEXT_CIM_DTD_2_0, -, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
						(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);

				// Associators should be handled separately
				if (bNotAssoc == FALSE)
				{
					// Append the XML node to the XML nodes stream
					bstrXML = bstrXML + _bstr_t(MULTINODE_XMLASSOCSTAG2) + 
						 + bstrInstXML + _bstr_t(MULTINODE_XMLASSOCETAG2);
				}
				else
				{
					// Append the XML node to the XML nodes stream
					bstrXML +=  bstrInstXML;
				}

				// Release the memory allocated for bstrInstXML
				SAFEBSTRFREE(bstrInstXML);

				SAFEIRELEASE(pIObject);

				// if break event occurs then terminate the session
				if ( g_wmiCmd.GetBreakEvent() == TRUE )
					break;

				// Move to next instance in the enumeration.
				hr = pIEnum->Next(WBEM_INFINITE, 1, &pIObject, &ulReturned);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(
						L"IEnumWbemClassObject->Next(WBEM_INFINITE, 1, -, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
						dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);
			}

			// If instances are available
			if (bInstances)
			{
				// Add the </CIM> or </ASSOC.OBJECTARRAY> at the end.
				bstrXML += (bNotAssoc) ? MULTINODE_XMLENDTAG : 
							MULTINODE_XMLASSOCETAG1;

				// if no break event occured then only set the 
				// xml result set
				if ( g_wmiCmd.GetBreakEvent() == FALSE )
				{
					if (bNotAssoc)
					{
						// Store the XML result set
						rParsedInfo.GetCmdSwitchesObject().
								SetXMLResultSet(bstrXML);
						bstrXML = L"";
					}
				}
			}
			// no instances
			else 
			{
				bstrXML = L"<ERROR>";
				_bstr_t bstrMsg;
				WMIFormatMessage((bNotAssoc) ? 
								IDS_I_NO_INSTANCES : IDS_I_NO_ASSOCIATIONS,
								0, bstrMsg, NULL);

				if (bNotAssoc)
				{
					DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, TRUE, TRUE);
				}
				else
				{
					m_bNoAssoc = TRUE;
				}
				CHString sTemp;
				sTemp.Format(_T("<DESCRIPTION>%s</DESCRIPTION>"),
							(LPWSTR) bstrMsg);
				
				bstrXML += _bstr_t(sTemp);
				bstrXML += L"</ERROR>";

				if (bNotAssoc)
				{
					// Store the XML result set
					rParsedInfo.GetCmdSwitchesObject().
							SetXMLResultSet(bstrXML);
					bstrXML = L"";
				}
			}
			SAFEIRELEASE(pIEnum);
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIObject);
		SAFEIRELEASE(pIEnum);
		SAFEBSTRFREE(bstrInstXML);	
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	//trap for CHeap_Exception
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIObject);
		SAFEIRELEASE(pIEnum);
		SAFEBSTRFREE(bstrInstXML);	
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :ExecWMIMethod
   Synopsis	         :Executes a WMI method referring to the information
					  available with CParsedInfo object.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ExecWMIMethod(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ExecWMIMethod(CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	IWbemClassObject		*pIClassObj			= NULL,
							*pIInSign			= NULL, 
							*pIOutSign			= NULL,
							*pIInParam			= NULL;
	SAFEARRAY				*psaNames			= NULL;
	BSTR					bstrInParam			= NULL;
	BOOL					bContinue			= TRUE,
							bRet				= TRUE,
							bMethodDtls			= FALSE;
	CHString				chsMsg;
	DWORD					dwThreadId			= GetCurrentThreadId();
	CHARVECTOR::iterator	cviUnnamedValue		= NULL;
	BSTRMAP::iterator		bmiNamedValue		= NULL;
	VARIANT					varPut, 
							varGet, 
							varTemp;
	PROPDETMAP				pdmPropDetMap;
	PROPDETMAP::iterator	itrPropDetMap;
	VariantInit(&varPut);
	VariantInit(&varGet);
	VariantInit(&varTemp);

	METHDETMAP				mdmMethDet;
	METHDETMAP::iterator	mdmIterator		= NULL;
	mdmMethDet = rParsedInfo.GetCmdSwitchesObject().GetMethDetMap();

	try
	{
		_bstr_t					bstrClassName("");
		// Obtain the parameter details.
		if (!mdmMethDet.empty())
		{
			mdmIterator = mdmMethDet.begin();
			pdmPropDetMap = (*mdmIterator).second.Params;
			bMethodDtls = TRUE;
		}

		// Obtain the WMI class name 
		
		// If <alias> is not specified
		if (rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL)
		{
			bstrClassName = _bstr_t(rParsedInfo.GetCmdSwitchesObject().
							GetClassPath());
		}
		// If <alias> specified
		else
		{
			rParsedInfo.GetCmdSwitchesObject().
							GetClassOfAliasTarget(bstrClassName);
		}

		// Obtain the object schema.
		hr = m_pITargetNS->GetObject(bstrClassName, 
							WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, 
							&pIClassObj, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)", 
					(LPWSTR) bstrClassName);		
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Get method information
		hr = pIClassObj->GetMethod(_bstr_t(rParsedInfo.GetCmdSwitchesObject()
				.GetMethodName()), 0, &pIInSign, &pIOutSign); 

		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::GetMethod(L\"%s\", 0, -, -)", 
					rParsedInfo.GetCmdSwitchesObject().GetMethodName() ?
					rParsedInfo.GetCmdSwitchesObject().GetMethodName() 
					: L"<null>");		
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		if ( pIInSign != NULL )
		{
			// Spawn object instance.
			hr = pIInSign->SpawnInstance(0, &pIInParam);
			if ( m_eloErrLogOpt )
			{
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
					_T("IWbemClassObject::SpawnInstance(0, -)"), dwThreadId, 
					rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			CHARVECTOR cvInParams = 
				rParsedInfo.GetCmdSwitchesObject().GetPropertyList();
			BSTRMAP bmParameterMap =
				rParsedInfo.GetCmdSwitchesObject().GetParameterMap();

			// If parameter list is TRUE
			if (!cvInParams.empty() || !bmParameterMap.empty())
			{
				// Get the input paramters for this method from the input 
				// signature object.
				hr = pIInSign->GetNames(NULL, 
								WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY, 
								NULL, 
								&psaNames);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::GetNames(NULL, "
							L"WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY, "
							L"NULL, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, m_bTrace);
				}	
				ONFAILTHROWERROR(hr);

				LONG lLower = 0, lUpper = 0, lIndex = 0; 
				hr = SafeArrayGetLBound(psaNames, 1, &lLower);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetLBound(-, 1, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				hr = SafeArrayGetUBound(psaNames, 1, &lUpper);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetUBound(-, 1, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				// Puting param values depend on named param list or not.
				BOOL bNamedParamList = rParsedInfo.GetCmdSwitchesObject().
													  GetNamedParamListFlag();

				// Make necessary initializations.
				if ( bNamedParamList == FALSE)
					cviUnnamedValue = cvInParams.begin();
				lIndex = lLower;

				// Associate the parameter values specified to the input 
				// parameters in the order available.
				while(TRUE)
				{
					// Breaking conditions.
					if ( lIndex > lUpper )
						break;
					if ( bNamedParamList == FALSE &&
						 cviUnnamedValue == cvInParams.end())
						 break;

					hr = SafeArrayGetElement(psaNames, &lIndex, &bstrInParam);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					// Obtain the property details
					PROPERTYDETAILS pdPropDet;
					GetPropertyAttributes(pIInParam, bstrInParam, 
											pdPropDet, m_bTrace);

					_TCHAR* pszValue = NULL;
					if ( bNamedParamList == TRUE )
					{
						// If in parameter not found in named parameter map.
						if (!Find(bmParameterMap, bstrInParam, bmiNamedValue)) 
						{
							// If not found in alias verb parameters. 
							if ( !Find(pdmPropDetMap, bstrInParam, 
									itrPropDetMap) )
							{
								lIndex++;
								SAFEBSTRFREE(bstrInParam);
								continue;
							}
							else // If found in alias verb parameters.
							{
								// Value should be taken from Default of alias
								// verb parameters.
								if (!((*itrPropDetMap).second.Default))
								{
									lIndex++;
									SAFEBSTRFREE(bstrInParam);
									continue;
								}
								else
									pszValue = (*itrPropDetMap).second.Default;
							}
						}
						else
							pszValue = (*bmiNamedValue).second;
					}
					else
						pszValue = *cviUnnamedValue;

					if (rParsedInfo.GetCmdSwitchesObject().
								GetAliasName() == NULL)
					{
						// Check the parameter value supplied against
						// the qualifier information for the parameter.
						bRet = CheckQualifierInfo(rParsedInfo, pIInSign, 
										bstrInParam, pszValue);
					}
					else
					{
						// If method and parameter information is available
						if (bMethodDtls && !pdmPropDetMap.empty())
						{
							bRet = CheckAliasQualifierInfo(rParsedInfo,
									bstrInParam, pszValue, pdmPropDetMap);
						}
					}

					// The parameter value does not fit into the qualifier
					// allowed values.
					if (!bRet)
					{
						bContinue = FALSE;
						break;
					}

			        if(!IsArrayType(pIInParam, bstrInParam))
					{
						VariantInit(&varTemp);
						varTemp.vt = VT_BSTR;
						varTemp.bstrVal = SysAllocString(pszValue);

						if (varTemp.bstrVal == NULL)
						{
							//Reset the variant, it will be cleaned up by the catch...
							VariantInit(&varTemp);
							throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
						}

						VariantInit(&varPut);
						if(_tcslen(pszValue) > 0){
						    hr = ConvertCIMTYPEToVarType(varPut, varTemp,
												 (_TCHAR*)pdPropDet.Type);
						} else {
							hr = VariantChangeType(&varPut, &varTemp, 0, VT_NULL);
						}

						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"VariantChangeType(-, -, 0, -)"); 
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
								(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);
					}
					else
					{
						BSTRVECTOR vArrayValues;
						RemoveParanthesis(pszValue);
						GetArrayFromToken(pszValue, vArrayValues);
						hr = CheckForArray( pIInParam, bstrInParam,  
											varPut, vArrayValues, rParsedInfo);
						ONFAILTHROWERROR(hr);
					}

                    hr = pIInParam->Put(bstrInParam, 0, &varPut, 0);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Put(L\"%s\", 0,"
								L"-, 0)", (LPWSTR) bstrInParam); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);

					VARIANTCLEAR(varPut);
					VARIANTCLEAR(varGet);
					VARIANTCLEAR(varTemp);
					SAFEBSTRFREE(bstrInParam);

					// Looping statements.
					
					if ( bNamedParamList == FALSE )
						cviUnnamedValue++;
					lIndex++;
				}
				// Free the memory 
				SAFEADESTROY(psaNames);

				if (bContinue)
				{
					// If insufficient parameters are specified.
					if ( bNamedParamList == FALSE  &&
						 cviUnnamedValue != cvInParams.end() )
					{
						bContinue = FALSE;
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												IDS_E_INVALID_NO_OF_PARAMS);
						bRet = FALSE;
					}
				}
			}
		}
		else // No input parameters are available for this function.
		{
			// If unnamed parameters are specified.
			if (!rParsedInfo.GetCmdSwitchesObject().GetPropertyList().empty())
			{
				bContinue = FALSE;
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											   IDS_E_METHOD_HAS_NO_IN_PARAMS);
				bRet = FALSE;
			}
		}

		SAFEIRELEASE(pIInSign);
		SAFEIRELEASE(pIOutSign);
       	SAFEIRELEASE(pIClassObj);
		
		if (bContinue)
		{
			hr = FormQueryAndExecuteMethodOrUtility(rParsedInfo, pIInParam);
			ONFAILTHROWERROR(hr);
		}
	}
	catch(_com_error& e)
	{
		// Free the interface pointers and memory allocated.
		SAFEIRELEASE(pIClassObj);
		SAFEIRELEASE(pIInSign);
		SAFEIRELEASE(pIOutSign);
		SAFEIRELEASE(pIInParam);
		SAFEADESTROY(psaNames);
		SAFEBSTRFREE(bstrInParam);
		VARIANTCLEAR(varPut);
		VARIANTCLEAR(varGet);
		VARIANTCLEAR(varTemp);

		// Store the COM error object and set the return value to FALSE
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIClassObj);
		SAFEIRELEASE(pIInSign);
		SAFEIRELEASE(pIOutSign);
		SAFEIRELEASE(pIInParam);
		SAFEADESTROY(psaNames);
		SAFEBSTRFREE(bstrInParam);
		VARIANTCLEAR(varPut);
		VARIANTCLEAR(varGet);
		VARIANTCLEAR(varTemp);
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :CheckForArray
   Synopsis	         :Check for the parameter of array type. If it is of 
                      array type then creates a safearray and fills the 
                      values passed in it.  
   Type	             :Member Function
   Input Parameter(s):
		pIObj	     - pointer to IWbemClassObject object
		bstrProp     - property name
		varDest		 - VARIANT Destination
		vArrayValues - Input elements in Array for Array parameter
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s): None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CheckForArray( pIInParam, bstrInParam,  
                                     varPut, varTemp, rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CExecEngine::CheckForArray(IWbemClassObject* pIObj, 
							    BSTR bstrProp,  VARIANT& varDest, 
                                BSTRVECTOR& vArrayValues,CParsedInfo& rParsedInfo)
{
	HRESULT				hr			= S_OK;
	IWbemQualifierSet*	pIQualSet	= NULL;
	VARIANT				vtType, vtTypeProp, vtTemp, varSrc;
    CIMTYPE             ctCimType;
	CHString			chsMsg;
	DWORD				dwThreadId	= GetCurrentThreadId();
    SAFEARRAY*          pSa         = NULL;

    VariantInit(&vtType);
	VariantInit(&vtTypeProp);
	VariantInit(&vtTemp);
	VariantInit(&varSrc);
	try
	{
		// Obtain the property qualifier set for the property
   		hr = pIObj->GetPropertyQualifierSet(bstrProp, &pIQualSet);
		if ( pIQualSet != NULL )
		{
			// Obtain the CIM type of the property
			hr = pIQualSet->Get(_bstr_t(L"CIMTYPE"), 0L, &vtType, NULL);
			if (SUCCEEDED(hr))
			{
				if ( vtType.vt == VT_BSTR )
                {
                    // Obtain the CIM type of the property
		            hr = pIObj->Get(bstrProp, 0L, &vtTypeProp, &ctCimType, NULL);
			        if (SUCCEEDED(hr))
                    {
                        if ( ctCimType & VT_ARRAY )
                        {
							WMICLIINT nSize = vArrayValues.size();
                            SAFEARRAYBOUND pSab[1];
                            pSab[0].lLbound = 0;
                            pSab[0].cElements = nSize;
							VARTYPE vt = ReturnVarType(vtType.bstrVal);
							if(vt != VT_NULL && vt != VT_BYREF && vt != VT_EMPTY)
                            {
								pSa = SafeArrayCreate(vt, 1, pSab);
							}

                            if(pSa != NULL)
                            {
								BOOL bError = FALSE;
								for(WMICLIINT i = 0; i < nSize; i++)
								{
									VariantInit(&varSrc);
									VariantInit(&vtTemp);
									varSrc.vt = VT_BSTR;
									varSrc.bstrVal = SysAllocString(vArrayValues[i]);

									if (varSrc.bstrVal == NULL)
									{
										//Reset the variant, it will be cleaned up by the catch...
										VariantInit(&varSrc);
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}

									hr = ConvertCIMTYPEToVarType ( vtTemp, varSrc, vtType.bstrVal );
									if ( m_eloErrLogOpt )
									{
										chsMsg.Format(L"VariantChangeType(-, -, 0, -)"); 
										WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												(LPCWSTR)chsMsg, dwThreadId, 
												rParsedInfo, FALSE);
									}
									ONFAILTHROWERROR(hr);

									long lIndex[] = {i};
									if ( V_VT ( & vtTemp ) == VT_NULL )
									{
										hr = SafeArrayPutElement(pSa, lIndex, NULL);						        
									}
									else
									{
										VARTYPE vt = ReturnVarType(vtType.bstrVal);
										if(vt == VT_BSTR )
											hr = SafeArrayPutElement(pSa, lIndex, 
																	 vtTemp.bstrVal);						        
										else if(vt == VT_I2 )
											hr = SafeArrayPutElement(pSa, lIndex, 
																	 &vtTemp.iVal);
										else if(vt == VT_I4 )
											hr = SafeArrayPutElement(pSa, lIndex, 
																	 &vtTemp.lVal);
										else if(vt == VT_R4 )
											hr = SafeArrayPutElement(pSa, lIndex, 
																	 &vtTemp.fltVal);
										else if(vt == VT_R8 )
											hr = SafeArrayPutElement(pSa, lIndex, 
																	 &vtTemp.dblVal);
										else if(vt == VT_BOOL )
											hr = SafeArrayPutElement(pSa, lIndex, 
																	 &vtTemp.boolVal);
										else if(vt == VT_DISPATCH )
											hr = SafeArrayPutElement(pSa, lIndex, 
																	 vtTemp.pdispVal);
										else if(vt == VT_INT )
											hr = SafeArrayPutElement(pSa, lIndex, 
																	 &vtTemp.intVal);
										else if(vt == VT_UI1 )
											hr = SafeArrayPutElement(pSa, lIndex, 
																	 &vtTemp.bVal);
										else if(vt == VT_DATE )
											hr = SafeArrayPutElement(pSa, lIndex, 
																	 &vtTemp.date);
										else 
										{
											bError = TRUE;
										}
									}

									VARIANTCLEAR(vtTemp);
	                                VARIANTCLEAR(varSrc);
									if(!bError)
									{
										if ( m_eloErrLogOpt )
										{
											chsMsg.Format(L"SafeArrayPutElement(-, -, -)"); 
											WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
												(LPCWSTR)chsMsg, dwThreadId, 
												rParsedInfo, FALSE);
										}
										ONFAILTHROWERROR(hr);
									}
									else
									{
										SAFEADESTROY(pSa);
										break;
									}
								}
                                
								if(!bError)
                                {
									varDest.parray = pSa;
                                    varDest.vt = vt | VT_ARRAY;
                                }
                            }
                        }
			            VARIANTCLEAR(vtTypeProp);
                    }
                }
                hr = S_OK;
			    VARIANTCLEAR(vtType);
            }
			SAFEIRELEASE(pIQualSet);
        }
    }
	catch(_com_error& e)
	{
		VARIANTCLEAR(vtType);
		VARIANTCLEAR(vtTemp);
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(vtTypeProp);
		SAFEIRELEASE(pIQualSet);
        SAFEADESTROY(pSa);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(vtType);
		VARIANTCLEAR(vtTemp);
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(vtTypeProp);
		SAFEIRELEASE(pIQualSet);
        SAFEADESTROY(pSa);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :IsArrayType
   Synopsis	         :Check for array type 
   Type	             :Member Function
   Input Parameter(s):
		pIObj	     - pointer to IWbemClassObject object
		bstrProp     - property name
   Output Parameter(s): None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsArrayType(pIInParam, bstrInParam)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::IsArrayType(	IWbemClassObject* pIObj, 
								BSTR bstrProp)
{
	HRESULT				hr			= S_OK;
	IWbemQualifierSet*	pIQualSet	= NULL;
	VARIANT				vtType, vtTypeProp;
    CIMTYPE             ctCimType;
	BOOL				bRet = FALSE;

    VariantInit(&vtType);
	VariantInit(&vtTypeProp);
	try
	{
		// Obtain the property qualifier set for the property
   		hr = pIObj->GetPropertyQualifierSet(bstrProp, &pIQualSet);
		if ( pIQualSet != NULL )
		{
			// Obtain the CIM type of the property
			hr = pIQualSet->Get(_bstr_t(L"CIMTYPE"), 0L, &vtType, NULL);
			if (SUCCEEDED(hr))
			{
				if ( vtType.vt == VT_BSTR )
                {
                    // Obtain the CIM type of the property
		            hr = pIObj->Get(bstrProp, 0L, &vtTypeProp, &ctCimType, NULL);
			        if (SUCCEEDED(hr))
                    {
                        if ( ctCimType & VT_ARRAY )
                        {
							bRet = TRUE;
						}
						VARIANTCLEAR(vtTypeProp);
					}
				}
				VARIANTCLEAR(vtType);
			}
			SAFEIRELEASE(pIQualSet);
		}
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(vtType);
        VARIANTCLEAR(vtTypeProp);
		SAFEIRELEASE(pIQualSet);
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :GetArrayFromToken
   Synopsis	         :Separates comma delimited string and fill the values 
						in an array
   Type	             :Member Function
   Input Parameter(s):
		pszValue     - Comma separated array elements
   Output Parameter(s): 
		vArrayValues - Fills with array elements
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetArrayFromToken(pszValue, vArrayValues)
   Notes             :None
------------------------------------------------------------------------*/
void CExecEngine::GetArrayFromToken(_TCHAR* pszValue, 
								   BSTRVECTOR& vArrayValues)
{
	if(pszValue == NULL)
		return;

	// copy contents into local folder to stop original string changes because
	// in case of multiple instance operations original string need to be called
	// again and again
	// i.e. \0 is inserted by call to _tcstok
	_TCHAR* pszValueDup = new _TCHAR[lstrlen(pszValue)+1];
	if(pszValueDup)
	{
		lstrcpy(pszValueDup, pszValue);

		_TCHAR*	pszToken = _tcstok(pszValueDup, CLI_TOKEN_COMMA); 
		if(pszToken != NULL)
		{
			TrimBlankSpaces(pszToken);
			UnQuoteString(pszToken);
			vArrayValues.push_back(_bstr_t(pszToken));
		}

		while (pszToken != NULL)
		{
			pszToken = _tcstok(NULL, CLI_TOKEN_COMMA); 
			if (pszToken != NULL)
			{
				TrimBlankSpaces(pszToken);
				UnQuoteString(pszToken);
				vArrayValues.push_back(_bstr_t(pszToken));
			}
		}

		SAFEDELETE(pszValueDup);
	}
}

/*------------------------------------------------------------------------
   Name				 :ProcessSHOWInfo
   Synopsis	         :Executed the functionality requested by GET|LIST verb 
					  referring to the information available with 
					  CParsedInfo object or to display help in interactive mode
					  by displaying properties of concernrd instance.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
		bVerb		 - Verb or interactive info
		pszPath		 - the Path expression
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ProcessSHOWInfo(rParsedInfo, bVerb, pszPath)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ProcessSHOWInfo(CParsedInfo& rParsedInfo,	BOOL bVerb, 
															_TCHAR* pszPath)
{
	HRESULT					hr				= S_OK;
	BOOL					bPropList		= FALSE, 
							bRet			= TRUE, 
							bSysProp		= FALSE;
	_TCHAR					*pszWhereExpr	= NULL, 
							*pszClassPath	= NULL;
	CHARVECTOR::iterator	theIterator		= NULL, 
							theEndIterator	= NULL;
	try
	{
		_bstr_t				bstrPropList(""),	bstrClassName(""), 
							bstrQuery(""),		bstrXML("");

		//Formation of query only once , useful in case /every is specified.
		//if(rParsedInfo.GetCmdSwitchesObject().GetFirstQueryFormFlag() )
		if(rParsedInfo.GetCmdSwitchesObject().GetFormedQuery() == NULL 
					|| !bVerb)
		{	
			// Obtain the list of properties to be retrieved
			if(bVerb)
			{
				theIterator = rParsedInfo.GetCmdSwitchesObject().
								GetPropertyList().begin();
				theEndIterator = rParsedInfo.GetCmdSwitchesObject().
								GetPropertyList().end();
			}
			else
			{
				theIterator = rParsedInfo.GetCmdSwitchesObject().
								GetInteractivePropertyList().begin();
				theEndIterator = rParsedInfo.GetCmdSwitchesObject().
								GetInteractivePropertyList().end();
			}
			
			// Loop thru the list of properties specified,form comma seaprated
			// string of the properties i.e prop1, prop2, prop3, ....., propn
			while (theIterator != theEndIterator)
			{
				// Set the bPropList to TRUE
				bPropList		= TRUE;
				bstrPropList	+= _bstr_t(*theIterator);
				
				// If the system properties flag is not set to true
				if (!bSysProp)
					bSysProp = IsSysProp(*theIterator);
				
				// Move to next property
				theIterator++;
				if (theIterator != theEndIterator)
					bstrPropList += _bstr_t(L", ");
			}; 
			
			// If properties are not specified, then by default retrieve all 
			// the properties. i.e '*'
			if (!bPropList)
				bstrPropList = ASTERIX;
			
			// Obtain the alias target class
			rParsedInfo.GetCmdSwitchesObject().
						GetClassOfAliasTarget(bstrClassName);
			
			// Obtain the class path
			pszClassPath = rParsedInfo.GetCmdSwitchesObject().GetClassPath();
			
			BOOL bClass = FALSE;
			if(bVerb)
			{
				if(IsClassOperation(rParsedInfo))
				{
					bClass = TRUE;
				}
			}
			
			// If CLASS | PATH expression is specified.
			if ( pszClassPath != NULL)
			{
				if (bVerb && bClass)
				{
					bstrQuery = _bstr_t(L"SELECT * FROM") + 
								_bstr_t(" meta_class ");
				}
				else
					bstrQuery = _bstr_t(L"SELECT ") + bstrPropList + 
					_bstr_t(" FROM ") + _bstr_t(pszClassPath);
			}
			else
			{
				bstrQuery = _bstr_t("SELECT ") + bstrPropList + 
						_bstr_t(" FROM ") + bstrClassName;
			}
			
			if(bVerb)
			{
				if (bClass)
				{
					_TCHAR  pszWhere[MAX_BUFFER]	= NULL_STRING;	
					lstrcpy(pszWhere, _T("__Class =  \""));
					lstrcat(pszWhere, pszClassPath);
					lstrcat(pszWhere, _T("\""));
					pszWhereExpr = pszWhere;
				}
				else
					pszWhereExpr = rParsedInfo.GetCmdSwitchesObject().
								GetWhereExpression();
			}
			else if(pszPath)
			{
				_TCHAR  pszWhere[MAX_BUFFER]	= NULL_STRING;	
				bRet = ExtractClassNameandWhereExpr(pszPath, 
								rParsedInfo, pszWhere);
				if(bRet)
					pszWhereExpr = pszWhere;
			}
			
			if(pszWhereExpr)
			{
				bstrQuery += _bstr_t(" WHERE ") + _bstr_t(pszWhereExpr);
			}
			rParsedInfo.GetCmdSwitchesObject().SetFormedQuery(bstrQuery);
			rParsedInfo.GetCmdSwitchesObject().SetSysPropFlag(bSysProp);
		}
		else
		{
			bstrQuery = rParsedInfo.GetCmdSwitchesObject().GetFormedQuery();
			bSysProp = rParsedInfo.GetCmdSwitchesObject().GetSysPropFlag();
		}
		
		// Create the object of IWbemObjectTextSrc interface.
		if (m_pITextSrc == NULL)
			hr = CreateWMIXMLTextSrc(rParsedInfo);

		if (SUCCEEDED(hr))
		{
			// Connect to WMI namespace
			if (m_pITargetNS == NULL)
			{
				if ( IsFailFastAndNodeExist(rParsedInfo) == TRUE )
				{
					hr = ConnectToTargetNS(rParsedInfo);
					ONFAILTHROWERROR(hr);
				}
				else
					hr = E_FAIL;
			}

			if (SUCCEEDED(hr))
			{
 				// Obtain the XML Result set.
				hr = ObtainXMLResultSet(bstrQuery, rParsedInfo, 
										bstrXML, bSysProp, TRUE);
			}
			
			if(!bVerb)
			{
				BOOL bRet = g_wmiCmd.GetFormatObject().
									DisplayResults(rParsedInfo, TRUE);
				rParsedInfo.GetCmdSwitchesObject().FreeCOMError();
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(0);
				rParsedInfo.GetCmdSwitchesObject().SetInformationCode(0);
			}
		}
		bRet = FAILED(hr) ? FALSE : TRUE;
	}
	catch(_com_error& e)
	{
		bRet = FALSE;
		_com_issue_error(e.Error());
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ProcessCALLVerb
   Synopsis	         :Processes the CALL verb request referring to the 
					  information available with CParsedInfo object.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ProcessCALLVerb(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ProcessCALLVerb(CParsedInfo& rParsedInfo)
{
	HRESULT hr		= S_OK;
	BOOL	bRet	= TRUE;
	try
	{
		// Connect to WMI namespace
		if (m_pITargetNS == NULL)
		{
			if ( IsFailFastAndNodeExist(rParsedInfo) == TRUE )
				hr = ConnectToTargetNS(rParsedInfo);
			else
				bRet = FALSE;

			ONFAILTHROWERROR(hr);
		}
		
		if ( bRet == TRUE )
		{
			// Check for the verb type, so as to handle lauching of other 
			// commandline utilities from the shell.
			if ( rParsedInfo.GetCmdSwitchesObject().GetVerbType() == CMDLINE )
			{
				if (!ExecOtherCmdLineUtlty(rParsedInfo))
					bRet = FALSE;
			}
			else
			{
				if (!ExecWMIMethod(rParsedInfo))		
					bRet = FALSE;
			}
		}
	}
	catch(_com_error& e)
	{
		// Store the COM error and set the return value to FALSE
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ProcessASSOCVerb
   Synopsis	         :Processes the ASSOC verb request referring to the
					  information available with CParsedInfo object.
   Type	             :Member Function
   Input Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ProcessASSOCVerb(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ProcessASSOCVerb(CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	BOOL					bRet				= TRUE;
	WMICLIINT				nReqType			= 0;
    BOOL					bSwitches			= FALSE,
							bClass				= TRUE,
							bInstances			= FALSE;

	IEnumWbemClassObject	*pIEnumObj			= NULL;
	IWbemClassObject		*pIWbemObj			= NULL;
	VARIANT					varPath;
	VariantInit(&varPath);
	try
	{
		_bstr_t		bstrClassName(""), 	bstrQuery(""),	bstrAssocWhere(""),
					bstrResult(""), 	bstrXML(""),	bstrAggResult("");

		bstrAggResult = MULTINODE_XMLSTARTTAG;

		//If assoc switches are specified, bSwitches is set and correspondingly 
		//assoc where clause is framed	
		bSwitches =((rParsedInfo.GetCmdSwitchesObject().GetResultClassName())||
			(rParsedInfo.GetCmdSwitchesObject().GetResultRoleName()) ||
			(rParsedInfo.GetCmdSwitchesObject().GetAssocClassName()));

		if(bSwitches)
		{
			bstrAssocWhere +=  _bstr_t(" WHERE ");
			if((rParsedInfo.GetCmdSwitchesObject().GetResultClassName()) 
					!= NULL )
			{
				bstrAssocWhere += _bstr_t(L" ResultClass = ") +
					_bstr_t(rParsedInfo.GetCmdSwitchesObject().
						GetResultClassName());
				
			}
			if((rParsedInfo.GetCmdSwitchesObject().GetResultRoleName()) 
					!= NULL)
			{
				bstrAssocWhere += _bstr_t(L" ResultRole = ") +
					_bstr_t(rParsedInfo.GetCmdSwitchesObject().
						GetResultRoleName());
				
			}
			if((rParsedInfo.GetCmdSwitchesObject().GetAssocClassName()) 
					!= NULL)
			{
				bstrAssocWhere += _bstr_t(L" AssocClass  = ") +
					_bstr_t(rParsedInfo.GetCmdSwitchesObject().
						GetAssocClassName());
			}
		}
					
		//NOTE: nReqType = 2 implies that first get all instances and then
		// find associations for each instance

		// If PATH is specified 
		if (rParsedInfo.GetCmdSwitchesObject().GetPathExpression() != NULL)
		{
			// If PATH is specified (with key expression).
			if (!rParsedInfo.GetCmdSwitchesObject().
								GetExplicitWhereExprFlag())
			{
				if (rParsedInfo.GetCmdSwitchesObject().
					GetWhereExpression() == NULL)
				{
					nReqType = 2;
				}
				else
				{
					nReqType = 1;

					bstrQuery = _bstr_t(L"ASSOCIATORS OF {") 
						+ _bstr_t(rParsedInfo.GetCmdSwitchesObject()
										.GetPathExpression() 
						+ _bstr_t("}"));
				}
			}
			else
				nReqType = 2;
		}


		// If CLASS expression is specified.
		//associators of the class need to be displayed
		if (rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL
			&& rParsedInfo.GetCmdSwitchesObject().
											GetPathExpression() == NULL)
		{
			nReqType = 1;
			bstrQuery = _bstr_t(L"ASSOCIATORS OF {") 
				+ _bstr_t(rParsedInfo.GetCmdSwitchesObject().GetClassPath()) 
				+ _bstr_t("}");

			if (!bSwitches)
				bstrQuery += _bstr_t(L" WHERE SchemaOnly");
			else
				bstrQuery += bstrAssocWhere + _bstr_t(L" SchemaOnly");
		}		

		// Check for <alias> or alias and path without keyclause
		if (nReqType != 1)
		{
			// Obtain the alias target class
			if(rParsedInfo.GetCmdSwitchesObject().GetAliasName() != NULL)
			{
				rParsedInfo.GetCmdSwitchesObject().GetClassOfAliasTarget(
															bstrClassName);
			}
			else
				bstrClassName = _bstr_t(rParsedInfo.GetCmdSwitchesObject().
															GetClassPath());

			//obtain the instances corresponding to the alias target class
			bstrQuery = _bstr_t(L"SELECT * FROM ") + bstrClassName;

			//if pwhere expression is specified or where is specified
			if (rParsedInfo.GetCmdSwitchesObject().
							GetWhereExpression() != NULL)
			{
				bstrQuery += _bstr_t(" WHERE ") +_bstr_t(rParsedInfo.
							GetCmdSwitchesObject().GetWhereExpression());
			}

			nReqType = 2;
		}


		// Create the object of IWbemObjectTextSrc interface.
		if (m_pITextSrc == NULL)
			hr = CreateWMIXMLTextSrc(rParsedInfo);

		if (SUCCEEDED(hr))
		{
			// Connect to WMI namespace
			if (m_pITargetNS == NULL)
			{
				if ( IsFailFastAndNodeExist(rParsedInfo) == TRUE )
				{
					hr = ConnectToTargetNS(rParsedInfo);
					ONFAILTHROWERROR(hr);
				}
				else
					hr = E_FAIL; // Explicitly set error
			}
			
			if (SUCCEEDED(hr))
			{
				if(nReqType != 2)
				{
 					// Obtain the XML Result Set.
					hr = ObtainXMLResultSet(bstrQuery, rParsedInfo, bstrXML, 
								TRUE, FALSE);
					ONFAILTHROWERROR(hr);

					if (m_bNoAssoc)
					{
						_bstr_t bstrMsg;
						WMIFormatMessage(IDS_I_NO_ASSOC, 0, bstrMsg, NULL);
						DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, TRUE, TRUE);
						m_bNoAssoc = FALSE;
					}

					if (rParsedInfo.GetCmdSwitchesObject().
									GetPathExpression() == NULL)
					{
						bClass		= TRUE;
						hr = FrameAssocHeader(rParsedInfo.
								GetCmdSwitchesObject().GetClassPath(),	
								bstrResult, bClass);
						ONFAILTHROWERROR(hr);
					}
					else
					{
						bClass = FALSE;	
						hr = FrameAssocHeader(
								rParsedInfo.GetCmdSwitchesObject()
								.GetPathExpression(), bstrResult, bClass);
						ONFAILTHROWERROR(hr);
					}
					bstrResult += bstrXML;
					bstrResult += (bClass) ? L"</CLASS>" : L"</INSTANCE>";
					bstrAggResult += bstrResult;
				}
				else
				{
					// Set the class flag to FALSE
					bClass	= FALSE;
					ULONG					ulReturned			= 0;
					CHString				chsMsg;
					DWORD					dwThreadId			= 
											GetCurrentThreadId();
					VariantInit(&varPath);
					try
					{
						//enumerate the instances
						hr = m_pITargetNS->ExecQuery(_bstr_t(L"WQL"), 
												bstrQuery, 
												WBEM_FLAG_FORWARD_ONLY |
												WBEM_FLAG_RETURN_IMMEDIATELY, 
												NULL, &pIEnumObj);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\"," 
										L"L\"%s\", 0, NULL, -)", 
										(LPWSTR)bstrQuery);
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
									(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
									m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						// Set the interface security
						hr = SetSecurity(pIEnumObj, 
								rParsedInfo.GetAuthorityPrinciple(),
								rParsedInfo.GetNode(),
								rParsedInfo.GetUser(),
								rParsedInfo.GetPassword(),
								rParsedInfo.GetGlblSwitchesObject().
													GetAuthenticationLevel(),
								rParsedInfo.GetGlblSwitchesObject().
													GetImpersonationLevel());

						if (m_bTrace || m_eloErrLogOpt)
						{
							_TCHAR* pszAuthority = rParsedInfo.GetAuthorityPrinciple();

							if( pszAuthority != NULL &&
								_tcslen(pszAuthority) > 9 &&
								_tcsnicmp(pszAuthority, _T("KERBEROS:"), 9) == 0)
							{

								BSTR	bstrPrincipalName = ::SysAllocString(&pszAuthority[9]);

								chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_GSS_KERBEROS,"
										L"RPC_C_AUTHZ_NONE, %s, %d,   %d, -, EOAC_NONE)",
										(LPWSTR)bstrPrincipalName,	
										rParsedInfo.GetGlblSwitchesObject().
											GetAuthenticationLevel(),
										rParsedInfo.GetGlblSwitchesObject().
											GetImpersonationLevel());

								SAFEBSTRFREE(bstrPrincipalName);
							}
							else
							{
								chsMsg.Format(
									L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
									L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, "
									L"EOAC_NONE)",
									rParsedInfo.GetGlblSwitchesObject().
												GetAuthenticationLevel(),
									rParsedInfo.GetGlblSwitchesObject().
												GetImpersonationLevel());
							}
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											(LPCWSTR)chsMsg, dwThreadId,
								rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						// Loop thru the available instances
						hr = pIEnumObj->Next( WBEM_INFINITE, 1, &pIWbemObj, 
									&ulReturned );

						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(
								L"IEnumWbemClassObject->Next(WBEM_INFINITE, 1,"
								L"-, -)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
								(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
								m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						// Set this property in all objects of the collection
						while (ulReturned == 1)
 						{
							bInstances = TRUE;

							VariantInit(&varPath);
							hr = pIWbemObj->Get(L"__PATH", 0, &varPath, 0, 0);				
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(
									L"IWbemClassObject::Get(L\"__PATH\", 0, -,"
											L"0, 0)"); 
								GetBstrTFromVariant(varPath, bstrResult);
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
									(LPCWSTR)chsMsg, dwThreadId, rParsedInfo,
									m_bTrace, 0, bstrResult);
							}
							ONFAILTHROWERROR(hr);
							
							//form the query for finding the associators
							//of each of the instances
							bstrQuery = _bstr_t(L"ASSOCIATORS OF {") 
										+ varPath.bstrVal
										+ _bstr_t("}") ;
							if (bSwitches)
								bstrQuery += bstrAssocWhere;
						
							hr = FrameAssocHeader(varPath.bstrVal, bstrResult,
											bClass);
							ONFAILTHROWERROR(hr);

							//Obtain the result set for the associators
							//of the corresponding instance
							hr = ObtainXMLResultSet(bstrQuery, rParsedInfo, 
									bstrXML, TRUE, FALSE);
							ONFAILTHROWERROR(hr);

							if (m_bNoAssoc)
							{
								_bstr_t bstrMsg;
								WMIFormatMessage(IDS_I_NO_ASSOCIATIONS, 1, 
									bstrMsg, (LPWSTR)varPath.bstrVal);
								DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, 
									TRUE, TRUE);
								m_bNoAssoc = FALSE;
							}

							bstrResult += bstrXML;
							bstrResult += L"</INSTANCE>";
							bstrAggResult += bstrResult;

							//check for ctrl+c
							if ( g_wmiCmd.GetBreakEvent() == TRUE )
							{
								VARIANTCLEAR(varPath);
								SAFEIRELEASE(pIWbemObj);
								break;
							}

							VARIANTCLEAR(varPath);
							SAFEIRELEASE(pIWbemObj);

							if ( bRet == FALSE )
								break;

							// Obtain the next instance in the enumeration.
							hr = pIEnumObj->Next( WBEM_INFINITE, 1, &pIWbemObj,
										&ulReturned);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(
								  L"IEnumWbemClassObject->Next(WBEM_INFINITE,"
								  L"1, -, -)");
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
									(LPCWSTR)chsMsg,
									dwThreadId, rParsedInfo, m_bTrace);
							}
							ONFAILTHROWERROR(hr);
						}
						SAFEIRELEASE(pIEnumObj);		

						// If no instances are available
						if (bInstances == FALSE)
						{
							_bstr_t bstrMsg;
							WMIFormatMessage(IDS_I_NO_INSTANCES, 
									0, bstrMsg, NULL);
							DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, 
									TRUE, TRUE);
							CHString sTemp;
							sTemp.Format(
							_T("<ERROR><DESCRIPTION>%s</DESCRIPTION></ERROR>"),
									(LPWSTR) bstrMsg);
							bstrAggResult = _bstr_t(sTemp);
						}
					}
					catch(_com_error& e)
					{
						VARIANTCLEAR(varPath);
						SAFEIRELEASE(pIWbemObj);
						SAFEIRELEASE(pIEnumObj);		
						rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
					}
				}
				if (SUCCEEDED(hr))
				{
					if ((nReqType != 2) || ((nReqType == 2) && bInstances))
					{
						bstrAggResult += L"</CIM>";
						rParsedInfo.GetCmdSwitchesObject().
								SetXMLResultSet(bstrAggResult);
					}
				}
			}
			bRet = FAILED(hr) ? FALSE : TRUE;
		}
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(varPath);
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEnumObj);		
		_com_issue_error(e.Error());
	}
	// trap for CHeap_Exception
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(varPath);
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pIEnumObj);		
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ProcessSETVerb
   Synopsis	         :Processes the SET verb referring to the information
					  available with CParsedInfo object.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ProcessSETVerb(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ProcessSETVerb(CParsedInfo& rParsedInfo)
{
	// SET verb processing
	BOOL	 bRet		= TRUE;
	HRESULT	 hr			= S_OK;
	
	try
	{
		_bstr_t  bstrQuery(""), bstrObject(""), bstrClass("");
	
		// If anyone of the following is specified:
		// a) PATH <path expr>
		// b) PATH <class path expr> WHERE <where expr>
		if (rParsedInfo.GetCmdSwitchesObject().GetPathExpression() != NULL)
		{
			bstrClass = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetClassPath());
			bstrObject = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
													.GetPathExpression());

			// Form the query
			bstrQuery = _bstr_t(L"SELECT * FROM ") + bstrClass ;

			// If WHERE expresion is given
			if (rParsedInfo.GetCmdSwitchesObject().
								GetWhereExpression() != NULL)
			{
				bstrQuery +=	_bstr_t(L" WHERE ") 
								+ _bstr_t(rParsedInfo.GetCmdSwitchesObject()
														.GetWhereExpression());
			}
		}
		// If <alias> WHERE expression is specified.
		else if (rParsedInfo.GetCmdSwitchesObject().GetWhereExpression() 
				!= NULL)
		{
			rParsedInfo.GetCmdSwitchesObject().
								GetClassOfAliasTarget(bstrObject); 
			bstrQuery = _bstr_t(L"SELECT * FROM ") 
						+  bstrObject  
						+ _bstr_t(L" WHERE ") 
						+ _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetWhereExpression());
			bstrClass = bstrObject;
		}
		// If CLASS is specified.
		else if (rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL)
		{
			bstrObject = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetClassPath());
			bstrClass = bstrObject;
		}
		// if only <alias> is specified
		else 
		{
			rParsedInfo.GetCmdSwitchesObject().
					GetClassOfAliasTarget(bstrObject);
			bstrQuery = _bstr_t(L"SELECT * FROM ")
						+ bstrObject;
			bstrClass = bstrObject;
			
		}

		// Connect to WMI namespace
		if (m_pITargetNS == NULL)
		{
			if ( IsFailFastAndNodeExist(rParsedInfo) == TRUE )
			{
				hr = ConnectToTargetNS(rParsedInfo);
				ONFAILTHROWERROR(hr);
			}
			else
				hr = E_FAIL; // Explicitly set error
		}

		if (SUCCEEDED(hr))
		{
			// Validate the property values against the property
			// qualifier information if available.
			if (rParsedInfo.GetCmdSwitchesObject().GetAliasName() != NULL)
			{
				// Validate the input parameters against the alias
				// qualifier information.
				bRet = ValidateAlaisInParams(rParsedInfo);
			}
			else
			{
				// Validate the input parameters against the class
				// qualifier information
				bRet = ValidateInParams(rParsedInfo, bstrClass);
			}

			if (bRet)
			{
				// Set the values passed as input to the appropriate properties.
				bRet = SetPropertyInfo(rParsedInfo, bstrQuery, bstrObject);
			}
		}
		else
			bRet = FALSE;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :SetPropertyInfo
   Synopsis	         :This function updates the property value for the 
                      given property name and value
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to the CParsedInfo object 
		bstrQuery    - String consist of WQL query
		bstrObject   - String consist of object path
   Output Parameter(s):
		rParsedInfo  - reference to the CParsedInfo object 
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetPropertyInfo(rParsedInfo, bstrQuery, bstrObject)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::SetPropertyInfo(CParsedInfo& rParsedInfo, 
								 _bstr_t& bstrQuery, _bstr_t& bstrObject)
{
	HRESULT					hr					= S_OK;
	IEnumWbemClassObject	*pIEnumObj			= NULL;
	IWbemClassObject		*pIWbemObj			= NULL;
	ULONG					ulReturned			= 0;
	BOOL					bSuccess			= TRUE;
	CHString				chsMsg;
	DWORD					dwThreadId			= GetCurrentThreadId();
	VARIANT					varPath;
	VariantInit(&varPath);
	
	try
	{
		if (bstrQuery == _bstr_t(""))
		{
			// If query is NULL then get the object of WMI Class based on 
			// PATH expression
			hr = m_pITargetNS->GetObject(bstrObject,
										 0, NULL, &pIWbemObj, NULL);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, "
						L"NULL, -)", (LPWSTR) bstrObject);		
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			// If instance path is specified then modify the instance 
			// properties otherwise modify class properties
			if(rParsedInfo.GetCmdSwitchesObject().GetWhereExpression() == NULL) 
				bSuccess = SetProperties(rParsedInfo, pIWbemObj, TRUE);
			else
				bSuccess = SetProperties(rParsedInfo, pIWbemObj, FALSE);
			SAFEIRELEASE(pIWbemObj);
		}
		else
		{
			// Execute the query to get collection of objects
			hr = m_pITargetNS->ExecQuery(_bstr_t(L"WQL"), bstrQuery, 0,
										NULL, &pIEnumObj);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\"," 
							L"L\"%s\", 0, NULL, -)", (LPWSTR)bstrQuery);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			
			// Set the interface security
			hr = SetSecurity(pIEnumObj, 
					rParsedInfo.GetAuthorityPrinciple(),
					rParsedInfo.GetNode(),
					rParsedInfo.GetUser(),
					rParsedInfo.GetPassword(),
					rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
					rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());
			if (m_bTrace || m_eloErrLogOpt)
			{
				_TCHAR* pszAuthority = rParsedInfo.GetAuthorityPrinciple();

				if( pszAuthority != NULL &&
					_tcslen(pszAuthority) > 9 &&
					_tcsnicmp(pszAuthority, _T("KERBEROS:"), 9) == 0)
				{

					BSTR	bstrPrincipalName = ::SysAllocString(&pszAuthority[9]);

					chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_GSS_KERBEROS,"
							L"RPC_C_AUTHZ_NONE, %s, %d,   %d, -, EOAC_NONE)",
							(LPWSTR)bstrPrincipalName,	
							rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
							rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());

					SAFEBSTRFREE(bstrPrincipalName);
				}
				else
				{
					chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
						L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, EOAC_NONE)",
						rParsedInfo.GetGlblSwitchesObject().
									GetAuthenticationLevel(),
						rParsedInfo.GetGlblSwitchesObject().
									GetImpersonationLevel());
				}
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			BOOL bInstances = FALSE;

			// Loop thru the available instances
			hr = pIEnumObj->Next( WBEM_INFINITE, 1, &pIWbemObj, &ulReturned );

			// Set this property in all objects of the collection
			while (ulReturned == 1)
 			{
				bInstances = TRUE;
				
				// If instance updation failed.
				if (!SetProperties(rParsedInfo, pIWbemObj, FALSE))
				{
					bSuccess = FALSE;
					VARIANTCLEAR(varPath);
					SAFEIRELEASE(pIEnumObj);
					SAFEIRELEASE(pIWbemObj);
					break;
				}
				VARIANTCLEAR(varPath);
				SAFEIRELEASE(pIWbemObj);

				// Obtain the next instance in the enumeration.
				hr = pIEnumObj->Next( WBEM_INFINITE, 1, 
						&pIWbemObj, &ulReturned);
			}
			SAFEIRELEASE(pIEnumObj);
			// If no instances are available
			if (!bInstances)
			{
				rParsedInfo.GetCmdSwitchesObject().
					SetInformationCode(IDS_I_NO_INSTANCES);
			}
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bSuccess = FALSE;
	}
	// trap for CHeap_Exception
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bSuccess;
}

/*------------------------------------------------------------------------
   Name				 :SetProperties
   Synopsis	         :This function changes the property values for the 
                      given property names and values in a passed 
					  IWbemClassObject
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - CParsedInfo object consist of parsed tokens  
		pIWbemObj    - IWbemClassObject in which property has to be set
		bClass		 - Flag to indicate whether class object is passed or 
					   instance is passed
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetProperties(rParsedInfo, pIWbemObj, bClass)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::SetProperties(CParsedInfo& rParsedInfo, 
								IWbemClassObject* pIWbemObj, BOOL bClass)
{
	HRESULT				hr					= S_OK;
	IWbemQualifierSet	*pIQualSet			= NULL;
	BOOL				bRet				= TRUE, 
						bInteractive		= FALSE,
						bChange				= FALSE;
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	BSTRMAP::iterator	theIterator			= NULL;
	VARIANT				varValue, 
						varDest, 
						varSrc,
						varPath, 
						varType;
	INTEROPTION			interOption			= YES;
	
	VariantInit(&varValue);
	VariantInit(&varDest);
	VariantInit(&varSrc);
	VariantInit(&varPath);
	VariantInit(&varType);

	// Get the proprty name and their corresponding value
	BSTRMAP theMap = rParsedInfo.GetCmdSwitchesObject().GetParameterMap();
	
	// Set the iterator to the start of the map.
	theIterator = theMap.begin();

	// obtian the verb interactive mode status.
	bInteractive		= IsInteractive(rParsedInfo);
	
	try
	{
		_bstr_t				bstrResult;
		// Obtain the __PATH property value
		hr = pIWbemObj->Get(_bstr_t(L"__PATH"), 0, &varPath, 0, 0);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::Get(L\"__PATH\", 0, -,"
						L"0, 0)"); 
			GetBstrTFromVariant(varPath, bstrResult);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, m_bTrace, 0, bstrResult);
		}			
		ONFAILTHROWERROR(hr);

		// If /INTERACTIVE switch is specified, obtain the user response.
		if (bInteractive)
		{
			_bstr_t bstrMsg;
			while(TRUE)
			{
				if(IsClassOperation(rParsedInfo))
				{
					WMIFormatMessage(IDS_I_UPDATE_PROMPT, 1, bstrMsg, 
								(LPWSTR) _bstr_t(varPath.bstrVal));
					interOption	= GetUserResponse((LPWSTR)bstrMsg);
				}
				else
				{
					WMIFormatMessage(IDS_I_UPDATE_PROMPT2, 1, bstrMsg, 
								(LPWSTR) _bstr_t(varPath.bstrVal));
					interOption	= GetUserResponseEx((LPWSTR)bstrMsg);
				}
				
				if (interOption == YES || interOption == NO)
					break;
				else 
				if (interOption == HELP)
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(0);
					ProcessSHOWInfo(rParsedInfo, FALSE, 
							(_TCHAR*)_bstr_t(varPath.bstrVal));
				}
			}
		}
		else
		{
			_bstr_t bstrMsg;
			WMIFormatMessage(IDS_I_PROMPT_UPDATING, 1, bstrMsg, 
								(LPWSTR) _bstr_t(varPath.bstrVal));
			DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, FALSE, TRUE);
		}

		VARIANTCLEAR(varPath);	
		VariantInit(&varSrc);
		VariantInit(&varDest);

		if (interOption == YES)
		{
			PROPDETMAP pdmPropDetMap = rParsedInfo.GetCmdSwitchesObject().
															  GetPropDetMap();
			PROPDETMAP::iterator itrPropDetMap;
			BOOL bPropType = FALSE;

			// Update all properties
			while (theIterator != theMap.end())
			{
				// Get the property names and their corresponding values 
				_bstr_t bstrProp = _bstr_t((_TCHAR*)(*theIterator).first);

				// Get the derivation of property name
				if ( Find(pdmPropDetMap, bstrProp, itrPropDetMap) == TRUE )
				{
					if ( !((*itrPropDetMap).second.Derivation) == FALSE )
						bstrProp = (*itrPropDetMap).second.Derivation;
					bPropType = TRUE;
				}
				else
					bPropType = FALSE;

				// Check for the property validity(i.e. does it exist or not?)
				VariantInit(&varValue);
				hr = pIWbemObj->Get(bstrProp, 0, &varValue, 0, 0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"%s\", 0, -,"
								L"0, 0)", (LPWSTR) bstrProp); 
					if ( bPropType )
					{
						GetBstrTFromVariant(varValue, bstrResult, 
										(*itrPropDetMap).second.Type);
					}
					else
						GetBstrTFromVariant(varValue, bstrResult);

					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
						m_bTrace, 0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				// Set the change flag to TRUE
				bChange = TRUE;

				// If the property content is <empty>
				if ((varValue.vt == VT_EMPTY) || (varValue.vt == VT_NULL))
				{
					// Obtain the property qualifier set for the property
   					hr = pIWbemObj->GetPropertyQualifierSet(bstrProp, 
								&pIQualSet);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(
						 L"IWbemClassObject::GetPropertyQualifierSet(L\"%s\","
						 L" -)", (LPWSTR)bstrProp); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);
					

					VariantInit(&varType);
					if (pIQualSet)
					{
						// Obtain the CIM type of the property
						hr = pIQualSet->Get(_bstr_t(L"CIMTYPE"), 0L, 
											&varType, NULL);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IWbemQualifierSet::Get(L\"CIMTYPE\","
								L" 0, -, 0, 0)"); 
							GetBstrTFromVariant(varType, bstrResult);
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
								(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
								m_bTrace, 0, bstrResult);
						}
						ONFAILTHROWERROR(hr);

						if(!IsArrayType(pIWbemObj, bstrProp))
						{
							bool bNullConst = FALSE;

							varSrc.vt		= VT_BSTR;
							_TCHAR* pszValue = (*theIterator).second;

							if(_tcsicmp(pszValue,_T("NULL")) == 0){
									bNullConst = TRUE;
							}
							
							if(_tcsicmp(pszValue,_T("\"NULL\"")) == 0){
									varSrc.bstrVal	= SysAllocString(_T("NULL"));
							} else {

								varSrc.bstrVal	= SysAllocString(pszValue);
							}

							if (varSrc.bstrVal == NULL)
							{
								//Reset the variant, it will be cleaned up by the catch...
								VariantInit(&varSrc);
								throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
							}

							if (bNullConst)
								hr = VariantChangeType(&varDest, &varSrc, 0, VT_NULL);
							else
								hr = ConvertCIMTYPEToVarType(varDest, varSrc,
													 (_TCHAR*)varType.bstrVal);
							if ( m_eloErrLogOpt )
							{
								chsMsg.Format(L"VariantChangeType(-, -, 0, -)"); 
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
								 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
							}
							ONFAILTHROWERROR(hr);
						}
						else
						{
							BSTRVECTOR vArrayValues;
							_TCHAR* pszValue = (*theIterator).second;

							RemoveParanthesis(pszValue);
							GetArrayFromToken(pszValue, 
											  vArrayValues);
							hr = CheckForArray( pIWbemObj, bstrProp,  
												varDest, vArrayValues, rParsedInfo);
							ONFAILTHROWERROR(hr);
						}

						VARIANTCLEAR(varType);
						SAFEIRELEASE(pIQualSet);
					}
				}
				// If the property content is not <empty>
				else 
				{
					if(!IsArrayType(pIWbemObj, bstrProp))
					{
						bool bNullConst = FALSE;

						varSrc.vt		= VT_BSTR;
						_TCHAR* pszValue = (*theIterator).second;

						if(_tcsicmp(pszValue,_T("NULL")) == 0){
								bNullConst = TRUE;
						}
						
						if(_tcsicmp(pszValue,_T("\"NULL\"")) == 0){
								varSrc.bstrVal	= SysAllocString(_T("NULL"));
						} else {

							varSrc.bstrVal	= SysAllocString(pszValue);
						}

						if (varSrc.bstrVal == NULL)
						{
							//Reset the variant, it will be cleaned up by the catch...
							VariantInit(&varSrc);
							throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
						}

						// If _T("NULL") is the value should be treated as 
						// equivalent to VT_NULL
						if (bNullConst)
							hr = VariantChangeType(&varDest, &varSrc, 0, VT_NULL);
						else
							hr = VariantChangeType(&varDest, &varSrc, 
								0, varValue.vt);

						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"VariantChangeType(-, -, 0, -)"); 
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
								(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);
					}
					else
					{
						BSTRVECTOR vArrayValues;
						_TCHAR* pszValue = (*theIterator).second;

						RemoveParanthesis(pszValue);
						GetArrayFromToken(pszValue, 
										  vArrayValues);
						hr = CheckForArray( pIWbemObj, bstrProp,  
											varDest, vArrayValues, rParsedInfo);
						ONFAILTHROWERROR(hr);
					}
				}

				// Update the property value
				hr = pIWbemObj->Put(bstrProp, 0, &varDest, 0);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Put(L\"%s\", 0, -, 0)",
								(LPWSTR)bstrProp); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
						dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);
				VARIANTCLEAR(varSrc);
				VARIANTCLEAR(varDest);
				VARIANTCLEAR(varValue);

				// Move to next entry
				theIterator++;
			}
		}
		
		// Write the instance or class object to Windows Management 
		// Instrumentation (WMI). 
		if (bChange)
		{
			if(bClass)
			{
				// Update the class schema with the changes
				hr = m_pITargetNS->PutClass(pIWbemObj, 0, NULL, NULL);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemServices::PutClass(-, 0, "
							L"NULL, NULL)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);
			}
			else
			{
				// Update the instance with the changes
				hr = m_pITargetNS->PutInstance(pIWbemObj, WBEM_FLAG_UPDATE_ONLY, NULL, NULL);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemServices::PutInstance(-, 0, NULL"
						L", NULL)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);

			}
			DisplayString(IDS_I_SET_SUCCESS, CP_OEMCP, NULL, FALSE, TRUE);
		}
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(varDest);
		VARIANTCLEAR(varValue);
		VARIANTCLEAR(varType);
		SAFEIRELEASE(pIQualSet);
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(varDest);

		// Store the COM error, and set the return value to FALSE.
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(varDest);
		VARIANTCLEAR(varValue);
		VARIANTCLEAR(varType);
		SAFEIRELEASE(pIQualSet);
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(varDest);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ConnectToTargetNS
   Synopsis	         :This function connects to WMI namespace on the target
					  machine with given user credentials.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :ConnectToTargetNS(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CExecEngine::ConnectToTargetNS(CParsedInfo& rParsedInfo)
{
	HRESULT hr					= S_OK;
	CHString	chsMsg;
	DWORD	dwThreadId			= GetCurrentThreadId();
	try
	{
		SAFEIRELEASE(m_pITargetNS);
		_bstr_t bstrNameSpace = _bstr_t(L"\\\\") 
								+ _bstr_t(rParsedInfo.GetNode()) 
								+ _bstr_t(L"\\") 
								+ _bstr_t(rParsedInfo.GetNamespace());
		
		// Connect to the specified WMI namespace
		hr = Connect(m_pIWbemLocator, &m_pITargetNS, 
					bstrNameSpace, 
					_bstr_t(rParsedInfo.GetUser()),
					_bstr_t(rParsedInfo.GetPassword()),
					_bstr_t(rParsedInfo.GetLocale()),
					rParsedInfo);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemLocator::ConnectServer(L\"%s\", "
				L"L\"%s\", *, L\"%s\", 0L, L\"%s\", NULL, -)",
				(LPWSTR)bstrNameSpace,
				(rParsedInfo.GetUser()) ? rParsedInfo.GetUser() : L"<null>",
				rParsedInfo.GetLocale(),
				(rParsedInfo.GetAuthorityPrinciple()) ?
							rParsedInfo.GetAuthorityPrinciple() : L"<null>");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);


		// Set the interface level security 
		hr = SetSecurity(m_pITargetNS, 
				rParsedInfo.GetAuthorityPrinciple(),
				rParsedInfo.GetNode(),
				rParsedInfo.GetUser(),
				rParsedInfo.GetPassword(),
				rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
				rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());
		if (m_bTrace || m_eloErrLogOpt)
		{
			_TCHAR* pszAuthority = rParsedInfo.GetAuthorityPrinciple();

			if( pszAuthority != NULL &&
				_tcslen(pszAuthority) > 9 &&
				_tcsnicmp(pszAuthority, _T("KERBEROS:"), 9) == 0)
			{

				BSTR	bstrPrincipalName = ::SysAllocString(&pszAuthority[9]);

				chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_GSS_KERBEROS,"
						L"RPC_C_AUTHZ_NONE, %s, %d,   %d, -, EOAC_NONE)",
						(LPWSTR)bstrPrincipalName,	
						rParsedInfo.GetGlblSwitchesObject().
							GetAuthenticationLevel(),
						rParsedInfo.GetGlblSwitchesObject().
							GetImpersonationLevel());

				SAFEBSTRFREE(bstrPrincipalName);
			}
			else
			{
				chsMsg.Format(
					L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,"
					L"NULL, %d,   %d, -, EOAC_NONE)",
					rParsedInfo.GetGlblSwitchesObject().GetAuthenticationLevel(),
					rParsedInfo.GetGlblSwitchesObject().GetImpersonationLevel());
			}
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

	}
	catch(_com_error& e)
	{
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :CreateWMIXMLTextSrc
   Synopsis	         :This function creates the IWbemObjectTextSrc instance
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateWMIXMLTextSrc(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CExecEngine::CreateWMIXMLTextSrc(CParsedInfo& rParsedInfo)
{
	HRESULT hr					= S_OK;
	CHString	chsMsg;
	DWORD	dwThreadId			= GetCurrentThreadId();

	try
	{
		hr = CoCreateInstance(CLSID_WbemObjectTextSrc, NULL, 
							CLSCTX_INPROC_SERVER, 
							IID_IWbemObjectTextSrc, 
							(LPVOID*) &m_pITextSrc);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"CoCreateInstance(CLSID_WbemObjectTextSrc, NULL,"
				L"CLSCTX_INPROC_SERVER, IID_IWbemObjectTextSrc, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

	}
	catch(_com_error& e)
	{
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :CreateContext
   Synopsis	         :This function creates the IWbemContext instance
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateContext(rParsedInfo)
   Calls             :CParsedInfo::GetCmdSwitchesObject()
					  CCommandSwitches::SetCOMError()
					  CoCreateInstance()
   Called by         :CExecEngine::ObtainXMLResultSet()
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CExecEngine::CreateContext(CParsedInfo& rParsedInfo)
{
	HRESULT hr					= S_OK;
	CHString	chsMsg;
	DWORD	dwThreadId			= GetCurrentThreadId();
	try
	{
		//Create context object
		MULTI_QI mqi = { &IID_IWbemContext, 0, 0 };
		hr = CoCreateInstanceEx(CLSID_WbemContext, NULL, 
					          CLSCTX_INPROC_SERVER, 
							  0, 1, &mqi);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"CoCreateInstanceEx(CLSID_WbemContext, NULL,"
					L"CLSCTX_INPROC_SERVER, 0, 1, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

	    m_pIContext = reinterpret_cast<IWbemContext*>(mqi.pItf);
    }
	catch(_com_error& e)
	{
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*-------------------------------------------------------------------------
   Name				 :ExecuteMethodAndDisplayResults
   Synopsis	         :This function executes and displays the
					  results corresponding to the method. If 
					  interactive mode is set, the user is prompted 
					  choose the method
   Type	             :Member Function
   Input Parameter(s):
	bstrPath		 - _bstr_t type,Path expression
	rParsedInfo		 - reference to CParsedInfo class object
	pIInParam		 - Pointer to the IWbemclassobject
   Output Parameter(s):
    rParsedInfo		 - reference to CParsedInfo class object
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    :ExecuteMethodAndDisplayResults(bstrPath, rParsedInfo,
													 pIInParam)
   Calls             :None
   Called by         :CExecEngine::ExecWMIMethod()
   Notes             :none
-------------------------------------------------------------------------*/
HRESULT CExecEngine::ExecuteMethodAndDisplayResults(_bstr_t bstrPath,
												  CParsedInfo& rParsedInfo,
												  IWbemClassObject* pIInParam)
{
	_TCHAR					*pszMethodName		= NULL;
	INTEROPTION				interOption			= YES;
	IWbemClassObject		*pIOutParam			= NULL;
	HRESULT					hr					= S_OK;
	CHString				chsMsg;
	DWORD					dwThreadId			= GetCurrentThreadId();
	VARIANT					varTemp;
	VariantInit(&varTemp);

	// Obtain the method name
	pszMethodName =	rParsedInfo.GetCmdSwitchesObject().GetMethodName();

	try
	{
		// If /INTERACTIVE switch is specified, obtain the user response.
		if (IsInteractive(rParsedInfo) == TRUE)
		{
			_bstr_t bstrMsg;
			while ( TRUE )
			{
				BOOL bInstanceLevel = TRUE;
				if(IsClassOperation(rParsedInfo))
				{
					bInstanceLevel = FALSE;
				}
				else
				{
					_TCHAR *pszVerbName = rParsedInfo.GetCmdSwitchesObject().
																GetVerbName(); 
					if(CompareTokens(pszVerbName, CLI_TOKEN_CALL))
					{
						if ( rParsedInfo.GetCmdSwitchesObject().
											GetAliasName() != NULL )
						{
							if (rParsedInfo.GetCmdSwitchesObject().
											GetWhereExpression() == NULL)
							{
								bInstanceLevel = FALSE;
							}
							else
								bInstanceLevel = TRUE;
						}
						else
						{
							if ((rParsedInfo.GetCmdSwitchesObject().
											GetPathExpression() != NULL)
								&& (rParsedInfo.GetCmdSwitchesObject().
											GetWhereExpression() == NULL))
							{
								bInstanceLevel = FALSE;
							}
							else
								bInstanceLevel = TRUE;
						}
					}
					else
						bInstanceLevel = TRUE;
				}
				
				if(bInstanceLevel)
				{
					WMIFormatMessage(IDS_I_METH_EXEC_PROMPT2, 2, bstrMsg, 
										(LPWSTR) bstrPath,	pszMethodName);
					interOption = GetUserResponseEx((LPWSTR)bstrMsg);
				}
				else
				{
					WMIFormatMessage(IDS_I_METH_EXEC_PROMPT, 2, bstrMsg, 
										(LPWSTR) bstrPath,	pszMethodName);
					interOption = GetUserResponse((LPWSTR)bstrMsg);
				}
				
				if ( interOption == YES || interOption == NO )
					break;
				else if(interOption == HELP)
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(0);
					ProcessSHOWInfo(rParsedInfo, FALSE, (LPWSTR)bstrPath);
				}
			}
		}
		
		if ( interOption == YES )
		{
			if (IsInteractive(rParsedInfo) == FALSE)
			{
				_bstr_t bstrMsg;
				WMIFormatMessage(IDS_I_METH_EXEC_STATUS, 2, bstrMsg, 
									(LPWSTR) bstrPath,	pszMethodName);
				DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, FALSE, TRUE);
			}

			// Execute the method with the given input arguments
			hr = m_pITargetNS->ExecMethod(bstrPath,
								_bstr_t(rParsedInfo.GetCmdSwitchesObject()
													.GetMethodName()),
				   				0L,				
								NULL,			
								pIInParam,		
								&pIOutParam,	
								NULL);			
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::ExecMethod(L\"%s\", L\"%s\", "
					L"0, NULL, -, -, NULL)", (LPWSTR) bstrPath, 
					rParsedInfo.GetCmdSwitchesObject().GetMethodName()
					? rParsedInfo.GetCmdSwitchesObject().GetMethodName()
					: L"<null>");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			DisplayString(IDS_I_CALL_SUCCESS, CP_OEMCP, NULL, FALSE, TRUE);

			// Check the method execution status.
			if(pIOutParam)
			{
				_TCHAR szMsg[BUFFER1024] = NULL_STRING;
				rParsedInfo.GetCmdSwitchesObject().
											 SetMethExecOutParam(pIOutParam);

				DisplayMethExecOutput(rParsedInfo);
			}
			SAFEIRELEASE(pIOutParam);
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIOutParam);
		VARIANTCLEAR(varTemp);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIOutParam);
		VARIANTCLEAR(varTemp);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :DisplayMethExecOutput
   Synopsis	         :Displays the result of execution of the method.
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo	 - CParsedInfo object.
   Output Parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayMethExecOutput(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CExecEngine::DisplayMethExecOutput(CParsedInfo& rParsedInfo)
{
	HRESULT				hr					= S_OK;
	IWbemClassObject	*pIOutParam			= NULL;
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	BSTR				pstrMofTextOfObj	=	NULL;		
	VARIANT				vtTemp;
	VariantInit(&vtTemp);

	try
	{
		_bstr_t				bstrResult;
		pIOutParam = rParsedInfo.GetCmdSwitchesObject().GetMethExecOutParam();
		if ( pIOutParam != NULL )
		{
			hr = pIOutParam->GetObjectText(0, &pstrMofTextOfObj);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject->GetObjectText(0, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			DisplayString(IDS_I_OUT_PARAMS,CP_OEMCP, NULL, FALSE, TRUE);
			DisplayMessage(_bstr_t(pstrMofTextOfObj), CP_OEMCP, FALSE, TRUE);
			DisplayMessage(_T("\n"), CP_OEMCP, TRUE, TRUE);
			SAFEBSTRFREE(pstrMofTextOfObj);
		}
	}
	catch(_com_error& e)
	{
		SAFEBSTRFREE(pstrMofTextOfObj);
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		SAFEBSTRFREE(pstrMofTextOfObj);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*------------------------------------------------------------------------
   Name				 :ExecOtherCmdLineUtlty
   Synopsis	         :Invokes other command line utility specified in 
					  Derivation of Verb if Verb Type is "CommandLine"
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo	 - CParsedInfo object.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ExecOtherCmdLineUtlty(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ExecOtherCmdLineUtlty(CParsedInfo& rParsedInfo)
{
	BOOL	bRet				= TRUE;
	BOOL	bInvalidNoOfArgs	= FALSE;
	
	if ( rParsedInfo.GetCmdSwitchesObject().GetNamedParamListFlag() == FALSE )
	{
		METHDETMAP mdpMethDetMap = 
						 rParsedInfo.GetCmdSwitchesObject().GetMethDetMap();
		METHDETMAP::iterator iMethDetMapItr = mdpMethDetMap.begin();
		METHODDETAILS mdMethDet = (*iMethDetMapItr).second;
		
		CHARVECTOR cvInParams = 
			rParsedInfo.GetCmdSwitchesObject().GetPropertyList();

		PROPDETMAP pdmPropDetMap = mdMethDet.Params;
		if ( !pdmPropDetMap.empty() )
		{
			if ( pdmPropDetMap.size() != cvInParams.size() )
				bInvalidNoOfArgs = TRUE;
		}
	}
													   
	if ( bInvalidNoOfArgs == TRUE )
	{
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_NO_OF_PARAMS);
		bRet = FALSE;
	}
	else
	{
		HRESULT hr = FormQueryAndExecuteMethodOrUtility(rParsedInfo);
		bRet = FAILED(hr) ? FALSE : TRUE;
	}

	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ProcessDELETEVerb
   Synopsis	         :Processes the DELETE verb referring to the information
					  available with CParsedInfo object.
   Type	             :Member Function
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ProcessDELETEVerb(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ProcessDELETEVerb(CParsedInfo& rParsedInfo)
{
	// DELETE verb processing
	BOOL	 bRet			= TRUE;
	HRESULT	 hr				= S_OK;
	
	try
	{
		_bstr_t  bstrQuery(""), bstrObject("");
		// If anyone of the following is specified:
		// a) PATH <path expr>
		// b) PATH <class path expr> WHERE <where expr>
		if (rParsedInfo.GetCmdSwitchesObject().GetPathExpression() != NULL)
		{
			_bstr_t bstrClass = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetClassPath());

			bstrObject = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
											.GetPathExpression());

			// Form the query
			bstrQuery = _bstr_t(L"SELECT * FROM ") + bstrClass ;

			// If WHERE expresion is given
			if (rParsedInfo.GetCmdSwitchesObject().
								GetWhereExpression() != NULL)
			{
				bstrQuery +=	_bstr_t(L" WHERE ") 
								+ _bstr_t(rParsedInfo.GetCmdSwitchesObject()
														.GetWhereExpression());
			}
		}
		// If <alias> WHERE expression is specified.
		else if (rParsedInfo.GetCmdSwitchesObject().GetWhereExpression() 
			!= NULL)
		{
			rParsedInfo.GetCmdSwitchesObject().
								GetClassOfAliasTarget(bstrObject); 
			bstrQuery = _bstr_t(L"SELECT * FROM ") 
						+  bstrObject  
						+ _bstr_t(L" WHERE ") 
						+ _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetWhereExpression());
		}
		// If CLASS is specified.
		else if (rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL)
		{
			bstrObject = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetClassPath());
		}
		// if Alias name is specified
		else 
		{
			rParsedInfo.GetCmdSwitchesObject().
								GetClassOfAliasTarget(bstrObject); 
			bstrQuery = _bstr_t (L"SELECT * FROM ")
						+bstrObject;
		}

		// Connect to WMI namespace
		if (m_pITargetNS == NULL)
		{
			if ( IsFailFastAndNodeExist(rParsedInfo) == TRUE )
			{
				hr = ConnectToTargetNS(rParsedInfo);
				ONFAILTHROWERROR(hr);
			}
			else
				hr = E_FAIL; // Explicitly set error
		}

		if (SUCCEEDED(hr))
			bRet = DeleteObjects(rParsedInfo, bstrQuery, bstrObject);
		else
			bRet = FALSE;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
		bRet = FALSE;
	}

	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :DeleteObjects
   Synopsis	         :This function deletes the instances(s) or class 
					  specified for deletion.
   Type	             :Member Function
   Input parameter   :
		rParsedInfo  - reference to the CParsedInfo object 
		bstrQuery    - String consist of WQL query
		bstrObject   - String consist of object path
   Output parameters :
		rParsedInfo  - reference to the CParsedInfo object 
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :DeleteObjects(rParsedInfo, bstrQuery, bstrObject)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::DeleteObjects(CParsedInfo& rParsedInfo, 
								 _bstr_t& bstrQuery, _bstr_t& bstrObject)
{
	HRESULT					hr					= S_OK;
	BOOL					bSuccess			= TRUE;
	IEnumWbemClassObject	*pIEnumObj			= NULL;		
	IWbemClassObject		*pIWbemObj			= NULL;
	ULONG					ulReturned			= 0;
	INTEROPTION				interOption			= YES;
	CHString				chsMsg;
	DWORD					dwThreadId			= GetCurrentThreadId();
	VARIANT					vtPath;
	VariantInit(&vtPath);

	try
	{ 
		_bstr_t					bstrResult;
		if (bstrQuery == _bstr_t(""))
		{
			// If /INTERACTIVE switch is specified, obtain the user response.
			if (IsInteractive(rParsedInfo) == TRUE)
			{
				_bstr_t bstrMsg;
				while ( TRUE )
				{
					if(IsClassOperation(rParsedInfo))
					{
						WMIFormatMessage(IDS_I_DELETE_CLASS_PROMPT, 1, bstrMsg, 
									(LPWSTR) bstrObject);
						interOption = GetUserResponse((LPWSTR)bstrMsg);
					}
					else
					{
					   WMIFormatMessage(IDS_I_DELETE_CLASS_PROMPT2, 1, bstrMsg, 
									(LPWSTR) bstrObject);
						interOption = GetUserResponseEx((LPWSTR)bstrMsg);
					}

					if ( interOption == YES || interOption == NO )
						break;
					else if(interOption == HELP)
					{
						rParsedInfo.GetCmdSwitchesObject().
								SetInformationCode(0);
						ProcessSHOWInfo(rParsedInfo, FALSE, 
								(LPWSTR)bstrObject);
					}
				}
			}
					
			if (interOption == YES)
			{
				// If instance path is specified then delete the instance 
				// properties otherwise delete the class
				if(!rParsedInfo.GetCmdSwitchesObject().GetWhereExpression()) 
				{
					// If WHERE expression is NULL then delete the WMI class
					hr = m_pITargetNS->DeleteClass(bstrObject, 0, NULL, NULL);

					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemServices::DeleteClass"
							L"(L\"%s\", 0, NULL, NULL)", (LPWSTR)bstrObject);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);
					DisplayString(IDS_I_DELETE_SUCCESS,CP_OEMCP, 
							NULL, FALSE, TRUE);
				}
				else
				{
						// If WHERE expression is not NULL then delete the 
						// WMI instance
						DisplayString(IDS_I_DELETING_INSTANCE,
										CP_OEMCP,(LPWSTR)vtPath.bstrVal,
										FALSE, TRUE);
						hr = m_pITargetNS->DeleteInstance(bstrObject,
												0, NULL, NULL);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IWbemServices::DeleteInstance"
								L"(L\"%s\", 0, NULL, NULL)", 
								(LPWSTR) bstrObject);
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
								(LPCWSTR)chsMsg, dwThreadId, rParsedInfo,
								 m_bTrace);
						}
						ONFAILTHROWERROR(hr);
						DisplayString(IDS_I_INSTANCE_DELETE_SUCCESS,
							CP_OEMCP, NULL,	FALSE, TRUE);
				}
			}
		}
		else 
		{
			// Execute the query to get collection of objects
			hr = m_pITargetNS->ExecQuery(_bstr_t(L"WQL"), bstrQuery,
								0, NULL, &pIEnumObj);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\"," 
							L"L\"%s\", 0, NULL, -)", (LPWSTR)bstrQuery);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			
			// Set the interface security
			hr = SetSecurity(pIEnumObj, 
					rParsedInfo.GetAuthorityPrinciple(),
					rParsedInfo.GetNode(),
					rParsedInfo.GetUser(),
					rParsedInfo.GetPassword(),
					rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
					rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());
			if (m_bTrace || m_eloErrLogOpt)
			{
				_TCHAR* pszAuthority = rParsedInfo.GetAuthorityPrinciple();

				if( pszAuthority != NULL &&
					_tcslen(pszAuthority) > 9 &&
					_tcsnicmp(pszAuthority, _T("KERBEROS:"), 9) == 0)
				{

					BSTR	bstrPrincipalName = ::SysAllocString(&pszAuthority[9]);

					chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_GSS_KERBEROS,"
							L"RPC_C_AUTHZ_NONE, %s, %d,   %d, -, EOAC_NONE)",
							(LPWSTR)bstrPrincipalName,	
							rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
							rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());

					SAFEBSTRFREE(bstrPrincipalName);
				}
				else
				{
					chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
						L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, EOAC_NONE)",
						rParsedInfo.GetGlblSwitchesObject().
									GetAuthenticationLevel(),
						rParsedInfo.GetGlblSwitchesObject().
									GetImpersonationLevel());
				}
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
					dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);


			BOOL bInstances		= FALSE;
			BOOL bInteractive	= IsInteractive(rParsedInfo);

			hr = pIEnumObj->Next(WBEM_INFINITE, 1, &pIWbemObj, &ulReturned);
			
			// Set this property in all objects of the collection
			while (ulReturned == 1)
 			{
				INTEROPTION	interOption	= YES;
				bInstances  = TRUE;
				VariantInit(&vtPath);

				// Get the object path.
				hr = pIWbemObj->Get(_bstr_t(L"__PATH"), 0, &vtPath, NULL, NULL);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(
							L"IWbemClassObject::Get(L\"__PATH\", 0, -, 0, 0)"); 
					GetBstrTFromVariant(vtPath, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace, 0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				// If /INTERACTIVE switch is specified, obtain user response.
				if (IsInteractive(rParsedInfo) == TRUE)
				{
					_bstr_t bstrMsg;
					while ( TRUE )
					{
						if(IsClassOperation(rParsedInfo))
						{
							WMIFormatMessage(IDS_I_DELETE_CLASS_PROMPT, 
								1, bstrMsg, (LPWSTR) vtPath.bstrVal);
							interOption = GetUserResponse((LPWSTR)bstrMsg);
						}
						else
						{
							WMIFormatMessage(IDS_I_DELETE_CLASS_PROMPT2, 1, 
								bstrMsg, (LPWSTR) vtPath.bstrVal);
							interOption = GetUserResponseEx((LPWSTR)bstrMsg);
						}

						if ( interOption == YES || interOption == NO )
							break;
						else if(interOption == HELP)
						{
							rParsedInfo.GetCmdSwitchesObject().
									SetInformationCode(0);
							ProcessSHOWInfo(rParsedInfo, FALSE, 
									(LPWSTR)vtPath.bstrVal);
						}
					}
				}
					
				if (interOption == YES)
				{
					DisplayString(IDS_I_DELETING_INSTANCE,
								CP_OEMCP,(LPWSTR)vtPath.bstrVal, FALSE, TRUE);
					hr = m_pITargetNS->DeleteInstance(vtPath.bstrVal,
											0, NULL, NULL);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemServices::DeleteInstance"
							L"(L\"%s\", 0, NULL, NULL)", 
							(LPWSTR) vtPath.bstrVal);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);
														
				
					VARIANTCLEAR(vtPath);
					SAFEIRELEASE(pIWbemObj);
					DisplayString(IDS_I_INSTANCE_DELETE_SUCCESS,CP_OEMCP,
								NULL, FALSE, TRUE);
				}
				hr = pIEnumObj->Next( WBEM_INFINITE, 1, &pIWbemObj, 
						&ulReturned);
			}
			SAFEIRELEASE(pIEnumObj);

			// If no instances are available
			if (!bInstances)
			{
				rParsedInfo.GetCmdSwitchesObject().
					SetInformationCode(IDS_I_NO_INSTANCES);
			}
		}
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(vtPath);
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bSuccess = FALSE;
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(vtPath);
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bSuccess;
}

/*------------------------------------------------------------------------
   Name				 :GetUserResponse
   Synopsis	         :This function accepts the user response before going
					  ahead, when /INTERACTIVE is specified at the verb 
					  level
   Type	             :Member Function
   Input parameter   :
			pszMsg	 - message to be displayed.
   Output parameters :None
   Return Type       :INTEROPTION
   Global Variables  :None
   Calling Syntax    :GetUserResponse(pszMsg)
   Notes             :None
------------------------------------------------------------------------*/
INTEROPTION CExecEngine::GetUserResponse(_TCHAR* pszMsg)
{
	INTEROPTION bRet				= YES;
	_TCHAR 		szResp[BUFFER255]	= NULL_STRING;
	_TCHAR *pBuf					= NULL;

	if (pszMsg == NULL)
		bRet = NO;

	if(bRet != NO)
	{
		// Get the user response, till 'Y' - yes or 'N' - no
		// is keyed in
		while(TRUE)
		{
			DisplayMessage(pszMsg, CP_OEMCP, TRUE, TRUE);
			pBuf = _fgetts(szResp, BUFFER255-1, stdin);
			if(pBuf != NULL)
			{
				LONG lInStrLen = lstrlen(szResp);
				if(szResp[lInStrLen - 1] == _T('\n'))
						szResp[lInStrLen - 1] = _T('\0');
			}
			else if ( g_wmiCmd.GetBreakEvent() != TRUE )
			{
				lstrcpy(szResp, RESPONSE_NO);
				DisplayMessage(_T("\n"), CP_OEMCP, TRUE, TRUE);
			}

			if ( g_wmiCmd.GetBreakEvent() == TRUE )
			{
				g_wmiCmd.SetBreakEvent(FALSE);
				lstrcpy(szResp, RESPONSE_NO);
				DisplayMessage(_T("\n"), CP_OEMCP, TRUE, TRUE);
			}
			if (CompareTokens(szResp, RESPONSE_YES)
				|| CompareTokens(szResp, RESPONSE_NO))
				break;
		}
		if (CompareTokens(szResp, RESPONSE_NO))
			bRet = NO;
	}
	
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ProcessCREATEVerb
   Synopsis	         :Processes the CREATE verb referring to the information
					  available with CParsedInfo object.
   Type	             :Member Function
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ProcessCREATEVerb(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ProcessCREATEVerb(CParsedInfo& rParsedInfo)
{ 
	// CREATE verb processing
	BOOL		bRet		= TRUE;
	INTEROPTION	interCreate	= YES;
	HRESULT		hr			= S_OK;
	
	try
	{
		_bstr_t		bstrClass("");
		// If object PATH expression is specified.
		if (rParsedInfo.GetCmdSwitchesObject().GetPathExpression() != NULL)
		{
			bstrClass = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetClassPath());
		}
		// If CLASS is specified.
		else if (rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL)
		{
			bstrClass = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetClassPath());
		}
		// if Alias name is specified
		else 
		{
			rParsedInfo.GetCmdSwitchesObject().
					GetClassOfAliasTarget(bstrClass);
		}

		// Check if interactive mode 
		if (IsInteractive(rParsedInfo) == TRUE)
		{
			_bstr_t bstrMsg;
			WMIFormatMessage(IDS_I_CREATE_INST_PROMPT, 1, 
								bstrMsg, (LPWSTR) bstrClass);
			// Get the user response.
			interCreate = GetUserResponse((LPWSTR)bstrMsg);
		}
		if (interCreate == YES)
		{
			// Connect to WMI namespace
			if (m_pITargetNS == NULL)
			{
				if ( IsFailFastAndNodeExist(rParsedInfo) == TRUE )
				{
					hr = ConnectToTargetNS(rParsedInfo);
					ONFAILTHROWERROR(hr);
				}
				else
					hr = E_FAIL; // Explicitly set error
			}

			if (SUCCEEDED(hr))
			{
				// Validate the property values against the property
				// qualifier information if available.
				if (rParsedInfo.GetCmdSwitchesObject().GetAliasName() != NULL)
				{
					// Validate the input parameters against the alias
					// qualifier information.
					bRet = ValidateAlaisInParams(rParsedInfo);
				}
				else
				{
					// Validate the input parameters against the class
					// qualifier information
					bRet = ValidateInParams(rParsedInfo, bstrClass);
				}

				if (bRet)
				{
					// Set the values passed as input to the appropriate properties.
					bRet = CreateInstance(rParsedInfo, bstrClass);
				}
			}
			else
				bRet = FALSE;
		}
		else
		{
			// Message to be displayed to the user
			rParsedInfo.GetCmdSwitchesObject().
						SetInformationCode(IDS_I_NOCREATE);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :CreateInstance
   Synopsis	         :This function creates an instance of the specified 
					  class 
   Type	             :Member Function
   Input parameter   :
		rParsedInfo  - reference to the CParsedInfo object 
		bstrClass	 - classname
   Output parameters :
		rParsedInfo  - reference to the CParsedInfo object 
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :CreateInstance(rParsedInfo, bstrClass)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::CreateInstance(CParsedInfo& rParsedInfo, BSTR bstrClass)
{
	HRESULT					hr					= S_OK;
	IWbemClassObject		*pIWbemObj			= NULL;
	IWbemClassObject		*pINewInst			= NULL;
	IWbemQualifierSet		*pIQualSet			= NULL;
	BOOL					bSuccess			= TRUE;
	DWORD					dwThreadId			= GetCurrentThreadId();
	CHString				chsMsg;
	VARIANT					varType, 
							varSrc, 
							varDest;
	VariantInit(&varSrc);
	VariantInit(&varDest);
	VariantInit(&varType);
	
	
	// Obtain the list of properties and their associated values
	BSTRMAP theMap = rParsedInfo.GetCmdSwitchesObject().GetParameterMap();
	BSTRMAP::iterator theIterator = NULL;
	theIterator = theMap.begin();
	try
	{
		_bstr_t					bstrResult;
		// Get the class definition
		hr = m_pITargetNS->GetObject(bstrClass,
									 0, NULL, &pIWbemObj, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", 0, NULL, -)", 
					(LPWSTR) bstrClass);		
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId,	rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

	    // Create a new instance.
	    hr = pIWbemObj->SpawnInstance(0, &pINewInst);
		if ( m_eloErrLogOpt )
		{
			chsMsg.Format(L"IWbemClassObject::SpawnInstance(0, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, FALSE);
		}
		ONFAILTHROWERROR(hr);


		PROPDETMAP pdmPropDetMap = rParsedInfo.GetCmdSwitchesObject().
														  GetPropDetMap();
		PROPDETMAP::iterator itrPropDetMap;

		// Update all properties
		while (theIterator != theMap.end())
		{
			// Get the propert name and the corresponding value 
			_bstr_t bstrProp = _bstr_t((_TCHAR*)(*theIterator).first);
		
			// Get the derivation of property name
			if ( Find(pdmPropDetMap, bstrProp, itrPropDetMap) == TRUE &&
				!((*itrPropDetMap).second.Derivation) == FALSE )
				bstrProp = (*itrPropDetMap).second.Derivation;

			// Obtain the property qualifier set for the property
   			hr = pINewInst->GetPropertyQualifierSet(bstrProp, &pIQualSet);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::GetPropertyQualifierSet"
					L"(L\"%s\", -)", (LPWSTR) bstrProp);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			VariantInit(&varType);
			if (pIQualSet)
			{
				// Obtain the CIM type of the property
				hr = pIQualSet->Get(_bstr_t(L"CIMTYPE"), 0L, &varType, NULL);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemQualifierSet::Get(L\"CIMTYPE\", "
							L"0, -, NULL)"); 
					GetBstrTFromVariant(varType, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, m_bTrace, 0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				if(!IsArrayType(pINewInst, bstrProp))
				{
					varSrc.vt = VT_BSTR;
					varSrc.bstrVal = SysAllocString((_TCHAR*)(*theIterator).second);

					if (varSrc.bstrVal == NULL)
					{
						//Reset the variant, it will be cleaned up by the catch...
						VariantInit(&varSrc);
						throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
					}

					hr = ConvertCIMTYPEToVarType(varDest, varSrc,
											 (_TCHAR*)varType.bstrVal);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"VariantChangeType(-, -, 0, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);
				}
				else
				{
					BSTRVECTOR vArrayValues;
					_TCHAR* pszValue = (*theIterator).second;

					RemoveParanthesis(pszValue);
					GetArrayFromToken(pszValue, 
									  vArrayValues);
					hr = CheckForArray( pINewInst, bstrProp,  
										varDest, vArrayValues, rParsedInfo);
					ONFAILTHROWERROR(hr);
				}

				VARIANTCLEAR(varType);
				SAFEIRELEASE(pIQualSet);
			}
			
			// Update the property value
			hr = pINewInst->Put(bstrProp, 0, &varDest, 0);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::Put(L\"%s\", 0, -, 0)",
							(LPWSTR) bstrProp); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId,	rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			VARIANTCLEAR(varSrc);
			VARIANTCLEAR(varDest);
			theIterator++;
		}

		// Update the instance with the changes
		hr = m_pITargetNS->PutInstance(pINewInst, WBEM_FLAG_CREATE_ONLY,
					NULL, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemServices::PutInstance(-, "
						L"WBEM_FLAG_CREATE_ONLY, NULL, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);
		
		SAFEIRELEASE(pINewInst);
		rParsedInfo.GetCmdSwitchesObject().
						SetInformationCode(IDS_I_CREATE_SUCCESS);
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(varDest);
		VARIANTCLEAR(varType);
		SAFEIRELEASE(pIQualSet);
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pINewInst);

		// Store the COM error and set the return value to FALSE
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bSuccess = FALSE;
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(varSrc);
		VARIANTCLEAR(varDest);
		VARIANTCLEAR(varType);
		SAFEIRELEASE(pIQualSet);
		SAFEIRELEASE(pIWbemObj);
		SAFEIRELEASE(pINewInst);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bSuccess;
}

/*------------------------------------------------------------------------
   Name				 :ValidateInParams
   Synopsis	         :Validates the property value specified against the 
					  property qualifiers for that property (i.e checking 
					  against the contents of following qualifiers if 
					  available:
					  1. MaxLen,
					  2. ValueMap
					  3. Values
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo	 - CParsedInfo object.
		bstrClass	 - Bstr type, class name.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ValidateInParams(rParsedInfo, bstrClass)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ValidateInParams(CParsedInfo& rParsedInfo, _bstr_t bstrClass)
{
	HRESULT				hr					= S_OK;
	IWbemClassObject	*pIObject			= NULL;
	IWbemQualifierSet	*pIQualSet			= NULL;
	BOOL				bRet				= TRUE;
	CHString			chsMsg;
	VARIANT				varMap, 
						varValue, 
						varLen;
	VariantInit(&varMap);
	VariantInit(&varValue);
	VariantInit(&varLen);
	BSTRMAP theMap = rParsedInfo.GetCmdSwitchesObject().GetParameterMap();
	BSTRMAP::iterator theIterator = theMap.begin();
	DWORD dwThreadId = GetCurrentThreadId();
	
	try
	{
		// Obtain the class schema
		hr = m_pITargetNS->GetObject(bstrClass,                           
						WBEM_FLAG_RETURN_WBEM_COMPLETE | 
						WBEM_FLAG_USE_AMENDED_QUALIFIERS,
							NULL,                        
							&pIObject,    
							NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
		  chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", "
			L"WBEM_FLAG_RETURN_WBEM_COMPLETE|WBEM_FLAG_USE_AMENDED_QUALIFIERS,"
			L" 0, NULL, -)", (LPWSTR) bstrClass);		
		  WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
			  rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Loop through the list of available properties.
		while (theIterator != theMap.end())
		{
			// Get the property name and the corresponding value.
			_bstr_t bstrProp	= _bstr_t((_TCHAR*)(*theIterator).first);
			WCHAR*	pszValue	= (LPWSTR)(*theIterator).second;
			
			// Check the value against the qualifier information
			bRet = CheckQualifierInfo(rParsedInfo, pIObject, 
										bstrProp, pszValue);
			if (bRet)
			{
				// A mapping between 'Values' and 'ValueMaps' is possible, 
				// hence update the parameter value to reflect the change.
				rParsedInfo.GetCmdSwitchesObject().
					UpdateParameterValue(bstrProp, _bstr_t(pszValue));
			}
			else
				break;
			theIterator++;
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIObject);
		SAFEIRELEASE(pIQualSet);
		VARIANTCLEAR(varMap);
		VARIANTCLEAR(varValue);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIObject);
		SAFEIRELEASE(pIQualSet);
		VARIANTCLEAR(varMap);
		VARIANTCLEAR(varValue);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :IsInteractive()
   Synopsis	         :Checks whether user has to be prompted for response
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo	 - reference to CParsedInfo class object.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsInteractive(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::IsInteractive(CParsedInfo& rParsedInfo)
{
	BOOL bInteractive = FALSE;

	// Get the status of /INTERACTIVE global switch.
	bInteractive = rParsedInfo.GetGlblSwitchesObject().
						GetInteractiveStatus();

	// If /NOINTERACTIVE specified at the verb level.
	if (rParsedInfo.GetCmdSwitchesObject().
					GetInteractiveMode() == NOINTERACTIVE)
	{
		bInteractive = FALSE;
	}
	else if (rParsedInfo.GetCmdSwitchesObject().
					GetInteractiveMode() == INTERACTIVE)
	{
		bInteractive = TRUE;
	}
	return bInteractive;
}

/*------------------------------------------------------------------------
   Name				 :CheckQualifierInfo
   Synopsis	         :Validates the parameter value specified against the 
					  parameter qualifiers for that parameter(i.e checking 
					  against the contents of following qualifiers if 
					  available:
					  1. MaxLen,
					  2. ValueMap
					  3. Values
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo	 - CParsedInfo object.
		pIMethodSign - input signature of the method.
		bstrParam	 - parameter name
		pszValue	 - new value.
   Output Parameter(s):
		pszValue	 - new value.
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :CheckQualifierInfo(rParsedInfo, pIMethodSign,
											bstrParam, pszValue)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::CheckQualifierInfo(CParsedInfo& rParsedInfo,
									  IWbemClassObject *pIObject,
									  _bstr_t bstrParam,
									  WCHAR*& pszValue)
{
	HRESULT				hr					= S_OK;
	IWbemQualifierSet	*pIQualSet			= NULL;
	BOOL				bRet				= TRUE;
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	VARIANT				varMap, 
						varValue,
						varLen;
	VariantInit(&varMap);
	VariantInit(&varValue);
	VariantInit(&varLen);
	
	try
	{
		BOOL bFound	= FALSE;
		
		// Obtain the property qualifier set for the parameter.
		hr= pIObject->GetPropertyQualifierSet(bstrParam, &pIQualSet);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IWbemClassObject::GetPropertyQualifierSet"
					L"(L\"%s\", -)", (LPWSTR) bstrParam);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
				dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Check whether the 'Maxlen' qualifier is applicable.
		pIQualSet->Get(_bstr_t(L"MaxLen"), 0, &varLen, NULL);
		if (varLen.vt != VT_EMPTY && varLen.vt != VT_NULL)
		{
			// If the property value length exceeds maximum length
			// allowed set the return value to FALSE
			if (lstrlen(pszValue) > varLen.lVal)
			{
				rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_VALUE_EXCEEDS_MAXLEN);
				bRet = FALSE;
			}
		}
		VARIANTCLEAR(varLen);

		if (bRet)
		{
			bool bValue = false;
			WMICLIINT iValue = GetNumber ( pszValue );
			if ( iValue && iValue != -1 )
			{
				bValue = true;
			}

			// Obtain the 'ValueMap' qualifier contents if present
			pIQualSet->Get(_bstr_t(L"ValueMap"), 0, &varMap, NULL);
			if (varMap.vt != VT_EMPTY && varMap.vt != VT_NULL)
			{
				// Get lower and upper bounds of Descriptions array
				LONG lUpper = 0, lLower = 0;
				hr = SafeArrayGetLBound(varMap.parray, varMap.parray->cDims, 
										&lLower);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				hr = SafeArrayGetUBound(varMap.parray, varMap.parray->cDims,
										&lUpper);
				if ( m_eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++) 
				{
					void* pv = NULL;
					hr = SafeArrayGetElement(varMap.parray, &lIndex, &pv);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					if ( bValue )
					{
						WMICLIINT ipv = GetNumber ( ( WCHAR* ) pv );
						if ( ipv != -1 )
						{
							if ( iValue == ipv )
							{
								_itow ( ipv, pszValue, 10);
								bFound = TRUE;
								break;
							}
						}
					}
					else
					{
						// Check whether the property value is available with the
						// value map entries.
						if (CompareTokens(pszValue, (_TCHAR*)pv))
						{
							bFound = TRUE;
							break;
						}
					}
				}
				bRet = bFound;
			}
			
			// If not found in the ValueMap
			if (!bRet || !bFound)
			{
				// Obtain the 'Values' qualifier contents if present
				pIQualSet->Get(_bstr_t(L"Values"), 0, &varValue, NULL);
				if (varValue.vt != VT_EMPTY && varValue.vt != VT_NULL)
				{
					// Get lower and upper bounds of Descriptions array
					LONG lUpper = 0, lLower = 0;
					hr = SafeArrayGetLBound(varValue.parray, 
							varValue.parray->cDims, &lLower);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					hr = SafeArrayGetUBound(varValue.parray, 
							varValue.parray->cDims,	&lUpper);
					if ( m_eloErrLogOpt )
					{
						chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
					}
					ONFAILTHROWERROR(hr);

					for (LONG lIndex = lLower; lIndex <= lUpper; lIndex++) 
					{
						void *pv = NULL;
						hr = SafeArrayGetElement(varValue.parray, 
								&lIndex, &pv);
						if ( m_eloErrLogOpt )
						{
							chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
							 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, FALSE);
						}
						ONFAILTHROWERROR(hr);

						// Check for any matching entry.
						if (CompareTokens(pszValue, (_TCHAR*)pv))
						{
							void* pmv = NULL;
							if (varMap.vt != VT_EMPTY && varMap.vt != VT_NULL)
							{
								// obtain the correponding ValueMap entry.
								hr = SafeArrayGetElement(varMap.parray, 
										&lIndex, &pmv);
								if ( m_eloErrLogOpt )
								{
									chsMsg.Format(
										L"SafeArrayGetElement(-, -, -)"); 
									WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										(LPCWSTR)chsMsg, dwThreadId, 
										rParsedInfo, FALSE);
								}
								ONFAILTHROWERROR(hr);

								if ( bValue )
								{
									WMICLIINT ipmv = GetNumber ( (WCHAR*)pmv );
									_itow ( ipmv, pszValue, 10);
								}
								else
								{
									// Modify the current property value 
									// (i.e 'Values' to 'ValueMap' content)
									lstrcpy(pszValue, ((_TCHAR*)pmv));
								}
							}
							// Only 'Values' qualifier available
							else
							{
								_TCHAR szTemp[BUFFER255] = NULL_STRING;
								_itot(lIndex, szTemp, 10);
								// Modify the current property value 
								// (i.e 'Values' entry to index)
								lstrcpy(pszValue, szTemp);
							}

							bFound = TRUE;
							break;
						}

					}
					// If not match found in 'ValueMap' and 'Values' qualifier
					// list
					if (!bFound)
					{
						rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_VALUE_NOTFOUND);
					}
					bRet = bFound;
				}
			}	
			VARIANTCLEAR(varValue);
			VARIANTCLEAR(varMap);
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIQualSet);
		VARIANTCLEAR(varMap);
		VARIANTCLEAR(varValue);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIQualSet);
		VARIANTCLEAR(varMap);
		VARIANTCLEAR(varValue);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :ValidateAlaisInParams
   Synopsis	         :Validates the property value specified against the 
					  property qualifiers available for that property 
					  from the <alias> definition (i.e checking 
					  against the contents of following qualifiers if 
					  available:
					  1. MaxLen,
					  2. ValueMap
					  3. Values
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo	 - reference to CParsedInfo object.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ValidateAlaisInParams(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::ValidateAlaisInParams(CParsedInfo& rParsedInfo)
{
	BOOL				bRet				= TRUE;
	//_TCHAR				szMsg[BUFFER1024]	= NULL_STRING;
	BSTRMAP				theParamMap;
	BSTRMAP::iterator	theIterator			= NULL;
	DWORD				dwThreadId			= GetCurrentThreadId();
	PROPDETMAP			pdmPropDetMap;

	// Get the property details map.
	pdmPropDetMap = rParsedInfo.GetCmdSwitchesObject().GetPropDetMap();

	// If the property details are available
	if (!pdmPropDetMap.empty())
	{
		// Get the parameters map
		theParamMap = rParsedInfo.GetCmdSwitchesObject().GetParameterMap();
		theIterator = theParamMap.begin();


		try
		{
			// Loop through the list of available parameters
			while (theIterator != theParamMap.end())
			{
				// Get the property name and the corresponding value.
				_bstr_t bstrProp	= _bstr_t((_TCHAR*)(*theIterator).first);
				WCHAR*	pszValue	= (LPWSTR)(*theIterator).second;
				
				// Check the value against the qualifier information
				bRet = CheckAliasQualifierInfo(rParsedInfo, bstrProp, 
									pszValue, pdmPropDetMap);
				if (bRet)
				{
					// A mapping between 'Values' and 'ValueMaps' is possible, 
					// hence update the parameter value to reflect the change.
					rParsedInfo.GetCmdSwitchesObject().
						UpdateParameterValue(bstrProp, _bstr_t(pszValue));
				}
				else
					break;
				theIterator++;
			}
		}
		catch(_com_error& e)
		{
			_com_issue_error(e.Error());
			bRet = FALSE;
		}
		catch(...)
		{
			bRet = FALSE;
		}
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :CheckAliasQualifierInfo
   Synopsis	         :Validates the parameter value specified against the 
					  parameter qualifiers for that parameter from the 
					  <alias> definition (i.e checking 
					  against the contents of following qualifiers if 
					  available:
					  1. MaxLen,
					  2. ValueMap
					  3. Values
   Type	             :Member Function 
   Input Parameter(s):
		rParsedinfo		- CParsedInfo object.
		bstrParam		- parameter name
		pszValue		- new value.
		pdmPropDetMap	- property details map
   Output Parameter(s):
		pszValue	 - new value
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :CheckAliasQualifierInfo(rParsedInfo, bstrParam, 
											pszValue, pdmPropDetMap)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CExecEngine::CheckAliasQualifierInfo(CParsedInfo& rParsedInfo,
												_bstr_t bstrParam,
												WCHAR*& pszValue,
												PROPDETMAP pdmPropDetMap)
{
	BOOL						bRet				= TRUE,
								bFound				= FALSE;
	PROPDETMAP::iterator		propItrtrStart		= NULL;
	PROPDETMAP::iterator		propItrtrEnd		= NULL;

	QUALDETMAP					qualMap;
	QUALDETMAP::iterator		qualDetMap			= NULL;

	BSTRVECTOR::iterator		qualEntriesStart	= NULL;
	BSTRVECTOR::iterator		qualEntriesEnd		= NULL;
	BSTRVECTOR					qualVMEntries;
	BSTRVECTOR					qualVEntries;
	BSTRVECTOR					qualMEntries;

	propItrtrStart	= pdmPropDetMap.begin();
	propItrtrEnd	= pdmPropDetMap.end();

	try
	{
		while (propItrtrStart != propItrtrEnd)
		{	
			// If the property is found.
			if (CompareTokens( (LPWSTR)bstrParam, 
					((LPWSTR)(*propItrtrStart).first) ))
			{
				// Get the qualifier map
				qualMap = ((*propItrtrStart).second).QualDetMap;
				
				// Check if the qualifier information is available.
				if (!qualMap.empty())
				{
					// Check for the 'MaxLen' qualifier
					qualDetMap = qualMap.find(_bstr_t(L"MaxLen"));

					// If MaxLen qualifier information is available.
					if (qualDetMap != qualMap.end())
					{
						qualMEntries = (*qualDetMap).second;

						BSTRVECTOR::reference qualRef = qualMEntries.at(0);
						if (lstrlen(pszValue) > _wtoi((LPWSTR)qualRef))
						{
							rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_VALUE_EXCEEDS_MAXLEN);
							bRet = FALSE;
						}
					}
					
					if (bRet)
					{
						WMICLIINT iValue = 0;

						bool bValue = false;
						bool bNumber = true;

						VARTYPE vt = ReturnVarType ( (_TCHAR*) ((*propItrtrStart).second).Type );
						if	(
								vt == VT_I1 || 
								vt == VT_I2 || 
								vt == VT_I4 || 
								vt == VT_R4 || 
								vt == VT_R8 || 
								vt == VT_UI1 || 
								vt == VT_UI2 || 
								vt == VT_UI4 || 
								vt == VT_INT || 
								vt == VT_UINT
							)
						{
							iValue = GetNumber ( pszValue );
							if ( iValue == -1 )
							{
								bNumber = false;
							}
							bValue = true;
						}

						// Check for the 'ValueMap' qualfiers
						qualDetMap = qualMap.find(_bstr_t(L"ValueMap"));

						// If 'ValueMap' qualifier information is available.
						if (qualDetMap  != qualMap.end())
						{
							// Get the qualifier entries vector
							qualVMEntries		= (*qualDetMap ).second;
							qualEntriesStart	= qualVMEntries.begin();
							qualEntriesEnd		= qualVMEntries.end();

							if ( bNumber )
							{
								// Loop thru the available 'ValueMap' entries.
								while (qualEntriesStart != qualEntriesEnd)
								{
									if	( bValue )
									{
										WMICLIINT iqualEntriesStart = GetNumber ( ( WCHAR* ) (*qualEntriesStart) );
										if ( iqualEntriesStart != -1 )
										{
											if ( iValue == iqualEntriesStart )
											{
												_itow ( iqualEntriesStart, pszValue, 10);
												bFound = TRUE;
												break;
											}
										}
									}
									else
									{
										// Check whether the property value is 
										// available with the value map entries.
										if (CompareTokens(pszValue, 
														(_TCHAR*)(*qualEntriesStart)))
										{
											bFound = TRUE;
											break;
										}
									}
									
									// Move to next entry
									qualEntriesStart++;
								}
								bRet = bFound;
							}
						}

						// If not found in the 'ValueMap' entries
						if (!bRet || !bFound)
						{
							// Check for the 'Values' qualfiers
							qualDetMap = qualMap.find(_bstr_t(L"Values"));

							// If 'Values' qualifier information is available.
							if (qualDetMap != qualMap.end())
							{
								// Get the qualifier entries vector
								qualVEntries		= (*qualDetMap).second;
								qualEntriesStart	= qualVEntries.begin();
								qualEntriesEnd		= qualVEntries.end();

								WMICLIINT nLoop = 0;
								// Loop thru the available 'Values' entries.
								while (qualEntriesStart != qualEntriesEnd)
								{
									// Check whether the property value is 
									// available with the value map entries.
									if (CompareTokens(pszValue, 
												(_TCHAR*)(*qualEntriesStart)))
									{
										// If 'ValueMap' entries are available.
										if (!qualVMEntries.empty())
										{
											//Get corresponding entry from 
											//'ValueMap'
											BSTRVECTOR::reference qualRef = 
													qualVMEntries.at(nLoop);

											if ( bValue )
											{
												WMICLIINT iqualRef = GetNumber ( (WCHAR*)(qualRef) );
												_itow ( iqualRef, pszValue, 10);
											}
											else
											{
												lstrcpy(pszValue, (_TCHAR*)(qualRef));
											}
										}
										bFound = TRUE;
										break;
									}
									
									// Move to next entry
									qualEntriesStart++;
									nLoop++;
								}
								// If match not found in 'ValueMap' and 
								// 'Values' qualifier entries  list
								if (!bFound)
								{
									rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(IDS_E_VALUE_NOTFOUND);
								}
								bRet = bFound;
							}
						}
					}
				}	
				break;
			}
			else
				propItrtrStart++;
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
		bRet = FALSE;
	}
	return bRet;
}
			
/*------------------------------------------------------------------------
   Name				 :SubstHashAndExecCmdUtility
   Synopsis	         :Substitute hashes and execute command line utility.
					  If pIWbemObj != NULL then utility should be passed 
					  with appropriate instance values.
   Type	             :Member Function 
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo object.
		pIWbemObj	 - pointer to object of type IWbemClassObject. 
   Output Parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SubstHashAndExecCmdUtility(rParsedInfo, pIWbemObj) 
   Notes             :None
------------------------------------------------------------------------*/
void CExecEngine::SubstHashAndExecCmdUtility(CParsedInfo& rParsedInfo, 
											 IWbemClassObject *pIWbemObj)
{
	size_t				nHashPos	= 0;
	size_t				nAfterVarSpacePos = 0;
	LONG				lHashLen	= lstrlen(CLI_TOKEN_HASH);
	LONG				lSpaceLen	= lstrlen(CLI_TOKEN_SPACE);
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	HRESULT				hr					= S_OK;
	BOOL				bSubstituted		= FALSE;
	VARIANT vtInstanceValue;
	VARIANT vtPath;
		
	try
	{
		_bstr_t				bstrResult;
		_bstr_t bstrVerbDerivation =
				  _bstr_t(rParsedInfo.GetCmdSwitchesObject().
					GetVerbDerivation());
		if ( bstrVerbDerivation == _bstr_t(CLI_TOKEN_NULL) )
			bstrVerbDerivation = CLI_TOKEN_SPACE;

		STRING	strCmdLine(bstrVerbDerivation);

		BOOL bNamedParamList = rParsedInfo.GetCmdSwitchesObject().
										  GetNamedParamListFlag();

		// If NamedParamList is specified param=values are in Parameter map
		// Order them as appear in alias verb parameter definition and put
		// them in to cvInParams for further processing.
		CHARVECTOR cvInParams;
		if ( bNamedParamList == TRUE )
			ObtainInParamsFromParameterMap(rParsedInfo, cvInParams);
		else // else params are available in property list.
			cvInParams = rParsedInfo.GetCmdSwitchesObject().GetPropertyList();

		CHARVECTOR::iterator theActParamIterator = NULL;
		try
		{
			// Loop initialization.
			theActParamIterator = cvInParams.begin();

			while( TRUE )
			{
				// Loop condition.
				if (theActParamIterator == cvInParams.end())
					break;

				bSubstituted = FALSE;
				
				while ( bSubstituted == FALSE )
				{
					nHashPos = strCmdLine.find(CLI_TOKEN_HASH, 
								nHashPos, lHashLen);
					if ( nHashPos != STRING::npos )
					{
						// No instance specified.
						if ( pIWbemObj == NULL )
						{
							strCmdLine.replace(nHashPos, lHashLen,
									*theActParamIterator);
							nHashPos = nHashPos + lstrlen(*theActParamIterator);
							bSubstituted = TRUE;
						}
						else
						{
							if ( strCmdLine.compare(nHashPos + 1, 
													lSpaceLen, 
													CLI_TOKEN_SPACE) == 0 ||
								 strCmdLine.compare(nHashPos + 1,
											lstrlen(CLI_TOKEN_SINGLE_QUOTE), 
											CLI_TOKEN_SINGLE_QUOTE) == 0 )
							{
								strCmdLine.replace(nHashPos, lHashLen, 
										*theActParamIterator);
								nHashPos = nHashPos + 
											lstrlen(*theActParamIterator);
								bSubstituted = TRUE;
							}
							else
							{
								nAfterVarSpacePos = 
										strCmdLine.find(
											CLI_TOKEN_SPACE, nHashPos + 1,
											lSpaceLen);
								if ( nAfterVarSpacePos == STRING::npos )
								{
									strCmdLine.replace(nHashPos, 
										lHashLen, *theActParamIterator);
									nHashPos = nHashPos + 
											lstrlen(*theActParamIterator);
									bSubstituted = TRUE;
								}
							}
						}
					}
					else
					{
						strCmdLine.append(_T(" "));
						strCmdLine.append(*theActParamIterator);
						bSubstituted = TRUE;
					}

					if ( bSubstituted == FALSE )
						nHashPos = nHashPos + lHashLen;
				}
				
				// Loop expression.
				theActParamIterator++;
			}

			if ( pIWbemObj != NULL )
			{
				// Replacing #Variable parameters
				nHashPos	= 0;

				while ( TRUE )
				{
					nHashPos = strCmdLine.find(CLI_TOKEN_HASH, nHashPos, 
						lHashLen);
					if ( nHashPos == STRING::npos )
						break;

					nAfterVarSpacePos = 
									strCmdLine.find(CLI_TOKEN_SPACE, 
									nHashPos + 1, lSpaceLen);
					if ( nAfterVarSpacePos == STRING::npos )
						break;

					_bstr_t bstrPropName(strCmdLine.substr(nHashPos + 1,
							  nAfterVarSpacePos -  (nHashPos + 1)).data());
					VariantInit(&vtInstanceValue);
					hr = pIWbemObj->Get(bstrPropName, 0, 
									&vtInstanceValue, 0, 0);

					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IWbemClassObject::Get(%s, 0, "
							L"-, 0, 0)", (LPWSTR)bstrPropName);
						GetBstrTFromVariant(vtInstanceValue, bstrResult);
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
								(LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, m_bTrace, 0, bstrResult);
					}
					ONFAILTHROWERROR(hr);

					_bstr_t bstrInstanceValue;
					GetBstrTFromVariant(vtInstanceValue, bstrInstanceValue);

					strCmdLine.replace(nHashPos, nAfterVarSpacePos - nHashPos , 
										bstrInstanceValue);
					nHashPos = nHashPos + lstrlen(bstrInstanceValue);

					VARIANTCLEAR(vtInstanceValue);
				}
				
				VariantInit(&vtPath);
				hr = pIWbemObj->Get(L"__PATH", 0, &vtPath, 0, 0);

				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"__PATH\", 0, "
						L"-, 0, 0)"); 
					GetBstrTFromVariant(vtPath, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace, 0, bstrResult);
				}
				ONFAILTHROWERROR(hr);
			}

			INTEROPTION	interInvoke	= YES;
			_TCHAR szMsg[BUFFER1024] = NULL_STRING;

			// Get the user response if interactive mode is set
			if (IsInteractive(rParsedInfo) == TRUE)
			{
				_bstr_t bstrMsg;
				if ( pIWbemObj != NULL )
				{
					WMIFormatMessage(IDS_I_METH_INVOKE_PROMPT1, 2, bstrMsg,
							 (LPWSTR)vtPath.bstrVal, 
							 (LPWSTR)strCmdLine.data());
				}
				else
				{
					WMIFormatMessage(IDS_I_METH_INVOKE_PROMPT2, 1, bstrMsg,
							  (LPWSTR)strCmdLine.data());
				}
				interInvoke = GetUserResponse((LPWSTR)bstrMsg);
			}

			if ( interInvoke == YES )
			{
				DisplayMessage(L"\n", CP_OEMCP, FALSE, TRUE);
				BOOL bResult = _tsystem(strCmdLine.data());
				DisplayMessage(L"\n", CP_OEMCP, FALSE, TRUE);
			}
			VARIANTCLEAR(vtPath);
		}
		catch(_com_error& e)
		{
			VARIANTCLEAR(vtInstanceValue);
			VARIANTCLEAR(vtPath);
			rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*------------------------------------------------------------------------
   Name				 :FormQueryAndExecuteMethodOrUtility
   Synopsis	         :Forms query and executes method or command line 
					  utility.
   Type	             :Member Function 
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo object.
		pIInParam	 - pointer to object of type IWbemClassObject. 
   Output Parameter(s):None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :FormQueryAndExecuteMethodOrUtility(rParsedInfo, pIInParam) 
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CExecEngine::FormQueryAndExecuteMethodOrUtility(
										CParsedInfo& rParsedInfo,
										IWbemClassObject *pIInParam)
{
	HRESULT					hr					= S_OK;
	IEnumWbemClassObject	*pIEnumObj			= NULL;
	IWbemClassObject		*pIWbemObj			= NULL;
	CHString				chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	
	try
	{
		_bstr_t		bstrResult("");
		_bstr_t		bstrPath("");
		BOOL		bWhereExpr = FALSE;

		// If PATH specified
		if (rParsedInfo.GetCmdSwitchesObject().GetPathExpression() != NULL)
		{
			if(rParsedInfo.GetCmdSwitchesObject().
						GetWhereExpression() != NULL)
			{
				bWhereExpr = TRUE;
			}
			else
				bstrPath = _bstr_t(rParsedInfo.GetCmdSwitchesObject()
												.GetPathExpression());
		}
		else
		{
			// If CLASS specfied
			if (rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL)
			{
				bstrPath = _bstr_t(rParsedInfo.GetCmdSwitchesObject().
										GetClassPath());
			}
			else if(rParsedInfo.GetCmdSwitchesObject().
						GetWhereExpression() != NULL)
			{
				bWhereExpr = TRUE;
			}
			else
				rParsedInfo.GetCmdSwitchesObject().
							GetClassOfAliasTarget(bstrPath);
		}

		// If bstrPath is not empty
		if ( !bWhereExpr )
		{
			if ( rParsedInfo.GetCmdSwitchesObject().GetVerbType() == CMDLINE )
			{
				SubstHashAndExecCmdUtility(rParsedInfo);
			}
			else
			{
				hr = ExecuteMethodAndDisplayResults(bstrPath, rParsedInfo,
													pIInParam);
			}
			ONFAILTHROWERROR(hr);
		}
		else
		{
			ULONG	ulReturned = 0;
			_bstr_t bstrQuery;

			// Frame the WMI query to be executed.
			if (rParsedInfo.GetCmdSwitchesObject().
								GetPathExpression() != NULL)
			{
				bstrPath = _bstr_t(rParsedInfo.
								GetCmdSwitchesObject().GetClassPath());
			}
			else
			{
				rParsedInfo.GetCmdSwitchesObject()
							.GetClassOfAliasTarget(bstrPath);
			}
			
			bstrQuery = _bstr_t("SELECT * FROM ") +	bstrPath; 
			if(rParsedInfo.GetCmdSwitchesObject().
								GetWhereExpression() != NULL)
			{
				bstrQuery += _bstr_t(" WHERE ") 
							 + _bstr_t(rParsedInfo.GetCmdSwitchesObject().
									GetWhereExpression());
			}
			
			hr = m_pITargetNS->ExecQuery(_bstr_t(L"WQL"), bstrQuery,
										WBEM_FLAG_FORWARD_ONLY |
										WBEM_FLAG_RETURN_IMMEDIATELY, 
										NULL, &pIEnumObj);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::ExecQuery(L\"WQL\"," 
							L" L\"%s\", 0, NULL, -)", (LPWSTR)bstrQuery);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			// Set the interface security
			hr = SetSecurity(pIEnumObj, 
					rParsedInfo.GetAuthorityPrinciple(),
					rParsedInfo.GetNode(),
					rParsedInfo.GetUser(),
					rParsedInfo.GetPassword(),
					rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
					rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());
			if (m_bTrace || m_eloErrLogOpt)
			{
				_TCHAR* pszAuthority = rParsedInfo.GetAuthorityPrinciple();

				if( pszAuthority != NULL &&
					_tcslen(pszAuthority) > 9 &&
					_tcsnicmp(pszAuthority, _T("KERBEROS:"), 9) == 0)
				{

					BSTR	bstrPrincipalName = ::SysAllocString(&pszAuthority[9]);

					chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_GSS_KERBEROS,"
							L"RPC_C_AUTHZ_NONE, %s, %d,   %d, -, EOAC_NONE)",
							(LPWSTR)bstrPrincipalName,	
							rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
							rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());

					SAFEBSTRFREE(bstrPrincipalName);
				}
				else
				{
					chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
						L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, EOAC_NONE)",
						rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
						rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());
				}
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			BOOL bNoInstances = TRUE;

			// Loop thru the available instances
			while (((hr = pIEnumObj->Next( WBEM_INFINITE, 1, 
					&pIWbemObj, &ulReturned )) == S_OK) 
					&& (ulReturned == 1))
 			{
				bNoInstances = FALSE;
				VARIANT vtPath;
				VariantInit(&vtPath);
				hr = pIWbemObj->Get(L"__PATH", 0, &vtPath, 0, 0);

				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IWbemClassObject::Get(L\"__PATH\", 0, "
						L"-, 0, 0)"); 
					GetBstrTFromVariant(vtPath, bstrResult);
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace, 0, bstrResult);
				}
				ONFAILTHROWERROR(hr);

				if ( vtPath.vt == VT_BSTR )
				{
					if ( rParsedInfo.GetCmdSwitchesObject().GetVerbType() 
							== CMDLINE )
					{
						SubstHashAndExecCmdUtility(rParsedInfo, pIWbemObj);
					}
					else
					{
						hr = ExecuteMethodAndDisplayResults(vtPath.bstrVal,
							rParsedInfo, pIInParam);
					}
					ONFAILTHROWERROR(hr);
				}
				VariantClear(&vtPath);
				SAFEIRELEASE(pIWbemObj);
			}
			// If next fails.
			ONFAILTHROWERROR(hr);

			SAFEIRELEASE(pIEnumObj);

			// If no instances are available
			if ( bNoInstances == TRUE )
			{
				rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_NO_INSTANCES);
			}
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIEnumObj);
		SAFEIRELEASE(pIWbemObj);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ExtractClassNameandWhereExpr
   Synopsis	         :This function takes the input as a path expression and 
					  extracts the Class and Where expression part from the 
					  path expression.
   Type	             :Member Function
   Input Parameter(s):
		pszPathExpr  - the path expression
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
		pszWhere	 -  the Where expression
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ExtractClassNameandWhereExpr(pszPathExpr, rParsedInfo,
							pszWhere)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CExecEngine::ExtractClassNameandWhereExpr(_TCHAR* pszPathExpr, 
												 CParsedInfo& rParsedInfo,
												 _TCHAR* pszWhere)
{
	// Frame the class name and where expression based on the object path
	BOOL	bRet					= TRUE;
	_TCHAR* pszToken				= NULL;
	BOOL	bFirst					= TRUE;
	_TCHAR	pszPath[MAX_BUFFER]		= NULL_STRING;

	if (pszPathExpr == NULL || pszWhere == NULL)
		bRet = FALSE;

	try
	{
		if ( bRet == TRUE )
		{
			lstrcpy(pszPath, pszPathExpr);
			lstrcpy(pszWhere, CLI_TOKEN_NULL);
			pszToken = _tcstok(pszPath, CLI_TOKEN_DOT);
			if (pszToken != NULL)
			{
				if(CompareTokens(pszToken, pszPathExpr))
					bRet = FALSE;
			}

			while (pszToken != NULL)
			{
				pszToken = _tcstok(NULL, CLI_TOKEN_COMMA); 
				if (pszToken != NULL)
				{
					if (!bFirst)
						lstrcat(pszWhere, CLI_TOKEN_AND);
					lstrcat(pszWhere, pszToken);
					bFirst = FALSE;
				}
				else
					break;
			}
		}
	}
	catch(...)
	{
		rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_PATH);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :GetUserResponseEx
   Synopsis	         :This function accepts the user response before going
					  ahead, when /INTERACTIVE is specified at the verb 
					  level
   Type	             :Member Function
   Input parameter   :
			pszMsg	 - message to be displayed.
   Output parameters :None
   Return Type       :INTEROPTION
   Global Variables  :None
   Calling Syntax    :GetUserResponseEx(pszMsg)
   Notes             :None
------------------------------------------------------------------------*/
INTEROPTION CExecEngine::GetUserResponseEx(_TCHAR* pszMsg)
{
	INTEROPTION	bRet			= YES;
	_TCHAR szResp[BUFFER255]	= NULL_STRING;
	_TCHAR *pBuf				= NULL;

	if (pszMsg == NULL)
		bRet = NO;

	if(bRet != NO)
	{
		// Get the user response, till 'Y' - yes or 'N' - no
		// is keyed in
		while(TRUE)
		{
			DisplayMessage(pszMsg, CP_OEMCP, TRUE, TRUE);
			pBuf = _fgetts(szResp, BUFFER255-1, stdin);
			if(pBuf != NULL)
			{
				LONG lInStrLen = lstrlen(szResp);
				if(szResp[lInStrLen - 1] == _T('\n'))
						szResp[lInStrLen - 1] = _T('\0');
			}
			else if ( g_wmiCmd.GetBreakEvent() != TRUE )
			{
				lstrcpy(szResp, RESPONSE_NO);
				DisplayMessage(_T("\n"), CP_OEMCP, TRUE, TRUE);
			}

			if ( g_wmiCmd.GetBreakEvent() == TRUE )
			{
				g_wmiCmd.SetBreakEvent(FALSE);
				lstrcpy(szResp, RESPONSE_NO);
				DisplayMessage(_T("\n"), CP_OEMCP, TRUE, TRUE);
			}
			if (CompareTokens(szResp, RESPONSE_YES)
				|| CompareTokens(szResp, RESPONSE_NO)
				|| CompareTokens(szResp, RESPONSE_HELP))
				break;
		}
		if (CompareTokens(szResp, RESPONSE_NO))
			bRet = NO;
		else if (CompareTokens(szResp, RESPONSE_YES))
			bRet = YES;
		else if (CompareTokens(szResp, RESPONSE_HELP))
			bRet = HELP;
	}

	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainInParamsFromParameterMap
   Synopsis	         :This function obtains param values from parameter map 
					  in the same order as they appear in the alias verb 
					  definition.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo		- reference to CParsedInfo object
   Output Parameter(s):
		cvParamValues	- reference to parameter values vector
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :ObtainInParamsFromParameterMap(rParsedInfo, cvParamValues)
   Notes             :None
----------------------------------------------------------------------------*/
void CExecEngine::ObtainInParamsFromParameterMap(CParsedInfo& rParsedInfo, 
												 CHARVECTOR& cvParamValues)
{
	PROPDETMAP pdmVerbParamsFromAliasDef = (*(rParsedInfo.
											GetCmdSwitchesObject().
											GetMethDetMap().begin())).
											second.Params;
	PROPDETMAP::iterator itrVerbParams;

	BSTRMAP bmNamedParamList = rParsedInfo.GetCmdSwitchesObject().
															GetParameterMap();
	BSTRMAP::iterator itrNamedParamList;

	try
	{
		for ( itrVerbParams = pdmVerbParamsFromAliasDef.begin();
			  itrVerbParams != pdmVerbParamsFromAliasDef.end();	
			  itrVerbParams++ )
		{
			_TCHAR* pszVerbParamName = (*itrVerbParams).first;
			// To remove numbers from Names.
			pszVerbParamName = pszVerbParamName + 5;

			if ( Find(bmNamedParamList, pszVerbParamName, itrNamedParamList)
																	 == TRUE)
			{
				cvParamValues.push_back(_bstr_t((*itrNamedParamList).second));
			}
			else
			{
				cvParamValues.push_back(
						_bstr_t(((*itrVerbParams).second).Default));
			}
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*----------------------------------------------------------------------------
   Name				 :FrameAssocHeader
   Synopsis	         :This function frames the XML header to be used with 
					  the ASSOCIATORS output 
   Type	             :Member Function
   Input Parameter(s):
		bstrPath  - object/class path
		bClass	  - TRUE	- Indicates class level associators header
					FALSE	- Indicates instance level associators header
   Output Parameter(s):
   		bstrFrag  - fragment string
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :FrameAssocHeader(bstrPath, bstrFrag, bClass)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT CExecEngine::FrameAssocHeader(_bstr_t bstrPath, _bstr_t& bstrFrag, 
									  BOOL bClass)
{
	HRESULT				hr			= S_OK;
	IWbemClassObject	*pIObject	= NULL;
	try
	{
		_variant_t		vClass,		vSClass,	vPath, 
						vOrigin,	vType;
		_bstr_t			bstrProp;
		CHString		szBuf;

		// Get the Class/instance information.
		hr = m_pITargetNS->GetObject(bstrPath, WBEM_FLAG_USE_AMENDED_QUALIFIERS, 
						NULL, &pIObject, NULL);
		ONFAILTHROWERROR(hr);

		// Get the __CLASS property value
		bstrProp = L"__CLASS"; 
		hr = pIObject->Get(bstrProp, 0, &vClass, 0, 0);
		ONFAILTHROWERROR(hr);
		
		// Get the __PATH property value
		bstrProp = L"__PATH";
		hr = pIObject->Get(bstrProp, 0, &vPath, 0, 0);
		ONFAILTHROWERROR(hr);

		// If CLASS level associators required 
		if (bClass)
		{
			// Get the __SUPERCLASS property value
			bstrProp = L"__SUPERCLASS";
			hr = pIObject->Get(bstrProp, 0, &vSClass, NULL, NULL);
			ONFAILTHROWERROR(hr);

			szBuf.Format(_T("<CLASS NAME=\"%s\" SUPERCLASS=\"%s\"><PROPERTY "
					L"NAME=\"__PATH\" CLASSORIGIN=\"__SYSTEM\" TYPE=\"string\">"
					L"<VALUE><![CDATA[%s]]></VALUE></PROPERTY>"),
					(vClass.vt != VT_NULL && (LPWSTR)vClass.bstrVal) 
					? (LPWSTR)vClass.bstrVal : L"N/A", 
					(vSClass.vt != VT_NULL && (LPWSTR)vSClass.bstrVal)
					? (LPWSTR)vSClass.bstrVal : L"N/A",
					(vPath.vt != VT_NULL && (LPWSTR)vPath.bstrVal)
					? (LPWSTR)vPath.bstrVal : L"N/A");
		}
		else
		{
			szBuf.Format(
				_T("<INSTANCE CLASSNAME=\"%s\"><PROPERTY NAME=\"__PATH\""
					L" CLASSORIGIN=\"__SYSTEM\" TYPE=\"string\"><VALUE><![CDATA[%s]]>"
					L"</VALUE></PROPERTY>"),
					(vClass.vt != VT_NULL && (LPWSTR)vClass.bstrVal)
					? (LPWSTR)vClass.bstrVal : L"N/A",
					(vPath.vt != VT_NULL && (LPWSTR)vPath.bstrVal)
					? (LPWSTR)vPath.bstrVal : L"N/A");
		}
		SAFEIRELEASE(pIObject);
		bstrFrag = _bstr_t(szBuf);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIObject);
		hr = e.Error();
	}
	// trap for CHeap_Exception
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIObject);
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\errorlog.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ErrorLog.cpp 
Project Name				: WMI Command Line
Author Name					: C. V. Nandi
Date of Creation (dd/mm/yy) : 11th-January-2001
Version Number				: 1.0 
Brief Description			: This file has all the global function definitions 
Revision History			:
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date  : 12th-January-2001
*****************************************************************************/ 
// ErrorLog.cpp : implementation file
#include "Precomp.h"
#include "ErrorLog.h"

/*------------------------------------------------------------------------
   Name				 :CErrorLog
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CErrorLog::CErrorLog()
{
	m_eloErrLogOpt		= NO_LOGGING;
	m_pszLogDir			= NULL;
	m_bGetErrLogInfo	= TRUE;
	m_bCreateLogFile	= TRUE;
	m_hLogFile			= NULL;
}

/*------------------------------------------------------------------------
   Name				 :~CErrorLog
   Synopsis	         :This function uninitializes the member variables 
					  when an object of the class type goes out of scope.
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type		 :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CErrorLog::~CErrorLog()
{
	SAFEDELETE(m_pszLogDir);
	if ( m_hLogFile )
		CloseHandle(m_hLogFile);
}

/*------------------------------------------------------------------------
   Name				 :GetErrLogInfo
   Synopsis	         :This function reads the following information from 
					  the registry:
					  1. LoggingMode and 
					  2. LogDirectory
   Type				 :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetErrLogInfo()
   Notes             :None
------------------------------------------------------------------------*/
void CErrorLog::GetErrLogInfo()
{
	HKEY hkKeyHandle = NULL;

	try
	{
		// Open the registry key
		if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
						   _T("SOFTWARE\\Microsoft\\Wbem\\CIMOM"), 0, 
						   KEY_QUERY_VALUE, &hkKeyHandle ) == ERROR_SUCCESS )
		{
			DWORD dwBufSize				= BUFFER512;
			TCHAR szKeyValue[BUFFER512] = NULL_STRING;
			_tcscpy(szKeyValue,CLI_TOKEN_NULL);

			// Query the "Logging" mode
			if ( RegQueryValueEx(hkKeyHandle, 
								 _T("Logging"), NULL, NULL,
								 (LPBYTE)szKeyValue, &dwBufSize) == ERROR_SUCCESS )
			{
				if ( !_tcsicmp(szKeyValue, CLI_TOKEN_ONE) )
					m_eloErrLogOpt = ERRORS_ONLY;
				else if ( !_tcsicmp(szKeyValue, CLI_TOKEN_TWO) )
					m_eloErrLogOpt = EVERY_OPERATION;
				else
					m_eloErrLogOpt = NO_LOGGING;
			}

			_TCHAR *pszKeyValue = NULL;

			// Query for the content length of the "Logging Directory"
			if ( RegQueryValueEx(hkKeyHandle, _T("Logging Directory"), NULL, 
						NULL, NULL, &dwBufSize) == ERROR_SUCCESS)
			{
				pszKeyValue = new _TCHAR [dwBufSize];
				if (pszKeyValue != NULL)
				{
					// Query the "Logging Directory"
					if ( RegQueryValueEx(hkKeyHandle, _T("Logging Directory"), 
									NULL, NULL, (LPBYTE)pszKeyValue, &dwBufSize) 
									== ERROR_SUCCESS)
					{
						SAFEDELETE(m_pszLogDir);
						m_pszLogDir = new _TCHAR [lstrlen(pszKeyValue) + 1];
						if (!m_pszLogDir)
						{
							SAFEDELETE(pszKeyValue);
							throw(OUT_OF_MEMORY);
						}
						lstrcpy(m_pszLogDir, pszKeyValue);
					}
					SAFEDELETE(pszKeyValue);
				}
			}

			// Query the "Log File Max Size"
			if ( RegQueryValueEx(hkKeyHandle, 
								 _T("Log File Max Size"), NULL, NULL,
								 (LPBYTE)szKeyValue, &dwBufSize) == ERROR_SUCCESS )
			{
				m_llLogFileMaxSize = _ttol(szKeyValue);
			}
			
			// Close the registry key
			RegCloseKey(hkKeyHandle);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetErrLogOption
   Synopsis	         :This function returns the logging mode
   Type				 :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :
			ERRLOGOPT - typdefined variable
   Global Variables  :None
   Calling Syntax    :GetErrLogOption()
   Notes             :None
------------------------------------------------------------------------*/
ERRLOGOPT CErrorLog::GetErrLogOption()
{
	if ( m_bGetErrLogInfo == TRUE )
	{
		GetErrLogInfo();
		m_bGetErrLogInfo = FALSE;
	}
	return m_eloErrLogOpt;
}

/*------------------------------------------------------------------------
   Name				 :CreateLogFile
   Synopsis	         :This function creates the WMIC.LOG file
   Type				 :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetErrLogOption()
   Notes             :None
------------------------------------------------------------------------*/
void CErrorLog::CreateLogFile() 
{
	DWORD	dwError = 0;
	try
	{
		if ( m_bGetErrLogInfo == TRUE )
		{
			GetErrLogInfo();
			m_bGetErrLogInfo = FALSE;
		}

		// Frame the file path.
		_bstr_t bstrFilePath = _bstr_t(m_pszLogDir);
		bstrFilePath += _bstr_t("WMIC.LOG");

		m_hLogFile = CreateFile(bstrFilePath, 
								GENERIC_READ |GENERIC_WRITE,
								FILE_SHARE_READ | FILE_SHARE_WRITE, 
								NULL, 
								OPEN_ALWAYS, 
								FILE_ATTRIBUTE_NORMAL, 
								NULL);

		// If handle is invalid.
		if (m_hLogFile == INVALID_HANDLE_VALUE)
		{
			dwError = ::GetLastError();
			::SetLastError(dwError);
			DisplayString(IDS_E_ERRLOG_OPENFAIL, CP_OEMCP, 
							NULL, TRUE, TRUE);
			::SetLastError(dwError);
			DisplayWin32Error();
			throw(dwError);
		}

		if ( SetFilePointer(m_hLogFile, 0, NULL, FILE_END) 
							== INVALID_SET_FILE_POINTER &&
					dwError != NO_ERROR )
		{
			dwError = ::GetLastError();
			::SetLastError(dwError);
			DisplayWin32Error();
			::SetLastError(dwError);
			throw(dwError);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :LogErrorOrOperation
   Synopsis	         :This function logs the error or operation result 
   Type				 :Member Function
   Input parameter   :
		hrErrNo			- HRESULT code
		pszFileName		- file name
		lLineNo			- line number
		pszFunName		- function name
		dwThreadId		- thread id
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetErrLogOption()
   Notes             :None
------------------------------------------------------------------------*/
void CErrorLog::LogErrorOrOperation(HRESULT hrErrNo, char* pszFileName, 
							LONG lLineNo, _TCHAR* pszFunName, 
							DWORD dwThreadId, DWORD dwError) 
{
	try
	{
		if ( pszFunName )
		{
			if ( (m_eloErrLogOpt == ERRORS_ONLY && FAILED(hrErrNo)) ||
				  m_eloErrLogOpt == EVERY_OPERATION )
			{
				if ( m_bCreateLogFile == TRUE )
				{
					CreateLogFile();
					m_bCreateLogFile = FALSE;
				}
				
				SYSTEMTIME stSysTime;
				GetLocalTime(&stSysTime);

				CHAR szDate[BUFFER32];
				sprintf(szDate, "%.2d/%.2d/%.4d", stSysTime.wMonth,
											stSysTime.wDay,
											stSysTime.wYear);

				CHAR szTime[BUFFER32];
				sprintf(szTime, "%.2d:%.2d:%.2d:%.3d", stSysTime.wHour,
											   stSysTime.wMinute,
											   stSysTime.wSecond,
											   stSysTime.wMilliseconds);

				CHString chsErrMsg;
				BOOL bWriteToFile = FALSE;
				if ( FAILED(hrErrNo) )
				{
					if (dwError)
					{
						chsErrMsg.Format( 
							  L"ERROR %s - FAILED! error# %d %s %s thread:%d [%s.%d]\r\n", 
									CHString(pszFunName),dwError,CHString(szDate),
									CHString(szTime), dwThreadId, 
									CHString(pszFileName), lLineNo);
					}
					else
					{
						chsErrMsg.Format( 
							  L"ERROR %s - FAILED! error# %x %s %s thread:%d [%s.%d]\r\n", 
								CHString(pszFunName), hrErrNo, CHString(szDate),
								CHString(szTime), dwThreadId, CHString(pszFileName),
								lLineNo);
					}
					bWriteToFile = TRUE;
				}
				else if (_tcsnicmp(pszFunName,_T("COMMAND:"),8) == 0)
				{
					chsErrMsg.Format( 
							  L"SUCCESS %s - Succeeded %s %s thread:%d [%s.%d]\r\n", 
									CHString(pszFunName), CHString(szDate), 
									CHString(szTime), dwThreadId,
									CHString(pszFileName),lLineNo);
					bWriteToFile = TRUE;
				}

				_bstr_t bstrErrMsg = _bstr_t((LPCWSTR)chsErrMsg);
				CHAR *szErrMsg = (CHAR*)bstrErrMsg;
				if ( bWriteToFile == TRUE && szErrMsg != NULL)
				{
					DWORD	dwNumberOfBytes = 0;
					
					LARGE_INTEGER liFileSize;
					if ( GetFileSizeEx(m_hLogFile, &liFileSize) == TRUE &&
						 (liFileSize.QuadPart + strlen(szErrMsg)) > 
															  m_llLogFileMaxSize )
					{
						// Frame the file path.
						_bstr_t bstrLogFilePath		= _bstr_t(m_pszLogDir);
						_bstr_t bstrCatalogFilePath = _bstr_t(m_pszLogDir);

						bstrLogFilePath		+= _bstr_t("WMIC.LOG");
						bstrCatalogFilePath += _bstr_t("WMIC.LO_");

						if(!CopyFile((LPTSTR)bstrLogFilePath, 
									(LPTSTR)bstrCatalogFilePath,      
									FALSE))
						{
							DWORD dwError = ::GetLastError();
							DisplayString(IDS_E_ERRLOG_WRITEFAIL, CP_OEMCP, 
									NULL, TRUE, TRUE);
							::SetLastError(dwError);
							DisplayWin32Error();
							::SetLastError(dwError);
							throw(dwError);
						}

						// close wmic.log
						if ( m_hLogFile )
						{
							CloseHandle(m_hLogFile);
							m_hLogFile = 0;
						}

						m_hLogFile = CreateFile(bstrLogFilePath, 
												GENERIC_READ |GENERIC_WRITE,
												FILE_SHARE_READ | FILE_SHARE_WRITE, 
												NULL, 
												CREATE_ALWAYS, 
												FILE_ATTRIBUTE_NORMAL, 
												NULL);

						// If handle is invalid.
						if (m_hLogFile == INVALID_HANDLE_VALUE)
						{
							dwError = ::GetLastError();
							::SetLastError(dwError);
							DisplayString(IDS_E_ERRLOG_OPENFAIL, CP_OEMCP, 
											NULL, TRUE, TRUE);
							::SetLastError(dwError);
							DisplayWin32Error();
							throw(dwError);
						}
					}

					if (!WriteFile(m_hLogFile, szErrMsg, strlen(szErrMsg), 
									&dwNumberOfBytes, NULL))
					{
						DWORD dwError = ::GetLastError();
						DisplayString(IDS_E_ERRLOG_WRITEFAIL, CP_OEMCP, 
								NULL, TRUE, TRUE);
						::SetLastError(dwError);
						DisplayWin32Error();
						::SetLastError(dwError);
						throw(dwError);
					}
				}
			}
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	catch(DWORD dwError)
	{
		throw (dwError);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\errorinfo.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ErrorInfo.h 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy
	Last Modified date		: 17th-January-2001
****************************************************************************/ 

/*-------------------------------------------------------------------
 Class Name			: CErrorInfo
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the error message support 
					  functionality needed by the Format Engine for
					  dislaying the WBEM error descriptions.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/
/////////////////////////////////////////////////////////////////////////////
// CErrorInfo
class CErrorInfo
{
public:
// Construction
	CErrorInfo();

// Destruction
	~CErrorInfo();

// Restrict Assignment
	CErrorInfo& operator=(CErrorInfo& rErrInfo);

private:
// Attributes
	IWbemStatusCodeText		*m_pIStatus;
	BOOL					m_bWMIErrSrc;
	_TCHAR					*m_pszErrStr;
		
// Operations
private:
	HRESULT					CreateStatusCodeObject();
	void					GetWbemErrorText(HRESULT hr, BOOL bXML, 
								_bstr_t& bstrErr, _bstr_t& bstrFacility);
	
public:
	void					Uninitialize();

	// Return the description & facility code string(s) corresponding to 
	// hr passed.
	void					GetErrorString(HRESULT hr, BOOL bTrace, 
									_bstr_t& bstrErrDesc,
									_bstr_t& bstrFacility); 

	// Frames the XML string for error info
	void					GetErrorFragment(HRESULT hr, _bstr_t& bstrError);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\errorlog.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ErrorLog.h 
Project Name				: WMI Command Line
Author Name					: C. V. Nandi 
Date of Creation (dd/mm/yy) : 11th-January-2001
Version Number				: 1.0 
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy
	Last Modified date		: 12th-January-2001
****************************************************************************/ 

/*-------------------------------------------------------------------
 Class Name			: CErrorLog
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the error logging support 
					  functionality needed by the wmic.exe for logging 
					  the errors, commands issues depending on Logging
					  key value available with the registry.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/
/////////////////////////////////////////////////////////////////////////////
// CErrorInfo

class CErrorLog
{
public:
//	Construction
	CErrorLog();

//	Destruction
	~CErrorLog();

//	Restrict Assignment
	CErrorLog& operator=(CErrorLog& rErrLog);

// Attributes
private:
	// typedef variable.
	ERRLOGOPT	m_eloErrLogOpt;

	_TCHAR*		m_pszLogDir;
	
	BOOL		m_bGetErrLogInfo;
	
	BOOL		m_bCreateLogFile;
	
	HANDLE		m_hLogFile;

	LONGLONG	m_llLogFileMaxSize;

// Operations
private:
	void		GetErrLogInfo();
	
	void		CreateLogFile();
public:
	ERRLOGOPT	GetErrLogOption();

	// Log the error, 
	void		LogErrorOrOperation(HRESULT hrErrNo, 
									char*	pszFileName, 
									LONG	lLineNo,	
									_TCHAR* pszFunName, 
									DWORD	dwThreadId,
									DWORD	dwError = 0); 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\formatengine.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-2002 Microsoft Corporation 
File Name					: FormatEngine.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: The Format Engine is primarily responsible for 
							  displaying the 
							  a) the data views for the management areas by 
							  using predefined XSL style sheets
							  b) the property update/method execution status 
							  c) error messages and 
							  d) display of usage information. It depends     
							  on the output of Parsing and/or Format Engine.
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 11th-April-2001
******************************************************************************/ 

// FormatEngine.cpp : implementation file
//
#include "Precomp.h"
#include "CommandSwitches.h"
#include "GlobalSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "ErrorInfo.h"
#include  "WMICliXMLLog.h"
#include "FormatEngine.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "WmiCmdLn.h"
#include "OutputStream.h"

/*------------------------------------------------------------------------
   Name				 :CFormatEngine
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated.
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CFormatEngine::CFormatEngine()
{
	m_pIXMLDoc				= NULL;
	m_pIXSLDoc				= NULL;
	m_bRecord				= FALSE;
	m_bTrace				= FALSE;
	m_bHelp					= FALSE;
	m_bGetOutOpt			= TRUE;
	m_bGetAppendFilePinter	= TRUE;
	m_bGetOutputFilePinter	= TRUE;
	m_bLog					= TRUE;
	m_bInteractiveHelp		= FALSE;
	m_bOutputGoingToStream	= FALSE;
}

/*------------------------------------------------------------------------
   Name				 :~CFormatEngine
   Synopsis	         :Destructor 
   Type	             :Destructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CFormatEngine::~CFormatEngine()
{
	Uninitialize(TRUE);
}

/*------------------------------------------------------------------------
   Name				 :CreateEmptyDocument
   Synopsis	         :Creates an empty XML Document and returns the same 
					  in Passed Parameter.
   Type	             :Member Function 
   Input parameter   :
   Output parameters :None
				pDoc - Pointer to pointer to IXMLDOMDocument2 Interface
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateEmptyDocument(&pIXMLDoc)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CFormatEngine::CreateEmptyDocument(IXMLDOMDocument2** pIDoc)
{
   	// Create an empty XML document
    return CoCreateInstance(CLSID_FreeThreadedDOMDocument, NULL, 
								CLSCTX_INPROC_SERVER,
                                IID_IXMLDOMDocument2, (LPVOID*)pIDoc);
}

/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :Carries out the releasing process.
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::Uninitialize(BOOL bFinal)
{
	// Release the interface pointers
	SAFEIRELEASE(m_pIXMLDoc);
	SAFEIRELEASE(m_pIXSLDoc);

	m_bTrace				= FALSE;
	m_eloErrLogOpt			= NO_LOGGING;
	m_bHelp					= FALSE;
	m_bGetOutOpt			= TRUE;
	m_bGetAppendFilePinter	= TRUE;
	m_bGetOutputFilePinter	= TRUE;
	m_bLog					= TRUE;
	m_bInteractiveHelp		= FALSE;
	m_bOutputGoingToStream	= FALSE;
	m_chsOutput.Empty();
	
	// Uninitialize the ErrInfo object
	m_ErrInfo.Uninitialize();
	
	// Erase the help vector
	if ( !m_cvHelp.empty() )
	{
		if (m_cvHelp.size())
		{
			CHARVECTOR::iterator theIterator = m_cvHelp.begin();
			while (theIterator != m_cvHelp.end())
			{
				SAFEDELETE(*theIterator);
				theIterator++;
			}
		}
		m_cvHelp.erase(m_cvHelp.begin(), m_cvHelp.end());
	}
	m_WmiCliLog.Uninitialize(bFinal);
}

/*------------------------------------------------------------------------
   Name				 :ApplyXSLFormatting
   Synopsis	         :Applies a XSL style sheet containing format of the 
					  display to a XML stream containing result set.
   Type	             :Member Function 
   Input parameter   :
    	rParsedInfo  - reference to CParsedInfo class object
   Output parameters :
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL 
   Global Variables  :None
   Calling Syntax    :ApplyXSLFormatting(rParsedInfo);
   Notes             :None
------------------------------------------------------------------------*/
BOOL CFormatEngine::ApplyXSLFormatting(CParsedInfo& rParsedInfo)
{
	BOOL	bRet				= TRUE;
	DWORD	dwThreadId			= GetCurrentThreadId();
	
	if ( g_wmiCmd.GetBreakEvent() == TRUE )
	{
		bRet = TRUE;
	}
	// If the XML stream is empty (or) XSL file path is empty
	// set the return value as FALSE.
	else if (!rParsedInfo.GetCmdSwitchesObject().GetXMLResultSet() || 
			 rParsedInfo.GetCmdSwitchesObject().GetXSLTDetailsVector().empty())
	{
		bRet = FALSE;
	}
	else
	{
		HRESULT			hr					= S_OK;
		//BSTR			bstrOutput			= NULL;
		_bstr_t			bstrOutput;
		CHString		chsMsg;
		VARIANT_BOOL	varBool				= VARIANT_FALSE;
		VARIANT			varXSL;
		VariantInit(&varXSL);
		try
		{
			// Create an empty XML Document 
			hr = CreateEmptyDocument(&m_pIXMLDoc);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"CoCreateInstance(CLSID_FreeThreadedDOMDocument, NULL,"
						 L" CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			BOOL bFlag = FALSE;
			BOOL bTranslateTable = FALSE;

			// If Translate table name is given and before format switch
			// translate switch is given then set the flag
			if( rParsedInfo.GetCmdSwitchesObject().
						GetTranslateTableName() != NULL && 
							rParsedInfo.GetCmdSwitchesObject().
									GetTranslateFirstFlag() == TRUE) 
			{
				bTranslateTable = TRUE;
			}

			// If Translate table name is given then translate 
			// the XML node list
			if ( bTranslateTable == TRUE )
			{
				bFlag = TraverseNode(rParsedInfo);
			}
			else
			{
				// Load XML content
				hr = m_pIXMLDoc->loadXML(rParsedInfo.GetCmdSwitchesObject().
											GetXMLResultSet(), &varBool);
				if (m_bTrace || m_eloErrLogOpt)
				{
					WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMDocument::loadXML(-, -)"), 
							dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);
			}

			// If loading the XML document is successful or if translate table 
			// name is given and translation is successful
			if( (bTranslateTable == TRUE && bFlag == TRUE) || 
				(bTranslateTable == FALSE && varBool == VARIANT_TRUE) )
			{
				bRet = DoCascadeTransforms(rParsedInfo, bstrOutput);
	
				if (bRet)
				{
					STRING strOutput((_TCHAR*)bstrOutput);

					// If /TRANSLATE:<table> is specified and after format 
					// switch translate switch is given then translate the
					// result
					if ( bTranslateTable == FALSE)
					{
						// Translate the result 
						ApplyTranslateTable(strOutput, rParsedInfo);
					}

					bRet = TRUE;
					if (m_bRecord && m_bLog && !m_bInteractiveHelp)
					{
						hr = m_WmiCliLog.WriteToXMLLog(rParsedInfo,
									_bstr_t(strOutput.data()));
						if (FAILED(hr))
						{
							m_WmiCliLog.StopLogging();
							m_bRecord = FALSE;
							hr = S_OK;
							DisplayString(IDS_E_WRITELOG_FAILED, FALSE, 
										NULL, TRUE);
						}
						m_bLog = FALSE;
					}

					// Display the result
					DisplayLargeString(rParsedInfo, strOutput);
					bRet = TRUE;
				}
			}
			else
			{
				// Invalid XML content.
				rParsedInfo.GetCmdSwitchesObject()
							.SetErrataCode(IDS_E_INVALID_XML_CONTENT);
				bRet = FALSE;
			}
		}
		catch(_com_error& e)
		{
			// Set the COM error.
			rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
			bRet = FALSE;
		}
		catch(CHeap_Exception)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
			_com_issue_error(hr);
		}
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :DisplayResults
   Synopsis	         :Displays the result referring CcommandSwitches and 
					  CGlobalSwitches Objects of the CParsedInfo object.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo		 - reference to CParsedInfo class object
		bInteractiveHelp 
				TRUE	-  indicates intermediate help display in 
						   interactive mode
				FALSE	-  indicates results display in normal mode
   Output parameters :
		rParsedInfo - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :DisplayResults(rParsedInfo, bInteractiveHelp)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CFormatEngine::DisplayResults(CParsedInfo& rParsedInfo,
									BOOL bInteractiveHelp)
{
	BOOL	bRet					= TRUE;
	DWORD	dwThreadId				= GetCurrentThreadId();
	_TCHAR* pszVerbName				= NULL;
	BOOL	bLog					= TRUE;
	HRESULT	hr						= S_OK;
	
	m_bInteractiveHelp = bInteractiveHelp;
	// Frame the command part of the log entry:
	// "command: <<command input>>" 
	
	try
	{
		CHString	chsCmdMsg(_T("command: "));
		chsCmdMsg += rParsedInfo.GetCmdSwitchesObject().GetCommandInput();
		// Get the TRACE status and store it in m_bTrace
		m_bTrace		= rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

		// Get the Logging mode (VERBOSE | ERRORONLY | NOLOGGING) and store
		// it in m_eloErrLogOpt
		m_eloErrLogOpt	= rParsedInfo.GetErrorLogObject().GetErrLogOption();

		// Get the output option to redirect the output.
		m_opsOutputOpt	= rParsedInfo.GetGlblSwitchesObject().
												GetOutputOrAppendOption(TRUE);
		m_bGetOutOpt = FALSE;

		// FALSE for getting append file pointer.
		m_fpAppendFile = rParsedInfo.GetGlblSwitchesObject().
										  GetOutputOrAppendFilePointer(FALSE);
		m_bGetAppendFilePinter = FALSE;

		// TRUE for getting out file pointer.
		m_fpOutFile = rParsedInfo.GetGlblSwitchesObject().
										  GetOutputOrAppendFilePointer(TRUE);
		m_bGetOutputFilePinter = FALSE;

		// If /RECORD global switch has been specified, create the log file
		// and write the input command.
		if (rParsedInfo.GetGlblSwitchesObject().GetRPChangeStatus())
		{
			// Stop logging
			m_WmiCliLog.StopLogging();
			
			if (rParsedInfo.GetGlblSwitchesObject().GetRecordPath() != NULL)
			{
				if (!rParsedInfo.GetCmdSwitchesObject().GetEverySwitchFlag())
				{
					// Set the log file path
					m_WmiCliLog.SetLogFilePath(rParsedInfo.
								GetGlblSwitchesObject().GetRecordPath());

					// Set the m_bRecord flag to TRUE
					m_bRecord	= TRUE;

					// Set the recordpath change flag to FALSE
					rParsedInfo.GetGlblSwitchesObject().
										SetRPChangeStatus(FALSE);
				}
			}
			else
			{
				// Set the m_bRecord flag to FALSE
				m_bRecord	= FALSE;
			}

			// Get Token vector
			CHARVECTOR cvTokens = g_wmiCmd.GetTokenVector();
			
			// if command consist of only /RECORD switch option then don't 
			// record it. (It will come here only when /RECORD is given)
			if (cvTokens.size() <= 4)
				m_bLog = FALSE;
		}

		//If the COM error is not NULL , then display the error
		if (rParsedInfo.GetCmdSwitchesObject().GetCOMError() != NULL)
		{
			DisplayCOMError(rParsedInfo);
		}
		// Check the success flag , display error in case error flag is set.
		else if (!rParsedInfo.GetCmdSwitchesObject().GetSuccessFlag())
		{
			_bstr_t bstrErrMsg;
			if (IDS_E_ALIAS_NOT_FOUND == rParsedInfo.GetCmdSwitchesObject()
										.GetErrataCode())
			{
				WMIFormatMessage(IDS_E_ALIAS_NOT_FOUND, 1, bstrErrMsg, 
							 rParsedInfo.GetCmdSwitchesObject().
															GetAliasName());
				DisplayString((LPTSTR) bstrErrMsg,  TRUE, TRUE);
			}
			else if (IDS_E_INVALID_CLASS == rParsedInfo.GetCmdSwitchesObject()
										.GetErrataCode())
			{
				WMIFormatMessage(IDS_E_INVALID_CLASS, 1, bstrErrMsg, 
							 rParsedInfo.GetCmdSwitchesObject().
														   GetClassPath());
				DisplayString((LPTSTR) bstrErrMsg,  TRUE, TRUE);
			}
			else
				DisplayString(rParsedInfo.GetCmdSwitchesObject().
							GetErrataCode(), TRUE, NULL, TRUE);

			if ( m_eloErrLogOpt )
			{
				
				chsCmdMsg += _T(", Utility returned error ID.");
				// explicit error -1 to specify errata code. 
				WMITRACEORERRORLOG(-1, __LINE__, __FILE__, (LPCWSTR)chsCmdMsg, 
							dwThreadId, rParsedInfo, FALSE, 
							rParsedInfo.GetCmdSwitchesObject().GetErrataCode());
			}
		}
		//if the help has been specified , FrameHelpVector is called .
		else if (rParsedInfo.GetGlblSwitchesObject().GetHelpFlag())
		{
			m_bHelp = TRUE;

			// Form help vector
			FrameHelpVector(rParsedInfo);

			// Display paged help
			DisplayPagedHelp(rParsedInfo);

			if ( m_eloErrLogOpt )
				WMITRACEORERRORLOG(S_OK, __LINE__, __FILE__, (LPCWSTR)chsCmdMsg, 
						dwThreadId,	rParsedInfo, FALSE);
		}
		else
		{
			// Get the verb name
			pszVerbName = rParsedInfo.GetCmdSwitchesObject().
											GetVerbName();
			// Check the information code 
			if (rParsedInfo.GetCmdSwitchesObject().GetInformationCode())
			{
				DisplayString(rParsedInfo.GetCmdSwitchesObject().
							GetInformationCode());

				if ( m_eloErrLogOpt )
				{
					WMITRACEORERRORLOG(S_OK, __LINE__, __FILE__, (LPCWSTR)chsCmdMsg, 
							dwThreadId, rParsedInfo, FALSE);
				}
			}
			else if ( CompareTokens(pszVerbName, CLI_TOKEN_LIST) || 
				CompareTokens(pszVerbName, CLI_TOKEN_ASSOC) || 
				CompareTokens(pszVerbName, CLI_TOKEN_GET) || 
				m_bInteractiveHelp)
			{
				//If XSL file is not specified - pick the default XSL.
				if(rParsedInfo.GetCmdSwitchesObject().GetXSLTDetailsVector().
																	  empty())
				{
					if(IsClassOperation(rParsedInfo))
					{
						rParsedInfo.GetCmdSwitchesObject().
										ClearXSLTDetailsVector();
					   
						//default format is MOF if CLASS 
						bRet = FrameFileAndAddToXSLTDetVector	(
																	XSL_FORMAT_MOF,
																	CLI_TOKEN_MOF,
																	rParsedInfo
																);
					}
					else
					{
						rParsedInfo.GetCmdSwitchesObject().
										ClearXSLTDetailsVector();
					   
						// Default format is TABLE if an alias or path
						// with where expression or with keyclause
						bRet = FrameFileAndAddToXSLTDetVector	(
																	XSL_FORMAT_TABLE,
																	CLI_TOKEN_TABLE,
																	rParsedInfo
																);
					}

					if (bInteractiveHelp && !CompareTokens(pszVerbName, 
									CLI_TOKEN_ASSOC))
					{
						rParsedInfo.GetCmdSwitchesObject().
										ClearXSLTDetailsVector();

						//otherwise go with LIST 
						bRet = FrameFileAndAddToXSLTDetVector	(
																	XSL_FORMAT_TEXTVALUE,
																	CLI_TOKEN_TEXTVALUE,
																	rParsedInfo
																);
					}
				}

				// If result set is not empty
				if (!(!rParsedInfo.GetCmdSwitchesObject().GetXMLResultSet()))
				{
					// Apply the XSL formatting.
					bRet = ApplyXSLFormatting(rParsedInfo);

					// If XSL formatting fails
					if (!bRet)
					{
						//If the COM error is not NULL , then display the error
						if (rParsedInfo.GetCmdSwitchesObject().
										GetCOMError() != NULL)
						{
							DisplayCOMError(rParsedInfo);
						}
						else
						{
							DisplayString(rParsedInfo.
									GetCmdSwitchesObject().GetErrataCode(),
									TRUE, NULL, TRUE);
							if ( m_eloErrLogOpt )
							{
								
							   chsCmdMsg += _T(", Utility returned error ID.");
							   // explicit error -1 to specify errata code. 
							   WMITRACEORERRORLOG(-1, __LINE__, __FILE__,
											(LPCWSTR)chsCmdMsg, 
											dwThreadId, rParsedInfo, FALSE, 
											rParsedInfo.GetCmdSwitchesObject().
												GetErrataCode());
							}
						}
					}

					if ( m_eloErrLogOpt )
					{
						HRESULT hrTemp;
						if ( g_wmiCmd.GetSessionErrorLevel() != 0)
							hrTemp = -1;
						else
							hrTemp = S_OK;
						
						WMITRACEORERRORLOG(hrTemp, __LINE__, __FILE__, 
							(LPCWSTR)chsCmdMsg, 
							dwThreadId, rParsedInfo, FALSE);
					}
				}
				else
				{
					if (CompareTokens(pszVerbName, CLI_TOKEN_ASSOC))
					{
						if (m_bRecord && m_bLog)
						{
							hr = m_WmiCliLog.WriteToXMLLog(rParsedInfo, 
									_bstr_t((LPCWSTR)m_chsOutput));
							if (FAILED(hr))
							{
								m_WmiCliLog.StopLogging();
								m_bRecord = FALSE;
								hr = S_OK;
								DisplayString(IDS_E_WRITELOG_FAILED, 
												FALSE, NULL, TRUE);
							}
							m_bLog = FALSE;
						}
					}
				}
			}
			//SET, DELETE, CREATE verbs - on successfully invoked
			else
			{
				if (m_bRecord && m_bLog)
				{
					hr = m_WmiCliLog.WriteToXMLLog(rParsedInfo, 
										_bstr_t((LPCWSTR)m_chsOutput));
					if (FAILED(hr))
					{
						m_WmiCliLog.StopLogging();
						m_bRecord = FALSE;
						hr = S_OK;
						DisplayString(IDS_E_WRITELOG_FAILED, 
											FALSE, NULL, TRUE);
					}
					m_bLog = FALSE;
				}
			}
		}
	}
	// To handle COM exception 
	catch (_com_error& e)
	{
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	// To handle user-defined exceptions
	catch(WMICLIINT nVal)
	{
		// If memory allocation failed.
		if (nVal == OUT_OF_MEMORY)
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
		}
		bRet = FALSE;
	}
	//trap for CHeap_Exception
	catch(CHeap_Exception)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	catch(DWORD dwError)
	{
		// If Win32 function call failed.
		::SetLastError(dwError);
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(dwError);
		DisplayWin32Error();
		::SetLastError(dwError);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :DisplayGETUsage
   Synopsis	         :Displays GET usage.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayGETUsage(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayGETUsage(CParsedInfo& rParsedInfo)
{
	BOOL bClass = FALSE;
	if(IsClassOperation(rParsedInfo))
	{
		bClass = TRUE;
	}

	if(!bClass)
	{
		DisplayInvalidProperties(rParsedInfo);
		if (rParsedInfo.GetHelpInfoObject().GetHelp(GETSwitchesOnly) == FALSE)
		{
			if ( rParsedInfo.GetCmdSwitchesObject().
					GetPropertyList().size() == 0 )
			{
				// Display the usage of the GET verb
				DisplayString(IDS_I_NEWLINE);
				DisplayString(IDS_I_GET_DESC);
				DisplayString(IDS_I_USAGE);
				DisplayString(IDS_I_NEWLINE);
				DisplayString(IDS_I_GET_USAGE);
				DisplayString(IDS_I_PROPERTYLIST_NOTE1);
			}
			
			// Display the properties
			DisplayPropertyDetails(rParsedInfo);
		}
	}
	else
	{
		// Display the usage of the CLASS <class name> GET verb
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASS_GET_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASS_GET_USAGE);
	}
	
	// Enumerate the available GET switches
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_GET_SWITCH_HEAD);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_GET_SWITCH_VALUE);
	DisplayString(IDS_I_GET_SWITCH_ALL);
	DisplayString(IDS_I_SWITCH_TRANSLATE);
	DisplayString(IDS_I_SWITCH_EVERY);
	DisplayString(IDS_I_SWITCH_FORMAT);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_TRANSFORMAT_NOTE1);
	DisplayString(IDS_I_TRANSFORMAT_NOTE2);
	DisplayString(IDS_I_TRANSFORMAT_NOTE3);
}

/*------------------------------------------------------------------------
   Name				 :DisplayLISTUsage
   Synopsis	         :Displays LIST usage.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayLISTUsage(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayLISTUsage(CParsedInfo& rParsedInfo)
{
	try
	{
		if (rParsedInfo.GetHelpInfoObject().GetHelp(LISTSwitchesOnly) == FALSE)
		{
			// Display the usage of the LIST verb
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_LIST_DESC);
			DisplayString(IDS_I_USAGE);
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_LIST_USAGE);
		
			ALSFMTDETMAP afdAlsFmtDet = rParsedInfo.
										GetCmdSwitchesObject().
										GetAliasFormatDetMap();
			ALSFMTDETMAP::iterator theIterator; 
			if ( afdAlsFmtDet.empty() )
			{
				// If no list formats are available/defined for the 
				// alias specified.
				DisplayString(IDS_I_NEWLINE);
				DisplayString(IDS_I_LIST_NOFORMATS);
			}
			else
			{
				// Display the available/defined LIST formats for 
				// the alias specified.
				DisplayString(IDS_I_NEWLINE);
				DisplayString(IDS_I_LIST_FMT_HEAD);
				DisplayString(IDS_I_NEWLINE);

				for ( theIterator = afdAlsFmtDet.begin(); theIterator != 
						afdAlsFmtDet.end();  theIterator++ )
				{
					_bstr_t bstrProps = _bstr_t("");
					// Print props associated with the format.
					BSTRVECTOR bvProps = (*theIterator).second;
					BSTRVECTOR::iterator propIterator;
					for ( propIterator = bvProps.begin(); 
						  propIterator != bvProps.end();
						  propIterator++ )
					{
						if ( propIterator != bvProps.begin() )
							bstrProps += _bstr_t(", ");

						bstrProps += *propIterator;
					}

					_TCHAR szMsg[MAX_BUFFER] = NULL_STRING;
					_stprintf(szMsg, _T("%-25s - %s\r\n"), 
							(_TCHAR*)(*theIterator).first,
							(_TCHAR*)bstrProps);
					DisplayString(szMsg);
				}
			}
		}

		// Display the LIST switches
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_LIST_SWITCH_HEAD);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_SWITCH_TRANSLATE);
		DisplayString(IDS_I_SWITCH_EVERY);
		DisplayString(IDS_I_SWITCH_FORMAT);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_TRANSFORMAT_NOTE1);
		DisplayString(IDS_I_TRANSFORMAT_NOTE2);
		DisplayString(IDS_I_TRANSFORMAT_NOTE3);
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayCALLUsage
   Synopsis	         :Displays CALL usage.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayCALLUsage(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayCALLUsage(CParsedInfo& rParsedInfo)
{
	// Display the usage of the CALL verb
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_CALL_DESC);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_CALL_USAGE);
	DisplayString(IDS_I_CALL_PARAM_NOTE);

	// Display the method details.
	DisplayMethodDetails(rParsedInfo);
}

/*------------------------------------------------------------------------
   Name				 :DisplaySETUsage
   Synopsis	         :Displays SET usage.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplaySETUsage(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplaySETUsage(CParsedInfo& rParsedInfo)
{
	DisplayInvalidProperties(rParsedInfo, TRUE);
	if ( rParsedInfo.GetCmdSwitchesObject().
			GetPropertyList().size() == 0 )
	{
		// Display the usage of the SET verb
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_SET_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_SET_USAGE);
		DisplayString(IDS_I_ASSIGNLIST_NOTE1);
		DisplayString(IDS_I_ASSIGNLIST_NOTE2);
	}

	// Display the property details
	DisplayPropertyDetails(rParsedInfo);
}

/*------------------------------------------------------------------------
   Name				 :DisplayCREATEUsage
   Synopsis	         :Displays CREATE usage.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayCREATEsage(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayCREATEUsage(CParsedInfo& rParsedInfo)
{
	DisplayInvalidProperties(rParsedInfo);
	if ( rParsedInfo.GetCmdSwitchesObject().
			GetPropertyList().size() == 0 )
	{
		// Display the usage of the CREATE verb
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CREATE_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CREATE_USAGE);
		DisplayString(IDS_I_ASSIGNLIST_NOTE1);
		DisplayString(IDS_I_ASSIGNLIST_NOTE2);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CREATE_NOTE);
	}

	// Display the property details
	DisplayPropertyDetails(rParsedInfo);
}

/*------------------------------------------------------------------------
   Name				 :DisplayDELETEUsage
   Synopsis	         :Displays DELETE usage.
   Type	             :Member Function 
   Input parameter   :
   		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayDELETEUsage()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayDELETEUsage(CParsedInfo& rParsedInfo)
{
	// Display the usage of the DELETE verb
	DisplayString(IDS_I_NEWLINE);

	if(IsClassOperation(rParsedInfo))
	{
		DisplayString(IDS_I_CLASS_DELETE_DESC);
	}
	else
	{
		DisplayString(IDS_I_DELETE_DESC);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayASSOCUsage
   Synopsis	         :Displays ASSOC usage.
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayASSOCUsage(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayASSOCUsage(CParsedInfo& rParsedInfo)
{
	if (rParsedInfo.GetHelpInfoObject().GetHelp(ASSOCSwitchesOnly) == FALSE)
	{
		DisplayString(IDS_I_NEWLINE);
		if(IsClassOperation(rParsedInfo))
		{
			DisplayString(IDS_I_CLASS_ASSOC_DESC);
		}
		else
		{
			DisplayString(IDS_I_ASSOC_DESC);
		}
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_ASSOC_USAGE);
		DisplayString(IDS_I_ASSOC_FMT_NOTE);
		DisplayString(IDS_I_NEWLINE);
	}
	DisplayString(IDS_I_ASSOC_SWITCH_HEAD);
	DisplayString(IDS_I_NEWLINE);
    DisplayString(IDS_I_ASSOC_RESULTCLASS);
	DisplayString(IDS_I_ASSOC_RESULTROLE);
	DisplayString(IDS_I_ASSOC_ASSOCCLASS);
}

/*------------------------------------------------------------------------
   Name				 :DisplayAliasFriendlyNames
   Synopsis	         :Displays alias names
   Type	             :Member Function 
   Input parameter   :
	   rParsedInfo  - reference to CParsedInfo class object
	   pszAlias	   - alias name (default null)
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayAliasFriendlyNames(rParsedInfo, pszAlias)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayAliasFriendlyNames(CParsedInfo& rParsedInfo,
											_TCHAR* pszAlias)
{
	_TCHAR szMsg[MAX_BUFFER] = NULL_STRING;
	// display ALIAS help
	BSTRMAP theMap = rParsedInfo.GetCmdSwitchesObject()
									.GetAlsFrnNmsOrTrnsTblMap();
	BSTRMAP::iterator theIterator;

	// Displaying the alias specific description
	if (pszAlias)
	{
		theIterator = theMap.find(CharUpper(pszAlias));
		if (theIterator != theMap.end())
		{
			DisplayString(IDS_I_NEWLINE);
			_stprintf(szMsg,_T("%s - %s\r\n"),
							(LPTSTR) (*theIterator).first,
							(LPTSTR) (*theIterator).second);

			DisplayString((LPTSTR) szMsg);
		}
	}
	else if ( !theMap.empty() )
	{
		_TCHAR* pszCmdString = rParsedInfo.GetCmdSwitchesObject().
															GetCommandInput();

		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_ALIASCMD_HEAD);
	
		// Display the alias friendly names together with the 
		// descriptions
		for (theIterator = theMap.begin(); theIterator != theMap.end(); 
												theIterator++)
		{
			if ( rParsedInfo.GetGlblSwitchesObject().
					GetHelpOption() == HELPBRIEF	&&
					StrStrI(pszCmdString, _T("BRIEF")) &&
					lstrlen((*theIterator).second) > 48)
			{
				_stprintf(szMsg,_T("%-25s- %.48s...\r\n"),
									(LPTSTR) (*theIterator).first,
									(LPTSTR) (*theIterator).second);
			}
			else
			{
				_stprintf(szMsg,_T("%-25s- %s\r\n"),
									(LPTSTR) (*theIterator).first,
									(LPTSTR) (*theIterator).second);
			}

			DisplayString((LPTSTR) szMsg);
		}
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CMD_MORE);
	}
	else
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_ALIASCMD_NOT_AVLBL);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayGlobalSwitchesAndOtherDesc
   Synopsis	         :Display help for global switches
   Type	             :Member Function 
   Input parameter   :
	   	rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayGlobalSwitchesAndOtherDesc(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayGlobalSwitchesAndOtherDesc(
												CParsedInfo& rParsedInfo)
{
	BOOL bDisplayAllInfo = rParsedInfo.GetHelpInfoObject().
			GetHelp(GlblAllInfo);

	// Display NAMESPACE help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Namespace))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_NAMESPACE_DESC1);
		DisplayString(IDS_I_NAMESPACE_DESC2);
		DisplayString(IDS_I_NAMESPACE_DESC3);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_NAMESPACE_USAGE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	// Display ROLE help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Role))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_ROLE_DESC1);
		DisplayString(IDS_I_ROLE_DESC2);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_ROLE_USAGE);
		DisplayString(IDS_I_ROLE_NOTE1);
		DisplayString(IDS_I_ROLE_NOTE2);
		DisplayString(IDS_I_ROLE_NOTE3);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	// Display NODE help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Node))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_NODE_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_NODE_USAGE);
		DisplayString(IDS_I_NODE_NOTE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}
		
	// Display IMPLEVEL help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Level))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_IMPLEVEL_DESC1);
		DisplayString(IDS_I_IMPLEVEL_DESC2);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_IMPLEVEL_USAGE);
		DisplayString(IDS_I_IMPLEVEL_HEAD);
		DisplayString(IDS_I_IMPLEVEL_HEAD1);
		DisplayString(IDS_I_IMPLEVEL_HEAD2);
		DisplayString(IDS_I_IMPLEVEL_ANON);
		DisplayString(IDS_I_IMPLEVEL_IDENTIFY);
		DisplayString(IDS_I_IMPLEVEL_IMPERSONATE);
		DisplayString(IDS_I_IMPLEVEL_DELEGATE);
		DisplayString(IDS_I_IMPLEVEL_NOTE);
	}

	// Display AUTHLEVEL help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(AuthLevel))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_AUTHLEVEL_DESC1);
		DisplayString(IDS_I_AUTHLEVEL_DESC2);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_AUTHLEVEL_USAGE);
		DisplayString(IDS_I_AUTHLEVEL_HEAD);
		DisplayString(IDS_I_AUTHLEVEL_HEAD1);
		DisplayString(IDS_I_AUTHLEVEL_HEAD2);
		DisplayString(IDS_I_AUTHLEVEL_DEFAULT);
		DisplayString(IDS_I_AUTHLEVEL_NONE);
		DisplayString(IDS_I_AUTHLEVEL_CONNECT);
		DisplayString(IDS_I_AUTHLEVEL_CALL);
		DisplayString(IDS_I_AUTHLEVEL_PKT);
		DisplayString(IDS_I_AUTHLEVEL_PKTINTGRTY);
		DisplayString(IDS_I_AUTHLEVEL_PKTPRVCY);
	}

	// Display LOCALE help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Locale))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_LOCALE_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_LOCALE_USAGE);
		DisplayString(IDS_I_LOCALE_NOTE1);
		DisplayString(IDS_I_LOCALE_NOTE2);
	}

	// Display PRIVILEGES help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Privileges))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PRIVILEGES_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PRIVILEGES_USAGE);
		DisplayString(IDS_I_PRIVILEGES_NOTE);
	}

	// Display TRACE help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Trace))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_TRACE_DESC1);
		DisplayString(IDS_I_TRACE_DESC2);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_TRACE_USAGE);
		DisplayString(IDS_I_TRACE_NOTE);
	}
	
	// Display RECORD help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(RecordPath))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_RECORD_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_RECORD_USAGE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	// Display INTERACTIVE help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Interactive))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_INTERACTIVE_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_INTERACTIVE_USAGE);
		DisplayString(IDS_I_TRACE_NOTE);
	}

	// Display FAILFAST help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(FAILFAST))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_FAILFAST_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_FAILFAST_USAGE);
		DisplayString(IDS_I_TRACE_NOTE);
	}

	// Display OUTPUT help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(OUTPUT))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_OUTPUT_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_OUTPUT_USAGE);
		DisplayString(IDS_I_OUTPUT_NOTE);
		DisplayString(IDS_I_STDOUT_NOTE);
		DisplayString(IDS_I_CLIPBOARD_NOTE);
		DisplayString(IDS_I_OUTPUT_FILE_NOTE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	// Display APPEND help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(APPEND))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_APPEND_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_APPEND_USAGE);
		DisplayString(IDS_I_OUTPUT_NOTE);
		DisplayString(IDS_I_STDOUT_NOTE);
		DisplayString(IDS_I_CLIPBOARD_NOTE);
		DisplayString(IDS_I_APPEND_FILE_NOTE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	// Display USER help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(User))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_USER_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_USER_USAGE);
		DisplayString(IDS_I_USER_NOTE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	//Display AGGREGATE help
	if(bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Aggregate))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_AGGREGATE_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_AGGREGATE_USAGE);
		DisplayString(IDS_I_AGGREGATE_NOTE);
	}
	
	// Display PASSWORD help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Password))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PASSWORD_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PASSWORD_USAGE);
		if (!bDisplayAllInfo)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_SPECIAL_NOTE);
		}
	}

	// Display AUTHORITY help
	if (bDisplayAllInfo || rParsedInfo.GetHelpInfoObject().GetHelp(Authority))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_AUTHORITY_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_AUTHORITY_USAGE);
	}

	if (bDisplayAllInfo)
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_HELP_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_HELP_USAGE);
		DisplayString(IDS_I_HELP_NOTE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_SPECIAL_NOTE);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayMethodDetails
   Synopsis	         :Display help for Alias verbs
   Type	             :Member Function 
   Input parameter   :
	   	rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayMethodDetails(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayMethodDetails(CParsedInfo& rParsedInfo) 
{
	// Obtain the help option.
	HELPOPTION				hoHelpType	  = rParsedInfo.GetGlblSwitchesObject()
													.GetHelpOption();
	// Obtain the method details.
	METHDETMAP				theMap		  = rParsedInfo.GetCmdSwitchesObject().
													GetMethDetMap();
	METHDETMAP::iterator	theIterator;
	BOOL					bDisAliasVerb = rParsedInfo.GetHelpInfoObject().
												GetHelp(AliasVerb);
	BOOL					bPrinted	  = FALSE;

	_bstr_t					bstrLine;


	try
	{
		// Loop thru the method map
		for (theIterator = theMap.begin(); 
					theIterator != theMap.end(); theIterator++)
		{
						
			if (!bDisAliasVerb && theIterator == theMap.begin())
			{
				DisplayString(IDS_I_NEWLINE);
				if (rParsedInfo.GetCmdSwitchesObject().GetAliasName())
					DisplayString(IDS_I_ALIASVERB_HEAD);
				else
					DisplayString(IDS_I_VERB_HEAD);
				DisplayString(IDS_I_NEWLINE);
			}

			if ( bPrinted == FALSE )
			{
				DisplayString(IDS_I_PARAM_HEAD);
				DisplayString(IDS_I_PARAM_BORDER);
				bPrinted = TRUE;
			}

			METHODDETAILS	mdMethDet	= (*theIterator).second;
			_TCHAR			szMsg[MAX_BUFFER] = NULL_STRING;
			_stprintf(szMsg,_T("%-24s"),(LPTSTR) (*theIterator).first);
			_bstr_t			bstrMessage = _bstr_t(szMsg);


			PROPDETMAP pdmParams = mdMethDet.Params;
			PROPDETMAP::iterator paraIterator;
			for ( paraIterator = pdmParams.begin() ;  paraIterator !=
							pdmParams.end(); paraIterator++ )
			{
				if ( paraIterator != pdmParams.begin())
				{
					DisplayString(IDS_I_NEWLINE);
					_stprintf(szMsg, _T("\t\t\t"));
					bstrMessage = szMsg;
				}

				LPSTR pszParaId = NULL, pszParaType = NULL;
				PROPERTYDETAILS pdPropDet = (*paraIterator).second;
				
				if (!ConvertWCToMBCS((LPTSTR)(*paraIterator).first,(LPVOID*) &pszParaId, 
									CP_OEMCP))
					throw OUT_OF_MEMORY;
				if (!ConvertWCToMBCS(pdPropDet.Type,(LPVOID*) &pszParaType, CP_OEMCP))
					throw OUT_OF_MEMORY;
				
				_bstr_t bstrInOrOut;
				if ( pdPropDet.InOrOut == INP )
					bstrInOrOut = _bstr_t("[IN ]");
				else if ( pdPropDet.InOrOut == OUTP )
					bstrInOrOut = _bstr_t("[OUT]");
				else
					bstrInOrOut = _bstr_t("[UNKNOWN]");

				// Remove initial 5 chars from pszParaId to remove temporary 
				// number for maintaining order of paramas
				_bstr_t bstrLine = bstrInOrOut 
									+ _bstr_t(pszParaId + 5) 
									+ _bstr_t("(") 
									+ _bstr_t(pszParaType) + _bstr_t(")");
				_stprintf(szMsg,_T("%-36s\t"),(LPTSTR) bstrLine);
				bstrMessage += _bstr_t(szMsg);
				SAFEDELETE(pszParaId);
				SAFEDELETE(pszParaType);

				if ( paraIterator == pdmParams.begin() )
				{
					_stprintf(szMsg,_T("%-15s"),(LPTSTR) mdMethDet.Status);
					bstrMessage += szMsg;
				}
				bstrMessage += _bstr_t(L"\n");
				DisplayString((LPTSTR) bstrMessage);
			}

			if ( paraIterator == pdmParams.begin() )
			{
				_stprintf(szMsg,_T("\t\t\t\t\t%-15s"),(LPTSTR)mdMethDet.Status);
				bstrMessage += _bstr_t(szMsg) + _bstr_t(L"\n");
				DisplayString((LPTSTR) bstrMessage);
				DisplayString(IDS_I_NEWLINE);
			}
			DisplayString(IDS_I_NEWLINE);

			if ( hoHelpType == HELPFULL )
			{
				DisplayString(IDS_I_DESCRIPTION);
				bstrLine = mdMethDet.Description + _bstr_t(L"\n");
				DisplayString((LPTSTR) bstrLine);
				DisplayString(IDS_I_NEWLINE);
			}
		}
		if (!bPrinted)
		{
			if (rParsedInfo.GetCmdSwitchesObject().GetMethodName() != NULL)
			{
				DisplayString(IDS_I_ALIASVERB_NOT_AVLBL);
			}
			else
			{
				DisplayString(IDS_I_NEWLINE);
				DisplayString(IDS_I_VERB_NOT_AVLBL);
			}
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	catch(WMICLIINT nVal)
	{
		// If memory allocation failed.
		if (nVal == OUT_OF_MEMORY)
		{
  			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
		}
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayPropertyDetails
   Synopsis	         :Display help for Alias properties and their descriptions
   Type	             :Member Function 
   Input parameter   :
	  	rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayPropertyDetails(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayPropertyDetails(CParsedInfo& rParsedInfo)
{
	BOOL					bFirst				= TRUE;
	BOOL					bSetVerb			= FALSE;
	_TCHAR					szMsg[MAX_BUFFER]	= NULL_STRING;
	_bstr_t					bstrLine;
	PROPDETMAP::iterator	theIterator			= NULL;
	PROPERTYDETAILS			pdPropDet;

	HELPOPTION	hoHelpType	= rParsedInfo.GetGlblSwitchesObject().
								GetHelpOption();
	PROPDETMAP theMap = rParsedInfo.GetCmdSwitchesObject().GetPropDetMap();
	try
	{
		// If the verb is SET display only writable properties
		if (CompareTokens(rParsedInfo.GetCmdSwitchesObject().GetVerbName(), 
						CLI_TOKEN_SET))
		{
			bSetVerb = TRUE;
		}
		
		for (theIterator = theMap.begin(); 
				theIterator != theMap.end(); theIterator++)
		{
			pdPropDet = (PROPERTYDETAILS)((*theIterator).second);

			if (bFirst)
			{
				DisplayString(IDS_I_NEWLINE);
				if ( rParsedInfo.GetCmdSwitchesObject().
									GetPropertyList().size() == 0 )
				{
					if (bSetVerb)
					{
						DisplayString(IDS_I_PROP_WRITEABLE_HEAD);
					}
					else
					{
						DisplayString(IDS_I_PROP_HEAD);
					}
				}
				DisplayString(IDS_I_PROPS_HEAD);
				DisplayString(IDS_I_PROPS_BORDER);
				bFirst = FALSE;
			}

			_stprintf(szMsg,_T("%-35s\t%-20s\t%-10s\r\n"), 
						(LPTSTR)(*theIterator).first, 
						(LPTSTR) pdPropDet.Type, (LPTSTR) pdPropDet.Operation);
			DisplayString((LPTSTR) szMsg);
			
			if ( hoHelpType == HELPFULL )
			{
				DisplayString(IDS_I_DESCRIPTION);
				bstrLine = pdPropDet.Description + _bstr_t(L"\n");
				DisplayString((LPTSTR) bstrLine);	
				DisplayString(IDS_I_NEWLINE);
			}
		}
		
		if ( bSetVerb && 
			 rParsedInfo.GetCmdSwitchesObject().
									GetPropertyList().size() == 0 &&
			 bFirst == TRUE	)
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_PROP_WRITEABLE_NOT_AVLBL);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayStdVerbDescriptions
   Synopsis	         :Displays help for standard verbs
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayStdVerbDescriptions(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayStdVerbDescriptions(CParsedInfo& rParsedInfo)
{
	BOOL bDisAllCmdHelp = rParsedInfo.GetHelpInfoObject().GetHelp(CmdAllInfo);
	
	if (bDisAllCmdHelp)
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_STDVERB_HEAD);
	}

	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(GETVerb))
		DisplayGETUsage(rParsedInfo);

	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(SETVerb))
		DisplaySETUsage(rParsedInfo);
	
	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(LISTVerb))
		DisplayLISTUsage(rParsedInfo);
	
	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(CALLVerb))
		DisplayCALLUsage(rParsedInfo);
	
	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(ASSOCVerb))
		DisplayASSOCUsage(rParsedInfo);

	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(CREATEVerb))
		DisplayCREATEUsage(rParsedInfo);

	if (bDisAllCmdHelp || rParsedInfo.GetHelpInfoObject().GetHelp(DELETEVerb))
		DisplayDELETEUsage(rParsedInfo);

}


/*------------------------------------------------------------------------
   Name				 :FrameHelpVector
   Synopsis	         :Frames the help vector which will be later used for 
					  displaying the help on a page by page basis
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameHelpVector(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::FrameHelpVector(CParsedInfo& rParsedInfo)
{
	m_bDispCALL	=	rParsedInfo.GetCmdSwitchesObject().
											GetMethodsAvailable();

	m_bDispSET =	rParsedInfo.GetCmdSwitchesObject().
											GetWriteablePropsAvailable();

	m_bDispLIST =	rParsedInfo.GetCmdSwitchesObject().
											GetLISTFormatsAvailable();

	if (rParsedInfo.GetHelpInfoObject().GetHelp(GlblAllInfo))
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_GLBLCMD);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_GLBL_SWITCH_HEAD);

		if ( rParsedInfo.GetGlblSwitchesObject().GetHelpOption() == HELPBRIEF)
			DisplayGlobalSwitchesBrief();
		else
			DisplayGlobalSwitchesAndOtherDesc(rParsedInfo);

		DisplayString(IDS_I_NEWLINE);
		DisplayAliasFriendlyNames(rParsedInfo);

		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASS_DESCFULL);
		DisplayString(IDS_I_PATH_DESCFULL);
		DisplayString(IDS_I_CONTEXT_DESCFULL);
		DisplayString(IDS_I_QUITEXIT);
		
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASSPATH_MORE);
	}
	else if (rParsedInfo.GetHelpInfoObject().GetHelp(CmdAllInfo))
	{
		DisplayAliasFriendlyNames(rParsedInfo, 
					rParsedInfo.GetCmdSwitchesObject().GetAliasName());
		DisplayAliasHelp(rParsedInfo);
	}
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(PATH))
		DisplayPATHHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(WHERE))
		DisplayWHEREHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(CLASS))
		DisplayCLASSHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(PWhere))
		DisplayPWhereHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(TRANSLATE))
		DisplayTRANSLATEHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(EVERY))
		DisplayEVERYHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(REPEAT))
		DisplayREPEATHelp();
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(FORMAT))
		DisplayFORMATHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(VERBSWITCHES))
		DisplayVERBSWITCHESHelp(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(GLBLCONTEXT))
		DisplayContext(rParsedInfo);
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(CONTEXTHELP))
		DisplayContextHelp();
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(RESULTCLASShelp))
		DisplayRESULTCLASSHelp();
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(RESULTROLEhelp))
		DisplayRESULTROLEHelp();
	else if ( rParsedInfo.GetHelpInfoObject().GetHelp(ASSOCCLASShelp))
		DisplayASSOCCLASSHelp();
	else
	{
		DisplayGlobalSwitchesAndOtherDesc(rParsedInfo);
		DisplayStdVerbDescriptions(rParsedInfo);
		if ( rParsedInfo.GetHelpInfoObject().GetHelp(AliasVerb) )
			DisplayMethodDetails(rParsedInfo);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayAliasHelp
   Synopsis	         :Displays help for Alias 
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayAliasHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayAliasHelp(CParsedInfo& rParsedInfo)
{
	try
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_ALIAS_USAGE1);
		DisplayString(IDS_I_ALIAS_USAGE2);
		DisplayString(IDS_I_NEWLINE);

		// Get the Alias Name
		_bstr_t bstrAliasName = _bstr_t(rParsedInfo.
										GetCmdSwitchesObject().GetAliasName());
		CharUpper(bstrAliasName);
		DisplayStdVerbsUsage(bstrAliasName);
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayPATHHelp
   Synopsis	         :Displays help for Alias PATH
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayPATHHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayPATHHelp(CParsedInfo& rParsedInfo)
{
	if ( rParsedInfo.GetCmdSwitchesObject().GetClassPath() == NULL )
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PATH_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PATH_USAGE);
	}
	else
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PATH_DESC);
		_bstr_t bstrMsg;
		WMIFormatMessage(IDS_I_PATHHELP_SUBST, 0, bstrMsg, NULL);
		DisplayStdVerbsUsage(bstrMsg);
	}	
}

/*------------------------------------------------------------------------
   Name				 :DisplayWHEREHelp
   Synopsis	         :Displays help for WHERE
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayWHEREHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayWHEREHelp(CParsedInfo& rParsedInfo)
{
	try
	{
		if ( rParsedInfo.GetCmdSwitchesObject().GetWhereExpression() == NULL )
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_WHERE_DESC1);
			DisplayString(IDS_I_WHERE_DESC2);
			DisplayString(IDS_I_USAGE);
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_WHERE_USAGE);
		}
		else
		{
			DisplayString(IDS_I_NEWLINE);
			DisplayString(IDS_I_WHERE_DESC1);
			DisplayString(IDS_I_WHERE_DESC2);
			_bstr_t bstrMsg;
			WMIFormatMessage(IDS_I_WHEREHELP_SUBST, 0, bstrMsg, NULL);
			DisplayStdVerbsUsage(bstrMsg);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayCLASSHelp
   Synopsis	         :Displays help for CLASS
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayCLASSHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayCLASSHelp(CParsedInfo& rParsedInfo)
{
	if ( rParsedInfo.GetCmdSwitchesObject().GetClassPath() == NULL )
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASS_DESC);
		DisplayString(IDS_I_USAGE);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASS_USAGE);
	}
	else
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_CLASS_DESC);
		_bstr_t bstrMsg;
		WMIFormatMessage(IDS_I_CLASSHELP_SUBST, 0, bstrMsg, NULL);
		DisplayStdVerbsUsage(bstrMsg, TRUE);
	}		
}

/*------------------------------------------------------------------------
   Name				 :Help
   Synopsis	         :Displays help for PWhere
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayPWhereHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayPWhereHelp(CParsedInfo& rParsedInfo)
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_PWHERE_DESC1);
	DisplayString(IDS_I_PWHERE_DESC2);
	DisplayString(IDS_I_NEWLINE);
	_bstr_t bstrMsg;
	WMIFormatMessage(IDS_I_PWHEREHELP_SUBST, 1, bstrMsg, 
						CharUpper(rParsedInfo.GetCmdSwitchesObject()
								.GetAliasName()));
	DisplayStdVerbsUsage(bstrMsg);
	DisplayString(IDS_I_PWHERE_USAGE);
}


/*------------------------------------------------------------------------
   Name				 :DisplayString
   Synopsis	         :Displays localized string
   Type	             :Member Function 
   Input parameter   :None
			uID				- string table identifier
			bAddToVector	- add to help vector.
			LPTSTR			- lpszParam (parameter for substituion)
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayString(uID, bAddToVector, lpszParam)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayString(UINT uID, BOOL bAddToVector, LPTSTR lpszParam, BOOL bIsError) 
{
	LPTSTR	lpszMsg		= NULL;
	LPVOID	lpMsgBuf	= NULL;
	HRESULT	hr			= S_OK;

	try
	{
		lpszMsg = new _TCHAR [BUFFER1024];

		if ( m_bGetOutOpt == TRUE )
		{
			// Get the output option to redirect the output.
			m_opsOutputOpt	= g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										GetOutputOrAppendOption(TRUE);
			m_bGetOutOpt = FALSE;	
		}
		
		if ( m_bGetAppendFilePinter == TRUE )
		{
			// FALSE for getting append file pointer.
			m_fpAppendFile = g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(FALSE);
			m_bGetAppendFilePinter = FALSE;
		}

		if ( m_bGetOutputFilePinter == TRUE )
		{
			// TRUE for getting append file pointer.
			m_fpOutFile = g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(TRUE);
			m_bGetOutputFilePinter = FALSE;
		}

		if (lpszMsg)
		{
			LoadString(NULL, uID, lpszMsg, BUFFER1024);
			if (lpszParam)
			{
				char* pvaInsertStrs[1];
				pvaInsertStrs[0] = (char*)	lpszParam;

				DWORD dwRet = FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER | 
						FORMAT_MESSAGE_FROM_STRING | 
						FORMAT_MESSAGE_ARGUMENT_ARRAY,
						lpszMsg,
						0, 
						MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
						(LPTSTR) &lpMsgBuf,
						0,
						pvaInsertStrs);

				if (dwRet == 0)
				{
					SAFEDELETE(lpszMsg);
					throw (::GetLastError());
				}
			}

			if (m_bHelp && bAddToVector)
			{
				LPWSTR wszHelp = NULL ;
				if ( NULL != ( wszHelp = new WCHAR [ lstrlen ( reinterpret_cast < WCHAR* > ( ( lpMsgBuf ) ? lpMsgBuf : lpszMsg ) ) + 1 ] ) )
				{
					lstrcpy ( wszHelp, reinterpret_cast < WCHAR* > ( ( lpMsgBuf ) ? lpMsgBuf : lpszMsg ) ) ;
					m_cvHelp.push_back ( wszHelp ) ;
				}

				if ( NULL == wszHelp )
				{
					//
					// must delete here
					//
					SAFEDELETE(lpszMsg);

					// Free the memory used up the error message
					// and then exit
					if ( lpMsgBuf != NULL )
					{
						LocalFree(lpMsgBuf);
						lpMsgBuf = NULL ;
					}

					throw OUT_OF_MEMORY;
				}
			}
			else
			{
				if (m_bRecord && m_bLog && !m_bInteractiveHelp)
				{
					hr = m_WmiCliLog.WriteToXMLLog(g_wmiCmd.GetParsedInfoObject(), ( lpMsgBuf ) ? ( LPTSTR ) lpMsgBuf : lpszMsg );
					if (FAILED(hr))
					{
						m_WmiCliLog.StopLogging();
						m_bRecord = FALSE;
						hr = S_OK;
						DisplayString(IDS_E_WRITELOG_FAILED, FALSE, NULL, TRUE);
					}
					m_bLog = FALSE;
				}

				if (m_bInteractiveHelp)
				{
					m_chsOutput += ( ( lpMsgBuf ) ? ( LPTSTR ) lpMsgBuf : lpszMsg ) ;
				}

				DisplayMessage ( ( ( lpMsgBuf ) ? ( LPTSTR ) lpMsgBuf : lpszMsg ), CP_OEMCP, bIsError, FALSE, m_bOutputGoingToStream ) ;
			}

			//
			// must delete here
			//
			SAFEDELETE(lpszMsg);

			// Free the memory used up the error message
			// and then exit
			if ( lpMsgBuf != NULL )
			{
				LocalFree(lpMsgBuf);
				lpMsgBuf = NULL ;
			}
		}
		else
			_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
    catch(_com_error& e)
	{
		if ( lpMsgBuf != NULL )
		{
			LocalFree(lpMsgBuf);
			lpMsgBuf = NULL ;
		}

		SAFEDELETE(lpszMsg);
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		if ( lpMsgBuf != NULL )
		{
			LocalFree(lpMsgBuf);
			lpMsgBuf = NULL ;
		}

		 SAFEDELETE(lpszMsg);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}

}

/*------------------------------------------------------------------------
   Name				 :DisplayString
   Synopsis	         :Displays localized string 
   Type	             :Member Function 
   Input parameter   :
			lszpMsg  - string  
			bScreen	 - TRUE	- write to screen
					   FALSE - write only to log file
			bIsError - TRUE - write to STDERR
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayString(lpszMsg, bScreen, bIsError)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayString(LPTSTR lpszMsg, BOOL bScreen, BOOL bIsError)
{
	HRESULT hr = S_OK;
	try
	{
		if ( m_bGetOutOpt == TRUE )
		{
			// Get the output option to redirect the output.
			m_opsOutputOpt	= g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										GetOutputOrAppendOption(TRUE);
			m_bGetOutOpt = FALSE;	
		}

		if ( m_bGetAppendFilePinter == TRUE )
		{
			// FALSE for getting append file pointer.
			m_fpAppendFile = g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(FALSE);
			m_bGetAppendFilePinter = FALSE;
		}

		if ( m_bGetOutputFilePinter == TRUE )
		{
			// TRUE for getting append file pointer.
			m_fpOutFile = g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(TRUE);
			m_bGetOutputFilePinter = FALSE;
		}
	
		// If write to screen is TRUE and help flag is not enabled.
		if (bScreen && !m_bHelp)
		{
			if (m_bRecord && m_bLog && !m_bInteractiveHelp)
			{
				hr = m_WmiCliLog.WriteToXMLLog(g_wmiCmd.GetParsedInfoObject(),lpszMsg);
				if (FAILED(hr))
				{
					m_WmiCliLog.StopLogging();
					m_bRecord = FALSE;
					hr = S_OK;
					DisplayString(IDS_E_WRITELOG_FAILED, FALSE, NULL, TRUE);
				}
				m_bLog = FALSE;
			}

			if (m_bInteractiveHelp)
			{
				m_chsOutput += lpszMsg;
			}

			DisplayMessage ( lpszMsg, CP_OEMCP, bIsError, FALSE, m_bOutputGoingToStream ) ;
		}
		else if (m_bHelp)
		{
			LPWSTR wszHelp = NULL ;
			if ( NULL != ( wszHelp = new WCHAR [ lstrlen ( lpszMsg ) + 1 ] ) )
			{
				lstrcpy ( wszHelp, lpszMsg ) ;
				m_cvHelp.push_back ( wszHelp ) ;
			}
			else
			{
				throw OUT_OF_MEMORY;
			}
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayPagedHelp
   Synopsis	         :Displays help in pages
   Type	             :Member Function 
   Input parameter   :
			rParsedInfo - reference to CParsedInfo object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayPagedHelp(rParsedInfo)
------------------------------------------------------------------------*/
void CFormatEngine::DisplayPagedHelp(CParsedInfo& rParsedInfo) 
{
	CHARVECTOR::iterator		itrStart	= NULL, 
								itrEnd		= NULL;
	HANDLE hStdOut							= NULL ; 
	CONSOLE_SCREEN_BUFFER_INFO	csbiInfo;
	WMICLIINT					nHeight		= 0;
	WMICLIINT					nWidth		= 1;
	WMICLIINT					nLines		= 0;
	_TCHAR						cUserKey	= 0;
	_TCHAR						cCharESC	= 0x1B;
	_TCHAR						cCharCtrlC	= 0x03;
	_bstr_t						bstrHelp;
	HRESULT						hr			= S_OK;
	
	itrStart = m_cvHelp.begin();
	itrEnd	 = m_cvHelp.end();
	try
	{
		if (m_bRecord && m_bLog)
		{
			while (itrStart != itrEnd)
			{
				bstrHelp += *itrStart;
				itrStart++;
			}

			hr = m_WmiCliLog.WriteToXMLLog(rParsedInfo, bstrHelp);
			if (FAILED(hr))
			{
				m_WmiCliLog.StopLogging();
				m_bRecord = FALSE;
				hr = S_OK;
				DisplayString(IDS_E_WRITELOG_FAILED, FALSE, NULL, TRUE);
			}
			m_bLog = FALSE;
			itrStart = m_cvHelp.begin();
		}

		if ( m_bGetOutOpt == TRUE )
		{
			// Get the output option to redirect the output.
			m_opsOutputOpt	= g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										GetOutputOrAppendOption(TRUE);
			m_bGetOutOpt = FALSE;	
		}
		
		if ( m_bGetAppendFilePinter == TRUE )
		{
			// FALSE for getting append file pointer.
			m_fpAppendFile = g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(FALSE);
			m_bGetAppendFilePinter = FALSE;
		}

		if ( m_bGetOutputFilePinter == TRUE )
		{
			// TRUE for getting append file pointer.
			m_fpOutFile = g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(TRUE);
			m_bGetOutputFilePinter = FALSE;
		}

		// Obtain the standard output handle
		hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

		while (itrStart != itrEnd)
		{
			if ( STDOUT == m_opsOutputOpt )
			{
				// Get the screen buffer size. 
				if ( hStdOut != INVALID_HANDLE_VALUE && 
				     GetConsoleScreenBufferInfo ( hStdOut, &csbiInfo ) == TRUE )
				{
					nHeight = (csbiInfo.srWindow.Bottom - csbiInfo.srWindow.Top) - 1;
					nWidth  = csbiInfo.dwSize.X;
				}
				else
				{
					nHeight = 0;
					nWidth  = 0;
				}

				// if console size is positive (to address redirection)
				if ( nHeight > 0 )
				{
					if (nLines >= nHeight)
					{
						GetConsoleScreenBufferInfo ( hStdOut, &csbiInfo ) ;

						DisplayString(IDS_I_PAKTC, FALSE);
			
						cUserKey = (_TCHAR)_getch();

						EraseConsoleString(&csbiInfo);

						nLines = 0;

						if ( cUserKey == cCharESC || cUserKey == cCharCtrlC )
							break;
					}

					nLines += ceil(((float) lstrlen(*itrStart) / (float)nWidth ));
				}
			}

			DisplayMessage ( ( *itrStart ) ) ;

			// Move to next entry
			itrStart++;
		}

		DisplayMessage ( L"\r\n" ) ;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayStdVerbsUsage
   Synopsis	         :Displays all standard verbs available.
   Type	             :Member Function 
   Input Parameter(s):
			bstrBeginStr - string that needs to be appended.
			bClass		 
					TRUE - indicates class (drop LIST from the help)
   Output Parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayStdVerbsUsage(bstrBeginStr, bClass)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayStdVerbsUsage(_bstr_t bstrBeginStr, BOOL bClass)
{
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);

	// Display help for Alias name means standard verb available to this
	// Alias name
	DisplayString(IDS_I_STDVERB_ASSOC, TRUE, (LPTSTR)bstrBeginStr);

	if ( m_bDispCALL == TRUE )
		DisplayString(IDS_I_STDVERB_CALL, TRUE, (LPTSTR)bstrBeginStr);

	DisplayString(IDS_I_STDVERB_CREATE, TRUE, (LPTSTR)bstrBeginStr);
	DisplayString(IDS_I_STDVERB_DELETE, TRUE, (LPTSTR)bstrBeginStr);

	if (!bClass)
	{
		DisplayString(IDS_I_STDVERB_GET, TRUE, (LPTSTR)bstrBeginStr);
	}
	else
	{
		DisplayString(IDS_I_CLASS_STDVERB_GET, TRUE, (LPTSTR)bstrBeginStr);
	}

	if (!bClass)
	{
		if ( m_bDispLIST == TRUE )
			DisplayString(IDS_I_STDVERB_LIST, TRUE, (LPTSTR)bstrBeginStr);
	}

	if ( m_bDispSET == TRUE )
		DisplayString(IDS_I_STDVERB_SET, TRUE, (LPTSTR)bstrBeginStr);
}

/*------------------------------------------------------------------------
   Name				 :DisplayTRANSLATEHelp
   Synopsis	         :Displays help for TRANSLATE switch
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayTRANSLATEHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayTRANSLATEHelp(CParsedInfo& rParsedInfo)
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_TRANSLATE_FULL_DESC);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_TRANSLATE_USAGE);

	CHARVECTOR cvTables = rParsedInfo.
							GetCmdSwitchesObject().GetTrnsTablesList();
	if ( !cvTables.empty() )
	{
		CHARVECTOR::iterator theIterator;

		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_TRANSLATE_HEAD);

		for ( theIterator = cvTables.begin();
			  theIterator != cvTables.end(); theIterator++ )
		{
			DisplayString(IDS_I_NEWLINE);			
			DisplayString(*theIterator);			
		}
		DisplayString(IDS_I_NEWLINE);			
	}
	else
	{
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_TRANSLATE_NOTABLES);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayEVERYHelp
   Synopsis	         :Displays help for EVERY switch
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayTRANSLATEHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayEVERYHelp(CParsedInfo& rParsedInfo)
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_EVERY_DESC_FULL);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_EVERY_USAGE);
	DisplayString(IDS_I_EVERY_NOTE);
}

/*------------------------------------------------------------------------
   Name				 :DisplayREPEATHelp
   Synopsis	         :Displays help for REPEAT switch
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayREPEATHelp()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayREPEATHelp()
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_REPEAT_DESC_FULL);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_REPEAT_USAGE);
	DisplayString(IDS_I_REPEAT_NOTE);

}

/*------------------------------------------------------------------------
   Name				 :DisplayFORMATHelp
   Synopsis	         :Displays help for FORMAT switch
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayTRANSLATEHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayFORMATHelp(CParsedInfo& rParsedInfo)
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_FORMAT_DESC_FULL);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_FORMAT_USAGE);
	DisplayString(IDS_I_FORMAT_NOTE);
	DisplayString(IDS_I_NEWLINE);

	//
	// I need to get mappings from stl map 
	// I need to add this into help so it shows up
	//
	// DisplayString(IDS_I_FORMAT_KEYWORDS);
	// DisplayString(IDS_I_NEWLINE);
	// DisplayString(IDS_I_NEWLINE);
	//
	// DisplayString(keyword, FALSE);
	//
	// will do for all pairs from WmiCmdLn::m_bmKeyWordtoFileName
	//

	const BSTRMAP* pMap = g_wmiCmd.GetMappingsMap();
	BSTRMAP::iterator theMapIterator = NULL;

	if ( pMap->size() )
	{
		DisplayString(IDS_I_FORMAT_KEYWORDS);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_NEWLINE);
	}

	for ( theMapIterator = pMap->begin(); theMapIterator != pMap->end(); theMapIterator++ )
	{
		DisplayString((*theMapIterator).first, FALSE);
		DisplayString(IDS_I_NEWLINE);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayVERBSWITCHESHelp
   Synopsis	         :Displays help on <verb switches>
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayVERBSWITCHESHelp(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayVERBSWITCHESHelp(CParsedInfo& rParsedInfo)
{
	_TCHAR *pszVerbName = rParsedInfo.GetCmdSwitchesObject().GetVerbName(); 
	BOOL bInstanceHelp = TRUE;

	if(CompareTokens(pszVerbName, CLI_TOKEN_DELETE))
	{
		if(rParsedInfo.GetCmdSwitchesObject().
							GetInteractiveMode() != INTERACTIVE)
		{
			DisplayDELETEUsage(rParsedInfo);
		}
	}

	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_USAGE);

	if(CompareTokens(pszVerbName, CLI_TOKEN_CALL) 
		|| CompareTokens(pszVerbName, CLI_TOKEN_SET)
		|| CompareTokens(pszVerbName, CLI_TOKEN_DELETE))
	{
		if(IsClassOperation(rParsedInfo))
		{
			bInstanceHelp = FALSE;
		}
		else
		{
			if(CompareTokens(pszVerbName, CLI_TOKEN_CALL))
			{
				if ( rParsedInfo.GetCmdSwitchesObject().
									GetAliasName() != NULL )
				{
					if (rParsedInfo.GetCmdSwitchesObject().
									GetWhereExpression() == NULL)
					{
						bInstanceHelp = FALSE;
					}
					else
					{
						bInstanceHelp = TRUE;
					}
				}
				else
				{
					if ((rParsedInfo.GetCmdSwitchesObject().
									GetPathExpression() != NULL)
						&& (rParsedInfo.GetCmdSwitchesObject().
									GetWhereExpression() == NULL))
					{
						bInstanceHelp = FALSE;
					}
					else
					{
						bInstanceHelp = TRUE;
					}
				}
			}
			else
			{
				bInstanceHelp = TRUE;
			}
		}
	}
	else
	{
		bInstanceHelp = FALSE;
	}
	
	if(bInstanceHelp)
	{
		DisplayString(IDS_I_VERB_INTERACTIVE_DESC1);
		DisplayString(IDS_I_VERB_INTERACTIVE_DESC2);
		DisplayString(IDS_I_NEWLINE);
		DisplayString(IDS_I_PROPERTYLIST_NOTE1);
	}
	else
	{
		DisplayString(IDS_I_VERB_SWITCH_INTERACTIVE_DESC);
	}

	if(rParsedInfo.GetCmdSwitchesObject().GetInteractiveMode() != INTERACTIVE)
	{
		DisplayString(IDS_I_VERB_SWITCH_NOINTERACTIVE_DESC);
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayCOMError
   Synopsis	         :Displays the formatted COM error
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayCOMError(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayCOMError(CParsedInfo& rParsedInfo)
{
	_com_error*	pComError				= NULL;
	_TCHAR		szBuffer[BUFFER32]		= NULL_STRING;
	_bstr_t		bstrErr, bstrFacility, bstrMsg;

	
	// Get the TRACE status and store it in m_bTrace
	m_bTrace		= rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

	// Get the Logging mode (VERBOSE | ERRORONLY | NOLOGGING) and store
	// it in m_eloErrLogOpt
	m_eloErrLogOpt	= rParsedInfo.GetErrorLogObject().GetErrLogOption();

	try
	{
		//Getting the _com_error data.
		pComError = rParsedInfo.GetCmdSwitchesObject().GetCOMError();
		
		m_ErrInfo.GetErrorString(pComError->Error(), m_bTrace, 
					bstrErr, bstrFacility);

		//Printing the _com_error into a string for displaying it
		if (m_bTrace || m_eloErrLogOpt)
		{
			_stprintf(szBuffer, _T("0x%x"), pComError->Error());
			WMIFormatMessage(IDS_I_ERROR_MSG, 3, bstrMsg, szBuffer,
							(LPWSTR) bstrErr, (LPWSTR)bstrFacility);
		}
		else
		{
			WMIFormatMessage(IDS_I_ERROR_MSG_NOTRACE, 1, bstrMsg, 
						(LPWSTR)bstrErr);
		}

		DisplayMessage((LPWSTR) bstrMsg, CP_OEMCP, TRUE, FALSE);
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayGlobalSwitchesBrief
   Synopsis	         :Display help for global switches in brief
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayGlobalSwitchesBrief()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayGlobalSwitchesBrief()
{
	DisplayString(IDS_I_NAMESPACE_BRIEF);
	DisplayString(IDS_I_ROLE_BRIEF);
	DisplayString(IDS_I_NODE_BRIEF);
	DisplayString(IDS_I_IMPLEVEL_BRIEF);
	DisplayString(IDS_I_AUTHLEVEL_BRIEF);
	DisplayString(IDS_I_LOCALE_BRIEF);
	DisplayString(IDS_I_PRIVILEGES_BRIEF);
	DisplayString(IDS_I_TRACE_BRIEF);
	DisplayString(IDS_I_RECORD_BRIEF);
	DisplayString(IDS_I_INTERACTIVE_BRIEF);
	DisplayString(IDS_I_FAILFAST_BRIEF);
	DisplayString(IDS_I_USER_BRIEF);
	DisplayString(IDS_I_PASSWORD_BRIEF);
	DisplayString(IDS_I_OUTPUT_BRIEF);
	DisplayString(IDS_I_APPEND_BRIEF);
	DisplayString(IDS_I_AGGREGATE_BRIEF);
	DisplayString(IDS_I_AUTHORITY_BRIEF);
	DisplayString(IDS_I_HELPBRIEF);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_GLBL_MORE);
}

/*------------------------------------------------------------------------
   Name				 :DisplayContext
   Synopsis	         :Displays the environment variables (i.e global 
					  switches)
   Type	             :Member Function
   Input parameter   :
		rParsedInfo	 - reference to rParsedInfo object
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :DisplayContext(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayContext(CParsedInfo& rParsedInfo)
{
	_bstr_t bstrTemp;
	// NAMESPACE
	DisplayString(IDS_I_NAMESPACE_VALUE, TRUE, 
				rParsedInfo.GetGlblSwitchesObject().GetNameSpace());

	// ROLE
	DisplayString(IDS_I_ROLE_VALUE, TRUE, 
				rParsedInfo.GetGlblSwitchesObject().GetRole());

	// NODE(S)
	rParsedInfo.GetGlblSwitchesObject().GetNodeString(bstrTemp);
	DisplayString(IDS_I_NODELIST_VALUE, TRUE, (LPWSTR)bstrTemp);

	// IMPLEVEL
	rParsedInfo.GetGlblSwitchesObject().GetImpLevelTextDesc(bstrTemp);
	DisplayString(IDS_I_IMPLEVEL_VALUE, TRUE, (LPWSTR)bstrTemp);

	// AUTHORITY
	rParsedInfo.GetAuthorityDesc(bstrTemp);
	DisplayString(IDS_I_AUTHORITY_VALUE, TRUE, (LPWSTR)bstrTemp);
			
	// AUTHLEVEL
	rParsedInfo.GetGlblSwitchesObject().GetAuthLevelTextDesc(bstrTemp);
	DisplayString(IDS_I_AUTHLEVEL_VALUE, TRUE, (LPWSTR)bstrTemp);

	// LOCALE
	DisplayString(IDS_I_LOCALE_VALUE, TRUE, 
				rParsedInfo.GetGlblSwitchesObject().GetLocale());

	// PRIVILEGES
	rParsedInfo.GetGlblSwitchesObject().GetPrivilegesTextDesc(bstrTemp);
	DisplayString(IDS_I_PRIVILEGES_VALUE, TRUE, (LPWSTR)bstrTemp);

	// TRACE
	rParsedInfo.GetGlblSwitchesObject().GetTraceTextDesc(bstrTemp);
	DisplayString(IDS_I_TRACE_VALUE, TRUE, (LPWSTR)bstrTemp);

	// RECORDPATH
	rParsedInfo.GetGlblSwitchesObject().GetRecordPathDesc(bstrTemp);
	DisplayString(IDS_I_RECORDPATH_VALUE, TRUE, (LPWSTR)bstrTemp);

	// INTERACTIVE
	rParsedInfo.GetGlblSwitchesObject().GetInteractiveTextDesc(bstrTemp);
	DisplayString(IDS_I_INTERACTIVE_VALUE, TRUE, (LPWSTR)bstrTemp);

	// FAILFAST
	rParsedInfo.GetGlblSwitchesObject().GetFailFastTextDesc(bstrTemp);
	DisplayString(IDS_I_FAILFAST_VALUE, TRUE, (LPWSTR)bstrTemp);

	// TRUE for OUTPUT option.
	rParsedInfo.GetGlblSwitchesObject().GetOutputOrAppendTextDesc(bstrTemp,
																  TRUE);
	DisplayString(IDS_I_OUTPUT_VALUE, TRUE, (LPWSTR)bstrTemp);

	// FALSE for APPEND option.
	rParsedInfo.GetGlblSwitchesObject().GetOutputOrAppendTextDesc(bstrTemp,
																  FALSE);
	DisplayString(IDS_I_APPEND_VALUE, TRUE, (LPWSTR)bstrTemp);

	// USER
	rParsedInfo.GetUserDesc(bstrTemp);
	DisplayString(IDS_I_USER_VALUE, TRUE, (LPWSTR)bstrTemp);

	//AGGREGATE
	if(rParsedInfo.GetGlblSwitchesObject().GetAggregateFlag())
		DisplayString(IDS_I_AGGREGATE_VALUE, TRUE, CLI_TOKEN_ON);
	else
		DisplayString(IDS_I_AGGREGATE_VALUE, TRUE, CLI_TOKEN_OFF);
}

/*------------------------------------------------------------------------
   Name				 :DisplayContextHelp
   Synopsis	         :Displays the help on CONTEXT keyword
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :DisplayContextHelp()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayContextHelp()
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_CONTEXT_DESC);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_CONTEXT_USAGE);
}
			

/*------------------------------------------------------------------------
   Name				 :ApplyTranslateTable
   Synopsis	         :Processes the translation specified in translate table.
   Type	             :Member Function
   Input parameter   :
			rParsedInfo - CParsedInfo object, input information.
   Output parameters :
			strString	- STRING type, string to be translated.
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :ApplyTranslateTable(strOutput, rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::ApplyTranslateTable(STRING& strString, 
										CParsedInfo& rParsedInfo)
{
	BSTRMAP bmTransTbl = rParsedInfo.GetCmdSwitchesObject().
								   GetAlsFrnNmsOrTrnsTblMap();
	BSTRMAP::iterator iTransTblEntry;
	for( iTransTblEntry = bmTransTbl.begin();
		  iTransTblEntry != bmTransTbl.end();iTransTblEntry++ )
	{
		_TCHAR cValue1, cValue2, cTemp;
		if ( IsValueSet((*iTransTblEntry).first, cValue1, cValue2) )
		{
			for ( cTemp = cValue1; cTemp <= cValue2 ; cTemp++)
			{
				_TCHAR szTemp[2];
				szTemp[0] = cTemp;
				szTemp[1] = _T('\0');
				FindAndReplaceAll(strString, szTemp,
									(*iTransTblEntry).second);
			}
		}
		else
		{
			FindAndReplaceAll(strString, (*iTransTblEntry).first,
										(*iTransTblEntry).second);
		}
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayInvalidProperties
   Synopsis	         :Displays the list of invalid properties
   Type	             :Member Function
   Input parameter   :
			rParsedInfo - CParsedInfo object, input information.
			bSetVerb	- SET verb
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayInvalidProperties(rParsedInfo, bSetVerb)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayInvalidProperties(CParsedInfo& rParsedInfo, 
											 BOOL bSetVerb)
{
	CHARVECTOR::iterator	cvIterator	=  NULL;
	LONG					lCount		=  0;
	_bstr_t					bstrMsg; 	

	try
	{
		// Get the list of properties.
		CHARVECTOR cvPropertyList = rParsedInfo.GetCmdSwitchesObject().
											GetPropertyList();

		// Get the property details pooled up from alias definition
		PROPDETMAP pdmPropDetMap = rParsedInfo.GetCmdSwitchesObject().
											GetPropDetMap();

		if (cvPropertyList.size() != pdmPropDetMap.size() && 
						cvPropertyList.size() != 0)
		{
			for ( cvIterator = cvPropertyList.begin(); 
				  cvIterator != cvPropertyList.end();
				  cvIterator++ )
			{
				PROPDETMAP::iterator tempIterator = NULL;
				if ( !Find(pdmPropDetMap, *cvIterator, tempIterator) )
				{
					if ( lCount == 0)
					{
						bstrMsg += _bstr_t(*cvIterator);
					}
					else
					{
						bstrMsg += _bstr_t(L", ") + _bstr_t(*cvIterator);
					}
					lCount++;
				}
			}
			DisplayString(IDS_I_NEWLINE);
			if (bSetVerb)
				DisplayString(IDS_I_INVALID_NOWRITE_PROS, 
								TRUE, (LPWSTR)bstrMsg);
			else
				DisplayString(IDS_I_INVALID_PROS, TRUE, (LPWSTR)bstrMsg);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :DisplayLargeString
   Synopsis	         :Displays the large string line by line. And respond 
					  to Ctr+C event.	
   Type	             :Member Function
   Input parameter(s):
			rParsedInfo		- CParsedInfo object, input information.
			strLargeString	- reference to STRING object.
   Output parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayLargeString(rParsedInfo, stroutput)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayLargeString(CParsedInfo& rParsedInfo, 
										STRING& strLargeString)
{
	size_t	nLineStart	= 0;
	size_t	nLineEnd	= 0;

	while ( TRUE )
	{
		if ( g_wmiCmd.GetBreakEvent() == TRUE )
		{
			DisplayString(IDS_I_NEWLINE);
			break;
		}

		nLineEnd = strLargeString.find(_T("\n"), nLineStart);

		if ( nLineEnd == STRING::npos )
		{
			//
			// string may not be terminated by \n
			// check for NULL terminator
			//
			nLineEnd = strLargeString.find(_T("\0"), nLineStart);
		}

		if ( nLineEnd != STRING::npos )
		{
			DisplayString( (LPTSTR) strLargeString.substr ( nLineStart, ( nLineEnd - nLineStart + 1 ) ).data() ) ;
			nLineStart = nLineEnd + 1;
		}
		else
		{
			DisplayString(IDS_I_NEWLINE);
			break;
		}
	}
}

/*------------------------------------------------------------------------
   Name				 :TraverseNode
   Synopsis	         :Travese through XML stream node by node and translate 
					  all nodes
   Type	             :Member Function
   Input parameter   :
			rParsedInfo - CParsedInfo object, input information.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :TraverseNode(rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CFormatEngine::TraverseNode(CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	IXMLDOMElement			*pIXMLDOMElement	= NULL;
	IXMLDOMNodeList			*pIDOMNodeList		= NULL;
	IXMLDOMNode				*pIDOMNode			= NULL;
	IXMLDOMNode				*pIParentNode		= NULL;
	IXMLDOMNode				*pINewNode			= NULL;
	LONG					lValue				= 0;
	BSTR					bstrItemText		= NULL;
	BOOL					bRet				= TRUE;
	DWORD					dwThreadId			= GetCurrentThreadId();
	try
	{
		if(m_pIXMLDoc != NULL)
		{
			_bstr_t bstrTemp = rParsedInfo.GetCmdSwitchesObject().
									GetXMLResultSet();
	
			// Load the	XML stream 
			VARIANT_BOOL varBool;
			hr = m_pIXMLDoc->loadXML(bstrTemp, &varBool);
			if (m_bTrace || m_eloErrLogOpt)
			{
				WMITRACEORERRORLOG(hr, __LINE__, 
						__FILE__, _T("IXMLDOMDocument::loadXML(-, -)"), 
						dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			
			if(varBool == VARIANT_TRUE)
			{
				// Get the document element.
				hr = m_pIXMLDoc->get_documentElement(&pIXMLDOMElement);
				if (m_bTrace || m_eloErrLogOpt)
				{
					WMITRACEORERRORLOG(hr, __LINE__, 
					__FILE__, _T("IXMLDOMDocument::get_documentElement(-)"), 
					dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);

				if (pIXMLDOMElement != NULL)
				{
					// Get the Node List named <VALUE> in the current XML doc
					hr = pIXMLDOMElement->getElementsByTagName
							(_bstr_t(L"VALUE"), &pIDOMNodeList);
					if (m_bTrace || m_eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
							_T("IXMLDOMElement::getElementsByTagName"
							L"(L\"VALUE\", -)"), dwThreadId, rParsedInfo, 
							m_bTrace);
					}
					ONFAILTHROWERROR(hr);
					 
					// Get the length of the node list
					hr	= pIDOMNodeList->get_length(&lValue);
					if (m_bTrace || m_eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNodeList::get_length(-)"), 
							dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);

					// Traverse through full node list and apply 
					// translate table on  each node
					for(WMICLIINT ii = 0; ii < lValue; ii++)
					{
						// Get a node from node list
						hr = pIDOMNodeList->get_item(ii, &pIDOMNode);
						if (m_bTrace || m_eloErrLogOpt)
						{
							WMITRACEORERRORLOG(hr, __LINE__, 
								__FILE__, _T("IXMLDOMNodeList::get_item(-,-)"), 
								dwThreadId, rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						if (pIDOMNode == NULL)
							continue;

						// Get the value stored in the node
						hr = pIDOMNode->get_text(&bstrItemText);
						if (m_bTrace || m_eloErrLogOpt)
						{
							WMITRACEORERRORLOG(hr, __LINE__, 
								__FILE__, _T("IXMLDOMNode::get_text(-)"), 
								dwThreadId, rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						// Get the parent node of the current node to store 
						// the  translated value in the current node
						hr = pIDOMNode->get_parentNode(&pIParentNode);
						if (m_bTrace || m_eloErrLogOpt)
						{
							WMITRACEORERRORLOG(hr, __LINE__, 
								__FILE__, _T("IXMLDOMNode::get_parentNode(-)"), 
								dwThreadId, rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						// Create a clone node of current node
						VARIANT_BOOL vBool = VARIANT_FALSE;
						hr = pIDOMNode->cloneNode(vBool, &pINewNode);
						if (m_bTrace || m_eloErrLogOpt)
						{
							WMITRACEORERRORLOG(hr, __LINE__, 
								__FILE__, _T("IXMLDOMNode::cloneNode(-,-)"), 
								dwThreadId, rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						if (pINewNode != NULL && pIParentNode != NULL)
						{
							// If /TRANSLATE:<table> is specified.
							STRING strOutput((_TCHAR*)bstrItemText);
							if ( rParsedInfo.GetCmdSwitchesObject().
											GetTranslateTableName() != NULL )
							{
								// Translate the result 
								ApplyTranslateTable(strOutput, rParsedInfo);
							}

							// Reconvert the char string into BSTR string
							_bstr_t bstrTemp = 
										_bstr_t((LPTSTR)strOutput.data());

							// Write the translated value into new node
							hr = pINewNode->put_text(bstrTemp);
							if (m_bTrace || m_eloErrLogOpt)
							{
								WMITRACEORERRORLOG(hr, __LINE__, 
								__FILE__, _T("IXMLDOMNode::put_text(-)"), 
								dwThreadId, rParsedInfo, m_bTrace);
							}
							ONFAILTHROWERROR(hr);

							// Replace current node with translated node 
							hr = pIParentNode->replaceChild(pINewNode, 
											pIDOMNode, NULL);
							if (m_bTrace || m_eloErrLogOpt)
							{
								WMITRACEORERRORLOG(hr, __LINE__, 
								__FILE__, 
								_T("IXMLDOMNode::replaceChild(-,-,-)"), 
								dwThreadId, rParsedInfo, m_bTrace);
							}
							ONFAILTHROWERROR(hr);
						}

						SAFEBSTRFREE(bstrItemText);
						bstrItemText = NULL;
						SAFEIRELEASE(pINewNode);
						SAFEIRELEASE(pIParentNode);
						SAFEIRELEASE(pIDOMNode);
					}
					SAFEIRELEASE(pIDOMNodeList);
					SAFEIRELEASE(pIXMLDOMElement);
					bRet = TRUE;
				}
			}
			else
				bRet = FALSE;
		}
		else
			bRet = FALSE;
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIParentNode);
		SAFEIRELEASE(pINewNode);
		SAFEIRELEASE(pIDOMNode);
		SAFEIRELEASE(pIDOMNodeList);
		SAFEIRELEASE(pIXMLDOMElement);
		SAFEBSTRFREE(bstrItemText);
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
Name			  :DisplayRESULTCLASSHelp
Synopsis	      :Displays help for RESULT CLASS  switch
Type	          :Member Function 
Input parameter   :None
Output parameters :None
Return Type       :void
Global Variables  :None
Calling Syntax    :DisplayRESULTCLASSHelp()
Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayRESULTCLASSHelp()
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_RESULTCLASS_DESC_FULL);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_RESULTCLASS_USAGE);
}

/*------------------------------------------------------------------------
   Name				 :DisplayRESULTROLEHelp
   Synopsis	         :Displays help for RESULT ROLE  switch
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayRESULTROLEHelp()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayRESULTROLEHelp()
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_RESULTROLE_DESC_FULL );
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_RESULTROLE_USAGE);	
}
/*------------------------------------------------------------------------
   Name				 :DisplayASSOCCLASSHelp
   Synopsis	         :Displays help for ASSOCCLASS switch
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayASSOCCLASSHelp()
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::DisplayASSOCCLASSHelp()
{
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_ASSOCCLASS_DESC_FULL);
	DisplayString(IDS_I_USAGE);
	DisplayString(IDS_I_NEWLINE);
	DisplayString(IDS_I_SWITCH_ASSOCCLASS_USAGE);	
}


/*------------------------------------------------------------------------
   Name				 :AppendtoOutputString
   Synopsis	         :Appends the content currently being displayed, to the
					  m_chsOutput which will be used for XML logging
   Type	             :Member Function 
   Input parameter   :
		pszOutput  - output string
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :AppendtoOutputString(pszOutput)
   Notes             :None
------------------------------------------------------------------------*/
void CFormatEngine::AppendtoOutputString(_TCHAR* pszOutput)
{
	m_chsOutput += pszOutput;
}

/*------------------------------------------------------------------------
   Name				 :DoCascadeTransforms
   Synopsis	         :Does cascading transforms on the XML output obtained
					  as result (the intermediate transforms should data
					  which is DOM compliant)
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo object
   Output parameters :
		bstrOutput	 - transformed output
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :DoCascadeTransforms(rParsedInfo, bstrOutput)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CFormatEngine::DoCascadeTransforms(CParsedInfo& rParsedInfo,
										_bstr_t& bstrOutput)
{
	HRESULT				hr					= S_OK;
	IXMLDOMDocument2	*pIStyleSheet		= NULL;
	IXMLDOMDocument2	*pIObject			= NULL;
	IXSLTemplate		*pITemplate			= NULL;
	IXSLProcessor		*pIProcessor		= NULL;
	VARIANT				varValue, vtOutStream;
	VariantInit(&varValue);
	VariantInit(&vtOutStream);
	VARIANT_BOOL		varLoad				= VARIANT_FALSE;
	XSLTDETVECTOR		vecXSLDetails;
	XSLTDETVECTOR::iterator vecEnd			= NULL,
						vecIterator			= NULL;

	BSTRMAP::iterator	mapItrtr			= NULL,
						mapEnd				= NULL;

	BOOL				bFirst				= TRUE;
	DWORD				dwCount				= 0;
	DWORD				dwSize				= 0;
	BOOL				bRet				= TRUE;
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	CFileOutputStream	outStrm;

	vecXSLDetails = rParsedInfo.GetCmdSwitchesObject().GetXSLTDetailsVector();
	try
	{
		// Create single instance of the IXSLTemplate
		hr = CoCreateInstance(CLSID_XSLTemplate, NULL, CLSCTX_SERVER, 
				IID_IXSLTemplate, (LPVOID*)(&pITemplate));
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"CoCreateInstance(CLSID_XSLTemplate, NULL,"
					 L" CLSCTX_SERVER, IID_IXSLTemplate, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);
		
		if (pITemplate)
		{
			vecIterator = vecXSLDetails.begin();
			vecEnd		= vecXSLDetails.end();
			dwSize		= vecXSLDetails.size();

			// Loop thru the list of cascading transforms specified.
			while (vecIterator != vecEnd)
			{
				// Create single instance of IXMLDOMDocument2
				hr = CoCreateInstance(CLSID_FreeThreadedDOMDocument, NULL,
							CLSCTX_SERVER, IID_IXMLDOMDocument2, 
							(LPVOID*) (&pIStyleSheet));
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"CoCreateInstance("
						L"CLSID_FreeThreadedDOMDocument, NULL, CLSCTX_SERVER,"
						L"IID_IXMLDOMDocument2, -)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
							dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);
	
				if (pIStyleSheet)
				{
					hr = pIStyleSheet->put_async(VARIANT_FALSE);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IXSLDOMDocument2::put_async("
						L"VARIANT_FALSE)");
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);

					dwCount++;
											
					// Load the transform document (xsl)
					hr = pIStyleSheet->load(_variant_t((*vecIterator)
											.FileName), &varLoad);
					if (m_bTrace || m_eloErrLogOpt)
					{
						chsMsg.Format(L"IXSLDOMDocument2::load("
						L"L\"%s\", -)", (WCHAR*)(*vecIterator).FileName);

						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, m_bTrace);
					}
					ONFAILTHROWERROR(hr);

					if (varLoad == VARIANT_TRUE)
					{
						// Add the reference of the stylesheet to the 
						// IXSLTemplate object
						hr = pITemplate->putref_stylesheet(pIStyleSheet);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IXSTemplate::putref_stylesheet("
							L"-)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
								(LPCWSTR)chsMsg, dwThreadId, 
								rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						// Create the processor object
						hr = pITemplate->createProcessor(&pIProcessor);
						if (m_bTrace || m_eloErrLogOpt)
						{
							chsMsg.Format(L"IXSTemplate::createProcessor("
							L"-)");
							WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
								(LPCWSTR)chsMsg, dwThreadId, 
								rParsedInfo, m_bTrace);
						}
						ONFAILTHROWERROR(hr);

						if (pIProcessor)
						{
							// If parameters are specified
							if ((*vecIterator).ParamMap.size())
							{
								// Add the list of parameters specified to the
								// IXSLProcessor  interface object
								hr = AddParameters(rParsedInfo, pIProcessor, 
											(*vecIterator).ParamMap);
								ONFAILTHROWERROR(hr);
							}
							// If first tranformation, then feed the XML data
							// loaded into m_pIXMLDoc for transformation
							if (bFirst)
							{
								hr = pIProcessor->put_input(
													_variant_t(m_pIXMLDoc));
								bFirst = FALSE;
							}
							else
							{
								// Intermediate transformation - load the 
								// result data obtained in previous 
								// transformation
								hr = pIProcessor->put_input(
													_variant_t(pIObject));
							}
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IXSProcessor::put_input("
								L"-)");
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
									(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
									m_bTrace);
							}
							ONFAILTHROWERROR(hr);
							
							// if last transform then direct output to file
							// Streaming of output is done only if output 
							// redirection is specified or in case inline 
							// /output command 
							if (dwCount == dwSize)
							{
								// Set output stream i.e output file or
								// redirection file.
								// This function 
								if ( SetOutputStream(outStrm, vtOutStream) 
																	 == TRUE )
								{
									// Put output stream in IXSLProcessor
									// so that when transform() is executed
									// output goes directly to the stream
									// i.e output file or redirection file
									hr = pIProcessor->put_output(vtOutStream);
									if (m_bTrace || m_eloErrLogOpt)
									{
										chsMsg.Format(L"IXSProcessor::put_output("
										L"-)");
										WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
											(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
											m_bTrace);
									}
									ONFAILTHROWERROR(hr);
								}
							}

							// Transform the content
							hr = pIProcessor->transform(&varLoad);
							if (m_bTrace || m_eloErrLogOpt)
							{
								chsMsg.Format(L"IXSProcessor::tranform("
								L"-)");
								WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
									(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
									m_bTrace);
							}
							ONFAILTHROWERROR(hr);

							// If last transform is streamed out to stream 
							// specified by put_output() then apply again 
							// transform to get output in Unicode string 
							// which can be used in XML logging and for 
							// append file
							if (dwCount == dwSize &&
								m_bOutputGoingToStream == TRUE)
							{
								// Stop streaming output to out files
								V_VT(&vtOutStream) = VT_EMPTY;
								pIProcessor->put_output(vtOutStream);

								// Execute transform again to get output
								// in Unicode string
								hr = pIProcessor->transform(&varLoad);
								if (m_bTrace || m_eloErrLogOpt)
								{
									chsMsg.Format(L"IXSProcessor::tranform("
									L"-)");
									WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
										(LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
										m_bTrace);
								}
								ONFAILTHROWERROR(hr);
							}

							if (varLoad == VARIANT_TRUE)
							{
								// Retrieve the output
								hr = pIProcessor->get_output(&varValue);
								if (m_bTrace || m_eloErrLogOpt)
								{
									chsMsg.Format(L"IXSProcessor::"
										L"get_output(-)");
									WMITRACEORERRORLOG(hr, __LINE__, __FILE__,
									 (LPCWSTR)chsMsg, dwThreadId, rParsedInfo, 
									 m_bTrace);
								}
								ONFAILTHROWERROR(hr);

								// intermediate transform
								if (dwCount != dwSize)
								{
									if (pIObject == NULL)
									{
										hr = CoCreateInstance(CLSID_FreeThreadedDOMDocument,
												NULL, CLSCTX_SERVER, 
												IID_IXMLDOMDocument2, 
												(LPVOID*)(&pIObject));
										if (m_bTrace || m_eloErrLogOpt)
										{
											chsMsg.Format(L"CoCreateInstance("
												L"CLSID_FreeThreadedDOMDocument, NULL,"
												L" CLSCTX_INPROC_SERVER, "
												L"IID_IXMLDOMDocument2, -)");
											WMITRACEORERRORLOG(hr, __LINE__, 
												__FILE__, (LPCWSTR)chsMsg, 
												dwThreadId, rParsedInfo, 
												m_bTrace);
										}
										ONFAILTHROWERROR(hr);
									}	
	
									hr = pIObject->loadXML(
											varValue.bstrVal, &varLoad);
									if (m_bTrace || m_eloErrLogOpt)
									{
										chsMsg.Format(L"IXMLDOMDocument2::"
											L"loadXML(-, -)");
										WMITRACEORERRORLOG(hr, __LINE__, 
										__FILE__, (LPCWSTR)chsMsg, dwThreadId, 
										rParsedInfo, m_bTrace);
									}
									ONFAILTHROWERROR(hr);
								
									if (varLoad == VARIANT_FALSE)
									{
										// Invalid XML content.
										rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(
											IDS_E_INVALID_XML_CONTENT);
										bRet = FALSE;
										break;
									}
								}
								// last transform - print the result.
								else
								{
									bstrOutput = _bstr_t(varValue);
								}
								VariantClear(&varValue);
							}
							SAFEIRELEASE(pIProcessor);
						}
					}
					else
					{
						// Invalid XSL format.
						rParsedInfo.GetCmdSwitchesObject()
								.SetErrataCode(IDS_E_INVALID_FORMAT);
						bRet = FALSE;
						break;
					}
					SAFEIRELEASE(pIStyleSheet);
				}
				vecIterator++;
			}
			VariantClear(&vtOutStream);
			SAFEIRELEASE(pIProcessor);
			SAFEIRELEASE(pITemplate);
			SAFEIRELEASE(pIObject);
			SAFEIRELEASE(pITemplate);
		}
	}
	catch(_com_error& e)
	{
		rParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		VariantClear(&varValue);
		VariantClear(&vtOutStream);
		SAFEIRELEASE(pIProcessor);
		SAFEIRELEASE(pIStyleSheet);
		SAFEIRELEASE(pITemplate);
		SAFEIRELEASE(pIObject);
		bRet = FALSE;
	}
	//trap for CHeap_Exception
	catch(CHeap_Exception)
	{
		VariantClear(&varValue);
		VariantClear(&vtOutStream);
		SAFEIRELEASE(pIProcessor);
		SAFEIRELEASE(pIStyleSheet);
		SAFEIRELEASE(pITemplate);
		SAFEIRELEASE(pIObject);
		bRet = FALSE;
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :AddParameters
   Synopsis	         :Adds parameters to the IXSLProcessor object
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo  - reference to CParsedInfo object
		pIProcessor  - IXSLProcessor object
		bstrmapParam - parameter map
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :AddParameters(rParsedInfo, pIProcessor, bstrmapParam)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT	CFormatEngine::AddParameters(CParsedInfo& rParsedInfo,
									 IXSLProcessor	*pIProcessor, 
									 BSTRMAP bstrmapParam)
{
	HRESULT				hr					= S_OK;
	BSTRMAP::iterator	mapItrtr			= NULL,
						mapEnd				= NULL;
	_bstr_t				bstrProp,
						bstrVal;	
	CHString			chsMsg;
	DWORD				dwThreadId			= GetCurrentThreadId();
	try
	{
		mapItrtr	= bstrmapParam.begin();
		mapEnd		= bstrmapParam.end();	

		// Loop thru the available parameters
		while (mapItrtr != mapEnd)
		{
			bstrProp = (*mapItrtr).first;
			bstrVal	 = (*mapItrtr).second;

			// Add the parameter to the IXSLProcessor 
			hr = pIProcessor->addParameter(bstrProp, _variant_t(bstrVal));
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IXSProcessor::addParameter(L\"%s\", -)",
								(WCHAR*) bstrProp);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
					dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
			mapItrtr++;
		}
	}
	catch(_com_error& e)
	{
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
		_com_issue_error(hr);
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :SetOutputStream
   Synopsis	         :Sets the output stream, if /OUTPUT if FILEOUTPUT and 
					  is inline command i.e /OUTPUT:file command,
					  Or output redirection is specified. 	
   Type	             :Member Function 
   Input parameter   :
   Output parameters :
		fosFileOutputStream - CFileOutputStream object, initialized output stream
		vtStream			- VARIANT type, holds the stream object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetOutputStream(outStrm, vtOutStream); 
   Notes             :None
------------------------------------------------------------------------*/
BOOL CFormatEngine::SetOutputStream(CFileOutputStream& fosFileOutputStream,
	  							    VARIANT& vtStream)
{
	BOOL	bRet	= TRUE;
	HRESULT hr		= S_OK;

	try
	{
		if ( m_bGetOutOpt == TRUE )
		{
			// Get the output option to redirect the output.
			m_opsOutputOpt	= g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										GetOutputOrAppendOption(TRUE);
			m_bGetOutOpt = FALSE;	
		}

		// If Output is directed to file and /OUTPUT is appearing in command
		// i.e ( /OUTPUT:<file> command )
		if ( m_opsOutputOpt == FILEOUTPUT &&
			 g_wmiCmd.GetParsedInfoObject().GetCmdSwitchesObject().
											GetOutputSwitchFlag() == TRUE )
		{
			// Close the output file which is already opened in text mode.
			if ( CloseOutputFile() == TRUE )
			{
				// Make Out file pointer NULL.
				m_fpOutFile = NULL;
				// Set output file to stream
				hr = fosFileOutputStream.Init(
							g_wmiCmd.
								GetParsedInfoObject().
										GetGlblSwitchesObject().
											GetOutputOrAppendFileName(TRUE));
				ONFAILTHROWERROR(hr);
			}
			m_bOutputGoingToStream	= TRUE;
		}
		else if ( IsRedirection() == TRUE ) // If output redirection is specified
		{
            HANDLE hFile = GetStdHandle(STD_OUTPUT_HANDLE);
            BOOL bOutputGoingToStream = FALSE;
            if (FILE_TYPE_DISK == GetFileType(hFile))
            {
				bOutputGoingToStream = TRUE;
            }

            if(bOutputGoingToStream)
            {
			    hr = fosFileOutputStream.Init(GetStdHandle(STD_OUTPUT_HANDLE));
			    ONFAILTHROWERROR(hr);
			    m_bOutputGoingToStream	= TRUE;
            }
		}

		if ( m_bOutputGoingToStream == TRUE )
		{
			V_VT(&vtStream) = VT_UNKNOWN;
			V_UNKNOWN(&vtStream) = &fosFileOutputStream;
		}
		else
			bRet = FALSE;
	}
	catch(_com_error& e)
	{
		g_wmiCmd.GetParsedInfoObject().GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\execengine.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ExecEngine.h
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of member variable and
							  functions declarations of the Execution engine
							  module.
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 20th-March-2001
****************************************************************************/ 

/*-------------------------------------------------------------------
 Class Name			: CExecEngine
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for executing the WMI statements that are obtained
					  as a result of parsing engine. It also performs 
					  verb specific processing using the information 
					  available with CParsedInfo class.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: CParsedInfo
 Interfaces Used    : WMI COM Interfaces
 --------------------------------------------------------------------*/

class CParsedInfo;

class CExecEngine
{
public:
// Construction
	CExecEngine();

// Destruction
	~CExecEngine();

// Restrict Assignment
	CExecEngine& operator=(CExecEngine& rExecEngine);

// Attributes
private:
	// trace flag
	BOOL				m_bTrace;

	ERRLOGOPT			m_eloErrLogOpt;
	// Pointer to object of type IWbemObjectTextSrc encapsulates the 
	// functionality of WMI XML Encoder
	IWbemObjectTextSrc	*m_pITextSrc;
	
	// Pointer to object of type IWbemLocator, used to obtain IWbemServices 
	// object.
	IWbemLocator		*m_pIWbemLocator;
	
	// Pointer to object of type IWbemServices, Used to perform WMI operations
	// on target namespace.
	IWbemServices		*m_pITargetNS;

	// Context pointer
	IWbemContext		*m_pIContext;

	BOOL				m_bSysProp;

	BOOL				m_bNoAssoc;
// Operations
private:
	// Creates the instance of IWbemObjectTextSrc interface.
	HRESULT				CreateWMIXMLTextSrc(CParsedInfo& rParsedInfo);

	// Creates the instance of IWbemContext interface
	HRESULT				CreateContext(CParsedInfo& rPrasedInfo);

	// Connect to the WMI namespace on the target machine.
	HRESULT				ConnectToTargetNS(CParsedInfo& rParsedInfo);

	// Executes query to give results in XML file format. 
	// Refers data in the CCommnadSwicthes object of CParsedInfo object.
	HRESULT				ObtainXMLResultSet(BSTR bstrQuery,
										   CParsedInfo& rParsedInfo,
										   _bstr_t& bstrXML,
										   BOOL bSysProp = TRUE,
										   BOOL bNotAssoc = TRUE);

	HRESULT				FrameAssocHeader(_bstr_t bstrPath, _bstr_t& bstrFrag,
										BOOL bClass);

	// This function changes the property value for the 
    // given property name and value
	BOOL				SetPropertyInfo(CParsedInfo& rParsedInfo, 
										_bstr_t& bstrQuery, 
										_bstr_t& bstrObject);
	
	// Executes a WMI method specified in the CCommandSwicthes 
	// object of the CParsedInfo object passed to it.
	BOOL				ExecWMIMethod(CParsedInfo&);
	
	// Processes and executes GET|LIST verb referring CParsedInfo object
	// or to display help in interactive mode by displaying properties of 
	// concernrd instance.
	BOOL				ProcessSHOWInfo(CParsedInfo& rParsedInfo, BOOL bVerb=TRUE, 
															_TCHAR* pszPath=NULL);
	
	// Processes and executes CALL verb referring CParsedInfo object.
	BOOL				ProcessCALLVerb(CParsedInfo& rParsedInfo);
	
	// Processes and executes SET verb referring CParsedInfo object.
	BOOL				ProcessSETVerb(CParsedInfo& rParsedInfo);
	
	// Processes and executes CREATE verb referring CParsedInfo object.
	BOOL				ProcessCREATEVerb(CParsedInfo& rParsedInfo);

	// Processes and executes DELETE verb referring CParsedInfo object.
	BOOL				ProcessDELETEVerb(CParsedInfo& rParsedInfo);

	// Processes and executes ASSOC verb referring CParsedInfo object.
	BOOL				ProcessASSOCVerb(CParsedInfo& rParsedInfo);
	
	// This function constructs the path expression from alias info and
	// where info. Used for CALL verb only
	BOOL				FormPathExprFromWhereExpr(_bstr_t& bstrPath, 
												  CParsedInfo& rParsedInfo);

	// This function changes the property values for the given property names 
	// and values in a passed IWbemClassObject
	BOOL				SetProperties(CParsedInfo& rParsedInfo, 
				 					  IWbemClassObject* pIWbemObj, 
									  BOOL bClass);

	// Deletes the objects
	BOOL				DeleteObjects(CParsedInfo& rParsedInfo, 
									  _bstr_t& bstrQuery, 
									  _bstr_t& bstrObject);

	// Obtain user response
	INTEROPTION			GetUserResponse(_TCHAR* pszMsg);

	// Create a new instance
	BOOL				CreateInstance(CParsedInfo& rParsedInfo, 
									   BSTR bstrClass);

	// Validate the new input values supplied for the properties
	// against the qualifiers details.
	BOOL				ValidateInParams(CParsedInfo& rParsedInfo,
										 _bstr_t bstrClass);


	BOOL				ValidateAlaisInParams(CParsedInfo& rParsedInfo);

	BOOL				CheckAliasQualifierInfo(CParsedInfo& rParsedInfo,
												_bstr_t bstrParam,
												WCHAR*& pszValue,
												PROPDETMAP pdmPropDetMap);
									
	// Checks the parameter/property value against the following 
	// qualifiers:
	// 1. MaxLen, 2. Values 3. ValuesMap
	BOOL				CheckQualifierInfo(CParsedInfo& rParsedInfo,
										   IWbemClassObject* pIObject,
										   _bstr_t bstrParam,
										   WCHAR*& pszValue);

	// Method Execution 
	HRESULT				ExecuteMethodAndDisplayResults(_bstr_t bstrPath,
												 CParsedInfo& rParsedinfo,
												 IWbemClassObject* pIInParam);

	// Display the output parameters of method execution.
	void				DisplayMethExecOutput(CParsedInfo& rParsedInfo);

	// Invoke other command line Utilities
	BOOL				ExecOtherCmdLineUtlty(CParsedInfo& rParsedInfo);

	// Checks and returns TRUE if verb invocation mode is interactive
	BOOL				IsInteractive(CParsedInfo& rParsedInfo);	

	// Substitute hashes and execute command line utility.
	// If pIWbemObj != NULL then utility should be passed with appropriate 
	// instance values.
	void				SubstHashAndExecCmdUtility(CParsedInfo& rParsedInfo,
									IWbemClassObject *pIWbemObj = NULL);

	// Forms query and executes method or command line utility.
	HRESULT				FormQueryAndExecuteMethodOrUtility(
										CParsedInfo& rParsedInfo,
										IWbemClassObject *pIInParam = NULL);

	// This function takes the input as a path expression and 
	// extracts the Class and Where expression part from the 
	// path expression.
	BOOL				ExtractClassNameandWhereExpr(_TCHAR* pszPathExpr, 
										CParsedInfo& rParsedInfo,
										_TCHAR* pszWhere);

	// This function accepts the user response before going
	// ahead, when /INTERACTIVE is specified at the verb level
	INTEROPTION			GetUserResponseEx(_TCHAR* pszMsg);

	// Obtain param values from parameter map in the same order as they
	// appear in the alias verb definition.
	void				ObtainInParamsFromParameterMap(CParsedInfo& rParsedinfo, 
										CHARVECTOR& cvParamValues);

    HRESULT CheckForArray(IWbemClassObject* pIObj, 
							BSTR bstrProp,  VARIANT& varDest, 
                            BSTRVECTOR& vArrayValues,CParsedInfo& rParsedInfo);

	void	GetArrayFromToken(_TCHAR* pszValue, BSTRVECTOR& vArrayValues);

	BOOL	IsArrayType(IWbemClassObject* pIObj, BSTR bstrProp);

public:
	// This function uninitializes the member variables. 
	void				Uninitialize(BOOL bFlag = FALSE);
	
	// Executes the command referring to CCommandSwitches and CGlobalSwitches
	// of the CParsedInfo object of CParsedInfo object Passed to it as 
	// parameters. Puts the results back in to objects passed to it for the 
	// use of Format Engine.
	BOOL				ExecuteCommand(CParsedInfo& rParsedInfo);
	
	// Sets the locator object passed via parameter to member 
	// of the class.
	BOOL				SetLocatorObject(IWbemLocator* pILocator);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\formatengine.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: FormatEngine.h 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CFormatEngine
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 12th-March-2001
****************************************************************************/ 
/*-------------------------------------------------------------------
 Class Name			: CFormatEngine
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for displaying the following:
					  1. results in the user desired format
					  2. error code(s) with description
					  3. success/failure status
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: CParsedInfo
					  CErrorInfo 	
					  CWMICliLog
 Interfaces Used    : WMI XML Adapter
 --------------------------------------------------------------------*/

// forward declaration of classes
class CParsedInfo;
class CErrorInfo;
//class CWMICliLog;
class CWMICliXMLLog;
class CFileOutputStream;

////////////////////////////////////////////////////////////////////////
// CFormatEngine
class CFormatEngine
{
public:
// Construction
	CFormatEngine();

// Destruction
	~CFormatEngine();

// Attributes
private:
	// Pointer to object of type IXMLDOMDocument, 
	// points to XML document containing result set.
	IXMLDOMDocument2	*m_pIXMLDoc;

	// Pointer to object of type IXMLDOMDocument, 
	// points to XSL document containing format of 
	// the output result.  
	IXMLDOMDocument2	*m_pIXSLDoc;

	// Object of type CErrorInfo, Used for handling 
	// Error information.
	CErrorInfo			m_ErrInfo;

	// Object of type CWMICliLog, Used for logging 
	// the input and output to the logfile.
	//CWMICliLog			m_WmiCliLog;

	// SRIRAM - xml logging
	CWMICliXMLLog		m_WmiCliLog;
	// SRIRAM - xml logging

	// Loggin option
	ERRLOGOPT			m_eloErrLogOpt;

	// help vector
	CHARVECTOR			m_cvHelp;

	// Help flag
	BOOL				m_bHelp;

	// Record flag
	BOOL				m_bRecord;

	// Trace flag
	BOOL				m_bTrace;

	// Display LIST flag.
	OUTPUTSPEC			m_opsOutputOpt;

	// Get output option.
	BOOL				m_bGetOutOpt;

	// Display CALL flag.
	BOOL				m_bDispCALL;

	// Display SET flag.
	BOOL				m_bDispSET;

	// Display LIST flag.
	BOOL				m_bDispLIST;

	// Flag to specify availibilty of Append file pointer to format engine.
	BOOL				m_bGetAppendFilePinter;

	// File pointer of append file.
	FILE*				m_fpAppendFile;

	// Flag to specify availibilty of output file pointer to format engine.
	BOOL				m_bGetOutputFilePinter;

	// File pointer of out file.
	FILE*				m_fpOutFile;

	BOOL				m_bLog;

	CHString			m_chsOutput;

	BOOL				m_bInteractiveHelp;

	// Specifies that output is going to stream if TRUE.
	BOOL				m_bOutputGoingToStream;
	
// Operations
private:
	// Creates an empty XML Document and returns the same 
	// in Passed Parameter.
	HRESULT				CreateEmptyDocument(IXMLDOMDocument2** pIDoc);
	
	// Applies a XSL style sheet containing format of the 
	// display to a XML file Containing result set.
	BOOL				ApplyXSLFormatting(CParsedInfo& rParsedInfo);
	
	// Displays GET verb usage.
	void				DisplayGETUsage(CParsedInfo& rParsedInfo);
	
	// Displays LIST verb usage.
	void				DisplayLISTUsage(CParsedInfo& rParsedInfo);
	
	// Displays CALL verb usage.
	void				DisplayCALLUsage(CParsedInfo& rParsedInfo);
	
	// Displays SET verb usage.
	void				DisplaySETUsage(CParsedInfo& rParsedInfo);
	
	// Displays ASSOC verb usage.
	void				DisplayASSOCUsage(CParsedInfo& rParsedInfo);

	// Displays CREATE verb usage.
	void				DisplayCREATEUsage(CParsedInfo& rParsedInfo);

	// Displays DELETE verb usage
	void				DisplayDELETEUsage(CParsedInfo& rParsedInfo);
	
	// Frames the help vector
	void				FrameHelpVector(CParsedInfo& refParsedInfo);
	
	// Displays help for Alias 
	void				DisplayAliasHelp(CParsedInfo& rParsedInfo);

	// Displays help for Alias PATH
	void				DisplayPATHHelp(CParsedInfo& refParsedInfo);
	
	// Displays help for WHERE
	void				DisplayWHEREHelp(CParsedInfo& refParsedInfo);
	
	// Displays help for CLASS
	void				DisplayCLASSHelp(CParsedInfo& refParsedInfo);
	
	// Displays help for PWhere
	void				DisplayPWhereHelp(CParsedInfo& refParsedInfo);
	
	// Displays alias names
	void				DisplayAliasFriendlyNames(CParsedInfo& refParsedInfo, 
								_TCHAR* pszAlias = NULL);
	
	// Display help for Alias verbs
	void				DisplayMethodDetails(CParsedInfo& refParsedInfo);

	// Display help for /GET /?
	void				DisplayPropertyDetails(CParsedInfo& refParsedInfo);
	
	// Displays help for standard verbs
	void				DisplayStdVerbDescriptions(CParsedInfo& refParsedInfo);
	
	// Displays localized string given the resource string ID
	void				DisplayString(UINT uID, BOOL bAddToVector = TRUE,
									LPTSTR lpszParam = NULL,
									BOOL	bIsError = FALSE);

	// Displays help for global switches
	void				DisplayGlobalSwitchesAndOtherDesc(CParsedInfo& 
								refParsedInfo);

	// Displays help for global switches in brief
	void				DisplayGlobalSwitchesBrief();

	// Displays the page-by-page help
	void				DisplayPagedHelp(CParsedInfo& rParsedInfo);

	// Displays all usages of standard verb available.
	void				DisplayStdVerbsUsage(_bstr_t bstrBeginStr,
								BOOL bClass = FALSE);

	// Displays help for /TRANSLATE switch.
	void				DisplayTRANSLATEHelp(CParsedInfo& rParsedInfo);

	// Displays help for /EVERY switch.
	void				DisplayEVERYHelp(CParsedInfo& rParsedInfo);

	// Displays help for /FORMAT switch.
	void				DisplayFORMATHelp(CParsedInfo& rParsedInfo);

	// Displays help for Verb Switches.
	void				DisplayVERBSWITCHESHelp(CParsedInfo& rParsedInfo);

	// Translates the output.
	void				ApplyTranslateTable(STRING& strString, 
									 CParsedInfo& rParsedInfo);

	// Displays the environment variables.
	void				DisplayContext(CParsedInfo& rParsedInfo);

	// Displays the help on CONTEXT keyword
	void				DisplayContextHelp();

	// Displays invalid properties if any.
	void				DisplayInvalidProperties(CParsedInfo& rParsedInfo, 
												BOOL bSetVerb = FALSE);

	// Displays the large string line by line.
	void				DisplayLargeString(CParsedInfo& rParsedInfo, 
											STRING& strLargeString);

	// Travese through XML stream node by node and translate all nodes
	BOOL				TraverseNode(CParsedInfo& rParsedInfo);

	// Displays help for /RESULTCLASS assoc switch.
	void				DisplayRESULTCLASSHelp();
		
	// Displays help for /RESULTROLE assoc switch.
	void				DisplayRESULTROLEHelp();
	
	// Displays help for /ASSOCCLASS assoc switch.
	void				DisplayASSOCCLASSHelp();

	// Displays help for /REPEAT
	void				DisplayREPEATHelp();

	// Apply cascading transforms and return the result data in bstrOutput
	BOOL				DoCascadeTransforms(CParsedInfo& rParsedInfo,
										_bstr_t& bstrOutput);

	// Add the parameters to the IXSLProcessor object
	HRESULT				AddParameters(CParsedInfo& rParsedInfo, 
									IXSLProcessor *pIProcessor, 
									BSTRMAP bstrmapParam);

	// Set output stream.
	BOOL				SetOutputStream(CFileOutputStream& fosFileOutputStream,
	  									VARIANT& vtStream);

public:
	// Displays the result referring CcommandSwitches and 
	// CGlobalSwitches Objects of the CParsedInfo object.
	BOOL				DisplayResults(CParsedInfo&, BOOL bInteractiveHelp = FALSE);

	// Displays localized string given the information to be displayed.
	void				DisplayString(LPTSTR lpszMsg, BOOL bScreen = TRUE, 
									  BOOL	bIsError = FALSE);

	// Carries out the releasing process.
	void				Uninitialize(BOOL bFinal = FALSE);

	// Appends the output or prompt messages to the output string
	// Useful in the case of CALL, CREATE, DELETE and SET for logging
	// the output to XML log.
	void				AppendtoOutputString(_TCHAR* pszOutput); 

	// Returns Error info Object
	CErrorInfo&			GetErrorInfoObject() {return m_ErrInfo; };

	// Displays COM error message
	void				DisplayCOMError(CParsedInfo& rParsedInfo);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\globalswitches.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: GlobalSwitches.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality needed
					          for accessing and storing the global switches 
					          information, which will be used by Parsing, 
					          Execution and Format Engines depending upon the 
					          applicablity.
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy
	Last Modified on		: 11th-April-2001
****************************************************************************/ 
// GlobalSwitches.cpp : implementation file
//
#include "precomp.h"
#include "GlobalSwitches.h"

/*------------------------------------------------------------------------
   Name				 :CGlobalSwitches
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameters  :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CGlobalSwitches::CGlobalSwitches()
{
	m_pszNameSpace			= NULL;
	m_pszRole				= NULL;
	m_pszNode				= NULL;
	m_pszLocale				= NULL;
	m_pszUser				= NULL;
	m_pszPassword			= NULL;
	m_pszAuthorityPrinciple	= NULL; // Authority string
	m_pszRecordPath			= NULL;
	m_bPrivileges			= TRUE;
	m_uConnInfoFlag			= 0;
	m_bRoleFlag				= TRUE;
	m_bNSFlag				= TRUE;
	m_bLocaleFlag			= TRUE;
	m_bRPChange				= FALSE;
	m_bAggregateFlag		= TRUE;

	// default impersonation level is IMPERSONATE
	m_ImpLevel				= IMPERSONATE; 

	// default authentication level is DEFAULT
	m_AuthLevel				= AUTHPKTPRIVACY;   

	// Trace mode if OFF by default
	m_bTrace				= FALSE; 

	// Interactive mode is OFF by default
	m_bInteractive			= FALSE; 

	// Help flag is OFF by default
	m_bHelp					= FALSE; 

	// Default help option is BRIEF
	m_HelpOption			= HELPBRIEF;

	m_bAskForPassFlag		= FALSE;
	m_bFailFast				= FALSE;
	m_opsOutputOpt			= STDOUT;
	m_opsAppendOpt			= STDOUT;
	m_eftFileType			= ANSI_FILE;
	m_pszOutputFileName		= NULL;
	m_fpOutFile				= NULL;
	m_pszAppendFileName		= NULL;
	m_fpAppendFile			= NULL;
	m_nSeqNum				= 0;
	m_pszLoggedOnUser		= NULL;
	m_pszNodeName			= NULL;
	m_pszStartTime			= NULL;
}
/*------------------------------------------------------------------------
   Name				 :~CGlobalSwitches
   Synopsis	         :This function Uninitializes the member variables when
                      an object of the class type is instantiated
   Type	             :Destructor 
   Input parameters  :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CGlobalSwitches::~CGlobalSwitches()
{
	Uninitialize();
}

/*------------------------------------------------------------------------
   Name				 :Initialize
   Synopsis	         :This function initializes the necessary member 
					  variables.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Initialize()
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::Initialize() throw(WMICLIINT)
{
	static BOOL bFirst = TRUE;
	try
	{
		if (bFirst)
		{
			// NAMESPACE
			// Set the default namespace to 'root\cimv2'
			m_pszNameSpace = new _TCHAR [BUFFER32];

			// Check for memory allocation failure.
			if (m_pszNameSpace == NULL)
				throw OUT_OF_MEMORY;
			lstrcpy(m_pszNameSpace, CLI_NAMESPACE_DEFAULT);
			
			// Set the default role as 'root\cli'
			m_pszRole = new _TCHAR [BUFFER32];

			// Check for memory allocation failure
			if (m_pszRole == NULL)
				throw OUT_OF_MEMORY;

			lstrcpy(m_pszRole, CLI_ROLE_DEFAULT);

			// Set the system default locale in the format ms_xxx
			m_pszLocale = new _TCHAR [BUFFER32];
			
			// Check for memory allocation failure
			if (m_pszLocale == NULL)
				throw OUT_OF_MEMORY;
			_stprintf(m_pszLocale, _T("ms_%x"),  GetSystemDefaultUILanguage());


			m_pszNodeName	  = new _TCHAR [MAX_COMPUTERNAME_LENGTH + 1];
			if (m_pszNodeName == NULL)
				throw OUT_OF_MEMORY;

			DWORD dwCompNameBufferSize = MAX_COMPUTERNAME_LENGTH + 1;	
			if (GetComputerName(m_pszNodeName, &dwCompNameBufferSize))
			{
				m_pszNodeName[MAX_COMPUTERNAME_LENGTH] = _T('\0');
			}
			else
				lstrcpy(m_pszNodeName, L"N/A");

			// current node is the default.
			m_pszNode = new _TCHAR [lstrlen(m_pszNodeName)+1];

			// Check for memory allocation failure
			if (m_pszNode == NULL)
				throw OUT_OF_MEMORY;

			lstrcpy(m_pszNode, m_pszNodeName);
			
			ULONG nSize	 = 0;

			if(!GetUserNameEx(NameSamCompatible, NULL, &nSize))
			{
				m_pszLoggedOnUser = new _TCHAR [nSize + 1];
				if (m_pszLoggedOnUser == NULL)
					throw OUT_OF_MEMORY;

				if (!GetUserNameEx(NameSamCompatible, m_pszLoggedOnUser, &nSize))    
					lstrcpy(m_pszLoggedOnUser, L"N/A");

			}
			
			if (!AddToNodesList(m_pszNode))
				throw OUT_OF_MEMORY;

			// Populate the IMPLEVEL mappings
			m_cimImpLevel.insert(CHARINTMAP::value_type(_bstr_t(L"ANONYMOUS"), 1));
			m_cimImpLevel.insert(CHARINTMAP::value_type(_bstr_t(L"IDENTIFY"), 2));
			m_cimImpLevel.insert(CHARINTMAP::value_type(_bstr_t(L"IMPERSONATE"),3));
			m_cimImpLevel.insert(CHARINTMAP::value_type(_bstr_t(L"DELEGATE"), 4));

			// Populate the AUTHLEVEL mappings
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"DEFAULT"), 0));
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"NONE"), 1));
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"CONNECT"), 2));
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"CALL"), 3));
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"PKT"), 4));
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"PKTINTEGRITY"),5));
			m_cimAuthLevel.insert(CHARINTMAP::value_type(_bstr_t(L"PKTPRIVACY"),  6));

			bFirst = FALSE;
		}
	}
	catch(_com_error& e) 
	{
		_com_issue_error(e.Error());
	}
	m_HelpOption	= HELPBRIEF;
}

/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables 
					  when the execution of a command string issued on the
					  command line is completed.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::Uninitialize()
{
	SAFEDELETE(m_pszNameSpace);
	SAFEDELETE(m_pszRole);
	SAFEDELETE(m_pszLocale);
	SAFEDELETE(m_pszNode);
	CleanUpCharVector(m_cvNodesList);
	SAFEDELETE(m_pszUser);
	SAFEDELETE(m_pszPassword);
	SAFEDELETE(m_pszAuthorityPrinciple);
	SAFEDELETE(m_pszRecordPath);
	SAFEDELETE(m_pszOutputFileName);
	SAFEDELETE(m_pszAppendFileName);
	if ( m_fpOutFile != NULL )
	{
		fclose(m_fpOutFile);
		m_fpOutFile = NULL;
	}
	if ( m_fpAppendFile != NULL )
	{
		fclose(m_fpAppendFile);
		m_fpAppendFile = NULL;
	}
	m_bHelp			= FALSE;
	m_bTrace		= FALSE;
	m_bInteractive	= FALSE;
	m_HelpOption	= HELPBRIEF;
	m_AuthLevel		= AUTHPKT;   
	m_ImpLevel		= IMPERSONATE;
	m_uConnInfoFlag = 0;
	m_cimAuthLevel.clear();
	m_cimImpLevel.clear();
	m_nSeqNum				= 0;
	SAFEDELETE(m_pszLoggedOnUser);
	SAFEDELETE(m_pszNodeName);
	SAFEDELETE(m_pszStartTime);
}

/*------------------------------------------------------------------------
   Name				 :SetNameSpace
   Synopsis	         :This function Sets the namespace passed in parameter
                      to m_pszNameSpace.
   Type	             :Member Function
   Input parameters   :
      pszNameSpace   -String type,contains Namespace specified in the command
	  AliasFlag      -Boolean type,specifies whether alias flag is set or not
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetNameSpace(pszNameSpace)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetNameSpace(_TCHAR* pszNamespace)
{
	BOOL bResult = TRUE;
	if(pszNamespace)
	{
		// If the value specified is not _T("")
		if( !CompareTokens(pszNamespace, CLI_TOKEN_NULL) )
		{
			// Check if the same value is specified for the /NAMESPACE.
			if (!CompareTokens(pszNamespace, m_pszNameSpace))
			{
				SAFEDELETE(m_pszNameSpace);
				m_pszNameSpace = new _TCHAR [lstrlen(pszNamespace)+1];
				if (m_pszNameSpace)
				{
					lstrcpy(m_pszNameSpace, pszNamespace);	
					m_bNSFlag = TRUE;
				}
				else
					bResult = FALSE;
			}
		}
		// set back to default
		else
		{
			// If the current namespace is not the default namespace
			if (!CompareTokens(m_pszRole, CLI_NAMESPACE_DEFAULT))
			{
				SAFEDELETE(m_pszNameSpace)
				m_pszNameSpace = new _TCHAR [BUFFER255];
				if (m_pszNameSpace)
				{
					lstrcpy(m_pszNameSpace, CLI_NAMESPACE_DEFAULT);
					m_bNSFlag = TRUE;
				}
				else
					bResult = FALSE;
			}
		}
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetRole
   Synopsis	         :This function Sets the role passed in parameter 
                      to m_pszRole.
   Type	             :Member Function
   Input parameters   :
           pszRole   -String type,contains Role specified in the command
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetRole(pszRole)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetRole(_TCHAR* pszRole)
{
	BOOL bResult = TRUE;
	if(pszRole)
	{
		// If the value specified is not _T("")
		if( !CompareTokens(pszRole, CLI_TOKEN_NULL) )
		{
			// Check if the same value is specified for the /ROLE.
			if (!CompareTokens(pszRole, m_pszRole))
			{
				SAFEDELETE(m_pszRole);
				m_pszRole = new _TCHAR [lstrlen(pszRole)+1];
				if (m_pszRole)
				{
					lstrcpy(m_pszRole, pszRole);	
					m_bRoleFlag		= TRUE;
					m_bLocaleFlag	= TRUE;
				}
				else
					bResult = FALSE;
			}
		}
		// set back to default
		else
		{
			// If the current role is not the default role
			if (!CompareTokens(m_pszRole, CLI_ROLE_DEFAULT))
			{
				SAFEDELETE(m_pszRole)
				m_pszRole = new _TCHAR [BUFFER255];
				if (m_pszRole)
				{
					lstrcpy(m_pszRole, CLI_ROLE_DEFAULT);
					m_bRoleFlag		= TRUE;
					m_bLocaleFlag	= TRUE;
				}
				else
					bResult = FALSE;
			}
		}
	}
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :SetLocale
   Synopsis	         :This function Assigns the locale passed in parameter 
                      to m_pszLocale.
   Type	             :Member Function
   Input parameters   :
         pszLocale   -String type,It contains Locale option specified in the
                      command
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetLocale(pszLocale)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetLocale(_TCHAR* pszLocale)
{
	BOOL bResult = TRUE;
	if(pszLocale)
	{
		// If the value specified is not _T("")
		if (!CompareTokens(pszLocale, CLI_TOKEN_NULL))
		{
			// Check if the same value is specified for the /LOCALE.
			if (!CompareTokens(m_pszLocale, pszLocale))
			{	
				SAFEDELETE(m_pszLocale);
				m_pszLocale = new _TCHAR [lstrlen(pszLocale)+1];
				if (m_pszLocale)
				{
					lstrcpy(m_pszLocale, pszLocale);	
					m_uConnInfoFlag |= LOCALE;
					m_bLocaleFlag = TRUE;
					m_bRoleFlag	  = TRUE;
					m_bNSFlag	  = TRUE;
				}
				else
					bResult = FALSE;
			}
		}
		// If the value specified is _T("") - set to default system locale.
		else
		{
			_TCHAR szLocale[BUFFER32] = NULL_STRING;
			_stprintf(szLocale, _T("ms_%x"),  GetSystemDefaultUILanguage());

			// If the current role is not the default role
			if (!CompareTokens(m_pszLocale, szLocale))
			{
				SAFEDELETE(m_pszLocale);
				m_pszLocale = new _TCHAR [BUFFER32];
				if (m_pszLocale)
				{
					m_uConnInfoFlag &= ~LOCALE;
					lstrcpy(m_pszLocale, szLocale);
					m_bLocaleFlag = TRUE;
					m_bRoleFlag	  = TRUE;
					m_bNSFlag	  = TRUE;
				}
				else
					bResult = FALSE;
			}
		}
	}
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :AddToNodesList
   Synopsis	         :This function adds the node passed in parameter
                      to m_cvNodesList
   Type	             :Member Function
   Input parameters  : 
           pszNode   - String type,contains Node option specified in the
		              command
   Output parameters :None
   Return Type       :void
   Global Variables  :BOOL
   Calling Syntax    :AddToNodesList(pszNode)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::AddToNodesList(_TCHAR* pszNode)
{
	_TCHAR* pszTempNode = NULL;
	BOOL	bRet		= TRUE;

	if (!CompareTokens(pszNode, CLI_TOKEN_NULL) &&
		!CompareTokens(pszNode, CLI_TOKEN_DOT) &&
		!CompareTokens(pszNode, CLI_TOKEN_LOCALHOST) &&
		!CompareTokens(pszNode, m_pszNodeName))
	{
		pszTempNode = new _TCHAR [ lstrlen ( pszNode ) + 1 ];
		if (pszTempNode)
			lstrcpy(pszTempNode, pszNode);
		else
			bRet = FALSE;
	}
	else
	{
		// "." specifies current node
		SAFEDELETE(m_pszNode);
		m_pszNode = new _TCHAR [ lstrlen (m_pszNodeName) + 1 ];
		if (m_pszNodeName)
		{
			lstrcpy(m_pszNode, m_pszNodeName);
			pszTempNode = new _TCHAR [ lstrlen (m_pszNodeName) + 1 ];
			if (pszTempNode)
				lstrcpy(pszTempNode, m_pszNodeName);
			else
				bRet = FALSE;
		}
		else
			bRet = FALSE;
	}
	
	if (bRet)
	{
		CHARVECTOR::iterator tempIterator;
		if ( !Find(m_cvNodesList, pszTempNode, tempIterator) )
			m_cvNodesList.push_back(pszTempNode);
		else if ( CompareTokens(pszTempNode, m_pszNodeName) == TRUE )
		{
			BOOL bFound = FALSE;
			tempIterator = m_cvNodesList.begin();
			while ( tempIterator != m_cvNodesList.end() )
			{
				if ( tempIterator != m_cvNodesList.begin() )
				{
					if(CompareTokens(*tempIterator, m_pszNodeName) == TRUE)
					{
						bFound = TRUE;
						break;
					}
				}
				tempIterator++;
			}
			if(bFound == FALSE)
				m_cvNodesList.push_back(pszTempNode);
			else
				SAFEDELETE(pszTempNode);
		}
		else
			SAFEDELETE(pszTempNode);
	}
	return bRet;
}
/*------------------------------------------------------------------------
   Name				 :SetUser
   Synopsis	         :This function Assigns the user passed in parameter
                      to m_pszUser
   Type	             :Member Function
   Input parameters   :
           pszUser   -String type,contains User option specified in the 
		              command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetUser(pszUser)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetUser(_TCHAR* pszUser)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszUser);
	if(pszUser)
	{
		if (!CompareTokens(pszUser, CLI_TOKEN_NULL))
		{
			m_pszUser = new _TCHAR [lstrlen(pszUser)+1];
			if (m_pszUser)
			{
				lstrcpy(m_pszUser, pszUser);	
				m_uConnInfoFlag |= USER;
			}
			else
				bResult = FALSE;
		}
		else
			m_uConnInfoFlag &= ~USER;
	}
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :SetPassword
   Synopsis	         :This function Assigns the password passed in parameter
                      to m_pszPassword
   Type	             :Member Function
   Input parameters   :
       pszPassword   -Assigns the password passed in parameter to
	                  m_pszPassword
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetPassword(pszPassword)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetPassword(_TCHAR* pszPassword)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszPassword)
	if (!CompareTokens(pszPassword, CLI_TOKEN_NULL))
	{
		m_pszPassword = new _TCHAR [lstrlen(pszPassword)+1];
		if (m_pszPassword) 
		{
			lstrcpy(m_pszPassword, pszPassword);	
			m_uConnInfoFlag |= PASSWORD;
		}
		else
			bResult = FALSE;
	}
	else
		m_uConnInfoFlag &= ~PASSWORD;
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAuthorityPrinciple
   Synopsis	         :This function Assigns the <authority principle> passed
					  in parameter to m_pszAuthorityPrinciple
   Type	             :Member Function
   Input parameters   :
       pszPassword   -Assigns the authority string passed in parameter to
	                  m_pszAuthorityPrinciple
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAuthorityPrinciple(pszAuthorityPrinciple)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetAuthorityPrinciple(_TCHAR* pszAuthorityPrinciple)
{
	BOOL bResult = TRUE;
	SAFEDELETE(m_pszAuthorityPrinciple)
	if (!CompareTokens(pszAuthorityPrinciple, CLI_TOKEN_NULL))
	{
		m_pszAuthorityPrinciple = new _TCHAR [lstrlen(pszAuthorityPrinciple)+1];
		if (m_pszAuthorityPrinciple) 
		{
			lstrcpy(m_pszAuthorityPrinciple, pszAuthorityPrinciple);	
			m_uConnInfoFlag |= AUTHORITY;
		}
		else
			bResult = FALSE;
	}
	else
		m_uConnInfoFlag &= ~AUTHORITY;
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetRecordPath(pszRecordPath)
   Synopsis	         :This function Assigns the record file passed in
                      parameter to m_pszRecordPath
   Type	             :Member Function
   Input parameters   :
     pszRecordPath   -String type,contains Record path specified in the 
	                  command.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetRecordPath(pszRecordPath)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetRecordPath(_TCHAR* pszRecordPath)
{
	BOOL bResult = TRUE;
	if (pszRecordPath)
	{
		// Check if the value specified is not _T("")
		if (!CompareTokens(pszRecordPath, CLI_TOKEN_NULL))
		{
			SAFEDELETE(m_pszRecordPath);
			m_pszRecordPath = new _TCHAR [lstrlen(pszRecordPath)+1];
			if (m_pszRecordPath)
			{
				lstrcpy(m_pszRecordPath, pszRecordPath);	
				m_bRPChange = TRUE;
			}
			else
				bResult = FALSE;
		}
		// if the value specified is _T("") set the recordpath to NULL
		else
		{
			SAFEDELETE(m_pszRecordPath);
			m_bRPChange = TRUE;
		}
	}
	else
	{
		SAFEDELETE(m_pszRecordPath);
		m_bRPChange = TRUE;
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetPrivileges(bEnable)
   Synopsis	         :This function sets bEnable flag to TRUE if Privileges 
                     :option is specified in the command                       
   Type	             :Member Function
   Input parameters   :
     pszPrivileges   -Boolean tye,Specifies whether the flag should be
	                  enabled or disabled
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetPrivileges(pszPrivileges)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetPrivileges(BOOL bEnable)
{
	m_bPrivileges = bEnable;
}
/*------------------------------------------------------------------------
   Name				 :SetImpersonationLevel(_TCHAR* const pszImpLevel)
   Synopsis	         :This function checks whether the specified pszImpLevel
                      is valid and assigns the mapped value to m_ImpLevel.
   Type	             :Member Function
   Input parameters   :
		pszImpLevel - IMPLEVEL input string
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetImpersonationLevel(pszImpLevel)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetImpersonationLevel(_TCHAR* const pszImpLevel)
{
	BOOL bResult = TRUE;
	// Check whether the string exists in the list of available values.
	CHARINTMAP::iterator theIterator = NULL;
	theIterator = m_cimImpLevel.find(CharUpper(pszImpLevel));
	if (theIterator != m_cimImpLevel.end())
	{
		m_ImpLevel = (IMPLEVEL) (*theIterator).second;
	}
	else
		bResult = FALSE;
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :SetAuthenticationLevel(_TCHAR* const pszAuthLevel)
   Synopsis	         :This function checks whether the specified pszAuthLevel
                      is valid and assigns the mapped value to m_AuthLevel.
   Type	             :Member Function
   Input parameters   :
		pszAuthLevel - AUTHLEVEL input string
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAuthenticationLevel(pszAuthLevel)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetAuthenticationLevel(_TCHAR* const pszAuthLevel)
{
	BOOL bResult = TRUE;
	// Check whether the string exists in the list of available values.
	CHARINTMAP::iterator theIterator = NULL;
	theIterator = m_cimAuthLevel.find(CharUpper(pszAuthLevel));
	if (theIterator != m_cimAuthLevel.end())
	{
		m_AuthLevel = (AUTHLEVEL) (*theIterator).second;
	}
	else
		bResult = FALSE;
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :SetTraceMode(BOOL bTrace)
   Synopsis	         :This function sets the m_bTrace to TRUE,If Trace mode
                      is specified in the command 					                      
   Type	             :Member Function
   Input parameter   :
             Trace   -Boolean type,Specifies whether the trace mode 
			          has been set or not
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetTraceMode(bTrace)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetTraceMode(BOOL bTrace)
{
	m_bTrace = bTrace;
}
/*------------------------------------------------------------------------
   Name				 :SetInteractiveMode
   Synopsis	         :This function sets the m_bInteractive to TRUE,If 
                      interactive mode is specified in the command                      
   Type	             :Member Function
   Input parameter   :
      bInteractive   -Boolean type,Specifies whether the interactive mode 
	                  has been set or not
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetInteractiveMode(bInteractive)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetInteractiveMode(BOOL bInteractive)
{
	m_bInteractive = bInteractive;
}
	
/*------------------------------------------------------------------------
   Name				 :SetHelpFlag
   Synopsis	         :sets the m_bHelp to TRUE, If /? is specified in the
                      command 
   Type	             :Member Function
   Input parameters   :
             bHelp   -BOOL type Specifies whether the helpflag has been
			          set or not
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetHelpFlag(bHelp)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetHelpFlag(BOOL bHelp)
{
	m_bHelp = bHelp;	
}
/*------------------------------------------------------------------------
   Name				 :SetHelpOption
   Synopsis	         :This function specifies whether the help should
                      be brief or full 
   Type	             :Member Function
   Input parameters   :
        helpOption   -Specifies whether the help should be brief or full
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetHelpOption(helpOption)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetHelpOption(HELPOPTION helpOption)
{
	m_HelpOption = helpOption;
}

/*------------------------------------------------------------------------
   Name				 :SetConnInfoFlag
   Synopsis	         :This function sets the Connection Info flag
   Type	             :Member Function
   Input parameter   :
			uFlag	 - Unsigned int type
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetConnInfoFlag(uFlag)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetConnInfoFlag(UINT uFlag)
{
	m_uConnInfoFlag = uFlag;
}
/*------------------------------------------------------------------------
   Name				 :GetConnInfoFlag
   Synopsis	         :This function returns the Connection Info flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :UINT
   Global Variables  :None
   Calling Syntax    :GetConnInfoFlag()
   Notes             :None
------------------------------------------------------------------------*/
UINT CGlobalSwitches::GetConnInfoFlag()
{
	return m_uConnInfoFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetNameSpace
   Synopsis	         :This function Returns the string held in m_pszNameSpace
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetNameSpace()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetNameSpace()
{
	return m_pszNameSpace;
}

/*------------------------------------------------------------------------
   Name				 :GetRole
   Synopsis	         :This function Returns the string held in m_pszRole
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetRole()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetRole()
{
	return m_pszRole;
}
/*------------------------------------------------------------------------
   Name				 :GetLocale
   Synopsis	         :This function Returns the string held in m_pszLocale .
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :_TCHR*
   Global Variables  :None
   Calling Syntax    :GetLocale()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetLocale()
{
	return m_pszLocale;
}
/*------------------------------------------------------------------------
   Name				 :GetNodesList
   Synopsis	         :This function Returns the vector held in m_cvNodesList
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHARVECTOR&
   Global Variables  :None
   Calling Syntax    :GetNodesList()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CGlobalSwitches::GetNodesList()
{
	return m_cvNodesList;
}
/*------------------------------------------------------------------------
   Name				 :GetUser
   Synopsis	         :This function Returns the string held in m_pszUser.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetUser()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetUser()
{
	return m_pszUser;
}
/*------------------------------------------------------------------------
   Name				 :GetPassword 
   Synopsis	         :This function Returns the string held in m_pszPassword
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetPassword()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetPassword()
{
	return m_pszPassword;
}

/*------------------------------------------------------------------------
   Name				 :GetAuthorityPrinciple 
   Synopsis	         :This function Returns the string held in
					  m_pszAuthorityPrinciple
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetAuthorityPrinciple()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetAuthorityPrinciple()
{
	return m_pszAuthorityPrinciple;
}

/*------------------------------------------------------------------------
   Name				 :GetRecordPath
   Synopsis	         :This function Returns the string held in m_pszRecordPath
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetRecordPath()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetRecordPath()
{
	return m_pszRecordPath;
}
/*------------------------------------------------------------------------
   Name				 :GetPrivileges
   Synopsis	         :This function Returns BOOL value held in m_bPrivileges
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetPrivileges()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetPrivileges()
{
	return m_bPrivileges;
}
/*------------------------------------------------------------------------
   Name				 :GetImpersonationLevel
   Synopsis	         :This function Returns impersonation level held 
                      in m_ImpLevel
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :LONG
   Global Variables  :None
   Calling Syntax    :GetImpersonationLevel()
   Notes             :None
------------------------------------------------------------------------*/
LONG CGlobalSwitches::GetImpersonationLevel()
{
	return m_ImpLevel;
}
/*------------------------------------------------------------------------
   Name				 :GetAuthenticationLevel
   Synopsis	         :This function Returns authentication level held in 
                      m_AuthLevel
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :LONG
   Global Variables  :None
   Calling Syntax    :GetAuthenticationLevel()
   Notes             :None
------------------------------------------------------------------------*/
LONG CGlobalSwitches::GetAuthenticationLevel()
{
	return m_AuthLevel;
}
/*------------------------------------------------------------------------
   Name				 :GetTraceStatus
   Synopsis	         :This function Returns trace status held in m_bTrace
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetTraceStatus()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetTraceStatus()
{
	return m_bTrace;
}
/*------------------------------------------------------------------------
   Name				 :GetInteractiveStatus
   Synopsis	         :This function Returns interactive status held 
                      in m_bInteractive
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetInteractiveStatus()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetInteractiveStatus()
{
	return m_bInteractive;
}
/*------------------------------------------------------------------------
   Name				 :GetHelpFlag
   Synopsis	         :This function Returns help flag held in m_bHelp
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetHelpFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetHelpFlag()
{
	return m_bHelp;
}
/*------------------------------------------------------------------------
   Name				 :GetHelpOption
   Synopsis	         :This function Returns help option held in m_bHelpOption
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :HELPOPTION
   Global Variables  :None
   Calling Syntax    :GetHelpOption()
   Notes             :None
------------------------------------------------------------------------*/
HELPOPTION CGlobalSwitches::GetHelpOption()
{
	return m_HelpOption;
}

/*------------------------------------------------------------------------
   Name				 :GetRoleFlag
   Synopsis	         :This function returns the role flag value
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
		True	- /role changed recently.
		False	- no change in role till last command
   Global Variables  :None
   Calling Syntax    :GetRoleFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetRoleFlag()
{
	return m_bRoleFlag;
}
/*-------------------------------------------------------------------------
   Name				 :SetNameSpaceFlag
   Synopsis	         :This function sets the NameSpace flag value
   Type	             :Member Function
   Input parameter   :BOOL bNSFlag
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetNameSpaceFlag(bNSFlag)
   Notes             :None

-------------------------------------------------------------------------*/
void CGlobalSwitches::SetNameSpaceFlag(BOOL bNSFlag)
{
	m_bNSFlag = bNSFlag;
}

/*-------------------------------------------------------------------------
   Name				 :SetRoleFlag
   Synopsis	         :This function sets the Role flag value
   Type	             :Member Function
   Input parameter   :BOOL bRoleFlag
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetRoleFlag(bRoleFlag)
   Notes             :None

-------------------------------------------------------------------------*/
void CGlobalSwitches::SetRoleFlag(BOOL bRoleFlag)
{
	m_bRoleFlag = bRoleFlag;
}

/*-------------------------------------------------------------------------
   Name				 :SetLocaleFlag
   Synopsis	         :This function sets the Locale flag value
   Type	             :Member Function
   Input parameter   :BOOL bLocaleFlag
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetLocaleFlag(bLocaleFlag)
   Notes             :None

-------------------------------------------------------------------------*/
void CGlobalSwitches::SetLocaleFlag(BOOL bLocaleFlag)
{
	m_bLocaleFlag = bLocaleFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetNamespaceFlag
   Synopsis	         :This function returns the namespace flag value
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
		True	- /namespace changed recently.
		False	- no change in namespace till last command
   Global Variables  :None
   Calling Syntax    :GetRoleFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetNameSpaceFlag()
{
	return m_bNSFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetRPChangeStatus
   Synopsis	         :This function returns the recordpath flag value
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
		True	- recordpath changed recently.
		False	- no change in recordpath till last command
   Global Variables  :None
   Calling Syntax    :GetRPChangeStatus()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetRPChangeStatus()
{
	return m_bRPChange;
}

/*-------------------------------------------------------------------------
   Name				 :SetRPChangeStatus
   Synopsis	         :This function sets the recordpath flag value
   Type	             :Member Function
   Input parameter   :BOOL bStatus
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetRPChangeStatus(bStatus)
   Notes             :None

-------------------------------------------------------------------------*/
void CGlobalSwitches::SetRPChangeStatus(BOOL bStatus)
{
	m_bRPChange = bStatus;
}

/*------------------------------------------------------------------------
   Name				 :GetLocaleFlag
   Synopsis	         :This function returns the Locale flag value
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
		True	- /Locale changed recently.
		False	- no change in Locale till last command
   Global Variables  :None
   Calling Syntax    :GetLocaleFlag()
   Notes             :None
------------------------------------------------------------------------*/

BOOL CGlobalSwitches::GetLocaleFlag()
{
	return m_bLocaleFlag;
}

/*------------------------------------------------------------------------
   Name				 :SetNode
   Synopsis	         :This function Assigns the node passed in parameter
                      to m_pszNode
   Type	             :Member Function
   Input parameters   :
           pszNode   -String type,contains Node option specified in the
		              command
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetNode(pszNode)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetNode(_TCHAR* pszNode)
{
	BOOL bResult = TRUE;	
	SAFEDELETE(m_pszNode);
	if(pszNode)
	{
		if (!CompareTokens(pszNode, CLI_TOKEN_NULL))
		{
			m_pszNode = new _TCHAR [lstrlen(pszNode)+1];
			if (m_pszNode)
			{
				lstrcpy(m_pszNode, pszNode);	
				m_uConnInfoFlag |= NODE;
			}
			else
				bResult = FALSE;
		}
		else
		// "." specifies current node
		{
			m_pszNode = new _TCHAR [lstrlen(m_pszNodeName)+1];
			if (m_pszNode)
			{
				lstrcpy(m_pszNode, m_pszNodeName);
				m_uConnInfoFlag &= ~NODE;
			}
			else
				bResult = FALSE;
		}
	}
	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :GetNode
   Synopsis	         :This function Returns the string held in m_pszNode
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetNode()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetNode()
{
	return m_pszNode;
}

/*------------------------------------------------------------------------
   Name				 :ClearNodesList
   Synopsis	         :Clears the nodes list
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ClearNodesList()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::ClearNodesList()
{
	BOOL bRet = TRUE;
	CleanUpCharVector(m_cvNodesList);
	if (!AddToNodesList(CLI_TOKEN_NULL))
		bRet = FALSE;
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :SetAskForPassFlag
   Synopsis	         :This function sets the askforpassword flag
   Type	             :Member Function
   Input parameter   :bFlag
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetAskForPassFlag(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetAskForPassFlag(BOOL bFlag)
{
	m_bAskForPassFlag = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetAskForPassFlag
   Synopsis	         :This function checks and returns TRUE if the user 
					  has to be prompted for the password
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetAskForPassFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetAskForPassFlag()
{
	return m_bAskForPassFlag;
}
/*------------------------------------------------------------------------
   Name				 :GetGetPrivilegesTextDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_bPrivilges flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
		bstrPriv - privileges status string
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetPrivilegesTextDesc()
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetPrivilegesTextDesc(_bstr_t& bstrPriv)
{
	try
	{
		if (m_bPrivileges) 
			bstrPriv = _bstr_t(CLI_TOKEN_ENABLE);
		else
			bstrPriv = _bstr_t(CLI_TOKEN_DISABLE);
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetTraceTextDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_bTrace flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
		bstrTrace - trace status string
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetTraceTextDesc(bstrTrace)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetTraceTextDesc(_bstr_t& bstrTrace)
{
	try
	{
		if (m_bTrace) 
			bstrTrace = CLI_TOKEN_ON;
		else
			bstrTrace = CLI_TOKEN_OFF;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetInteractiveTextDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_bInteractive flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
		bstrInteractive - interactive status string
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetInteractiveTextDesc(bstrInteractive)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetInteractiveTextDesc(_bstr_t& bstrInteractive)
{
	try
	{
		if (m_bInteractive) 
			bstrInteractive = CLI_TOKEN_ON;
		else
			bstrInteractive = CLI_TOKEN_OFF;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetFailFastTextDesc
   Synopsis	         :Return the string equivalent of the boolean value
					  contained in m_bFailFast flag.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
		bstrFailFast - FailFast status string
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetFailFastTextDesc(bstrFailFast)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetFailFastTextDesc(_bstr_t& bstrFailFast)
{
	try
	{
		if (m_bFailFast) 
			bstrFailFast = CLI_TOKEN_ON;
		else
			bstrFailFast = CLI_TOKEN_OFF;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :GetImpLevelTextDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_ImpLevel flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
		bstrImpLevel - impersonation level description
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetImpLevelTextDesc(bstrImpLevel)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetImpLevelTextDesc(_bstr_t& bstrImpLevel)
{
	try
	{
		switch(m_ImpLevel)
		{
		case 1:
				bstrImpLevel = L"ANONYMOUS";
				break;
		case 2:
				bstrImpLevel = L"IDENTIFY";
				break;
		case 3:
				bstrImpLevel = L"IMPERSONATE";
				break;
		case 4:
				bstrImpLevel = L"DELEGATE";
				break;
		default:
				bstrImpLevel = TOKEN_NA;
				break;
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}
/*------------------------------------------------------------------------
   Name				 :GetAuthLevelTextDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_AuthLevel flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
			bstrAuthLevel - authentication level description
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetAuthLevelTextDesc(bstrAuthLevel)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetAuthLevelTextDesc(_bstr_t& bstrAuthLevel)
{
	try
	{
		switch(m_AuthLevel)
		{
		case 0:
				bstrAuthLevel = L"DEFAULT";
				break;
		case 1:
				bstrAuthLevel = L"NONE";
				break;
		case 2:
				bstrAuthLevel = L"CONNECT";
				break;
		case 3:
				bstrAuthLevel = L"CALL";
				break;
		case 4:
				bstrAuthLevel = L"PKT";
				break;
		case 5:
				bstrAuthLevel = L"PKTINTEGRITY";
				break;
		case 6:
				bstrAuthLevel = L"PKTPRIVACY";
				break;
		default:
				bstrAuthLevel = TOKEN_NA;
				break;
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}
/*------------------------------------------------------------------------
   Name				 :GetNodeString
   Synopsis	         :This function Returns the ',' separated node
					  string of the available nodes
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
			bstrNString - node string (comma separated)
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetNodeString(bstrNSString)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetNodeString(_bstr_t& bstrNString)
{
	try
	{
		CHARVECTOR::iterator theIterator;
		if (m_cvNodesList.size() > 1)
		{
			theIterator = m_cvNodesList.begin();
			// Move to next node
			theIterator++;
			while (theIterator != m_cvNodesList.end())
			{
				bstrNString += *theIterator;
				theIterator++;
				if (theIterator != m_cvNodesList.end())
					bstrNString += L", ";
			}
		}
		else
		{
			bstrNString = m_pszNode;
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}
/*------------------------------------------------------------------------
   Name				 :GetRecordPathDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_pszRecordPath flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
			bstrRPDesc - record path description
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetRecordPathDesc(bstrRPDesc)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetRecordPathDesc(_bstr_t& bstrRPDesc)
{
	try
	{
		if (m_pszRecordPath) 
		{
			bstrRPDesc = m_pszRecordPath;
		}
		else
			bstrRPDesc = TOKEN_NA;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*------------------------------------------------------------------------
   Name				 :SetFailFast
   Synopsis	         :This function sets the m_bFailFast flag.
   Type	             :Member Function
   Input parameter   :
			   bFlag - Boolean variable to set flag.
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetFailFast(bFlag)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetFailFast(BOOL bFlag)
{
	m_bFailFast = bFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetFailFast
   Synopsis	         :This function returns the m_bFailFast flag.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetFailFast()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetFailFast()
{
	return m_bFailFast;
}

/*------------------------------------------------------------------------
   Name				 :SetFileType
   Synopsis	         :This function sets the type of file it appends to
   Type	             :Member Function
   Input parameter   :aftOpt - type
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetAppendFileType(aftOpt)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetFileType ( FILETYPE eftOpt )
{
	m_eftFileType = eftOpt ;
}

/*------------------------------------------------------------------------
   Name				 :GetFileType
   Synopsis	         :This function returns the append option.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :FILETYPE
   Global Variables  :None
   Calling Syntax    :GetAppendFileType()
   Notes             :None
------------------------------------------------------------------------*/
FILETYPE CGlobalSwitches::GetFileType ( )
{
	return m_eftFileType ;
}

/*------------------------------------------------------------------------
   Name				 :SetOutputOption
   Synopsis	         :This function sets the ouput option.
   Type	             :Member Function
   Input parameter   :opoOutputOpt - Specifies the ouput option.
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetOutputOption(opoOutputOpt)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetOutputOrAppendOption(OUTPUTSPEC opsOpt,
											  BOOL bIsOutput)
{
	if ( bIsOutput == TRUE )
		m_opsOutputOpt = opsOpt;
	else
		m_opsAppendOpt = opsOpt;
}

/*------------------------------------------------------------------------
   Name				 :GetOutputOption
   Synopsis	         :This function returns the ouput option.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :OUTPUTOPT
   Global Variables  :None
   Calling Syntax    :GetOutputOption()
   Notes             :None
------------------------------------------------------------------------*/
OUTPUTSPEC CGlobalSwitches::GetOutputOrAppendOption(BOOL bIsOutput)
{
	OUTPUTSPEC opsOpt;
	if ( bIsOutput == TRUE )
		opsOpt = m_opsOutputOpt;
	else
		opsOpt = m_opsAppendOpt;

	return opsOpt;
}

/*------------------------------------------------------------------------
   Name				 :SetOutputOrAppendFileName
   Synopsis	         :This function Set Output or Append File Name,
					  bOutput = TRUE for Output FALSE for Append.
   Type	             :Member Function
   Input parameter   :pszFileName - output or append file name
                      bOutput - output option 
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetOutputOrAppendFileName(pszFileName,bOutput)
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::SetOutputOrAppendFileName(const _TCHAR* pszFileName,
												BOOL  bOutput)
{
	BOOL bResult = TRUE;
	
	if ( bOutput == TRUE )
	{
		SAFEDELETE(m_pszOutputFileName)
	}
	else
	{
		SAFEDELETE(m_pszAppendFileName)
	}

	if ( pszFileName != NULL )
	{
		_TCHAR* pszTempFileName;
		pszTempFileName = new _TCHAR [lstrlen(pszFileName)+1];
		if ( pszTempFileName == NULL ) 
			bResult = FALSE;
		else
		{
			if ( bOutput == TRUE )
			{
				m_pszOutputFileName = pszTempFileName;
				lstrcpy(m_pszOutputFileName, pszFileName);
			}
			else
			{
				m_pszAppendFileName = pszTempFileName;
				lstrcpy(m_pszAppendFileName, pszFileName);
			}
		}
	}

	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :GetOutputOrAppendFileName
   Synopsis	         :This function returns the output or append file name
					  depending upon the output option - bOutput.
   Input parameter   :bOutput - output option 
   Output parameters :None
   Return Type       :_TCHAR
   Global Variables  :None
   Calling Syntax    :GetOutputOrAppendFileName(BOOL	bOutput)
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR*	CGlobalSwitches::GetOutputOrAppendFileName(BOOL	bOutput)
{
	_TCHAR*		pszTempFile;

	if ( bOutput == TRUE )
		pszTempFile = m_pszOutputFileName;
	else
		pszTempFile = m_pszAppendFileName;

	return pszTempFile;
}

/*------------------------------------------------------------------------
   Name				 :GetOutputOptTextDesc
   Synopsis	         :This function returns the string equivalent of the 
					  OUTPUTOPT value contained in m_opoOutputOpt member.
   Input parameter   :None
   Output parameters :bstrOutputOpt - string equivalent of the 
					  OUTPUTOPT value
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetOutputOptTextDesc(bstrOutputOpt)
   Notes             :None
------------------------------------------------------------------------*/
void	CGlobalSwitches::GetOutputOrAppendTextDesc(_bstr_t& bstrOutputOpt,
												   BOOL bIsOutput)	
{
	try
	{
		if ( bIsOutput == TRUE )
		{
			if ( m_opsOutputOpt == STDOUT )
				bstrOutputOpt = CLI_TOKEN_STDOUT;
			else if ( m_opsOutputOpt == CLIPBOARD )
				bstrOutputOpt = CLI_TOKEN_CLIPBOARD;
			else
				bstrOutputOpt = _bstr_t(m_pszOutputFileName);
		}
		else
		{
			if ( m_opsAppendOpt == STDOUT )
				bstrOutputOpt = CLI_TOKEN_STDOUT;
			else if ( m_opsAppendOpt == CLIPBOARD )
				bstrOutputOpt = CLI_TOKEN_CLIPBOARD;
			else
				bstrOutputOpt = _bstr_t(m_pszAppendFileName);
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}


/*------------------------------------------------------------------------
   Name				 :SetOutputOrAppendFilePointer
   Synopsis	         :This function Sets output or append file pointer,
					  bOutput == TRUE for Output 
					  bOutput == FALSE or Append.
   Input parameter   :fpFile -  pointer to output or append
					  bOutput - ouput option
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetOutputOrAppendFilePointer(fpFile, bOutput)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetOutputOrAppendFilePointer(FILE* fpFile, BOOL bOutput)
{
	if ( bOutput == TRUE )
		m_fpOutFile = fpFile;
	else
		m_fpAppendFile = fpFile;
}
/*------------------------------------------------------------------------
   Name				 :GetOutputOrAppendFilePointer
   Synopsis	         :This function returns the ouput or append file pointer.
					  bOutput == TRUE for Output 
					  bOutput == FALSE or Append.
   Input parameter   :bOutput - ouput option
   Output parameters :None
   Return Type       :FILE*
   Global Variables  :None
   Calling Syntax    :GetOutputOrAppendFilePointer(bOutput)
   Notes             :None
------------------------------------------------------------------------*/
FILE* CGlobalSwitches::GetOutputOrAppendFilePointer(BOOL bOutput)
{
	FILE* fpTemp;
	if ( bOutput == TRUE )
		fpTemp = m_fpOutFile;
	else
		fpTemp = m_fpAppendFile;
	return fpTemp;
}

/*------------------------------------------------------------------------
   Name				 :GetSequenceNumber
   Synopsis	         :This function returns the sequence number of the command 
                      logged .
   Input parameter   :None
   Output parameters :None
   Return Type       :WMICLIINT
   Global Variables  :None
   Calling Syntax    :GetSequenceNumber()
   Notes             :None
------------------------------------------------------------------------*/
WMICLIINT CGlobalSwitches::GetSequenceNumber()
{
	return m_nSeqNum;
}

/*------------------------------------------------------------------------
   Name				 :GetLoggedonUser
   Synopsis	         :This function returns the current logged on user.
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetLoggedonUser()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR*	CGlobalSwitches::GetLoggedonUser()
{
	return m_pszLoggedOnUser;
}

/*------------------------------------------------------------------------
   Name				 :GetMgmtStationName
   Synopsis	         :This function returns the management station that 
				      issued the command.
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetMgmtStationName()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CGlobalSwitches::GetMgmtStationName()
{
	return m_pszNodeName;
}

/*------------------------------------------------------------------------
   Name				 :GetStartTime
   Synopsis	         :This function returns the time at which the command
					  execution started. 
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR*
   Global Variables  :None
   Calling Syntax    :GetStartTime()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR*	CGlobalSwitches::GetStartTime()
{
	return m_pszStartTime;
}

/*------------------------------------------------------------------------
   Name				 :SetStartTime
   Synopsis	         :This function sets the time at which the command
					  execution started. 
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetStartTime()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CGlobalSwitches::SetStartTime()
{
	BOOL bResult = TRUE;
	if (m_pszStartTime == NULL)
	{
		m_pszStartTime = new _TCHAR[BUFFER64];
	}
	if (m_pszStartTime)
	{
		SYSTEMTIME stSysTime;
		GetLocalTime(&stSysTime);

		_stprintf(m_pszStartTime, L"%.2d-%.2d-%.4dT%.2d:%.2d:%.2d", 
							stSysTime.wMonth, stSysTime.wDay, stSysTime.wYear,
							stSysTime.wHour, stSysTime.wMinute, stSysTime.wSecond);

		// Increment the command counter.
		m_nSeqNum++; 
	}
	else
		bResult = FALSE;
	return bResult;
}
/*------------------------------------------------------------------------
   Name				 :SetAggregateFlag
   Synopsis	         :This function sets the Aggregation flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetAggregateFlag(BOOL)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::SetAggregateFlag(BOOL bAggregateFlag)
{
	m_bAggregateFlag = bAggregateFlag;
}
/*------------------------------------------------------------------------
   Name				 :GetAggreagateFlag
   Synopsis	         :This function gets the Aggregation flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetAggregateFlag()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CGlobalSwitches::GetAggregateFlag()
{
	return m_bAggregateFlag;
}

/*------------------------------------------------------------------------
   Name				 :GetAggregateTextDesc
   Synopsis	         :This function checks and Returns the string 
					  equivalent of the boolean value contained in 
					  m_bAggregateFlag flag
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
		bstrAggregate - aggreaget status string
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :GetAggregateTextDesc(bstrAggregate)
   Notes             :None
------------------------------------------------------------------------*/
void CGlobalSwitches::GetAggregateTextDesc(_bstr_t& bstrAggregate)
{
	try
	{
		if (m_bAggregateFlag) 
			bstrAggregate = CLI_TOKEN_ON;
		else
			bstrAggregate = CLI_TOKEN_OFF;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\makefile.inc ===
$(O)\cli.mof: cli.mof
    copy copyright.mof+cli.mof $(O)\cli.mof
$(O)\cliegali.mfl: cliegaliases.mfl
    copy copyright.mof+cliegaliases.mfl $(O)\cliegali.mfl
$(O)\cliegali.mof: cliegaliases.mof
    copy copyright.mof+cliegaliases.mof+cliegaliases.mfl $(O)\cliegali.mof
$(O)\texttbl.xsl: texttable.xsl
    copy texttable.xsl $(O)\texttbl.xsl
$(O)\textvalu.xsl: textvaluelist.xsl
    copy textvaluelist.xsl $(O)\textvalu.xsl
$(O)\xslmap.xml: xsl-mappings.xml
    copy xsl-mappings.xml $(O)\xslmap.xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\helpers.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-2002 Microsoft Corporation 
File Name					: helpers.cpp 
Project Name				: WMI Command Line
Author Name					: Ch.Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file has all the global function definitions 
Revision History			:
		Last Modified By	: Ch Sriramachandramurthy
		Last Modified Date  : 03-March-2001
*****************************************************************************/ 
#include "Precomp.h"
#include "CommandSwitches.h"
#include "GlobalSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ErrorInfo.h"
#include "WmiCliXMLLog.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "FormatEngine.h"
#include "WmiCmdLn.h"

/*----------------------------------------------------------------------------
   Name				 :CompareTokens
   Synopsis	         :It compares the two tokens passed to it as input 
					  arguments and returns a BOOL value ,
					  TRUE if they are equal 
					  FALSE if not equal.
   Type	             :Global Function
   Input parameter(s):
			pszToken1- String type, Contains the first string of the two 
					   string to be compared
			pszToken2- String type, Contains the second string of the two 
					   string to be compared
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :CompareTokens(pszToken1,pszToken2)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CompareTokens(_TCHAR* pszToken1, _TCHAR* pszToken2)
{	
	return (CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT, 
					NORM_IGNORECASE | NORM_IGNOREWIDTH,	
					pszToken1, (pszToken1) ? lstrlen(pszToken1) : 0,
					pszToken2, (pszToken2) ? lstrlen(pszToken2) : 0)) 
					? TRUE : FALSE;
}

/*----------------------------------------------------------------------------
   Name				 :CompareTokensChars
   Synopsis	         :It compares the two tokens passed to it as input 
					  arguments and returns a BOOL value ,
					  TRUE if they are equal 
					  FALSE if not equal.
   Type	             :Global Function
   Input parameter(s):
			pszToken1- String type, Contains the first string of the two 
					   string to be compared
			pszToken2- String type, Contains the second string of the two 
					   string to be compared
		    cchToken-  number of characters to compare
   Output parameter(s):None
   Re