,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ILog_get_Server_Proxy( 
    ILog * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ILog_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ILog_put_Server_Proxy( 
    ILog * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ILog_put_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILog_Clear_Proxy( 
    ILog * This);


void __RPC_STUB ILog_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILog_INTERFACE_DEFINED__ */


#ifndef __IEvents_INTERFACE_DEFINED__
#define __IEvents_INTERFACE_DEFINED__

/* interface IEvents */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B70B0436-726F-4742-B08E-1AEE6D6C6AA9")
    IEvents : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IEvents * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IEvents * This,
            /* [retval][out] */ LPUNKNOWN *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IEvents * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } IEventsVtbl;

    interface IEvents
    {
        CONST_VTBL struct IEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEvents_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IEvents_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IEvents_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvents_get_Count_Proxy( 
    IEvents * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IEvents_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvents_get__NewEnum_Proxy( 
    IEvents * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB IEvents_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvents_get_Item_Proxy( 
    IEvents * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IEvents_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEvents_INTERFACE_DEFINED__ */


#ifndef __IEvent_INTERFACE_DEFINED__
#define __IEvent_INTERFACE_DEFINED__

/* interface IEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5FF33202-DD46-4C30-809D-BD868D6A6D29")
    IEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventID( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventType( 
            /* [retval][out] */ eEventType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Category( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_User( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OccurrenceTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Data( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventID )( 
            IEvent * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventType )( 
            IEvent * This,
            /* [retval][out] */ eEventType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IEvent * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IEvent * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Source )( 
            IEvent * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_User )( 
            IEvent * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OccurrenceTime )( 
            IEvent * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ComputerName )( 
            IEvent * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Data )( 
            IEvent * This,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } IEventVtbl;

    interface IEvent
    {
        CONST_VTBL struct IEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEvent_get_EventID(This,pVal)	\
    (This)->lpVtbl -> get_EventID(This,pVal)

#define IEvent_get_EventType(This,pVal)	\
    (This)->lpVtbl -> get_EventType(This,pVal)

#define IEvent_get_Category(This,pVal)	\
    (This)->lpVtbl -> get_Category(This,pVal)

#define IEvent_get_Description(This,pVal)	\
    (This)->lpVtbl -> get_Description(This,pVal)

#define IEvent_get_Source(This,pVal)	\
    (This)->lpVtbl -> get_Source(This,pVal)

#define IEvent_get_User(This,pVal)	\
    (This)->lpVtbl -> get_User(This,pVal)

#define IEvent_get_OccurrenceTime(This,pVal)	\
    (This)->lpVtbl -> get_OccurrenceTime(This,pVal)

#define IEvent_get_ComputerName(This,pVal)	\
    (This)->lpVtbl -> get_ComputerName(This,pVal)

#define IEvent_get_Data(This,pVal)	\
    (This)->lpVtbl -> get_Data(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_EventID_Proxy( 
    IEvent * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IEvent_get_EventID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_EventType_Proxy( 
    IEvent * This,
    /* [retval][out] */ eEventType *pVal);


void __RPC_STUB IEvent_get_EventType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_Category_Proxy( 
    IEvent * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IEvent_get_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_Description_Proxy( 
    IEvent * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEvent_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_Source_Proxy( 
    IEvent * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEvent_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_User_Proxy( 
    IEvent * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEvent_get_User_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_OccurrenceTime_Proxy( 
    IEvent * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IEvent_get_OccurrenceTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_ComputerName_Proxy( 
    IEvent * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEvent_get_ComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_Data_Proxy( 
    IEvent * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IEvent_get_Data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEvent_INTERFACE_DEFINED__ */



#ifndef __EventLogUtilities_LIBRARY_DEFINED__
#define __EventLogUtilities_LIBRARY_DEFINED__

/* library EventLogUtilities */
/* [helpstring][version][uuid] */ 




EXTERN_C const IID LIBID_EventLogUtilities;

EXTERN_C const CLSID CLSID_View;

#ifdef __cplusplus

class DECLSPEC_UUID("FF184146-A804-4FB1-BDA7-1E05052C5553")
View;
#endif

EXTERN_C const CLSID CLSID_Log;

#ifdef __cplusplus

class DECLSPEC_UUID("07C97B1B-4042-4DD3-9FDD-56EC7677E30E")
Log;
#endif

EXTERN_C const CLSID CLSID_Event;

#ifdef __cplusplus

class DECLSPEC_UUID("32FB0C7C-96CA-4263-A1FE-215A0AF69B34")
Event;
#endif
#endif /* __EventLogUtilities_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\logs.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Logs.h : Declaration of the CLogs

#ifndef __LOGS_H_
#define __LOGS_H_

#include "resource.h"       // main symbols
#include "Log.h"

/////////////////////////////////////////////////////////////////////////////
// CLogs
class ATL_NO_VTABLE CLogs : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CLogs, &CLSID_Logs>,
	public ISupportErrorInfo,
	public IDispatchImpl<ILogs, &IID_ILogs, &LIBID_EventLogUtilities>
{
private:
	ULONG m_Count;
	CComVariant* m_pVector;
	_bstr_t m_btCurrentLogName;

public:
	_bstr_t m_ServerName;

	CLogs() : m_Count(0), m_pVector(NULL)
	{
	}

	~CLogs()
	{
		delete [] m_pVector;
	}

	// Internal functions
	HRESULT Init();

DECLARE_REGISTRY_RESOURCEID(IDR_LOGS)
DECLARE_NOT_AGGREGATABLE(CLogs)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLogs)
	COM_INTERFACE_ENTRY(ILogs)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ILogs
	STDMETHOD(get_Item)(/*[in]*/ VARIANT Index, /*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
};

#endif //__LOGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\evntutl.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// EventLogUtilities.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for EventLogUtilities.idl by adding the following
//      files to the Outputs.
//          EventLogUtilities_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f EventLogUtilitiesps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "Evntutl.h"
#include "dlldatax.h"

#include "EvntUtl_i.c"
#include "View.h"
// #include "Logs.h"
#include "Log.h"
// #include "Events.h"
#include "Event.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_View, CView)
// OBJECT_ENTRY(CLSID_Logs, CLogs)
OBJECT_ENTRY(CLSID_Log, CLog)
// OBJECT_ENTRY(CLSID_Events, CEvents)
OBJECT_ENTRY(CLSID_Event, CEvent)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_EventLogUtilities);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	MessageBox(NULL, TEXT("Registering eventutl.dll"), TEXT("evntutl.dll"), MB_OK);
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\log.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Log.h : Declaration of the CLog

#ifndef __LOG_H_
#define __LOG_H_

#include "resource.h"       // main symbols
#include "Events.h"

/////////////////////////////////////////////////////////////////////////////
// CLog
class ATL_NO_VTABLE CLog : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CLog, &CLSID_Log>,
	public ISupportErrorInfo,
	public IDispatchImpl<ILog, &IID_ILog, &LIBID_EventLogUtilities>
{
private:
	CComObject<CEvents>* m_pEvents;
	HANDLE m_hLog;

public:
	_bstr_t m_Name;
	_bstr_t m_ServerName;

	CLog() : m_hLog(NULL)
	{
		m_pEvents = new CComObject<CEvents>;
		if (m_pEvents)
			m_pEvents->AddRef();
	}

	~CLog()
	{
		if (m_hLog)	CloseEventLog(m_hLog);
		if (m_pEvents) m_pEvents->Release();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_LOG)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLog)
	COM_INTERFACE_ENTRY(ILog)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ILog: Interface methods and properties
	STDMETHOD(get_Events)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_Server)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Server)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(Clear)();
};

#endif //__LOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\log.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Log.cpp : Implementation of CLog
#include "stdafx.h"
#include "Evntutl.h"
#include "Log.h"

/////////////////////////////////////////////////////////////////////////////
// CLog

STDMETHODIMP CLog::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ILog
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*
	Function:  get_Events
	Inputs:  empty variant pointer
	Outputs:  variant dispatch pointer to a filled Events collection
	Purpose:  provide access to IEvents interface, open an event log if not already open
	Notes:  This op is very expensive when calling m_pEvents->Init()
*/
STDMETHODIMP CLog::get_Events(VARIANT *pVal)
{
	HRESULT hr = S_OK;

	VariantInit(pVal);

	IDispatch* pDisp;
	m_pEvents->QueryInterface (IID_IDispatch, (void**) &pDisp);
	pVal->vt = VT_DISPATCH;
	pVal->pdispVal = pDisp;

	// Need to open the log before users can start retreiving events.
	if (!m_Name) hr = E_INVALIDARG;
	else
	{
		if (!m_hLog)  // if removed, calling Log.Events will refresh the collection
		{
			m_hLog = OpenEventLog(m_ServerName, m_Name);
			if (m_hLog) m_pEvents->Init(m_hLog, m_Name);
			else hr = E_HANDLE;
		}
	}

	return hr;
}

/*
	Function:  get_Name
	Inputs:  empty BSTR
	Outputs:  BSTR containing the name of the EventLog
	Purpose:  Allows user to access the name of the active EventLog
*/
STDMETHODIMP CLog::get_Name(BSTR *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_Name.copy();
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_Server
	Inputs:  empty BSTR
	Outputs:  BSTR containing the name of the server for the EventLog
	Purpose:  Allows user to access the name of the active Server
*/
STDMETHODIMP CLog::get_Server(BSTR *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_ServerName.copy();
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  put_Server
	Inputs:  BSTR containing the name of the server for the EventLog
	Outputs:  HRESULT showing error code in case of failure, does not change input
	Purpose:  Allows user to alter the name of the active Server
*/
STDMETHODIMP CLog::put_Server(BSTR newVal)
{
	m_ServerName = newVal;

	return S_OK;
}

/*
	Function:  Clear
	Inputs:  none
	Outputs:  HRESULT showing error code in case of failure
	Purpose:  Allows user to wipe EventLog clean
	Note:  The function does NOT backup the EventLog first
*/
STDMETHODIMP CLog::Clear()
{
	HRESULT hr = S_OK;

	if (!m_hLog) m_hLog = OpenEventLog(m_ServerName, m_Name);
	if (m_hLog)
	{
		if (ClearEventLog(m_hLog, NULL)) m_hLog = NULL;
		else hr = E_FAIL;
	}
	else hr = E_HANDLE;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\logs.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Logs.cpp : Implementation of CLogs
#include "stdafx.h"
#include "Evntutl.h"
#include "Logs.h"

/////////////////////////////////////////////////////////////////////////////
// CLogs

STDMETHODIMP CLogs::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ILogs
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*
	Function:  get_Count
	Inputs:  empty long
	Outputs:  number event logs available
	Purpose:  Allows user to determine the number of DEFAULT EventLogs
			  Custom EventLogs are not visible in the count
*/
STDMETHODIMP CLogs::get_Count(long *pVal)
{
	*pVal = m_Count;

	return S_OK;
}

/*
	Function:  get_NewEnum
	Inputs:  empty IUnknown pointer
	Outputs:  IEnumVariant object filled with names of default EventLogs
	Purpose:  Allows user to use For Each syntax to do operations on all
			  DEFAULT EventLogs
*/
STDMETHODIMP CLogs::get__NewEnum(LPUNKNOWN *pVal)
{
	HRESULT hr = S_OK;

	if (NULL == pVal) return E_POINTER;
	*pVal = NULL;

	EnumVar* pEVar = new EnumVar;

	hr = pEVar->Init(&m_pVector[0], &m_pVector[m_Count], NULL, AtlFlagCopy);
	if (SUCCEEDED(hr)) 
		hr = pEVar->QueryInterface(IID_IEnumVARIANT, (void**) pVal);

	if FAILED(hr)
		if (pEVar) delete pEVar;
	return hr;
}

/*
	Function:  get_Item
	Inputs:  Valid Index (containing integer for default or BSTR for Default and Custom), empty Variant
	Outputs:  variant dispatch pointer to a Log object
	Purpose:  Allows user to access individual EventLogs by name or default EventLogs by number
*/
STDMETHODIMP CLogs::get_Item(VARIANT Index, VARIANT *pVal)
{
	HRESULT hr = S_OK;
	CComObject<CLog>* pLog;
	ILog* ptLog;
	LPDISPATCH pDisp = NULL;
	_bstr_t bstrCurrentName;
	_bstr_t bstrCheck;
	CComBSTR bstrTemp;
	bool bfound = false;
	unsigned int i = 0;

	if (NULL == pVal) return E_POINTER;
	VariantInit(pVal);
	pVal->vt = VT_UNKNOWN;
	pVal->punkVal = NULL;

	switch(Index.vt)
	{
	case VT_I4 :
	case VT_UI2:
	case VT_UINT:
	case VT_INT:
		{
			if ((Index.iVal > 0) && (UINT(Index.iVal) < m_Count + 1))
				VariantCopy(pVal, &m_pVector[Index.iVal - 1]);
			else hr = E_INVALIDARG;
		}
		break;

	case VT_BSTR :
		{
			if (!Index.bstrVal)
				hr = E_INVALIDARG;
			else
			{
				m_btCurrentLogName = Index.bstrVal;
				// This loop should check the existing VariantArray for a log with name = Index
				// it completes when the item is found or all default logs have been checked
				while ((i<m_Count) && (false == bfound))
				{
					hr = m_pVector[i].pdispVal->QueryInterface(IID_ILog, (void**) &ptLog);
					hr = ptLog->get_Name(&bstrTemp);
					bstrCurrentName = bstrTemp;
					if (bstrCurrentName == m_btCurrentLogName)
					{
						VariantCopy(pVal, &m_pVector[i]);
						bfound = true;
					}
					ptLog->Release();
					i++;
				}
				if (false == bfound)
				{
					hr = CComObject<CLog>::CreateInstance(&pLog);
					bstrCurrentName = Index.bstrVal;
					pLog->m_Name = bstrCurrentName;
					pLog->m_ServerName = m_ServerName;
					hr = pLog->QueryInterface(IID_IDispatch, (void**)&pDisp);
					pLog->AddRef();
					pVal->vt = VT_DISPATCH;
					pVal->pdispVal = pDisp;
				}
			}
		}
		break;

	default:
		hr = E_INVALIDARG;
		break;
	}

	return hr;
}

/*
	Function:  Init
	Inputs:  none
	Outputs:  HRESULT indicating what error if any occured
	Purpose:  Prepares a variant array filled with Log objects for 3 default logs.
*/
HRESULT CLogs::Init()
{
	HRESULT hr = S_OK;
	UINT i;

	//	Default Logs: "Application" "Security" "System"
	static wchar_t* LogNames[] = {L"Application", L"Security", L"System"};

	m_Count = 3;

	if (m_pVector !=NULL) delete [] m_pVector;

	m_pVector = new CComVariant[m_Count];
	CComObject<CLog>* pLog;
	LPDISPATCH pDisp = NULL;

	for (i = 0; i < m_Count; i++)
	{
		// create a CLog object
		hr = CComObject<CLog>::CreateInstance(&pLog);
		if (SUCCEEDED(hr))
		{
			pLog->m_Name = LogNames[i];
			pLog->m_ServerName = m_ServerName.copy();

			// get IDispatch pointer
			hr = pLog->QueryInterface(IID_IDispatch, (void**)&pDisp);
			if (SUCCEEDED(hr))
			{
				// create a variant reference and set the type of object
				CComVariant& var = m_pVector[i];
				var.vt = VT_DISPATCH;
				var.pdispVal = pDisp;
			}
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tstst\conv.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    conv.h

Abstract:

    UNICODE / ASCII conversion macros

Author:

    Hakki T. Bostanci (hakkib) 5-Aug-1998

Revision History:

--*/

#ifndef USES_CONVERSION

// USES_CONVERSION must be defined in every function that uses the
// conversion macros

#define USES_CONVERSION int __nLength; PCWSTR __pUnicode; PCSTR __pAscii

//////////////////////////////////////////////////////////////////////////
//
// W2A
//
// Routine Description:
//   Converts a UNICODE string to ASCII. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          UNICODE string
//
// Return Value:
//   the converted ASCII string
//

#define W2A(pStr)								                \
												                \
	((__pUnicode = pStr) == 0 ? (PSTR) 0 : (	                \
												                \
	__nLength = WideCharToMultiByte(				            \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		0,										                \
		0,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pAscii = (PCSTR) _alloca(__nLength * sizeof(CHAR)),       \
												                \
	WideCharToMultiByte(						                \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		(PSTR) __pAscii,						                \
		__nLength,								                \
		0,										                \
		0										                \
	),											                \
												                \
	(PSTR) __pAscii))							                \


//////////////////////////////////////////////////////////////////////////
//
// A2W
//
// Routine Description:
//   Converts an ASCII string to UNICODE. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          ASCII string
//
// Return Value:
//   the converted UNICODE string
//

#define A2W(pStr)								                \
												                \
	((__pAscii = pStr) == 0 ? (PWSTR) 0 : (					    \
												                \
	__nLength = MultiByteToWideChar(				            \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pUnicode = (PCWSTR) _alloca(__nLength * sizeof(WCHAR)),	\
												                \
	MultiByteToWideChar(						                \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		(PWSTR) __pUnicode,							            \
		__nLength									            \
	),											                \
												                \
	(PWSTR) __pUnicode))							            \

//////////////////////////////////////////////////////////////////////////
//
// T2A, A2T, T2W, W2T
//
// Routine Description:
//   These macros expand to the corresponding correct form according to the
//   #definition of UNICODE. 
//
//   We use the cryptic form (__nLength, __pAscii, __pUnicode, pStr) to avoid 
//   the compiler warning "symbol defined but not used" due to the variables 
//   defined in USES_CONVERSION macro.
//

#ifdef UNICODE
	#define T2A(pStr) W2A(pStr)
	#define A2T(pStr) A2W(pStr)
	#define T2W(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define W2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2DA(pStr) W2A(pStr)
	#define A2DT(pStr) A2W(pStr)
	#define T2DW(pStr) _wcsdupa(pStr)
	#define W2DT(pStr) _wcsdupa(pStr)
#else //UNICODE
	#define T2A(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define A2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2W(pStr) A2W(pStr)
	#define W2T(pStr) W2A(pStr)
	#define T2DA(pStr) _strdupa(pStr)
	#define A2DT(pStr) _strdupa(pStr)
	#define T2DW(pStr) A2W(pStr)
	#define W2DT(pStr) W2A(pStr)
#endif //UNICODE


//////////////////////////////////////////////////////////////////////////
//
// _tcsdupa
//
// Routine Description:
//   Duplicates a string to a buffer allocated off the stack using _alloca
//
// Arguments:
//	 pStr          input string
//
// Return Value:
//   duplicated string
//

#define _wcsdupa(pStr)                                                  \
                                                                        \
    (__pAscii, (__pUnicode = pStr) == 0 ? (PWSTR) 0 : (                 \
                                                                        \
    __nLength = wcslen(__pUnicode) + 1,                                 \
                                                                        \
    wcscpy((PWSTR) _alloca(__nLength * sizeof(WCHAR)), __pUnicode)))    \


#define _strdupa(pStr)                                                  \
                                                                        \
    (__pUnicode, (__pAscii = pStr) == 0 ? (PSTR) 0 : (                  \
                                                                        \
    __nLength = strlen(__pAscii) + 1,                                   \
                                                                        \
    strcpy((PSTR) _alloca(__nLength * sizeof(CHAR)), __pAscii)))        \


#ifdef UNICODE 
#define _tcsdupa _wcsdupa
#else
#define _tcsdupa _strdupa
#endif


#endif //USES_CONVERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tstst\drdetect.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    drdetect

Abstract:

    Detect whether RDPDR was properly installed.

Environment:

    User mode

Author:

    Tadb

--*/

#include "stdafx.h"
#include <setupapi.h>

////////////////////////////////////////////////////////////
//
//  Internal Defines
//

#define RDPDRPNPID      _T("ROOT\\RDPDR")
#define RDPDRDEVICEID   TEXT("Root\\RDPDR\\0000")

const GUID GUID_DEVCLASS_SYSTEM =
{ 0x4d36e97dL, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } };


ULONG RDPDRINST_DetectInstall()
/*++

Routine Description:

    Return the number of RDPDR.SYS devices found.

Arguments:

    NA

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
{
    HDEVINFO            devInfoSet;
    SP_DEVINFO_DATA     deviceInfoData;
    DWORD               iLoop;
    BOOL                bMoreDevices;
    ULONG               count;
    TCHAR               pnpID[256];


    GUID *pGuid=(GUID *)&GUID_DEVCLASS_SYSTEM;

    //
    //  Get the set of all devices with the RDPDR PnP ID.
    //
    devInfoSet = SetupDiGetClassDevs(pGuid, NULL, NULL,
                                   DIGCF_PRESENT);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "Error getting RDPDR devices from PnP.  Error code:  %ld.",
                GetLastError());
        return 0;
    }

    // Get the first device.
    iLoop=0;
    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, iLoop, &deviceInfoData);

    // Get the details for all matching device interfaces.
    count = 0;
    while (bMoreDevices)
    {
        // Get the PnP ID for the device.
        if (!SetupDiGetDeviceRegistryProperty(devInfoSet, &deviceInfoData,
                                SPDRP_HARDWAREID, NULL, (BYTE *)pnpID,
                                sizeof(pnpID), NULL)) {
            fprintf(stderr, "Error fetching PnP ID in RDPDR device node remove.  Error code:  %ld.",
                        GetLastError());
        }

        // If the current device matches the RDPDR PNP ID
        if (!_tcscmp(pnpID, RDPDRPNPID)) {
            count++;
        }

        // Get the next one device interface.
        bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, ++iLoop, &deviceInfoData);
    }

    // Release the device info list.
    SetupDiDestroyDeviceInfoList(devInfoSet);

    return count;
}


//
//      Unit-Test
//
//void __cdecl main()
//{
//    ULONG count;
//    count = RDPDRINST_DetectInstall();
//    printf("Found %ld instance(s) of RDPDR.SYS.\n", count);
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by EventLogUtilities.rc
//
#define IDS_PROJNAME                    100
#define IDR_VIEW                        101
#define IDR_LOGS                        102
#define IDR_LOG                         103
#define IDR_EVENTS                      104
#define IDR_EVENT                       105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tstst\stdafx.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\view.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// View.h : Declaration of the CView

#ifndef __VIEW_H_
#define __VIEW_H_

#include "resource.h"       // main symbols
#include "Logs.h"

/////////////////////////////////////////////////////////////////////////////
// CView
class ATL_NO_VTABLE CView : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CView, &CLSID_View>,
	public ISupportErrorInfo,
	public IDispatchImpl<IView, &IID_IView, &LIBID_EventLogUtilities>
{
private:
	CComObject<CLogs>* m_pLogs;
	_bstr_t m_ServerName;

public:

	CView()
	{
/*
// Don't know if I want to set ServerName initially
		char* lpBuffer;
		DWORD BufferLength;
		const unsigned int MaxComputerNameLength = 32;

		lpBuffer = new char[MaxComputerNameLength];
		BufferLength = GetEnvironmentVariable("COMPUTERNAME", lpBuffer, MaxComputerNameLength);
		m_ServerName = lpBuffer;
*/
		m_pLogs = new CComObject<CLogs>;
		m_pLogs->AddRef();
//		m_pLogs->Init();
	}

	~CView()
	{
		if (m_pLogs) m_pLogs->Release();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_VIEW)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CView)
	COM_INTERFACE_ENTRY(IView)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IView
	STDMETHOD(get_Server)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Server)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Logs)(/*[out, retval]*/ VARIANT *pVal);
};

#endif //__VIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__0829672C_6402_4F1B_A4E1_E4D00F7F4C04__INCLUDED_)
#define AFX_STDAFX_H__0829672C_6402_4F1B_A4E1_E4D00F7F4C04__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>
#include <wchar.h>

#include "Types.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0829672C_6402_4F1B_A4E1_E4D00F7F4C04__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\view.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// View.cpp : Implementation of CView
#include "stdafx.h"
#include "Evntutl.h"
#include "View.h"

/////////////////////////////////////////////////////////////////////////////
// CView

STDMETHODIMP CView::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IView
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*
	Function:  get_Logs
	Inputs:  empty variant
	Outputs:  variant dispatch pointer to an ILogs interface
	Purpose:  Provide access to ILogs
*/
STDMETHODIMP CView::get_Logs(VARIANT *pVal)
{
	HRESULT hr = S_OK;

	VariantInit(pVal);

	IDispatch* pDisp;
	hr = m_pLogs->QueryInterface (IID_IDispatch, (void**) &pDisp);
	if (SUCCEEDED(hr))
	{
		pVal->vt = VT_DISPATCH;
		pVal->pdispVal = pDisp;

		m_pLogs->m_ServerName = m_ServerName.copy();
		hr = m_pLogs->Init();
	}

	return hr;
}

/*
	Function:  get_Server
	Inputs:  empty BSTR
	Outputs:  BSTR containing the current value of the server member variable
	Purpose:  Allows user to see which Server's EventLog will be displayed
*/
STDMETHODIMP CView::get_Server(BSTR *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_ServerName.copy();
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  put_Server
	Inputs:  BSTR containing a valid server name
	Outputs:  none
	Purpose:  Allows user to set which Server's EventLog will be displayed
*/
STDMETHODIMP CView::put_Server(BSTR newVal)
{
	m_ServerName = newVal;
	m_pLogs->m_ServerName = m_ServerName.copy();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\types.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////

typedef CComObject<
				CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> >
			> EnumVar;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tstst\vermak.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/////////////////////////////////////////////////////////////////////////////
// VERSION INFO
#include <ntverp.h>


#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Terminal Server Setup Test"
#define VER_INTERNALNAME_STR        "tstst"
#define VER_ORIGINALFILENAME_STR    "tstst.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tstst\audio.cpp ===
#include    "nt.h"
#include    "ntrtl.h"
#include    "nturtl.h"
#include    "stdafx.h"
#include    <windows.h>
#include    <winsta.h>
#include    <rdpsndp.h>
#include    <rdpstrm.h>
#include    <stdio.h>
#include    <strstrea.h>

extern ostrstream szMoreInfo;
BOOL
IsTSRedirectingAudio( VOID )
{
    BOOL rv;
    static  BOOL    bChecked = FALSE;
    static  BOOL    RemoteConsoleAudio = 0;    // Allow audio play at
                                               // the console
                                               // when console session is
                                               // remoted
    // is not consle ?
    //
    rv = !(USER_SHARED_DATA->ActiveConsoleId ==
      NtCurrentPeb()->SessionId);

    // console, we don't redirect
    if ( !rv )
    {
        szMoreInfo << "Running on the console" << endl;
        goto exitpt;
    } else
        szMoreInfo << "Running in a session" << endl;

    // check if audio is redirected on PTS
    //
    if ( !bChecked )
    {
        WINSTATIONCLIENT ClientData;
        ULONG Length;

        if (WinStationQueryInformation(SERVERNAME_CURRENT,
                                        LOGONID_CURRENT,
                                        WinStationClient,
                                        &ClientData,
                                        sizeof(ClientData),
                                        &Length ))
        {
            RemoteConsoleAudio = ClientData.fRemoteConsoleAudio;
        }
        else {
            szMoreInfo << "WinStatinQueryInformation failed=" <<
                    GetLastError() << endl;
            RemoteConsoleAudio = 0;
        }
    }

    rv = !RemoteConsoleAudio;

exitpt:
    return rv;
}

BOOL
IsTSAudioDriverEnabled( VOID )
{
    BOOL rv = FALSE;
    WINSTATIONCONFIG config;
    BOOLEAN          fSuccess;
    DWORD            returnedLength;

    fSuccess = WinStationQueryInformation(NULL, LOGONID_CURRENT,
                    WinStationConfiguration, &config,
                    sizeof(config), &returnedLength);
    if (!fSuccess)
    {
        szMoreInfo << "WinStatinQueryInformation failed=" <<
                GetLastError() <<endl;
        goto exitpt;
    }

    rv = !config.User.fDisableCam;

exitpt:
    return rv;
}

BOOL
DumpStreamInfo( VOID )
{
    BOOL        rv = TRUE;
    HANDLE      hEv = NULL;
    HANDLE      hStream = NULL;
    PSNDSTREAM  Stream = NULL;
    DWORD       dw;

    hEv = OpenEvent(EVENT_ALL_ACCESS,
                    FALSE,
                    TSSND_DATAREADYEVENT);

    if ( NULL == hEv )
    {
        szMoreInfo << "ERROR: Can't open DataReady event=" <<
            GetLastError() <<endl;
        rv = FALSE;
    } else {
        szMoreInfo << "OK: DataReady event exist" << endl;
        dw = WaitForSingleObject( hEv, 0 );
        if ( WAIT_OBJECT_0 == dw )
        {
            szMoreInfo << "WARNING: DataReady event is signaled (playing sound ?)" <<endl;
            SetEvent( hEv );
            rv = FALSE;
        } else
            szMoreInfo << "OK: DataReady event is not signaled" <<endl;
        CloseHandle( hEv );
    }


    hEv = OpenEvent(EVENT_ALL_ACCESS,
            FALSE,
            TSSND_STREAMISEMPTYEVENT);
    if ( NULL == hEv )
    {
        szMoreInfo << "ERROR: Can't open StreamEmpty event=" <<
            GetLastError() <<endl;
        rv = FALSE;
    } else {
        szMoreInfo << "OK: StreamEmpty event exist" <<endl;
        dw = WaitForSingleObject( hEv, 0 );
        if ( WAIT_OBJECT_0 == dw )
        {
            szMoreInfo << "WARNING: StreamEmpty is signaled  (playing sound ?)" <<endl;
            rv = FALSE;
        } else {
            szMoreInfo << "OK: StreamEmpty event is not signaled" <<endl;
            SetEvent( hEv );
        }
        CloseHandle( hEv );
    }

    hEv = OpenEvent(EVENT_ALL_ACCESS,
            FALSE,
            TSSND_WAITTOINIT);
    if ( NULL == hEv )
    {
        szMoreInfo << "ERROR: Can't open WaitToInit event=" <<
            GetLastError() <<endl;
        rv = FALSE;
    }
    else {
        szMoreInfo << "OK: WaitToInit event exist" <<endl;
        dw = WaitForSingleObject( hEv, 0 );
        if ( WAIT_OBJECT_0 == dw )
        {
            szMoreInfo << "OK: WaitToInit is signaled" <<endl;
        } else {
            szMoreInfo << "WARNING: WaitToInit is NOT signaled" <<endl;
            rv = FALSE;
        }
        CloseHandle( hEv );
    }

    hEv = OpenMutex(SYNCHRONIZE,
            FALSE,
            TSSND_STREAMMUTEX);
    if ( NULL == hEv )
    {
        szMoreInfo << "ERROR: Can't open Stream mutex=" <<
            GetLastError() <<endl;
        rv = FALSE;
    } else {
        szMoreInfo << "OK: Stream mutex exist" <<endl;
        dw = WaitForSingleObject( hEv, 3000 );
        if ( WAIT_OBJECT_0 != dw )
        {
            szMoreInfo << "WARNING: Can't acquire Stream mutext after more than 3 seconds" <<endl;
            rv = FALSE;
        } else {
            szMoreInfo << "OK: Stream mutext acquired" <<endl;
            ReleaseMutex( hEv );
        }
        CloseHandle( hEv );
    }

    hStream = OpenFileMapping(
                    FILE_MAP_ALL_ACCESS,
                    FALSE,
                    TSSND_STREAMNAME
                );

    if (NULL == hStream)
    {
        szMoreInfo << "ERROR: Can't open the stream mapping" <<
            GetLastError() <<endl;
        rv = FALSE;
        goto exitpt;
    }

    Stream = (PSNDSTREAM)MapViewOfFile(
                    hStream,
                    FILE_MAP_ALL_ACCESS,
                    0, 0,       // offset
                    sizeof(*Stream)
                    );

    if (NULL == Stream)
    {
        szMoreInfo << "ERROR: Can't map the stream view: " <<
                 GetLastError() <<endl;
        rv = FALSE;
        goto exitpt;
    }

    szMoreInfo << "SNDSTREAM:" <<endl;
    szMoreInfo << "bNewVolume:            0x" << hex << Stream->bNewVolume <<endl;
    szMoreInfo << "bNewPitch:             0x" << hex << Stream->bNewPitch <<endl;

    szMoreInfo << "dwSoundCaps:           0x" << hex << Stream->dwSoundCaps <<endl;
    if ( 0 != (TSSNDCAPS_ALIVE & Stream->dwSoundCaps) )
        szMoreInfo << "\tTSSNDCAPS_ALIVE" <<endl;
    if ( 0 != (TSSNDCAPS_VOLUME & Stream->dwSoundCaps) )
        szMoreInfo << "\tTSSNDCAPS_VOLUME" << endl;
    if ( 0 != (TSSNDCAPS_PITCH & Stream->dwSoundCaps) )
        szMoreInfo << "\tTSSNDCAPS_PITCH" <<endl;

    szMoreInfo << "dwVolume:              0x" << hex << Stream->dwVolume <<endl;
    szMoreInfo << "dwPitch:               0x" << hex << Stream->dwPitch <<endl;

    dw = Stream->cLastBlockQueued;
    szMoreInfo << "cLastBlockQueued:      0x" << hex << dw <<endl;
    dw = Stream->cLastBlockSent;
    szMoreInfo << "cLastBlockSent:        0x" << hex << dw <<endl;
    dw = Stream->cLastBlockConfirmed;
    szMoreInfo << "cLastBlockConfirmed:   0x" << hex << dw <<endl;

exitpt:
    if ( rv )
        szMoreInfo << "OK: Stream seems good" <<endl;
    else
        szMoreInfo << "ERROR: Stream doesn't seem very healthy" <<endl;

    if ( NULL != Stream )
        UnmapViewOfFile( Stream );

    if ( NULL != hStream )
        CloseHandle( hStream );

    return rv;
}

BOOL
IsAudioOk(
    VOID
    )
{
    INT rv = TRUE;

    if ( !IsTSRedirectingAudio() )
    {
        szMoreInfo << "Audio is not redirected" <<endl;
        goto exitpt;
    }

    if ( !IsTSAudioDriverEnabled() )
    {
        szMoreInfo << "TS Auidio driver is disabled" <<endl;
        goto exitpt;
    }

    szMoreInfo << "Audio redirection is enabled. Dumping stream info" <<endl;

    rv = DumpStreamInfo();

exitpt:
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tstst\tstst.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation



#include "stdafx.h"
#include <iostream.h>

#include <string>
typedef std::basic_string<TCHAR> TString;

#include <fstream.h>
#include <strstrea.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <wtsapi32.h>
// #include <ostream>
//#include <cstring>
// #include <sstream>


class ConstCRegistry : public CRegistry
{
public:
    DWORD       OpenKey  (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS, LPCTSTR lpMachineName = NULL);
};

DWORD ConstCRegistry::OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, LPCTSTR lpMachineName /*= NULL*/)
{
    ASSERT(access == KEY_READ);
    return CRegistry::OpenKey(hKey, lpSubKey, KEY_READ, lpMachineName);
}

#define ConstCRegistry CRegistry
//
// global utilities and veraibles.
//


char szOutput[2048];
ostrstream szMoreInfo(szOutput, 4096);


TCHAR *ReturnBuffer()
{
    
    static TCHAR szReturnTchar[512];
    return szReturnTchar;
}



const OSVERSIONINFOEX *GetOSVersionInfo()
{
    static OSVERSIONINFOEX gOsVersion;
    static bGotOnce = FALSE;
    if (!bGotOnce)
    {
        ZeroMemory(&gOsVersion, sizeof(OSVERSIONINFOEX));
        gOsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        GetVersionEx( (LPOSVERSIONINFO ) &gOsVersion);
        bGotOnce = TRUE;
    }

    return &gOsVersion;
}



// #include <strstream>
#include "winsock2.h"


// ostringstream sz

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(P)          (P)
#endif

#define OLD_VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))


BOOL CheckifBinaryisSigned        (TCHAR *szFile);  // from tscert.cpp
BOOL EnumerateLicenseServers      ();               // from timebomb.cpp
TCHAR *IsBetaSystem                 ();
BOOL HasLicenceGracePeriodExpired ();               // from timebomb.cpp
BOOL ExtractAllTSEvents();


BOOL ValidateProductSuite (LPSTR SuiteName);
BOOL IsTerminalServicesEnabled ( VOID );
DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, BOOL *pbFound);
BOOL DoesHydraKeysExists ();
TCHAR *IsServer ();
BOOL IsKernelTSEnable ();
BOOL TSEnabled ();
BOOL DoesProductSuiteContainTS ();
BOOL IsTerminalServerRegistryOk ();
TCHAR *IsTerminalServiceStartBitSet ();
BOOL IsTermDDStartBitSet ();
BOOL GetTSOCLogFileName (char *strFileName, UINT uiSize);
BOOL DidTsOCgetCompleteInstallationMessage ();
BOOL FileExists (char *pszFullNameAndPath);
BOOL IsTSOClogPresent ();
BOOL DidOCMInstallTSEnable();
TCHAR *IsClusteringInstalled ();
BOOL IsRemoteAdminMode ();
BOOL CheckModeRegistry (BOOL bAppCompat);
BOOL IsTerminalServiceRunning ();
BOOL CheckVideoKeys ();
BOOL CheckModePermissions(DWORD *pdwSecurtyMode);
BOOL IsFile128Bit(LPTSTR szFile, BOOL *pb128Bit);
ULONG RDPDRINST_DetectInstall();    // defined in drdetect.cpp
BOOL IsAudioOk( VOID );


TCHAR *aszStack[] = {
//  _T("noexport\%SystemRoot%\\system32\\drivers\\rdpwdd.sys"),
    _T("%SystemRoot%\\system32\\drivers\\termdd.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdasync.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdipx.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdnetb.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdpipe.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdspx.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdtcp.sys"),
    _T("%SystemRoot%\\system32\\drivers\\rdpwd.sys"),
    _T("%SystemRoot%\\system32\\rdpdd.dll"),
    _T("%SystemRoot%\\system32\\rdpwsx.dll")
};

TCHAR Version[256];
TCHAR *GetTSVersion()
{
	CRegistry oRegTermsrv;
	DWORD cbVersion = 0;
	LPTSTR szVersion = NULL;

	if ((ERROR_SUCCESS == oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ)) &&
		(ERROR_SUCCESS == oRegTermsrv.ReadRegString(_T("ProductVersion"), &szVersion, &cbVersion)))
	{
		_tcscpy(Version, szVersion);
		return Version;
	}

	return _T("Error finding Version.");
}

BOOL IsIt50TS()
{
	return (0 == _tcsicmp(Version, _T("5.0")));
}

BOOL IsIt51TS()
{
	return (0 == _tcsicmp(Version, _T("5.1"))) || (0 == _tcsicmp(Version, _T("5.2")));
}


TCHAR *IsLicenceGracePeriodOk ()
{
    return  (HasLicenceGracePeriodExpired () ? _T("Yep, Its expired") : _T("Its Not expired"));
}


BOOL Check_termdd()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\termdd.sys"));
}
BOOL Check_tdasync()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\tdasync.sys"));
}
BOOL Check_tdipx()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\tdipx.sys"));
}
BOOL Check_tdnetb()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\tdnetb.sys"));
}
BOOL Check_tdpipe()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\tdpipe.sys"));
}
BOOL Check_tdspx()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\tdspx.sys"));
}
BOOL Check_tdtcp()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\tdtcp.sys"));
}
BOOL Check_rdpwd()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\rdpwd.sys"));
}
BOOL Check_rdpdd()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\rdpdd.dll"));
}
BOOL Check_rdpwsx()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\rdpwsx.dll"));
}


BOOL IsRdpDrInstalledProperly ()
{
    bool bPersonal = (GetOSVersionInfo()->wSuiteMask & VER_SUITE_PERSONAL) != 0;
    bool bRdpdrInstalled = RDPDRINST_DetectInstall() != 0;

    return bPersonal != bRdpdrInstalled;
}


TCHAR *GetModePermissions()
{
    CRegistry reg;
    DWORD dwSecurityMode;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ))
    {
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSUserEnabled"), &dwSecurityMode))
        {
            if (dwSecurityMode == 0)
            {
                return _T("Its W2k Compatible");
            }
            else if (dwSecurityMode == 1)
            {
                return _T("Its TS4 Compatible");

            }
            else
            {
                szMoreInfo << "SYSTEM\\CurrentControlSet\\Control\\Terminal Server/TSUserEnabled has wrong value" << dwSecurityMode << endl;
                return NULL;

            }
        }
    }

    return NULL;

}

BOOL CheckModePermissions (DWORD *pdwSecurtyMode)
{
//    PERM_WIN2K = 0,
//    PERM_TS4 = 1

    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ))
    {
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSUserEnabled"), pdwSecurtyMode))
        {
            return (*pdwSecurtyMode== 0) || (*pdwSecurtyMode== 1);
        }
    }

    return FALSE;
}

TCHAR *GetCypherStrenthOnRdpwd ()
{
    BOOL bFile128bit;
    if ( IsFile128Bit(_T("%SystemRoot%\\system32\\drivers\\rdpwd.sys"), &bFile128bit) )
    {
        return bFile128bit ? _T("128 Bit") : _T("56 Bit");
    }
    else
    {
        return NULL;
    }

}


BOOL IsFile128Bit(LPTSTR szFile, BOOL *pb128Bit)
{
    USES_CONVERSION;
    DWORD dwHandle;

    TCHAR szFullFile[MAX_PATH +1];

    BOOL bSuccess = FALSE;

    if (ExpandEnvironmentStrings(szFile, szFullFile, MAX_PATH))
    {
        if (FileExists(T2A(szFullFile)))
        {
            DWORD dwSize = GetFileVersionInfoSize(szFullFile, &dwHandle);
            if (dwSize > 0)
            {
                BYTE *pbData = new BYTE[dwSize];
                if (pbData)
                {
                    if (GetFileVersionInfo(szFullFile, 0, dwSize, pbData))
                    {
                        TCHAR *szFileDescription;
                        UINT uiLen = 0;
                        if (VerQueryValue(pbData, _T("\\StringFileInfo\\040904B0\\FileDescription"), (LPVOID *)&szFileDescription, &uiLen))
                        {
                            if (_tcsstr(szFileDescription, _T("Not for Export")))
                            {
                                *pb128Bit = TRUE;
                                bSuccess = TRUE;

                            }
                            else if (_tcsstr(szFileDescription, _T("Export Version")))
                            {
                                *pb128Bit = FALSE;
                                bSuccess = TRUE;
                            }
                        }
                    }

                    delete [] pbData;

                }

            }
        }
    }

    return bSuccess;
}



BOOL ValidateProductSuite (LPSTR SuiteName)
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPSTR ProductSuite = NULL;
    LPSTR p;

    Rslt = RegOpenKeyA(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\ProductOptions",
        &hKey
        );

    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueExA( hKey, "ProductSuite", NULL, &Type, NULL, &Size );
    if (Rslt != ERROR_SUCCESS || !Size)
        goto exit;

    ProductSuite = (LPSTR) LocalAlloc( LPTR, Size );
    if (!ProductSuite)
        goto exit;

    Rslt = RegQueryValueExA( hKey, "ProductSuite", NULL, &Type,
        (LPBYTE) ProductSuite, &Size );
     if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    p = ProductSuite;
    while (*p)
    {
        if (lstrcmpA( p, SuiteName ) == 0)
        {
            rVal = TRUE;
            break;
        }
        p += (lstrlenA( p ) + 1);
    }

exit:
    if (ProductSuite)
        LocalFree( ProductSuite );

    if (hKey)
        RegCloseKey( hKey );

    return rVal;
}


BOOL IsTerminalServicesEnabled( VOID )
{
    BOOL    bResult = FALSE;
    DWORD   dwVersion;
    OSVERSIONINFOEXA osVersionInfo;
    DWORDLONG dwlConditionMask = 0;
    HMODULE hmodK32 = NULL;
    typedef ULONGLONG (*PFnVerSetConditionMask) ( ULONGLONG, ULONG, UCHAR );
    typedef BOOL      (*PFnVerifyVersionInfoA) (POSVERSIONINFOEXA, DWORD, DWORDLONG);
    PFnVerSetConditionMask pfnVerSetConditionMask;
    PFnVerifyVersionInfoA pfnVerifyVersionInfoA;


    dwVersion = GetVersion();

    /* are we running NT ? */
    if (!(dwVersion & 0x80000000))
    {
        // Is it NT 50 or greater ?
        if (LOBYTE(LOWORD(dwVersion)) > 4)
        {
            /* In NT5 we need to use the Product Suite APIs
             Don't static link because it won't load on non-NT5 systems */

            hmodK32 = GetModuleHandleA( "KERNEL32.DLL" );
            if (hmodK32)
            {
                pfnVerSetConditionMask = (PFnVerSetConditionMask )GetProcAddress( hmodK32, "VerSetConditionMask");

                if (pfnVerSetConditionMask)
                {
                    /* get the condition mask. */
                    dwlConditionMask = (*pfnVerSetConditionMask)(dwlConditionMask, VER_SUITENAME, VER_AND);

                    pfnVerifyVersionInfoA = (PFnVerifyVersionInfoA)GetProcAddress( hmodK32, "VerifyVersionInfoA") ;

                    if (pfnVerifyVersionInfoA != NULL)
                    {

                        ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));
                        osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
                        osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;
                        bResult = (*pfnVerifyVersionInfoA)(
                                          &osVersionInfo,
                                          VER_SUITENAME,
                                          dwlConditionMask);
                    }
                }
            }
        }
        else
        {
            /* This is NT 40 */
            bResult = ValidateProductSuite( "Terminal Server" );
        }
    }

    return bResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, BOOL *pbFound)
* checks if parameter string exists in given multistring.
* returns error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, BOOL *pbFound)
{
    ASSERT(szkey && *szkey);
    ASSERT(szvalue && *szvalue);
    ASSERT(szCheckForString&& *szCheckForString);
    ASSERT(*szkey != '\\');
    ASSERT(pbFound);

    // not yet found.
    *pbFound = FALSE;

    CRegistry reg;
    DWORD dwError = reg.OpenKey(hkey, szkey, KEY_READ);  // open up the required key.
    if (dwError == NO_ERROR)
    {
        LPTSTR szSuiteValue;
        DWORD dwSize;
        dwError = reg.ReadRegMultiString(szvalue, &szSuiteValue, &dwSize);
        if (dwError == NO_ERROR)
        {
            LPCTSTR pTemp = szSuiteValue;
            while(_tcslen(pTemp) > 0 )
            {
                if (_tcscmp(pTemp, szCheckForString) == 0)
                {
                    *pbFound = TRUE;
                    break;
                }

                pTemp += _tcslen(pTemp) + 1; // point to the next string within the multistring.
                if ( DWORD(pTemp - szSuiteValue) > (dwSize / sizeof(TCHAR)))
                    break; // temporary pointer passes the size of the szSuiteValue something is wrong with szSuiteValue.
            }
        }
    }

    return dwError;

}


BOOL DoesHydraKeysExists()
{
    BOOL bStringExists = FALSE;
    DWORD dw = IsStringInMultiString(
        HKEY_LOCAL_MACHINE,
        _T("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
        _T("ProductSuite"),
        _T("Terminal Server"),
        &bStringExists);

    return (dw == ERROR_SUCCESS) && bStringExists;
}






TCHAR *IsItAppServer ()
{
    return ((GetOSVersionInfo()->wSuiteMask & VER_SUITE_TERMINAL) &&
           !(GetOSVersionInfo()->wSuiteMask & VER_SUITE_SINGLEUSERTS)) ? _T("Yes") : _T("No");
}


BOOL IsItServer ()
{
    return GetOSVersionInfo()->wProductType != VER_NT_WORKSTATION;
}


TCHAR *GetProductType ()
{
    BYTE wProductType = GetOSVersionInfo()->wProductType;
    _tcscpy(ReturnBuffer(), _T(""));

    if (wProductType == VER_NT_WORKSTATION)
    {
        _tcscat(ReturnBuffer(), _T("VER_NT_WORKSTATION "));
    }

    if (wProductType == VER_NT_DOMAIN_CONTROLLER)
    {
        _tcscat(ReturnBuffer(), _T("VER_NT_DOMAIN_CONTROLLER"));
    }

    if (wProductType == VER_NT_SERVER)
    {
        _tcscat(ReturnBuffer(), _T("VER_NT_SERVER"));
    }

    return ReturnBuffer();

}

TCHAR *GetProductSuite ()
{
    WORD wProductSuite = GetOSVersionInfo()->wSuiteMask;
    _tcscpy(ReturnBuffer(), _T(""));

    if (wProductSuite & VER_SERVER_NT)
    {
        _tcscat(ReturnBuffer(), _T("VER_SERVER_NT "));

    }
    if (wProductSuite & VER_WORKSTATION_NT)
    {
        _tcscat(ReturnBuffer(), _T("VER_WORKSTATION_NT "));

    }
    if (wProductSuite & VER_SUITE_SMALLBUSINESS)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_SMALLBUSINESS "));

    }
    if (wProductSuite & VER_SUITE_ENTERPRISE)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_ENTERPRISE "));

    }
    if (wProductSuite & VER_SUITE_BACKOFFICE)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_BACKOFFICE "));

    }
    if (wProductSuite & VER_SUITE_COMMUNICATIONS)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_COMMUNICATIONS "));

    }
    if (wProductSuite & VER_SUITE_TERMINAL)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_TERMINAL "));

    }
    if (wProductSuite & VER_SUITE_SMALLBUSINESS_RESTRICTED)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_SMALLBUSINESS_RESTRICTED "));

    }
    if (wProductSuite & VER_SUITE_EMBEDDEDNT)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_EMBEDDEDNT "));

    }
    if (wProductSuite & VER_SUITE_DATACENTER)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_DATACENTER "));

    }
    if (wProductSuite & VER_SUITE_SINGLEUSERTS)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_SINGLEUSERTS "));

    }
    if (wProductSuite & VER_SUITE_PERSONAL)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_PERSONAL "));

    }
    return ReturnBuffer();
}


TCHAR *IsServer ()
{
    return IsItServer() ? _T("Its a Server") : _T("Its a WorkStation");
}



BOOL IsKernelTSEnable ()
{
    return IsTerminalServicesEnabled();
}

BOOL TSEnabled ()
{

    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ))
    {
        DWORD dwTSEnabled = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSEnabled"), &dwTSEnabled))
        {
            return dwTSEnabled == 1;
        }
    }

    return FALSE;
}

BOOL DoesProductSuiteContainTS ()
{
    return DoesHydraKeysExists ();
}

BOOL IsTerminalServerRegistryOk ()
{
    CRegistry reg1;
    CRegistry reg2;
    CRegistry reg3;

    return
    (ERROR_SUCCESS == reg1.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ)) &&
    (ERROR_SUCCESS == reg2.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations"), KEY_READ)) &&
    (ERROR_SUCCESS == reg3.OpenKey(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"), KEY_READ));
}

TCHAR *GetWinstationList ()
{
    using namespace std;

    TString szWinstationList;


    bool bFoundNonConsoleWinstation = false;

    szWinstationList = _T("");

    CRegistry reg2;
    if (ERROR_SUCCESS == reg2.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations"), KEY_READ))
    {
        LPTSTR szWinstation;
        DWORD dwSize;

        if (ERROR_SUCCESS == reg2.GetFirstSubKey(&szWinstation, &dwSize))
        {
            bool bFirst = true;

            do
            {
                if (!bFirst)
                {
                    szWinstationList += _T(", ");
                }

                bFirst = false;

                if (0 != _tcsicmp(szWinstation, _T("Console")))
                {
                    bFoundNonConsoleWinstation = true;

                    //
                    // we need to read the listner port for this winstation.
                    //
                    CRegistry regSubKey;
                    if ( ERROR_SUCCESS == regSubKey.OpenKey(reg2, szWinstation, KEY_READ) )
                    {
                        DWORD dwPort;
                        if ( ERROR_SUCCESS != regSubKey.ReadRegDWord(_T("PortNumber"), &dwPort))
                        {
                            dwPort = 0;

                        }
                        TCHAR szPort[20];

                        _itot(dwPort, szPort, 10);
                        
                        szWinstationList += szWinstation; // << _T("(") << dwPort << _T(")");
                        szWinstationList += _T("(");
                        szWinstationList += szPort;
                        szWinstationList += _T(")");
                    }

                }
                else
                {
                    szWinstationList += szWinstation;
                }

            }
            while (ERROR_SUCCESS == reg2.GetNextSubKey(&szWinstation, &dwSize));
        }
    }

    if (szWinstationList.length() == 0)
    {
        szWinstationList = _T("Error, No winstations found.");
    }

    if (!bFoundNonConsoleWinstation)
    {
        szMoreInfo << "ERROR, No non Console Winstation not found" << endl;
    }

    _tcscpy(ReturnBuffer(), szWinstationList.c_str());
    return ReturnBuffer();

}

TCHAR *IsTerminalServiceStartBitSet ()
{

    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermService"), KEY_READ))
    {
        DWORD dwTermServStartBit = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("Start"), &dwTermServStartBit))
        {
            switch (dwTermServStartBit)
            {
                case 2:
                return _T("AutoStart");
                break;

                case 3:
                return _T("Manual Start");
                break;

                case 4:
                return _T("Error, Disabled");
                break;

                default:
                return _T("ERROR:Wrong value for startbit");
            }

        }
    }

    return _T("Error, Reading startbig");
}

BOOL IsTermDDStartBitSet ()
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermDD"), KEY_READ))
    {
        DWORD dwTermDDStartBit = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("Start"), &dwTermDDStartBit))
        {
            return dwTermDDStartBit == 2;
        }
    }

    return FALSE;
}

TCHAR *AreEffectiveConnectionAllowed ()
{
    HMODULE hmodRegAPI = LoadLibrary( _T("RegApi.dll") );

    if (hmodRegAPI)
    {

        typedef BOOLEAN (*PFDenyConnectionPolicy) ();
        PFDenyConnectionPolicy pfnDenyConnectionPolicy;

        pfnDenyConnectionPolicy = (PFDenyConnectionPolicy) GetProcAddress( hmodRegAPI, "RegDenyTSConnectionsPolicy");
        if (pfnDenyConnectionPolicy)
        {
              return (*pfnDenyConnectionPolicy)() ? _T("Not Allowed") : _T("Allowed");

        }
        else
        {
            szMoreInfo << "Failed to get proc RegDenyTSConnectionsPolicy" << endl;
            return _T("Failed");
        }
    }
    else
    {
       szMoreInfo << "Failed to Load regapi.dll" << endl;
       return _T("Failed");
    }


}

TCHAR *AreConnectionsAllowed ()
{
	DWORD dwError;
	CRegistry oRegTermsrv;

	dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ);
	if (ERROR_SUCCESS == dwError)
	{
		DWORD dwDenyConnect;
		dwError = oRegTermsrv.ReadRegDWord(_T("fDenyTSConnections"), &dwDenyConnect);
		if (ERROR_SUCCESS == dwError)
		{
			return dwDenyConnect ? _T("No, Not allowed") : _T("Yes");
		}
	}

	//
	// could not read registry, It means - for 51 connection not allowed. For 50 Connections allowed.
	//

	return IsIt51TS() ? _T("Error, Value not found") : _T("Yes");
}

BOOL GetTSOCLogFileName(char *strFileName, UINT uiSize)
{
    if (!GetSystemWindowsDirectoryA(strFileName, uiSize))
        return FALSE;

    strcat(strFileName, "\\tsoc.log");
    ASSERT(strlen(strFileName) < uiSize);
    return TRUE;
}

char *IncompleteMessage = "Error:TSOC Did not get OC_COMPLETE_INSTALLATION.";
BOOL DidTsOCgetCompleteInstallationMessage ()
{

    if (!IsTSOClogPresent())
    {
        szMoreInfo << "tsoc.log does not exist." << endl;
        return FALSE;
    }

    char strTSOCLog[256];
    GetTSOCLogFileName(strTSOCLog, 256);

	ifstream ifSrc(strTSOCLog);
	if(!ifSrc)
    {
        szMoreInfo << "Failed to open tsoc.log file." << endl;
        return FALSE;
    }


    char tempSrc[256];
	while(!ifSrc.eof())
	{
		ifSrc.getline(tempSrc, 256);
        if (strstr(tempSrc, IncompleteMessage))
        {
            return FALSE;
        }
	}

    return TRUE;
}

BOOL FileExists(char *pszFullNameAndPath)
{
    ASSERT(pszFullNameAndPath);

    if (pszFullNameAndPath && pszFullNameAndPath[0])
    {
        HANDLE hFile = CreateFileA(pszFullNameAndPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
					              NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	    if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
            return TRUE;
        }
    }

    return FALSE;
}

BOOL IsTSOClogPresent ()
{
    char strTSOCLog[256];
    GetTSOCLogFileName(strTSOCLog, 256);
    return FileExists(strTSOCLog);
}

BOOL DidOCMInstallTSEnable()
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\SubComponents"), KEY_READ))
    {
        DWORD dwTSEnabled = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("tsenable"), &dwTSEnabled))
        {
            return dwTSEnabled == 1;
        }
    }

    return FALSE;
}

TCHAR *IsClusteringInstalled ()
{
    DWORD dwClusterState;
    if (ERROR_SUCCESS == GetNodeClusterState(NULL, &dwClusterState))
    {
        if (dwClusterState != ClusterStateNotInstalled)
        {
            return _T("***Failed. Clustering is installed, this is not compatible with Terminal Server.");
       }

    }

    return _T("Passed");
}


TCHAR *GetTSMode (void)
{
    return IsRemoteAdminMode() ? _T("Remote Admin") : _T("Application Server");
}

BOOL IsRemoteAdminMode ()
{
    // HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server","TSAppCompat",0x00010001,0x0
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ))
    {
        DWORD dwAppCompat = 1;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSAppCompat"), &dwAppCompat))
        {
            return dwAppCompat == 0;
        }
        else
        {
            // if the registry TSAppCompat does not exist it means we are in app server mode.
            return FALSE;

        }
    }
    else
    {
        szMoreInfo << "ERROR:SYSTEM\\CurrentControlSet\\Control\\Terminal Server not found!" << endl;
    }

    // this return is bogus.
    return TRUE;

}

BOOL VerifyModeRegistry()
{
    return CheckModeRegistry(!IsRemoteAdminMode());
}

BOOL CheckModeRegistry (BOOL bAppCompat)
{
    USES_CONVERSION;
    BOOL bOk = TRUE;

    CRegistry reg;

    if (IsItServer())
    {
        CRegistry reg1;

        // check registry value
        // for appcompat mode
            //HKLM ,"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon","AppSetup",0x00000000,"UsrLogon.Cmd"
        // and for remote admin mode
            //HKLM ,"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon","AppSetup",0x00000000,""


        if ( ERROR_SUCCESS == reg1.OpenKey( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), KEY_READ))
        {
            LPTSTR str;
            DWORD dwSize;
            DWORD dwError;
            if (ERROR_SUCCESS == (dwError = reg1.ReadRegString(_T("AppSetup"), &str, &dwSize)))
            {
                if (bAppCompat)
                {
                    if (_tcsicmp(str, _T("UsrLogon.Cmd")) != 0)
                    {
                        bOk = FALSE;
                        szMoreInfo << "ERROR: Wrong value (" << T2A(str) << ") for AppSetup, contact makarp/breenh" << endl;
                    }

                }
                else
                {
                    if (_tcslen(str) != 0)
                    {
                        bOk = FALSE;
                        szMoreInfo << "ERROR: Wrong value (" << T2A(str) << ") for AppSetup, contact makarp/breenh" << endl;

                    }

                }

            }
            else
            {
                szMoreInfo << "ERROR reading appsetup registry (" << dwError << ")" << endl;
                bOk = FALSE;
            }

        }
        else
        {
            szMoreInfo << "ERROR:reading SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon" << endl;
            bOk = FALSE;
        }

    }



    // check registry value
    // for appcompat mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server","IdleWinStationPoolCount",0x00010001,0x2
    // and for remote admin mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server","IdleWinStationPoolCount",0x00010001,0x0


    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ))
    {
        DWORD dwIdleWinstations;
        if (ERROR_SUCCESS == reg.ReadRegDWord(_T("IdleWinStationPoolCount"), &dwIdleWinstations))
        {
            if (bAppCompat)
            {
                if (0x2 != dwIdleWinstations)
                {
                    bOk = FALSE;
                    szMoreInfo << "ERROR: Wrong IdleWinStationPoolCount (" << dwIdleWinstations << ")" << endl;
                }

            }
            else
            {
                if (0 != dwIdleWinstations)
                {
                    bOk = FALSE;
                    szMoreInfo << "ERROR: Wrong IdleWinStationPoolCount (" << dwIdleWinstations << ")" << endl;
                }

            }

        }
        else
        {
            bOk = FALSE;
            szMoreInfo << "ERROR:Reading IdleWinStationPoolCount registry" << endl;

        }

    }
    else
    {
        bOk = FALSE;
        szMoreInfo << "SYSTEM\\CurrentControlSet\\Control\\Terminal Server" << endl;
    }

    return bOk;


}

TCHAR * TermSrvCommandLine ()
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermService"), KEY_READ))
    {
        TCHAR *Imagepath;
        DWORD dwSize;
        if ( ERROR_SUCCESS == reg.ReadRegString(_T("ImagePath"), &Imagepath, &dwSize))
        {
            _tcscpy(ReturnBuffer(), Imagepath);

        }
        else
        {
            _tcscpy(ReturnBuffer(), _T("failed to read value"));
        }

    }
    else
    {
        _tcscpy(ReturnBuffer(), _T("failed to open key"));

    }

    return  ReturnBuffer();

    // termsrv executable has to have svchost.exe
}

BOOL IsTerminalServiceRunning ()
{

    BOOL bReturn = FALSE;

    SC_HANDLE hServiceController = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (hServiceController)
    {

        SC_HANDLE hTermServ = OpenService(hServiceController, _T("TermService"), SERVICE_QUERY_STATUS);
        if (hTermServ)
        {
            SERVICE_STATUS tTermServStatus;
            if (QueryServiceStatus(hTermServ, &tTermServStatus))
            {
                bReturn = (tTermServStatus.dwCurrentState == SERVICE_RUNNING);
            }
            else
            {
                szMoreInfo << "Failed to get service status, Error = " << GetLastError() << endl;

            }

            VERIFY(CloseServiceHandle(hTermServ));

        }
        else
        {
            szMoreInfo << "Failed to open TermServ service, Error = " << GetLastError() << endl;
        }

        VERIFY(CloseServiceHandle(hServiceController));
    }
    else
    {
        szMoreInfo << "Failed to Open Service Controller, Error = " << GetLastError() << endl;
    }

    return bReturn;
}


BOOL CheckVideoKeys ()
{
    //    HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server\VIDEO\rdpdd","VgaCompatible",0x00000000,"\Device\Video0"
    //    HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server\VIDEO\rdpdd","\Device\Video0",0x00000000,"\REGISTRY\Machine\System\ControlSet001\Services\RDPDD\Device0"

    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\VIDEO\\rdpdd"), KEY_READ))
    {
        LPTSTR str = 0;
        DWORD dwSize = 0;
        if (ERROR_SUCCESS == reg.ReadRegString(_T("VgaCompatible"), &str, &dwSize))
        {
            if (0 == _tcsicmp(str, _T("\\Device\\Video0")))
            {
                if (ERROR_SUCCESS == reg.ReadRegString(_T("\\Device\\Video0"), &str, &dwSize))
                {
                    if ((0 == _tcsicmp(str, _T("\\REGISTRY\\Machine\\System\\ControlSet001\\Services\\RDPDD\\Device0"))) ||
                        (0 == _tcsicmp(str, _T("\\REGISTRY\\Machine\\System\\CurrentControlSet\\Services\\RDPDD\\Device0"))))
                    {
                        return TRUE;
                    }
                    else
                    {
                    }
                }
                else
                {
                }
            }
            else
            {

            }

        }
        else
        {
        }
    }
    else
    {
    }

    return FALSE;
}

TCHAR szCompName[256];
TCHAR *GetCompName ()
{
    DWORD dwCompName = 256;

    if (GetComputerName(szCompName, &dwCompName))
    {
        return szCompName;

    }

    return NULL;

}


TCHAR szDomNameWorkgroup[] = _T("<Workgroup>");
TCHAR szDomNameUnknown[] = _T("<Unknown>");
TCHAR *GetDomName ()
{
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomainInfo = NULL;
    DWORD dwErr;

    //
    // Check if we're in a workgroup
    //
    dwErr = DsRoleGetPrimaryDomainInformation(NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *) &pDomainInfo);

    if (ERROR_SUCCESS != dwErr)
        return szDomNameUnknown;

    switch (pDomainInfo->MachineRole)
    {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            return szDomNameWorkgroup;
            break;      // just in case
    }

    if (pDomainInfo->DomainNameFlat)
        return pDomainInfo->DomainNameFlat;
    else if (pDomainInfo->DomainNameDns)
        return pDomainInfo->DomainNameDns;
    else
        return szDomNameUnknown;
}


TCHAR szSiteNameWorkgroup[] = _T("<Workgroup>");
TCHAR szSiteNameUnknown[] = _T("<Unknown>");
TCHAR *GetSiteName ()
{
    LPTSTR szSiteName = NULL;
    DWORD dwErr;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomainInfo = NULL;

    //
    // Check if we're in a workgroup
    //
    dwErr = DsRoleGetPrimaryDomainInformation(NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *) &pDomainInfo);

    if (ERROR_SUCCESS != dwErr)
        return szSiteNameUnknown;

    switch (pDomainInfo->MachineRole)
    {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            return szSiteNameWorkgroup;
            break;      // just in case
    }

    dwErr = DsGetSiteName(NULL,&szSiteName);

    if (NO_ERROR != dwErr)
    {
        return szSiteNameUnknown;
    }

    return szSiteName;
}


WCHAR wszIPAddress[128] = L"<error>";
TCHAR *GetIPAddress ()
{
	//get host address
	WORD wVersionRequested = MAKEWORD( 1, 1 ); 
	WSADATA wsaData;
	if (0 == WSAStartup(wVersionRequested,&wsaData))
    {
        char szHostName[256];

        if (0 == gethostname ( szHostName , 256 ))
        {
            hostent *h;
            if (NULL != (h=gethostbyname ( szHostName )))
            {
                in_addr *inaddr=(struct in_addr *)*h->h_addr_list;

                MultiByteToWideChar(CP_ACP,0,inet_ntoa(*inaddr),-1,wszIPAddress,128);
            }
        }
    }

    return wszIPAddress;
}




TCHAR *IsRDPNPinNetProviders ()
{
    TCHAR NEWORK_PROVIDER_ORDER_KEY[] = _T("SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order");
    TCHAR PROVIDER_ORDER_VALUE[]      = _T("ProviderOrder");
    TCHAR RDPNP_ENTRY[]               = _T("RDPNP");
	BOOL bRdpNpExists				  = FALSE;

	// read network privider key.
	CRegistry regNetOrder;
	LPTSTR szOldValue;
	DWORD dwSize;
	if ((ERROR_SUCCESS == regNetOrder.OpenKey(HKEY_LOCAL_MACHINE, NEWORK_PROVIDER_ORDER_KEY, KEY_READ)) &&
	   (ERROR_SUCCESS == regNetOrder.ReadRegString(PROVIDER_ORDER_VALUE, &szOldValue, &dwSize)))
	{
		bRdpNpExists = (_tcsstr(szOldValue, RDPNP_ENTRY) != NULL);
	
	}

	if (TSEnabled () == bRdpNpExists)
	{
		return (_T("Passed"));
	}
	else
	{
		if (bRdpNpExists)
		{
			return _T("Error: RDPNP, exists in ProviderOrder, but TS is disabled!");
		}
		else
		{
			if (IsIt50TS())
			{
				// rdp np is only for 51+ so its ok if its missing for 50.
				return _T("Passed");
			}
			else
			{
				return _T("ERROR, RDPNP is missing from ProviderOrder");
			}
		}
	}
}



TCHAR *IsMultiConnectionAllowed ()
{
	// SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon","AllowMultipleTSSessions
	CRegistry regWL;
	DWORD dwAllowMultipal;
	if ((ERROR_SUCCESS == regWL.OpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), KEY_READ)) &&
		(ERROR_SUCCESS == regWL.ReadRegDWord(_T("AllowMultipleTSSessions"), &dwAllowMultipal)))
	{
		return dwAllowMultipal ? _T("Yes") : _T("No");
	}

	if (IsIt50TS() || IsItServer())
	{
		return _T("Yes");
	}
	else
	{
		return _T("ERROR, registry missing");
	}
}

TCHAR *LogonType ()
{
	if (0 == _tcsicmp(GetDomName(), szDomNameWorkgroup))
	{
		CRegistry regWL;
		DWORD dwLogonType;
		if ((ERROR_SUCCESS == regWL.OpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), KEY_READ)) &&
			(ERROR_SUCCESS == regWL.ReadRegDWord(_T("LogonType"), &dwLogonType)))
		{
			return dwLogonType == 0 ? _T("Classic Gina") : _T("New Fancy");
		}

		if (IsIt50TS())
		{
			return _T("Classic");
		}
		else
		{
			return _T("ERROR, registry missing");
		}
	}
	else
	{
		return _T("Classic Gina");
	}
}

BOOL IsTermSrvInSystemContext ()
{
    USES_CONVERSION;
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermService"), KEY_READ))
    {
        TCHAR *szObjectName;
        DWORD dwSize;
        if ( ERROR_SUCCESS == reg.ReadRegString( _T("ObjectName"), &szObjectName, &dwSize))
        {
            if (0 == _tcsicmp(szObjectName, _T("LocalSystem")))
            {
                return TRUE;
            }
            else
            {
                szMoreInfo << "ERROR:Termsrv is set to run using (" << T2A(szObjectName) << ") context." << endl;
            }
        }
        else
        {
            szMoreInfo << "failed to read Objectname" << endl;
        }
    }
    else
    {
        szMoreInfo << "failed to open termsrv registry" << endl;
    }

    return FALSE;

}


BOOL DontRun ()
{
    szMoreInfo << "test not run because its not required." << endl;
    return FALSE;
}
BOOL DoRun ()
{
    szMoreInfo << "this test must be run." << endl;
    return TRUE;
}

TCHAR *SystemDirectory()
{
    TCHAR sysdir[MAX_PATH];
    sysdir[0] = '\0';
    if (GetSystemDirectory(sysdir, MAX_PATH) >= MAX_PATH) {
        sysdir[MAX_PATH -1] = '\0';
    }
    _tcscpy(ReturnBuffer(), sysdir);
    return  ReturnBuffer();
}

BOOL IsListenerSessionPresent()
{
    PWTS_SESSION_INFO pWtsSessionInfo;
    DWORD dwCount;
    bool bReturn = false;


    if (WTSEnumerateSessions(
        WTS_CURRENT_SERVER_HANDLE,
        0,
        1,
        &pWtsSessionInfo,
        &dwCount
         ))
    {
        for (DWORD i = 0; i < dwCount; i++)
        {
            if (pWtsSessionInfo[i].State == WTSListen)
            {
                bReturn = true;
                break;
            }
        }

        WTSFreeMemory(pWtsSessionInfo);
    }
    else
    {
        return FALSE;
    }

    return bReturn;
}

BOOL AreRemoteLogonEnabled ()
{
	CRegistry oRegTermsrv;
	if (ERROR_SUCCESS == oRegTermsrv.OpenKey(
								HKEY_LOCAL_MACHINE,
								_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
								KEY_READ
								))
	{
		DWORD dwSize = 0;
		LPTSTR szWinstationDisabled = NULL;
		if (ERROR_SUCCESS == oRegTermsrv.ReadRegString(_T("WinStationsDisabled"), &szWinstationDisabled, &dwSize))
		{
			if (_tcscmp(_T("0"), szWinstationDisabled) != 0)
			{
                return FALSE;
			}
		}
	}

    return TRUE;

}

#define  DOMAIN_LENGTH 17
#define  USERNAME_LENGTH 20


int
#if !defined(_MIPS_) && !defined(_ALPHA_) && !defined(_PPC_)
_cdecl
#endif
main( int  argc , char ** /* argv */)
{
    typedef BOOL    (PFN_BOOL)(void);
    typedef TCHAR * (PFN_TestSubjective)(void);


    USES_CONVERSION;

    struct TVerificationTest
    {
        char szTestName[256];                   // descriptive name of the test
        PFN_BOOL           *pfnNeedRunTest;     // pointer to function that will be called to decide if the test need run, test is run if NULL.
        PFN_TestSubjective *pfnSubTest;         // pointer to function if the test returns TCHAR *
        PFN_BOOL           *pfnObjTest;         // pointer to function if the test returns BOOL
    }
    theTests[] =
    {
        {"Machine Name...............................", NULL, GetCompName, NULL},
        {"Domain Name................................", NULL, GetDomName, NULL},
        {"Site Name..................................", NULL, GetSiteName, NULL},
        {"IP Address.................................", NULL, GetIPAddress, NULL},
        {"System Dir.................................", NULL, SystemDirectory, NULL},
		{"ProductType................................", NULL, GetProductType, NULL},
		{"ProductSuite...............................", NULL, GetProductSuite, NULL},
		{"TS Version.................................", NULL, GetTSVersion, NULL},
        {"Is this a server machine?..................", NULL, IsServer, NULL},
        {"Is tsoc.log Present?.......................", NULL, NULL, IsTSOClogPresent},
        {"Did TsOC get CompleteInstallationMessage...", NULL, NULL, DidTsOCgetCompleteInstallationMessage},
        {"Does ProductSuite Contain TS?..............", IsItServer, NULL, DoesProductSuiteContainTS},
        {"Did OCM Install TSEnable...................", IsIt50TS, NULL, DidOCMInstallTSEnable},
        {"Is TSEnabled registry alright?.............", NULL, NULL, TSEnabled},
        {"Is Kernel TSEnabled?.......................", IsItServer, NULL, IsKernelTSEnable},
        {"Is Terminal Server Registry Ok?............", NULL, NULL, IsTerminalServerRegistryOk},
        {"GetWinstationList..........................", NULL, GetWinstationList, NULL},
        {"Is TermServ Start Bit Ok?..................", NULL, IsTerminalServiceStartBitSet, NULL},
        {"Is TermServ service running?...............", NULL, NULL, IsTerminalServiceRunning},
        {"Termsrv Service Command....................", NULL, TermSrvCommandLine, NULL},
        {"Is Listner session Present ?...............", IsTerminalServiceRunning, NULL, IsListenerSessionPresent},
        {"Is TermSrv in System Context?..............", NULL, NULL, IsTermSrvInSystemContext},
        {"AreEffectiveConnectionAllowed..............", IsIt51TS, AreEffectiveConnectionAllowed, NULL },
        {"Are Connections Allowed?...................", IsIt51TS, AreConnectionsAllowed, NULL},
        {"Are Remote Logons allowed by winlogon?.....", NULL, NULL, AreRemoteLogonEnabled},
        {"Is RdpDr Installed Properly?...............", NULL, NULL, IsRdpDrInstalledProperly},
		{"Is RdpNP in NetProviders?..................", IsIt51TS, IsRDPNPinNetProviders, NULL},
		{"Are Multipal Connections Allowed...........", IsIt51TS, IsMultiConnectionAllowed, NULL},
        {"Are Video keys setup right?................", NULL, NULL, CheckVideoKeys},
        {"What mode is Terminal Server set in?.......", NULL, GetTSMode, NULL},
//        {"Is mode specific registry ok?..............", NULL, NULL, VerifyModeRegistry},
        {"What is permission Mode set to?............", NULL, GetModePermissions, NULL},
        {"Check termdd signature.....................", NULL, NULL, Check_termdd},
        {"Check tdpipe signature.....................", NULL, NULL, Check_tdpipe},
        {"Check tdtcp signature......................", NULL, NULL, Check_tdtcp},
        {"Check rdpwd signature......................", NULL, NULL, Check_rdpwd},
        {"Check rdpdd signature......................", NULL, NULL, Check_rdpdd},
        {"Check rdpwsx signature.....................", NULL, NULL, Check_rdpwsx},
        {"Is it 56 bit or 128?.......................", NULL, GetCypherStrenthOnRdpwd, NULL},
        {"Is this a Beta System?.....................", NULL, IsBetaSystem, NULL},
        {"Has Licence GracePeriod Expired............", NULL, IsLicenceGracePeriodOk, NULL},
        {"Audio test.................................", IsIt51TS, NULL, IsAudioOk}
    };

    BOOL bEverythingOk = TRUE;
    for (int i=0; i < sizeof(theTests)/sizeof(theTests[0]); i++)
    {
        ASSERT(theTests[i].pfnObjTest || theTests[i].pfnSubTest);
        ASSERT(!(theTests[i].pfnObjTest && theTests[i].pfnSubTest));

        if (theTests[i].pfnNeedRunTest && !(*(theTests[i].pfnNeedRunTest))())
        {
            // we asre asked to skip the test.
            cout << theTests[i].szTestName << "Skipped Test" << endl;
        }
        else
        {
            if (theTests[i].pfnObjTest)
            {
                BOOL bResult = (*(theTests[i].pfnObjTest))();
                cout << theTests[i].szTestName <<  (bResult ? "Passed" : "Failed") << endl;
                if (!bResult)
                    bEverythingOk = FALSE;

            }
            else
            {
                char *szStr = T2A((*(theTests[i].pfnSubTest))());
                if (szStr)
                {
                    cout << theTests[i].szTestName << szStr  << endl;
                }
            }
        }


        //
        // if previous test had any details to tell us
        //

        if (szMoreInfo.pcount())
        {
            char *pStr = szMoreInfo.str();
            cout << "   Details:" << pStr;
            cout << "------------------------------------------------" << endl;

            bEverythingOk = FALSE;
            ZeroMemory(pStr, 512);
            szMoreInfo.seekp(ios::beg);

        }



    }

    cout << endl;



    if (argc == 1 ) // if some argumnent is provided skip these time consuming test.
    {

        cout << "Enumerating Licensing Servers (May take some time)...";
        cout.flush();

        if(!IsRemoteAdminMode())
        {
            if (EnumerateLicenseServers())
            {
                    cout << ".....Passed, Found Some!" << endl;

            }
            else
            {
                cout << ".....Failed. No License Server Found." << endl;
            }
        }
        else
        {
            cout << "No License servers applicable in Remote Admin mode...";   
        }

        cout << "Extracting Related Events from Event Log...";
        cout.flush();
        if (ExtractAllTSEvents())
        {
                cout << ".....Found Some. See if they give any clue." << endl;

        }
        else
        {
            cout << ".....Found None." << endl;
        }


    }



    cout << endl;
    if (bEverythingOk)
    {
        cout << endl;
        cout << "**************************************************************" << endl;
        cout << "*** Nothing wrong with TS could detected by this utility.  ***" << endl;
        cout << "*** If you think something is wrong contact the developer. ***" << endl;
        cout << "**************************************************************" << endl;
        return 0;

    }

    return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tstst\event.cpp ===
#include "stdafx.h"
// #include "winbase.h"

#define MAX_INSERT_STRS     5

TCHAR *aszTSEventSources[] = { _T("TermService"), _T("TermDD"), _T("TermServDevices") };

BOOL ExtractEvents();
BOOL ExtractAllTSEvents()
{
    cout << endl;
    return ExtractEvents ();
}

BOOL ExtractEvents ()
{
    USES_CONVERSION;
    BOOL bFoundEvents = FALSE;



    HANDLE hEventLog = OpenEventLog(NULL, _T("System"));
    if (hEventLog)
    {

        const DWORD dwBytesToRead =  1024*10;

        char *pBuff = new char[dwBytesToRead];
        if (pBuff)
        {
            DWORD dwBytesRead, dwBytesNeeded;

            while (ReadEventLog(hEventLog,
                        EVENTLOG_BACKWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                        0,
                        PVOID(pBuff),
                        dwBytesToRead,
                        &dwBytesRead,
                        &dwBytesNeeded))
            {
                if (dwBytesRead == 0)
                    break;

                for (PEVENTLOGRECORD pEventLogRecord = ( PEVENTLOGRECORD ) pBuff;
                    PCHAR(pEventLogRecord) + pEventLogRecord->Length < pBuff + dwBytesRead;
                    pEventLogRecord = (EVENTLOGRECORD *)(PCHAR(pEventLogRecord) + pEventLogRecord->Length)
                    )
                {
                    LPCTSTR szSource = LPCTSTR(PBYTE(pEventLogRecord) + sizeof(EVENTLOGRECORD));


                    //
                    // check if event source is among interesting ones.
                    //

                    LPCTSTR szEventSource = NULL;
                    for (int i = 0; i < (sizeof(aszTSEventSources) / sizeof(aszTSEventSources[0])); i++)
                    {
                        if (_tcsicmp(szSource, aszTSEventSources[i]) == 0)
                            szEventSource = aszTSEventSources[i];
                    }

                    if (!szEventSource)
                        continue;


                    //
                    // prepare the array of insert strings for FormatMessage - the
                    // insert strings are in the log entry.
                    //
                    char *aInsertStrings[MAX_INSERT_STRS];

                    char *p = (char *) ((LPBYTE) pEventLogRecord + pEventLogRecord->StringOffset);
                    for (i = 0; i < pEventLogRecord->NumStrings && i < MAX_INSERT_STRS; i++)
                    {
                        aInsertStrings[i] = p;
                        p += strlen(p) + 1;     // point to next string
                    }



                    //
                    // Get the binaries to look message in from registry.
                    //

                    TCHAR szSourceKey[1024];
                    _tcscpy(szSourceKey, _T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\"));
                    _tcscat(szSourceKey, szEventSource);

                    CRegistry oReg;
                    TCHAR szSourcePath[MAX_PATH];

                    if (oReg.OpenKey(HKEY_LOCAL_MACHINE, szSourceKey, KEY_READ) == ERROR_SUCCESS)
                    {
                        LPTSTR str;
                        DWORD dwSize;
                        if (ERROR_SUCCESS == oReg.ReadRegString(_T("EventMessageFile"), &str, &dwSize))
                        {

                            ExpandEnvironmentStrings(str, szSourcePath, MAX_PATH);
                        }
                        else
                        {
                            cout << "       Error Reading Registry (" << T2A(szSourceKey) << ")/(EventMessageFiles)" << endl;
                            continue;
                        }

                    }
                    else
                    {
                        cout << "       Error Reading Registry (" << T2A(szSourceKey) << endl;
                        continue;
                    }

                    //
                    // Binary String in registry could contain multipal binaries seperated by ;
                    //

                    TCHAR *szModule;
                    szModule = _tcstok(szSourcePath, _T(";"));

                    //
                    // for each binary found
                    //

                    DWORD dwBytesTransfered = 0;
                    do
                    {
                        HINSTANCE hModule = LoadLibrary(szModule);

                        TCHAR szMessage[1024];
                        dwBytesTransfered = FormatMessage(
                                            FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                            hModule,
                                            pEventLogRecord->EventID,
                                            0,
                                            szMessage,
                                            1024,
					    (va_list *)aInsertStrings);

                        if (dwBytesTransfered)
                        {
                            bFoundEvents = TRUE;
                            TCHAR szTimeString[512];
                            time_t timeGenerated = pEventLogRecord->TimeGenerated;
                            _tcsftime(szTimeString, 512, _T("%c"), localtime( (const time_t *)&timeGenerated ));
                            cout <<  "       " << T2A(szTimeString) << ": ( " << T2A(szEventSource) << " ) : " << T2A(szMessage);
                        }
                        else
                        {
                            cout << "       FormatMessage Failed. lasterror = " << GetLastError() << endl;
                        }

                        szModule = _tcstok(NULL, _T(";"));

                    }
                    while (!dwBytesTransfered && szModule);

                }


            }

        }

    }
    else
    {
        cout << "       Failed to Open Event log." << endl;
        return FALSE;
    }

    return bFoundEvents;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tstst\tscert.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

#include "stdafx.h"

#define MemAlloc malloc // for certfy.inc
#define MemFree free

#include "../../tscert/inc/pubblob.h"    // needed by certvfy.inc
#include "../../tscert/inc/certvfy.inc"  // VerifyFile()


BOOL FileExists (char *pszFullNameAndPath); // from tstst.cpp

BOOL CheckifBinaryisSigned(TCHAR *szFile)
{
    USES_CONVERSION;
    TCHAR szFullFile[MAX_PATH +1];
    RTL_CRITICAL_SECTION VfyLock;

    if (ExpandEnvironmentStrings(szFile, szFullFile, MAX_PATH))
    {
        if (FileExists(T2A(szFullFile)))
        {
            RtlInitializeCriticalSection( &VfyLock );

            if ( VerifyFile( T2W(szFullFile), &VfyLock ) )
            {
                return TRUE;
            }
        }

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tstst\stdafx.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Module Name:
 *
 *      hydraoc.h
 *
 *  Abstract:
 *
 *      Common Header file for the HydraOC Component.
 *      HydraOc Component is an optional component which installs Termainal Server (Hydra)
 *
 *  Author:
 *
 *
 *  Environment:
 *
 *    User Mode
 */

#ifndef _stdafx_h_
#define _stdafx_h_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <devguid.h>
#include <initguid.h>
#include <objbase.h>
#include <tchar.h>
#include <time.h>
#include <stdio.h>
#include <setupapi.h>
#include <prsht.h>
#include <loadperf.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commdlg.h>
#include <lm.h>
#include <lmerr.h>
#include <lmserver.h>
#include <iostream.h>
#include <fstream.h>
#include <stdlib.h>
#include <string.h>
#include <clusapi.h>        // for GetNodeClusterState
#include <malloc.h>
#include <stddef.h>
#include <wincrypt.h>
#include <imagehlp.h>





#include "conv.h"
#include "Registry.h"       // CRegistry

#define AssertFalse() ASSERT(FALSE)
#define VERIFY(x)     RTL_VERIFY(x)

#endif // _stdafx_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tstst\timebomb.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include "license.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "secstore.h"
#include "..\conv.h"

#define LICENSING_TIME_BOMB L"TIMEBOMB_832cc540-3244-11d2-b416-00c04fa30cc4"
#define RTMLICENSING_TIME_BOMB L"RTMTSTB_832cc540-3244-11d2-b416-00c04fa30cc4"

#define LICENSING_TIME_BOMB_5_0 L"TIMEBOMB_832cc540-3244-11d2-b416-00c04fa30cc4"
#define RTMLICENSING_TIME_BOMB_5_0 L"RTMTSTB_832cc540-3244-11d2-b416-00c04fa30cc4"

// L$ means only readable from the local machine

#define BETA_LICENSING_TIME_BOMB_5_1 L"L$BETA3TIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define RTM_LICENSING_TIME_BOMB_5_1 L"L$RTMTIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define BETA_LICENSING_TIME_BOMB_LATEST_VERSION BETA_LICENSING_TIME_BOMB_5_1

#define RTM_LICENSING_TIME_BOMB_LATEST_VERSION RTM_LICENSING_TIME_BOMB_5_1

#define X509_CERT_PRIVATE_KEY_NAME \
    L"L$HYDRAENCKEY_dd2d98db-2316-11d2-b414-00c04fa30cc4"

///////////////////////////////////////////////////////////////////

typedef BOOL
(* TLSISBETANTSERVER)();

BOOL FIsBetaSystem ()
{
    HMODULE hmodTlsAPI = LoadLibrary( _T("mstlsapi.dll") );

    if (hmodTlsAPI)
    {
        TLSISBETANTSERVER pfnTLSIsBetaNTServer;
        BOOL fBeta = FALSE;
        
        pfnTLSIsBetaNTServer = (TLSISBETANTSERVER) GetProcAddress(hmodTlsAPI,"TLSIsBetaNTServer");

        if (NULL != pfnTLSIsBetaNTServer)
        {
            fBeta = pfnTLSIsBetaNTServer();
        }

        FreeLibrary(hmodTlsAPI);

        return fBeta;
    }
    else
    {
        return FALSE;
    }
}

TCHAR *IsBetaSystem ()
{
    return (FIsBetaSystem() ? _T("Its Beta") : _T("Its RTM"));
}

BOOL HasLicenceGracePeriodExpired ()
{
    DWORD status;
    DWORD  cbByte;
    PBYTE  pbByte = NULL;
    LPWSTR szTimeBombKey;
    FILETIME timebomb;
    FILETIME filetimeCurrent;
    DWORD dwVersion;

    dwVersion = GetVersion();

    if ((dwVersion & 0x80000000)
        || (LOBYTE(LOWORD(dwVersion)) <= 4))
    {
        cout << endl << "       Pre-Windows 2000.  No grace period" << endl;
        return FALSE;
    }
    else if ((LOBYTE(LOWORD(dwVersion)) == 5)
             && (HIBYTE(LOWORD(dwVersion)) == 0))
    {
        // Windows 2000

        if (FIsBetaSystem())
            szTimeBombKey = LICENSING_TIME_BOMB_5_0;
        else
            szTimeBombKey = RTMLICENSING_TIME_BOMB_5_0;
    }
    else if ((LOBYTE(LOWORD(dwVersion)) == 5)
             && (HIBYTE(LOWORD(dwVersion)) == 1))
    {
        // Whistler

        if (FIsBetaSystem())
            szTimeBombKey = BETA_LICENSING_TIME_BOMB_5_1;
        else
            szTimeBombKey = RTM_LICENSING_TIME_BOMB_5_1;
    }
    else
    {
        cout << endl << "       Unknown OS.  Assume no grace period" << endl;
        return FALSE;
    }

    status = RetrieveKey(
                         szTimeBombKey,
                         &pbByte,
                         &cbByte
                         );


    if(status == ERROR_SUCCESS && pbByte)
    {
        timebomb = *(FILETIME *)pbByte;


        GetSystemTimeAsFileTime(&filetimeCurrent);

        // yes license has expired if filetimeCurrent >= timebomb

        return (CompareFileTime(&timebomb, &filetimeCurrent) < 1);

    }
    else
    {
        // It hasn't been set yet, so we're not expired

        return FALSE;
    }
}

static gdwCount = 0;

BOOL ServerEnumCallBack(
    IN TLS_HANDLE hHandle,
    IN LPCTSTR pszServerName,
    IN HANDLE /* dwUserData */)
{
    USES_CONVERSION;

    if (hHandle)
    {
        cout << endl << "       Found #" << ++gdwCount << ":"<< T2A(pszServerName);
    }


    return 0;
}



typedef HANDLE
(* TLSCONNECTTOANYLSSERVER)(  
    DWORD dwTimeOut
);

typedef DWORD 
(* ENUMERATETLSSERVERNEW)(  
    TLSENUMERATECALLBACK fCallBack, 
    HANDLE dwUserData,
    DWORD dwTimeOut,
    BOOL fRegOnly
);


typedef DWORD 
(* ENUMERATETLSSERVEROLD)(  
    LPCTSTR szDomain,
    LPCTSTR szScope, 
    DWORD dwPlatformType, 
    TLSENUMERATECALLBACK fCallBack, 
    HANDLE dwUserData,
    DWORD dwTimeOut,
    BOOL fRegOnly
);

BOOL EnumerateLicenseServers ()
{
    HMODULE hmodTlsAPI = LoadLibrary( _T("mstlsapi.dll") );

    if (hmodTlsAPI)
    {
        DWORD dwResult;

        // load TLSShutdown to see if we have the new APIs
        if (NULL == GetProcAddress(hmodTlsAPI,"TLSShutdown"))
        {
            ENUMERATETLSSERVEROLD pfnEnumerateTlsServer;

            pfnEnumerateTlsServer = (ENUMERATETLSSERVEROLD) GetProcAddress(hmodTlsAPI,"EnumerateTlsServer");

            if (NULL != pfnEnumerateTlsServer)
            {

                dwResult = pfnEnumerateTlsServer(
                            NULL,
                            NULL,
                            LSKEYPACKPLATFORMTYPE_UNKNOWN,
                            ServerEnumCallBack,
                            0,
                            0,
                            FALSE);
            }
            else
            {
                cout << endl << "       Failed to GetProcAddress,ErrorCode = " << GetLastError() << endl;

                return FALSE;
            }
        }
        else
        {
            if (NULL != GetProcAddress(hmodTlsAPI,"TLSGetSupportFlags"))
            {
                // Use newer discovery function

                TLSCONNECTTOANYLSSERVER pfnTLSConnectToAnyLsServer;
                TLS_HANDLE hServer;

                pfnTLSConnectToAnyLsServer = (TLSCONNECTTOANYLSSERVER) GetProcAddress(hmodTlsAPI,"TLSConnectToAnyLsServer");

                if (NULL != pfnTLSConnectToAnyLsServer)
                {
                    hServer = pfnTLSConnectToAnyLsServer(INFINITE);

                    if (NULL != hServer)
                    {
                        return TRUE;
                    }
                    else
                    {
                        return FALSE;
                    }
                }
                else
                {
                    cout << endl << "       Failed to GetProcAddress TLSConnectToAnyLsServer,ErrorCode = " << GetLastError() << endl;
                    
                    return FALSE;
                }
            }
            else
            {
                ENUMERATETLSSERVERNEW pfnEnumerateTlsServer;

                pfnEnumerateTlsServer = (ENUMERATETLSSERVERNEW) GetProcAddress(hmodTlsAPI,"EnumerateTlsServer");

                if (NULL != pfnEnumerateTlsServer)
                {
                    dwResult = pfnEnumerateTlsServer(
                                                     ServerEnumCallBack,
                                                     0,
                                                     0,
                                                     FALSE);
                }
                else
                {
                    cout << endl << "       Failed to GetProcAddress,ErrorCode = " << GetLastError() << endl;
                    
                    return FALSE;
                }
            }
        }
        
        FreeLibrary(hmodTlsAPI);
        
        if (dwResult != NO_ERROR)
            cout << endl << "       Failed to EnumerateTlsServer,ErrorCode = " << dwResult << endl;


        if (gdwCount > 0)
            cout << endl;

        return gdwCount > 0;

    }
    else
    {
        cout << endl << "       Failed to load mstlsapi.dll,ErrorCode = " << GetLastError() << endl;

        return FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\cpmutil.c ===
/*************************************************************************
*
* cpmutil.c
*
* System Library Client Printer functions
*
*  These functions tend to be includes in the spooler, printman,
*  and various port monitor DLL's. So they are here for common code.
*
* Copyright Microsoft, 1998
*
*
*
*
*************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "winsta.h"
#include "syslib.h"

#if DBG
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*****************************************************************************
 *
 *  IsClientPrinterPort
 *
 *   Return whether the name is a client printer port
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
IsClientPrinterPort(
    PWCHAR pName
    )
{
    BOOL Result;
    PORTNAMETYPE Type;

    //
    // This just does a brute force compare
    //
    if( pName == NULL ) {
        return( FALSE );
    }

    if( _wcsicmp( L"Client\\LPT1:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\LPT2:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\LPT3:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\LPT4:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\COM1:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\COM2:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\COM3:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\COM4:", pName ) == 0 ) {
        return( TRUE );
    }

    //
    // See if its a specific port
    //
    Result = ParseDynamicPortName(
                 pName,
                 NULL,
                 NULL,
                 &Type
                 );

    if( Type != PortNameUnknown ) {
        return( TRUE );
    }

    return( FALSE );
}

/*****************************************************************************
 *
 *  ExtractDosNamePtr
 *
 *   Extract the DOS name from a client port string.
 *
 *   Returns a pointer to the DOS name which is contained within
 *   the argument string.
 *
 *   Does not modify the argument string.
 *
 * ENTRY:
 *   pName (input)
 *     Input name string
 *
 * EXIT:
 *   NULL: No DOS name
 *   !=NULL Pointer to DOS name
 *
 ****************************************************************************/

PWCHAR
ExtractDosNamePtr(
    PWCHAR pName
    )
{
    PWCHAR this, prev;
    LPWSTR Ptr;
    ULONG Len, i, Count;
    WCHAR NameBuf[USERNAME_LENGTH+9];

    if( pName == NULL ) {
        return NULL;
    }

    // Make sure it starts with "Client\"
    if( _wcsnicmp( pName, L"Client\\", 7 ) != 0 ) {
        return NULL;
    }

    // Count the '\'s
    prev = pName;
    Count = 0;
    while( 1 ) {
        this = wcschr( prev, L'\\' );
        if( this == NULL ) {
            break;
        }
        // Now we must skip over the '\' character
        this++;
        Count++;
        prev = this;
    }

    if( Count == 0 ) {
        DBGPRINT(("ExtractDosNamePtr: Bad Dynamic name format No separators :%ws:\n",pName));
        return NULL;
    }

    //
    // Might be Client\LPTx:
    //
    // NOTE: Windows printers currently do not support
    //       a generic name.
    //
    if( Count == 1 ) {

        Len = wcslen( pName );
        if( Len < 11 ) {
            DBGPRINT(("ExtractDosNamePtr: Bad Dynamic name format Len < 11 :%ws:\n",pName));
            return NULL;
        }

        // Skip over "Client\"
        Ptr = pName + 7;

        return( Ptr );
    }

    // Skip over "Client\"
    Ptr = pName + 7;

    //
    // Here we must skip over the ICAName# or WinStationName
    //
    while( *Ptr ) {

        if( *Ptr == '\\' ) {
            break;
        }
        Ptr++;
    }

    //
    // Ptr now points to the '\\' after the
    // WinStation or ICA name. After this slash,
    // is the rest of the printer or port name.
    //
    Ptr++;

    return( Ptr );
}

/*****************************************************************************
 *
 *  ExtractDosName
 *
 *   Extract the DOS name from a client port string.
 *
 *   Returns the DOS name which is in a newly allocated string.
 *
 *   Does not modify the argument string.
 *
 * ENTRY:
 *   pName (input)
 *     Input name string
 *
 * EXIT:
 *   NULL: No DOS name
 *   !=NULL Pointer to DOS name
 *
 ****************************************************************************/

PWCHAR
ExtractDosName(
    PWCHAR pName
    )
{
    PWCHAR Ptr;
    PWCHAR pNewName = NULL;

    Ptr = ExtractDosNamePtr( pName );
    if( Ptr == NULL ) return NULL;

    pNewName = RtlAllocateHeap( RtlProcessHeap(), 0, (wcslen( Ptr )+1)*sizeof(WCHAR) );
    if( pNewName == NULL ) return NULL;

    wcscpy( pNewName, Ptr );

    return( pNewName );
}

/*****************************************************************************
 *
 *  ParseDynamicPortName
 *
 *   Parse a dynamic port name into its components.
 *   (NOTE: This is also in \nt\private\windows\spooler\localspl\citrix\cpmsup.c)
 *
 *   A dynamic port name is of the form:
 *
 *   Client\WinStationName\LPTx:,    where WinStationName is the hardwire name
 *   Client\ICAName#\LPTx:,          where ICAName is the ICA configured client name
 *   Client\LPTx:
 *   Client\IcaName#\Windows_Printer_Name
 *                                   where Windows_Printer_Name is
 *                                   the remote windows client print
 *                                   manager printer name.
 *
 *   Client\IcaName#\\\ntbuild\print1
 *                                   where Windows_Printer_Name is
 *                                   the remote windows client print
 *                                   manager printer name.
 *
 * ENTRY:
 *   pName (input)
 *     Name to be parsed
 *
 * EXIT:
 *   TRUE  - Name parsed successfully
 *   FALSE - Name is incorrect.
 *
 ****************************************************************************/

BOOL
ParseDynamicPortName(
    LPWSTR pName,
    LPWSTR pUser,
    LPWSTR pDosPort,
    PORTNAMETYPE *pType
    )
{
    PWCHAR this, prev;
    LPWSTR Ptr;
    ULONG Len, i, Count;
    WCHAR NameBuf[USERNAME_LENGTH+9];

    if( pName == NULL ) {
        *pType = PortNameUnknown;
        return(FALSE);
    }

    // Make sure it starts with "Client\"
    if( _wcsnicmp( pName, L"Client\\", 7 ) != 0 ) {
        *pType = PortNameUnknown;
        return(FALSE);
    }

    // Count the '\'s
    prev = pName;
    Count = 0;
    while( 1 ) {
        this = wcschr( prev, L'\\' );
        if( this == NULL ) {
            break;
        }
        // Now we must skip over the '\' character
        this++;
        Count++;
        prev = this;
    }

    if( Count == 0 ) {
        DBGPRINT(("ParseDynamicName: Bad Dynamic name format No separators :%ws:\n",pName));
        *pType = PortNameUnknown;
        return(FALSE);
    }

    //
    // Might be Client\LPTx:
    //
    // NOTE: Windows printers currently do not support
    //       a generic name.
    //
    if( Count == 1 ) {

        Len = wcslen( pName );
        if( Len < 11 ) {
            *pType = PortNameUnknown;
            DBGPRINT(("ParseDynamicName: Bad Dynamic name format Len < 11 :%ws:\n",pName));
            return(FALSE);
        }

        // Skip over "Client\"
        Ptr = pName + 7;

        if( !((_wcsnicmp( Ptr, L"LPT", 3 ) == 0)
                 ||
            (_wcsnicmp( Ptr, L"COM", 3 ) == 0)
                 ||
            (_wcsnicmp( Ptr, L"AUX", 3 ) == 0)) ) {

            *pType = PortNameUnknown;
            DBGPRINT(("ParseDynamicName: Bad Dynamic name format Not LPT!COM!AUX :%ws:\n",pName));
            return(FALSE);
        }

        // Range check the number
        if( (Ptr[3] < L'1') || (Ptr[3] > L'4') ) {
            *pType = PortNameUnknown;
            DBGPRINT(("ParseDynamicName: Bad Dynamic name format Number Range:%ws:\n",pName));
            return(FALSE);
        }

        Ptr = ExtractDosNamePtr( pName );
        if( Ptr == NULL ) {
            // Bad Dos component
            *pType = PortNameUnknown;
            DBGPRINT(("ParseDynamicName: Bad Dynamic name format DosName :%ws:\n",pName));
            return(FALSE);
        }

        // Copy out the Dos name
        if( pDosPort )
            wcscpy( pDosPort, Ptr );

        // Set the rest of the flags
        if( pUser )
            pUser[0] = 0;

        *pType = PortNameGeneric;

        return(TRUE);
    }

#ifdef notdef
    //
    // The rest of the formats have two '\'s
    //
    if( Count != 2 ) {
        DBGPRINT(("ParseDynamicName: Bad Dynamic name format Must be 2 :%ws:\n",pName));
        *pType = PortNameUnknown;
        return(FALSE);
    }

    // Get the Dos Name, which could also be a Windows printer name
    Ptr = ExtractDosNamePtr( pName );
    if( Ptr == NULL ) {
        // Bad Dos component
        *pType = PortNameUnknown;
        return(FALSE);
    }

    // Copy out the Dos name
    if( pDosPort )
        wcscpy( pDosPort, Ptr );
#endif

    // Skip over "Client\"
    Ptr = pName + 7;

    //
    // Now copy the ICAName#, or WinStationName to a local
    // buffer for further processing

    i = 0;
    NameBuf[i] = 0;

    while( *Ptr ) {

        if( *Ptr == '\\' ) {
            NameBuf[i] = 0;
            break;
        }
        NameBuf[i] = *Ptr;
        Ptr++;
        i++;
    }

    //
    // Ptr now points to the '\\' after the
    // WinStation or ICA name. After this slash,
    // is the rest of the printer or port name.
    //
    Ptr++;

    // Copy out the Dos name
    if( pDosPort )
        wcscpy( pDosPort, Ptr );

    //
    // See if this is an ICA name, or a WinStation name
    //
    Ptr = wcschr( NameBuf, L'#' );
    if( Ptr != NULL ) {

        // NULL terminate the ICAName and copy it out
        *Ptr = (WCHAR)NULL;
        if( pUser )
            wcscpy( pUser, NameBuf );

        // Set the type to an ICA named roving WinStation
        *pType = PortNameICA;
    }
    else {

        //
        // The name will be treated as a WinStation name
        //
        if( pUser )
            wcscpy( pUser, NameBuf );

        *pType = PortNameHardWire;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\data.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "security.h"

/*
 * List of accounts we allow file access for
 */

ADMIN_ACCOUNTS AllowAccounts[] = {
    { L"Administrators", NULL },
    { L"SYSTEM",         NULL },
    { CURRENT_USER,      NULL }
};

DWORD AllowAccountEntries = sizeof(AllowAccounts)/sizeof(ADMIN_ACCOUNTS);

ACCESS_MASK AllowAccess = STANDARD_RIGHTS_ALL | FILE_ALL_ACCESS;

/*
 * List of accounts to deny file access for
 */

ADMIN_ACCOUNTS DenyAccounts[] = {
    { L"", NULL }
};

DWORD DenyAccountEntries = 0;

ACCESS_MASK DeniedAccess = STANDARD_RIGHTS_ALL | FILE_ALL_ACCESS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\deldir.c ===
/*************************************************************************
*
* deldir.c
*
* Functions to delete all the files and subdirectories under a given
* directory (similar to rm -rf).
*
* Copyright Microsoft, 1998
*
*
*************************************************************************/

/* include files */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "winsta.h"
#include "syslib.h"

#if DBG
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*
 * Data Structure
 */
typedef struct dirent {
    ULONG  d_attr;                      /* file attributes */
    WCHAR  d_name[MAX_PATH+1];          /* file name */
    WCHAR  d_first;
    HANDLE d_handle;
} DIR, *PDIR;


/*
 * procedure prototypes
 */
void remove_file( PWCHAR, ULONG );
PDIR opendir( PWCHAR );
PDIR readdir( PDIR );
int closedir( PDIR );
BOOL QueryFlatTempKey( VOID );
BOOLEAN SetFileTree( PWCHAR pRoot, PWCHAR pAvoidDir );


/*****************************************************************************
 *
 *  RemoveDir
 *
 *  Delete the given subdirectory and all files and subdirectories within it.
 *
 * ENTRY:
 *   PWCHAR (In) dirname - directory to delete
 *
 * EXIT:
 *   SUCCESS: TRUE
 *   FAILURE: FALSE
 *
 ****************************************************************************/
BOOL RemoveDir(PWCHAR dirname)
{
   DIR    *dirp, *direntp;
   PWCHAR pathname = NULL;
   ULONG  pathlen;
   PWCHAR namep;
   ULONG  ulattr;

   if ((dirp = opendir(dirname)) == NULL) {
      return(FALSE);
   }

   // Allocate space for the path name. Add extra bytes for the subdirectory or file names.
   pathlen = ( wcslen( dirname ) + 4 + MAX_PATH ) * sizeof( WCHAR ) ;
   pathname = RtlAllocateHeap( RtlProcessHeap(), 0, pathlen );
   if ( pathname == NULL) {
       return FALSE;
   }

   memset( pathname, 0, pathlen );

   wcscpy( pathname, dirname );
   if ( pathname[wcslen(pathname)-1] != L'\\' &&
        pathname[wcslen(pathname)-1] != L'/' )
      wcscat( pathname, L"\\" );
   namep = pathname + wcslen(pathname);

   while ( direntp = readdir( dirp ) ) {
      if ( wcscmp( direntp->d_name, L"." ) &&
           wcscmp( direntp->d_name, L".." ) ) {
         wcscpy( namep, direntp->d_name );
         if ( direntp->d_attr & FILE_ATTRIBUTE_DIRECTORY ) {
            RemoveDir( pathname );
         } else {
            remove_file( pathname, direntp->d_attr );
         }
      }
   }

   closedir( dirp );
   RtlFreeHeap( RtlProcessHeap(), 0, pathname );

   /*
    * If directory is read-only, make it writable before trying to remove it
    */
   ulattr = GetFileAttributes(dirname);
   if ((ulattr != 0xffffffff) &&
       (ulattr & FILE_ATTRIBUTE_READONLY)) {
      SetFileAttributes(dirname, (ulattr & ~FILE_ATTRIBUTE_READONLY));
   }
   if (!RemoveDirectory(dirname)) {
      DBGPRINT(("RemoveDir: unable to remove directory=%ws\n", dirname));
      if (ulattr & FILE_ATTRIBUTE_READONLY) {           // set back to readonly
         SetFileAttributes(dirname, ulattr);
      }
   }
   return(TRUE);
}


/*****************************************************************************
 *
 *  remove_file
 *
 *  Delete the given file.
 *
 * ENTRY:
 *   PWCHAR (In) fname - file to delete
 *   ULONG  (In) attr  - attributes of file to delete
 *
 * EXIT:
 *   void
 *
 ****************************************************************************/
void remove_file(PWCHAR fname, ULONG attr)
{
   /*
    * If file is read-only, then make it writable before trying to remove it
    */
   if (attr & FILE_ATTRIBUTE_READONLY) {
      if (!SetFileAttributes(fname, (attr & ~FILE_ATTRIBUTE_READONLY))) {
         DBGPRINT(("remove_file: unable to remove file=%ws\n", fname));
         return;
      }
   }

   /*
    * remove the file
    */
   if (!DeleteFile(fname)) {
      if (!(attr & FILE_ATTRIBUTE_READONLY)) {  // if file was read-only,
         DBGPRINT(("remove_file: unable to remove file=%ws\n", fname));
         SetFileAttributes(fname, attr);        // then change it back
      }
   }
}


/*****************************************************************************
 *
 *  opendir
 *
 *  "Open" (FindFirstFile) the specified directory.
 *
 * ENTRY:
 *   PWCHAR (In) dirname - directory to open
 *
 * EXIT:
 *   SUCCESS:  pointer to DIR struct
 *   FAILURE:  NULL
 *
 ****************************************************************************/
PDIR opendir( PWCHAR dirname )
{
   PDIR dirp;
   unsigned count = 1;
   WIN32_FIND_DATA fileinfo;
   PWCHAR pathname = NULL;
   WCHAR sep;
   ULONG pathlen;
   unsigned rc;

   if ((dirp = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(DIR))) == NULL) {
      DBGPRINT(("opendir: unable to allocate DIR structure.\n"));
      return( NULL );
   }

   memset( dirp, 0, sizeof(DIR) );

   // Allocate space for the path name. Add extra bytes for *.*.
   pathlen = ( wcslen( dirname ) + 6 ) * sizeof( WCHAR );
   pathname = RtlAllocateHeap( RtlProcessHeap(), 0, pathlen );
   if ( pathname == NULL) {
       return NULL;
   }

   memset( pathname, 0, pathlen );

   /*
    * Build pathname to use for FindFirst call
    */
   wcscpy( pathname, dirname );
   if ( pathname[1] == L':' && pathname[2] == L'\0' )
      wcscat( pathname, L".\\*.*" );
   else if ( pathname[0] == '\0' ||
             (sep = pathname[wcslen(pathname)-1]) == L'\\' || sep == L'/' )
      wcscat( pathname, L"*.*" );
   else
      wcscat( pathname, L"\\*.*" );

   if ((dirp->d_handle =
       FindFirstFile(pathname, &fileinfo)) == INVALID_HANDLE_VALUE) {
      rc = GetLastError();
      DBGPRINT(("opendir: unable to open directory=%ws, rc=%d\n", dirname, rc));
   } else {
      rc = 0;
   }

   RtlFreeHeap( RtlProcessHeap(), 0, pathname );

   if (rc == NO_ERROR) {
      dirp->d_attr = fileinfo.dwFileAttributes;
      wcscpy(dirp->d_name, fileinfo.cFileName);
      dirp->d_first = TRUE;
      return( dirp );
   }

   if ( rc != ERROR_NO_MORE_FILES ) {
      closedir( dirp );
      return( NULL );
   }

   return( dirp );
}


/*****************************************************************************
 *
 *  readdir
 *
 *  Get the next file/directory to be deleted
 *
 * ENTRY:
 *   PDIR (In) dirp - pointer to open directory structure
 *
 * EXIT:
 *   SUCCESS:  pointer to DIR struct
 *   FAILURE:  NULL
 *
 ****************************************************************************/
PDIR readdir( PDIR dirp )
{
   WIN32_FIND_DATA fileinfo;
   unsigned count = 1;
   unsigned rc;

   if ( !dirp ) {
      return( NULL );
   }

   if ( dirp->d_first ) {
      dirp->d_first = FALSE;
      return( dirp );
   }

   if ( !(rc = FindNextFile( dirp->d_handle, &fileinfo )) ) {
      rc = GetLastError();
      DBGPRINT(("readdir: FindNextFile failed, rc=%d\n", rc));
   } else {
      rc = 0;
   }

   if ( rc == NO_ERROR ) {
      dirp->d_attr = fileinfo.dwFileAttributes;
      wcscpy(dirp->d_name, fileinfo.cFileName);
      return( dirp );
   }

   return( NULL );
}


/*****************************************************************************
 *
 *  closedir
 *
 *  Close an open directory handle
 *
 * ENTRY:
 *   PDIR (In) dirp - pointer to open directory structure
 *
 * EXIT:
 *   SUCCESS:  0
 *   FAILURE:  -1
 *
 ****************************************************************************/

int closedir( PDIR dirp )
{

   if ( !dirp ) {
      return( -1 );
   }

   FindClose( dirp->d_handle );

   RtlFreeHeap( RtlProcessHeap(), 0, dirp );

   return( 0 );
}


/*****************************************************************************
 *
 *  CtxCreateTempDir
 *
 *  Create and set the temporary environment variable for this user.
 *
 * ENTRY:
 *   PWSTR pwcEnvVar (In): Pointer to environment variable to set
 *   PWSTR pwcLogonID (In): Pointer to user's logon ID
 *   PVOID *pEnv (In): Pointer to pointer (a handle) to environment to query/set
 *   PWSTR ppTempName (Out/Optional): Pointer to location to return name
 *                                    of temp directory that was created
 *
 * EXIT:
 *   SUCCESS:  Returns TRUE
 *   FAILURE:  Returns FALSE
 *
 ****************************************************************************/

BOOL
CtxCreateTempDir( PWSTR pwcEnvVar, PWSTR pwcLogonId, PVOID *pEnv, 
                  PWSTR *ppTempName, PCTX_USER_DATA pCtxUserData )
{
    WCHAR Buffer[MAX_PATH];
    WCHAR RootPath[]=L"x:\\";
    ULONG Dtype;
    UNICODE_STRING Name, Value;
    ULONG  ulattr;
    NTSTATUS Status;
    BOOL bRC;
    HANDLE ImpersonationHandle;

    Value.Buffer = Buffer;
    Value.Length = 0;
    Value.MaximumLength = sizeof(Buffer);
    RtlInitUnicodeString(&Name, pwcEnvVar);

    //
    // Get the temp directory variable
    //
    Status = RtlQueryEnvironmentVariable_U( *pEnv, &Name, &Value );
    if ( !NT_SUCCESS(Status) )
        return( FALSE );

    //
    // If temp directory points to a network (or client) drive,
    // or is not accessible, then change it to point to the \temp
    // directory on the %SystemRoot% drive.
    //
    // Took out check for DRIVE_REMOTE, per incident 34313hq.      KLB 09-13-96
    //
    // Need to impersonate user during logon cause drive mapped under
    // impersonation.   cjc 12-18-96
    //
    RootPath[0] = Buffer[0];
    if (pCtxUserData) {
        ImpersonationHandle = CtxImpersonateUser(pCtxUserData, NULL);

        if (!ImpersonationHandle) {

            return( FALSE );
        }

    }


    Dtype = GetDriveType( RootPath );
    if (pCtxUserData) {
        CtxStopImpersonating(ImpersonationHandle);
    }
    if ( Dtype == DRIVE_NO_ROOT_DIR || Dtype == DRIVE_UNKNOWN ||
         Dtype == DRIVE_CDROM ) {
        UNICODE_STRING SystemRoot;

        RtlInitUnicodeString( &SystemRoot, L"SystemRoot" );
        Status = RtlQueryEnvironmentVariable_U( *pEnv, &SystemRoot, &Value );
        if ( !NT_SUCCESS(Status) )
            return( FALSE );
        lstrcpy( &Buffer[3], L"temp" );
    }

    //
    // See if the directory already exists and if not try to create it
    //
    ulattr = GetFileAttributesW(Buffer);
    if ( ulattr == 0xffffffff ) {
        bRC = CreateDirectory( Buffer, NULL );
        DBGPRINT(( "CreateDirectory(%ws) %s.\n", Buffer, bRC ? "successful" : "failed" ));
        if ( !bRC ) {
            return( FALSE );
        }
    }
    else if ( !(ulattr & FILE_ATTRIBUTE_DIRECTORY) ) {
        return ( FALSE );
    }

    // Append the logonid onto the temp env. variable.  We ONLY do this if the
    // registry key for "Flat Temporary Directories" is not set.  If it is,
    // then they want to put their temp directory under the user's directory,
    // and DON'T want it to be in a directory under that.  This is related to
    // incident 34313hq.                                           KLB 09-16-96
    if ( !QueryFlatTempKey() ) {
       if ( lstrlen(Buffer) + lstrlen(pwcLogonId) >= MAX_PATH ) {
           return( FALSE );
       }
       lstrcat(Buffer, L"\\");
       lstrcat(Buffer, pwcLogonId);

       //
       // See if the directory already exists and if not try to create it
       // with the new
       //
       ulattr = GetFileAttributesW(Buffer);
       if ( ulattr == 0xffffffff ) {
           bRC = CreateDirectory( Buffer, NULL );
           DBGPRINT(( "CreateDirectory(%ws) %s.\n", Buffer, bRC ? "successful" : "failed" ));
           if ( !bRC ) {
               return( FALSE );
           }
       }
       else if ( !(ulattr & FILE_ATTRIBUTE_DIRECTORY) ) {
           return ( FALSE );
       }
    }

    //
    // Need to set security on the new directory.  This is done by simply
    // calling code from JohnR's ACLSET utility that we brought over here.
    // KLB 09-25-96
    //
    SetFileTree( Buffer, NULL );

    // Must re-init Value since length of string has changed
    RtlInitUnicodeString( &Value, Buffer );
    if (*pEnv == NtCurrentPeb()->ProcessParameters->Environment) {
        RtlSetEnvironmentVariable( NULL, &Name, &Value );
        *pEnv = NtCurrentPeb()->ProcessParameters->Environment;
    }
    else {
        RtlSetEnvironmentVariable( pEnv, &Name, &Value );
        RtlSetEnvironmentVariable( NULL, &Name, &Value );
    }

    if ( ppTempName )
        *ppTempName = _wcsdup( Buffer );

    return( TRUE );
} // end of CtxCreateTempDir()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\makefile.inc ===
#
#       Do not delete this file, needed to build .lib file.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\execclt.c ===
/*************************************************************************
*
* execclt.c
*
* Exec service client.
*
* This allows the starting of a program on any CITRIX WinStation under
* the account of the logged on user, or the SYSTEM account for services.
*
* Copyright Microsoft, 1998
*
* Log:
*
*
*
*************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <lmsname.h>
#include <windows.h>
#include <stdio.h>
#include <execsrv.h>
#include <winsta.h>
#include <syslib.h>

#pragma warning (error:4312)

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


//
// Forward references
//

PWCHAR
MarshallStringW(
    PWCHAR pSource,
    PCHAR  pBase,
    ULONG  MaxSize,
    PCHAR  *ppPtr,
    PULONG pCount
    );

VOID
AnsiToUnicode(
    WCHAR *,
    ULONG,
    CHAR *
    );


/*****************************************************************************
 *
 *  WinStationCreateProcessA
 *
 *   ANSI version of WinStationCreateProcessW
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
WinStationCreateProcessA(
    ULONG  LogonId,
    BOOL   System,
    PCHAR  lpszImageName,
    PCHAR  lpszCommandLine,
    PSECURITY_ATTRIBUTES psaProcess,
    PSECURITY_ATTRIBUTES psaThread,
    BOOL   fInheritHandles,
    DWORD  fdwCreate,
    LPVOID lpvEnvironment,
    LPCSTR lpszCurDir,
    LPSTARTUPINFOA pStartInfo,
    LPPROCESS_INFORMATION pProcInfo
    )
{
    ULONG  Len;
    STARTUPINFOW Info;
    BOOL   Result = FALSE;
    PWCHAR pImage = NULL;
    PWCHAR pCmdLine = NULL;
    PWCHAR pCurDir = NULL;
    PWCHAR pDesk = NULL;
    PWCHAR pTitle = NULL;

    // Convert the valid ANSI strings to UNICODE

    if( lpszImageName ) {
        Len = (strlen(lpszImageName)+1)*sizeof(WCHAR);
        pImage = LocalAlloc( LMEM_FIXED, Len );
        if( pImage == NULL ) goto Cleanup;
        AnsiToUnicode( pImage, Len, lpszImageName );
    }
    if( lpszCommandLine ) {
        Len = (strlen(lpszCommandLine)+1)*sizeof(WCHAR);
        pCmdLine = LocalAlloc( LMEM_FIXED, Len );
        if( pCmdLine == NULL ) goto Cleanup;
        AnsiToUnicode( pCmdLine, Len, lpszCommandLine );
    }
    if( lpszCurDir ) {
        Len = (strlen(lpszCurDir)+1)*sizeof(WCHAR);
        pCurDir = LocalAlloc( LMEM_FIXED, Len );
        if( pCurDir == NULL ) goto Cleanup;
        AnsiToUnicode( pCurDir, Len, (CHAR*)lpszCurDir );
    }
    if( pStartInfo->lpDesktop ) {
        Len = (strlen(pStartInfo->lpDesktop)+1)*sizeof(WCHAR);
        pDesk = LocalAlloc( LMEM_FIXED, Len );
        if( pDesk == NULL ) goto Cleanup;
        AnsiToUnicode( pDesk, Len, pStartInfo->lpDesktop );
    }
    if( pStartInfo->lpTitle ) {
        Len = (strlen(pStartInfo->lpTitle)+1)*sizeof(WCHAR);
        pTitle = LocalAlloc( LMEM_FIXED, Len );
        if( pTitle == NULL ) goto Cleanup;
        AnsiToUnicode( pTitle, Len, pStartInfo->lpTitle );
    }

    Info.cb = sizeof(STARTUPINFOW);
    Info.lpReserved = (PWCHAR)pStartInfo->lpReserved;
    Info.lpDesktop = pDesk;
    Info.lpTitle = pTitle;
    Info.dwX = pStartInfo->dwX;
    Info.dwY = pStartInfo->dwY;
    Info.dwXSize = pStartInfo->dwXSize;
    Info.dwYSize = pStartInfo->dwYSize;
    Info.dwXCountChars = pStartInfo->dwXCountChars;
    Info.dwYCountChars = pStartInfo->dwYCountChars;
    Info.dwFillAttribute = pStartInfo->dwFillAttribute;
    Info.dwFlags = pStartInfo->dwFlags;
    Info.wShowWindow = pStartInfo->wShowWindow;
    Info.cbReserved2 = pStartInfo->cbReserved2;
    Info.lpReserved2 = pStartInfo->lpReserved2;
    Info.hStdInput = pStartInfo->hStdInput;
    Info.hStdOutput = pStartInfo->hStdOutput;
    Info.hStdError = pStartInfo->hStdError;

    Result = WinStationCreateProcessW(
                 LogonId,
                 System,
                 pImage,
                 pCmdLine,
                 psaProcess,
                 psaThread,
                 fInheritHandles,
                 fdwCreate,
                 lpvEnvironment,
                 pCurDir,
                 &Info,
                 pProcInfo
             );

Cleanup:
    if( pImage ) LocalFree( pImage );
    if( pCmdLine ) LocalFree( pCmdLine );
    if( pCurDir ) LocalFree( pCurDir );
    if( pDesk ) LocalFree( pDesk );
    if( pTitle ) LocalFree( pTitle );

    return( Result );
}


/*****************************************************************************
 *
 *  WinStationCreateProcessW
 *
 *   Create a process on the given WinStation (LogonId)
 *
 * ENTRY:
 *   LogonId (input)
 *     LogonId of WinStation to create process on
 *
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
WinStationCreateProcessW(
    ULONG  LogonId,
    BOOL   System,
    PWCHAR lpszImageName,
    PWCHAR lpszCommandLine,
    PSECURITY_ATTRIBUTES psaProcess,
    PSECURITY_ATTRIBUTES psaThread,
    BOOL   fInheritHandles,
    DWORD  fdwCreate,
    LPVOID lpvEnvionment,
    LPWSTR lpszCurDir,
    LPSTARTUPINFOW pStartInfo,
    LPPROCESS_INFORMATION pProcInfo
    )
{
    BOOL   Result;
    HANDLE hPipe = NULL;
    WCHAR  szPipeName[MAX_PATH];
    PCHAR  ptr;
    ULONG  Count, AmountWrote, AmountRead;
    DWORD  MyProcId;
    PEXECSRV_REQUEST pReq;
    EXECSRV_REPLY    Rep;
    CHAR Buf[EXECSRV_BUFFER_SIZE];
    ULONG  MaxSize = EXECSRV_BUFFER_SIZE;

    if( lpszImageName )
        TRACE0(("EXECCLIENT: lpszImageName %ws\n",lpszImageName));

    if( lpszCommandLine )
        TRACE0(("EXECCLIENT: lpszCommandLine %ws\n",lpszCommandLine));

    // Winlogon handles all now. System flag tells it what to do
    swprintf(szPipeName, EXECSRV_SYSTEM_PIPE_NAME, LogonId);

    hPipe = CreateFileW(
                szPipeName,
                GENERIC_READ|GENERIC_WRITE,
                0,    // File share mode
                NULL, // default security
                OPEN_EXISTING,
                0,    // Attrs and flags
                NULL  // template file handle
                );

    if( hPipe == INVALID_HANDLE_VALUE ) {
        DBGPRINT(("EXECCLIENT: Could not create pipe name %ws\n", szPipeName));
        return(FALSE);
    }

    /*
     * Get the handle to the current process
     */
    MyProcId = GetCurrentProcessId();

    /*
     * setup the marshalling
     */
    ptr = Buf;
    Count = 0;

    pReq = (PEXECSRV_REQUEST)ptr;
    ptr   += sizeof(EXECSRV_REQUEST);
    Count += sizeof(EXECSRV_REQUEST);

    // set the basic parameters
    pReq->System = System;
    pReq->RequestingProcessId = MyProcId;
    pReq->fInheritHandles = fInheritHandles;
    pReq->fdwCreate = fdwCreate;

    // marshall the ImageName string
    if( lpszImageName ) {
        pReq->lpszImageName = MarshallStringW( lpszImageName, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->lpszImageName = NULL;
    }

    // marshall in the CommandLine string
    if( lpszCommandLine ) {
        pReq->lpszCommandLine = MarshallStringW( lpszCommandLine, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->lpszCommandLine = NULL;
    }

    // marshall in the CurDir string
    if( lpszCurDir ) {
        pReq->lpszCurDir = MarshallStringW( lpszCurDir, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->lpszCurDir = NULL;
    }

    // marshall in the StartupInfo structure
    RtlMoveMemory( &pReq->StartInfo, pStartInfo, sizeof(STARTUPINFO) );

    // Now marshall the strings in STARTUPINFO
    if( pStartInfo->lpDesktop ) {
        pReq->StartInfo.lpDesktop = MarshallStringW( pStartInfo->lpDesktop, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->StartInfo.lpDesktop = NULL;
    }

    if( pStartInfo->lpTitle ) {
        pReq->StartInfo.lpTitle = MarshallStringW( pStartInfo->lpTitle, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->StartInfo.lpTitle = NULL;
    }

    //
    // WARNING: This version does not pass the following:
    //
    //  Also saProcess and saThread are ignored right now and use
    //  the users default security on the remote WinStation
    //
    // Set things that are always NULL
    //
    pReq->StartInfo.lpReserved = NULL;  // always NULL
    pReq->lpvEnvironment = NULL;    
    pReq->hToken = NULL;

    // now fill in the total count
    pReq->Size = Count;

    /*
     * Now send the buffer out to the server
     */
    Result = WriteFile(
                 hPipe,
                 Buf,
                 Count,
                 &AmountWrote,
                 NULL
                 );

    if( !Result ) {
        DBGPRINT(("EXECCLIENT: Error %d sending request\n",GetLastError()));
        goto Cleanup;
    }

    /*
     * Now read the reply
     */
    Result = ReadFile(
                 hPipe,
                 &Rep,
                 sizeof(Rep),
                 &AmountRead,
                 NULL
                 );

    if( !Result ) {
        DBGPRINT(("EXECCLIENT: Error %d reading reply\n",GetLastError()));
        goto Cleanup;
    }

    /*
     * Check the result
     */
    if( !Rep.Result ) {
        DBGPRINT(("EXECCLIENT: Error %d in reply\n",Rep.LastError));
        // set the error in the current thread to the returned error
        Result = Rep.Result;
        SetLastError( Rep.LastError );
        goto Cleanup;
    }

    /*
     * We copy the PROCESS_INFO structure from the reply
     * to the caller.
     *
     * The remote site has duplicated the handles into our
     * process space for hProcess and hThread so that they will
     * behave like CreateProcessW()
     */

     RtlMoveMemory( pProcInfo, &Rep.ProcInfo, sizeof( PROCESS_INFORMATION ) );

Cleanup:
    CloseHandle(hPipe);

    DBGPRINT(("EXECCLIENT: Result 0x%x\n", Result));

    return(Result);
}

/*****************************************************************************
 *
 *  MarshallStringW
 *
 *   Marshall in a UNICODE_NULL terminated WCHAR string
 *
 * ENTRY:
 *   pSource (input)
 *     Pointer to source string
 *
 *   pBase (input)
 *     Base buffer pointer for normalizing the string pointer
 *
 *   MaxSize (input)
 *     Maximum buffer size available
 *
 *   ppPtr (input/output)
 *     Pointer to the current context pointer in the marshall buffer.
 *     This is updated as data is marshalled into the buffer
 *
 *   pCount (input/output)
 *     Current count of data in the marshall buffer.
 *     This is updated as data is marshalled into the buffer
 *
 * EXIT:
 *   NULL - Error
 *   !=NULL "normalized" pointer to the string in reference to pBase
 *
 ****************************************************************************/

PWCHAR
MarshallStringW(
    PWCHAR pSource,
    PCHAR  pBase,
    ULONG  MaxSize,
    PCHAR  *ppPtr,
    PULONG pCount
    )
{
    ULONG Len;
    PCHAR ptr;

    Len = wcslen( pSource );
    Len++; // include the NULL;

    Len *= sizeof(WCHAR); // convert to bytes
    if( (*pCount + Len) > MaxSize ) {
        return( NULL );
    }

    RtlMoveMemory( *ppPtr, pSource, Len );

    // the normalized ptr is the current count
    ptr = LongToPtr(*pCount);

    *ppPtr += Len;
    *pCount += Len;

    return((PWCHAR)ptr);
}

/*******************************************************************************
 *
 *  AnsiToUnicode
 *
 *     convert an ANSI (CHAR) string into a UNICODE (WCHAR) string
 *
 * ENTRY:
 *
 *    pUnicodeString (output)
 *       buffer to place UNICODE string into
 *    lUnicodeMax (input)
 *       maximum number of characters to write into pUnicodeString
 *    pAnsiString (input)
 *       ANSI string to convert
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
AnsiToUnicode( WCHAR * pUnicodeString,
               ULONG lUnicodeMax,
               CHAR * pAnsiString )
{
    ULONG ByteCount;

    RtlMultiByteToUnicodeN( pUnicodeString, lUnicodeMax, &ByteCount,
                            pAnsiString, (strlen(pAnsiString) + 1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\dumpsd.c ===
// Include NT headers
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include "windows.h"

void CtxDumpSid( PSID, PCHAR, PULONG );
void DumpAcl( PACL, PCHAR, PULONG );
void DumpAce( PACE_HEADER, PCHAR, PULONG );

#if DBG
void
DumpSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSD
    )
{
    PISECURITY_DESCRIPTOR p = (PISECURITY_DESCRIPTOR)pSD;
    PSID pSid;
    PACL pAcl;
    PCHAR pTmp;
    ULONG Size;

    //
    // This is done under an exception handler in case someone passes in
    // a totally bogus security descriptor
    //
    try {

        DbgPrint("DUMP_SECURITY_DESCRIPTOR: Revision %d, Sbz1 %d, Control 0x%x\n",
            p->Revision, p->Sbz1, p->Control );

        if ( p->Control & SE_SELF_RELATIVE ) {
            DbgPrint("Self Relative\n");
        }

        DbgPrint("PSID Owner 0x%x\n",p->Owner);

        // If this is self relative, must offset the pointers
        if( p->Owner != NULL ) {
            if( p->Control & SE_SELF_RELATIVE ) {
                pTmp = (PCHAR)pSD;
                pTmp += (UINT_PTR)p->Owner;
                CtxDumpSid( (PSID)pTmp, (PCHAR)p, &Size );
            }
            else {
                // can reference it directly
                CtxDumpSid( p->Owner, (PCHAR)p, &Size );
            }
        }


        DbgPrint("PSID Group 0x%x\n",p->Group);

        // If this is self relative, must offset the pointers
        if( p->Group != NULL ) {
            if( p->Control & SE_SELF_RELATIVE ) {
                pTmp = (PCHAR)pSD;
                pTmp += (UINT_PTR)p->Group;
                CtxDumpSid( (PSID)pTmp, (PCHAR)p, &Size );
            }
            else {
                // can reference it directly
                CtxDumpSid( p->Group, (PCHAR)p, &Size );
            }
        }

        DbgPrint("\n");

        DbgPrint("PACL Sacl 0x%x\n",p->Sacl);

        // If this is self relative, must offset the pointers
        if( p->Sacl != NULL ) {
            if( p->Control & SE_SELF_RELATIVE ) {
                pTmp = (PCHAR)pSD;
                pTmp += (UINT_PTR)p->Sacl;
                DumpAcl( (PSID)pTmp, (PCHAR)p, &Size );
            }
            else {
                // can reference it directly
                DumpAcl( p->Sacl, (PCHAR)p, &Size );
            }
        }

        DbgPrint("\n");

        DbgPrint("PACL Dacl 0x%x\n",p->Dacl);

        // If this is self relative, must offset the pointers
        if( p->Dacl != NULL ) {
            if( p->Control & SE_SELF_RELATIVE ) {
                pTmp = (PCHAR)pSD;
                pTmp += (UINT_PTR)p->Dacl;
                DumpAcl( (PSID)pTmp, (PCHAR)p, &Size );
            }
            else {
                // can reference it directly
                DumpAcl( p->Dacl, (PCHAR)p, &Size );
            }
        }


    } except( EXCEPTION_EXECUTE_HANDLER) {
          DbgPrint("DUMP_SECURITY_DESCRIPTOR: Exception %d accessing descriptor\n",GetExceptionCode());
          return;
    }
}
#endif

#if DBG
void
CtxDumpSid(
    PSID   pSid,
    PCHAR  pBase,
    PULONG pSize
    )
{
    PISID p;
    ULONG i;
    BOOL  OK;
    DWORD szUserName;
    DWORD szDomain;
    SID_NAME_USE UserSidType;
    WCHAR UserName[256];
    WCHAR Domain[256];
    ULONG Size = 0;

    p = (PISID)pSid;

    DbgPrint("Revision %d, SubAuthorityCount %d\n", p->Revision, p->SubAuthorityCount);

    Size += 2;   // Revision, SubAuthorityCount

    DbgPrint("IdentifierAuthority: %x %x %x %x %x %x\n",
        p->IdentifierAuthority.Value[0],
        p->IdentifierAuthority.Value[1],
        p->IdentifierAuthority.Value[2],
        p->IdentifierAuthority.Value[3],
        p->IdentifierAuthority.Value[4],
        p->IdentifierAuthority.Value[5] );

    Size += 6;   // IdentifierAuthority

    for( i=0; i < p->SubAuthorityCount; i++ ) {

        DbgPrint("SubAuthority[%d] 0x%x\n", i, p->SubAuthority[i]);

        Size += sizeof(ULONG);
    }

    if( pSize ) {
        *pSize = Size;
    }

    szUserName = sizeof(UserName);
    szDomain = sizeof(Domain);

    // Now print its account
    OK = LookupAccountSidW(
             NULL, // Computer Name
             pSid,
             UserName,
             &szUserName,
             Domain,
             &szDomain,
             &UserSidType
             );

    if( OK ) {
        DbgPrint("Account Name %ws, Domain %ws, Type %d, SidSize %d\n",UserName,Domain,UserSidType,Size);
    }
    else {
        DbgPrint("Error looking up account name %d, SizeSid %d\n",GetLastError(),Size);
    }

}
#endif

#if DBG
void
DumpAcl(
    PACL   pAcl,
    PCHAR  pBase,
    PULONG pSize
    )
{
    USHORT i;
    PCHAR  pTmp;
    ULONG  Size, MySize;
    PACL   p = pAcl;
    PCHAR  pCur = (PCHAR)pAcl;

    MySize = 0;

    DbgPrint("AclRevision %d, Sbz1 %d, AclSize %d, AceCount %d, Sbz2 %d\n",
        p->AclRevision, p->Sbz1, p->AclSize, p->AceCount, p->Sbz2 );

    // bump over the ACL header to point to the first ACE
    pCur += sizeof( ACL );

    MySize += sizeof( ACL );

    for( i=0; i < p->AceCount; i++ ) {

        DumpAce( (PACE_HEADER)pCur, pBase, &Size );

        pCur += Size;
        MySize += Size;
    }

    // ACL consistency check
    if( p->AclSize != MySize ) {
        DbgPrint("Inconsistent ACL Entry! p->AclSize %d, RealSize %d\n",p->AclSize,MySize);
    }

    // return the size of this ACL
    *pSize = MySize;
    return;
}
#endif

#if DBG
void
DumpAce(
    PACE_HEADER pAce,
    PCHAR  pBase,
    PULONG pSize
    )
{
    PACE_HEADER p = pAce;
    PACCESS_ALLOWED_ACE pAl;
    PACCESS_DENIED_ACE pAd;
    PSYSTEM_AUDIT_ACE pSa;
    PSYSTEM_ALARM_ACE pSl;
    PCHAR pTmp;
    ULONG MySize, Size;


    DbgPrint("ACE_HEADER: Type %d, Flags 0x%x, Size %d\n",
        p->AceType, p->AceFlags, p->AceSize );


    switch( p->AceType ) {

    case ACCESS_ALLOWED_ACE_TYPE:
	    pAl = (PACCESS_ALLOWED_ACE)p;
	    DbgPrint("ACCESS_ALLOWED_ACE: AccessMask 0x%x, Sid 0x%x\n",pAl->Mask,pAl->SidStart);

	    MySize = sizeof(ACCESS_ALLOWED_ACE);

            if( pAl->SidStart ) {
	        pTmp = (PCHAR)&pAl->SidStart;
		CtxDumpSid( (PSID)pTmp, pBase, &Size );
	        MySize += Size;
                // Adjust for the first ULONG of the ACE
		// being part of the Sid
                MySize -= sizeof(ULONG);
	    }

	    break;

    case ACCESS_DENIED_ACE_TYPE:
	    pAd = (PACCESS_DENIED_ACE)p;
	    DbgPrint("ACCESS_DENIED_ACE: AccessMask 0x%x, Sid 0x%x\n",pAd->Mask,pAd->SidStart);

	    MySize = sizeof(ACCESS_DENIED_ACE);

            if( pAd->SidStart ) {
	        pTmp = (PCHAR)&pAd->SidStart;
		CtxDumpSid( (PSID)pTmp, pBase, &Size );
		MySize += Size;
                // Adjust for the first ULONG of the ACE
		// being part of the Sid
                MySize -= sizeof(ULONG);
	    }

	    break;

    case SYSTEM_AUDIT_ACE_TYPE:
	    pSa = (PSYSTEM_AUDIT_ACE)p;
	    DbgPrint("SYSTEM_AUDIT_ACE: AccessMask 0x%x, Sid 0x%x\n",pSa->Mask,pSa->SidStart);

	    MySize = sizeof(SYSTEM_AUDIT_ACE);

            if( pSa->SidStart ) {
 	        pTmp = (PCHAR)&pSa->SidStart;
		CtxDumpSid( (PSID)pTmp, pBase, &Size );
		MySize += Size;
                // Adjust for the first ULONG of the ACE
		// being part of the Sid
                MySize -= sizeof(ULONG);
	    }

	    break;

    case SYSTEM_ALARM_ACE_TYPE:
	    pSl = (PSYSTEM_ALARM_ACE)p;
	    DbgPrint("SYSTEM_ALARM_ACE: AccessMask 0x%x, Sid 0x%x\n",pSl->Mask,pSl->SidStart);

	    MySize = sizeof(SYSTEM_ALARM_ACE);

            if( pSl->SidStart ) {
	        pTmp = (PCHAR)&pSl->SidStart;
		CtxDumpSid( (PSID)pTmp, pBase, &Size );
		MySize += Size;
                // Adjust for the first ULONG of the ACE
		// being part of the Sid
                MySize -= sizeof(ULONG);
	    }

	    break;

    default:
            DbgPrint("Unknown ACE type %d\n", p->AceType);
    }

    // Check its consistency
    if( p->AceSize != MySize ) {
        DbgPrint("Inconsistent ACE Entry! p->AceSize %d, RealSize %d\n",p->AceSize,MySize);
    }

    // return the size so the caller can update the pointer
    *pSize = p->AceSize;

    DbgPrint("\n");

    return;
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\dirwalk.c ===
/*************************************************************************
*
* dirwalk.c
*
* Walk a tree setting ACL's on an NT system.
*
* Copyright Microsoft, 1998
*
*
*
*************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <process.h>

#include <winsta.h>
#include <syslib.h>

#include "security.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


// Global variables
PWCHAR gpAvoidDir = NULL;

CRITICAL_SECTION SyslibCritSect;


typedef BOOLEAN (CALLBACK* NODEPROC)( PWCHAR, PWIN32_FIND_DATAW, DWORD, DWORD );

BOOLEAN
EnumerateDirectory(
    PWCHAR   pRoot,
    DWORD    Level,
    NODEPROC pProc
    );

BOOLEAN
NodeEnumProc(
    PWCHAR pParent,
    PWIN32_FIND_DATA p,
    DWORD  Level,
    DWORD  Index
    );

PWCHAR
AddWildCard(
    PWCHAR pRoot
    );

PWCHAR
AddBackSlash(
    PWCHAR pRoot
    );

FILE_RESULT
xxxProcessFile(
    PWCHAR pParent,
    PWIN32_FIND_DATAW p,
    DWORD  Level,
    DWORD  Index
    );

/*****************************************************************************
 *
 *  CtxGetSyslibCritSect
 *
 *   Returns the library global critical section pointer.
 *   Critical section will be initialised if necessary
 *
 * ENTRY:
 *    VOID - Caller must ensure that only one threads a times calls this
 *           function. The function will not itself guarantie mutual exclusion.
 * EXIT:
 *   Pointer to critical section. NULL if failure.
 *
 ****************************************************************************/


PCRITICAL_SECTION
CtxGetSyslibCritSect(void)
{
    static BOOLEAN fInitialized = FALSE;
    NTSTATUS Status;

    if( !fInitialized ){

            Status = RtlInitializeCriticalSection(&SyslibCritSect);
            if (NT_SUCCESS(Status)) {
                fInitialized = TRUE;
            }else{
                return NULL;
            }

    }
    return(&SyslibCritSect);
}


/*****************************************************************************
 *
 *  SetFileTree
 *
 *   Walk the given tree calling the processing function for each node.
 *
 * ENTRY:
 *   pRoot (input)
 *     Full WIN32 path to directory to walk
 *
 *   pVoidDir (input)
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
SetFileTree(
    PWCHAR   pRoot,
    PWCHAR   pAvoidDir
    )
{
    BOOLEAN rc;
    PWCHAR pRootNew;
    static BOOLEAN fInitialized = FALSE;
    PRTL_CRITICAL_SECTION pLock = CtxGetSyslibCritSect(); 

    // if critical section could not be created, do nothing.

    if (pLock == NULL) {
        return FALSE;
    }
    DBGPRINT(( "entering SetFileTree(pRoot=%ws,pAvoidDir=%ws)\n", pRoot, pAvoidDir ));

    EnterCriticalSection(pLock);
    // If this is the console make sure the user hasn't changed

    if ((NtCurrentPeb()->SessionId == 0) && fInitialized) {
        CheckUserSid();

    } else if ( !fInitialized ) {
       fInitialized = TRUE;
       if ( !InitSecurity() ) {
          DBGPRINT(( "problem initializing security; we're outta here.\n" ));
          LeaveCriticalSection(pLock);
          return( 1 ); // (non-zero for error...)// Should be return FALSE!?
       }
    }
    LeaveCriticalSection(pLock);

    gpAvoidDir = pAvoidDir;

    // be sure to apply security to root directory
    pRootNew = AddBackSlash(pRoot);
    if(pRootNew) {
        DBGPRINT(( "processing file %ws\n", pRootNew ));
        xxxProcessFile(pRootNew, NULL, 0, 0);
        LocalFree(pRootNew);
    }

    rc = EnumerateDirectory( pRoot, 0, NodeEnumProc );
    DBGPRINT(( "leaving SetFileTree()\n" ));
    return( rc );
}

/*****************************************************************************
 *
 *  EnumerateDirectory
 *
 *   Walk the given directory calling the processing function for each file.
 *
 * ENTRY:
 *   pRoot (input)
 *     Full WIN32 path to directory to walk
 *
 *   Level (input)
 *     Level we are in a given tree. Useful for formating output
 *
 *   pProc (input)
 *     Procedure to call for each non-directory file
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
EnumerateDirectory(
    PWCHAR   pRoot,
    DWORD    Level,
    NODEPROC pProc
    )
{
    BOOL rc;
    DWORD Result;
    HANDLE hf;
    DWORD Index;
    WIN32_FIND_DATA Data;
    PWCHAR pRootNew;

    DBGPRINT(( "entering EnumerateDirectory(pRoot=%ws,Level=%ld,pProc=NodeEnumProc)\n",pRoot,Level ));

    if( pRoot == NULL ) {
        DBGPRINT(( "leaving EnumerateDirectory(), return=FALSE\n" ));
        return( FALSE );
    }

    // Make sure it is not one we want to avoid
    if( gpAvoidDir ) {
        DWORD Len = wcslen( gpAvoidDir );

        if( _wcsnicmp( pRoot, gpAvoidDir, Len ) == 0 ) {
            DBGPRINT(( "leaving EnumerateDirectory(), return=FALSE\n" ));
            return( FALSE );
        }
    }

    pRootNew = AddWildCard( pRoot );
    if( pRootNew == NULL ) {
        DBGPRINT(( "leaving EnumerateDirectory(), return=FALSE\n" ));
        return( FALSE );
    }

    Index = 0;

    DBGPRINT(("FindFirstFileW: %ws\n",pRootNew));

    hf = FindFirstFileW(
             pRootNew,
             &Data
             );

    if( hf == INVALID_HANDLE_VALUE ) {
        DBGPRINT(("EnumerateDirectory: Error %d opening root %ws\n",GetLastError(),pRootNew));
        LocalFree( pRootNew );
        DBGPRINT(( "leaving EnumerateDirectory(), return=FALSE\n" ));
        return(FALSE);
    }

    while( 1 ) {

        // pass the parent without the wildcard added
        pProc( pRoot, &Data, Level, Index );

        rc = FindNextFile(
                 hf,
                 &Data
                 );

        if( !rc ) {
            Result = GetLastError();
            if( Result == ERROR_NO_MORE_FILES ) {
                FindClose( hf );
                LocalFree( pRootNew );
                DBGPRINT(( "leaving EnumerateDirectory(), return=TRUE\n" ));
                return( TRUE );
            }
            else {
                DBGPRINT(("EnumerateDirectory: Error %d, Index 0x%x\n",Result,Index));
                FindClose( hf );
                LocalFree( pRootNew );
                DBGPRINT(( "leaving EnumerateDirectory(), return=FALSE\n" ));
                return( FALSE );
            }
        }

        Index++;
    }

// UNREACHABLE.

}

/*****************************************************************************
 *
 *  NodeEnumProc
 *
 *   Process the enumerated file
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
NodeEnumProc(
    PWCHAR pParent,
    PWIN32_FIND_DATAW p,
    DWORD  Level,
    DWORD  Index
    )
{
    BOOLEAN rc;
    PWCHAR  pParentNew;
    DWORD   ParentCount, ChildCount;

    //
    // We must append the directory to our parent path to get the
    // new full path.
    //

    ParentCount = wcslen( pParent );
    ChildCount  = wcslen( p->cFileName );

    pParentNew = LocalAlloc( LMEM_FIXED, (ParentCount + ChildCount + 2)*sizeof(WCHAR) );

    if( pParentNew == NULL ) return( FALSE );

    wcscpy( pParentNew, pParent );
    wcscat( pParentNew, L"\\" );
    wcscat( pParentNew, p->cFileName );

    if( p->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

        // Skip "." and ".."
        if( wcscmp( L".", p->cFileName ) == 0 ) {
            LocalFree( pParentNew );
            return( TRUE );
        }

        if( wcscmp( L"..", p->cFileName ) == 0 ) {
            LocalFree( pParentNew );
            return( TRUE );
        }

        TRACE0(("%ws:\n",pParentNew));

        xxxProcessFile( pParentNew, p, Level, Index );

        // For directories, we recurse
        rc = EnumerateDirectory( pParentNew, Level+1, NodeEnumProc );

        LocalFree( pParentNew );

        return( rc );
    }

    TRACE0(("%ws\n",pParentNew));

    xxxProcessFile( pParentNew, p, Level, Index );

    LocalFree( pParentNew );

    return( TRUE );
}

/*****************************************************************************
 *
 *  AddWildCard
 *
 *   Add the wild card search specifier
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PWCHAR
AddWildCard(
    PWCHAR pRoot
    )
{
    DWORD  Count;
    PWCHAR pNew;
    PWCHAR WildCard = L"\\*";

    Count = wcslen( pRoot );
    pNew = LocalAlloc( LMEM_FIXED, (Count + wcslen(WildCard) + 1)*sizeof(WCHAR) );

    if( pNew == NULL ) {
        return( NULL );
    }

    wcscpy( pNew, pRoot );
    wcscat( pNew, WildCard );

    return( pNew );
}

/*****************************************************************************
 *
 *  AddBackSlash
 *
 *   Add the backslash character to path
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PWCHAR
AddBackSlash(
    PWCHAR pRoot
    )
{
    DWORD  Count;
    PWCHAR pNew;
    PWCHAR BackSlash = L"\\";

    Count = wcslen( pRoot );
    pNew = LocalAlloc( LMEM_FIXED, (Count + wcslen(BackSlash) + 1)*sizeof(WCHAR) );

    if( pNew == NULL ) {
        return( NULL );
    }

    wcscpy( pNew, pRoot );

    // only add backslash if string doesn't already have it
    if(*(pRoot+Count-1) != L'\\')
        wcscat( pNew, BackSlash );

    return( pNew );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\file.c ===
/*************************************************************************
*
* file.c
*
* Process the security on a file
*
* Copyright Microsoft, 1998
*
*
*
*************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <process.h>

#include <winsta.h>
#include <syslib.h>

#include "security.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#ifdef FULL_DEBUG
#define DBGPRINT(x) DbgPrint x
#else
#define DBGPRINT(x)
#endif
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

// External data

// data.c
extern ACCESS_MASK DeniedAccess;

// security.c
extern PSID  SeCreatorOwnerSid;
extern PSID  SeCreatorGroupSid;


FILE_RESULT
xxxSetFileSecurity(
    PWCHAR pFile
    );

/*****************************************************************************
 *
 *  xxxProcessFile
 *
 *   Process the given file for access security holes
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

FILE_RESULT
xxxProcessFile(
    PWCHAR pFile,
    PWIN32_FIND_DATAW p,
    DWORD  Level,
    DWORD  Index
    )
{
    FILE_RESULT rc;

    rc = xxxSetFileSecurity( pFile );

    return( rc );
}


/*****************************************************************************
 *
 *  xxxSetFileSecurity
 *
 *   Set the security properties for the given file
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

FILE_RESULT
xxxSetFileSecurity(
    PWCHAR pFile
    )
{
    BOOL rc;
    BOOL DaclPresent;
    BOOL Default;
    BOOL OwnerDefaulted;
    BOOL GroupDefaulted;
    FILE_RESULT Result, ReturnResult;
    DWORD Size, Index;
    PACL pACL = NULL;
    PVOID pAce = NULL;
    SECURITY_INFORMATION Info = 0;
    DWORD Error;
    PSECURITY_DESCRIPTOR pSelfSd = NULL;

    // Absolute SD values
    PSECURITY_DESCRIPTOR pAbsSd = NULL;
    DWORD AbsSdSize = 0;
    PACL  pAbsAcl = NULL;
    DWORD AbsAclSize = 0;
    PACL  pAbsSacl = NULL;
    DWORD AbsSaclSize = 0;
    PSID  pAbsOwner = NULL;
    DWORD AbsOwnerSize = 0;
    PSID  pAbsGroup = NULL;
    DWORD AbsGroupSize = 0;

    DBGPRINT(( "entering xxxSetFileSecurity(pFile=%ws)\n", pFile ));

    /*
     * Get the files current security descriptor
     */

    Size = 0;
    rc = GetFileSecurityW(
             pFile,
             DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION,
             NULL,    // pSelfSd
             0,
             &Size
             );

    if( rc ) {
        Error = GetLastError();

        ReportFileResult(
            FileAccessErrorUserFormat,
            0,                           // Access
            pFile,
            NULL,                        // pAccountName
            NULL,                        // pDomainName
            "%d has no DACL",
            Error
            );

        DBGPRINT(( "leaving xxxSetFileSecurity(1); returning=FileAccessError\n" ));
        return( FileAccessError );
    }
    else {
        pSelfSd = LocalAlloc( LMEM_FIXED, Size );
        if( pSelfSd == NULL ) {

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "Out of memory skipped entry"
                );

            DBGPRINT(( "leaving xxxSetFileSecurity(2); returning=0\n" ));
            return( FALSE );
        }

        rc = GetFileSecurityW(
                 pFile,
                 DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION,
                 pSelfSd,
                 Size,
                 &Size
                 );

        if( !rc ) {
            Error = GetLastError();

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "%d Could not get DACL",
                Error
                );

            LocalFree( pSelfSd );
            DBGPRINT(( "leaving xxxSetFileSecurity(3); returning=FileAccessError\n" ));
            return( FileAccessError );
        }
    }

    //
    // Now convert the self relative SD to an absolute one.
    //

    rc = MakeAbsoluteSD (
             pSelfSd,
             pAbsSd,
             &AbsSdSize,
             pAbsAcl,
             &AbsAclSize,
             pAbsSacl,
             &AbsSaclSize,
             pAbsOwner,
             &AbsOwnerSize,
             pAbsGroup,
             &AbsGroupSize
             );

    if( !rc ) {
        Error = GetLastError();

        if( Error != ERROR_INSUFFICIENT_BUFFER ) {

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "%d converting SECURITY_DESCRIPTOR",
                Error
                );

               LocalFree( pSelfSd );
            DBGPRINT(( "leaving xxxSetFileSecurity(4); returning=FileAccessError\n" ));
               return( FileAccessError );
        }

        // Allocate buffers and now really get the SD
        pAbsSd    = LocalAlloc( LMEM_FIXED, AbsSdSize );
        pAbsAcl   = LocalAlloc( LMEM_FIXED, AbsAclSize );
        pAbsSacl  = LocalAlloc( LMEM_FIXED, AbsSaclSize );
        pAbsOwner = LocalAlloc( LMEM_FIXED, AbsOwnerSize );
        pAbsGroup = LocalAlloc( LMEM_FIXED, AbsGroupSize );

        if( !( pAbsSd && pAbsAcl && pAbsSacl && pAbsOwner && pAbsGroup ) ) {

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "Allocating memory"
                );

               if( pAbsSd ) LocalFree( pAbsSd );
               if( pAbsAcl ) LocalFree( pAbsAcl );
               if( pAbsSacl ) LocalFree( pAbsSacl );
               if( pAbsOwner ) LocalFree( pAbsOwner );
               if( pAbsGroup ) LocalFree( pAbsGroup );
               LocalFree( pSelfSd );
               DBGPRINT(( "leaving xxxSetFileSecurity(5); returning=FileAccessError\n" ));
               return( FileAccessError );
        }

        // Try it again
        rc = MakeAbsoluteSD (
                 pSelfSd,
                 pAbsSd,
                 &AbsSdSize,
                 pAbsAcl,
                 &AbsAclSize,
                 pAbsSacl,
                 &AbsSaclSize,
                 pAbsOwner,
                 &AbsOwnerSize,
                 pAbsGroup,
                 &AbsGroupSize
                 );

        if( !rc ) {
            Error = GetLastError();

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "%d Making ABSOLUTE SD",
                Error
                );

               if( pAbsSd ) LocalFree( pAbsSd );
               if( pAbsAcl ) LocalFree( pAbsAcl );
               if( pAbsSacl ) LocalFree( pAbsSacl );
               if( pAbsOwner ) LocalFree( pAbsOwner );
               if( pAbsGroup ) LocalFree( pAbsGroup );
               LocalFree( pSelfSd );
               DBGPRINT(( "leaving xxxSetFileSecurity(6); returning=FileAccessError\n" ));
               return( FileAccessError );
        }
    }

    //
    // Get our new trusted ACL
    //
    pACL = GetSecureAcl();
    if( pACL == NULL ) {

        ReportFileResult(
            FileAccessErrorUserFormat,
            0,                           // Access
            pFile,
            NULL,                        // pAccountName
            NULL,                        // pDomainName
            "Could not get New ACL"
            );
        
        if( pAbsSd ) LocalFree( pAbsSd );
        if( pAbsAcl ) LocalFree( pAbsAcl );
        if( pAbsSacl ) LocalFree( pAbsSacl );
        if( pAbsOwner ) LocalFree( pAbsOwner );
        if( pAbsGroup ) LocalFree( pAbsGroup );
        LocalFree( pSelfSd );
        DBGPRINT(( "leaving xxxSetFileSecurity(7); returning=FileAccessError\n" ));
        return( FileAccessError );
    }

    //
    // Now set the trusted ACL onto the security descriptor
    //

    rc = SetSecurityDescriptorDacl(
             pAbsSd,
             TRUE,   // DACL present
             pACL,
             FALSE   // Not default
             );

    if( !rc ) {
        Error = GetLastError();

        ReportFileResult(
            FileAccessErrorUserFormat,
            0,                           // Access
            pFile,
            NULL,                        // pAccountName
            NULL,                        // pDomainName
            "Could not set new ACL in Security Descriptor %d",
            Error
            );

        if( pAbsSd ) LocalFree( pAbsSd );
        if( pAbsAcl ) LocalFree( pAbsAcl );
        if( pAbsSacl ) LocalFree( pAbsSacl );
        if( pAbsOwner ) LocalFree( pAbsOwner );
        if( pAbsGroup ) LocalFree( pAbsGroup );
        LocalFree( pSelfSd );
        DBGPRINT(( "leaving xxxSetFileSecurity(8); returning=FileAccessError\n" ));
        return( FileAccessError );
    }

    Info |= DACL_SECURITY_INFORMATION;

    //
    // If the owner is not one of the admins, we will grab
    // it and local admin will now own it
    //

    if( pAbsOwner && !IsAllowSid( pAbsOwner ) ) {

        // Make the local admin own it
        rc = SetSecurityDescriptorOwner(
                 pAbsSd,
                 GetAdminSid(),
                 FALSE   // Not defaulted
                 );

        if( !rc ) {
            Error = GetLastError();

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "Could not set file owner %d",
                Error
            );

            if( pAbsSd ) LocalFree( pAbsSd );
            if( pAbsAcl ) LocalFree( pAbsAcl );
            if( pAbsSacl ) LocalFree( pAbsSacl );
            if( pAbsOwner ) LocalFree( pAbsOwner );
            if( pAbsGroup ) LocalFree( pAbsGroup );
            LocalFree( pSelfSd );
            DBGPRINT(( "leaving xxxSetFileSecurity(9); returning=FileAccessError\n" ));
            return( FileAccessError );
        }
        else {
            Info |= OWNER_SECURITY_INFORMATION;
        }
    }

#ifdef notdef       // WWM - don't worry about the group
    if( pAbsGroup && !IsAllowSid( pAbsGroup ) ) {

        // Make the local admin group own it
        rc = SetSecurityDescriptorGroup(
                 pAbsSd,
                 GetLocalAdminGroupSid(),
                 FALSE   // Not defaulted
                 );

        if( !rc ) {
            Error = GetLastError();

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "Could not set file group %d",
                Error
            );

            if( pAbsSd ) LocalFree( pAbsSd );
            if( pAbsAcl ) LocalFree( pAbsAcl );
            if( pAbsSacl ) LocalFree( pAbsSacl );
            if( pAbsOwner ) LocalFree( pAbsOwner );
            if( pAbsGroup ) LocalFree( pAbsGroup );
            LocalFree( pSelfSd );
            DBGPRINT(( "leaving xxxSetFileSecurity(10); returning=FileAccessError\n" ));
            return( FileAccessError );
        }
        else {
            Info |= GROUP_SECURITY_INFORMATION;
        }
    }
#endif 

    //
    // Now set the new security descriptor onto the file
    //

    rc = SetFileSecurityW(
             pFile,
             Info,
             pAbsSd
             );

    if( !rc ) {
        Error = GetLastError();

        ReportFileResult(
            FileAccessErrorUserFormat,
            0,                           // Access
            pFile,
            NULL,                        // pAccountName
            NULL,                        // pDomainName
            "Could not set new Security Descriptor %d",
            Error
            );

        if( pAbsSd ) LocalFree( pAbsSd );
        if( pAbsAcl ) LocalFree( pAbsAcl );
        if( pAbsSacl ) LocalFree( pAbsSacl );
        if( pAbsOwner ) LocalFree( pAbsOwner );
        if( pAbsGroup ) LocalFree( pAbsGroup );
        LocalFree( pSelfSd );
        DBGPRINT(( "leaving xxxSetFileSecurity(11); returning=FileAccessError\n" ));
        return( FileAccessError );
    }

    if( pAbsSd ) LocalFree( pAbsSd );
    if( pAbsAcl ) LocalFree( pAbsAcl );
    if( pAbsSacl ) LocalFree( pAbsSacl );
    if( pAbsOwner ) LocalFree( pAbsOwner );
    if( pAbsGroup ) LocalFree( pAbsGroup );
    LocalFree( pSelfSd );
    DBGPRINT(( "leaving xxxSetFileSecurity(12); returning=FileOk\n" ));
    return( FileOk );
}


#ifdef notdef
    //
    // Get the owner SID
    //
    rc = GetSecurityDescriptorOwner(
             pSelfSd,
             &Owner,
             &OwnerDefaulted
             );

    if( !rc ) {
        // No owner info
        Owner = NULL;
    }

    //
    // Get the group SID
    //
    rc = GetSecurityDescriptorGroup(
             pSelfSd,
             &Group,
             &GroupDefaulted
             );

    if( !rc ) {
        // No group info
        Group = NULL;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\report.c ===
/*************************************************************************
*
* report.c
*
* Report module
*
*  Copyright Microsoft, 1998
*
*
*  This module puts all reporting in one place to accommadate changes.
*
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>              // Make a bunch of default NT templates
#include <process.h>

#include <winsta.h>
#include <syslib.h>

#include "security.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


//
// Forward references
//
VOID
PrintFileAccessMask(
    ACCESS_MASK Mask
    );


/*****************************************************************************
 *
 *  ReportFileResult
 *
 *   Generates a report on a file access check
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
ReportFileResult(
    FILE_RESULT Code,
    ACCESS_MASK Access,
    PWCHAR      pFile,
    PWCHAR      pAccountName,
    PWCHAR      pDomainName,
    PCHAR       UserFormat,
    ...
    )
{
    va_list arglist;
    UCHAR Buffer[512];
    int cb;
    DWORD Len;

    va_start(arglist, UserFormat);

    //
    // New format:
    //
    //    6      28                          xxx
    //  ACCESS ACCOUNT                      FILE
    //  ______ ____________________________ _______________________________________
    //

    if( Code == FileOk ) {
        ; // Do nothing, future options may report an OK list
        return (TRUE );
    }
    else if( Code == FileAccessError ) {
        DBGPRINT(("***WARNING*** Error accessing security information on file %ws\n",pFile));
        DBGPRINT(("The account in which the utility is run may not have access to the file\n"));
        DBGPRINT(("Use FileManager to take ownership of this file\n"));
        return (TRUE );
    }
    else if( Code == FileAccessErrorUserFormat ) {

        // Use the user supplied format string in the error report
        cb = _vsnprintf(Buffer, sizeof(Buffer), UserFormat, arglist);
        if (cb == -1) {         // detect buffer overflow
            cb = sizeof(Buffer);
            Buffer[sizeof(Buffer) - 1] = '\n';
        }

        DBGPRINT(("***ERROR*** %s on file %ws\n",Buffer,pFile));
        return( TRUE );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\inimap.c ===
/*************************************************************************
*
* inimap.c
*
* Functions to query/set ini file mapping for the WinStation and set the
* application
*
* Copyright Microsoft, 1998
*
*
*************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "winsta.h"
#include "syslib.h"

#if DBG
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

#define CITRIX_COMPAT_TEBVALID 0x80000000  // Compat flags in Teb are valid


/*****************************************************************************
 *
 *  SetCtxAppCompatFlags
 *
 *   Set the application's current compatibility flags, this will only update
 *   the current compatibility flags, not the flags in the registry.
 *
 * ENTRY:
 *   ULONG ulAppFlags (IN) - Desired compatibility flags
 *
 * EXIT:
 *   Returns TRUE to indicate success
 *
 ****************************************************************************/
BOOL SetCtxAppCompatFlags(ULONG ulAppFlags)
{
#if 0
    NtCurrentTeb()->CtxCompatFlags = ulAppFlags;
    NtCurrentTeb()->CtxCompatFlags |= CITRIX_COMPAT_TEBVALID;
#endif
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\registry.c ===
/*************************************************************************
*
* registry.c
*
* Functions to provide easy access to security (ACLs).
*
* Copyright Microsoft, 1998
*
*
*************************************************************************/

/* include files */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "winsta.h"
#include "syslib.h"
#include "regapi.h"

#if DBG
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*
 * Data Structure
 */
/// NONE YET...


/*
 * Definitions
 */
#define SZENABLE TEXT("1")


/*
 * procedure prototypes
 */
BOOL QueryFlatTempKey( VOID );


/*****************************************************************************
 *
 *  QueryFlatTempKey
 *
 *  ENTRY: Nothing.
 *
 *  EXIT:  TRUE  - enabled
 *         FALSE - disabled (key doesn't exist or isn't "1")
 *
 *
 ****************************************************************************/

BOOL
QueryFlatTempKey( VOID )
{
    DWORD  dwType = REG_SZ;
    DWORD  dwSize = 3 * sizeof(WCHAR);
    WCHAR  szValue[3];
    HKEY   Handle;
    LONG   rc;

    // 
    // Ideally, I could just call TS's  RegGetMachinePolicy() and get the policy. But
    // that makes a lot of reg reads and I just don't want to slow down the
    // login cycle.
    // So, for now, I will read the reg policy tree directly.
    // 08/15/2000 AraBern
    //


    // see if there is a policy value:
    {
         DWORD dwType;
         DWORD perSessionTempDir;
         LONG  Err;
         HKEY  hKey;
         DWORD dwSize = sizeof(DWORD);

        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            TS_POLICY_SUB_TREE,
            0,
            KEY_QUERY_VALUE,
            &hKey);
    
        if(Err == ERROR_SUCCESS)
        {
                         
            Err = RegQueryValueEx(hKey,
                         REG_TERMSRV_PERSESSIONTEMPDIR ,
                         NULL,
                         &dwType,
                         (LPBYTE)&perSessionTempDir,
                         &dwSize);


            RegCloseKey(hKey);
            
            if(Err == ERROR_SUCCESS)
            {
                // if we have per session temp folders, then obviously we can't allow flat temp.
                if (perSessionTempDir ) 
                {
                    return FALSE;
                }
                // else is a fall thru, since not having per session does not mean having flat temp.

            }
            // else is a fall thru to the below block
    
        }
    }

    // by now we have no policy present, so if the flat temp is set.

    /*
     *  Open registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REG_CONTROL_TSERVER,
                       0,
                       KEY_READ,
                       &Handle ) != ERROR_SUCCESS ) {
        return FALSE;
    }

    /*
     *  Read registry value
     */
    rc = RegQueryValueExW( Handle,
                           REG_CITRIX_FLATTEMPDIR,
                           NULL,
                           &dwType,
                           (PUCHAR)&szValue,
                           &dwSize );

    szValue[(sizeof(szValue)/sizeof(szValue[0])) - 1] = L'\0';

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    return( (rc == ERROR_SUCCESS) && (lstrcmp(szValue,SZENABLE) == 0) );

} // end of QueryFlatTempKey()


// FROM regapi\reguc.c : this function has been modified to get rid of all
// registry accesses.
/*******************************************************************************
 *
 *  RegDefaultUserConfigQueryW (UNICODE)
 *
 *    Query the Default User Configuration from the indicated server's registry.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to access (NULL for current machine).
 *    pUserConfig (input)
 *       Pointer to a USERCONFIGW structure that will receive the default
 *       user configuration information.
 *    UserConfigLength (input)
 *       Specifies the length in bytes of the pUserConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pUserConfig buffer.
 *
 * EXIT:
 *    Always will return ERROR_SUCCESS, unless UserConfigLength is incorrect.
 *
 ******************************************************************************/

LONG WINAPI
RegDefaultUserConfigQueryW( WCHAR * pServerName,
                            PUSERCONFIGW pUserConfig,
                            ULONG UserConfigLength,
                            PULONG pReturnLength )
{
    UNREFERENCED_PARAMETER( pServerName );

    /*
     * Validate length and zero-initialize the destination
     * USERCONFIGW buffer.
     */
    if ( UserConfigLength < sizeof(USERCONFIGW) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Initialize to an initial default.
     */
    memset(pUserConfig, 0, UserConfigLength);

    pUserConfig->fInheritAutoLogon = TRUE;

    pUserConfig->fInheritResetBroken = TRUE;

    pUserConfig->fInheritReconnectSame = TRUE;

    pUserConfig->fInheritInitialProgram = TRUE;

    pUserConfig->fInheritCallback = FALSE;

    pUserConfig->fInheritCallbackNumber = TRUE;

    pUserConfig->fInheritShadow = TRUE;

    pUserConfig->fInheritMaxSessionTime = TRUE;

    pUserConfig->fInheritMaxDisconnectionTime = TRUE;

    pUserConfig->fInheritMaxIdleTime = TRUE;

    pUserConfig->fInheritAutoClient = TRUE;

    pUserConfig->fInheritSecurity = FALSE;

    pUserConfig->fPromptForPassword = FALSE;

    pUserConfig->fResetBroken = FALSE;

    pUserConfig->fReconnectSame = FALSE;

    pUserConfig->fLogonDisabled = FALSE;

    pUserConfig->fAutoClientDrives = TRUE;

    pUserConfig->fAutoClientLpts = TRUE;

    pUserConfig->fForceClientLptDef = TRUE;

    pUserConfig->fDisableEncryption = TRUE;

    pUserConfig->fHomeDirectoryMapRoot = FALSE;

    pUserConfig->fUseDefaultGina = FALSE;

    pUserConfig->fDisableCpm = FALSE;

    pUserConfig->fDisableCdm = FALSE;

    pUserConfig->fDisableCcm = FALSE;

    pUserConfig->fDisableLPT = FALSE;

    pUserConfig->fDisableClip = FALSE;

    pUserConfig->fDisableExe = FALSE;

    pUserConfig->fDisableCam = FALSE;

    pUserConfig->UserName[0] = 0;

    pUserConfig->Domain[0] = 0;

    pUserConfig->Password[0] = 0;

    pUserConfig->WorkDirectory[0] = 0;

    pUserConfig->InitialProgram[0] = 0;

    pUserConfig->CallbackNumber[0] = 0;

    pUserConfig->Callback = Callback_Disable;

    pUserConfig->Shadow = Shadow_EnableInputNotify;

    pUserConfig->MaxConnectionTime = 0;

    pUserConfig->MaxDisconnectionTime = 0;

    pUserConfig->MaxIdleTime = 0;

    pUserConfig->KeyboardLayout = 0;

    pUserConfig->MinEncryptionLevel = 1;

    pUserConfig->fWallPaperDisabled = FALSE;

    pUserConfig->NWLogonServer[0] = 0;

    pUserConfig->WFProfilePath[0] = 0;

    pUserConfig->WFHomeDir[0] = 0;

    pUserConfig->WFHomeDirDrive[0] = 0;
    
    pUserConfig->fCursorBlinkDisabled = FALSE;

    *pReturnLength = sizeof(USERCONFIGW);

    return( ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\security.c ===
/*************************************************************************
*
* security.c
*
* NT Security routines
*
* copyright notice: Copyright 1997, Microsoft
*
*************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <ntseapi.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <windows.h>
#include <string.h>
#include <wcstr.h>
#include "seopaque.h"
#include "sertlp.h"

#include <process.h>

#include <winsta.h>
#include <syslib.h>
#include <lmcons.h> // for DNLEN  KLB 09-18-96

#include "security.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

typedef struct _SIDLIST {
    struct _SIDLIST *Next;
    USHORT          SidCrc;
    PWCHAR          pAccountName;
    PWCHAR          pDomainName;
} SIDLIST, *PSIDLIST;

static PSIDLIST SidCache = NULL;

// Computer Name
WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH+1];

// Admins only ACL
PACL  pAdminsOnlyAcl = NULL;
DWORD AdminsOnlyAclSize = 0;

//
// Universal well known SIDs
//

PSID  SeNullSid;
PSID  SeWorldSid;
PSID  SeLocalSid;
PSID  SeCreatorOwnerSid;
PSID  SeCreatorGroupSid;

//
// Sids defined by NT
//

PSID SeNtAuthoritySid;
PSID SeDialupSid;
PSID SeNetworkSid;
PSID SeBatchSid;
PSID SeInteractiveSid;
PSID SeServiceSid;
PSID SeLocalGuestSid;
PSID SeLocalSystemSid;
PSID SeLocalAdminSid;
PSID SeLocalManagerSid;
PSID SeAliasAdminsSid;
PSID SeAliasUsersSid;
PSID SeAliasGuestsSid;
PSID SeAliasPowerUsersSid;
PSID SeAliasAccountOpsSid;
PSID SeAliasSystemOpsSid;
PSID SeAliasPrintOpsSid;
PSID SeAliasBackupOpsSid;
PSID SeAliasReplicatorSid;

static SID_IDENTIFIER_AUTHORITY    SepNullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepWorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepLocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepCreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepNtAuthority = SECURITY_NT_AUTHORITY;

//
// Sid of primary domain, and admin account in that domain
//

PSID SepPrimaryDomainSid;
PSID SepPrimaryDomainAdminSid;


// External data
extern ADMIN_ACCOUNTS AllowAccounts[];
extern DWORD AllowAccountEntries;
extern ACCESS_MASK AllowAccess;

extern ADMIN_ACCOUNTS DenyAccounts[];
extern DWORD DenyAccountEntries;
extern ACCESS_MASK DeniedAccess;


// Forward and external references

BOOLEAN
InitializeBuiltinSids();

BOOL
LoadAccountSids();

BOOL
BuildSecureAcl();

BOOL
xxxLookupBuiltinAccount(
    PWCHAR pSystemName,
    PWCHAR pAccountName,
    PSID   *ppSid
    );

BOOL
GetCurrentUserSid( PSID *ppSid );


/*****************************************************************************
 *
 *  InitSecurity
 *
 *   Initialize the security package
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   TRUE  - no error
 *   FALSE - error
 *
 ****************************************************************************/

BOOL
InitSecurity(
    )
{
    BOOL rc;
    DWORD Size = sizeof(ComputerName)/sizeof(WCHAR);

    rc = GetComputerNameW( ComputerName, &Size );
    if( !rc ) {
        DBGPRINT(("***ERROR*** %d Could not get computer name\n",GetLastError() ));
        return( FALSE );
    }

    rc = InitializeBuiltinSids();
    if( !rc ) {
        DBGPRINT(("***ERROR*** Some built-in accounts not loaded\n"));
        return( FALSE );
    }

    rc = LoadAccountSids();
    if( !rc ) {
        DBGPRINT(("***ERROR*** Some accounts not loaded\n"));
        return( FALSE );
    }

    rc = BuildSecureAcl();
    if( !rc ) {
        DBGPRINT(("***ERROR*** Could not build ACL\n"));
        return( FALSE );
    }

    return( TRUE );
}

/*****************************************************************************
 *
 *  LoadAccountSids
 *
 *   Load the list of account access SIDS.
 *
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
LoadAccountSids()
{
    BOOL rc, Final;
    NTSTATUS Status;
    SID_IDENTIFIER_AUTHORITY gSystemSidAuthority = SECURITY_NT_AUTHORITY;

    Final = TRUE;

    //
    // Get the SID's for all of the allow accounts
    //

    //
    // Get the SID of the built-in Administrators group
    //

    Status = RtlAllocateAndInitializeSid(
                     &gSystemSidAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,0,0,0,0,0,
                     &(AllowAccounts[ADMIN_ACCOUNT].pSid));
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("SYSLIB: Couldn't allocate Administrators SID (0x%x)\n", Status ));
        Final = FALSE;
    }

    //
    // SYSTEM
    //

    Status = RtlAllocateAndInitializeSid(
                     &gSystemSidAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,0,0,0,0,0,0,
                     &(AllowAccounts[SYSTEM_ACCOUNT].pSid));
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("SYSLIB: Couldn't allocate SYSTEM SID (0x%x)\n", Status ));
        Final = FALSE;
    }

    //
    // Get the current user's Sid
    //
    //First, see if we run in SYSTEM context.
    //If we do, get current user SID from TERMSRV, otherwise use a user SID from process token.
    Final = FALSE;

    {
        HANDLE hToken;
        PTOKEN_USER pTokenUser = NULL;
        DWORD dwInfoLength = 0;

        if(OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&hToken))
        {
            GetTokenInformation(hToken,TokenUser,pTokenUser,dwInfoLength,&dwInfoLength);

            if(dwInfoLength)
            {
                pTokenUser = (PTOKEN_USER)LocalAlloc(LPTR,dwInfoLength);
                if(pTokenUser) 
                {
                    if(GetTokenInformation(hToken,TokenUser,pTokenUser,dwInfoLength,&dwInfoLength))
                    {
                        if(EqualSid(AllowAccounts[SYSTEM_ACCOUNT].pSid,pTokenUser->User.Sid))
                        {
                             rc = xxxLookupAccountName(
                                     ComputerName,
                                     CURRENT_USER,
                                     &(AllowAccounts[USER_ACCOUNT].pSid)
                                     );

                            if ( !rc ) 
                            {
                                // It might be a special builtin account
                                rc = xxxLookupBuiltinAccount(
                                     ComputerName,
                                     CURRENT_USER,
                                     &(AllowAccounts[USER_ACCOUNT].pSid)
                                     );

                                if( !rc ) 
                                {
                                    DBGPRINT(("***WARNING*** Could not find SID for current user account, Error %d\n", GetLastError() ));
                                }
                            }
                            if( rc )
                            {
                                Final = TRUE;
                            }
                        }
                        else
                        {
                            DWORD dwSidLength = GetLengthSid(pTokenUser->User.Sid);
                            AllowAccounts[USER_ACCOUNT].pSid = (PSID)LocalAlloc(LPTR,dwSidLength);
                            if(AllowAccounts[USER_ACCOUNT].pSid)
                            {
                                CopyMemory(AllowAccounts[USER_ACCOUNT].pSid,pTokenUser->User.Sid,dwSidLength);
                                Final = TRUE;
                            }
                            
                        }
                    }
                    LocalFree(pTokenUser);
                }
            }

            CloseHandle(hToken);
        }
    }

#ifdef notdef
    //
    // Lookup the SID's for all of the deny accounts
    //

    for( Index = 0; Index < DenyAccountEntries; Index++ ) {

        p = &DenyAccounts[Index];

        rc = xxxLookupAccountName(
                 ComputerName,
                 p->Name,
                 &p->pSid
                 );

        if( !rc ) {
            // It might be a special builtin account
            rc = xxxLookupBuiltinAccount(
                     ComputerName,
                     p->Name,
                     &p->pSid
                     );

            if( !rc ) {
                DBGPRINT(("***WARNING*** Could not find SID for account %ws Error %d\n",p->Name,GetLastError() ));
                Final = FALSE;
            }
        }
    }
#endif

    // Lower level function outputs if any accounts are invalid

    return( Final );
}

/*****************************************************************************
 *
 *  IsAllowSid
 *
 *   Returns whether the supplied SID is in the allow group
 *
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
IsAllowSid(
    PSID pSid
    )
{
    DWORD Index;
    PADMIN_ACCOUNTS p;
    BOOL  AllowSid = FALSE;

    for( Index = 0; Index < AllowAccountEntries; Index++ ) {

        p = &AllowAccounts[Index];

        if( p->pSid && EqualSid( pSid, p->pSid ) ) {
            // The Sid is for an allowed account
            AllowSid = TRUE;
            break;
        }
    }

    return( AllowSid );
}


/*****************************************************************************
 *
 *  xxxLookupAccountName
 *
 *   Wrapper to lookup the SID for a given account name
 *
 *   Returns a pointer to the SID in newly allocated memory
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
xxxLookupAccountName(
    PWCHAR pSystemName,
    PWCHAR pAccountName,
    PSID   *ppSid
    )
{
    BOOL  rc;
    DWORD Size, DomainSize, Error;
    SID_NAME_USE Type;
    PWCHAR pDomain = NULL;
    PSID pSid = NULL;
    WCHAR Buf;
    WCHAR pCurrentUser[MAX_ACCOUNT_NAME];   // KLB 09-16-96
    DWORD dwCurrentUser = MAX_ACCOUNT_NAME; // KLB 09-16-96
    WCHAR pAccountToLookup[MAX_ACCOUNT_NAME+DNLEN+1]; // KLB 09-18-96
    LPWSTR pLogon32DomainName = NULL; // KLB 09-19-96
    WINSTATIONINFORMATION WinInfo; // KLB 09-30-96
    ULONG ReturnLength; // KLB 09-30-96

    Size = 0;
    DomainSize = 0;

    /*
     * Open the WinStation and Query its information.
     */
    memset( &WinInfo,    0, sizeof(WINSTATIONINFORMATION) );
    rc = WinStationQueryInformation( SERVERNAME_CURRENT,
                                     LOGONID_CURRENT,
                                     WinStationInformation,
                                     (PVOID)&WinInfo,
                                     sizeof(WINSTATIONINFORMATION),
                                     &ReturnLength );
    if ( !rc ) {
        DBGPRINT(("error querying winstation information %d.\n", GetLastError() ));
        return( FALSE );
    }
    if( ReturnLength != sizeof(WINSTATIONINFORMATION) ) {
        DBGPRINT(("winstation info version mismatch!\n"));
        return( FALSE );
    }

    if (lstrcmpi(pAccountName,CURRENT_USER) == 0) {
       lstrcpy( pAccountToLookup, WinInfo.Domain );
       lstrcat( pAccountToLookup, L"\\" );
       lstrcat( pAccountToLookup, WinInfo.UserName );
    } else {
       lstrcpy( pAccountToLookup, pAccountName );
    }
    DBGPRINT(( "looking up account %ws\n", pAccountToLookup ));

    rc = LookupAccountNameW(
             pSystemName,
             pAccountToLookup, // KLB 09-16-96
             &Buf,    // pSid
             &Size,
             &Buf,    // pDomain
             &DomainSize,
             &Type
             );

    if( rc ) {
        DBGPRINT(("Internal error on account name %ws\n",pAccountToLookup));
        return( FALSE );
    }
    else {
        Error = GetLastError();
        if( Error != ERROR_INSUFFICIENT_BUFFER ) {
            DBGPRINT(("***ERROR*** %d looking up SID for account name %ws skipped without processing!\n",Error,pAccountToLookup));
            return( FALSE );
        }

        pSid = LocalAlloc( LMEM_FIXED, Size );
        if( pSid == NULL ) {
            DBGPRINT(("***ERROR*** Out of memory, skipped account %ws without processing!\n",pAccountToLookup));
            return( FALSE );
        }

        pDomain = LocalAlloc( LMEM_FIXED, DomainSize*sizeof(WCHAR) );
        if( pDomain == NULL ) {
            DBGPRINT(("***ERROR*** Out of memory, skipped account %ws without processing!\n",pAccountToLookup));
            LocalFree( pSid );
            return( FALSE );
        }

        rc = LookupAccountNameW(
                 pSystemName,
                 pAccountToLookup,
                 pSid,
                 &Size,
                 pDomain,
                 &DomainSize,
                 &Type
                 );

        if( !rc ) {
            DBGPRINT(("***ERROR*** %d looking up SID for account name %ws skipped without processing!\n",Error,pAccountToLookup));
            LocalFree( pSid );
            LocalFree( pDomain );
            return( FALSE );
        }

        *ppSid = pSid;

        LocalFree( pDomain );
        DBGPRINT(( "leaving xxxLookupAccountName(); pSid is okay, returning TRUE.\n" ));
        return( TRUE );
    }
}

/*****************************************************************************
 *
 *  InitializeBuiltinSids
 *
 *   Initialize the built in SIDS
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
InitializeBuiltinSids()
{

    ULONG SidWithZeroSubAuthorities;
    ULONG SidWithOneSubAuthority;
    ULONG SidWithTwoSubAuthorities;
    ULONG SidWithThreeSubAuthorities;

    SID_IDENTIFIER_AUTHORITY NullSidAuthority;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority;
    SID_IDENTIFIER_AUTHORITY SeNtAuthority;

    NullSidAuthority         = SepNullSidAuthority;
    WorldSidAuthority        = SepWorldSidAuthority;
    LocalSidAuthority        = SepLocalSidAuthority;
    CreatorSidAuthority      = SepCreatorSidAuthority;
    SeNtAuthority            = SepNtAuthority;

    //
    //  The following SID sizes need to be allocated
    //

    SidWithZeroSubAuthorities  = RtlLengthRequiredSid( 0 );
    SidWithOneSubAuthority     = RtlLengthRequiredSid( 1 );
    SidWithTwoSubAuthorities   = RtlLengthRequiredSid( 2 );
    SidWithThreeSubAuthorities = RtlLengthRequiredSid( 3 );

    //
    //  Allocate and initialize the universal SIDs
    //

    SeNullSid         = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, SidWithOneSubAuthority);
    SeWorldSid        = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, SidWithOneSubAuthority);
    SeLocalSid        = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, SidWithOneSubAuthority);
    SeCreatorOwnerSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, SidWithOneSubAuthority);
    SeCreatorGroupSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, SidWithOneSubAuthority);

    //
    // Fail initialization if we didn't get enough memory for the universal
    // SIDs.
    //

    if ( (SeNullSid         == NULL) ||
         (SeWorldSid        == NULL) ||
         (SeLocalSid        == NULL) ||
         (SeCreatorOwnerSid == NULL) ||
         (SeCreatorGroupSid == NULL)
       ) {

        return( FALSE );
    }

    RtlInitializeSid( SeNullSid,         &NullSidAuthority, 1 );
    RtlInitializeSid( SeWorldSid,        &WorldSidAuthority, 1 );
    RtlInitializeSid( SeLocalSid,        &LocalSidAuthority, 1 );
    RtlInitializeSid( SeCreatorOwnerSid, &CreatorSidAuthority, 1 );
    RtlInitializeSid( SeCreatorGroupSid, &CreatorSidAuthority, 1 );

    *(RtlSubAuthoritySid( SeNullSid, 0 ))         = SECURITY_NULL_RID;
    *(RtlSubAuthoritySid( SeWorldSid, 0 ))        = SECURITY_WORLD_RID;
    *(RtlSubAuthoritySid( SeLocalSid, 0 ))        = SECURITY_LOCAL_RID;
    *(RtlSubAuthoritySid( SeCreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID;
    *(RtlSubAuthoritySid( SeCreatorGroupSid, 0 )) = SECURITY_CREATOR_GROUP_RID;

    //
    // Allocate and initialize the NT defined SIDs
    //

    SeNtAuthoritySid  = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithZeroSubAuthorities);
    SeDialupSid       = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeNetworkSid      = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeBatchSid        = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeInteractiveSid  = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeServiceSid      = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeLocalGuestSid   = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeLocalSystemSid  = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeLocalAdminSid   = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeLocalManagerSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);

    SeAliasAdminsSid     = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasUsersSid      = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasGuestsSid     = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasPowerUsersSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasAccountOpsSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasSystemOpsSid  = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasPrintOpsSid   = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasBackupOpsSid  = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasReplicatorSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);


    //
    // Fail initialization if we didn't get enough memory for the NT SIDs.
    //

    if ( (SeNtAuthoritySid      == NULL) ||
         (SeDialupSid           == NULL) ||
         (SeNetworkSid          == NULL) ||
         (SeBatchSid            == NULL) ||
         (SeInteractiveSid      == NULL) ||
         (SeServiceSid          == NULL) ||
         (SeLocalGuestSid       == NULL) ||
         (SeLocalSystemSid      == NULL) ||
         (SeLocalAdminSid       == NULL) ||
         (SeLocalManagerSid     == NULL) ||
         (SeAliasAdminsSid      == NULL) ||
         (SeAliasUsersSid       == NULL) ||
         (SeAliasGuestsSid      == NULL) ||
         (SeAliasPowerUsersSid  == NULL) ||
         (SeAliasAccountOpsSid  == NULL) ||
         (SeAliasSystemOpsSid   == NULL) ||
         (SeAliasReplicatorSid  == NULL) ||
         (SeAliasPrintOpsSid    == NULL) ||
         (SeAliasBackupOpsSid   == NULL)
       ) {

        return( FALSE );
    }

    RtlInitializeSid( SeNtAuthoritySid,     &SeNtAuthority, 0 );
    RtlInitializeSid( SeDialupSid,          &SeNtAuthority, 1 );
    RtlInitializeSid( SeNetworkSid,         &SeNtAuthority, 1 );
    RtlInitializeSid( SeBatchSid,           &SeNtAuthority, 1 );
    RtlInitializeSid( SeInteractiveSid,     &SeNtAuthority, 1 );
    RtlInitializeSid( SeServiceSid,         &SeNtAuthority, 1 );
    RtlInitializeSid( SeLocalGuestSid,      &SeNtAuthority, 1 );
    RtlInitializeSid( SeLocalSystemSid,     &SeNtAuthority, 1 );
    RtlInitializeSid( SeLocalAdminSid,      &SeNtAuthority, 1 );
    RtlInitializeSid( SeLocalManagerSid,    &SeNtAuthority, 1 );

    RtlInitializeSid( SeAliasAdminsSid,     &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasUsersSid,      &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasGuestsSid,     &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasPowerUsersSid, &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasAccountOpsSid, &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasSystemOpsSid,  &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasPrintOpsSid,   &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasBackupOpsSid,  &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasReplicatorSid, &SeNtAuthority, 2);


    *(RtlSubAuthoritySid( SeDialupSid,          0 )) = SECURITY_DIALUP_RID;
    *(RtlSubAuthoritySid( SeNetworkSid,         0 )) = SECURITY_NETWORK_RID;
    *(RtlSubAuthoritySid( SeBatchSid,           0 )) = SECURITY_BATCH_RID;
    *(RtlSubAuthoritySid( SeInteractiveSid,     0 )) = SECURITY_INTERACTIVE_RID;
    *(RtlSubAuthoritySid( SeServiceSid,         0 )) = SECURITY_SERVICE_RID;
//    *(RtlSubAuthoritySid( SeLocalGuestSid,      0 )) = SECURITY_LOCAL_GUESTS_RID;
    *(RtlSubAuthoritySid( SeLocalSystemSid,     0 )) = SECURITY_LOCAL_SYSTEM_RID;
//    *(RtlSubAuthoritySid( SeLocalAdminSid,      0 )) = SECURITY_LOCAL_ADMIN_RID;
//    *(RtlSubAuthoritySid( SeLocalManagerSid,    0 )) = SECURITY_LOCAL_MANAGER_RID;


    *(RtlSubAuthoritySid( SeAliasAdminsSid,     0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasUsersSid,      0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasGuestsSid,     0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasPowerUsersSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasAccountOpsSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasSystemOpsSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasPrintOpsSid,   0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasBackupOpsSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasReplicatorSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;

    *(RtlSubAuthoritySid( SeAliasAdminsSid,     1 )) = DOMAIN_ALIAS_RID_ADMINS;
    *(RtlSubAuthoritySid( SeAliasUsersSid,      1 )) = DOMAIN_ALIAS_RID_USERS;
    *(RtlSubAuthoritySid( SeAliasGuestsSid,     1 )) = DOMAIN_ALIAS_RID_GUESTS;
    *(RtlSubAuthoritySid( SeAliasPowerUsersSid, 1 )) = DOMAIN_ALIAS_RID_POWER_USERS;
    *(RtlSubAuthoritySid( SeAliasAccountOpsSid, 1 )) = DOMAIN_ALIAS_RID_ACCOUNT_OPS;
    *(RtlSubAuthoritySid( SeAliasSystemOpsSid,  1 )) = DOMAIN_ALIAS_RID_SYSTEM_OPS;
    *(RtlSubAuthoritySid( SeAliasPrintOpsSid,   1 )) = DOMAIN_ALIAS_RID_PRINT_OPS;
    *(RtlSubAuthoritySid( SeAliasBackupOpsSid,  1 )) = DOMAIN_ALIAS_RID_BACKUP_OPS;
    *(RtlSubAuthoritySid( SeAliasReplicatorSid, 1 )) = DOMAIN_ALIAS_RID_REPLICATOR;

    return( TRUE );
}


/*****************************************************************************
 *
 *  xxxLookupBuiltinAccount
 *
 *   Wrapper to lookup the SID for a given built in account name
 *
 *   Returns a pointer to the SID in newly allocated memory
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
xxxLookupBuiltinAccount(
    PWCHAR pSystemName,
    PWCHAR pAccountName,
    PSID   *ppSid
    )
{
    USHORT SidLen;
    SID_NAME_USE Type;
    PSID pSid = NULL;

    if( _wcsicmp( L"NULL_SID", pAccountName ) == 0 ) {
        pSid = SeNullSid;
        Type = SidTypeInvalid;
    }

    if( pSid == NULL ) {
        SetLastError( ERROR_NONE_MAPPED );
        return( FALSE );
    }

    SidLen = (USHORT)GetLengthSid( pSid );
    *ppSid = LocalAlloc(LMEM_FIXED, SidLen );
    if( *ppSid == NULL ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return( FALSE );
    }

    RtlMoveMemory( *ppSid, pSid, SidLen );

    return( TRUE );

#ifdef notdef

    if( EqualSid( SeNullSid, pSid ) ) {
        pName = L"NULL_SID";
        Type = SidTypeInvalid;
    }

    if( EqualSid( SeWorldSid, pSid ) ) {
        pName = L"WORLD";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeLocalSid, pSid ) ) {
        pName = L"LOCAL_ACCOUNT";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeCreatorOwnerSid, pSid ) ) {
        pName = L"CREATOR_OWNER";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeCreatorGroupSid, pSid ) ) {
        pName = L"CREATOR_GROUP";
        Type = SidTypeWellKnownGroup;
    }

    //
    // Look at the NT SIDS
    //

    if( EqualSid( SeNtAuthoritySid, pSid ) ) {
        pName = L"NTAUTHORITY";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeDialupSid, pSid ) ) {
        pName = L"DIALUP";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeNetworkSid, pSid ) ) {
        pName = L"NETWORK";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeBatchSid, pSid ) ) {
        pName = L"BATCH";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeInteractiveSid, pSid ) ) {
        pName = L"INTERACTIVE";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeServiceSid, pSid ) ) {
        pName = L"SERVICE";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeLocalGuestSid, pSid ) ) {
        pName = L"LOCALGUEST";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeLocalSystemSid, pSid ) ) {
        pName = L"LOCALSYSTEM";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeLocalAdminSid, pSid ) ) {
        pName = L"LOCALADMIN";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeLocalManagerSid, pSid ) ) {
        pName = L"LOCALMANAGER";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeAliasAdminsSid, pSid ) ) {
        pName = L"ALIAS_ADMINS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasUsersSid, pSid ) ) {
        pName = L"ALIAS_USERS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasGuestsSid, pSid ) ) {
        pName = L"ALIAS_GUESTS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasPowerUsersSid, pSid ) ) {
        pName = L"ALIAS_POWERUSERS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasAccountOpsSid, pSid ) ) {
        pName = L"ALIAS_ACCOUNT_OPS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasSystemOpsSid, pSid ) ) {
        pName = L"ALIAS_SYSTEM_OPS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasPrintOpsSid, pSid ) ) {
        pName = L"ALIAS_PRINT_OPS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasBackupOpsSid, pSid ) ) {
        pName = L"ALIAS_BACKUP_OPS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasReplicatorSid, pSid ) ) {
        pName = L"ALIAS_REPLICATOR";
        Type = SidTypeAlias;
    }
#endif
}

/*****************************************************************************
 *
 *  GetSecureAcl
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PACL
GetSecureAcl()
{
    return( pAdminsOnlyAcl );
}

/*****************************************************************************
 *
 *  BuildSecureAcl
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
BuildSecureAcl()
{
    BOOL  rc;
    DWORD Index, Error;
    PADMIN_ACCOUNTS p;
    DWORD AclSize;
    PACL  pAcl = NULL;
    PACCESS_ALLOWED_ACE pAce = NULL;

    /*
     * Calculate the ACL size
     */
    AclSize = sizeof(ACL);

    //
    // Reserve memory for the deny ACE's
    //
    for( Index = 0; Index < DenyAccountEntries; Index++ ) {

        p = &DenyAccounts[Index];

        if( p->pSid ) {
            AclSize += sizeof(ACCESS_DENIED_ACE);
            AclSize += (GetLengthSid( p->pSid ) - sizeof(DWORD));
        }
    }

    //
    // Reserve memory for the allowed ACE's
    //
    for( Index = 0; Index < AllowAccountEntries; Index++ ) {

        p = &AllowAccounts[Index];

        if( p->pSid ) {
            AclSize += sizeof(ACCESS_ALLOWED_ACE);
            AclSize += (GetLengthSid( p->pSid ) - sizeof(DWORD));
        }
    }

    pAcl = LocalAlloc( LMEM_FIXED, AclSize );
    if( pAcl == NULL ) {
        DBGPRINT(("Could not allocate memory\n"));
        return( FALSE );
    }

    rc = InitializeAcl(
             pAcl,
             AclSize,
             ACL_REVISION
             );

    if( !rc ) {
        DBGPRINT(("Error %d InitializeAcl\n",GetLastError()));
        LocalFree( pAcl );
        return( FALSE );
    }

    /*
     * Add a deny all ACE for each account in the deny list
     */
    for( Index = 0; Index < DenyAccountEntries; Index++ ) {

        p = &DenyAccounts[Index];

        rc = AddAccessDeniedAce(
                 pAcl,
                 ACL_REVISION,
                 FILE_ALL_ACCESS,
                 p->pSid
                 );

        if( !rc ) {
            Error = GetLastError();
            DBGPRINT(("***ERROR*** adding deny ACE %d for account %ws\n",Error,p->Name));
        }
    }

    /*
     * Add an allow all ACE for each account in the allow list
     */
    for( Index = 0; Index < AllowAccountEntries; Index++ ) {

        p = &AllowAccounts[Index];

        rc = AddAccessAllowedAce(
                 pAcl,
                 ACL_REVISION,
                 FILE_ALL_ACCESS,
                 p->pSid
                 );

        if( !rc ) {
            Error = GetLastError();
            DBGPRINT(("***ERROR*** adding allow ACE %d for account %ws\n",Error,p->Name));
        }
    }

    pAdminsOnlyAcl = pAcl;
    AdminsOnlyAclSize = AclSize;

    //
    // Put the inherit flags on the ACE's
    //
    for( Index=0; Index < pAcl->AceCount; Index++ ) {

        rc = GetAce( pAcl, Index, (PVOID)&pAce );
        if( !rc ) {
            continue;
        }

        pAce->Header.AceFlags |= (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE);
   }

   return( TRUE );
}

/*****************************************************************************
 *
 *  GetLocalAdminSid
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PSID
GetLocalAdminSid()
{
    return( SeLocalAdminSid );
}

/*****************************************************************************
 *
 *  GetAdminSid
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *
 ****************************************************************************/

PSID
GetAdminSid()
{
    return( AllowAccounts[ADMIN_ACCOUNT].pSid );
}

/*****************************************************************************
 *
 *  GetLocalAdminGroupSid
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PSID
GetLocalAdminGroupSid()
{
    return( SeAliasAdminsSid );
}


/*****************************************************************************
 *
 *  GetLocalAdminGroupSid
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL CheckUserSid()
{
    BOOL rc;
    PSID pSid;
    PSID pPrevSid;

    rc = xxxLookupAccountName(
         ComputerName,
         AllowAccounts[USER_ACCOUNT].Name,
         &pSid
         );

    if( !rc ) {
        // It might be a special builtin account
        rc = xxxLookupBuiltinAccount(
                 ComputerName,
                 AllowAccounts[USER_ACCOUNT].Name,
                 &pSid
                 );
    }

    pPrevSid = AllowAccounts[USER_ACCOUNT].pSid;
    if (rc && (!pPrevSid || !EqualSid( pSid, pPrevSid ))) {
        AllowAccounts[USER_ACCOUNT].pSid = pSid;
        if (pAdminsOnlyAcl) {
            LocalFree( pAdminsOnlyAcl );
            pAdminsOnlyAcl = NULL;
            AdminsOnlyAclSize = 0;
        }
        rc = BuildSecureAcl();
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\security.h ===
/*
 * List of accounts we allow file access for
 */
#define MAX_ACCOUNT_NAME 32
#define CURRENT_USER L"%user%"

// These are the accounts we want to have access to the directory
#define ADMIN_ACCOUNT  0
#define SYSTEM_ACCOUNT 1
#define USER_ACCOUNT   2

typedef struct _ADMIN_ACCOUNTS {
    WCHAR Name[MAX_ACCOUNT_NAME];
    PSID  pSid;
} ADMIN_ACCOUNTS, *PADMIN_ACCOUNTS;

/*
 * Operation result codes to allow a separate reporting module
 */
typedef enum _FILE_RESULT {
    FileOk,                   // File can not be written by users
    FileAccessError,          // Error occured, disposition unknown
    FileAccessErrorUserFormat // Error, user formatted message
} FILE_RESULT;

BOOL
InitSecurity(
    );

BOOL
IsAllowSid(
    PSID pSid
    );

BOOL
xxxLookupAccountName(
    PWCHAR pSystemName,
    PWCHAR pAccountName,
    PSID   *ppSid
    );

BOOLEAN
SetFileTree(
    PWCHAR   pRoot,
    PWCHAR   pAvoidDir
    );

BOOL
ReportFileResult(
    FILE_RESULT Code,
    ACCESS_MASK Access,
    PWCHAR      pFile,
    PWCHAR      pAccountName,
    PWCHAR      pDomainName,
    PCHAR       UserFormat,
    ...
    );

PACL
GetSecureAcl();

PSID
GetLocalAdminSid();

PSID
GetAdminSid();

PSID
GetLocalAdminGroupSid();

BOOL
CheckUserSid();

#if DBG
void
DumpSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSD
    );

void
DumpAcl(
    PACL   pAcl,
    PCHAR  pBase,
    PULONG pSize
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\secutil.c ===
/*************************************************************************
*
* secutil.c
*
* Security Related utility functions
*
* copyright notice: Copyright 1998, Microsoft.
*
*
*
*************************************************************************/

// Include NT headers
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include "windows.h"
#include <winsta.h>
#include <syslib.h>


/*****************************************************************************
 *
 *  TestUserForAdmin
 *
 *   Returns whether the current thread is running under admin
 *   security.
 *
 * ENTRY:
 *
 * EXIT:
 *   TRUE/FALSE - whether user is specified admin
 *
 ****************************************************************************/

BOOL 
TestUserForAdmin( VOID )
{
    BOOL IsMember, IsAnAdmin;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    PSID AdminSid;


    IsAnAdmin = FALSE;

    if (NT_SUCCESS(RtlAllocateAndInitializeSid(
                                     &SystemSidAuthority,
                                     2,
                                     SECURITY_BUILTIN_DOMAIN_RID,
                                     DOMAIN_ALIAS_RID_ADMINS,
                                     0, 0, 0, 0, 0, 0,
                                     &AdminSid
                                     ) ) )
    {
        CheckTokenMembership( NULL,
                              AdminSid,
                              &IsAnAdmin);
        RtlFreeSid(AdminSid);
    }

    return IsAnAdmin;

}



/*****************************************************************************
 *
 *  TestUserForGroup
 *
 *   Returns whether the current thread is a member of the requested group.
 *
 * ENTRY:
 *   pwszGrouName (input)
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/
/* unused
BOOL
TestUserForGroup( PWCHAR pwszGroupName )
{
    HANDLE Token;
    ULONG InfoLength;
    PTOKEN_GROUPS TokenGroupList;
    ULONG GroupIndex;
    BOOL GroupMember = FALSE;
    PSID pGroupSid = NULL;
    DWORD cbGroupSid = 0;
    NTSTATUS Status;
    PWCHAR pwszDomain = NULL;
    DWORD cbDomain = 0;
    SID_NAME_USE peUse;

    //
    // Open current thread/process token
    //
    Status = NtOpenThreadToken( NtCurrentThread(), TOKEN_QUERY, FALSE, &Token );
    if ( !NT_SUCCESS( Status ) ) {
        Status = NtOpenProcessToken( NtCurrentProcess(), TOKEN_QUERY, &Token );
        if ( !NT_SUCCESS( Status ) ) {
            return( FALSE );
        }
    }

    //
    // Retrieve the requested sid
    //
    if ( !LookupAccountNameW( NULL, 
                              pwszGroupName,
                              pGroupSid, 
                              &cbGroupSid,
                              pwszDomain, 
                              &cbDomain,
                              &peUse ) ) {

        //
        //  other eror
        //
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER  ) {
            NtClose(Token);
            return(FALSE);
        }

        //
        //  alloc group sid
        //
        pGroupSid = LocalAlloc(LPTR, cbGroupSid);
        if (pGroupSid == NULL) {
            NtClose(Token);
            return(FALSE);
        }
    
        //
        //  alloc domain name
        //
        cbDomain *= sizeof(WCHAR);
        pwszDomain = LocalAlloc(LPTR, cbDomain);
        if (pwszDomain == NULL) {
            LocalFree(pGroupSid);
            NtClose(Token);
            return(FALSE);
        }
    
        //
        // Retrieve the requested sid 
        //
        if ( !LookupAccountNameW( NULL, 
                                  pwszGroupName,
                                  pGroupSid, 
                                  &cbGroupSid,
                                  pwszDomain, 
                                  &cbDomain,
                                  &peUse ) ) {
            LocalFree(pGroupSid);
            LocalFree(pwszDomain);
            NtClose( Token );
            return( FALSE );
        }
    }
    else {
#if DBG
        DbgPrint("***ERROR*** this path should never get hit\n");
#endif
        NtClose( Token );
        return( FALSE );
    }

    ASSERT(pGroupSid != NULL);
    ASSERT(pwszDomain != NULL);

    //
    // Get a list of groups in the token
    //
    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenGroups,              // TokenInformationClass
                 NULL,                     // TokenInformation
                 0,                        // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );
    if ((Status != STATUS_SUCCESS) && (Status != STATUS_BUFFER_TOO_SMALL)) {
        LocalFree(pwszDomain);
        LocalFree(pGroupSid);
        NtClose(Token);
        return( FALSE );
    }

    TokenGroupList = LocalAlloc(LPTR, InfoLength);
    if (TokenGroupList == NULL) {
        LocalFree(pwszDomain);
        LocalFree(pGroupSid);
        NtClose(Token);
        return(FALSE);
    }

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenGroups,              // TokenInformationClass
                 TokenGroupList,           // TokenInformation
                 InfoLength,               // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );
    if (!NT_SUCCESS(Status)) {
        LocalFree(TokenGroupList);
        LocalFree(pwszDomain);
        LocalFree(pGroupSid);
        NtClose(Token);
        return(FALSE);
    }

    //
    // Search group list for membership
    //
    GroupMember = FALSE;
    for (GroupIndex=0; GroupIndex < TokenGroupList->GroupCount; GroupIndex++ ) {
        if (RtlEqualSid(TokenGroupList->Groups[GroupIndex].Sid, pGroupSid)) {
            GroupMember = TRUE;
            break;
        }
    }

    //
    // Tidy up
    //
    LocalFree(TokenGroupList);
    LocalFree(pwszDomain);
    LocalFree(pGroupSid);
    NtClose(Token);

    return(GroupMember);
}
*/

/***************************************************************************\
* FUNCTION: CtxImpersonateUser
*
* PURPOSE:  Impersonates the user by setting the users token
*           on the specified thread. If no thread is specified the token
*           is set on the current thread.
*
* RETURNS:  Handle to be used on call to StopImpersonating() or NULL on failure
*           If a non-null thread handle was passed in, the handle returned will
*           be the one passed in. (See note)
*
* NOTES:    Take care when passing in a thread handle and then calling
*           StopImpersonating() with the handle returned by this routine.
*           StopImpersonating() will close any thread handle passed to it -
*           even yours !
*
* HISTORY:
*
*   04-21-92 Davidc       Created.
*   12-18-96 cjc     copied from \windows\gina\msgina\wlsec.c
*
\***************************************************************************/


HANDLE
CtxImpersonateUser(
    PCTX_USER_DATA UserData,
    HANDLE      ThreadHandle
    )
{
    NTSTATUS Status, IgnoreStatus;
    HANDLE  UserToken = UserData->UserToken;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ImpersonationToken;
    BOOL ThreadHandleOpened = FALSE;

    if (ThreadHandle == NULL) {

        //
        // Get a handle to the current thread.
        // Once we have this handle, we can set the user's impersonation
        // token into the thread and remove it later even though we ARE
        // the user for the removal operation. This is because the handle
        // contains the access rights - the access is not re-evaluated
        // at token removal time.
        //

        Status = NtDuplicateObject( NtCurrentProcess(),     // Source process
                                    NtCurrentThread(),      // Source handle
                                    NtCurrentProcess(),     // Target process
                                    &ThreadHandle,          // Target handle
                                    THREAD_SET_THREAD_TOKEN,// Access
                                    0L,                     // Attributes
                                    DUPLICATE_SAME_ATTRIBUTES
                                  );
        if (!NT_SUCCESS(Status)) {
            return(NULL);
        }

        ThreadHandleOpened = TRUE;
    }


    //
    // If the usertoken is NULL, there's nothing to do
    //

    if (UserToken != NULL) {

        //
        // UserToken is a primary token - create an impersonation token version
        // of it so we can set it on our thread
        //

        InitializeObjectAttributes(
                            &ObjectAttributes,
                            NULL,
                            0L,
                            NULL,
                            UserData->NewThreadTokenSD);

        SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly = FALSE;

        ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


        Status = NtDuplicateToken( UserToken,
                                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES |
                                        TOKEN_QUERY,
                                   &ObjectAttributes,
                                   FALSE,
                                   TokenImpersonation,
                                   &ImpersonationToken
                                 );
        if (!NT_SUCCESS(Status)) {

            if (ThreadHandleOpened) {
                IgnoreStatus = NtClose(ThreadHandle);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            return(NULL);
        }



        //
        // Set the impersonation token on this thread so we 'are' the user
        //

        Status = NtSetInformationThread( ThreadHandle,
                                         ThreadImpersonationToken,
                                         (PVOID)&ImpersonationToken,
                                         sizeof(ImpersonationToken)
                                       );
        //
        // We're finished with our handle to the impersonation token
        //

        IgnoreStatus = NtClose(ImpersonationToken);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Check we set the token on our thread ok
        //

        if (!NT_SUCCESS(Status)) {

            if (ThreadHandleOpened) {
                IgnoreStatus = NtClose(ThreadHandle);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            return(NULL);
        }
    }


    return(ThreadHandle);

}


/***************************************************************************\
* FUNCTION: CtxStopImpersonating
*
* PURPOSE:  Stops impersonating the client by removing the token on the
*           current thread.
*
* PARAMETERS: ThreadHandle - handle returned by ImpersonateUser() call.
*
* RETURNS:  TRUE on success, FALSE on failure
*
* NOTES: If a thread handle was passed in to ImpersonateUser() then the
*        handle returned was one and the same. If this is passed to
*        StopImpersonating() the handle will be closed. Take care !
*
* HISTORY:
*
*   04-21-92 Davidc       Created.
*   12-18-96 cjc     copied from \windows\gina\msgina\wlsec.c
*
\***************************************************************************/

BOOL
CtxStopImpersonating(
    HANDLE  ThreadHandle
    )
{
    NTSTATUS Status, IgnoreStatus;
    HANDLE ImpersonationToken;


    if (ThreadHandle == NULL) {
       return FALSE;
    }
    //
    // Remove the user's token from our thread so we are 'ourself' again
    //

    ImpersonationToken = NULL;

    Status = NtSetInformationThread( ThreadHandle,
                                     ThreadImpersonationToken,
                                     (PVOID)&ImpersonationToken,
                                     sizeof(ImpersonationToken)
                                   );
    //
    // We're finished with the thread handle
    //

    IgnoreStatus = NtClose(ThreadHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    return(NT_SUCCESS(Status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\syslib\winsta.c ===
/*************************************************************************
*
* winsta.c
*
* System Library WinStation utilities
*
*  This file contains common routines needed in many places in the
*  system. An example is that (3) separate DLL's in the spooler need
*  functions to deal with the current user of a WinStation. IE: Get
*  name, find which LogonId, get name by logonid, etc.
*
*  This common library at least keeps the source management in one
*  place. This is likely to become another Hydra DLL's in the future
*  to reduce memory.
*
*
*
*
*************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "winsta.h"
#include "syslib.h"

#pragma warning (error:4312)

#if DBG
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


//
// Structure for FindUserOnWinStation
//
typedef struct _FINDUSERDATA {
    LPWSTR   pName;
    ULONG    ResultLogonId;
} FINDUSERDATA, *PFINDUSERDATA;


/*****************************************************************************
 *
 *  WinStationGetUserName
 *
 *   Return the user name for the WinStation
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
WinStationGetUserName(
    ULONG  LogonId,
    PWCHAR pBuf,
    ULONG  BufSize
    )
{
    BOOL Result;
    ULONG ReturnLength;
    WINSTATIONINFORMATION WSInfo;

    memset( &WSInfo, 0, sizeof(WSInfo) );

    // Query it
    Result = WinStationQueryInformation(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationInformation,
                 &WSInfo,
                 sizeof(WSInfo),
                 &ReturnLength
                 );

    if( !Result ) {
        DBGPRINT(("GetWinStationInfo: Error %d getting info on WinStation %d\n",GetLastError(),LogonId));
        return( FALSE );
    }

    // Scale BufSize to UNICODE characters
    if( BufSize >= sizeof(WCHAR) ) {
        BufSize /= sizeof(WCHAR);
    }
    else {
        BufSize = 0;
    }

    if( (BufSize > 1) && WSInfo.UserName[0] ) {
        wcsncpy( pBuf, WSInfo.UserName, BufSize );
        pBuf[BufSize-1] = (WCHAR)NULL;
    }
    else {
        pBuf[0] = (WCHAR)NULL;
    }

    return( TRUE );
}


/*****************************************************************************
 *
 *  SearchUserCallback
 *
 *   Callback for search function
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
SearchUserCallback(
    ULONG CurrentIndex,
    PLOGONIDW pInfo,
    ULONG_PTR lParam
    )
{
    BOOL Result;
    PFINDUSERDATA p;
    WCHAR UserName[USERNAME_LENGTH+1];

    // Only active WinStations are valid
    if( pInfo->State != State_Active ) {
        // continue the search
        return( TRUE );
    }

    // Check the user on the WinStation
    Result = WinStationGetUserName( pInfo->LogonId, UserName, sizeof(UserName) );
    if( !Result ) {
        DBGPRINT(("SearchUserCallback: Error getting WinStation User Name LogonId %d\n",pInfo->LogonId,GetLastError()));
        // continue the search
        return( TRUE );
    }

    p = (PFINDUSERDATA)lParam;

    if( _wcsicmp(p->pName, UserName) == 0 ) {
        TRACE0(("SearchUserCallback: Found username %ws on WinStation LogonId %d\n",UserName,pInfo->LogonId));
        // Found it, return the LogonId
        p->ResultLogonId = pInfo->LogonId;
        // Stop the search
        return( FALSE );
    }

    // continue the search
    return( TRUE );
}

/*****************************************************************************
 *
 *  FindUsersWinStation
 *
 *  Find the given users WinStation.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
FindUsersWinStation(
    PWCHAR   pName,
    PULONG   pLogonId
    )
{
    BOOL Result;
    FINDUSERDATA Data;

    ASSERT( pLogonId != NULL );

    // If a NULL name, we are not going to find it.
    if( (pName == NULL) ||
        (pName[0] == (WCHAR)NULL) ) {
        TRACE0(("FindUsersWinStation: NULL user name\n"));
        return( FALSE );
    }

    Data.ResultLogonId = (ULONG)(-1);
    Data.pName = pName;

    //
    // Use the WinStation Enumerator to check all the WinStations
    //
    Result = WinStationEnumeratorW(
                 0,                        // StartIndex
                 SearchUserCallback,       // enumerator callback function
                 (ULONG_PTR)&Data              // lParam is our structure
                 );

    if( !Result ) {
        // Problem with enumerator
        DBGPRINT(("FindUsersWinStation: Problem with enumerator\n"));
        return(FALSE);
    }

    //
    // If ResultLogonId != (-1), a WinStation was found for the user
    //
    if( Data.ResultLogonId != (ULONG)(-1) ) {
        TRACE0(("FindUsersWinStation: Found LogonId %d\n",Data.ResultLogonId));
        *pLogonId = Data.ResultLogonId;
        return(TRUE);
    }

    TRACE0(("FindUsersWinStation: Could not find user %ws\n",pName));
    return(FALSE);
}


/*****************************************************************************
 *
 *  WinStationGetIcaNameA
 *
 *   ANSI version
 *
 *   Get the ICA name from the supplied WinStations Logonid
 *
 *   Returns it in newly allocated memory that must be freed with
 *   RtlFreeHeap().
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PCHAR
WinStationGetICANameA(
    ULONG LogonId
    )
{
    BOOL   Result;
    ULONG ReturnLength;
    PCHAR pName = NULL;
    WINSTATIONCLIENTA ClientInfo;
    WINSTATIONINFORMATIONA WSInfo;
    CHAR NameBuf[MAX_PATH+1];

    memset( &WSInfo, 0, sizeof(WSInfo) );

    Result = WinStationQueryInformationA(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationInformation,
                 &WSInfo,
                 sizeof(WSInfo),
                 &ReturnLength
                 );

    if( !Result ) {
        DBGPRINT(("GetWinStationICANameA: Error %d getting info on WinStation\n",GetLastError()));
        return( NULL );
    }

    memset( &ClientInfo, 0, sizeof(ClientInfo) );

    // Query its Info
    Result = WinStationQueryInformationA(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationClient,
                 &ClientInfo,
                 sizeof(ClientInfo),
                 &ReturnLength
                 );

    if( !Result ) {
        DBGPRINT(("GetWinStationICANameA: Error %d getting client info\n",GetLastError()));
        return( NULL );
    }

    //
    // If the ClientName is NULL, then we use the user
    // as the ICA name.
    //
    if( ClientInfo.ClientName[0] == (CHAR)NULL ) {
#ifdef notdef // spec change...
            if( ClientInfo.SerialNumber )
                wsprintf( NameBuf, L"%ws-%d", WSInfo.UserName, ClientInfo.SerialNumber);
            else
#endif
            sprintf( NameBuf, "%s", WSInfo.UserName);

    }
    else {
        // copy out the Client name
        strcpy( NameBuf, ClientInfo.ClientName );
    }

    ReturnLength = strlen( NameBuf ) + 1;

    pName = RtlAllocateHeap( RtlProcessHeap(), 0, ReturnLength );
    if( pName == NULL ) {
        return( NULL );
    }

    strcpy( pName, NameBuf );

    return( pName );
}


/*****************************************************************************
 *
 *  WinStationGetIcaNameW
 *
 *   UNICODE Version
 *
 *   Get the ICA name from the supplied WinStations Logonid
 *
 *   Returns it in newly allocated memory that must be freed with
 *   RtlFreeHeap().
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PWCHAR
WinStationGetICANameW(
    ULONG LogonId
    )
{
    BOOL   Result;
    ULONG ReturnLength;
    PWCHAR pName = NULL;
    WINSTATIONCLIENT ClientInfo;
    WINSTATIONINFORMATION WSInfo;
    WCHAR NameBuf[MAX_PATH+1];

    memset( &WSInfo, 0, sizeof(WSInfo) );

    Result = WinStationQueryInformationW(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationInformation,
                 &WSInfo,
                 sizeof(WSInfo),
                 &ReturnLength
                 );

    if( !Result ) {
        DBGPRINT(("GetWinStationICANameW: Error %d getting info on WinStation\n",GetLastError()));
        return( NULL );
    }

    memset( &ClientInfo, 0, sizeof(ClientInfo) );

    // Query its Info
    Result = WinStationQueryInformationW(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationClient,
                 &ClientInfo,
                 sizeof(ClientInfo),
                 &ReturnLength
                 );

    if( !Result ) {
        DBGPRINT(("GetWinStationICANameW: Error %d getting client info\n",GetLastError()));
        return( NULL );
    }

    //
    // If the ClientName is NULL, then we use the user
    // as the ICA name.
    //
    if( ClientInfo.ClientName[0] == (WCHAR)NULL ) {
#ifdef notdef // spec change...
            if( ClientInfo.SerialNumber )
                wsprintf( NameBuf, L"%ws-%d", WSInfo.UserName, ClientInfo.SerialNumber);
            else
#endif
            wsprintf( NameBuf, L"%ws", WSInfo.UserName);

    }
    else {
        // copy out the Client name
        wcscpy( NameBuf, ClientInfo.ClientName );
    }

    ReturnLength = wcslen( NameBuf ) + 1;
    ReturnLength *= sizeof(WCHAR);

    pName = RtlAllocateHeap( RtlProcessHeap(), 0, ReturnLength );
    if( pName == NULL ) {
        return( NULL );
    }

    wcscpy( pName, NameBuf );

    return( pName );
}


/*****************************************************************************
 *
 *  WinStationIsHardWire
 *
 *   Returns whether the WinStation is hardwired. IE: No modem
 *   or network. Like a dumb terminal.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
WinStationIsHardWire(
    ULONG LogonId
    )
{
    return( FALSE );
}

/*****************************************************************************
 *
 *  GetWinStationUserToken
 *
 *   Return the token for the user currently logged onto the WinStation
 *
 * ENTRY:
 *   LogonId (input)
 *     LogonId of WinStation
 *
 *   pUserToken (output)
 *     Variable to place the returned token handle if successfull.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
GetWinStationUserToken(
    ULONG LogonId,
    PHANDLE pUserToken
    )
{
    BOOL   Result;
    ULONG  ReturnLength;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE ImpersonationToken;
    WINSTATIONUSERTOKEN Info;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;


    //
    // This gets the token of the user logged onto the WinStation
    // if we are an admin caller.
    //

    // This is so that CSRSS can dup the handle to our process
    Info.ProcessId = LongToHandle(GetCurrentProcessId());
    Info.ThreadId = LongToHandle(GetCurrentThreadId());

    Result = WinStationQueryInformation(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationUserToken,
                 &Info,
                 sizeof(Info),
                 &ReturnLength
                 );

    if( !Result ) {
        DBGPRINT(("GetWinStationUserToken: Error %d getting UserToken LogonId %d\n",GetLastError(),LogonId));
        return( FALSE );
    }

    //
    // The token returned is a duplicate of a primary token.
    //
    // We must make it into an IMPERSONATION TOKEN or the
    // AccessCheck() routine will fail since it only operates
    // against impersonation tokens.
    //

    InitializeObjectAttributes( &ObjA, NULL, 0L, NULL, NULL );

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjA.SecurityQualityOfService = &SecurityQualityOfService;

    Status = NtDuplicateToken( Info.UserToken,
                               0, // inherit granted accesses TOKEN_IMPERSONATE
                               &ObjA,
                               FALSE,
                               TokenImpersonation,
                               &ImpersonationToken );

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("GetWinStationUserToken: Error %d duping UserToken to impersonation LogonId %d\n",GetLastError(),LogonId));
        NtClose( Info.UserToken );
        return( FALSE );
    }

    // return the impersonation token
    *pUserToken = ImpersonationToken;

    NtClose( Info.UserToken );

    return( TRUE );
}

//
// This is not in winnt.h, but in ntseapi.h which we can not
// include readily since we are a WIN32 program as we 'hide' this
// new information type from WIN32 programs.
//

/*****************************************************************************
 *
 *  GetClientLogonId
 *
 *   Get the logonid from the client who we should be impersonating. If any
 *   errors, we return 0 to mean the Console Logon Id since this may be a
 *   remote network call.
 *
 * ENTRY:
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

ULONG
GetClientLogonId()
{
    BOOL          Result;
    HANDLE        TokenHandle;
    ULONG         LogonId, ReturnLength;

    //
    // We should be impersonating the client, so we will get the
    // LogonId from out token.
    //
    // We may not have a valid one if this is a remote network
    // connection.

    Result = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_QUERY,
                 FALSE,              // Use impersonation
                 &TokenHandle
                 );

    if( Result ) {

        // This identifies which WinStation is making this request.
        //

        Result = GetTokenInformation(
                     TokenHandle,
                     TokenSessionId,
                     &LogonId,
                     sizeof(LogonId),
                     &ReturnLength
                     );

        if( Result ) {
#if DBG
            if( ReturnLength != sizeof(LogonId) ) {
                DbgPrint("LOCALSPOOL: CompleteRead: ReturnLength %d != sizeof(LogonId)\n", ReturnLength );
            }
#endif
        }
        else {
            DBGPRINT(("SYSLIB: Error getting token information %d\n", GetLastError()));
            LogonId = 0; // Default to console
        }
        CloseHandle( TokenHandle );
    }
    else {
        TRACE0(("SYSLIB: Error opening token %d\n", GetLastError()));
        LogonId = 0;
    }

    return( LogonId );
}

/*****************************************************************************
 *
 *  WinStationEnumeratorW
 *
 *   Enumerator for WinStations
 *
 * ENTRY:
 *   StartIndex (input)
 *     WinStation Index to start Enumeration at
 *
 *   pProc (input)
 *     Pointer to function that gets called for each WinStation
 *     entry.
 *
 *     EXAMPLE:
 *
 *     BOOLEAN
 *     EnumCallBack(
 *         ULONG CurrentIndex,   // Current Index of this entry
 *         PLOGONIDW pInfo,      // WinStation Entry
 *         ULONG_PTR lParam      // Passed through from caller of WinStationEnumeratorW
 *         );
 *
 *     If the EnumCallback function returns TRUE, the WinStationEnumeratorW()
 *     continues the search. If it returns FALSE, the search is stopped.
 *
 *   lParam (input)
 *     Caller supplied argument passed through to caller supplied function
 *
 * EXIT:
 *   TRUE  - no error
 *   FALSE - Error
 *
 ****************************************************************************/

BOOLEAN
WinStationEnumeratorW(
    ULONG StartIndex,
    WINSTATIONENUMPROC pProc,
    ULONG_PTR lParam
    )
{
    BOOLEAN Result;
    ULONG Entries, i;
    ULONG ByteCount, ReqByteCount, Index;
    ULONG Error, CurrentIndex;
    PLOGONIDW ptr;
    ULONG QuerySize = 32;
    PLOGONIDW SmNameCache = NULL;   // WinStation namelist

    Index = StartIndex;
    CurrentIndex = StartIndex;

    Entries = QuerySize;
    ByteCount = Entries * sizeof( LOGONIDW );
    SmNameCache = (PLOGONIDW)RtlAllocateHeap( RtlProcessHeap(), 0, ByteCount );
    if ( SmNameCache == NULL )
        return(FALSE);

    while( 1 ) {

        ReqByteCount = ByteCount;
        ptr = SmNameCache;
        Result = WinStationEnumerate_IndexedW( SERVERNAME_CURRENT, &Entries, ptr, &ByteCount, &Index );

        if( !Result ) {
            Error = GetLastError();
            if( Error == ERROR_NO_MORE_ITEMS ) {
                // Done
                RtlFreeHeap( RtlProcessHeap(), 0, SmNameCache );
                return(TRUE);
            }
            else if( Error == ERROR_ALLOTTED_SPACE_EXCEEDED ) {
                // Entries contains the maximum query size
                if( QuerySize <= Entries ) {
                    DBGPRINT(("CPMMON: SM Query Size < RetCapable. ?View Memory Leak? Query %d, Capable %d\n", QuerySize, Entries ));
                    QuerySize--; // See when it recovers. On retail, it will still work.
                }
                else {
                    // We asked for more than it can handle
                    QuerySize = Entries;
                }
                
                if( QuerySize == 0 ) {
                    RtlFreeHeap( RtlProcessHeap(), 0, SmNameCache );
                    return(FALSE);
                }

                Entries = QuerySize;
                ByteCount = Entries * sizeof( LOGONIDW );
                
                continue;
            }
            else {
                // Other error
                DBGPRINT(("CPMMON: Error emumerating WinStations %d\n",Error));
                RtlFreeHeap( RtlProcessHeap(), 0, SmNameCache );
                return(FALSE);
            }
        }

        ASSERT( ByteCount <= ReqByteCount );

        // We got some entries, now call the enumerator function

        for( i=0; i < Entries; i++ ) {
            Result = pProc( CurrentIndex, &SmNameCache[i], lParam );
            CurrentIndex++;
            if( !Result ) {
                // The Enumerator proc wants us to stop the search
                RtlFreeHeap( RtlProcessHeap(), 0, SmNameCache );
                return(TRUE);
            }
        }
    } // Outer while

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\allusrsm.c ===
/*************************************************************************
*
* allusrsm.c
*
* Move items from a user's start menu to the All Users start menu
*
* copyright notice: Copyright 1998 Micrsoft
*
*  When entering install mode, if the start menu snapshot file already
*  exists, don't overwrite it.  Otherwise, some shortcuts may not get moved
*  over.  This fixes a problem where an App reboots the machine when it
*  finishes installing, without giving the user a chance to switch back to
*  execute mode.  Now, when the user logs in again, the menu shortcuts will
*  be moved because winlogon always does a "change user /install" and then
*  "change user /execute".  (That's to support RunOnce programs.)
*  MS 1057
*
*
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <userenv.h>
#include <shlobj.h>

// This program takes a snapshot of the Current User's start menu and
// saves it to a file.  When run with the /c option, it compares the
// snapshot to the present contents of the Current User's start menu.
// Each new or changed file/directory is then moved to the All Users
// start menu.  Additionally, Read permission is granted to the Everyone
// group for each moved file or directory.



typedef struct File_Struct {
   struct File_Struct *Next;        // Only used in Memory
   WCHAR       FileName[MAX_PATH];
   BOOL        TimeValid;
   SYSTEMTIME  Time;
   } FILENODE, *PFILENODE;


typedef struct Path_Struct {
   DWORD      FilesInDir;
   struct Path_Struct *Next;  // Only used in Memory
   PFILENODE  FileHead;       // Only used in Memory
   PFILENODE  FileTail;       // Only used in Memory
   WCHAR      PathStr[MAX_PATH];
   } PATHNODE, *PPATHNODE;


typedef struct Tree_Struct {
   DWORD     NumPaths;
   PPATHNODE PathHead;
   PPATHNODE PathTail;
   } TREENODE, *PTREENODE;


typedef struct RemoveDir_Struct {
        WCHAR PathStr[MAX_PATH];
        struct RemoveDir_Struct *Next;
} REMOVEDIRLIST, *PPREMOVEDIRLIST;




int RunMode;
WCHAR SaveName[MAX_PATH];
WCHAR CurUserDir[MAX_PATH];
WCHAR AllUserDir[MAX_PATH];
int CurUserDirLen;
WCHAR StartMenu[MAX_PATH]=L"";


void ReadTree(PTREENODE Tree, WCHAR *Dir);

#define SD_SIZE (65536 + SECURITY_DESCRIPTOR_MIN_LENGTH)

////////////////////////////////////////////////////////////////////////////

 BOOLEAN FileExists( WCHAR *path )
{
    return( GetFileAttributes(path) == -1 ? FALSE : TRUE );
}

////////////////////////////////////////////////////////////////////////////

 NTSTATUS CreateNewSecurityDescriptor( PSECURITY_DESCRIPTOR *ppNewSD,
                                             PSECURITY_DESCRIPTOR pSD,
                                             PACL pAcl )
/*++
Routine Description:
   From a SD and a Dacl, create a new SD. The new SD will be fully self
   contained (it is self relative) and does not have pointers to other
   structures.

Arguments:
     ppNewSD - used to return the new SD. Caller should free with LocalFree
     pSD     - the self relative SD we use to build the new SD
     pAcl    - the new DACL that will be used for the new SD

Return Value:
     NTSTATUS code
--*/
{
    PACL pSacl;
    PSID psidGroup, psidOwner;
    BOOLEAN fSaclPres;
    BOOLEAN fSaclDef, fGroupDef, fOwnerDef;
    ULONG NewSDSize;
    SECURITY_DESCRIPTOR NewSD;
    PSECURITY_DESCRIPTOR pNewSD;
    NTSTATUS Status;

    // extract the originals from the security descriptor
    Status = RtlGetSaclSecurityDescriptor(pSD, &fSaclPres, &pSacl, &fSaclDef);
    if (!NT_SUCCESS(Status))
       return(Status);

    Status = RtlGetOwnerSecurityDescriptor(pSD, &psidOwner, &fOwnerDef);
    if (!NT_SUCCESS(Status))
       return(Status);

    Status = RtlGetGroupSecurityDescriptor(pSD, &psidGroup, &fGroupDef);
    if (!NT_SUCCESS(Status))
       return(Status);

    // now create a new SD and set the info in it. we cannot return this one
    // since it has pointers to old SD.
    Status = RtlCreateSecurityDescriptor(&NewSD, SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(Status))
       return(Status);


    Status = RtlSetDaclSecurityDescriptor(&NewSD, TRUE, pAcl, FALSE);
    if (!NT_SUCCESS(Status))
       return(Status);

    Status = RtlSetSaclSecurityDescriptor(&NewSD, fSaclPres, pSacl, fSaclDef);
    if (!NT_SUCCESS(Status))
       return(Status);

    Status = RtlSetOwnerSecurityDescriptor(&NewSD, psidOwner, fOwnerDef);
    if (!NT_SUCCESS(Status))
       return(Status);

    Status = RtlSetGroupSecurityDescriptor(&NewSD, psidGroup, fGroupDef);
    if (!NT_SUCCESS(Status))
       return(Status);

    // calculate size needed for the returned SD and allocated it
    NewSDSize = RtlLengthSecurityDescriptor(&NewSD);
    pNewSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LMEM_FIXED, NewSDSize);
    if (pNewSD == NULL)
       return(STATUS_INSUFFICIENT_RESOURCES);


    // convert the absolute to self relative
    Status = RtlAbsoluteToSelfRelativeSD(&NewSD, pNewSD, &NewSDSize);
    if (NT_SUCCESS(Status))
        *ppNewSD = pNewSD;
    else
        LocalFree(pNewSD);

    return(Status);
} // CreateNewSecurityDescriptor

/////////////////////////////////////////////////////////////////////////

//  Add Read and Execute permissions for built in "Everyone" Group to
//  the indicated file.

 BOOLEAN APIENTRY AddEveryoneRXPermissionW( LPCWSTR lpFileName)
{
   NTSTATUS Status;
   BOOLEAN ExitVal = FALSE;

   HANDLE FileHandle=NULL;
   OBJECT_ATTRIBUTES Obja;
   UNICODE_STRING FileName;
   RTL_RELATIVE_NAME_U RelativeName;
   BOOLEAN TranslationStatus;
   IO_STATUS_BLOCK IoStatusBlock;
   PVOID FreeBuffer;

   PSECURITY_DESCRIPTOR pSD = NULL;
   PSECURITY_DESCRIPTOR pNewSD = NULL;
   DWORD LengthNeeded = 0;

   static PACCESS_ALLOWED_ACE pNewAce = NULL;
   static USHORT NewAceSize;

   ACL  Acl;
   PACL pAcl, pNewAcl = NULL;
   BOOLEAN fDaclPresent, fDaclDef;
   USHORT NewAclSize;

   ////////////////////////////////////////////////////////////////////////
   //  First time through this routine, create an ACE for the built-in
   //  "Everyone" group.
   ////////////////////////////////////////////////////////////////////////

   if (pNewAce == NULL)
      {
      PSID  psidEveryone = NULL;
      SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;

      // Get the SID of the built-in Everyone group
      Status = RtlAllocateAndInitializeSid( &WorldSidAuthority, 1,
                       SECURITY_WORLD_RID, 0,0,0,0,0,0,0, &psidEveryone);
      if (!NT_SUCCESS(Status))
         goto ErrorExit;

      // allocate and initialize new ACE
      NewAceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
                   RtlLengthSid(psidEveryone));

      pNewAce = (PACCESS_ALLOWED_ACE) LocalAlloc(LMEM_FIXED, NewAceSize);
      if (pNewAce == NULL)
         goto ErrorExit;

      pNewAce->Header.AceFlags = (UCHAR) CONTAINER_INHERIT_ACE |
                                         OBJECT_INHERIT_ACE ;
      pNewAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
      pNewAce->Header.AceSize = NewAceSize;
      pNewAce->Mask = FILE_GENERIC_READ | FILE_EXECUTE;
      RtlCopySid(RtlLengthSid(psidEveryone), (PSID)(&pNewAce->SidStart),
                 psidEveryone);
      }

   ////////////////////////////////////////////////////////////////////////
   //  Open the indicated file.
   ////////////////////////////////////////////////////////////////////////

   TranslationStatus = RtlDosPathNameToRelativeNtPathName_U( lpFileName,
                                         &FileName, NULL, &RelativeName );
   if ( !TranslationStatus ) {
      goto ErrorExit;
   }

   FreeBuffer = FileName.Buffer;

   if ( RelativeName.RelativeName.Length )
      FileName = RelativeName.RelativeName;
   else
      RelativeName.ContainingDirectory = NULL;

   InitializeObjectAttributes( &Obja, &FileName, OBJ_CASE_INSENSITIVE,
                             RelativeName.ContainingDirectory, NULL );

   Status = NtOpenFile( &FileHandle, READ_CONTROL | WRITE_DAC, &Obja, &IoStatusBlock,
                  FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0 );

   RtlReleaseRelativeName(&RelativeName);
   RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

   if (!NT_SUCCESS(Status))
      goto ErrorExit;

   ////////////////////////////////////////////////////////////////////////
   //  Retrieve the security descriptor for the file and then get the
   //  file's DACL from it.
   ////////////////////////////////////////////////////////////////////////

   pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LMEM_FIXED, SD_SIZE);
   if (pSD == NULL)
      goto ErrorExit;

   Status = NtQuerySecurityObject( FileHandle, DACL_SECURITY_INFORMATION,
                                   pSD, SD_SIZE, &LengthNeeded );
   if (!NT_SUCCESS(Status))
      goto ErrorExit;

   // extract the originals from the security descriptor
   Status = RtlGetDaclSecurityDescriptor(pSD, &fDaclPresent, &pAcl, &fDaclDef);
   if (!NT_SUCCESS(Status))
      goto ErrorExit;

   ////////////////////////////////////////////////////////////////////////
   //  Create a new DACL by copying the existing DACL and appending the
   //  "Everyone" ACE.
   ////////////////////////////////////////////////////////////////////////

   // if no DACL present, we create one
   if ((fDaclPresent == FALSE) || (pAcl == NULL))
      {
      Status = RtlCreateAcl(&Acl, sizeof(Acl), ACL_REVISION) ;
      if (!NT_SUCCESS(Status))
         goto ErrorExit;

      pAcl = &Acl;
      }

   // Copy the DACL into a larger buffer and add the new ACE to the end.
   NewAclSize = pAcl->AclSize + NewAceSize;
   pNewAcl = (PACL) LocalAlloc(LMEM_FIXED, NewAclSize);
   if (!pNewAcl)
      goto ErrorExit;

   RtlCopyMemory(pNewAcl, pAcl, pAcl->AclSize);
   pNewAcl->AclSize = NewAclSize;

   Status = RtlAddAce(pNewAcl, ACL_REVISION, pNewAcl->AceCount,
                        pNewAce, NewAceSize);
   if (!NT_SUCCESS(Status))
      goto ErrorExit;

   ////////////////////////////////////////////////////////////////////////
   //  Create self-relative security descriptor with new DACL.  Then
   //  save the security descriptor back to the file.
   ////////////////////////////////////////////////////////////////////////

   Status = CreateNewSecurityDescriptor(&pNewSD, pSD, pNewAcl);
   if (!NT_SUCCESS(Status))
      goto ErrorExit;

   Status = NtSetSecurityObject(FileHandle, DACL_SECURITY_INFORMATION, pNewSD);
   if (!NT_SUCCESS(Status))
      goto ErrorExit;

   ExitVal = TRUE;

ErrorExit:

   if (FileHandle != NULL)
      NtClose(FileHandle);

   if (pNewAcl != NULL)
      LocalFree(pNewAcl);

   if (pNewSD != NULL)
      LocalFree(pNewSD);

   if (pSD != NULL)
      LocalFree(pSD);

   return(ExitVal);
}

////////////////////////////////////////////////////////////////////////////

#if 0
 BOOLEAN APIENTRY AddEveryoneRXPermissionA( WCHAR * lpFileName)
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpFileName);
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) )
       {
        ULONG dwErrorCode;

        dwErrorCode = RtlNtStatusToDosError( Status );
        SetLastError( dwErrorCode );
        return FALSE;
       }

    return ( AddEveryoneRXPermissionW((LPCWSTR)Unicode->Buffer) );
}
#endif

////////////////////////////////////////////////////////////////////////////

// return -1 for dates invalid, 0 for equal, 1 for f1 newer, 2 for f2 newer

 int CheckDates(PFILENODE FN1, PFILENODE FN2)
{
   SYSTEMTIME f1s = FN1->Time;
   SYSTEMTIME f2s = FN2->Time;

   if (FN1->TimeValid == FALSE || FN2->TimeValid == FALSE)
      return -1;

   if (f1s.wYear > f2s.wYear)     return 1;
   if (f1s.wYear < f2s.wYear)     return 2;

   if (f1s.wMonth > f2s.wMonth)   return 1;
   if (f1s.wMonth < f2s.wMonth)   return 2;

   if (f1s.wDay > f2s.wDay)       return 1;
   if (f1s.wDay < f2s.wDay)       return 2;

   if (f1s.wHour > f2s.wHour)     return 1;
   if (f1s.wHour < f2s.wHour)     return 2;

   if (f1s.wMinute > f2s.wMinute) return 1;
   if (f1s.wMinute < f2s.wMinute) return 2;

   if (f1s.wSecond > f2s.wSecond) return 1;
   if (f1s.wSecond < f2s.wSecond) return 2;

   return 0;
}

////////////////////////////////////////////////////////////////////////////

 PPATHNODE GetPathNode(PTREENODE Tree, WCHAR *Dir)
{
   PPATHNODE p;

   // Handle Empty List
   if (Tree->PathTail == NULL)
      {
      p = (PPATHNODE) LocalAlloc(0,sizeof(PATHNODE));
      if (p == NULL)
         return NULL;
      Tree->PathHead = p;
      Tree->PathTail = p;
      Tree->NumPaths++;
      p->Next = NULL;
      p->FileHead = NULL;
      p->FileTail = NULL;
      p->FilesInDir = 0;
      wcscpy(p->PathStr,Dir);
      return p;
      }

   // Last Node Matches
   if (wcscmp(Tree->PathTail->PathStr,Dir) == 0)
      return Tree->PathTail;

   // Need to add a node
   p = (PPATHNODE) LocalAlloc(0,sizeof(PATHNODE));
   if (p == NULL)
      return NULL;
   Tree->PathTail->Next = p;
   Tree->PathTail = p;
   Tree->NumPaths++;
   p->Next = NULL;
   p->FileHead = NULL;
   p->FileTail = NULL;
   p->FilesInDir = 0;
   wcscpy(p->PathStr,Dir);
   return p;
}

////////////////////////////////////////////////////////////////////////////

 void AddFileNode(PTREENODE Tree, WCHAR *Dir, PFILENODE FileNode)
{
   PPATHNODE PathNode = GetPathNode(Tree, Dir);

   if (FileNode == NULL)
      return;

   if (PathNode == NULL)
      {
      LocalFree(FileNode);
      return;
      }

   // New node is always the last.
   FileNode->Next = NULL;

   // If list isn't empty, link to last node in list
   // Otherwise, set head pointer.
   if (PathNode->FileTail != NULL)
      PathNode->FileTail->Next = FileNode;
   else
      PathNode->FileHead = FileNode;

   // Put new node on end of list.
   PathNode->FileTail = FileNode;
   PathNode->FilesInDir++;
}

////////////////////////////////////////////////////////////////////////////

 void ProcessFile(PTREENODE Tree, LPWIN32_FIND_DATA LocalData, WCHAR *LocalDir)
{
    PFILENODE FileNode;

    // Don't handle directories
    if ((LocalData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
       return;

    // Allocate a file node
    FileNode = (PFILENODE) LocalAlloc(0,sizeof(FILENODE));
    if (FileNode == NULL)
       return;

    // Fill in the Local Fields
    wcscpy(FileNode->FileName, LocalData->cFileName);
    FileNode->TimeValid = FileTimeToSystemTime(&LocalData->ftLastWriteTime,
                                                  &FileNode->Time);

    // Add to the list
    AddFileNode(Tree, LocalDir, FileNode);
}

////////////////////////////////////////////////////////////////////////////

 void ProcessDir(PTREENODE Tree, LPWIN32_FIND_DATA FindData, WCHAR *Dir)
{
   WCHAR NewDir[MAX_PATH];
   PPATHNODE PathNode;

   // Only Handle Directories
   if ((FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
      return;

   // Don't recurse into these directories
   if (wcscmp(FindData->cFileName, L".") == 0)
      return;
   if (wcscmp(FindData->cFileName, L"..") == 0)
      return;

   wcscpy(NewDir,Dir);
   wcscat(NewDir,L"\\");
   wcscat(NewDir,FindData->cFileName);

   // This creates a node for the directory.  Nodes get automatically
   // created when adding files, but that doesn't handle empty
   // directories.  This does.
   PathNode = GetPathNode(Tree, NewDir);

   ReadTree(Tree, NewDir);
}

////////////////////////////////////////////////////////////////////////////

//  Creates an in-memory representation of the Current User's start menu.

 void ReadTree(PTREENODE Tree, WCHAR *Dir)
{
   HANDLE FindHandle;
   WIN32_FIND_DATA FindData;
   int retval;

   // First compare all files in current directory.
   retval = SetCurrentDirectory(Dir);
   if (retval == 0)
      {
      // printf("Unable to find directory %s\n",Dir);
      return;
      }

   FindHandle = FindFirstFile(L"*.*", &FindData);
   if (FindHandle != INVALID_HANDLE_VALUE)
      {
      ProcessFile(Tree, &FindData, Dir);

      while (FindNextFile(FindHandle, &FindData) != FALSE)
         ProcessFile(Tree, &FindData, Dir);

      FindClose(FindHandle);
      }


   // Next, handle subdirectories.
   retval = SetCurrentDirectory(Dir);
   if (retval == 0)
      {
      // printf("Unable to find directory %s\n",Dir);
      return;
      }

   FindHandle = FindFirstFile(L"*.*", &FindData);
   if (FindHandle != INVALID_HANDLE_VALUE)
      {
      ProcessDir(Tree, &FindData, Dir);

      while (FindNextFile(FindHandle, &FindData) != FALSE)
         ProcessDir(Tree, &FindData, Dir);

      FindClose(FindHandle);
      }
}

////////////////////////////////////////////////////////////////////////////

 int WriteTreeToDisk(PTREENODE Tree)
{
   PPATHNODE PN;
   PFILENODE FN;
   HANDLE hFile;
   DWORD BytesWritten;
   DWORD i;

   hFile = CreateFile(SaveName, GENERIC_WRITE, 0, NULL,
                      CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
   if (hFile == INVALID_HANDLE_VALUE)
      return(-1);  // error

   // DbgPrint("Tree->NumPaths is %d\n",Tree->NumPaths);
   if (WriteFile(hFile,&Tree->NumPaths,sizeof(DWORD),&BytesWritten, NULL) == 0)
      {
      CloseHandle(hFile);
      return(-1); // error
      }

   for (PN = Tree->PathHead; PN != NULL; PN = PN->Next)
      {
      if (WriteFile(hFile,PN,sizeof(PATHNODE),&BytesWritten, NULL) == 0)
         {
         CloseHandle(hFile);
         return(-1); // error
         }

      // DbgPrint("\n%s (%d)\n",PN->PathStr, PN->FilesInDir);
      FN = PN->FileHead;
      for (i = 0; i < PN->FilesInDir; i++)
          {
          if (WriteFile(hFile,FN,sizeof(FILENODE),&BytesWritten, NULL) == 0)
             {
             CloseHandle(hFile);
             return(-1); // error
             }

          // DbgPrint("      %s \n", FN->FileName);
          FN = FN->Next;
          }
      }

   CloseHandle(hFile);
   return(0);
}

////////////////////////////////////////////////////////////////////////////

 int ReadTreeFromDisk(PTREENODE Tree)
{
   PATHNODE  LocalPath;
   PPATHNODE PN;
   PFILENODE FN;
   HANDLE hFile;
   DWORD BytesRead;
   DWORD i,j;
   DWORD NumFiles, NumTrees;

   hFile = CreateFile(SaveName, GENERIC_READ, 0, NULL,
                      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
   if (hFile == INVALID_HANDLE_VALUE)
      return(-1);

   if (ReadFile(hFile,&NumTrees,sizeof(DWORD),&BytesRead, NULL) == 0)
      {
      CloseHandle(hFile);
      return(-1); // error
      }

   for (i = 0; i < NumTrees; i++)
      {
      if (ReadFile(hFile,&LocalPath,sizeof(PATHNODE),&BytesRead, NULL) == 0)
         {
         CloseHandle(hFile);
         return(-1); // error
         }

      PN = GetPathNode(Tree, LocalPath.PathStr);
      if (PN == NULL)
         {
         CloseHandle(hFile);
         return(-1); // error
         }

      NumFiles = LocalPath.FilesInDir;
      // DbgPrint("\n<<%s (%d)\n",PN->PathStr, NumFiles);

      for (j = 0; j < NumFiles; j++)
          {
          // Allocate a file node
          FN = (PFILENODE) LocalAlloc(0,sizeof(FILENODE));
          if (FN == NULL)
             {
             CloseHandle(hFile);
             return(-1); // error
             }

          if (ReadFile(hFile,FN,sizeof(FILENODE),&BytesRead, NULL) == 0)
             {
             CloseHandle(hFile);
             LocalFree(FN);
             return(-1); // error
             }

          AddFileNode(Tree, PN->PathStr, FN);
          // DbgPrint("      %d: %s >>\n", j, FN->FileName);
          }
      }

   CloseHandle(hFile);
   return(0);
}

////////////////////////////////////////////////////////////////////////////

//  Finds a path in a menu tree.  If not found, NULL is returned.

 PPATHNODE FindPath(PTREENODE Tree, PPATHNODE PN)
{
   PPATHNODE FoundPN;

   for (FoundPN = Tree->PathHead; FoundPN != NULL; FoundPN = FoundPN->Next)
      {
      if (_wcsicmp(FoundPN->PathStr,PN->PathStr) == 0)
         return FoundPN;
      }

   return NULL;
}

////////////////////////////////////////////////////////////////////////////

//  Finds a file in a directory node.  If not found, NULL is returned.

 PFILENODE FindFile(PPATHNODE PN, PFILENODE FN)
{
   PFILENODE FoundFN;

   for (FoundFN = PN->FileHead; FoundFN != NULL; FoundFN = FoundFN->Next)
      {
      if (_wcsicmp(FoundFN->FileName,FN->FileName) == 0)
         return FoundFN;
      }

   return NULL;
}



////////////////////////////////////////////////////////////////////////////
/* ============================================================== 
  Function Name         :       wcsrevchr
  Description           :       Reverse wcschr
                            Finds a character in a string starting from the end
  Arguments             :       
  Return Value          :       PWCHAR
============================================================== */
PWCHAR wcsrevchr( PWCHAR string, WCHAR ch )
{
   int cLen, iCount;

   cLen = wcslen(string);
   string += cLen;

   for (iCount = cLen; iCount && *string != ch ; iCount--, string--)
           ;

   if (*string == ch)
           return string;
   else
           return NULL;

}




////////////////////////////////////////////////////////////////////////////

// Create the indicated directory.  This function creates any parent
// directories that are needed too.
//
//  Return:  TRUE  = directory now exists
//           FALSE = directory couldn't be created

 BOOLEAN TsCreateDirectory( WCHAR *DirName )
{
   BOOL RetVal;
   WCHAR *LastSlash;

   //
   //  Try to create the specified directory.  If the create works or
   //  the directory already exists, return TRUE.  If the called failed
   //  because the path wasn't found, continue.  This occurs if the
   //  parent directory doesn't exist.
   //

   RetVal = CreateDirectory(DirName, NULL);
   if ((RetVal == TRUE) || (GetLastError() == ERROR_ALREADY_EXISTS))
      return(TRUE);

   if (GetLastError() != ERROR_PATH_NOT_FOUND)
      return(FALSE);

   //
   //  Remove the last component of the path and try creating the
   //  parent directory.  Upon return, add the last component back
   //  in and try to create the specified directory again.
   //

   

//  Desc : BUG 267014 - replaced
// LastSlash = wcschr(DirName, L'\\');
// Given a full pathname, previous always returns the drive letter.
// Next line returns path components
   LastSlash = wcsrevchr(DirName, L'\\');

   if (LastSlash == NULL)  // Can't reduce path any more
      return(FALSE);

   *LastSlash = L'\0';
   RetVal = TsCreateDirectory(DirName);
   *LastSlash = L'\\';

   if (RetVal == FALSE)  // Couldn't create parent directory
      return(FALSE);

   RetVal = CreateDirectory(DirName, NULL);
   if ((RetVal == TRUE) || (GetLastError() == ERROR_ALREADY_EXISTS))
      return(TRUE);

   return(FALSE);
}

////////////////////////////////////////////////////////////////////////////

//  Moves a file from the current start menu to the All Users start menu.
//  Creates any directories that may be needed in the All Users menu.

 void TsMoveFile(PPATHNODE PN, PFILENODE FN)
{
   WCHAR Src[MAX_PATH];
   WCHAR Dest[MAX_PATH];

   // Normalize Source Path
   wcscpy(Src,PN->PathStr);
   if (Src[wcslen(Src)-1] != L'\\')
      wcscat(Src,L"\\");

   // Create Destination Path.
   wcscpy(Dest,AllUserDir);
   wcscat(Dest,&Src[CurUserDirLen]);

   // If directory doesn't exist, make it.  The default permission is fine.
   if (TsCreateDirectory(Dest) != TRUE)
      return;

   wcscat(Src,FN->FileName);
   wcscat(Dest,FN->FileName);

   // Move Fails if the target already exists.  This could happen
   // if we're copying a file that has a newer timestamp.
   if ( GetFileAttributes(Dest) != -1 )
      DeleteFile(Dest);

   // DbgPrint("Moving File %s \n         to %s\n",Src,Dest);
   if (MoveFile(Src, Dest) == FALSE)
      return;

   AddEveryoneRXPermissionW(Dest);
}

////////////////////////////////////////////////////////////////////////////

//  Compare the current start menu with the original.  Copy any new or
//  changed files to the All Users menu.

 void ProcessChanges(PTREENODE OrigTree, PTREENODE NewTree)
{
   PPATHNODE NewPN, OrigPN;
   PFILENODE NewFN, OrigFN;
   BOOL fRet; 
   PPREMOVEDIRLIST pRemDirList = NULL, pTemp;

   for (NewPN = NewTree->PathHead; NewPN != NULL; NewPN = NewPN->Next)
      {

      // DbgPrint("PC: Dir is %s\n",NewPN->PathStr);
      // If directory not found in original tree, move it over
      OrigPN = FindPath(OrigTree, NewPN);
      if (OrigPN == NULL)
      {
             for (NewFN = NewPN->FileHead; NewFN != NULL; NewFN = NewFN->Next)
             {
                 // DbgPrint("    Move File is %s\n",NewFN->FileName);
                 TsMoveFile(NewPN,NewFN);
             }
            //  Desc : BUG 267014 - replaced        
            //         RemoveDirectory(NewPN->PathStr);
            //      We have a problem if NewPN doesn't contain file items but subfolders.
            //      In this case, we do not enter the above loop, as there is nothing to move
            //      But the folder can't be removed because it contains a tree that haven't been moved yet.
            //      To remove it, we store its name in a LIFO stack. Stack items are removed when the loop exits
    
            fRet = RemoveDirectory(NewPN->PathStr);

            if (!fRet && GetLastError() == ERROR_DIR_NOT_EMPTY) {
#if DBG
                     DbgPrint("Adding to List--%S\n", NewPN->PathStr);
#endif
                     if (pRemDirList) {
                            pTemp = (PPREMOVEDIRLIST)LocalAlloc(LMEM_FIXED,sizeof(REMOVEDIRLIST));
                            wcscpy(pTemp->PathStr, NewPN->PathStr);
                            pTemp->Next = pRemDirList;
                            pRemDirList = pTemp;
                     }
                     else {
                             pRemDirList = (PPREMOVEDIRLIST)LocalAlloc(LMEM_FIXED, sizeof(REMOVEDIRLIST));
                             wcscpy(pRemDirList->PathStr, NewPN->PathStr);
                             pRemDirList->Next = NULL;
                     }
            }
 
        continue;
      }

      // Directory was found, check the files
      for (NewFN = NewPN->FileHead; NewFN != NULL; NewFN = NewFN->Next)
          {
          // DbgPrint("    File is %s\n",NewFN->FileName);
          // File wasn't found, move it
          OrigFN = FindFile(OrigPN,NewFN);
          if (OrigFN == NULL)
             {
             TsMoveFile(NewPN,NewFN);
             continue;
             }

          // Check TimeStamp, if New Scan is more recent, move it.
          if (CheckDates(NewFN,OrigFN) == 1)
             {
             TsMoveFile(NewPN,NewFN);
             continue;
             }
          }
      }

//  Desc :  BUG 267014 - added
//                      Directories stack removal
   if (pRemDirList) {
           while (pRemDirList) {
                   pTemp = pRemDirList;
                   pRemDirList = pRemDirList->Next;
                   RemoveDirectory(pTemp->PathStr);
                   LocalFree(pTemp);
           }
   }


}

////////////////////////////////////////////////////////////////////////////

//  Frees the in-memory representation of a start menu

 void FreeTree(PTREENODE Tree)
{
   PPATHNODE PN,NextPN;
   PFILENODE FN,NextFN;

   for (PN = Tree->PathHead; PN != NULL; PN = NextPN)
       {
       for (FN = PN->FileHead; FN != NULL; FN = NextFN)
           {
           NextFN = FN->Next;
           LocalFree(FN);
           }

       NextPN = PN->Next;
       LocalFree(PN);
       }

    Tree->PathHead = NULL;
    Tree->PathTail = NULL;
    Tree->NumPaths = 0;
}

////////////////////////////////////////////////////////////////////////////

//  Updates the "All User" menu by moving new items from the Current User's
//  start menu.  In RunMode 0, a snapshot of the Current User's start menu
//  is taken.  After modifications to the Current User's start menu are done,
//  this function is called again with RunMode 1.  Then, it compares the
//  current state of the start menu with the saved snapshot.  Any new or
//  modified files are copied over to the corresponding location in the
//  "All User" start menu.
//
//  RunMode 0 is invoked when the system is changed into install mode and
//  mode 1 is called when the system returns to execute mode.

int TermsrvUpdateAllUserMenu(int RunMode)
{
   TREENODE OrigTree;
   TREENODE NewTree;
   WCHAR p[MAX_PATH];
   int retval;
   PMESSAGE_RESOURCE_ENTRY MessageEntry;
   PVOID DllHandle;
   NTSTATUS Status;
   DWORD dwlen;

   OrigTree.PathHead = NULL;
   OrigTree.PathTail = NULL;
   OrigTree.NumPaths = 0;
   NewTree.PathHead = NULL;
   NewTree.PathTail = NULL;
   NewTree.NumPaths = 0;

   retval = GetEnvironmentVariable(L"UserProfile", p, MAX_PATH);
   if (retval == 0)
      return(-1);

   if (!StartMenu[0]) {
      HINSTANCE hInst;
      typedef HRESULT (* LPFNSHGETFOLDERPATH)(HWND, int, HANDLE, DWORD, LPWSTR);
      LPFNSHGETFOLDERPATH  lpfnSHGetFolderPath;
      WCHAR ssPath[MAX_PATH];
      WCHAR *LastSlash;

      wcscpy( StartMenu, L"\\Start Menu");

      hInst = LoadLibrary(L"SHELL32.DLL");
      if (hInst) {
         lpfnSHGetFolderPath = (LPFNSHGETFOLDERPATH)GetProcAddress(hInst,"SHGetFolderPathW");
         if (lpfnSHGetFolderPath) {
            if (S_OK == lpfnSHGetFolderPath(NULL, CSIDL_STARTMENU, NULL, 0, ssPath)) {
               LastSlash = wcsrevchr(ssPath, L'\\');
               if (LastSlash) {
                  wcscpy(StartMenu, LastSlash);
               }
            }
         }
         FreeLibrary(hInst);
      }
   }
   wcscpy(SaveName,p);
   wcscat(SaveName,L"\\TsAllUsr.Dat");
   wcscpy(CurUserDir,p);
   wcscat(CurUserDir,StartMenu);
   CurUserDirLen = wcslen(CurUserDir);

   dwlen = sizeof(AllUserDir)/sizeof(WCHAR);
   if (GetAllUsersProfileDirectory(AllUserDir, &dwlen))
      {

      wcscat(AllUserDir,StartMenu);

#if DBG
       DbgPrint("SaveName is '%S'\n",SaveName);
       DbgPrint("CurUserDir is '%S'\n",CurUserDir);
       DbgPrint("AllUserDir is '%S'\n",AllUserDir);
#endif

      if (RunMode == 0)
         {
         // If the start menu snapshot already exists, don't overwrite it.
         // The user may enter "change user /install" twice, or an app may
         // force a reboot without changing back to execute mode.  The
         // existing file is older.  If we overwrite it, then some shortcuts
         // won't get moved.
         if (FileExists(SaveName) != TRUE)
            {
            ReadTree(&OrigTree, CurUserDir);
            if (WriteTreeToDisk(&OrigTree) == -1)
               DeleteFile(SaveName);
            FreeTree(&OrigTree);
            }
         }

      else if (RunMode == 1)
         {
         if (ReadTreeFromDisk(&OrigTree) == -1)
            {
            FreeTree(&OrigTree);
            DeleteFile(SaveName);  // Could be a bad file.  If it doesn't
                                   // exist, this won't hurt anything.
            return(-1);
            }

         ReadTree(&NewTree, CurUserDir);
         ProcessChanges(&OrigTree,&NewTree);
         DeleteFile(SaveName);
         FreeTree(&OrigTree);
         FreeTree(&NewTree);
         }
      }

   return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\compatfl.h ===
/*************************************************************************
*
* compatfl.h
*
* Function declarations for Citrix application compatibility flags
*
* copyright notice: Microsoft 1998
*
*
*************************************************************************/

#ifndef _COMPATFLH_
#define _COMPATFLH_

#include <winsta.h>
#include <syslib.h>
#include <regapi.h>

//
// Default limit for physical memory returned by GLobalMemoryStatus
// when physical memory limit is set in the compatibility flags.
//

#define TERMSRV_COMPAT_DEFAULT_PHYSMEMLIM   (32*1024*1024)

// Private Compatibility flags to indicate if flags in TEB are valid
// Other flags values are in syslib.h

#define TERMSRV_COMPAT_BADAPPVALID \
                                0x40000000  // Bad app flags in Teb are valid
#define TERMSRV_COMPAT_TEBVALID \
                                0x80000000  // Compat flags in Teb are valid

#define TERMSRV_COMPAT                   NTAPI_COMPAT_REG_NAME
#define TERMSRV_COMPAT_APP               NTAPI_COMPAT_APPS_REG_PREFIX
#define TERMSRV_COMPAT_DLLS              NTAPI_COMPAT_DLLS_REG_PREFIX
#define TERMSRV_COMPAT_INIFILE           NTAPI_COMPAT_INI_REG_NAME
#define TERMSRV_COMPAT_REGENTRY          NTAPI_COMPAT_REGENTRY_REG_NAME
#define TERMSRV_INIFILE_TIMES            NTAPI_INIFILE_TIMES_REG_NAME
#define USER_SOFTWARE_TERMSRV            REG_SOFTWARE_TSERVER
#define TERMSRV_REG_CONTROL_NAME         REG_NTAPI_CONTROL_TSERVER
#define TERMSRV_CROSS_WINSTATION_DEBUG   REG_CITRIX_CROSSWINSTATIONDEBUG
#define TERMSRV_USER_SYNCTIME            COMPAT_USER_LASTUSERINISYNCTIME
#define TERMSRV_PHYSMEMLIM               COMPAT_PHYSICALMEMORYLIMIT

#define TERMSRV_INIFILE_TIMES_SHORT      L"\\" REG_INSTALL L"\\" REG_INIFILETIMES
#define TERMSRV_INSTALL_SOFTWARE_SHORT   L"\\" REG_INSTALL L"\\Software"
// Define the file information class values
//
// WARNING:  The order of the following values are assumed by the I/O system.
//           Any changes made here should be reflected there as well.
//


typedef struct _BADAPP {
    ULONG BadAppFlags;
    ULONG BadAppFirstCount;
    ULONG BadAppNthCount;
    LARGE_INTEGER BadAppTimeDelay;
} BADAPP, *PBADAPP;

typedef struct _BADCLPBRDAPP {
    ULONG BadClpbrdAppFlags;
    ULONG BadClpbrdAppEmptyRetries;
    ULONG BadClpbrdAppEmptyDelay;
} BADCLPBRDAPP, *PBADCLPBRDAPP;

ULONG GetTermsrCompatFlags(LPWSTR, LPDWORD, TERMSRV_COMPATIBILITY_CLASS);
ULONG GetTermsrCompatFlagsEx(LPWSTR, LPDWORD, TERMSRV_COMPATIBILITY_CLASS);
ULONG GetCtxAppCompatFlags(LPDWORD, LPDWORD);
ULONG GetCtxPhysMemoryLimits(LPDWORD, LPDWORD);
BOOL CtxGetBadAppFlags(LPWSTR, PBADAPP);
BOOL CtxGetBadClpbrdAppFlags(PBADCLPBRDAPP);
BOOL CtxGetModuleBadClpbrdAppFlags(LPWSTR, PBADCLPBRDAPP);
BOOL GetAppTypeAndModName(LPDWORD, PWCHAR, ULONG);

// Defines for compatibility flag caching in kernel32.dll
extern ULONG CompatFlags;
extern BOOL  CompatGotFlags;
extern DWORD CompatAppType;
extern void CtxLogObjectCreate(PUNICODE_STRING, PCHAR, PVOID);

#define CacheCompatFlags \
{ \
    if (!CompatGotFlags ) { \
        GetCtxAppCompatFlags(&CompatFlags, &CompatAppType); \
        CompatGotFlags = TRUE; \
    } \
}

#define LogObjectCreation(ObjName,ObjType,RetAddr) \
{ \
    CacheCompatFlags \
    if (CompatFlags & TERMSRV_COMPAT_LOGOBJCREATE) { \
        CtxLogObjectCreate(ObjName,ObjType,RetAddr); \
    } \
}

// Environment variable for object creation log file
#define OBJ_LOG_PATH_VAR L"TERMSRV_COMPAT_LOGPATH"




#define  DEBUG_IAT   0x80000000  // use the registry to set value of "IAT" to 0x8000000 for debug output.
                                 // value of the optional debug IAT flag read from the registry.
                                 // Currently, only 0x1 and 0x8000000 have meaning, the first disables
                                 // calls to LoabLib, and the 2nd enables debug output.


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\inimap.c ===
/*************************************************************************
*
* inimap.c
*
* Handle Copy-On-Reference Ini File Mapping
*
* copyright notice: Copyright 1998 Micrsoft
*
*
*************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define LOCAL
#include "regmap.h"

//#include "basedll.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

#define IS_NEWLINE_CHAR( c )  ((c == 0x0D) || (c == 0x0A))

/*
 *  INI_BUF_SIZE defines the maximum number of characters that can
 *  be on a single INI file line.  If a line contains more than this
 *  number of characters, the additional characters will be lost.
 */
#define INI_BUF_SIZE 1024


/* Internal Functions */

BOOL
TermsrvDoesFileExist(
    PUNICODE_STRING pFileName
    );

BOOL
TermsrvBuildSysIniPath(
    PUNICODE_STRING pIniPath,
    PUNICODE_STRING pSysPath,
    PUNICODE_STRING pUserPath
    );

BOOL
TermsrvCopyIniFile(
    PUNICODE_STRING pSysPath,
    PUNICODE_STRING pUserPath,
    PUNICODE_STRING pFileName
    );

BOOL
TermsrvGetUnicodeRemainder(
    PUNICODE_STRING pFullPath,
    PUNICODE_STRING pPrefix,
    PUNICODE_STRING pRemainder
    );

NTSTATUS
TermsrvIniCopyLoop(
    HANDLE SrcHandle,
    HANDLE DestHandle
    );

NTSTATUS
TermsrvPutString(
    HANDLE DestHandle,
    PCHAR  pStr,
    ULONG  StringSize
    );

NTSTATUS
TermsrvProcessBuffer(
    PCHAR  *ppStr,
    PULONG pStrSize,
    PULONG pStrBufSize,
    PBOOL  pSawNL,
    PCHAR  pIOBuf,
    PULONG pIOBufIndex,
    PULONG pIOBufFillSize
    );

NTSTATUS
TermsrvGetString(
    HANDLE SrcHandle,
    PCHAR  *ppStringPtr,
    PULONG pStringSize,
    PCHAR  pIOBuf,
    ULONG  IOBufSize,
    PULONG pIOBufIndex,
    PULONG pIOBufFillSize
    );

NTSTATUS
TermsrvIniCopyAndChangeLoop(
    HANDLE SrcHandle,
    HANDLE DestHandle,
    PUNICODE_STRING pUserFullPath,
    PUNICODE_STRING pSysFullPath
    );

BOOL
TermsrvReallocateBuf(
    PCHAR  *ppStr,
    PULONG pStrBufSize,
    ULONG  NewSize
    );


PCHAR
Ctxstristr( PCHAR pstring1,
            PCHAR pstring2
          );


NTSTATUS
TermsrvCheckKeys(HANDLE hKeySysRoot,
             HANDLE hKeyUsrRoot,
             PKEY_BASIC_INFORMATION pKeySysInfo,
             PKEY_FULL_INFORMATION pKeyUsrInfo,
             ULONG ulcsys,
             ULONG ulcusr,
             DWORD  indentLevel);

NTSTATUS
TermsrvCloneKey(HANDLE hKeySys,
            HANDLE hKeyUsr,
            PKEY_FULL_INFORMATION pDefKeyInfo,
            BOOL fCreateSubKeys);

VOID
InitUnicodeStringWithLen(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString,
    IN USHORT StringLength
    );

void TermsrvCheckNewRegEntries(IN LPCWSTR wszBaseKeyName);

BOOL
TermsrvGetUserSyncTime(PULONG pultime);

BOOL
TermsrvSetUserSyncTime(void);

NTSTATUS 
TermsrvCheckNewIniFilesInternal(IN LPCWSTR wszBaseKeyName);

NTSTATUS 
GetFullKeyPath(
        IN HANDLE hKeyParent,
        IN LPCWSTR wszKey,
        OUT LPWSTR *pwszKeyPath);

PWINSTATIONQUERYINFORMATIONW pWinStationQueryInformationW;

DWORD g_debugIniMap=FALSE;

DWORD IsDebugIniMapEnabled()
{
    HKEY    hKey;
    DWORD   rc;
    DWORD   res=0;
    DWORD   size;

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install",
                  0, KEY_READ, &hKey );

    size = sizeof(DWORD);

    if (rc == ERROR_SUCCESS )
    {
        rc = RegQueryValueEx( hKey, L"debug",  NULL , NULL , (LPBYTE ) &res, & size  ) ;

        if (rc != ERROR_SUCCESS )
        {
            res = FALSE;
        }
        RegCloseKey( hKey );
    }

    return res;
}

void    Indent( ULONG indent)
{
    ULONG   i;
    for ( i = 1; i <indent ; i++ )
    {
        DbgPrint("%ws", L"\t");
    }
}

// last param is a unicode string
void Debug1( DWORD indent, DWORD line, WCHAR *where, UNICODE_STRING *pS )
{
    WCHAR   s[1024];

    if (g_debugIniMap)
    {
        wcsncpy( s, pS->Buffer, pS->Length );
    
        s[pS->Length + 1 ] = L'\0';
    
        Indent( indent );
        DbgPrint("L: %4d, %10ws: %ws \n", line, where, s );
    }

}


// last param two params, one is the wchar str and the last one is the length. Boy I miss c++ and func overloading...
void Debug2( DWORD indent, DWORD line, WCHAR *where, WCHAR *pS , DWORD length)
{
    WCHAR   s[1024];

    if (g_debugIniMap)
    {
        wcsncpy( s, pS, length );
    
        s[length + 1 ] = L'\0';
    
        Indent( indent );
        DbgPrint("L: %4d, %10ws: %ws \n", line, where, s );
    }

}

void DebugTime( DWORD indent, DWORD line, WCHAR *comment, LARGE_INTEGER li )
{
    if (g_debugIniMap)
    {
        Indent( indent );
        DbgPrint("L: %4d, %5ws : %I64x \n",  line , comment , li.QuadPart );
    }
}

/*****************************************************************************
 *
 *  TermsrvGetUserSyncTime
 *
 *  This routine will get the last time we sync'd up this user's .ini files
 *  and registry values with the system versions.
 *
 * ENTRY:
 *   PULONG pultime: pointer to receive last sync time (in seconds since 1970)
 *
 * EXIT:
 *   SUCCESS:
 *      returns TRUE
 *   FAILURE:
 *      returns FALSE
 *
 ****************************************************************************/

BOOL TermsrvGetUserSyncTime(PULONG pultime)
{
    ULONG ullen, ultmp;
    NTSTATUS Status;
    HANDLE hKey, hKeyRoot;
    OBJECT_ATTRIBUTES ObjectAttr;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo;
    UNICODE_STRING UniString, UserSID;
    PWCHAR pwch;

    // Allocate a buffer for the key value name and time info
    ullen = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG);
    pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ullen);

    // If we didn't get the buffer, return
    if (!pKeyValInfo) {
        return(FALSE);
    }

    Status = RtlOpenCurrentUser(KEY_READ,
                                &hKeyRoot);

    if (NT_SUCCESS(Status)) {

        // Now open up the Citrix key for this user
        RtlInitUnicodeString(&UniString,
                             USER_SOFTWARE_TERMSRV);

        InitializeObjectAttributes(&ObjectAttr,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   hKeyRoot,
                                   NULL);

        Status = NtCreateKey(&hKey,
                             KEY_READ,
                             &ObjectAttr,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &ultmp);

        NtClose(hKeyRoot);
    }

    // If we opened the key, and it was already there, get the value
    if (NT_SUCCESS(Status) && (ultmp == REG_OPENED_EXISTING_KEY)) {
        RtlInitUnicodeString(&UniString, TERMSRV_USER_SYNCTIME);
        Status = NtQueryValueKey(hKey,
                                 &UniString,
                                 KeyValuePartialInformation,
                                 pKeyValInfo,
                                 ullen,
                                 &ultmp);

        NtClose(hKey);
        if (NT_SUCCESS(Status)) {
            *pultime = *(PULONG)pKeyValInfo->Data;
        }
    } else {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }

    RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
    return(NT_SUCCESS(Status));
}


/*****************************************************************************
 *
 *  TermsrvSetUserSyncTime
 *
 *  This routine will set the current time as this user's last .ini file
 *  sync time.
 *
 * ENTRY:
 *
 * EXIT:
 *   SUCCESS:
 *      returns TRUE
 *   FAILURE:
 *      returns FALSE
 *
 ****************************************************************************/

BOOL TermsrvSetUserSyncTime(void)
{
    ULONG ultmp;
    NTSTATUS Status;
    HANDLE hKey, hKeyRoot;
    OBJECT_ATTRIBUTES ObjectAttr;
    UNICODE_STRING UniString;
    PWCHAR pwch;
    FILETIME FileTime;

    Status = RtlOpenCurrentUser(KEY_WRITE,
                                &hKeyRoot);

    if (NT_SUCCESS(Status)) {

        // Now open up the Citrix key for this user
        RtlInitUnicodeString(&UniString,
                             USER_SOFTWARE_TERMSRV);

        InitializeObjectAttributes(&ObjectAttr,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   hKeyRoot,
                                   NULL);

        Status = NtCreateKey(&hKey,
                             KEY_WRITE,
                             &ObjectAttr,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &ultmp);
        NtClose(hKeyRoot);
    }

    // If we opened the key, and set the sync time value
    if (NT_SUCCESS(Status)) {
        // Get the system time, convert to local time, and convert to seconds
        GetSystemTimeAsFileTime(&FileTime);
        RtlTimeToSecondsSince1970((PLARGE_INTEGER)&FileTime,
                                  &ultmp);

        RtlInitUnicodeString(&UniString,
                             TERMSRV_USER_SYNCTIME);

        // Now store it under the citrix key in the registry
        Status = NtSetValueKey(hKey,
                               &UniString,
                               0,
                               REG_DWORD,
                               &ultmp,
                               sizeof(ultmp));

        NtClose(hKey);
    } else {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }

    return(NT_SUCCESS(Status));
}



/*****************************************************************************
 *
 *  TermsrvCORIniFile
 *
 *   Copy On Reference an Ini file
 *
 *   This function is called to copy an ini file from the system
 *   directory to a users local ini file directory.
 *
 *   The path supplied is the fully translated TERMSRV INI file path,
 *   whichs points to a users directory.
 *
 *   This string is used to find the system ini file, and copy it to the
 *   users directory.
 *
 *   All paths are NT paths, NOT WIN32 paths.
 *
 *   Example:
 *
 *   \DosDevices\U:\users\default\windows\win.ini is the path given
 *
 *   %SystemRoot%\win.ini is the "default" location with ini mapping off.
 *
 *   If \DosDevices\U:\users\default\windows\win.ini does not exist, test to see if
 *   %SystemRoot%\win.ini exists, and if does, copy the system version
 *   to the users directory.
 *
 *   NOTE: If the path is to the normal unmapped system directory, just
 *         return since there is no mapping occuring.
 *
 * ENTRY:
 *   pUserFullPath (input)
 *     Translated TERMSRV INI path name
 *
 * EXIT:
 *
 ****************************************************************************/

VOID
TermsrvCORIniFile(
    PUNICODE_STRING pUserFullPath
    )
{
    DWORD Result;
    BOOL  rc;
    UNICODE_STRING SysFullPath;
    UNICODE_STRING UserBasePath;

    /*
     * If in install mode, just return to make
     * everything behave as stock NT.
     */
    if ( IsSystemLUID() || TermsrvAppInstallMode() ) {
        TRACE0(("TermsrvCORIniFile: INI file mapping is OFF\n"));
        return;
    }

    if (!TermsrvPerUserWinDirMapping()) {
        return;
    }

    /*
     * If a NULL file name, just return
     */
    if( (pUserFullPath == NULL) || (pUserFullPath->Buffer == NULL) ) {
        TRACE0(("TermsrvCORIniFile: NULL File INI file name\n"));
        return;
    }

    /*
     * Test if user file exists
     */
    if( TermsrvDoesFileExist( pUserFullPath ) ) {

        TRACE0(("TermsrvCORIniFile: File %ws Exists\n",pUserFullPath->Buffer));
        //
        // Nothing to do if the user already has a copy
        //
        return;
    }
    else {
        TRACE0(("TermsrvCORIniFile: File %ws DOES NOT Exist!\n",pUserFullPath->Buffer));
    }

    /*
     * The requested ini file does not exist in the users local
     * directory. We must change the path name to point to the system
     * directory, and test if the ini file exists there.
     */

    /*
     * Build full system path to the Ini file.
     *
     * This also parses out the users base path and returns that as well.
     */
    if( !TermsrvBuildSysIniPath( pUserFullPath, &SysFullPath, &UserBasePath ) ) {

        TRACE0(("TermsrvCORIniFile: Error building Sys Ini Path!\n"));
        return;
    }

    /*
     * Test if system version exists
     */
    if( !TermsrvDoesFileExist( &SysFullPath ) ) {
        //
        // It does not exist in the system directory either,
        // so we just return.
        //
        TRACE0(("TermsrvCORIniFile: Path %ws does not exist in system dir, Length %d\n",SysFullPath.Buffer,SysFullPath.Length));
        TRACE0(("TermsrvCORIniFile: UserPath %ws\n",pUserFullPath->Buffer));
        RtlFreeHeap( RtlProcessHeap(), 0, SysFullPath.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, UserBasePath.Buffer );
        return;
    }

    /*
     * Now Copy it.
     *
     * The copy routine could also translate any paths internal to the
     * ini file that point to the system directory, to point to the user
     * directory in the base path.
     */
    rc = TermsrvCopyIniFile( &SysFullPath, &UserBasePath, pUserFullPath);

#if DBG
    if( !rc ) {
        DBGPRINT(("TermsrvCORIniFile: Could not copy file %ws to %ws\n",SysFullPath.Buffer,pUserFullPath->Buffer));
    }
#endif

    RtlFreeHeap( RtlProcessHeap(), 0, SysFullPath.Buffer );
    RtlFreeHeap( RtlProcessHeap(), 0, UserBasePath.Buffer );

    return;
}


/*****************************************************************************
 *
 *  TermsrvDoesFileExist
 *
 *   Returns whether the file exists or not.
 *
 *   Must use NT, not WIN32 pathnames.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
TermsrvDoesFileExist(
    PUNICODE_STRING pFileName
    )
{
    NTSTATUS Status;
    FILE_BASIC_INFORMATION BasicInfo;
    OBJECT_ATTRIBUTES Obja;

    InitializeObjectAttributes(
        &Obja,
        pFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    /*
     * Now query it
     */
    Status = NtQueryAttributesFile( &Obja, &BasicInfo );

    if( NT_SUCCESS( Status ) ) {
        return( TRUE );
    }

    return( FALSE );
}


/*****************************************************************************
 *
 *  TermsrvBuildSysIniPath
 *
 *   Builds the full ini path to pointing to the system directory
 *   from the users private ini path.
 *
 *   Also returns the users base ini path directory to be used by
 *   the ini file path conversion when copying.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
TermsrvBuildSysIniPath(
    PUNICODE_STRING pUserFullPath,
    PUNICODE_STRING pSysFullPath,
    PUNICODE_STRING pUserBasePath
    )
{
    BOOL     rc = FALSE;
    NTSTATUS Status;
    UNICODE_STRING SysBasePath;
    UNICODE_STRING IniPathTail;
    UNICODE_STRING UniSysDir;
    WCHAR CtxWindowsPath[MAX_PATH+1];
    UNICODE_STRING CtxWindowsDir = {
        sizeof(CtxWindowsPath),
        sizeof(CtxWindowsPath),
        CtxWindowsPath
    };
    OBJECT_ATTRIBUTES ObjectAttr;
    HKEY   hKey = 0;
    ULONG  ul;
    PKEY_VALUE_FULL_INFORMATION pKeyValInfo;
    WCHAR SystemWindowsDirectory[MAX_PATH+1];

    if (!TermsrvPerUserWinDirMapping()) {
        return FALSE;
    }

    SysBasePath.Buffer = NULL;

    pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH
                                 );
    if (pKeyValInfo) {
        RtlInitUnicodeString(&UniSysDir,
                             TERMSRV_COMPAT
                            );

        InitializeObjectAttributes(&ObjectAttr,
                                   &UniSysDir,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        Status = NtOpenKey(&hKey, KEY_READ, &ObjectAttr);

        if (NT_SUCCESS(Status)) {

            RtlInitUnicodeString(&UniSysDir, L"SYSDIR");
            Status = NtQueryValueKey(hKey,
                                     &UniSysDir,
                                     KeyValueFullInformation,
                                     pKeyValInfo,
                                     sizeof(KEY_VALUE_FULL_INFORMATION) +
                                         MAX_PATH,
                                     &ul
                                    );

            if (NT_SUCCESS(Status)) {
                NtClose(hKey);

                if (ul = wcslen((PWCHAR)((PCHAR)pKeyValInfo +
                                    pKeyValInfo->DataOffset))) {

                    RtlInitUnicodeString(&UniSysDir,
                                         (PWCHAR)((PCHAR)pKeyValInfo +
                                             pKeyValInfo->DataOffset)
                                        );

                    // Convert to an NT path
                    rc = RtlDosPathNameToNtPathName_U(
                             UniSysDir.Buffer,
                             &SysBasePath,
                             NULL,
                             NULL
                            );

                    // Was this a valid path?  If not, use actual system directory.
                    if (rc && !TermsrvDoesFileExist(&SysBasePath)) {
                        RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
                        SysBasePath.Buffer = NULL;
                        rc = FALSE;
                    }

                    // if the path is the root, get rid of last backslash
                    if (ul == 3 && SysBasePath.Buffer) {
                        SysBasePath.Buffer[SysBasePath.Length/sizeof(WCHAR)] = L'\0';
                        SysBasePath.Length -= 2;
                    }
                }
            }
        }
    }

    GetSystemWindowsDirectory(SystemWindowsDirectory,(MAX_PATH * sizeof(WCHAR)));

    if (!rc) {

        /*
         * We must convert the SystemWindowsDirectory from a WIN32 path to
         * an NT path.
         */
        rc = RtlDosPathNameToNtPathName_U( SystemWindowsDirectory,
                                           &SysBasePath,
                                           NULL,
                                           NULL
                                         );
    }

    if (pKeyValInfo) {
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
    }

    TRACE0(("BaseWindowsDirectory is %ws\n",SystemWindowsDirectory));

    if( !rc ) {
        DBGPRINT(("BuildSysIniPath: Error translating system path to NT path %ws\n",SystemWindowsDirectory));
        return( FALSE );
    }

    TRACE0(("BuildSysIniPath: NT SYS path is %ws\n",SysBasePath.Buffer));

    /*
     * Get the users windows path prefix
     */
    Status = GetPerUserWindowsDirectory( &CtxWindowsDir );
    if( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("BuildSysIniPath: Could not get TermsrvWindowsDir 0x%x\n",Status));
        RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
        return( FALSE );
    }

    /*
     * Now convert it into an NT path
     */
    rc = RtlDosPathNameToNtPathName_U(
             CtxWindowsDir.Buffer,
             pUserBasePath,
             NULL,
             NULL
             );

    if( !rc ) {
        DBGPRINT(("BuildSysIniPath: Could not convert TermsrvWindowsDir %d\n",rc));
        RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
        return( FALSE );
    }

    TRACE0(("BuildSysIniPath: Users Ini PathBase is %ws\n",pUserBasePath->Buffer));

    //
    // Here we have:
    //
    // SysBasePath, UserBasePath
    //
    // UserFullPath, must now build SysFullPath
    //

    rc = TermsrvGetUnicodeRemainder( pUserFullPath, pUserBasePath, &IniPathTail );

    if( !rc ) {
        WCHAR szShortPath[MAX_PATH];
        WCHAR szPath[MAX_PATH];
        UNICODE_STRING ShortPath;

        //
        // GetShortPathName doesn't take NT Path. Strip out "\??\"
        //
        if (!wcsncmp(pUserBasePath->Buffer,L"\\??\\",4)) {
            wcsncpy(szPath,&(pUserBasePath->Buffer[4]),(pUserBasePath->Length - 4));
        } else {
            wcsncpy(szPath,pUserBasePath->Buffer,pUserBasePath->Length);
        }
        if (GetShortPathNameW(szPath,szShortPath,MAX_PATH)) {

            if (!wcsncmp(pUserBasePath->Buffer,L"\\??\\",4)) {
                wcscpy(szPath,L"\\??\\");
                wcscat(szPath,szShortPath);
            } else {
                wcscpy(szPath,szShortPath);
            }

            RtlInitUnicodeString(&ShortPath,szPath);
            rc = TermsrvGetUnicodeRemainder( pUserFullPath, &ShortPath, &IniPathTail );
        }

        if (!rc) {
            RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
            RtlFreeHeap( RtlProcessHeap(), 0, pUserBasePath->Buffer );
            return( FALSE );
        }
    }

    pSysFullPath->Length = 0;
    pSysFullPath->MaximumLength = (MAX_PATH+1)*sizeof(WCHAR);
    pSysFullPath->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, pSysFullPath->MaximumLength );

    if( pSysFullPath->Buffer == NULL ) {
        DBGPRINT(("BuildSysPath: Error in memory allocate\n"));
        RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, IniPathTail.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, pUserBasePath->Buffer );
        return( FALSE );
    }

    TRACE0(("BuildSysPath: IniPathTail :%ws:, Length %d\n",IniPathTail.Buffer,IniPathTail.Length));
    RtlCopyUnicodeString( pSysFullPath, &SysBasePath );

     if ((pSysFullPath->Buffer[pSysFullPath->Length/sizeof(WCHAR) -1 ] != L'\\') &&
        (IniPathTail.Buffer[0] != L'\\')) {     // check whether need "\\"
        Status = RtlAppendUnicodeToString(pSysFullPath, L"\\");
        if ( !NT_SUCCESS( Status) ) {
            DBGPRINT(("BuildSysPath: Error appending UnicodeStirng\n",Status));
            return( FALSE );
        }
     }

    Status = RtlAppendUnicodeStringToString( pSysFullPath, &IniPathTail );

    if( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("BuildSysPath: Error 0x%x appending UnicodeString\n",Status));
        RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, IniPathTail.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, pUserBasePath->Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, pSysFullPath->Buffer );
        return( FALSE );
    }

    TRACE0(("BuildSysPath: SysFullPath :%ws:, Length %d\n",pSysFullPath->Buffer,pSysFullPath->Length));

    /*
     * Free the local resources allocated
     */
    RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
    RtlFreeHeap( RtlProcessHeap(), 0, IniPathTail.Buffer );

    return( TRUE );
}


/*****************************************************************************
 *
 *  TermsrvGetUnicodeRemainder
 *
 *   Given the full path, and a prefix, return the remainder of
 *   the UNICODE_STRING in newly allocated buffer space.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   TRUE  - no error
 *   FALSE - error
 *
 ****************************************************************************/

BOOL
TermsrvGetUnicodeRemainder(
    PUNICODE_STRING pFullPath,
    PUNICODE_STRING pPrefix,
    PUNICODE_STRING pRemainder
    )
{
    WCHAR c1, c2;
    USHORT Index, RemIndex;
    USHORT PathLen, PrefixLen, RemLen;

    PathLen = pFullPath->Length / sizeof(WCHAR);
    PrefixLen = pPrefix->Length / sizeof(WCHAR);

    if( (PathLen == 0) || (PrefixLen == 0) ) {
        TRACE1(("TermsrvGetUnicodeRemainder: 0 PathLength Full %d, Prefix %d\n",PathLen,PrefixLen));
        return( FALSE );
    }

    Index = 0;
    while( PathLen && PrefixLen ) {

        c1 = pFullPath->Buffer[Index];
        c2 = pPrefix->Buffer[Index];

        // Do a fast case insensitive compare
        if( (c1 != c2) && (towupper(c1) != towupper(c2)) ) {
            TRACE1(("TermsrvGetUnicodeRemainder: Non matching character Index %d\n",Index));
            return( FALSE );
        }

        PathLen--;
        PrefixLen--;
        Index++;
    }

    // If prefix is longer, its an error
    if( PrefixLen ) {
        TRACE1(("TermsrvGetUnicodeRemainder: Prefix is longer\n"));
        return(FALSE);
    }

    // If PathLen is 0, there is no remainder.
    if( PathLen == 0 ) {
        RemLen = 0;
    }
    else {
        RemLen = PathLen;
    }

    // Allocate memory for remainder, including a UNICODE_NULL
    pRemainder->Length = RemLen*sizeof(WCHAR);
    pRemainder->MaximumLength = (RemLen+1)*sizeof(WCHAR);
    pRemainder->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, pRemainder->MaximumLength );
    if( pRemainder->Buffer == NULL ) {
        TRACE1(("TermsrvGetUnicodeRemainder: Memory allocation error\n"));
        return( FALSE );
    }

    RemIndex  = 0;
    while( RemLen ) {

        pRemainder->Buffer[RemIndex] = pFullPath->Buffer[Index];

        Index++;
        RemIndex++;
        RemLen--;
    }

    // Now include the UNICODE_NULL
    pRemainder->Buffer[RemIndex] = UNICODE_NULL;

    TRACE0(("TermsrvGetUnicodeRemainder: Remainder %ws\n",pRemainder->Buffer));

    return( TRUE );
}


/*****************************************************************************
 *
 *  TermsrvCopyIniFile
 *
 *   Copies the INI file from the system directory to the
 *   users directory.
 *
 *   Any paths inside the INI file that match pUserBasePath and do not point
 *   to a shareable application resource will be translated.
 *
 * ENTRY:
 *  PUNICODE_STRING pSysFullPath (In)  - Path of ini file in system dir (source)
 *  PUNICODE_STRING pUserBasePath (In) - Optional, User's windows home dir
 *  PUNICODE_STRING pUserFullPath (In) - Path of ini file in user's home dir (dest)
 *
 * Notes:
 *  If pUserBasePath is NULL, no path substitution is done as the ini file is
 *  copied from the system directory to the user's home directory.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
TermsrvCopyIniFile(
    PUNICODE_STRING pSysFullPath,
    PUNICODE_STRING pUserBasePath,
    PUNICODE_STRING pUserFullPath
    )
{
    NTSTATUS Status;
    HANDLE SrcHandle, DestHandle;
    OBJECT_ATTRIBUTES SrcObja;
    OBJECT_ATTRIBUTES DestObja;
    IO_STATUS_BLOCK   SrcIosb;
    IO_STATUS_BLOCK   DestIosb;
    PWCHAR            pwch, pwcIniName;
    ULONG             ulCompatFlags;

    TRACE0(("TermsrvCopyIniFile: From %ws, TO -> %ws\n",pSysFullPath->Buffer,pUserFullPath->Buffer));
    TRACE0(("UserBasePath %ws\n",pUserBasePath->Buffer));

    /*
     * This must all be done at the NT level
     */
    InitializeObjectAttributes(
        &SrcObja,
        pSysFullPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    InitializeObjectAttributes(
        &DestObja,
        pUserFullPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    // Open the src
    SrcIosb.Status = STATUS_SUCCESS;
    Status = NtOpenFile(
                 &SrcHandle,
                 FILE_GENERIC_READ,
                 &SrcObja,
                 &SrcIosb,
                 FILE_SHARE_READ|FILE_SHARE_WRITE,
                 FILE_SYNCHRONOUS_IO_NONALERT    // OpenOptions
                 );

    if( NT_SUCCESS(Status) ) {
        // Get final I/O status
        Status = SrcIosb.Status;
    }

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("TermsrvCopyIniFile: Error 0x%x opening SrcFile %ws\n",Status,pSysFullPath->Buffer));
        return( FALSE );
    }

    // Create the destination file
    DestIosb.Status = STATUS_SUCCESS;
    Status = NtCreateFile(
                 &DestHandle,
                 FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                 &DestObja,
                 &DestIosb,
                 NULL,        // Allocation size
                 FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes
                 FILE_SHARE_WRITE,      // dwShareMode
                 FILE_OVERWRITE_IF,           // CreateDisposition
                 FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, // CreateFlags
                 NULL, // EaBuffer
                 0     // EaLength
                 );

    if( NT_SUCCESS(Status) ) {
        // Get final I/O status
        Status = DestIosb.Status;
    }

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("TermsrvCopyIniFile: Error 0x%x Creating DestFile %ws\n",Status,pUserFullPath->Buffer));
        NtClose( SrcHandle );
        return( FALSE );
    }

    TRACE0(("TermsrvCopyFile: Create Disposition 0x%x\n",DestIosb.Information));

    // Get the ini file name
    pwch = wcsrchr(pSysFullPath->Buffer, L'\\') + 1;
    pwcIniName = RtlAllocateHeap( RtlProcessHeap(),
                                  0,
                                  (wcslen(pwch) + 1)*sizeof(WCHAR));
    if(!pwcIniName)
    {
        DBGPRINT(("TermsrvCopyIniFile: Error Allocating pwcIniName\n"));
        NtClose( SrcHandle );
        NtClose( DestHandle );
        return( FALSE );
    }

    wcscpy(pwcIniName, pwch);
    pwch = wcsrchr(pwcIniName, L'.');
    if (pwch) {
        *pwch = L'\0';
    }

    GetTermsrCompatFlags(pwcIniName, &ulCompatFlags, CompatibilityIniFile);

    RtlFreeHeap( RtlProcessHeap(), 0, pwcIniName );

    /*
     * Now do the copy loop
     */
    if (pUserBasePath && !(ulCompatFlags & TERMSRV_COMPAT_ININOSUB)) {
        Status = TermsrvIniCopyAndChangeLoop( SrcHandle,
                                          DestHandle,
                                          pUserBasePath,
                                          pSysFullPath
                                        );
    } else {
        Status = TermsrvIniCopyLoop( SrcHandle, DestHandle );
    }

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("TermsrvCopyIniFile: Error 0x%x Doing copy loop\n",Status));
        NtClose( SrcHandle );
        NtClose( DestHandle );
        return( FALSE );
    }

    /*
     * Close the file handles
     */
    NtClose( SrcHandle );
    NtClose( DestHandle );

    return( TRUE );
}

/*****************************************************************************
 *
 *  TermsrvIniCopyLoop
 *
 *   Actual copy loop. This copies the src ini file to the destination
 *   ini file.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
TermsrvIniCopyLoop(
    HANDLE SrcHandle,
    HANDLE DestHandle
    )
{
    NTSTATUS Status;
    PCHAR  pBuf = NULL;
    IO_STATUS_BLOCK   Iosb;

    pBuf = LocalAlloc( LPTR, INI_BUF_SIZE );
    if ( !pBuf ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    while( 1 ) {

        Iosb.Status = STATUS_SUCCESS;
        Status = NtReadFile(
                     SrcHandle,
                     NULL,      // Event
                     NULL,      // APC routine
                     NULL,      // APC context
                     &Iosb,
                     pBuf,
                     INI_BUF_SIZE,
                     NULL,      // ByteOffset (not used since in synchronous I/O)
                     NULL       // Key
                     );

        if( Status == STATUS_PENDING ) {
            Status = NtWaitForSingleObject( SrcHandle, FALSE, NULL );
        }

        if( NT_SUCCESS(Status) ) {
            // Get final I/O status
            Status = Iosb.Status;
        }

        if( !NT_SUCCESS(Status) ) {
            if( Status == STATUS_END_OF_FILE ) {
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }
            DBGPRINT(("TermsrvIniCopyLoop: Error 0x%x doing NtReadFile\n",Status));
            goto Cleanup;
        }

        Iosb.Status = STATUS_SUCCESS;
        Status = NtWriteFile(
                     DestHandle,
                     NULL,      // Event
                     NULL,      // APC routine
                     NULL,      // APC context
                     &Iosb,
                     pBuf,
                     (ULONG)Iosb.Information,  // Actual amount read
                     NULL,      // ByteOffset (not used since in synchronous I/O)
                     NULL       // Key
                     );

        if( Status == STATUS_PENDING ) {
            Status = NtWaitForSingleObject( DestHandle, FALSE, NULL );
        }

        if( NT_SUCCESS(Status) ) {
            // Get final I/O status
            Status = Iosb.Status;
        }

        if( !NT_SUCCESS(Status) ) {
            DBGPRINT(("TermsrvIniCopyLoop: Error 0x%x doing NtWriteFile\n",Status));
            goto Cleanup;
        }

    } // end while(1)

Cleanup:

    if ( pBuf ) {
        LocalFree( pBuf );
    }
    return( Status );
}

/*****************************************************************************
 *
 *  TermsrvIniCopyAndChangeLoop
 *
 *   Actual copy loop. This copies the src ini file to the destination
 *   ini file. It also handles any path translations.
 *
 * ENTRY:
 *  HANDLE SrcHandle (In) - Source file handle
 *  HANDLE DestHandle (In) - Destination file handle
 *  PUNICODE_STRING pUserFullPath (In) - Ptr to Uni string with user's home
 *                                       windows dir
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
TermsrvIniCopyAndChangeLoop(
    HANDLE SrcHandle,
    HANDLE DestHandle,
    PUNICODE_STRING pUserFullPath,
    PUNICODE_STRING pSysFullPath
    )
{
    PCHAR pStr, pch, ptemp, pnext;
    PWCHAR pwch;
    NTSTATUS Status;
    ULONG StringSize;
    CHAR  IOBuf[512];
    ULONG IOBufSize = 512;
    ULONG IOBufIndex = 0;
    ULONG IOBufFillSize = 0;
    ANSI_STRING AnsiUserDir, AnsiSysDir;
    UNICODE_STRING UniString;

    // Get the DOS filename from the NT file name
    if (pwch = wcschr(pUserFullPath->Buffer, L':')) {
        pwch--;
    } else {
        pwch = pUserFullPath->Buffer;
    }

    RtlInitUnicodeString( &UniString, pwch );

    Status = RtlUnicodeStringToAnsiString( &AnsiUserDir,
                                           &UniString,
                                           TRUE
                                         );
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("TermsrvIniCopyAndChangeLoop: Error 0x%x converting user dir\n", Status));
        return(Status);
    }

    // Get the system directory from the fully qualified system path
    if (pwch = wcschr(pSysFullPath->Buffer, L':')) {
        pwch--;
    } else {
        pwch = pUserFullPath->Buffer;
    }

    RtlInitUnicodeString( &UniString, pwch );

    Status = RtlUnicodeStringToAnsiString( &AnsiSysDir,
                                           &UniString,
                                           TRUE
                                         );

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("TermsrvIniCopyAndChangeLoop: Error 0x%x converting system dir\n", Status));
        RtlFreeAnsiString( &AnsiUserDir );
        return(Status);
    }

    pch = strrchr(AnsiSysDir.Buffer, '\\');

    // unless something has gone wrong, we should always have a pch since a full-path always
    // has at least "\" in it, and actually in our case, we have atleast two slashes inside,
    // since we are dealing with a string such as "\A\file.ini", where 'A' is a folder
    // name that has at least one letter in it
    if (pch)
    {

        if ((pch - AnsiSysDir.Buffer) > 2) {
            *pch = '\0';
        } else {
            *(pch+1) = '\0';
        }
        AnsiSysDir.Length = (USHORT) strlen(AnsiSysDir.Buffer);

        while( 1 ) {

            pStr = NULL;
            StringSize = 0;

            /*
             * Get a string from the source ini file
             */
            Status = TermsrvGetString(
                         SrcHandle,
                         &pStr,
                         &StringSize,
                         IOBuf,
                         IOBufSize,
                         &IOBufIndex,
                         &IOBufFillSize
                         );

            if( !NT_SUCCESS(Status) ) {

                ASSERT( pStr == NULL );

                RtlFreeAnsiString( &AnsiUserDir );
                RtlFreeAnsiString( &AnsiSysDir );

                if( Status == STATUS_END_OF_FILE ) {
                    return( STATUS_SUCCESS );
                }
                return( Status );
            }

            /*
             * Process the string for any ini path translations
             */
            ASSERT( pStr != NULL );

            // Go through the string looking for anything that contains the system
            // directory.
            if (pch = Ctxstristr(pStr, AnsiSysDir.Buffer)) {
                // See if this entry might point to an ini file
                if ((ptemp = strchr(pch, '.')) && !(_strnicmp(ptemp, ".ini", 4))) {

                    // Check to make sure this is the right string to replace
                    pnext = pch + AnsiSysDir.Length + 1;
                    while (pch && (pnext < ptemp)) {
                        // Check for another entry
                        if (*pnext == ',') {
                            pch = Ctxstristr(pnext, AnsiSysDir.Buffer);
                            if (pch) {
                                pnext = pch + AnsiSysDir.Length + 1;
                            }
                        }
                        pnext++;
                    }

                    // Check that this .ini is in the system directory
                    pnext = pch + AnsiSysDir.Length + 1;
                    while (pch && (pnext < ptemp)) {
                        if (*pnext == '\\') {
                            pch = NULL;
                        }
                        pnext++;
                    }

                    if (pch && (pch < ptemp)) {
                        ptemp = RtlAllocateHeap( RtlProcessHeap(),
                                                 0,
                                                 StringSize + AnsiUserDir.Length );
                        strncpy(ptemp, pStr, (size_t)(pch - pStr));       // copy up to sys dir
                        ptemp[pch - pStr] = '\0';
                        strcat(ptemp, AnsiUserDir.Buffer);      // subst user dir
                        if (AnsiSysDir.Length == 3) {
                            strcat(ptemp, "\\");
                        }
                        strcat(ptemp, pch + AnsiSysDir.Length); // append rest of line
                        RtlFreeHeap( RtlProcessHeap(), 0, pStr );
                        StringSize = strlen(ptemp);
                        pStr = ptemp;
                    }
                }
            }

            /*
             * Write out the translated string
             */
            Status = TermsrvPutString(
                         DestHandle,
                         pStr,
                         StringSize
                         );

              RtlFreeHeap( RtlProcessHeap(), 0, pStr );

            if( !NT_SUCCESS(Status) ) {
                DBGPRINT(("TermsrvIniCopyLoop: Error 0x%x doing NtWriteFile\n",Status));
                RtlFreeAnsiString( &AnsiUserDir );
                RtlFreeAnsiString( &AnsiSysDir );
                return( Status );
            }

        } // end while(1)
    }
    else
    {
        return STATUS_UNSUCCESSFUL;

    }
}


/*****************************************************************************
 *
 *  TermsrvGetString
 *
 *   This function gets a "string" from an ini file and returns it to the
 *   caller. Since processing must be done in memory on the strings, they
 *   are returned NULL terminated, but this NULL is NOT included in the
 *   returned string size. Of course, buffer size calculations take this
 *   NULL into account. Strings retain any <CR><LF> characters and are
 *   not stripped out like the C runtime.
 *
 *   The I/O buffer used is passed in by the caller. If the IoBufIndex is
 *   not 0, this is an indication that there is still data left in the buffer
 *   from a previous operation. This data is used before reading additional
 *   data from the file handle. This handles the case where string breaks
 *   do not occur at buffer boundries.
 *
 *   Strings are returned in newly allocated memory on the process heap.
 *   The caller is reponsible for freeing them when done.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
TermsrvGetString(
    HANDLE SrcHandle,
    PCHAR  *ppStringPtr,
    PULONG pStringSize,
    PCHAR  pIOBuf,
    ULONG  IOBufSize,
    PULONG pIOBufIndex,
    PULONG pIOBufFillSize
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK   Iosb;
    BOOL  SawNL = FALSE;
    ULONG StrSize = 0;
    ULONG StrBufSize = 512;
    PCHAR pStr = NULL;

    /*
     * first process any left over data in the current I/O buffer
     */
    if( *pIOBufIndex < *pIOBufFillSize ) {

        Status = TermsrvProcessBuffer(
                     &pStr,
                     &StrSize,
                     &StrBufSize,
                     &SawNL,
                     pIOBuf,
                     pIOBufIndex,
                     pIOBufFillSize
                     );

        if( Status == STATUS_SUCCESS ) {
            *ppStringPtr = pStr;
            *pStringSize = StrSize;
            return( STATUS_SUCCESS );
        }
        else if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
            /*
             * emptied the buffer
             */
            *pIOBufIndex = 0;
            *pIOBufFillSize = 0;

            // fall through to read more data
        }
        else {
            // Error
            if( pStr ) {
                RtlFreeHeap( RtlProcessHeap(), 0, pStr );
            }
            *ppStringPtr = NULL;
            *pStringSize = 0;
            return( Status );
        }
    }

    while( 1 ) {

        ASSERT( *pIOBufIndex == 0 );
        ASSERT( *pIOBufFillSize == 0 );

        Iosb.Status = STATUS_SUCCESS;
        Status = NtReadFile(
                     SrcHandle,
                     NULL,      // Event
                     NULL,      // APC routine
                     NULL,      // APC context
                     &Iosb,
                     pIOBuf,
                     IOBufSize,
                     NULL,      // ByteOffset (not used since in synchronous I/O)
                     NULL       // Key
                     );

        if( Status == STATUS_PENDING ) {
            Status = NtWaitForSingleObject( SrcHandle, FALSE, NULL );
        }

        if( NT_SUCCESS(Status) ) {
            // Get final I/O status
            Status = Iosb.Status;
        }

        if( !NT_SUCCESS(Status) ) {

        if( (Status == STATUS_END_OF_FILE) && (StrSize != 0) ) {

                // Force the string finished
                pStr[StrSize] = (CHAR)NULL;
                *pStringSize = StrSize;
                *ppStringPtr = pStr;
                return( STATUS_SUCCESS );
            }

            // Free the buffer
            if( pStr ) {
                RtlFreeHeap( RtlProcessHeap(), 0, pStr );
            }
            *ppStringPtr = NULL;
            *pStringSize = 0;
            if (Status != STATUS_END_OF_FILE)
                DBGPRINT(("TermsrvIniCopyLoop: Error 0x%x doing NtReadFile\n",Status));
            return( Status );
        }

        // Fill in the count
        *pIOBufFillSize = (ULONG)Iosb.Information;

        /*
         * Now process this buffer of data
         */
        Status = TermsrvProcessBuffer(
                     &pStr,
                     &StrSize,
                     &StrBufSize,
                     &SawNL,
                     pIOBuf,
                     pIOBufIndex,
                     pIOBufFillSize
                     );

        if( Status == STATUS_SUCCESS ) {
            *ppStringPtr = pStr;
            *pStringSize = StrSize;
            return( STATUS_SUCCESS );
        }
        else if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
            /*
             * emptied the buffer
             */
            *pIOBufIndex = 0;
            *pIOBufFillSize = 0;

            // fall through to read more data
        }
        else {
            // Error
            if( pStr ) {
                RtlFreeHeap( RtlProcessHeap(), 0, pStr );
            }
            *ppStringPtr = NULL;
            *pStringSize = 0;
            return( Status );
        }
    } // end while(1)
}

/*****************************************************************************
 *
 *  TermsrvProcessBuffer
 *
 *   Process a buffer of data.
 *
 *   This uses state passed in by the caller since the string can be
 *   partially built, and the buffer may not be fully processed when
 *   a string completes.
 *
 *   Can return if it completes a string with data still in buffer.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
TermsrvProcessBuffer(
    PCHAR  *ppStr,
    PULONG pStrSize,
    PULONG pStrBufSize,
    PBOOL  pSawNL,
    PCHAR  pIOBuf,
    PULONG pIOBufIndex,
    PULONG pIOBufFillSize
    )
{
    PCHAR pStr;
    ULONG Index;
    BOOL  SawNL;

    /*
     * See if we are starting a new string
     */
    if( *ppStr == NULL ) {

        pStr = RtlAllocateHeap( RtlProcessHeap(), 0, *pStrBufSize );
        if( pStr == NULL ) {
            DBGPRINT(("TermsrvProcessBuf: Memory allocation failure\n"));
            return( STATUS_NO_MEMORY );
        }

        // Set it to our caller
        *ppStr = pStr;
    }

    /*
     * Get passed in state to local variables
     */
    pStr = *ppStr;
    Index = *pStrSize;
    SawNL = *pSawNL;

    while ( *pIOBufIndex < *pIOBufFillSize ) {

        pStr[Index] = pIOBuf[*pIOBufIndex];
        if( IS_NEWLINE_CHAR( pStr[Index] ) ) {

            /*
             * Mark the we saw an end of string character.
             * We will keep putting them into the buffer until a
             * non-NL character is encountered. This handles the
             * variations for <CR><LF>, <CR> alone, or <CR><LF><CR>
             * if its been mangled by a buggy editor.
             */
            SawNL = TRUE;
        }
        else {
            /*
             * If we saw a previous NL character, and this character
             * is not one, we do not take this one, but put a NULL in
             * its place and return. NOTE: Do not bump the count, since
             * the count does not include the NULL.
             */
            if( SawNL ) {
                pStr[Index] = (CHAR)NULL;
                *pStrSize = Index;
                return( STATUS_SUCCESS );
            }
        }

        Index++;
        (*pIOBufIndex)++;
        if( Index >= *pStrBufSize ) {

            // Grow the string buffer
            if( !TermsrvReallocateBuf( &pStr, pStrBufSize, (*pStrBufSize) * 2 ) ) {
                if( pStr ) {
                    RtlFreeHeap( RtlProcessHeap(), 0, pStr );
                }
                *ppStr = NULL;
                DBGPRINT(("TermsrvIniCopyLoop: Memory re-allocation failure\n"));
                return( STATUS_NO_MEMORY );
            }
            // Memory buffer has been re-allocated
            *ppStr = pStr;
            *pStrBufSize = (*pStrBufSize) * 2;
        }
    }

    *pStrSize = Index;
    *pSawNL = SawNL;

    /*
     * emptied the buffer without building a whole string
     */
    return( STATUS_MORE_PROCESSING_REQUIRED );
}

/*****************************************************************************
 *
 *  TermsrvReallocateBuf
 *
 *   Grow the buffer, copy data to new buffer.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
TermsrvReallocateBuf(
    PCHAR  *ppStr,
    PULONG pStrBufSize,
    ULONG  NewSize
    )
{
    PCHAR ptr;
    ULONG CopyCount;

    CopyCount = *pStrBufSize;

    ptr = RtlAllocateHeap( RtlProcessHeap(), 0, NewSize );
    if( ptr == NULL ) {
        return( FALSE );
    }

    RtlMoveMemory( ptr, *ppStr, CopyCount );

    RtlFreeHeap( RtlProcessHeap(), 0, *ppStr );

    *ppStr = ptr;

    return( TRUE );
}

/*****************************************************************************
 *
 *  TermsrvPutString
 *
 *   Write out the current string to the destination file handle
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
TermsrvPutString(
    HANDLE DestHandle,
    PCHAR  pStr,
    ULONG  StringSize
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK   Iosb;

    Iosb.Status = STATUS_SUCCESS;

    Status = NtWriteFile(
                 DestHandle,
                 NULL,      // Event
                 NULL,      // APC routine
                 NULL,      // APC context
                 &Iosb,
                 pStr,
                 StringSize,
                 NULL,      // ByteOffset (not used since in synchronous I/O)
                 NULL       // Key
                 );

    if( Status == STATUS_PENDING ) {
        Status = NtWaitForSingleObject( DestHandle, FALSE, NULL );
    }

    if( NT_SUCCESS(Status) ) {
        // Get final I/O status
        Status = Iosb.Status;
    }

    return( Status );
}


/*****************************************************************************
 *
 *  TermsrvCheckNewIniFiles
 *
 *  This routine will check the timestamps of the .ini files installed by the
 *  system administrator, and see if any of the user's .ini file are out of
 *  date, and if so, they will be renamed.
 *
 * ENTRY:
 *
 * EXIT:
 *   No return value.
 *
 ****************************************************************************/

void TermsrvCheckNewIniFiles(void)
{
    NTSTATUS Status;

    #if defined (_WIN64)
    Status = TermsrvCheckNewIniFilesInternal(REG_NTAPI_SOFTWARE_WOW6432_TSERVER);
    if (!NT_SUCCESS(Status)) {
        return;
    }
    #endif // defined(_WIN64)

    Status = TermsrvCheckNewIniFilesInternal(REG_NTAPI_SOFTWARE_TSERVER);
    if (!NT_SUCCESS(Status)) {
        return;
    }

    // Update the user's sync time in the registry
    TermsrvSetUserSyncTime();
}

/*****************************************************************************
 *
 *  TermsrvCheckNewIniFilesInternal
 *
 *  This routine will check the timestamps of the .ini files installed by the
 *  system administrator, and see if any of the user's .ini file are out of
 *  date, and if so, they will be renamed.
 *
 * ENTRY:
 *       LPCWSTR wszBaseKeyName
 *
 * EXIT:
 *   No return value.
 *
 ****************************************************************************/

NTSTATUS
TermsrvCheckNewIniFilesInternal(
        IN LPCWSTR wszBaseKeyName)
{
    PWCHAR pwch;
    UNICODE_STRING UniString, UniUserDir, UniNTDir = {0,0,NULL};
    OBJECT_ATTRIBUTES ObjectAttr;
    FILE_NETWORK_OPEN_INFORMATION BasicInfo;
    HANDLE hKey = NULL, hWinDir = NULL;
    NTSTATUS Status;
    ULONG ulcnt, ullen, ultmp;
    WCHAR wcWinDir[MAX_PATH], wcbuff[MAX_PATH];
    PKEY_VALUE_FULL_INFORMATION pKeyValInfo;
    PKEY_BASIC_INFORMATION pKeyInfo;
    IO_STATUS_BLOCK IOStatus;

    g_debugIniMap = IsDebugIniMapEnabled();

    // Allocate a buffer for the key value name and time info
    ullen = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
            sizeof(ULONG);
    pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ullen);

    // If we didn't get the buffer, return
    if (!pKeyValInfo) {
        return STATUS_NO_MEMORY;
    }

    // Open up the registry key to get the last sync time for this user
    wcscpy(wcbuff,wszBaseKeyName);
    wcscat(wcbuff,TERMSRV_INIFILE_TIMES_SHORT);

    RtlInitUnicodeString(&UniString,
                         wcbuff);
    InitializeObjectAttributes(&ObjectAttr,
                               &UniString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&hKey, KEY_READ, &ObjectAttr);

    // If we successfully opened the key, check if there are any new entries
    if (NT_SUCCESS(Status)) {

        // Since we already allocated a hunk of memory, use the value buffer
        // for the key info query
        pKeyInfo = (PKEY_BASIC_INFORMATION)pKeyValInfo;

        // Get the last time anyone wrote to "IniFile Times" key
        Status = NtQueryKey(hKey,
                            KeyBasicInformation,
                            pKeyInfo,
                            ullen,
                            &ultmp);

        // We got the last write time OK, now get the last time we sync'd
        if (NT_SUCCESS(Status) && TermsrvGetUserSyncTime(&ultmp)) {

            // Convert the time value to seconds since 1970
            RtlTimeToSecondsSince1970 (&pKeyInfo->LastWriteTime,
                                       &ulcnt);

            // If no .ini files or reg entries have been updated since the last
            // time we sync'd this user, just return
            if (ultmp >= ulcnt) {
                NtClose(hKey);
                RtlFreeHeap(RtlProcessHeap(), 0, pKeyValInfo);
                return STATUS_SUCCESS;
            }
        }

        TermsrvCheckNewRegEntries(wszBaseKeyName);

        // Set up UniUserDir to point at wcbuff
        UniUserDir.Buffer = wcWinDir;
        UniUserDir.Length = 0;
        UniUserDir.MaximumLength = sizeof(wcbuff);

        Status = GetPerUserWindowsDirectory(&UniUserDir);

        if (NT_SUCCESS(Status)) {

            // Convert to an NT path
            if (RtlDosPathNameToNtPathName_U(UniUserDir.Buffer,
                                             &UniNTDir,
                                             NULL,
                                             NULL)) {
                InitializeObjectAttributes(&ObjectAttr,
                                           &UniNTDir,
                                           OBJ_CASE_INSENSITIVE,
                                           NULL,
                                           NULL);

                // Open the user's windows directory
                IOStatus.Status = STATUS_SUCCESS;
                Status = NtOpenFile(&hWinDir,
                                    FILE_GENERIC_READ,
                                    &ObjectAttr,
                                    &IOStatus,
                                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                                    FILE_SYNCHRONOUS_IO_NONALERT);
            } else {
                Status = STATUS_NO_SUCH_FILE;
            }
        }

        // Go through each of the keys, checking if it's newer than the user's
        // version of the file, and if so rename it
        ulcnt = 0;
        wcscat(wcWinDir, L"\\");
        UniUserDir.Length += 2;         // add in length of \ seperator
        while (NT_SUCCESS(Status)) {
            Status = NtEnumerateValueKey(hKey,
                                         ulcnt++,
                                         KeyValueFullInformation,
                                         pKeyValInfo,
                                         ullen,
                                         &ultmp);
            if (NT_SUCCESS(Status)) {

                RtlMoveMemory(wcbuff, pKeyValInfo->Name, pKeyValInfo->NameLength);
                wcbuff[pKeyValInfo->NameLength/sizeof(WCHAR)] = L'\0';

                // Get rid of the .ini extension
                if (pwch = wcschr(wcbuff, L'.')) {
                    *pwch = L'\0';
                }

                // Get the compatibility flags for this .ini file
                GetTermsrCompatFlags(wcbuff,
                                     &ultmp,
                                     CompatibilityIniFile);

                // If we removed the extension, put it back
                if (pwch) {
                    *pwch = '.';
                }

                // If the INISYNC compat bit is set, don't rename the file
                if ((ultmp & (TERMSRV_COMPAT_INISYNC | TERMSRV_COMPAT_WIN16)) !=
                     (TERMSRV_COMPAT_INISYNC | TERMSRV_COMPAT_WIN16)) {

                    RtlInitUnicodeString(&UniString, wcbuff);

                    // Query the last write time of the .ini file
                    InitializeObjectAttributes(&ObjectAttr,
                                               &UniString,
                                               OBJ_CASE_INSENSITIVE,
                                               hWinDir,
                                               NULL);

                    // Get the last write time
                    if (NT_SUCCESS(NtQueryFullAttributesFile( &ObjectAttr,
                                                              &BasicInfo ))) {

                        // Convert the last write time to seconds
                        RtlTimeToSecondsSince1970(&BasicInfo.LastWriteTime,
                                                  &ultmp);

                        // Check if the system version is newer than the user's
                        // version
                        if (*(PULONG)((PCHAR)pKeyValInfo +
                                      pKeyValInfo->DataOffset) > ultmp) {

                            // Concatenate the .ini name onto the user's path
                            wcscpy(wcWinDir + (UniUserDir.Length/sizeof(WCHAR)),
                                   wcbuff);

                            // Create the target name to rename the file
                            // (inifile.ctx)
                            wcscpy(wcbuff, wcWinDir);
                            pwch = wcsrchr(wcbuff, L'.');
                            if (pwch) {
                                wcscpy(pwch, L".ctx");
                            } else {
                                wcscat(pwch, L".ctx");
                            }

                            // Rename the .ini file
                            MoveFileExW(wcWinDir,
                                        wcbuff,
                                        MOVEFILE_REPLACE_EXISTING);
                        }
                    }
                }
            }
        }

        // Close the handles, if they were opened
        if (hKey) {
            NtClose(hKey);
        }
        if (hWinDir) {
            NtClose(hWinDir);
        }

    }


    // Free the memory we allocated
    RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
    if (UniNTDir.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, UniNTDir.Buffer);
    }

    return STATUS_SUCCESS;
}



/*****************************************************************************
 *
 *  TermsrvCheckKeys
 *
 *  This recursive routine will check for any subkeys under the system root
 *  key passed in.  It will delete the corresponding key in the user's
 *  software registry if the user's key is older than the system key.  If the
 *  INISYNC bit is set for this registry key or the key is still has subkeys,
 *  it won't be deleted.  If the key doesn't exist in the user's registry,
 *  it will be added.
 *
 * ENTRY:
 *  HANDLE hKeySysRoot: handle to key in system section of registry
 *  HANDLE hKeyUsrRoot: handle to key in user section of registry
 *  PKEY_BASIC_INFORMATION pKeySysInfo: Ptr to buffer for key basic info struc
 *  PKEY_FULL_INFORMATION pKeyUsrInfo: Ptr to buffer for full key info struc
 *  ULONG ulcsys: Size of SysInfo buffer
 *  ULONG ulcusr: Size of UsrInfo buffer
 *
 * EXIT:
 *   SUCCESS:
 *      STATUS_SUCCESS
 *   FAILURE:
 *      NTSTATUS Return Code
 *
 ****************************************************************************/
NTSTATUS TermsrvCheckKeys(HANDLE hKeySysRoot,
                      HANDLE hKeyUsrRoot,
                      PKEY_BASIC_INFORMATION pKeySysInfo,
                      PKEY_FULL_INFORMATION pKeyUsrInfo,
                      ULONG ulcsys,
                      ULONG ulcusr,
                      DWORD indentLevel )
{
    NTSTATUS Status = STATUS_SUCCESS, Status2;
    ULONG ultemp, ulcnt = 0;
    UNICODE_STRING UniPath, UniString;
    OBJECT_ATTRIBUTES ObjAttr;
    HANDLE hKeyUsr = NULL, hKeySys = NULL;
    LPWSTR wcbuff = NULL;
    ULONG aulbuf[4];
    PKEY_FULL_INFORMATION pKeyUsrFullInfoSaved = NULL ;
    ULONG   sizeFullInfo;
    PKEY_VALUE_PARTIAL_INFORMATION pValKeyInfo =
        (PKEY_VALUE_PARTIAL_INFORMATION)aulbuf;

    ++indentLevel;
    
    Status = GetFullKeyPath(hKeyUsrRoot,NULL,&wcbuff);
    if(!NT_SUCCESS(Status)) {
        return Status;
    }

    // Get the compatibility flags for this entry
    GetTermsrCompatFlags(wcbuff,
                         &ultemp,
                         CompatibilityRegEntry);

    LocalFree(wcbuff);

    // If the INISYNC or NOREGMAP bits are set for this entry,
    // return, since there's nothing to do
    if ((ultemp & TERMSRV_COMPAT_WIN32) &&
         (ultemp & (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_INISYNC))) {
        return(STATUS_NO_MORE_ENTRIES);
    }

    // Save the current info for the current user key
    // @@@
    if (!hKeyUsrRoot)
    {
        DBGPRINT(("ERROR : LINE : %4d, why is this null? \n", __LINE__ ));
        return(STATUS_NO_MORE_ENTRIES );
    }

    // use a zero length query to get the actual length
    Status = NtQueryKey(hKeyUsrRoot,
                   KeyFullInformation,
                   pKeyUsrFullInfoSaved,
                   0,
                   &ultemp) ;

	if ( !NT_SUCCESS( Status ) )
	{
		if (Status == STATUS_BUFFER_TOO_SMALL )
		{
			sizeFullInfo = ultemp;
		
			pKeyUsrFullInfoSaved = RtlAllocateHeap(RtlProcessHeap(), 0, sizeFullInfo );

			if ( ! pKeyUsrFullInfoSaved )
			{
				return STATUS_NO_MEMORY;
			}

			Status = NtQueryKey(hKeyUsrRoot,
					   KeyFullInformation,
					   pKeyUsrFullInfoSaved,
					   sizeFullInfo,
					   &ultemp);
			
			if( !NT_SUCCESS(Status ) )
			{
				DBGPRINT(("ERROR : LINE : %4d, Status =0x%lx , ultemp=%d\n", __LINE__ , Status, ultemp));
				RtlFreeHeap( RtlProcessHeap(), 0, pKeyUsrFullInfoSaved);
				return( Status );
			}		

		}
		else
		{

            DBGPRINT(("ERROR : LINE : %4d, Status =0x%lx \n", __LINE__ , Status ));
			return Status;
		}
	}

    // Go through each of the subkeys, checking for user keys that are older
    // than the system version of the keys
    while (NT_SUCCESS(Status)) {

        Status = NtEnumerateKey(hKeySysRoot,
                                ulcnt++,
                                KeyBasicInformation,
                                pKeySysInfo,
                                ulcsys,
                                &ultemp);

        // See if there are any user keys under this key that are out of date
        if (NT_SUCCESS(Status)) {

            // Null terminate the key name
            pKeySysInfo->Name[pKeySysInfo->NameLength/sizeof(WCHAR)] = L'\0';

            // Create a unicode string for the key name
            RtlInitUnicodeString(&UniPath, pKeySysInfo->Name);

            InitializeObjectAttributes(&ObjAttr,
                                       &UniPath,
                                       OBJ_CASE_INSENSITIVE,
                                       hKeySysRoot,
                                       NULL);

            Debug1( indentLevel, __LINE__, L"system", &UniPath );

            // Open up the system key
            Status2 = NtOpenKey(&hKeySys,
                                KEY_READ,
                                &ObjAttr);

            // We opened up the system key, now open the user key
            if (NT_SUCCESS(Status2)) {

                // Setup the object attr struc for the user key
                InitializeObjectAttributes(&ObjAttr,
                                           &UniPath,
                                           OBJ_CASE_INSENSITIVE,
                                           hKeyUsrRoot,
                                           NULL);

                // Open up the user key
                Status2 = NtOpenKey(&hKeyUsr,
                                    MAXIMUM_ALLOWED,
                                    &ObjAttr);

                // Check if there are any subkeys under this key
                if (NT_SUCCESS(Status2)) {

                    Debug1(indentLevel, __LINE__, L"user", &UniPath );

                    TermsrvCheckKeys(hKeySys,
                                 hKeyUsr,
                                 pKeySysInfo,
                                 pKeyUsrInfo,
                                 ulcsys,
                                 ulcusr,
                                 indentLevel);

                    NtClose(hKeyUsr);
                }

                // key doesn't exist, clone system key to user
                else {
                    
                    Status2 = GetFullKeyPath(hKeyUsrRoot,pKeySysInfo->Name,&wcbuff);
                    
                    if(NT_SUCCESS(Status2)) {

                        // don't clone if mapping off for this registry entry
                        GetTermsrCompatFlags(wcbuff,
                                             &ultemp,
                                             CompatibilityRegEntry);
                        
                        LocalFree(wcbuff);

                        if (((ultemp & (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) !=
                             (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP) ))
                        {
                            Status2 = NtQueryKey(hKeySys,
                                                 KeyFullInformation,
                                                 pKeyUsrInfo,
                                                 ulcusr,
                                                 &ultemp);

                            if (NT_SUCCESS(Status2)) {

                                // don't clone if key previously deleted
                                RtlInitUnicodeString(&UniString, TERMSRV_COPYONCEFLAG);
                                Status2 = NtQueryValueKey(hKeySys,
                                                          &UniString,
                                                          KeyValuePartialInformation,
                                                          pValKeyInfo,
                                                          sizeof(aulbuf),
                                                          &ultemp);

                                if (!(NT_SUCCESS(Status2) && (pValKeyInfo->Data))) {
                                    // Setup the unicode string for the class
                                    InitUnicodeStringWithLen(&UniString,
                                                             pKeyUsrInfo->ClassLength ? pKeyUsrInfo->Class : NULL,
                                                             (USHORT)pKeyUsrInfo->ClassLength);

                                    Debug1(indentLevel, __LINE__, L"creating user key", ObjAttr.ObjectName  );

                                    Status2 = NtCreateKey(&hKeyUsr,
                                                          MAXIMUM_ALLOWED,
                                                          &ObjAttr,
                                                          0,
                                                          &UniString,
                                                          REG_OPTION_NON_VOLATILE,
                                                          &ultemp);

                                    if (NT_SUCCESS(Status2)) {

                                        Debug1(indentLevel, __LINE__, L"cloning key", ObjAttr.ObjectName  );

                                        TermsrvCloneKey(hKeySys,
                                                    hKeyUsr,
                                                    pKeyUsrInfo,
                                                    TRUE);
                                    }
                                }
                            }
                        }
                    }
                }
                NtClose(hKeySys);
            }
        }
    }

    // Get the info for the user key
    if (NtQueryKey(hKeyUsrRoot,
                   KeyFullInformation,
                   pKeyUsrInfo,
                   ulcusr,
                   &ultemp) == STATUS_SUCCESS) {

        // Now get the info for the system key (again)
        if (NtQueryKey(hKeySysRoot,
                       KeyBasicInformation,
                       pKeySysInfo,
                       ulcsys,
                       &ultemp) == STATUS_SUCCESS) {

            // Get the compatibility flags for this registry entry
            pKeySysInfo->Name[pKeySysInfo->NameLength/sizeof(WCHAR)] = L'\0';
            GetTermsrCompatFlags(pKeySysInfo->Name,
                                 &ultemp,
                                 CompatibilityRegEntry);

            
            //check if it's older than the system version
            if( pKeyUsrFullInfoSaved->LastWriteTime.QuadPart <
                 pKeySysInfo->LastWriteTime.QuadPart) 
            {
                DebugTime(indentLevel, __LINE__, L"User key time", pKeyUsrFullInfoSaved->LastWriteTime );
                DebugTime(indentLevel, __LINE__, L"Sys  key time", pKeySysInfo->LastWriteTime);

                Debug2( indentLevel, __LINE__, L"Key Old, values being cloned",  pKeySysInfo->Name, pKeySysInfo->NameLength );

                if(NtQueryKey(hKeySysRoot,
                             KeyFullInformation,
                             pKeyUsrInfo,
                             ulcusr,
                             &ultemp) == STATUS_SUCCESS) {

                    TermsrvCloneKey(hKeySysRoot,
                                    hKeyUsrRoot,
                                    pKeyUsrInfo,//actually it is system key information
                                    FALSE);
                }
            }
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, pKeyUsrFullInfoSaved);
    return(Status);
}




/*****************************************************************************
 *
 *  TermsrvCheckNewRegEntries
 *
 *  This routine will check the user's registry keys, and see if any of them
 *  are older than the system versions.  If so, the old key will be removed.
 *
 * ENTRY:
 *        IN LPCWSTR wszBaseKeyName
 *
 * EXIT:
 *   No return value.
 *
 ****************************************************************************/

void 
TermsrvCheckNewRegEntries(
        IN LPCWSTR wszBaseKeyName)
{
    NTSTATUS Status;
    ULONG ulcsys, ulcusr;
    UNICODE_STRING UniPath;
    OBJECT_ATTRIBUTES ObjAttr;
    PKEY_BASIC_INFORMATION pKeySysInfo = NULL;
    PKEY_FULL_INFORMATION pKeyUserInfo = NULL;
    HANDLE hKeyUser, hKeySys = NULL;
    WCHAR wcuser[MAX_PATH], wcsys[MAX_PATH];

    DWORD   indentLevel = 0;

    // Oct 15, 1999
    // This is BAD ! The Status bit was not initiazted to zero, which causes intermitent
    // execution by this function. The problem is that even if the status bit is init'd
    // to zero, then we can get the wrong behavior which will cause Office97 installation to
    // go wrong.
    // See BUG ID 412419
    // Here is what woudl happen: Install any app ( say TsClient). This would cause
    // an update to a Key in HKDU called Explorer\ShellFolders, just a refresh (no real change).
    // Then, if Admin did an logout and login, the call from UserInit.EXE into this
    // function (assuming by chance Status=0 was on the stack) would cause deletion of
    // that key (ShellFolder). But once Explorer starts, it writes to the ShellFolder with
    // a subset of original 19 values.
    // The problem is that if then, you decide to install Office97, setup.exe would look
    // in the same key for a value called "template" which is now missing. Explorer
    // would then create it, but it would point to some other than default location.
    // When all was done, our office97 compat script would be looking to where the
    // "template" value used to point (the default location), not where it is pointing now.
    //
    // we decide to disable this func by calling return right here, and instead, rely
    // on the TS mechanism to fault in keys.

    // Oct 31, 1999
    // I have decided to initialize the status var and let this func run, in addition to
    // marking the Explorer\ShellFolders as a do-not propagate key tree.
    //
    // It was discovered that after installing Office2000, when a user clicks on the
    // start-menu-> Open Office Docs link, MSI starts to run since user's hive is missing some
    // keys.
    //
    // The reason MSI does not see the keys in HKCU is because MSI has the TS-aware bit set,
    // which means that there are no faulting-in for any keys. The same is true for the Explorer.
    // On the other hand, when an app such as Office runs, since it is not ts-aware, we
    // fault in the keys that office touches. I verified this to work as expected.
    // The problem is that when you click on "Open Office Documents", you do so from the
    // explorer and when Explorer opens keys in the registry, since explorer is TS-aware,
    // those keys are not faulted in. I have verified that if you mark explorer as a non-TS-aware
    // app, the problem goes away.
    // We made a recent change in TS code (B-bug 412419, bld 2156+) to fix a different
    // problem which has now uncovered the reliance of the Explorer to get keys
    // faulted in during login.
    //      Specifically, TS used to fault in all keys at login time,
    //      regardless of the need. Post 2156, TS faults in only keys upon
    //      access by non-ts-aware apps. This was to fix a bug based on
    //      what we considered to be our most informed and well tested opinion. That
    //      has turned out to be wrong.
    // It is too risky to mark explorer non-ts-aware this late, so we must change the fix for 412419.
    // This should also make Bruno Amice very happy, since the fix will be as it was
    // advocated by him.
    Status = STATUS_SUCCESS;


    // Get a buffer for the system key info
    ulcsys = sizeof(KEY_BASIC_INFORMATION) + MAX_PATH*sizeof(WCHAR);
    pKeySysInfo = RtlAllocateHeap(RtlProcessHeap(),
                                   0,
                                   ulcsys);
    if (!pKeySysInfo) {
        Status = STATUS_NO_MEMORY;
    }

    // Get a buffer for the user key info
    if (NT_SUCCESS(Status)) {

        ulcusr = sizeof(KEY_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR);
        pKeyUserInfo = RtlAllocateHeap(RtlProcessHeap(),
                                       0,
                                       ulcusr);
        if (!pKeyUserInfo) {
            Status = STATUS_NO_MEMORY;
        }
    }

    // We have the necessary buffers, start checking the keys
    if (NT_SUCCESS(Status)) {

        // Build a string that points to Citrix\Install\Software
        wcscpy(wcsys, wszBaseKeyName);
        wcscat(wcsys, TERMSRV_INSTALL_SOFTWARE_SHORT);


        // Build up a string for this user's software section
        Status = RtlFormatCurrentUserKeyPath( &UniPath );
        if (NT_SUCCESS(Status)) {
            wcscpy(wcuser, UniPath.Buffer);
            wcscat(wcuser, L"\\Software");

            // Free the original user path
            RtlFreeHeap( RtlProcessHeap(), 0, UniPath.Buffer );
        }

        if (NT_SUCCESS(Status)) {
            // Create a unicode string for the system key path
            RtlInitUnicodeString(&UniPath, wcsys);

            InitializeObjectAttributes(&ObjAttr,
                                       &UniPath,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            Debug1(indentLevel, __LINE__, L"system", &UniPath );

            Status = NtOpenKey(&hKeySys,
                               KEY_READ,
                               &ObjAttr);
        }

        if (NT_SUCCESS(Status)) {
            // Create a unicode string for the user key path
            RtlInitUnicodeString(&UniPath, wcuser);

            InitializeObjectAttributes(&ObjAttr,
                                       &UniPath,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            Debug1(indentLevel, __LINE__, L"user", &UniPath );

            Status = NtOpenKey(&hKeyUser,
                               KEY_READ | DELETE,
                               &ObjAttr);
        }

        // Go through each of the keys, checking if the system version is
        // newer than the user version
        if (NT_SUCCESS(Status)) {
            TermsrvCheckKeys(hKeySys,
                         hKeyUser,
                         pKeySysInfo,
                         pKeyUserInfo,
                         ulcsys,
                         ulcusr,
                         indentLevel );

            // Close the user key
            NtClose(hKeyUser);
        }

        // If we allocated the system key, close it
        if (hKeySys) {
            NtClose(hKeySys);
        }
    }

    // Free up any memory we allocated
    if (pKeySysInfo) {
        RtlFreeHeap( RtlProcessHeap(), 0, pKeySysInfo);
    }
    if (pKeyUserInfo) {
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyUserInfo);
    }

}


/*****************************************************************************
 *
 *  Ctxstristr
 *
 *  This is a case insensitive version of strstr.
 *
 * ENTRY:
 *   PCHAR pstring1 (In) - String to search in
 *   PCHAR pstring2 (In) - String to search for
 *
 * EXIT:
 *   TRUE  - User ini file should be sync'd
 *   FALSE - User ini file should be sync'd
 *
 ****************************************************************************/

PCHAR
Ctxstristr(
    PCHAR pstring1,
    PCHAR pstring2)
{
    PCHAR pch, ps1, ps2;

    pch = pstring1;

    while (*pch)
    {
        ps1 = pch;
        ps2 = pstring2;

        while (*ps1 && *ps2 && !(toupper(*ps1) - toupper(*ps2))) {
                   ps1++;
            ps2++;
        }

        if (!*ps2) {
            return(pch);
        }

        pch++;
    }
    return(NULL);
}

/*****************************************************************************
 *
 *  TermsrvLogInstallIniFile
 *
 *  This routine will write the time the .ini file was last updated into the
 *  Terminal Server\install section of the registry.
 *
 * ENTRY:
 *
 * EXIT:
 *   TRUE  - Success
 *   FALSE - Failure
 *
 ****************************************************************************/

BOOL TermsrvLogInstallIniFile(PUNICODE_STRING NtFileName)
{
    PWCHAR pwch;
    UNICODE_STRING UniString;
    OBJECT_ATTRIBUTES ObjectAttr;
    FILE_NETWORK_OPEN_INFORMATION BasicInfo;
    HANDLE hKey;
    NTSTATUS Status;
    ULONG ultmp;

    if (!TermsrvPerUserWinDirMapping()) {
        return FALSE;
    }

    // Open up the registry key to store the last write time of the file
    RtlInitUnicodeString(&UniString,
                         TERMSRV_INSTALL);

    InitializeObjectAttributes(&ObjectAttr,
                               &UniString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    // Open or create the Terminal Server\Install path
    Status = NtCreateKey(&hKey,
                         KEY_WRITE,
                         &ObjectAttr,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &ultmp);

    // Now open or create the IniFile Times key
    if (NT_SUCCESS(Status)) {
        NtClose(hKey);

        RtlInitUnicodeString(&UniString,
                             TERMSRV_INIFILE_TIMES);

        InitializeObjectAttributes(&ObjectAttr,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
        Status = NtCreateKey(&hKey,
                             KEY_WRITE,
                             &ObjectAttr,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &ultmp);
    }

    // Opened up the registry key, now get the last write time of the file
    if (NT_SUCCESS(Status)) {

        // Query the last write time of the .ini file
        InitializeObjectAttributes(&ObjectAttr,
                                   NtFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
        Status = NtQueryFullAttributesFile( &ObjectAttr, &BasicInfo );

        // Got the last write time, convert to seconds and write it out
        if (NT_SUCCESS(Status)) {

            // Just save the .ini filename, get rid of the path
            pwch = wcsrchr(NtFileName->Buffer, L'\\') + 1;
            if (!pwch) {
                pwch = NtFileName->Buffer;
            }

            // Convert to seconds (so it fits in a DWORD)
            RtlTimeToSecondsSince1970 (&BasicInfo.LastWriteTime,
                                       &ultmp);

            RtlInitUnicodeString(&UniString,
                                 pwch);

            // Write it out the .ini file name and the last write time
            Status = NtSetValueKey(hKey,
                                   &UniString,
                                   0,
                                   REG_DWORD,
                                   &ultmp,
                                   sizeof(ultmp));
        }
        // Close the registry key
        NtClose(hKey);
    }

    return(NT_SUCCESS(Status));
}
/**********************************************************************
*
*  BOOL TermsrvLogInstallIniFileEx( WCHAR *pDosFileName )
*
*  This wraps TermsrvLogInstallIniFile() for dos name files instead of
*  NT-file-objects
*
*  The file name must have the full path since func will try to get
*  access time for that file.
*
*  EXIT:
*    TRUE  - Success
*    FALSE - Failure
**********************************************************************/

BOOL TermsrvLogInstallIniFileEx( WCHAR *pDosFileName )
{
    UNICODE_STRING uniString;

    BOOL rc= FALSE;

    if ( RtlDosPathNameToNtPathName_U( pDosFileName, &uniString, 0, 0 ) )
    {
        if ( rc = TermsrvLogInstallIniFile( & uniString ) )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, uniString.Buffer );
        }
    }

    return rc;
}

/**********************************************************************
*
*  GetFullKeyPath()
*  
*  PURPOSE: 
*              Creates full key path given the key handle and subkey name.
*  
*  PARAMETERS: 
*              IN HANDLE hKeyParent - key handle 
*              IN LPCWSTR wszKey    - subkey name (may be NULL)
*              OUT LPWSTR *pwszKeyPath - on return contains a full key path
*              (caller must freee allocated memory with LocalFree()).
*
*  EXIT: NTSTATUS
*    
**********************************************************************/
NTSTATUS 
GetFullKeyPath(
        IN HANDLE hKeyParent,
        IN LPCWSTR wszKey,
        OUT LPWSTR *pwszKeyPath)
{
    NTSTATUS Status = STATUS_NO_MEMORY;
    PKEY_NAME_INFORMATION pNameInfo;
    ULONG cbSize = 0;
    
    *pwszKeyPath = NULL;

    cbSize = sizeof(KEY_NAME_INFORMATION) + MAX_PATH*sizeof(WCHAR);

    pNameInfo = (PKEY_NAME_INFORMATION) LocalAlloc(LPTR, cbSize);

    if(pNameInfo)
    {
        Status = NtQueryKey(
                        hKeyParent,
                        KeyNameInformation,
                        pNameInfo,
                        cbSize,
                        &cbSize);

        if(Status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pNameInfo);
            pNameInfo = (PKEY_NAME_INFORMATION) LocalAlloc(LPTR, cbSize);
            
            if(pNameInfo)
            {
                Status = NtQueryKey(
                            hKeyParent,
                            KeyNameInformation,
                            pNameInfo,
                            cbSize,
                            &cbSize);
            }
            else
            {
                return STATUS_NO_MEMORY;
            }
        }

        if(NT_SUCCESS(Status))
        {
            cbSize = pNameInfo->NameLength + sizeof(WCHAR);
            if(wszKey)
            {
                cbSize += wcslen(wszKey)*sizeof(WCHAR) + sizeof(L'\\');
            }
            
            *pwszKeyPath = (LPWSTR) LocalAlloc(LPTR, cbSize);

            if(*pwszKeyPath)
            {
                memcpy(*pwszKeyPath,pNameInfo->Name,pNameInfo->NameLength);
                (*pwszKeyPath)[pNameInfo->NameLength/sizeof(WCHAR)] = 0;
                
                if(wszKey)
                {
                    wcscat(*pwszKeyPath,L"\\");
                    wcscat(*pwszKeyPath,wszKey);
                }
            }
            else
            {
                Status = STATUS_NO_MEMORY;
            }
        }

        LocalFree(pNameInfo);
    }

    return Status;
}

VOID
InitUnicodeStringWithLen(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString,
    IN USHORT StringLength
    )
{
    DestinationString->Buffer = (PWSTR)SourceString;
    DestinationString->Length = StringLength;
    if ( StringLength ) {
        DestinationString->MaximumLength = StringLength + (USHORT)sizeof(UNICODE_NULL);
    } 
    else {
        DestinationString->MaximumLength = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\inipath.h ===
/*************************************************************************
*
* inipath.h
*
* Function declarations for INI file mapping
*
* copyright notice: Copyright 1998, Microsoft Corporation
*
*
*
*************************************************************************/

#define CtxFreeSID LocalFree


/*
 * Forward references
 */

NTSTATUS
GetPerUserWindowsDirectory(
    OUT PUNICODE_STRING pFQName
    );

ULONG GetTermsrvAppCompatFlags(OUT LPDWORD pdwCompatFlags, OUT LPDWORD pdwAppType);

NTSTATUS
BuildIniFileName(
    OUT PUNICODE_STRING pFQName,
    IN  PUNICODE_STRING pBaseFileName
    );

NTSTATUS
GetEnvPath(
    OUT PUNICODE_STRING pFQPath,
    IN  PUNICODE_STRING pDriveVariableName,
    IN  PUNICODE_STRING pPathVariableName
    );

NTSTATUS
ConvertSystemRootToUserDir(
    OUT PUNICODE_STRING pFQPath,
    IN PUNICODE_STRING BaseWindowsDirectory
    );

BOOL CtxCreateSecurityDescriptor( PSECURITY_ATTRIBUTES psa );
BOOL CtxFreeSecurityDescriptor( PSECURITY_ATTRIBUTES psa );

NTSTATUS
CtxAddAccessAllowedAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN DWORD index
    );


//BOOL CtxSyncUserIniFile(PINIFILE_PARAMETERS a);

//BOOL CtxLogInstallIniFile(PINIFILE_PARAMETERS a);

BOOL IsSystemLUID(VOID);

BOOLEAN TermsrvPerUserWinDirMapping();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\keynode.cpp ===
/****************************************************************************/
// keynode.cpp
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/


#include <stdio.h>
#include "KeyNode.h"

extern ULONG   g_length_TERMSRV_USERREGISTRY_DEFAULT;
extern ULONG   g_length_TERMSRV_INSTALL;
extern WCHAR   g_debugFileName[MAX_PATH];
extern FILE    *g_debugFilePointer;
extern BOOLEAN g_debugIO;

KeyBasicInfo::KeyBasicInfo():
    pNameSz(NULL)
{
    size = sizeof(KEY_BASIC_INFORMATION) + MAX_PATH*sizeof(WCHAR);
    pInfo = ( KEY_BASIC_INFORMATION *)RtlAllocateHeap(RtlProcessHeap(), 0, size );

    if (!pInfo) {
        status = STATUS_NO_MEMORY;
        pInfo=NULL;
    }
    else
        status = STATUS_SUCCESS;

}

KeyBasicInfo::~KeyBasicInfo()
{
    if (pInfo)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pInfo);
    }

    if (pNameSz)
    {
        delete pNameSz;
    }
}

PCWSTR KeyBasicInfo::NameSz()
{
    if (Ptr()->NameLength < 2 * MAX_PATH )
    {
        if (!pNameSz)
        {
            pNameSz = new WCHAR [ MAX_PATH  + 1 ];
        }

        // the reason we re do this every call of NameSz() is because
        // Ptr() might changes, since KeyBasicInfo is being used as a
        // scratch pad and passed around for storing pointers to some
        // basic set of info on any key.

        // see if allocation was successful
        if ( pNameSz )
        {
            for ( ULONG i=0; i < Ptr()->NameLength / sizeof(WCHAR) ; i++)
            {
                pNameSz[i] = ( (USHORT)Ptr()->Name[i] );
            }
            pNameSz[i]=L'\0';
        }
    }
    else
    {
        status = STATUS_NO_MEMORY;
        pNameSz[0]=L'\0';
    }

    return pNameSz;

}

#if 0 // NOT USED yet!
KeyNodeInfo::KeyNodeInfo()
{
    size = sizeof(KEY_NODE_INFORMATION) + MAX_PATH*sizeof(WCHAR);
    pInfo = ( KEY_NODE_INFORMATION *)RtlAllocateHeap(RtlProcessHeap(), 0, size );

    if (!pInfo) {
        status = STATUS_NO_MEMORY;
        pInfo=NULL;
    }
    else
        status = STATUS_SUCCESS;


}
KeyNodeInfo::~KeyNodeInfo()
{
    if (pInfo)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pInfo);
    }
}

#endif

KeyFullInfo::KeyFullInfo() :
    pInfo(NULL)
{
    size = sizeof(KEY_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR);
    pInfo = ( KEY_FULL_INFORMATION *)RtlAllocateHeap(RtlProcessHeap(), 0, size );

    if (!pInfo) {
        status = STATUS_NO_MEMORY;
        pInfo=NULL;
    }
    else
        status = STATUS_SUCCESS;


}

KeyFullInfo::~KeyFullInfo()
{
    if (pInfo)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pInfo);
    }

}

KeyNode::KeyNode(HANDLE root, ACCESS_MASK access, PCWSTR name ) :
    root(NULL), hKey(NULL),
    accessMask(NULL),basic(NULL),full(NULL),
    pFullPath(NULL), pNameSz(NULL)
{
    hKey = NULL;
    PCWSTR n = name;
    accessMask = access;

    RtlInitUnicodeString(&uniName, n);

    InitializeObjectAttributes(&ObjAttr,
                           &uniName,
                           OBJ_CASE_INSENSITIVE,
                           root,
                           NULL);
    status=STATUS_SUCCESS;
}

KeyNode::KeyNode(KeyNode *pParent, KeyBasicInfo   *pInfo ) :
    root(NULL), hKey(NULL),
    accessMask(NULL),basic(NULL), full(NULL),
    pFullPath(NULL), pNameSz(NULL)
{
    hKey = NULL;
    PCWSTR n = pInfo->NameSz();
    accessMask = pParent->Masks();

    RtlInitUnicodeString(&uniName, n);

    InitializeObjectAttributes(&ObjAttr,
                           &uniName,
                           OBJ_CASE_INSENSITIVE,
                           pParent->Key(),
                           NULL);
    status=STATUS_SUCCESS;

}


KeyNode::~KeyNode()
{
    Close();

    if (basic)
    {
        delete basic;
    }

    if (full)
    {
        delete full;
    }

    if (pFullPath)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pFullPath);
    }

    if( pNameSz )
    {
        delete pNameSz;
    }

}

NTSTATUS KeyNode::Open()
{
    status = NtOpenKey(&hKey,
                    accessMask,
                    &ObjAttr);


    if ( !NT_SUCCESS( status))
    {
       hKey=NULL;
       // Debug(DBG_OPEN_FAILED );
    }

    return status;

}

NTSTATUS KeyNode::Close()
{

    if ( hKey )
    {
        status = NtClose( hKey );
        hKey = 0;
    }

    return status;
}

NTSTATUS KeyNode::Create( UNICODE_STRING *uClass)
{
    ULONG   ultmp;
    status = NtCreateKey(&hKey,
                         accessMask,
                         &ObjAttr,
                         0,
                         uClass,
                         REG_OPTION_NON_VOLATILE,
                         &ultmp);
    // Debug(DBG_CREATE);

    return status;
}



// Recursively create the reg path given by the uniName member variable
// Upon completion, open the reg key for access.

NTSTATUS KeyNode::CreateEx( UNICODE_STRING *uClass)
{
    ULONG   wsize = uniName.Length/sizeof(WCHAR);
    PWCHAR pTmpFullPath = new WCHAR[  uniName.Length + sizeof( WCHAR ) ];

    if(!pTmpFullPath)
    {
        status = STATUS_NO_MEMORY;
        return status;
    }

    wcsncpy(pTmpFullPath, uniName.Buffer , wsize);
    pTmpFullPath[ wsize ] = L'\0';

    PWCHAR    p;
    WCHAR     sep[]= {L"\\"};
    p = wcstok( pTmpFullPath, sep);

    // we know how many keys to create now.
    // start over again
    wcsncpy(pTmpFullPath, uniName.Buffer , wsize );
    pTmpFullPath[ wsize ] = L'\0';

    KeyNode *pKN1=NULL, *pKN2=NULL;
    p = wcstok( pTmpFullPath, sep);

    // the first item is "Registry", make it "\Registry" since we are opening
    // from the root.
    PWCHAR pTmpName = new WCHAR[  wcslen(p) + 2 ];

    if(!pTmpName)
    {
        DELETE_AND_NULL(pTmpFullPath);
        status = STATUS_NO_MEMORY;
        return status;
    }

    wcscpy(pTmpName, L"\\");
    wcscat( pTmpName , p );

    NTSTATUS st = STATUS_SUCCESS;
    while( p != NULL )
    {
        // @@@
        // ADD error handling, else you will create keys in the wrong places instead of bailing out.
        // @@@

        if ( pKN2 )
        {
            // ---- STEP 3 ---

            // NOT-first time around

            p = wcstok( NULL, sep);

            if ( p )    // we have more sub keys
            {
                pKN1 = new KeyNode( pKN2->Key(),  accessMask,  p );
                if (pKN1)
                {
                    st = pKN1->Open();

                    // if Open fails, then key does not exist, so create it
                    if ( !NT_SUCCESS( st ))
                    {
                        st = pKN1->Create();
                    }
                }
                else
                {
                    status = STATUS_NO_MEMORY;
                    break;
                }
            }
        }
        else
        {
            // ---- STEP 1 ---

            // First time around, we are opening \Registry node, use
            // pTmpName instead of "p"
            pKN1 = new KeyNode( NULL, accessMask , pTmpName );
            if (pKN1)
            {
                st = pKN1->Open();
            }
            else
            {
                status = STATUS_NO_MEMORY ;
                break;
            }

        }

        p = wcstok( NULL, sep);

        if (p)  // we have more sub keys
        {

            // ---- STEP 2 ---

            pKN2 = new KeyNode( pKN1->Key(), accessMask, p );
            if (pKN2 )
            {
                st = pKN2->Open();
                if ( !NT_SUCCESS( pKN2->Status() ))
                {
                    st = pKN2->Create();
                }
            }
            else
            {
                status = STATUS_NO_MEMORY;
                DELETE_AND_NULL (pKN1);
                break;
            }

            DELETE_AND_NULL (pKN1);
            pKN1 = pKN2;
        }
    }

    DELETE_AND_NULL( pKN2 );

    // since the last node was created above, now we can open ourselfs incase
    // caller wants to use us.
    if ( NT_SUCCESS(status) )
    {
        Open();
    }

    DELETE_AND_NULL(pTmpName);

    DELETE_AND_NULL(pTmpFullPath);

    return status;

}

NTSTATUS KeyNode::Delete()
{
    if (hKey)
    {
        status = NtDeleteKey( hKey );
        // Debug(DBG_DELETE);
    }

    return status;
}


NTSTATUS KeyNode::DeleteSubKeys()
{
    if (hKey && NT_SUCCESS( status ))
    {
        KeyBasicInfo    basicInfo;
        status = basicInfo.Status();

        if (NT_SUCCESS( status )) 
        {
            status = EnumerateAndDeleteSubKeys( this, &basicInfo );
        }
    }
    return status;
}

NTSTATUS KeyNode::EnumerateAndDeleteSubKeys(
    IN KeyNode      *pSource,
    IN KeyBasicInfo *pBasicInfo )
{
    NTSTATUS  st = STATUS_SUCCESS;

    ULONG   ulCount=0;
    ULONG   ultemp;

    while (NT_SUCCESS(st) && st != STATUS_NO_MORE_ENTRIES )
    {
        ULONG       ultemp;
        NTSTATUS    st2;

        st = NtEnumerateKey(    pSource->Key(),
                                    ulCount,
                                    pBasicInfo->Type(),
                                    pBasicInfo->Ptr(),
                                    pBasicInfo->Size(),
                                    &ultemp);

        if (NT_SUCCESS(st) && st != STATUS_NO_MORE_ENTRIES )
        {
            pBasicInfo->Ptr()->Name[ pBasicInfo->Ptr()->NameLength/sizeof(WCHAR) ] = L'\0';

            KeyNode SourcesubKey(pSource, pBasicInfo);

            if (NT_SUCCESS( SourcesubKey.Open() )  )
            {

                // enumerate sub key down.
                st2 = EnumerateAndDeleteSubKeys(
                            &SourcesubKey,
                            pBasicInfo );

            }

            st = SourcesubKey.Delete();
        }

    }

    return st;
}

#if 0
NTSTATUS KeyNode::Query( KEY_NODE_INFORMATION **result , ULONG   *resultSize)
{

    if ( hKey )
    {
        // first time around we allocate memory and keep using it
        // as our scratch pad
        if (!node )
        {
            node = new KeyNodeInfo();
        }

        status = NtQueryKey(hKey,
            node->Type(),     //        Keynode,
            node->Ptr(),
            node->Size(),
            resultSize);

        *result = node->Ptr();
    }
    else
        status = STATUS_OBJECT_NAME_NOT_FOUND; // need to call open or key is not found

    return status;

}
#endif

NTSTATUS KeyNode::Query( KEY_FULL_INFORMATION **result , ULONG   *pResultSize)
{

    if ( hKey )
    {
        // first time around we allocate memory and keep using it
        // as our scratch pad
        if (!full )
        {
            full = new KeyFullInfo();
        }

        if (full)
        {
            status = NtQueryKey(hKey,
                full->Type(),     //        KeyFullInformation,
                full->Ptr(),
                full->Size(),
                pResultSize);
    
            *result = full->Ptr();
        }
        else
            status = STATUS_NO_MEMORY ;
    }
    else
        status = STATUS_OBJECT_NAME_NOT_FOUND; // need to call open or key is not found

    return status;

}

//This will allocate and set pFullPath. pFullPath is a global variable which is deallocated
//by the destructor, so this function should only be called if pFullPath has not already
//been allocated for this object.
NTSTATUS KeyNode::GenerateFullPath()
{
    status = STATUS_SUCCESS;

    // A key handle or root directory was specified, so get its path
    if (hKey)
    {
        ULONG ultemp = 0;
        ultemp = sizeof(UNICODE_STRING) + (sizeof(WCHAR) * MAX_PATH * 2);
        pFullPath = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ultemp);

        // Got the buffer OK, query the path
        if (pFullPath)
        {
            // Get the path for key or root directory
            status = NtQueryObject(hKey ,
                                   ObjectNameInformation,
                                   (PVOID)pFullPath,
                                   ultemp,
                                   NULL);

            if (!NT_SUCCESS(status))
                RtlFreeHeap(RtlProcessHeap(), 0, pFullPath);
        }
        else
             status = STATUS_NO_MEMORY;
    }
    else
        status = STATUS_OBJECT_NAME_NOT_FOUND; // need to call open or key is not found

    return (status);
}


NTSTATUS KeyNode::GetPath(PWCHAR *pwch)
{
    status = STATUS_SUCCESS;

    if (pFullPath == NULL)
        status = GenerateFullPath();

    if (NT_SUCCESS(status))
    {
        // Build the full path to the key to be created
        *pwch = ((PUNICODE_STRING)pFullPath)->Buffer;

        // Make sure the string is zero terminated
        ULONG ulWcharLength = 0;
        ulWcharLength = ((PUNICODE_STRING)pFullPath)->Length / sizeof(WCHAR);
        (*pwch)[ulWcharLength] = L'\0';
    }

    return (status);
}


void KeyNode::Debug( DebugType type )
{
    if ( debug )
    {
        ULONG i;

        switch( type )
        {
        case DBG_DELETE :
            fwprintf( g_debugFilePointer ,
                    L"Deleted key=%lx; status=%lx, name=", status, hKey );
            DbgPrint("Deleted key=%lx; status=%lx, name=", status, hKey );
            break;

        case DBG_OPEN_FAILED:
            fwprintf( g_debugFilePointer,
                    L"Unable to Open, status=%lx, name=", hKey, status );
            DbgPrint("Unable to Open, status=%lx, name=", hKey, status );
            break;

        case DBG_KEY_NAME:
            fwprintf( g_debugFilePointer,
                    L"hKey=%lx, name=", hKey);
            DbgPrint("hKey=%lx, name=", hKey);
            break;

        case DBG_CREATE:
            fwprintf( g_debugFilePointer,
                    L"Created hKey=%lx, status=%lx,name=", hKey, status);
            DbgPrint("Created hKey=%lx, status=%lx,name=", hKey, status );
            break;
        }

        fwprintf( g_debugFilePointer, L"%s\n",NameSz() );
        fflush( g_debugFilePointer );
        DbgPrint("%s\n",(char *)NameSz() );
    }
}


PCWSTR KeyNode::NameSz()
{
    if (!pNameSz)
    {
        pNameSz = new WCHAR [ uniName.Length / sizeof(WCHAR) + 1 ];

        if (pNameSz)
        {
            for ( ULONG i=0; i < uniName.Length / sizeof(WCHAR) ; i++)
            {
                pNameSz[i] = ( (USHORT)uniName.Buffer[i] );
            }
            pNameSz[i]=L'\0';
        }
        else
        {
            status = STATUS_NO_MEMORY;
        }
    }

    return pNameSz;
}

NTSTATUS KeyNode::GetFullInfo( KeyFullInfo   **p)
{
    // do a self query
    if ( !full )
    {
        ULONG   size;
        KEY_FULL_INFORMATION    *tmp;
        Query( &tmp , &size );
    }

    *p = full;

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\compatfl.c ===
/*************************************************************************
* compatfl.c
*
* Routines used to get Citrix application compatibility flags
*
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

typedef VOID (*GETDOSAPPNAME)(LPSTR);

ULONG gCompatFlags = 0xFFFFFFFF;
DWORD gdwAppType = 0;

WCHAR *
Ctx_wcsistr( WCHAR * pString, WCHAR * pPattern )
{
    WCHAR * pBuf1;
    WCHAR * pBuf2;
    WCHAR * pCh;

    if ( pString == NULL )
        return( NULL );

    pBuf1 = RtlAllocateHeap( RtlProcessHeap(), 0, (wcslen(pString) * sizeof(WCHAR)) + sizeof(WCHAR) );
    if ( pBuf1 == NULL )
        return( NULL );

    wcscpy( pBuf1, pString );

    pBuf2 = _wcslwr( pBuf1 );

    pCh = wcsstr( pBuf2, pPattern );

    RtlFreeHeap( RtlProcessHeap(), 0, pBuf1 );

    if ( pCh == NULL )
        return( NULL );

    return( pString + (pCh - pBuf2) );
}

//*****************************************************************************
// GetAppTypeAndModName
//
//    Returns the application type and module name of the running application.
//
//    Parameters:
//      LPDWORD pdwAppType     (IN)  - (IN optional) ptr to app type
//                             (OUT) - Application Type
//      PWCHAR ModName         (OUT) - Module Name
//      Length                 (IN)  - Maximum length of ModName including NULL
//
//    Return Value:
//      TRUE on successfully finding the application name, FALSE otherwise.
//
//    Notes:
//
//      If the caller knows that this is a win32 app, they can set pdwAppType
//      to TERMSRV_COMPAT_WIN32 to save some overhead.
//
//*****************************************************************************

BOOL GetAppTypeAndModName(OUT LPDWORD pdwAppType, OUT PWCHAR ModName, ULONG Length)
{
    PWCHAR  pwch, pwchext;
    WCHAR   pwcAppName[MAX_PATH+1];
    CHAR    pszAppName[MAX_PATH+1];
    HANDLE  ntvdm = NULL;
    GETDOSAPPNAME GetDOSAppNamep = NULL;
    ANSI_STRING   AnsiString;
    UNICODE_STRING UniString;
    PRTL_PERTHREAD_CURDIR  pRtlInfo;
    PRTL_USER_PROCESS_PARAMETERS pUserParam;

    // Get the path of the executable name
    pUserParam = NtCurrentPeb()->ProcessParameters;

    // Get the executable name, if there's no \ just use the name as it is
    pwch = wcsrchr(pUserParam->ImagePathName.Buffer, L'\\');
    if (pwch) {
        pwch++;
    } else {
        pwch = pUserParam->ImagePathName.Buffer;
    }
    wcscpy(pwcAppName, pwch);
    pwch = pwcAppName;

    // If it's not a Win32 app, do the extra work to get the image name
    if (!(*pdwAppType & TERMSRV_COMPAT_WIN32)) {

        *pdwAppType = TERMSRV_COMPAT_WIN32;  // Default to a Win32 app

        // Check if it's a DOS or Win16 app by checking if the app is ntvdm.exe
        if (!_wcsicmp(pwch, L"ntvdm.exe")) {
            pRtlInfo = RtlGetPerThreadCurdir();

            // If there's per-thread data, it's a Win16 app
            if (pRtlInfo) {
                *pdwAppType = TERMSRV_COMPAT_WIN16;
                wcscpy(pwcAppName, pRtlInfo->ImageName->Buffer);
            } else {
                // Load NTVDM
                if ((ntvdm = LoadLibrary(L"ntvdm.exe"))) {

                    // Get the address of GetDOSAppName
                    if ((GetDOSAppNamep = (GETDOSAPPNAME)GetProcAddress(
                                                          ntvdm,
                                                          "GetDOSAppName"))) {
                        RtlInitUnicodeString(&UniString, pwcAppName);
                        UniString.MaximumLength = MAX_PATH;


                        //
                        // Use pszAppName only if not NULL otherwise we are processing the PIF
                        // so go w/ NTVDM as the name.
                        //
                        GetDOSAppNamep(pszAppName);

                        if (*pszAppName != '\0') {
                           RtlInitAnsiString(&AnsiString, pszAppName);
                           RtlAnsiStringToUnicodeString(&UniString,
                                                        &AnsiString,
                                                        FALSE);
                        }
                        pwch = UniString.Buffer;
                        *pdwAppType = TERMSRV_COMPAT_DOS;
                        FreeLibrary(ntvdm);
                    } else {
#if DBG
                        DbgPrint( "KERNEL32: Couldn't get GetDOSAppName entry point\n" );
#endif
                        FreeLibrary(ntvdm);
                        return (FALSE);
                    }
                } else {
#if DBG
                    DbgPrint( "KERNEL32: Couldn't load ntvdm.exe\n" );
#endif
                    return(FALSE);
                }
            }
        } else if (!_wcsicmp(pwch, L"os2.exe")) {

            *pdwAppType = TERMSRV_COMPAT_OS2;

            // Look in the command line for /p, which is fully qualified path
            pwch = wcsstr(pUserParam->CommandLine.Buffer, L"/P");

            if (!pwch) {
                pwch = wcsstr(pUserParam->CommandLine.Buffer, L"/p");
            }

            if (pwch) {
                pwch += 3;          // skip over /p and blank
                if (pwchext = wcschr(pwch, L' ')) {
                    wcsncpy(pwcAppName, pwch, (size_t)(pwchext - pwch));
                    pwcAppName[pwchext - pwch] = L'\0';
                } else {
                    return (FALSE);
                }
            } else{
                return (FALSE);
            }
        }

        // Get rid of the app's path, if necessary
        if (pwch = wcsrchr(pwcAppName, L'\\')) {
            pwch++;
        } else {
            pwch = pwcAppName;
        }
        
        //
        //Set global gdwAppType only if we did the real type checking.
        //
        gdwAppType = *pdwAppType;
    }
    
    // Remove the extension
    if (pwchext = wcsrchr(pwch, L'.')) {
        *pwchext = '\0';
    }
    
    // Copy out the Module name
    if (((wcslen(pwch) + 1) * sizeof(WCHAR)) > Length) {
        return(FALSE);
    }
    
    wcscpy(ModName, pwch);
    return(TRUE);

}

//*****************************************************************************
// GetCtxPhysMemoryLimits
//
//    Returns the Physical Memory limits for the current application.
//
//    Parameters:
//      LPDWORD pdwAppType     (IN)  - (IN optional) ptr to app type
//                             (OUT) - Application Type
//      LPDWORD pdwPhysMemLim  (OUT) - Value of physical memory limit
//
//    Return Value:
//      TRUE on successfully finding a limit, ZERO if no limit.
//
//    Notes:
//
//      If the caller knows that this is a win32 app, they can set pdwAppType
//      to TERMSRV_COMPAT_WIN32 to save some overhead.
//
//*****************************************************************************
ULONG GetCtxPhysMemoryLimits(OUT LPDWORD pdwAppType, OUT LPDWORD pdwPhysMemLim)
{
    WCHAR   ModName[MAX_PATH+1];
    ULONG   ulrc = FALSE;
    ULONG dwCompatFlags;

    *pdwPhysMemLim = 0;

    if (!GetAppTypeAndModName(pdwAppType, ModName, sizeof(ModName))) {
        goto CtxGetPhysMemReturn;
    }

    // Get the compatibility flags to look for memory limits flag
    ulrc = GetTermsrCompatFlags(ModName, &dwCompatFlags, CompatibilityApp);
    if ( ulrc & ((dwCompatFlags & TERMSRV_COMPAT_PHYSMEMLIM ) &&
                  (dwCompatFlags & *pdwAppType)) ) {

        NTSTATUS NtStatus;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UniString;
        HKEY   hKey = 0;
        ULONG  ul, ulcbuf;
        ULONG  DataLen;
        PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;
        LPWSTR UniBuff = NULL;

        RtlInitUnicodeString( &UniString, NULL ); // we test for this below
        ulrc = TRUE;
        *pdwPhysMemLim = TERMSRV_COMPAT_DEFAULT_PHYSMEMLIM;

        ul = sizeof(TERMSRV_COMPAT_APP) + (wcslen(ModName) + 1)*sizeof(WCHAR);

        UniBuff = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ul);

        if (UniBuff) {
            wcscpy(UniBuff, TERMSRV_COMPAT_APP);
            wcscat(UniBuff, ModName);

            RtlInitUnicodeString(&UniString, UniBuff);
        }

        // Determine the value info buffer size
        ulcbuf = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
                 sizeof(ULONG);

        pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                      0,
                                      ulcbuf);

        // Did everything initialize OK?
        if (UniString.Buffer && pKeyValInfo) {
            InitializeObjectAttributes(&ObjectAttributes,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL
                                      );

            NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

            if (NT_SUCCESS(NtStatus)) {

                RtlInitUnicodeString(&UniString, TERMSRV_PHYSMEMLIM );
                NtStatus = NtQueryValueKey(hKey,
                                           &UniString,
                                           KeyValuePartialInformation,
                                           pKeyValInfo,
                                           ulcbuf,
                                           &DataLen);

                if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type)) {
                    *pdwPhysMemLim = *(PULONG)pKeyValInfo->Data;
                    ulrc = TRUE;
                }
                NtClose(hKey);
            }
        }
        // Free up the buffers we allocated
        // Need to zero out the buffers, because some apps (MS Internet Assistant)
        // won't install if the heap is not zero filled.
        if (UniBuff) {
            memset(UniBuff, 0, ul);
            RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
        }
        if (pKeyValInfo) {
            memset(pKeyValInfo, 0, ulcbuf);
            RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
        }
    }
    else {
        ulrc = FALSE;
    }

CtxGetPhysMemReturn:
//#if DBG
//DbgPrint("CtxGetPhysMemLim returning %d; PhysMemLim=%d\n", ulrc, *pdwPhysMemLim);
//#endif
    return(ulrc);
}


//*****************************************************************************
// GetCtxAppCompatFlags -
//
//    Returns the Citrix compatibility flags for the current application.
//
//    Parameters:
//      LPDWORD pdwCompatFlags (OUT) - Ptr to DWORD return value for flags
//      LPDWORD pdwAppType     (IN)  - (IN optional) ptr to app type
//                             (OUT) - Application Type
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    Notes:
//
//      If the caller knows that this is a win32 app, they can set pdwAppType
//      to TERMSRV_COMPAT_WIN32 to save some overhead.
//
//    Flag values are defined in syslib.h:
//
//      TERMSRV_COMPAT_DOS      - Compatibility flags are for DOS app
//      TERMSRV_COMPAT_OS2      - Compatibility flags are for OS2 app
//      TERMSRV_COMPAT_WIN16    - Compatibility flags are for Win16 app
//      TERMSRV_COMPAT_WIN32    - Compatibility flags are for Win32 app
//      TERMSRV_COMPAT_ALL      - Compatibility flags are for any app
//      TERMSRV_COMPAT_USERNAME - Return Username instead of Computername
//      TERMSRV_COMPAT_MSBLDNUM - Return MS build number, not Citrix build no.
//      TERMSRV_COMPAT_INISYNC  - Sync user ini file with system version
//*****************************************************************************
ULONG GetCtxAppCompatFlags(OUT LPDWORD pdwCompatFlags, OUT LPDWORD pdwAppType)
{
    WCHAR   ModName[MAX_PATH+1];
    
    if((gCompatFlags != 0xFFFFFFFF) && (gdwAppType == TERMSRV_COMPAT_WIN32))
    {
        *pdwCompatFlags = gCompatFlags;
        *pdwAppType = gdwAppType;
        return (TRUE);
    }

    if (!GetAppTypeAndModName(pdwAppType, ModName, sizeof(ModName))) {
        return (FALSE);
    }

    // Get the flags

    return (GetTermsrCompatFlags(ModName, pdwCompatFlags, CompatibilityApp));
}


//*****************************************************************************
// GetTermsrCompatFlags -
//
//    Returns the Citrix compatibility flags for the specified task.
//
//    Parameters:
//      LPWSTR  lpModName      (IN)  - Image name to look up in registry
//      LPDWORD pdwCompatFlags (OUT) - Ptr to DWORD return value for flags
//      TERMSRV_COMPATIBILITY_CLASS CompatType (IN) - Indicates app or inifile
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    Notes:
//      Assumes it's being called in the context of the current application -
//      we use the current Teb to get the compatibility flags.
//
//      Flag values are defined in syslib.h.
//
//*****************************************************************************

ULONG GetTermsrCompatFlags(LPWSTR lpModName,
                           LPDWORD pdwCompatFlags,
                           TERMSRV_COMPATIBILITY_CLASS CompatType)
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UniString;
    HKEY   hKey = 0;
    ULONG  ul, ulcbuf;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;
    ULONG  ulRetCode = FALSE;
    LPWSTR UniBuff = NULL;
    
    *pdwCompatFlags = 0;

    // If terminal services aren't enabled, just return
    if (!IsTerminalServer()) {
        return(TRUE);
    }

    UniString.Buffer = NULL;

    if (CompatType == CompatibilityApp) {

        if (gCompatFlags != 0xFFFFFFFF) {
            //DbgPrint( "GetTermsrCompatFlags: Return cached compatflags (gCompatFlags)%lx for app %ws\n",gCompatFlags,lpModName );
            *pdwCompatFlags = gCompatFlags;
            return TRUE;
        }

        // Look and see if the compat flags in the Teb are valid (right now
        // they're only valid for Win16 apps).  Don't set them for DOS apps
        // unless you can have a mechanism to have unique values for each
        // DOS app in a VDM.
//      if (wcsstr(NtCurrentPeb()->ProcessParameters->ImagePathName.Buffer, L"ntvdm.exe")) {
//          PVOID Ra;
//          ASSERT(gpTermsrvTlsIndex != 0xFFFFFFFF);
//          Ra = TlsGetValue( gpTermsrvTlsIndex );
//          if (Ra != NULL) {
//              //DbgPrint( "GetTermsrCompatFlags: Return cached compatflags (Ra)%lx for app %ws\n",Ra,lpModName );
//              *pdwCompatFlags = (DWORD)PtrToUlong(Ra);
//              return TRUE;
//          }
//      }
#if 0
        if (NtCurrentTeb()->CtxCompatFlags & TERMSRV_COMPAT_TEBVALID) {
            *pdwCompatFlags = NtCurrentTeb()->CtxCompatFlags;
            return(TRUE);
        }
#endif

        ul = sizeof(TERMSRV_COMPAT_APP) + (wcslen(lpModName) + 1)*sizeof(WCHAR);

        UniBuff = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ul);

        if (UniBuff) {
            wcscpy(UniBuff, TERMSRV_COMPAT_APP);
            wcscat(UniBuff, lpModName);

            RtlInitUnicodeString(&UniString, UniBuff);
        }
    } else {
        RtlInitUnicodeString(&UniString,
                             (CompatType == CompatibilityIniFile) ?
                             TERMSRV_COMPAT_INIFILE : TERMSRV_COMPAT_REGENTRY
                            );
    }

    // Determine the value info buffer size
    ulcbuf = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
             sizeof(ULONG);

    pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ulcbuf);

    // Did everything initialize OK?
    if (UniString.Buffer && pKeyValInfo) {
        InitializeObjectAttributes(&ObjectAttributes,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(NtStatus)) {

            // If we're not checking for a registry entry, just try to get
            // the value for the key
            if (CompatType != CompatibilityRegEntry) {
                RtlInitUnicodeString(&UniString,
                    CompatType == CompatibilityApp ? COMPAT_FLAGS : lpModName);
                NtStatus = NtQueryValueKey(hKey,
                                           &UniString,
                                           KeyValuePartialInformation,
                                           pKeyValInfo,
                                           ulcbuf,
                                           &ul);

                if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type)) {
                    *pdwCompatFlags = *(PULONG)pKeyValInfo->Data;
                    ulRetCode = TRUE;
                }


                //
                // Cache the appcompatiblity flags
                //
//              if (CompatType == CompatibilityApp) {
//                  if (wcsstr(NtCurrentPeb()->ProcessParameters->ImagePathName.Buffer, L"ntvdm.exe")) {
//                      TlsSetValue(gpTermsrvTlsIndex,(PVOID)((*pdwCompatFlags)| TERMSRV_COMPAT_TEBVALID));
//                      //DbgPrint( "GetTermsrCompatFlags: Setting cached compatflags (gCompatFlags)%lx for WOW app %ws\n",((*pdwCompatFlags)| TERMSRV_COMPAT_TEBVALID),lpModName );
//                  } else {
//                      gCompatFlags = *pdwCompatFlags;
//                      //DbgPrint( "GetTermsrCompatFlags: Setting cached compatflags (gCompatFlags)%lx for app %ws\n",gCompatFlags,lpModName );
//                  }
//              }

                if (CompatType == CompatibilityApp) {

                    if(!gdwAppType) {

                        DWORD dwTmp = 0;
                        GetAppTypeAndModName(&dwTmp, NULL, 0);
                    }
                    if (gdwAppType == TERMSRV_COMPAT_WIN32) {
                        
                        gCompatFlags = *pdwCompatFlags;
                    }
                }

            // For registry keys, we need to enumerate all of the keys, and
            // check if the the substring matches our current path.
            } else {
                PWCH pwch;
                ULONG ulKey = 0;
                PKEY_VALUE_FULL_INFORMATION pKeyFullInfo;

                pKeyFullInfo = (PKEY_VALUE_FULL_INFORMATION)pKeyValInfo;

                // Get to the software section
                pwch = Ctx_wcsistr(lpModName, L"\\software");

                // Skip past the next backslash
                if (pwch) {
                    pwch = wcschr(pwch + 1, L'\\');
                }

                // We don't need to look for a key if this isn't in the user
                // software section
                if (pwch) {

                    // Skip over the leading backslash
                    pwch++;

                    // Go through each value, looking for this path
                    while (NtEnumerateValueKey(hKey,
                                               ulKey++,
                                               KeyValueFullInformation,
                                               pKeyFullInfo,
                                               ulcbuf,
                                               &ul) == STATUS_SUCCESS) {

                        if (!_wcsnicmp(pKeyFullInfo->Name,
                                      pwch,
                                      pKeyFullInfo->NameLength/sizeof(WCHAR))) {
                            *pdwCompatFlags = *(PULONG)((PCHAR)pKeyFullInfo +
                                                     pKeyFullInfo->DataOffset);
                            ulRetCode = TRUE;
                            break;
                        }
                    }
                }

            }
            NtClose(hKey);

        } else {

            if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND &&
                CompatType == CompatibilityApp) {

                    if(!gdwAppType) {

                        DWORD dwTmp = 0;
                        GetAppTypeAndModName(&dwTmp, NULL, 0);
                    }
                    if (gdwAppType == TERMSRV_COMPAT_WIN32) {
                        
                        gCompatFlags = 0;
                        ulRetCode = TRUE;
                    }
            }
        }
    }

    // Free up the buffers we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    if (UniBuff) {
        memset(UniBuff, 0, UniString.MaximumLength);
        RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
    }
    if (pKeyValInfo) {
        memset(pKeyValInfo, 0, ulcbuf);
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
    }

    return(ulRetCode);
}

//*****************************************************************************
// CtxGetBadAppFlags -
//
//    Gets the Citrix badapp and compatibility flags for the specified task.
//
//    Parameters:
//      LPWSTR  lpModName      (IN)  - Image name to look up in registry
//      PBADAPP pBadApp        (OUT) - Structure to used to return flags
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    Flag values are defined in syslib.h.
//
//*****************************************************************************

BOOL CtxGetBadAppFlags(LPWSTR lpModName, PBADAPP pBadApp)
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UniString;
    HKEY hKey = 0;
    ULONG ul, ulcnt, ulcbuf, ulrc = FALSE;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = NULL;
    LPWSTR UniBuff;
    PWCHAR pwch;
    static ULONG badappregdefaults[3] = {1,15,5};
    static BOOL  fgotdefaults = FALSE;
    WCHAR  *pbadappNameValue[] = {
                   COMPAT_MSGQBADAPPSLEEPTIMEINMILLISEC,
                                   COMPAT_FIRSTCOUNTMSGQPEEKSSLEEPBADAPP,
                                   COMPAT_NTHCOUNTMSGQPEEKSSLEEPBADAPP,
                                   COMPAT_FLAGS
                                 };


    // Get the executable name only, no path.
    pwch = wcsrchr(lpModName, L'\\');
    if (pwch) {
        pwch++;
    } else {
        pwch = lpModName;
    }

    // Get the buffers we need
    ul = sizeof(TERMSRV_COMPAT_APP) + (wcslen(pwch) + 1)*sizeof(WCHAR);

    UniBuff = RtlAllocateHeap(RtlProcessHeap(), 0, ul);

    ulcbuf = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG);

    pKeyValueInfo = RtlAllocateHeap(RtlProcessHeap(), 0, ulcbuf);

    if (UniBuff && pKeyValueInfo) {

        if (!fgotdefaults) {
            // Get the default values from the registry
            RtlInitUnicodeString(&UniString,
                TERMSRV_REG_CONTROL_NAME
                );

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL
                                      );

            NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

            if (NT_SUCCESS(NtStatus)) {

                for (ulcnt = 0; ulcnt < 3; ulcnt++) {

                    RtlInitUnicodeString(&UniString, pbadappNameValue[ulcnt]);
                    NtStatus = NtQueryValueKey(hKey,
                                               &UniString,
                                               KeyValuePartialInformation,
                                               pKeyValueInfo,
                                               ulcbuf,
                                               &ul);

                    if (NT_SUCCESS(NtStatus) &&
                        (REG_DWORD == pKeyValueInfo->Type)) {
                        badappregdefaults[ulcnt] = *(PULONG)pKeyValueInfo->Data;
                    }
                }
                NtClose(hKey);
            }
            fgotdefaults = TRUE;
        }

        wcscpy(UniBuff, TERMSRV_COMPAT_APP);
        wcscat(UniBuff, pwch);

        // Remove the extension
        if (pwch = wcsrchr(UniBuff, L'.')) {
            *pwch = '\0';
        }

        RtlInitUnicodeString(&UniString,
                             UniBuff
                            );

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(NtStatus)) {

            ulrc = TRUE;
            for (ulcnt = 0; ulcnt < 4; ulcnt++) {

                RtlInitUnicodeString(&UniString, pbadappNameValue[ulcnt]);
                NtStatus = NtQueryValueKey(hKey,
                                           &UniString,
                                           KeyValuePartialInformation,
                                           pKeyValueInfo,
                                           ulcbuf,
                                           &ul);

                if (NT_SUCCESS(NtStatus) &&
                    (REG_DWORD == pKeyValueInfo->Type)) {
                    switch (ulcnt) {
                        case 0:
                            pBadApp->BadAppTimeDelay =
                                RtlEnlargedIntegerMultiply(
                                    *(PULONG)pKeyValueInfo->Data,
                                    -10000 );
                            break;
                        case 1:
                            pBadApp->BadAppFirstCount =
                                *(PULONG)pKeyValueInfo->Data;
                            break;
                        case 2:
                            pBadApp->BadAppNthCount =
                                *(PULONG)pKeyValueInfo->Data;
                            break;
                        case 3:
                            pBadApp->BadAppFlags =
                                *(PULONG)pKeyValueInfo->Data;
                            break;
                    }
                } else {
                    switch (ulcnt) {
                        case 0:
                            pBadApp->BadAppTimeDelay =
                                RtlEnlargedIntegerMultiply(
                                    badappregdefaults[ulcnt],
                                    -10000 );
                            break;
                        case 1:
                            pBadApp->BadAppFirstCount = badappregdefaults[ulcnt];
                            break;
                        case 2:
                            pBadApp->BadAppNthCount = badappregdefaults[ulcnt];
                            break;
                        case 3:
                            pBadApp->BadAppFlags = 0;
                            break;
                    }
                }
            }
            NtClose(hKey);
        }
    }

    // Free the memory we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    if (UniBuff) {
        memset(UniBuff, 0, UniString.MaximumLength);
        RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
    }
    if (pKeyValueInfo) {
        memset(pKeyValueInfo, 0, ulcbuf);
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValueInfo );
    }

    return(ulrc);
}


//*****************************************************************************
// GetCitrixCompatClipboardFlags -
//
//    Returns the Citrix compatibility clipboard flags for the specified
//    application
//
//    Parameters:
//      LPWSTR  lpModName      (IN)  - Image name to look up in registry
//      LPDWORD pdwCompatFlags (OUT) - Ptr to DWORD return value for clipboard flags
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    Notes:
//      Flag values are defined in syslib.h.
//
//*****************************************************************************

ULONG
GetCitrixCompatClipboardFlags(LPWSTR lpModName,
                              LPDWORD pdwClipboardFlags)
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UniString;
    HKEY   hKey = 0;
    ULONG  ul, ulcbuf;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;
    ULONG  ulRetCode = FALSE;
    LPWSTR UniBuff = NULL;

    UniString.Buffer = NULL;

    ul = sizeof(TERMSRV_COMPAT_APP) + (wcslen(lpModName) + 1)*sizeof(WCHAR);

    UniBuff = RtlAllocateHeap(RtlProcessHeap(),
                              0,
                              ul);

    if (UniBuff) {
       wcscpy(UniBuff, TERMSRV_COMPAT_APP);
       wcscat(UniBuff, lpModName);

       RtlInitUnicodeString(&UniString, UniBuff);
    }

    // Determine the value info buffer size
    ulcbuf = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
             sizeof(ULONG);

    pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ulcbuf);

    // Did everything initialize OK?
    if (UniString.Buffer && pKeyValInfo) {
        InitializeObjectAttributes(&ObjectAttributes,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(NtStatus)) {

            RtlInitUnicodeString(&UniString, COMPAT_CLIPBOARDFLAGS );
            NtStatus = NtQueryValueKey(hKey,
                                       &UniString,
                                       KeyValuePartialInformation,
                                       pKeyValInfo,
                                       ulcbuf,
                                       &ul);

            if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type)) {
                *pdwClipboardFlags = *(PULONG)pKeyValInfo->Data;
                ulRetCode = TRUE;
            }

            NtClose(hKey);
        }
    }

    // Free up the buffers we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    if (UniBuff) {
        memset(UniBuff, 0, UniString.MaximumLength);
        RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
    }
    if (pKeyValInfo) {
        memset(pKeyValInfo, 0, ulcbuf);
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
    }

    return(ulRetCode);
}


//*****************************************************************************
// CitrixGetAppModuleName -
//
//    Extracts the module name for a given process handle.  The directory
//    path and the file extension are stripped off.
//
//    Parameters:
//      HANDLE  ProcHnd        (IN)  - Handle to the process
//      LPWSTR  buffer         (IN)  - buffer used to return the module
//      LPWSTR  lpModName      (IN)  - Available size of the buffer in bytes
//      LPDWORD pdwCompatFlags (OUT) - Ptr to DWORD return value for clipboard flags
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    Notes:
//      Function only works for 32 bit windows applications
//
//*****************************************************************************


BOOLEAN
CitrixGetAppModuleName ( HANDLE ProcHnd, LPWSTR Buffer, ULONG Length )
{
   PROCESS_BASIC_INFORMATION ProcInfo;
   ULONG retLen;
   PEB peb;
   RTL_USER_PROCESS_PARAMETERS params;
   WCHAR pwcAppName[MAX_PATH];
   PWCHAR pwch;

   if ( NtQueryInformationProcess( ProcHnd, ProcessBasicInformation,
                                    (PVOID) &ProcInfo, sizeof(ProcInfo),
                                    &retLen ) ) {
      return ( FALSE );
   }

   if ( !ProcInfo.PebBaseAddress ) {
      return ( FALSE );
   }

   if ( ! ReadProcessMemory(ProcHnd, (PVOID)ProcInfo.PebBaseAddress, &peb,
                            sizeof(peb), NULL ) ) {
      return ( FALSE );
   }

   if ( !ReadProcessMemory(ProcHnd, peb.ProcessParameters, &params,
                           sizeof(params), NULL ) ) {
      return ( FALSE );
   }

   if ( !ReadProcessMemory( ProcHnd, params.ImagePathName.Buffer, pwcAppName,
                            sizeof(pwcAppName), NULL) ) {
      return ( FALSE );
   }

   pwch = wcsrchr(pwcAppName, L'\\');
   if ( pwch ) {
      pwch++;
   }
   else {
      pwch = pwcAppName;
   }

   if ( wcslen(pwch) >= (Length / sizeof(WCHAR)) ) {
      return ( FALSE );
   }

   wcscpy(Buffer, pwch);

   // Remove the extension
   if (pwch = wcsrchr(Buffer, L'.')) {
       *pwch = '\0';
   }
   return ( TRUE );
}

// Globals for logging
// We cache the compatibility flags for the running 32 bit app.
// If the logging is enabled for ntvdm, we'll check the flags of the
// Win16 or DOS app on each object create.

DWORD CompatFlags = 0;
BOOL CompatGotFlags = FALSE;
DWORD CompatAppType = TERMSRV_COMPAT_WIN32;

void CtxLogObjectCreate(PUNICODE_STRING ObjName, PCHAR ObjType,
                        PVOID RetAddr)
{
    CHAR RecBuf[2 * MAX_PATH];
    CHAR ObjNameA[MAX_PATH];
    PCHAR DllName;
    WCHAR FileName[MAX_PATH];
    WCHAR ModName[MAX_PATH];
    ANSI_STRING AnsiString;
    PRTL_PROCESS_MODULES LoadedModules;
    PRTL_PROCESS_MODULE_INFORMATION Module;

    HANDLE LogFile;
    OVERLAPPED Overlapped;
    NTSTATUS Status;
    ULONG i;
    DWORD BytesWritten;
    DWORD lCompatFlags;    // For Win16 or DOS Apps
    DWORD AppType = 0;
    ULONG AllocSize = 4096;
    BOOL NameFound = FALSE;


    // Determine the log file name
    if (GetEnvironmentVariableW(OBJ_LOG_PATH_VAR, FileName, MAX_PATH)) {
        if (GetAppTypeAndModName(&AppType,ModName,sizeof(ModName))) {
            if (AppType != TERMSRV_COMPAT_WIN32 ) {
                // Logging was enabled for ntvdm - check the
                // compatibility flags of the Win16 or DOS app
                if (!GetTermsrCompatFlags(ModName,
                                          &lCompatFlags,
                                          CompatibilityApp) ||
                    !(lCompatFlags & TERMSRV_COMPAT_LOGOBJCREATE))
                    return;
            }
            if ((wcslen(FileName) + wcslen(ModName) + 2) <= MAX_PATH) {
                lstrcatW(FileName, L"\\");
                lstrcatW(FileName,ModName);
                lstrcatW(FileName,L".log");
            } else
                return;
        } else
           return;
    } else
        return;

    //Format the log record
    AnsiString.Buffer = ObjNameA;
    AnsiString.MaximumLength = MAX_PATH;
    RtlUnicodeStringToAnsiString(&AnsiString, ObjName, FALSE);

    // Try to get the DLL name of the caller
    AllocSize = 4096;
    for (;;) {
        LoadedModules = (PRTL_PROCESS_MODULES)
            RtlAllocateHeap(RtlProcessHeap(), 0, AllocSize);
        if (!LoadedModules) {
            return;
        }

        Status = LdrQueryProcessModuleInformation(LoadedModules, AllocSize, NULL);
        if (NT_SUCCESS(Status)) {
            break;
        }
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            RtlFreeHeap( RtlProcessHeap(), 0, LoadedModules );
            LoadedModules = NULL;
            AllocSize += 4096;
            continue;
        }
        // Other error;
        RtlFreeHeap( RtlProcessHeap(), 0, LoadedModules );
        return;
    }

    for (i=0,Module = &LoadedModules->Modules[0];
         i<LoadedModules->NumberOfModules;
         i++, Module++ ) {
        if ((RetAddr >= Module->ImageBase) &&
            ((ULONG_PTR) RetAddr < (((ULONG_PTR)Module->ImageBase) + Module->ImageSize))) {
            NameFound = TRUE;
            DllName = Module->FullPathName;
            break;
        }
    }

    if (!NameFound) {
        DllName = "DLL Not Found";
    }

    sprintf(RecBuf,"Create %s name: %s Return Addr: %p (%s)\n",
            ObjType, ObjNameA, RetAddr, DllName);

    if (LoadedModules) {
        RtlFreeHeap( RtlProcessHeap(), 0, LoadedModules );
        LoadedModules = NULL;
    }

    // Write log record
    if ((LogFile = CreateFileW(FileName, GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL, OPEN_ALWAYS, 0, NULL)) ==
        INVALID_HANDLE_VALUE ) {
        return;
    }

    // Lock the file exclusive since we always write at the end.
    // We get mutual exclusion by always locking the first 64k bytes
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;
    Overlapped.hEvent = NULL;
    LockFileEx(LogFile, LOCKFILE_EXCLUSIVE_LOCK, 0, 0x10000, 0, &Overlapped);

    // Write at the end of the file
    SetFilePointer(LogFile, 0, NULL, FILE_END);
    WriteFile(LogFile, RecBuf, strlen(RecBuf), &BytesWritten, NULL);
    UnlockFileEx(LogFile, 0, 0x10000, 0, &Overlapped);

    CloseHandle(LogFile);

}

//*****************************************************************************
// CtxGetCrossWinStationDebug -
//
//    Gets the Citrix Cross Winstation debug flag
//
//    Parameters:
//       NONE
//    Return Value:
//      TRUE   Cross WinStation Debug enabled
//      FALSE  CrosS WinStation Debug Disabled
//
//
//*****************************************************************************

BOOL CtxGetCrossWinStationDebug()
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UniString;
    HKEY hKey = 0;
    ULONG ul, ulcnt, ulcbuf, ulrc = FALSE;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = NULL;
    LPWSTR UniBuff;
    ULONG Flag = 0;

    // Get the buffers we need
    ul = sizeof(TERMSRV_REG_CONTROL_NAME);

    UniBuff = RtlAllocateHeap(RtlProcessHeap(), 0, ul);

    ulcbuf = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG);

    pKeyValueInfo = RtlAllocateHeap(RtlProcessHeap(), 0, ulcbuf);

    if (UniBuff && pKeyValueInfo) {

        RtlInitUnicodeString(&UniString, TERMSRV_REG_CONTROL_NAME );

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(NtStatus)) {

            RtlInitUnicodeString(&UniString, TERMSRV_CROSS_WINSTATION_DEBUG);
            NtStatus = NtQueryValueKey(hKey,
                                       &UniString,
                                       KeyValuePartialInformation,
                                       pKeyValueInfo,
                                       ulcbuf,
                                       &ul);

            if ( NT_SUCCESS(NtStatus) ) {
                if ( REG_DWORD == pKeyValueInfo->Type ) {
                    Flag = *(PULONG)pKeyValueInfo->Data;
                }
            }
            NtClose(hKey);
        }
    }

    // Free the memory we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    if (UniBuff) {
        memset(UniBuff, 0, UniString.MaximumLength);
        RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
    }
    if (pKeyValueInfo) {
        memset(pKeyValueInfo, 0, ulcbuf);
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValueInfo );
    }

    return( Flag ? TRUE : FALSE );
}


//*****************************************************************************
// CtxGetModuleBadClpbrdAppFlags -
//
//    Gets the Citrix BadClpbrdApp and compatibility flags for the specified
//    module.
//
//    Parameters:
//      LPWSTR  lpModName      (IN)  - Image name to look up in registry
//      PBADCLPBRDAPP pBadClpbrdApp        (OUT) - Structure to used to return flags
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    The BADCLPBRDAPP structure is defined in:
//           base\client\citrix\compatfl.h and user\inc\user.h.
//
//*****************************************************************************

BOOL CtxGetModuleBadClpbrdAppFlags(LPWSTR lpModName, PBADCLPBRDAPP pBadClpbrdApp)
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UniString;
    HKEY hKey = 0;
    ULONG ul, ulcnt, ulcbuf, ulrc = FALSE;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = NULL;
    LPWSTR UniBuff;
    PWCHAR pwch;
    WCHAR  *pbadappNameValue[] = { COMPAT_OPENCLIPBOARDRETRIES,
                                                   COMPAT_OPENCLIPBOARDDELAYINMILLISECS,
                                   COMPAT_CLIPBOARDFLAGS,
                                   NULL
                                 };


    // Get the executable name only, no path.
    pwch = wcsrchr(lpModName, L'\\');
    if (pwch) {
        pwch++;
    } else {
        pwch = lpModName;
    }

    // Get the buffers we need
    ul = sizeof(TERMSRV_COMPAT_APP) + (wcslen(pwch) + 1)*sizeof(WCHAR);

    UniBuff = RtlAllocateHeap(RtlProcessHeap(), 0, ul);

    ulcbuf = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG);

    pKeyValueInfo = RtlAllocateHeap(RtlProcessHeap(), 0, ulcbuf);

    if (UniBuff && pKeyValueInfo) {
        wcscpy(UniBuff, TERMSRV_COMPAT_APP);
        wcscat(UniBuff, pwch);

        // Remove the extension
        if (pwch = wcsrchr(UniBuff, L'.')) {
            *pwch = '\0';
        }

        RtlInitUnicodeString(&UniString,
                             UniBuff
                            );

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(NtStatus)) {

            ulrc = TRUE;
            for (ulcnt = 0; pbadappNameValue[ulcnt]; ulcnt++) {

                RtlInitUnicodeString(&UniString, pbadappNameValue[ulcnt]);
                NtStatus = NtQueryValueKey(hKey,
                                           &UniString,
                                           KeyValuePartialInformation,
                                           pKeyValueInfo,
                                           ulcbuf,
                                           &ul);

                if (NT_SUCCESS(NtStatus) &&
                    (REG_DWORD == pKeyValueInfo->Type)) {
                    switch (ulcnt) {
                        case 0:
                            pBadClpbrdApp->BadClpbrdAppEmptyRetries =
                                *(PULONG)pKeyValueInfo->Data;
                            break;
                        case 1:
                            pBadClpbrdApp->BadClpbrdAppEmptyDelay =
                                    *(PULONG)pKeyValueInfo->Data;
                            break;
                        case 2:
                            pBadClpbrdApp->BadClpbrdAppFlags =
                                *(PULONG)pKeyValueInfo->Data;
                            break;
                    }
                } else {
                    switch (ulcnt) {
                        case 0:
                            pBadClpbrdApp->BadClpbrdAppEmptyRetries = 0;
                            break;
                        case 1:
                            pBadClpbrdApp->BadClpbrdAppEmptyDelay = 50;
                            break;
                        case 2:
                            pBadClpbrdApp->BadClpbrdAppFlags = 0;
                            break;
                    }
                }
            }
            NtClose(hKey);
        }
    }

    // Free the memory we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    if (UniBuff) {
        memset(UniBuff, 0, UniString.MaximumLength);
        RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
    }
    if (pKeyValueInfo) {
        memset(pKeyValueInfo, 0, ulcbuf);
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValueInfo );
    }

    return(ulrc);
}

//*****************************************************************************
// CtxGetBadClpbrdAppFlags -
//
//    Gets the Citrix BadClpbrdApp and compatibility flags for the
//    current task.
//
//    Parameters:
//      LPWSTR  lpModName      (IN)  - Image name to look up in registry
//      PBADCLPBRDAPP pBadClpbrdApp        (OUT) - Structure to used to return flags
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    The BADCLPBRDAPP structure is defined in:
//           base\client\citrix\compatfl.h and user\inc\user.h.
//
//*****************************************************************************

BOOL CtxGetBadClpbrdAppFlags(OUT PBADCLPBRDAPP pBadClpbrdApp)
{
    WCHAR   ModName[MAX_PATH+1];
    DWORD dwAppType = 0;

    if (!GetAppTypeAndModName(&dwAppType, ModName, sizeof(ModName))) {
        return (FALSE);
    }

    // Get the flags
    return (CtxGetModuleBadClpbrdAppFlags(ModName, pBadClpbrdApp));
}


//*****************************************************************************
//
// Same as GetTermsrCompatFlags(), except that the first argument is name
// of an executable module with possible path and extention.
// This func will strip path and extension, and then call GetTermsrCompatFlags()
// with just the module name
//
//*****************************************************************************
ULONG GetTermsrCompatFlagsEx(LPWSTR lpModName,
                           LPDWORD pdwCompatFlags,
                           TERMSRV_COMPATIBILITY_CLASS CompatType)
{
    // drop the path and extension from the module name
    WCHAR   *p, *e;
    int     size;

    size = wcslen(lpModName);

    p = &lpModName[size-1];     // move to to the end of string

    // walk back to the start, break if you hit a back-slash
    while (p != lpModName)
    {
        if ( *p == TEXT('\\') )
        {   ++p; //move past the back-slash
            break;
        }
        --p;
    }

    // p is at the begining of the name of an executable.

    // get rid of the extension, set end pointer e to the start of str
    // move forward until you hit '.'
    e = p;
    while (*e)
    {
        if (*e == TEXT('.') )

        {
            *e = TEXT('\0');  // terminate at "."
            break;
        }
        e++;
    }

    // 'p' is the module/executable name, no path, and no extension.
    return ( GetTermsrCompatFlags( p,  pdwCompatFlags, CompatType) );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\inipath.c ===
/*************************************************************************
*
* inipath.c
*
* Routines to manage per user mapping of Ini file paths
*
* copyright notice: Copyright 1998, Microsoft Corporation
*
*
*
*************************************************************************/
#include "precomp.h"
#pragma hdrstop


//*** Instance data
ULONG ulWinDirFlags = 0;            // State of user's Windows directory

#define WINDIR_FLAGS_VALID          0x01    // The flags are initialized
#define WINDIR_USER_WINDIR_OK       0x02    // User's Windows dir exists

#define WINDOWS_DIR L"WINDOWS"
UNICODE_STRING WindowsDir = { sizeof(WINDOWS_DIR) - sizeof(UNICODE_NULL) , sizeof(WINDOWS_DIR) + sizeof(UNICODE_NULL), WINDOWS_DIR };

WCHAR gpwszDefaultUserName[MAX_PATH+1];

/******************************************************************************
 *
 *  TermsrvPerUserWinDirMapping
 *
 *
/******************************************************************************/
BOOLEAN TermsrvPerUserWinDirMapping() {

#ifdef PERUSERBYREQUEST
    PRTL_USER_PROCESS_PARAMETERS pUserParam;
    PWCHAR  pwch, pwchext;
    WCHAR   pwcAppName[MAX_PATH+1];
    ULONG ulCompat=0, ulAppType=0;

    // Get the path of the executable name
    pUserParam = NtCurrentPeb()->ProcessParameters;

    // Get the executable name, if there's no \ just use the name as it is
    pwch = wcsrchr(pUserParam->ImagePathName.Buffer, L'\\');
    if (pwch) {
        pwch++;
    } else {
        pwch = pUserParam->ImagePathName.Buffer;
    }
    wcscpy(pwcAppName, pwch);
    pwch = pwcAppName;

    if (_wcsicmp(pwch, L"ntvdm.exe")) {

        // If not a 16 bit app
        // Check if we should return the per user windows dir for this app
        GetCtxAppCompatFlags(&ulCompat, &ulAppType);
        if (!(ulCompat & TERMSRV_COMPAT_PERUSERWINDIR) ||
            !(ulCompat & ulAppType)) {
            //
            // Let the standard GetWindowsDirectory call return the actual path
            //
            return FALSE;

         }
    }

    return TRUE;
#else
    ULONG ulCompat=0, ulAppType = 0;


    // Check if we should return the system windows dir for this app
    GetCtxAppCompatFlags(&ulCompat, &ulAppType);
    if ((ulCompat & CITRIX_COMPAT_SYSWINDIR) &&
        (ulCompat & ulAppType)) {
        return FALSE;
    } else {
        return TRUE;
    }

#endif
}

/******************************************************************************
 *
 *  TermsrvBuildIniFileName
 *
 *  Build the INI file name based on the INIPATH or HOMEPATH (if no INIPATH)
 *
 *  ENTRY:
 *     pFQName (output)
 *       Buffer to place fully qualified INI file name
 *     pBaseFileName (input)
 *       pointer to buffer containing base INI file name
 *
 *  EXIT:
 *      NTSTATUS
 *
 *****************************************************************************/
NTSTATUS
TermsrvBuildIniFileName(
    OUT PUNICODE_STRING pFQName,
    IN PUNICODE_STRING pBaseFileName
    )
{
    NTSTATUS Status;
    USHORT   indexLastWChar;
    ULONG ulCompat, ulAppType=0;


//Added By SalimC
    /*
     * If in install mode, use the base windows directory
     * like a stock NT.
     */
    if( IsSystemLUID() || TermsrvAppInstallMode() ) {

        return( STATUS_UNSUCCESSFUL );
    }
//END SalimC

    if (!TermsrvPerUserWinDirMapping()) {
        return( STATUS_UNSUCCESSFUL );
    }
#if 0
    GetCtxAppCompatFlags(&ulCompat, &ulAppType);
    if (((ulCompat & TERMSRV_COMPAT_SYSWINDIR) && (ulCompat & ulAppType))) {

        return STATUS_UNSUCCESSFUL;

    }
#endif

    Status = GetPerUserWindowsDirectory( pFQName );
    if ( NT_SUCCESS( Status ) ) {
       /*
        * Add a '\' if one's not already there
        */
       if ( indexLastWChar = pFQName->Length / sizeof( WCHAR ) ) {
          if ( pFQName->Buffer[--indexLastWChar] != L'\\' ) {
             Status = RtlAppendUnicodeToString( pFQName, L"\\" );
          }
       }

       /*
        * Append the base file name to the fully qualified directory name
        */
       if ( NT_SUCCESS( Status ) ) {
           Status = RtlAppendUnicodeStringToString( pFQName, pBaseFileName );
       }
    }

    return( Status );
}

/******************************************************************************
 *
 *  GetPerUserWindowsDirectory
 *
 *  Get the user's INI file directory
 *
 *  ENTRY:
 *     pFQName (output)
 *       Buffer to place fully qualified INI file name
 *
 *  EXIT:
 *      NTSTATUS
 *
 *****************************************************************************/
NTSTATUS
GetPerUserWindowsDirectory(
    OUT PUNICODE_STRING pFQName
    )
{
    NTSTATUS Status;
    int      indexLastWChar;
    USHORT   Length;
#if 0 //Bug fix #340691: Inherit the security
    PSECURITY_ATTRIBUTES psa = NULL;
#endif //Bug fix #340691: Inherit the security
    UNICODE_STRING UserProfilePath;
    WCHAR*   pwszFQProfileName;
#if DBG
    char pszFile[MAX_PATH+1];
#endif

    UNICODE_STRING BaseHomePathVariableName, BaseHomeDriveVariableName;

    /*
     * If in install mode, use the base windows directory
     * like a stock NT.
     */
    if( IsSystemLUID() || TermsrvAppInstallMode() ) {
        //Status = GetEnvPath( pFQName, NULL, &BaseWindowsDirectory );
        return( STATUS_UNSUCCESSFUL );
    }

    /*
     * Check for HOMEDRIVE and HOMEPATH
     */
    RtlInitUnicodeString(&BaseHomeDriveVariableName,L"HOMEDRIVE");
    RtlInitUnicodeString(&BaseHomePathVariableName,L"HOMEPATH");

    if (!NT_SUCCESS(Status = GetEnvPath( pFQName, &BaseHomeDriveVariableName,
                         &BaseHomePathVariableName ))){

        if (Status == STATUS_BUFFER_TOO_SMALL) {

            // Need 2 bytes for the "\" character to cat FQN and WindowsDir
            Length = pFQName->Length + sizeof(WCHAR) + WindowsDir.Length;

#if DBG
            DbgPrint("pFQName->Length = %u        WindowsDir.Length = %u    Length = %u\n",
                        pFQName->Length, WindowsDir.Length, Length);
#endif


            pFQName->Length = Length;
#if DBG
            DbgPrint("\nGetEnvPath return STATUS_BUFFER_TOO_SMALL\n");
#endif
        } else {
#if DBG
            DbgPrint("GetEnvPath failed with Status %lx\n",Status);
#endif

        }

        return Status;
    }

    /*
     * If the user profile is Default User then use the
     * base windows directory.
     */

    if (pwszFQProfileName = wcsrchr( pFQName->Buffer, L'\\' )) {

        if (_wcsnicmp(pwszFQProfileName+1, gpwszDefaultUserName, MAX_PATH+1) == 0) {

            return STATUS_UNSUCCESSFUL;
        }
    }

    /*
    * Check buffer length
    */
    Length = pFQName->Length + sizeof(WCHAR) + WindowsDir.Length;

// take into account the NULL terminator character
    if (pFQName->MaximumLength < Length + 1)  {
      // Need 2 bytes for the NULL terminator
       Length += sizeof(WCHAR);
       pFQName->Length = Length;
       Status = STATUS_BUFFER_TOO_SMALL;
       goto done;
    }


    /*
    * Add a trailing backslash if one's not already there
    */
    if ( indexLastWChar = pFQName->Length / sizeof( WCHAR ) ) {

        if ( pFQName->Buffer[--indexLastWChar] != L'\\' ) {

            if (NT_SUCCESS(RtlAppendUnicodeToString( pFQName, L"\\" ))) {

                /*
                 * Append "WINDOWS" to home dir
                 */
                Status = RtlAppendUnicodeStringToString( pFQName, &WindowsDir );
            }

        } else {

            Status = RtlAppendUnicodeStringToString( pFQName, &WindowsDir );
        }

    }

    if (NT_SUCCESS(Status)) {

       // Check if we've already tried to create the user's windows path
       if (ulWinDirFlags & WINDIR_FLAGS_VALID) {
          if (ulWinDirFlags & WINDIR_USER_WINDIR_OK) {
             goto done;
          } else {
             Status = STATUS_OBJECT_PATH_INVALID;
          }
       }
    }

    if ( NT_SUCCESS(Status) ) {

       WCHAR Buffer[MAX_PATH+1];
       SECURITY_ATTRIBUTES sa;
       BOOL  fDirCreated = FALSE;

       // Mark this process's windows directory flags as valid
       ulWinDirFlags |= WINDIR_FLAGS_VALID;
#if 0 //Bug fix #340691: Inherit the security
       /*
        * Since creating a security descriptor calls LookupAccountName,
        * which is very time consuming, we only do that if we have to
        * create the directory (which should rarely happen anyway).
        */
       if ( CreateDirectoryW( (LPCWSTR)pFQName->Buffer, NULL ) &&
            RemoveDirectoryW( (LPCWSTR)pFQName->Buffer )       &&
            CtxCreateSecurityDescriptor( &sa ) )  {
          psa = &sa;
       }
       /*
        * Create windows directory if it doesn't exist
        */
       if ( !CreateDirectoryW( (LPCWSTR)pFQName->Buffer, psa ) ) {
#endif //Bug fix #340691: Inherit the security
       if ( !CreateDirectoryW( (LPCWSTR)pFQName->Buffer, NULL ) ) {

          if ( (Status = GetLastError()) == ERROR_ALREADY_EXISTS ) {
             Status = STATUS_SUCCESS;
          }

#if DBG
          else {
              wcstombs( pszFile, pFQName->Buffer, sizeof(pszFile) );
              DbgPrint( "KERNEL32: Error (%d) creating dir '%s'\n",
                        Status, pszFile );
          }
#endif
       } else {
           fDirCreated = TRUE;
       }

       if (NT_SUCCESS(Status)) {


          /*
           * Create system directory if it doesn't exist
           * (ignore return code)
           */
          wcscpy( Buffer, pFQName->Buffer );
          wcscat( Buffer, L"\\system" );

          /*
           * If the user's WINDOWS directory already existed but the
           * WINDOWS\SYSTEM directory didn't, we need to create the
           * security descriptor (this scenario is even rarer).
           */
#if 0 //Bug fix #340691: Inherit the security
          if ( !psa && !fDirCreated &&
               CreateDirectoryW( (LPCWSTR)Buffer, NULL ) &&
               RemoveDirectoryW( (LPCWSTR)Buffer )       &&
               CtxCreateSecurityDescriptor( &sa ) )  {
              psa = &sa;
          }


          if ( !CreateDirectoryW( (LPCWSTR)Buffer, psa ) ) {
#endif
          if ( !CreateDirectoryW( (LPCWSTR)Buffer, NULL ) ) {
#if DBG
             if ( GetLastError() != ERROR_ALREADY_EXISTS ) {
                 wcstombs( pszFile, Buffer, sizeof(pszFile) );
                 DbgPrint( "KERNEL32: Error (%d) creating dir '%s'\n",
                           GetLastError(), pszFile );
             }
#endif
          }

          ulWinDirFlags |= WINDIR_USER_WINDIR_OK;
       }
    }


done:
#if 0 //Bug fix #340691: Inherit the security
    if ( psa ) {
       CtxFreeSecurityDescriptor( psa );
    }
#endif //Bug fix #340691: Inherit the security
#if DDBG
    wcstombs( pszFile, pFQName->Buffer, sizeof(pszFile) );
    DbgPrint( "KERNEL32: ctxwindir='%s'\n", Status ? "Error" : pszFile );
#endif

    return( Status );
}

/******************************************************************************
 *
 *  GetEnvPath
 *
 *  Retrieve a fully qualified path derived from a drive and dir env variable
 *
 *  ENTRY:
 *     pFQPath (output)
 *       Buffer to place fully qualified path name
 *     pDriveVariableName (input)
 *       pointer to buffer containing env variable name for drive
 *       if NULL, pPathVariableName is a FQPath and no env vars are used
 *     pPathVariableName (input)
 *       pointer to buffer containing env variable name for dir
 *
 *  EXIT:
 *      NTSTATUS
 *
 *      If NTSTATUS is STATUS_BUFFER_TOO_SMALL, pFQPath->Length will be set
 *      to the buffer size needed.
 *
 *****************************************************************************/
NTSTATUS
GetEnvPath(
    OUT PUNICODE_STRING pFQPath,
    IN  PUNICODE_STRING pDriveVariableName,
    IN  PUNICODE_STRING pPathVariableName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING Path;
    USHORT         Length;

    if ( pDriveVariableName ) {
       /*
        * First let's figure out how big the buffer needs to be
        * We need to do this in case the buffer is too small and we
        * need to return the required size
        */
       RtlInitUnicodeString( &Path, NULL );

       /*
        * See if an env variable is defined for the drive
        */
       Status = RtlQueryEnvironmentVariable_U( NULL, pDriveVariableName,
                                               &Path);
       switch ( Status ) {
          case STATUS_BUFFER_TOO_SMALL:
             Length = Path.Length; // Count how big this the drive spec is
             break;
          case STATUS_SUCCESS:
             Status = STATUS_OBJECT_NAME_NOT_FOUND; // Something's wrong!
          default:
             goto done;
             break;
       }

       /*
        * See if an env variable is defined for the directory
        */
       Path.Length = 0;
       Status = RtlQueryEnvironmentVariable_U( NULL, pPathVariableName,
                                               &Path);
       switch ( Status ) {
          case STATUS_BUFFER_TOO_SMALL:
             Length += Path.Length; // Count how big this the dir spec is
             break;
          case STATUS_SUCCESS:
             Status = STATUS_OBJECT_NAME_NOT_FOUND; // Something's wrong!
          default:
             goto done;
             break;
       }

       /*
        * If the buffer is too small, return the max size needed
        */
       if ( Length + sizeof(WCHAR) > pFQPath->MaximumLength ) {
          Status = STATUS_BUFFER_TOO_SMALL;
          pFQPath->Length = Length + sizeof(WCHAR); // return size
          goto done;
       }

       /*
        * Get the env variable for the drive - should work if we got this far
        */
       if ( Status = RtlQueryEnvironmentVariable_U( NULL, pDriveVariableName,
                                                    pFQPath) ) {
          goto done;
       }

       /*
        * Setup a receive buffer that points to the proper spot in pFQPath
        */
       Length = pFQPath->Length; // Save the drive length
       Path.Length = 0;
       Path.MaximumLength = pFQPath->MaximumLength - Length;
       (ULONG_PTR)Path.Buffer = (ULONG_PTR)pFQPath->Buffer + (ULONG)Length;

       /*
        * Get the env variable for the directory - should work if we got this far
        * Then append it to the end of the drive spec
        */
       if ( Status = RtlQueryEnvironmentVariable_U( NULL, pPathVariableName,
                                                    &Path) ) {
          goto done;
       }

       /*
        * Fix up the structure and we're done
        */
       pFQPath->Length = Path.Length + Length;

    } else {

       /*
        * pPathVariableName is really the FQ directory name
        */
       if ( (pPathVariableName->Length + sizeof(WCHAR)) > pFQPath->MaximumLength ) {
          Status = STATUS_BUFFER_TOO_SMALL;
          pFQPath->Length = pPathVariableName->Length + sizeof(WCHAR); // return size
       } else {
          RtlCopyUnicodeString( pFQPath, pPathVariableName );
       }
    }

done:
    return( Status );
}

/******************************************************************************
 *
 *  TermsrvConvertSysRootToUserDir
 *
 *  People who use INI files should never have to fully qualify them, but some
 *  people do anyway.  What's more, some people do it wrong.  For example,
 *  Microsoft PowerPoint 4.0 will call GetSystemDir (not GetWindowsDir) and
 *  will strip off "\system" to build a fully qualified path.
 *
 *  ENTRY:
 *     pFQPath (input/output)
 *       Buffer containing fully qualified path name
 *
 *  EXIT:
 *      NTSTATUS
 *
 *      If NTSTATUS is not STATUS_SUCCESS, the directory was not converted
 *
 *****************************************************************************/
NTSTATUS
TermsrvConvertSysRootToUserDir(
    OUT PUNICODE_STRING pFQPath,
    IN PUNICODE_STRING BaseWindowsDirectory
    )
{
    NTSTATUS       Status = STATUS_UNSUCCESSFUL;
    PWSTR          p;
    INT_PTR        c;
    WCHAR          buffer[MAX_PATH+1];
    UNICODE_STRING BaseFileName;
#if DDBG
    char           pszFile[MAX_PATH+1];
#endif

     ULONG ulCompat, ulAppType=0;

    /*
     * If in install mode, use the base windows directory
     * like a stock NT.
     */
    if( IsSystemLUID() || TermsrvAppInstallMode() ) {
        goto done;
    }


#if 0
    GetCtxAppCompatFlags(&ulCompat, &ulAppType);
    if (((ulCompat & TERMSRV_COMPAT_SYSWINDIR) && (ulCompat & ulAppType))) {
        goto done;
    }
#endif
    if (!TermsrvPerUserWinDirMapping()) {
        goto done;
    }


    /*
     * Check for NULL pointers
     */
    if ( !pFQPath || !pFQPath->Buffer ) {
#if DBG
        DbgPrint( "KERNEL32: Bogus ini path\n" );
#endif
        goto done;
    }

    /*
     * Validate and isolate the path
     */
    if ( !(p = wcsrchr( pFQPath->Buffer, L'\\' ) ) ) {
#if DBG
       DbgPrint( "KERNEL32: No backslash in ini path\n" );
#endif
       goto done;
    }
    c = (INT_PTR)((ULONG_PTR)p - (ULONG_PTR)pFQPath->Buffer);

#if DDBG
    wcstombs( pszFile, BaseWindowsDirectory->Buffer, sizeof(pszFile) );
    DbgPrint( "KERNEL32: c(%d) c2(%d) BaseWinDir: '%s'\n",
              c, (int)BaseWindowsDirectory->Length, pszFile );
    wcstombs( pszFile, p, sizeof(pszFile) );
    DbgPrint( "KERNEL32:  BaseFileName: '%s'\n", pszFile );
#endif

    if ( c != (INT_PTR)BaseWindowsDirectory->Length ) {
#if DDBG
       DbgPrint( "KERNEL32: Path length diff from BaseWinDir length\n" );
#endif
       goto done;
    }

    /*
     * See if the path is the same as the base windows directory
     */
    c /= sizeof(WCHAR);
    if ( _wcsnicmp( BaseWindowsDirectory->Buffer, pFQPath->Buffer, (size_t)c ) ) {
#if DDBG
        DbgPrint( "KERNEL32: Path diff from BaseWinDir\n" );
#endif
        goto done;
    }

    /*
     * Use the user's directory instead
     */
    wcscpy( buffer, ++p );
    RtlInitUnicodeString( &BaseFileName, buffer );
    Status = TermsrvBuildIniFileName( pFQPath, &BaseFileName );

done:

#if DDBG
    wcstombs( pszFile, pFQPath->Buffer, sizeof(pszFile) );
    DbgPrint( "KERNEL32: Exit(%x) ConvertSystemRootToUserDir: '%s'\n",
              Status, pszFile );
#endif

    return( Status );
}

/******************************************************************************
 *
 *  CtxCreateSecurityDescriptor
 *
 *  This routine will create a security descriptor based on the specified
 *  generic flags.  If this function succeeds, the caller needs to call
 *  CtxFreeSecurityDescriptor() when it is done using the descriptor.
 *
 *  ENTRY:
 *     psa (output)
 *       Pointer to uninitialized security attributes structure
 *
 *  EXIT:
 *      TRUE if successful, FALSE if error occurred
 *
 *      (GetLastError() can be called to retrieve error code)
 *
 *****************************************************************************/
#if 0 //Bug fix #340691: Inherit the security
BOOL CtxCreateSecurityDescriptor( PSECURITY_ATTRIBUTES psa )
{
    BOOL  fSuccess = FALSE;
    NTSTATUS Status;
    PSID  psidAdmin, psidUser;
    UINT  cb = sizeof( SECURITY_DESCRIPTOR ) + 2 * sizeof(PSID);
    UINT  cbAcl = sizeof(ACL);
    PACL  pAcl;
    PSID *ppsidAdmin, *ppsidUser;
    SID_IDENTIFIER_AUTHORITY gSystemSidAuthority = SECURITY_NT_AUTHORITY;
    HANDLE  hUserToken;
    PTOKEN_USER pTokenUser = NULL;
    DWORD   cbNeeded;

    /*
     * Initialize pointers to dynamic memory blocks
     */
    psa->lpSecurityDescriptor = NULL;
    psidAdmin = NULL;
    psidUser  = NULL;

    /*
     * Get the SID of the bult-in Administrators group
     */
    Status = RtlAllocateAndInitializeSid(
                     &gSystemSidAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,0,0,0,0,0,
                     &psidAdmin);
    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("KERNEL32: Couldn't allocate Administrators SID (0x%x)\n", Status );
#endif
        goto done;
    }

    /*
     * Get the SID for the current user from their process token
     */
    Status = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &hUserToken);
    if (Status == STATUS_NO_TOKEN) {
        Status = NtOpenProcessToken(
                         NtCurrentProcess(),
                         TOKEN_QUERY,
                         &hUserToken);
    }
    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("KERNEL32: Couldn't access process' token (0x%x)\n", Status );
#endif
        RtlFreeHeap( RtlProcessHeap(), 0, psidAdmin );
        goto done;
    }
    Status =  NtQueryInformationToken(
                      hUserToken,
                      TokenUser,
                      NULL,
                      0,
                      &cbNeeded );
    if (Status == STATUS_BUFFER_TOO_SMALL) {
        pTokenUser = (PTOKEN_USER)RtlAllocateHeap( RtlProcessHeap(), 0, cbNeeded );
        if (pTokenUser != NULL) {
            Status =  NtQueryInformationToken(
                              hUserToken,
                              TokenUser,
                              (LPVOID)pTokenUser,
                              cbNeeded,
                              &cbNeeded );
            if (NT_SUCCESS(Status)) {
                /*
                 * Make a copy of the user's SID
                 */
                psidUser = RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthSid(pTokenUser->User.Sid) );
                if (psidUser != NULL) {
                    Status = RtlCopySid( RtlLengthSid(pTokenUser->User.Sid), psidUser, pTokenUser->User.Sid );
                } else {
                    Status = STATUS_NO_MEMORY;
                }
            }
        } else {
            Status = STATUS_NO_MEMORY;
        }
    }

    if (pTokenUser != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, pTokenUser );
    }
    NtClose(hUserToken);

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("KERNEL32: Couldn't query user's token (0x%x)\n", Status );
#endif
        RtlFreeHeap( RtlProcessHeap(), 0, psidAdmin );
        if (psidUser != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, psidUser );
        }
        goto done;
    }

    /*
     * Figure out how much memory we need to allocate for the SD
     */
    cbAcl += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid( psidUser ) - sizeof(DWORD);
    cbAcl += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid( psidAdmin ) - sizeof(DWORD);

    /*
     * Allocate all the memory we need for the security descriptor
     */
    if ( !(psa->lpSecurityDescriptor =
             (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb + cbAcl ) ) ) {
#if DBG
        DbgPrint("KERNEL32: No memory to create security descriptor (%d)\n",
                  cb + cbAcl);
#endif
        goto done;
    }

    /*
     * Divvy up our memory block to include SIDs and ACLs
     */
    ppsidAdmin = (PSID*)((ULONG_PTR)psa->lpSecurityDescriptor + sizeof(SECURITY_DESCRIPTOR));
    ppsidUser  = (PSID*)((ULONG_PTR)ppsidAdmin + sizeof(PSID));
    pAcl = (PACL)((ULONG_PTR)ppsidUser + sizeof(PSID));
    /*
     * Save the SIDs - the SIDs must not be freed until we're done
     * using the security descriptor
     */
    *ppsidAdmin = psidAdmin;
    *ppsidUser  = psidUser;

    /*
     * Initialize the rest of the security attributes structure
     */
    psa->nLength = sizeof( SECURITY_ATTRIBUTES );
    psa->bInheritHandle = FALSE;

    /*
     * Initialize the security descriptor
     */
    if ( Status = RtlCreateSecurityDescriptor(
                                            psa->lpSecurityDescriptor,
                                            SECURITY_DESCRIPTOR_REVISION ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) initializing security descriptor\n",
                  Status );
#endif
        goto done;
    }

    /*
     * Set the owner
     */
    if ( Status = RtlSetOwnerSecurityDescriptor( psa->lpSecurityDescriptor,
                                                 NULL, FALSE ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) setting security descriptor owner\n",
                  Status );
#endif
        goto done;
    }

    /*
     * Set the group
     */
    if ( Status = RtlSetGroupSecurityDescriptor( psa->lpSecurityDescriptor,
                                      psidAdmin, FALSE ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) setting security descriptor owner\n",
                  Status );
#endif
        goto done;
    }

    /*
     * Initialize the ACL
     */
    if ( Status = RtlCreateAcl( pAcl, cbAcl, ACL_REVISION ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) initializing ACL\n",
                  Status );
#endif
        goto done;
    }

    /*
     * Add user ACE
     */
    if ( Status = CtxAddAccessAllowedAce( pAcl, ACL_REVISION, GENERIC_ALL, psidUser, 0 ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) adding user ACE\n", Status );
#endif
        goto done;
    }

    /*
     * Add Administrators ACE
     */
    if ( Status = CtxAddAccessAllowedAce( pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin, 1 ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) adding admin ACE\n", Status );
#endif
        goto done;
    }

    /*
     * Set the discretionary ACL
     */
    if ( Status = RtlSetDaclSecurityDescriptor( psa->lpSecurityDescriptor,
                                                TRUE, pAcl, FALSE ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) setting security descriptor owner\n",
                  Status );
#endif
        goto done;
    }

    fSuccess = TRUE;

done:
    if ( !fSuccess && psa->lpSecurityDescriptor ) {
       CtxFreeSecurityDescriptor( psa );
    }
    return( fSuccess );
}

/******************************************************************************
 *
 *  CtxFreeSecurityDescriptor
 *
 *  This routine will free resources allocated in a corresponding
 *  CtxCreateSecurityDescriptor() call.
 *
 *  ENTRY:
 *     psa (input)
 *       Pointer to security attributes
 *
 *  EXIT:
 *      TRUE if successful, FALSE if error occurred
 *
 *      (GetLastError() can be called to retrieve error code)
 *
 *****************************************************************************/
BOOL CtxFreeSecurityDescriptor( PSECURITY_ATTRIBUTES psa )
{
    BOOL fSuccess = TRUE;
    PSID *ppsidAdmin, *ppsidUser;

    if ( psa->lpSecurityDescriptor ) {
        ppsidAdmin = (PSID*)((ULONG_PTR)psa->lpSecurityDescriptor + sizeof(SECURITY_DESCRIPTOR));
        ppsidUser  = (PSID*)((ULONG_PTR)ppsidAdmin + sizeof(PSID));
       if ( *ppsidUser ) {
           CtxFreeSID( *ppsidUser );
       }
       if ( *ppsidAdmin ) {
           CtxFreeSID( *ppsidAdmin );
       }
       fSuccess = !LocalFree( psa->lpSecurityDescriptor );
#if DDBG
       DbgPrint( "KERNEL32: fSuccess(%d) freeing security descriptor (%08X)\n",
                  fSuccess, psa->lpSecurityDescriptor );
#endif
    }

    return( fSuccess );
}

NTSTATUS
CtxAddAccessAllowedAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN DWORD index
    )
{
    NTSTATUS Status;
    ACE_HEADER *pHeader;

    /*
     * First add the ACL
     */
    if ( !(Status = RtlAddAccessAllowedAce( Acl, AceRevision,
                                            AccessMask, Sid ) ) ) {
        /*
         * Get the ACE
         */
        if ( Status = RtlGetAce( Acl, index, &pHeader ) ) {
#if DBG
            DbgPrint( "KERNEL32: Error (%X) from RtlGetAce\n", Status );
#endif
            goto done;
        }

        /*
         * Now set the inheritence bits
         */
        pHeader->AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    }

done:
    return( Status );
}
#endif //Bug fix #340691: Inherit the security

// from \nt\private\windows\gina\userenv\globals.h
#define PROFILE_LIST_PATH            L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"
#define DEFAULT_USER_PROFILE         L"DefaultUserProfile"
#define DEFAULT_USER                 L"Default User"

BOOL GetDefaultUserProfileName(
    LPWSTR lpProfileDir,
    LPDWORD lpcchSize
    )
{
    WCHAR*   pwszProfileName;
    BYTE     pKeyValueInfo[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+(MAX_PATH+1)*sizeof(WCHAR)];
    ULONG    ulSize;
    DWORD    dwLength;
    BOOL     bRetVal = FALSE;
    HKEY     hKey;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UnicodeString;


    //
    // Query for the Default User profile name
    //

    RtlInitUnicodeString(&UnicodeString, PROFILE_LIST_PATH);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);


    Status = NtOpenKey( &hKey,
                        KEY_READ,
                        &ObjectAttributes );

    //lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
    //                        0, KEY_READ, &hKey);

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("TSAppCmp:GetDefaultUserProfileName:  Failed to open profile list key with 0x%x.",Status);
#endif
        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }

    //lResult = RegQueryValueExW(hKey, DEFAULT_USER_PROFILE, NULL, &dwType,
    //                           (LPBYTE) wszProfileName, &dwSize);

    RtlInitUnicodeString(&UnicodeString, DEFAULT_USER_PROFILE);

    Status = NtQueryValueKey( hKey,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              pKeyValueInfo,
                              sizeof(pKeyValueInfo),
                              &ulSize);

    pwszProfileName = (WCHAR*)(((PKEY_VALUE_PARTIAL_INFORMATION)pKeyValueInfo)->Data);

    if (!NT_SUCCESS(Status)) {
        lstrcpy (pwszProfileName, DEFAULT_USER);
    }

    NtClose(hKey);


    //
    // Save the result if possible
    dwLength = lstrlen(pwszProfileName) + 1;

    if (lpProfileDir) {

        if (*lpcchSize >= dwLength) {
            lstrcpy (lpProfileDir, pwszProfileName);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }

    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
    }


    *lpcchSize = dwLength;

    return bRetVal;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\msihooks.cpp ===
/****************************************************************************************
* MSI will call these APIs to ask TS to propogate changes from .Default to the TS hive. 
*                                                                                       
* NTSTATUS TermServPrepareAppInstallDueMSI()                                            
*
* NTSTATUS TermServProcessAppIntallDueMSI( BOOLEAN cleanup )                            
* 
* These API need not be called in the same boot cycles, many boot cycles could
* happen in between.
*
* Copyright (C) 1997-1999 Microsoft Corp.
****************************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <stdio.h>
#include <windows.h>
#include <winuser.h>
#include <stdlib.h>
#include <tsappcmp.h>
#include <stdio.h>
#include <fcntl.h>

#include "KeyNode.h"
#include "ValInfo.h"

// real externs!
extern "C" {
void TermsrvLogRegInstallTime(void);
}

extern "C" {
BOOL HKeyExistsInOmissionList(HKEY hKeyToCheck);
}

extern "C" {
BOOL RegPathExistsInOmissionList(PWCHAR pwchKeyToCheck);
}

// forward declaration
extern        NTSTATUS DeleteReferenceHive(WCHAR *);
extern        NTSTATUS CreateReferenceHive( WCHAR *, WCHAR *);
extern        NTSTATUS DeltaDeleteKeys(WCHAR *, WCHAR *, WCHAR *);
extern        NTSTATUS DeltaUpdateKeys(WCHAR *, WCHAR *, WCHAR *);

ULONG   g_length_TERMSRV_USERREGISTRY_DEFAULT;
ULONG   g_length_TERMSRV_INSTALL;
WCHAR   g_debugFileName[MAX_PATH];
FILE    *g_debugFilePointer=NULL;
BOOLEAN g_debugIO = FALSE;
BOOLEAN KeyNode::debug=FALSE; // init the static

#define TERMSRV_USERREGISTRY_DEFAULT TEXT("\\Registry\\USER\\.Default")

// This is for debug I/O, output looks better with it.
void    Indent( ULONG indent)
{

    for ( ULONG i = 1; i <indent ; i++ )
    {
        fwprintf( g_debugFilePointer, L"  ");
    }
}

// a key name is written to the log file based on the contect of pBasicInfo
void DebugKeyStamp( NTSTATUS status, KeyBasicInfo *pBasicInfo, int indent , WCHAR *pComments=L"" )
{
    Indent(indent);
    fwprintf( g_debugFilePointer,L"%ws, status=%lx, %ws\n",pBasicInfo->NameSz(), status , pComments);
    fflush( g_debugFilePointer );                             
    DbgPrint("%ws\n",pBasicInfo->NameSz());
}

// a debug stamp is written to the log file, including the line number where error happened
void DebugErrorStamp(NTSTATUS status , int lineNumber, ValueFullInfo    *pValue=NULL)
{
    fwprintf( g_debugFilePointer, 
        L"ERROR ?!? status = %lx, linenumber:%d\n", status, lineNumber);
    if (pValue)
    {
        pValue->Print(g_debugFilePointer);
    }
    fflush(g_debugFilePointer); 
}

#define  KEY_IGNORED        L"[key was ignored]"
#define  NO_KEY_HANDLE      L"[No handle, key ignored]"

void DebugInfo(NTSTATUS status , int lineNumber, KeyNode *pKey, WCHAR *comment)
{
	if(g_debugIO && g_debugFilePointer)
	{
		fwprintf( g_debugFilePointer, 
			L"ERROR ?!? status = %lx, linenumber:%d, KeyNode name=%ws, %ws\n", status, 
			lineNumber , pKey->Name() , comment);
		fflush(g_debugFilePointer); 
	}
}

// use this func to track the status value which is used to bail out in 
// case of an error.
// this is only used in teh debug build, see below
BOOL    NT_SUCCESS_OR_ERROR_STAMP( NTSTATUS    status,  ULONG   lineNumber) 
{
    if ( g_debugIO )
    {   
        if ( ( (ULONG)status) >=0xC0000000 )
        {
            DebugErrorStamp( status, lineNumber );
        }
    }

    return ( (NTSTATUS)(status) >= 0 );
}

#ifdef DBG
#define NT_SUCCESS_EX(Status) NT_SUCCESS_OR_ERROR_STAMP( (Status), __LINE__ )
#define DEBUG_INFO(Status, pKey, comment )   DebugInfo( Status, __LINE__ , pKey , comment)
#else
#define NT_SUCCESS_EX(Status) NT_SUCCESS(Status)
#define DEBUG_INFO(Stats, pKey , comment)    
#endif

/***************************************************************************
*
*  All three branch-walker functions use this method to alter the status code, and
*  if necessary, log an error message to the log file
*
***************************************************************************/
NTSTATUS AlterStatus( NTSTATUS status , int lineNumber )
{
    switch( status )
    {
    case STATUS_ACCESS_DENIED:
        // this should never happen since we run in the system context
        if ( g_debugIO )
        {
            DebugErrorStamp( status, lineNumber );
        }
        status = STATUS_SUCCESS;
        break;

    case STATUS_SUCCESS:
        break;

    case STATUS_NO_MORE_ENTRIES:
        status = STATUS_SUCCESS;
        break;

    default:
        if ( g_debugIO )
        {
            DebugErrorStamp( status, lineNumber );
        }
        break;


    }
    return status;
}

/******************************************************************************
*
* Based on a special reg key/value init the debug flags and pointers which are
* used to log debug info into a log file. When called with start=TRUE, the
* relevant data structs are initialized. When called with start=FALSE, the log
* file is closed.
*
******************************************************************************/
void InitDebug( BOOLEAN start)
{
    if ( start )
    {
        KeyNode tsHiveNode (NULL, KEY_READ, TERMSRV_INSTALL );
    
        if ( NT_SUCCESS( tsHiveNode.Open() ) )
        {
            ValuePartialInfo    debugValue( &tsHiveNode );
            if ( NT_SUCCESS( debugValue.Status() ) && NT_SUCCESS( debugValue.Query(L"TS_MSI_DEBUG") ) )
            {
                g_debugIO = TRUE;
                KeyNode::debug=TRUE;
                for (ULONG i =0; i < debugValue.Ptr()->DataLength/sizeof(WCHAR); i++)
                {
                    g_debugFileName[i] = ((WCHAR*)(debugValue.Ptr()->Data))[i];
                }
                g_debugFileName[i] = L'\0';
    
                g_debugFilePointer = _wfopen( g_debugFileName, L"a+" );
                fwprintf( g_debugFilePointer, L"----\n");
            }
        }
    }
    else
    {
        if ( g_debugFilePointer )
        {
            fclose(g_debugFilePointer);
        }
    }
}

/***************************************************************************
*
* Function:
*  TermServPrepareAppInstallDueMSI()
*
* Description:
*  MSI service calls this function prior to starting an installation cycle.
*  When called, this function blows away the RefHive (in case it was around 
*  with some stale data...), and then it creates a fresh copy of 
*  .Default\Software as the new RefHive.
*
* Return:
*   NTSTATUS
*
***************************************************************************/
NTSTATUS TermServPrepareAppInstallDueMSI()
{
    NTSTATUS    status = STATUS_SUCCESS;

    WCHAR   sourceHive[MAX_PATH];
    WCHAR   referenceHive[MAX_PATH];
    WCHAR   destinationHive[MAX_PATH];

    wcscpy(sourceHive,  TERMSRV_USERREGISTRY_DEFAULT );
    wcscat(sourceHive, L"\\Software");
    g_length_TERMSRV_USERREGISTRY_DEFAULT = wcslen( TERMSRV_USERREGISTRY_DEFAULT );

    wcscpy(referenceHive, TERMSRV_INSTALL );
    wcscat(referenceHive, L"\\RefHive");
    g_length_TERMSRV_INSTALL = wcslen( TERMSRV_INSTALL );

    InitDebug( TRUE );

    if ( g_debugIO)
    {
        fwprintf( g_debugFilePointer,L"In %ws\n",
                  L"TermServPrepareAppInstallDueMSI");
        fflush( g_debugFilePointer );
    }

    // delete the existing hive (if any )
    status = DeleteReferenceHive( referenceHive );

    if ( NT_SUCCESS( status ) )
    {
        // 1-COPY
        // copy all keys under .Default\Software into a special location 
        // under our TS hive, let's call it the RefHive
        status = CreateReferenceHive(sourceHive, referenceHive);

    }

    InitDebug( FALSE );

    return status;
}

/**********************************************************************************
*
* Function:
*  TermServProcessAppInstallDueMSI
* 
* Description:
*  MSI service calls this function after calling TermServPrepareAppInstallDueMSI(), 
*  and after MSI finishing making an installation which updated the .Default 
*  hive (since MSI runs in the system context). 
*  This function will compare the content of .Default\SW to RefHive and then 
*  first it will create all new (missing) keys and values. Then it will 
*  compare any existing keys from .Default\SW with the equivalent RefHive, and
*  if value is different, it will delete the equivalent value from our TS hive
*  and then create a new value identical to what was found in .Default
*
* Return:
*   NTSTATUS
*
**********************************************************************************/
NTSTATUS TermServProcessAppInstallDueMSI( BOOLEAN cleanup)
{
    NTSTATUS    status = STATUS_SUCCESS;
    WCHAR   sourceHive[MAX_PATH];
    WCHAR   referenceHive[MAX_PATH];
    WCHAR   destinationHive[MAX_PATH];

    wcscpy(sourceHive,  TERMSRV_USERREGISTRY_DEFAULT );
    wcscat(sourceHive, L"\\Software");
    g_length_TERMSRV_USERREGISTRY_DEFAULT = wcslen( TERMSRV_USERREGISTRY_DEFAULT );

    wcscpy(referenceHive, TERMSRV_INSTALL );
    wcscat(referenceHive, L"\\RefHive");
    g_length_TERMSRV_INSTALL = wcslen( TERMSRV_INSTALL );

    wcscpy(destinationHive, TERMSRV_INSTALL );
    wcscat(destinationHive, L"\\Software");

    InitDebug( TRUE );

    if ( g_debugIO)
    {
        fwprintf( g_debugFilePointer,L"In %ws, cleanup=%lx\n",
                  L"TermServProcessAppIntallDueMSI", cleanup);
        fflush( g_debugFilePointer );
    }

    if ( !cleanup )
    {
        // 2-DELETE
        // compare .Dfeault keys to the equivalent keys in RefHive. If keys are
        // missing from .Default, then delete the equivalent keys from our
        // HKLM\...\TS\ hive
         status = DeltaDeleteKeys(sourceHive, referenceHive, destinationHive);
    
        if (NT_SUCCESS( status ) )
        {
            // Steps 3 and 4 are now combined.
            // 3-CREATE
            // compare .Default keys to the equivalent keys in RefHive, if keys are
            // present in .Default that are missing from RefHive, then, add those keys
            // to our HKLM\...\TS hive
            // 4-CHANGE
            // compare keys of .Default to RefHive. Those keys that are newer than 
            // RefHive, then, update the equivalent keys in HKLM\...\TS
        
            status = DeltaUpdateKeys(sourceHive, referenceHive, destinationHive);

            if (NT_SUCCESS( status ))
            {
                // update the time stamp in our hive since we want the standared TS reg key
                // propogation to take place.
                TermsrvLogRegInstallTime();


            }
        }
    }
    else
    {
        // blow away the existing reference hive, 
        status = DeleteReferenceHive( referenceHive ); 
    }

    InitDebug( FALSE );

    return status;
}

/*******************************************************************
*
* Function:
*  EnumerateAndCreateRefHive
*
* Parameters:
*  pSource points to the parent node, the branch we copy 
*  pref points to our RefHive which we are creating as a ref image
*  pBasicInfo is a scratch pad passed around which is used to 
*  extract basic Key information
*  pindextLevel is used to format the debug log output file
*
* Descritption:
*  Create a copy of the .Default\Sofwtare as our RefHive
*
* Return:
*  NTSTATUS
*******************************************************************/
NTSTATUS EnumerateAndCreateRefHive(    
    IN KeyNode      *pSource,
    IN KeyNode      *pRef,
    IN KeyBasicInfo *pBasicInfo,
    IN ULONG        *pIndentLevel
    )
{
    NTSTATUS    status=STATUS_SUCCESS;
    ULONG   ulCount=0;

    UNICODE_STRING  UniString;

    (*pIndentLevel)++;

    while( NT_SUCCESS(status)) 
    {
        ULONG       ultemp;

        status = NtEnumerateKey(    pSource->Key(),
                                    ulCount++,
                                    pBasicInfo->Type() , // keyInformationClass,
                                    pBasicInfo->Ptr(),   // pKeyInfo,
                                    pBasicInfo->Size(),  // keyInfoSize,
                                    &ultemp);

        if (NT_SUCCESS(status))                        
        {
            if ( g_debugIO)
            {
                DebugKeyStamp( status , pBasicInfo, *pIndentLevel );
            }
            
            // open a sub key
            KeyNode SourceSubKey(      pSource, pBasicInfo);

            // create the Ref sub key
            KeyNode RefSubKey( pRef, pBasicInfo);

            if (NT_SUCCESS_EX( status = SourceSubKey.Open() ) )
            {
                if ( NT_SUCCESS_EX( status = RefSubKey.Create() ) ) 
                {
                    NTSTATUS                status3;
                    KEY_FULL_INFORMATION    *ptrInfo;
                    ULONG                   size;
    
                    if (NT_SUCCESS(SourceSubKey.Query( &ptrInfo, &size )))
                    {
                        ValueFullInfo   valueFullInfo( &SourceSubKey );
                        ValueFullInfo   RefValue( &RefSubKey );
    
                        if ( NT_SUCCESS_EX( status = valueFullInfo.Status()) 
                             && NT_SUCCESS_EX(status = RefValue.Status()) )
                        {
                            for (ULONG ulkey = 0; ulkey < ptrInfo->Values; ulkey++) 
                            {
                                status = NtEnumerateValueKey(SourceSubKey.Key(),
                                                 ulkey,
                                                 valueFullInfo.Type(),
                                                 valueFullInfo.Ptr(),
                                                 valueFullInfo.Size(),
                                                 &ultemp);
    
                                if (NT_SUCCESS( status ))
                                {
                                    status = RefValue.Create( &valueFullInfo );
                                    // if status is not good, we bail out, since var "status" is set here
                                }
                                // else, no more entries left, we continue
                            }
                        }
                        // else, out of memory, status is set, we bail out.
                    }
                    // else, no values are present, continue with sub-key enums

                    if (NT_SUCCESS( status ) )
                    {
                        // enumerate sub key down.
                        status = EnumerateAndCreateRefHive(
                                    &SourceSubKey,
                                    &RefSubKey,
                                    pBasicInfo, 
                                    pIndentLevel
                                   );
                    }
                }
                // else, an error, status is set, so we bail out
    
            }// else, open on source has failed, var-status is set, we bail out

            status = AlterStatus( status, __LINE__ );
            // else, an error, status is set, so we bail out
        }
        // else, no more left

    }

    (*pIndentLevel)--;

    return( status );
}

/*******************************************************************
*
* Function:
*  EnumerateAndDeltaDeleteKeys
*
* Parameters:
*  pSource points to a node under .Dfeault
*  pref points to a node under our RefHive 
*  pDestination is a node under our TS\install\SW hive
*  pBasicInfo is a scratch pad passed around which is used to 
*  extract basic Key information
*  pindextLevel is used to format the debug log output file
*
* Descritption:
*  compare source to ref, if keys/values in source are deleted, then
*  delete the equivalent key/value from destination 
*
* Return:
*   NTSTATUS
*******************************************************************/
NTSTATUS EnumerateAndDeltaDeleteKeys( 
        IN KeyNode      *pSource,   // this is under the latest updated .Default\SW hive
        IN KeyNode      *pRef,      // this was a ref-copy of .Default\SW before the update
        IN KeyNode      *pDestination,// this is opur private TS-hive 
        IN KeyBasicInfo *pBasicInfo, 
        IN ULONG        *pIndentLevel)
{
    NTSTATUS    status=STATUS_SUCCESS, st2;
    ULONG   ulCount=0;

    UNICODE_STRING          UniString;
    ULONG                   size;

    (*pIndentLevel)++;

    while (NT_SUCCESS(status)) 
    {
        ULONG       ultemp;

        status = NtEnumerateKey(    pRef->Key(),
                                    ulCount++,
                                    pBasicInfo->Type() , // keyInformationClass,
                                    pBasicInfo->Ptr(),  // pKeyInfo,
                                    pBasicInfo->Size(),  // keyInfoSize,
                                    &ultemp);

        // pBasicInfo was filled up thru NtEnumerateKey() above

        if (NT_SUCCESS(status))                        
        {
            if ( g_debugIO)
            {
                DebugKeyStamp( status , pBasicInfo, *pIndentLevel );
            }
            
            KeyNode RefSubKey(    pRef,   pBasicInfo);
            KeyNode SourceSubKey( pSource,pBasicInfo);
            KeyNode DestinationSubKey( pDestination, pBasicInfo);

            RefSubKey.Open();
            SourceSubKey.Open();
            DestinationSubKey.Open();

            if (NT_SUCCESS( RefSubKey.Status() )  )
            {
                if ( ! NT_SUCCESS( SourceSubKey.Status () ) )
                {
                    // key is missing from the .Default\SW hive, we should delete
                    // the same sub-tree from our TS\Install\SW hive
                    if ( NT_SUCCESS( DestinationSubKey.Status()) )  
                    {
                        if (!HKeyExistsInOmissionList((HKEY)(DestinationSubKey.Key())))
                        {
                            DestinationSubKey.DeleteSubKeys();
                            NTSTATUS st = DestinationSubKey.Delete();

                            if ( g_debugIO)
                            {
                                DebugKeyStamp( st, pBasicInfo, *pIndentLevel );
                            }
                        }                                
                        else
                        {
                            DEBUG_INFO( status, &DestinationSubKey , KEY_IGNORED  );
                        }
                    }
                    // else
                    // As long as the key is missing from
                    // Ts\install\Hive, we will regard this condition as acceptable.
                }
                else
                {
                    // see if any values have been deleted

                    // don't bother unless the destination key exists, otherwise, no values 
                    // will be there to delete...
                    if ( NT_SUCCESS( DestinationSubKey.Status() ) )
                    {

                        KEY_FULL_INFORMATION    *ptrInfo;
                        ULONG   size;
    
                        if (NT_SUCCESS_EX(status = RefSubKey.Query( &ptrInfo, &size )))
                        {
                            // from the key-full-information, create a key-value-full-information     

                            ValueFullInfo   refValueFullInfo( &RefSubKey );
                            ValueFullInfo   sourceValue( &SourceSubKey );
                             
                            // if no allocation errors, then...
                            if ( NT_SUCCESS_EX( status = refValueFullInfo.Status() ) 
                                 && NT_SUCCESS_EX( status = sourceValue.Status() ) )
                            {
                                for (ULONG ulkey = 0; ulkey < ptrInfo->Values; ulkey++) 
                                {
                                    if ( NT_SUCCESS_EX (
                                        status = NtEnumerateValueKey(RefSubKey.Key(),
                                                     ulkey,
                                                     refValueFullInfo.Type(),
                                                     refValueFullInfo.Ptr(),
                                                     refValueFullInfo.Size(),
                                                     &ultemp)  )  )
                                    {
                                                         
                                        // for every value, see if the same value
                                        // exists in the SourceSubKey. If it doesn't
                                        // then delete the corresponding value from 
                                        // TS's hive
        
                                        sourceValue.Query( refValueFullInfo.SzName() );
    
                                        // if .Default\SW is missing a value, then delete the
                                        // corresponding value from our TS\ hive
                                        if ( sourceValue.Status() == STATUS_OBJECT_NAME_NOT_FOUND )
                                        {
                                            ValuePartialInfo    destinationValue( &DestinationSubKey);

                                            if (NT_SUCCESS_EX( status = destinationValue.Status () ) )
                                            {
                                                if (!HKeyExistsInOmissionList((HKEY)(DestinationSubKey.Key())))
                                                {
                                                    destinationValue.Delete( refValueFullInfo.SzName() );
                                                }
                                                else
                                                {
                                                    DEBUG_INFO( status, &DestinationSubKey , KEY_IGNORED  );
                                                }
                                            }
                                            // else, alloc error, status is set
                                        }
                                        else 
                                        {
                                            if ( !NT_SUCCESS_EX ( status = sourceValue.Status() ) )
                                            {
                                                if ( g_debugIO )
                                                {
                                                    DebugErrorStamp(status, __LINE__ );
                                                }
                                                // else, we will bail out here since var-status is set
                                            }
                                            // else, no error 
                                        }
                                        // if-else
                                    }
                                    // else, no more entries

                                } // for loop
                            }
                            // else, we have an error due to no memory, var-status is set
                        }
                        // else, we have an error since we can not get info on this existing ref key, var-status is set
            
                        if ( NT_SUCCESS( status ) )
                        {
                            // we were able to open the source key, which means that
                            // key was not deleted from .default. 
                            // so keep enuming away...
                            status = EnumerateAndDeltaDeleteKeys( 
                                &SourceSubKey,
                                &RefSubKey,
                                &DestinationSubKey,
                                pBasicInfo ,
                                pIndentLevel);
        
                        }
                        //else, status is bad, no point to traverse, we are bailing out
                    }
                    //else, there is no destination sub key to bother with deletion
                }
                // if-else
            }
            // else, ref had no more sub-keys

            status = AlterStatus( status, __LINE__ );
        }
        // else, no more entries
    }

    (*pIndentLevel)--;

    // the typical status would be: STATUS_NO_MORE_ENTRIES 
    return status;
}

/*******************************************************************
*
* Function:
*  EnumerateAndDeltaUpdateKeys
*
* Parameters:
*  pSource points to a node under .Dfeault
*  pref points to a node under our RefHive 
*  pDestination is a node under our TS\install\SW hive
*  pBasicInfo is a scratch pad passed around which is used to 
*  extract basic Key information
*  pindextLevel is used to format the debug log output file
*
* Descritption:
*  compare source to ref, if new keys/values in source have been created
*  then create the equivalent keys in our Ts\Install\SW branch (pDestination)
*  Also, check all values in pSource to values in pRef, if not the same
*  then delete the equivalent pDestination and create a new value
*  identical to value from pSource
*
* Return:
*   NTSTATUS
*******************************************************************/
NTSTATUS EnumerateAndDeltaUpdateKeys( 
        IN KeyNode      *pSource,   // this is under the latest updated .Default\SW hive
        IN KeyNode      *pRef,      // this was a ref-copy of .Default\SW before the update
        IN KeyNode      *pDestination,// this is opur private TS-hive 
        IN KeyBasicInfo *pBasicInfo, 
        IN ULONG        *pIndentLevel)
{
    NTSTATUS    status=STATUS_SUCCESS, st2;
    ULONG   ulCount=0;

    UNICODE_STRING          UniString;
    ULONG                   size;

    (*pIndentLevel)++;

    while (NT_SUCCESS_EX(status)) 
    {
        ULONG       ultemp;

        status = NtEnumerateKey(    pSource->Key(),
                                    ulCount++,
                                    pBasicInfo->Type() , // keyInformationClass,
                                    pBasicInfo->Ptr(),  // pKeyInfo,
                                    pBasicInfo->Size(),  // keyInfoSize,
                                    &ultemp);

        // pBasicInfo was filled up thru NtEnumerateKey() above

        if (NT_SUCCESS_EX(status))                        
        {
            if ( g_debugIO)
            {
                DebugKeyStamp( status , pBasicInfo, *pIndentLevel );
            }
            
            KeyNode RefSubKey(    pRef,   pBasicInfo);
            KeyNode SourceSubKey( pSource,pBasicInfo);

            // calling Open() on this may fail, and we will need to delete and recreate it if required.
            KeyNode *pDestinationSubKey = new KeyNode( pDestination, pBasicInfo);

            RefSubKey.Open();
            SourceSubKey.Open();

            if ( pDestinationSubKey )
            {
                pDestinationSubKey->Open();

                if (NT_SUCCESS_EX( status = SourceSubKey.Status() )  )
                {
                    // key is missing from the ref-hive, we should add
                    // the same sub-tree into our TS\Install\SW hive
                    if ( RefSubKey.Status() == STATUS_OBJECT_NAME_NOT_FOUND 
                         || RefSubKey.Status() == STATUS_OBJECT_PATH_SYNTAX_BAD)  
                    {
                        // @@@
                        // we expect the key not to exist, if it does, then what? delete it?
                        if ( !NT_SUCCESS( pDestinationSubKey->Status()) )
                        {
                            // here is what were are doing with the strings: 
                            // 1) get the path below the "\Registry\User\.Default", which would be
                            // something like "\Software\SomeDir\SomeDirOther\etc", this is the sub-path
                            // 2) create a new node at the destination, which would be something like:
                            // \HKLM\SW\MS\Windows NT\CurrentVersion\TS\INstall + the sub path
                            // we got above.

                            // this is the trailing part of the key-path missing from our TS hive
                            PWCHAR pwch;
                            SourceSubKey.GetPath(&pwch);
                            PWCHAR pDestinationSubPath = &pwch[g_length_TERMSRV_USERREGISTRY_DEFAULT ];

                            PWCHAR  pDestinationFullPath= new WCHAR [ g_length_TERMSRV_INSTALL + 
                                                    wcslen( pDestinationSubPath) + sizeof(WCHAR )];
                            wcscpy( pDestinationFullPath, TERMSRV_INSTALL );
                            wcscat( pDestinationFullPath, pDestinationSubPath );


                            DELETE_AND_NULL( pDestinationSubKey ); 
                            // create a new KeyNode object where the root will be TERMSRV_INSTALL,
                            // below which we will create a sub-layer of nodes, or  a single node.
                            pDestinationSubKey = new KeyNode( NULL , pDestination->Masks(), pDestinationFullPath);

                            // create the new key/branch/values
                            BOOL bCreate = TRUE;
                            if (wcslen(pDestinationFullPath) > sizeof(TERMSRV_INSTALL)/sizeof(WCHAR))
                            {
                                if (RegPathExistsInOmissionList(pDestinationFullPath + (sizeof(TERMSRV_INSTALL)/sizeof(WCHAR)) - 1))
                                    bCreate = FALSE;
                            }

                            if (bCreate)
                            {
                                status = pDestinationSubKey->CreateEx();

                                if ( g_debugIO )
                                {
                                    DebugKeyStamp( status, pBasicInfo, *pIndentLevel , L"[KEY WAS CREATED]");
                                }
                            }
                            else
                            {
                                DEBUG_INFO( status, pDestinationSubKey , KEY_IGNORED  );
                            }
                        } 
            
                    }                     
                    else
                    {
                        // if we have anything but success, set status and bail out
                        if ( !NT_SUCCESS_EX( status = RefSubKey.Status()) )
                        {
                            if ( g_debugIO )
                            {
                                DebugErrorStamp(status, __LINE__ );
                            }
                        }
                    }

                    // Key (if it is NEW) is NOT missing from destination hive at this point
                    // either it did exist, or was created in the above block of code

                    // check if there are any new values in this node.

                    KEY_FULL_INFORMATION    *ptrInfo;
                    ULONG                   size;

                    NTSTATUS st3 = SourceSubKey.Query( &ptrInfo, &size );

                    if (NT_SUCCESS( st3 ))
                    {
                        ValueFullInfo    sourceValueFullInfo( &SourceSubKey );

                        if ( NT_SUCCESS_EX( status = sourceValueFullInfo.Status() ) )
                        {
                            for (ULONG ulkey = 0; ulkey < ptrInfo->Values; ulkey++) 
                            {
                                status = NtEnumerateValueKey(SourceSubKey.Key(),
                                                 ulkey,
                                                 sourceValueFullInfo.Type(),
                                                 sourceValueFullInfo.Ptr(),
                                                 sourceValueFullInfo.Size(),
                                                 &ultemp);
                                                 
                                // @@@
                                if ( ! NT_SUCCESS( status ))
                                {
                                    DebugErrorStamp( status, __LINE__ );
                                }

                                // if the ref key is missing a value, then add
                                // value to the destination key.

                                KEY_VALUE_PARTIAL_INFORMATION *pValuePartialInfo;
                                ValuePartialInfo    refValuePartialInfo( &RefSubKey );

                                // It is important to realize that at this point, it is possible
                                // that ref key did not exist, which follows that refvalue would also
                                // not exist. The C++ objects RefSubKey and refValuePartialInfo do
                                // exist as objects, but there is not counter part of actual registry
                                // data in the registry, hence, the pointers in these object are NULL,
                                // as expected. Still, NULL data should be interpreted as not present data.
                                //
                                // So, the below call refValuePartialInfo.Status() should return TRUE since 
                                // object was created successfully above, but query should return object not 
                                // found or invalid handle without actually calling the reg apis since 
                                // the reg key handle is null.
                                //

                                if ( NT_SUCCESS_EX( status = refValuePartialInfo.Status() ) )
                                {
                                    refValuePartialInfo.Query( sourceValueFullInfo.SzName() );
        
                                    // if .Default\SW has a value that is missing from the ref hive, then add 
                                    // corresponding value into our TS\ hive
                                    if ( !NT_SUCCESS( refValuePartialInfo.Status()) )
                                    {
                                        // make sure pDestinationSubKey exists, else, create the key first before we
                                        // write a value. It is possible that even though the key did exists in the ref
                                        // hive at the start, a new value was added for the first time, which means that the
                                        // ts hive is getting the key and the value for the first time.
                                        if ( !NT_SUCCESS( pDestinationSubKey->Status() ) )
                                        {
                                            // here is what were are doing with the strings: 
                                            // 1) get the path below the "\Registry\User\.Default", which would be
                                            // something like "\Software\SomeDir\SomeDirOther\etc", this is the sub-path
                                            // 2) create a new node at the destination, which would be something like:
                                            // \HKLM\SW\MS\Windows NT\CurrentVersion\TS\INstall + the sub path
                                            // we got above.
                                            
                                            // this is the trailing part of the key-path missing from our TS hive
                                            PWCHAR pwch;
                                            SourceSubKey.GetPath( &pwch );
                                            PWCHAR  pDestinationSubPath = &pwch[g_length_TERMSRV_USERREGISTRY_DEFAULT ];
    
                                            PWCHAR  pDestinationFullPath= new WCHAR [ g_length_TERMSRV_INSTALL + 
                                                                    wcslen( pDestinationSubPath) + sizeof(WCHAR )];
                                            wcscpy( pDestinationFullPath, TERMSRV_INSTALL );
                                            wcscat( pDestinationFullPath, pDestinationSubPath );
                    
                        
                                            DELETE_AND_NULL( pDestinationSubKey ); 
                                            // create a new KeyNode object where the root will be TERMSRV_INSTALL,
                                            // below which we will create a sub-layer of nodes, or  a single node.
                                            pDestinationSubKey = new KeyNode( NULL , pDestination->Masks(), pDestinationFullPath);
                    
                                            // create the new key/branch/values
                                            BOOL bCreate = TRUE;
                                            if (wcslen(pDestinationFullPath) > sizeof(TERMSRV_INSTALL)/sizeof(WCHAR))
                                            {
                                                if (RegPathExistsInOmissionList(pDestinationFullPath + (sizeof(TERMSRV_INSTALL)/sizeof(WCHAR)) - 1))
                                                    bCreate = FALSE;
                                            }

                                            if (bCreate)
                                            {
                                                status = pDestinationSubKey->CreateEx();
                                                if ( g_debugIO )
                                                {
                                                    DebugKeyStamp( status,  pBasicInfo, *pIndentLevel, L"[KEY WAS CREATED]" );
                                                }
                                            }
                                            else
                                            {
                                                DEBUG_INFO( status, pDestinationSubKey , KEY_IGNORED  );
                                            }
                                        }
                                        //else, no problem, key did exist and we don't need to create it
                    
                                        // Create value at the destination node        
                                        // by now, if we do have a key, then we create values for it but only if
                                        // this key is not pointing to a reg path that we are suppose to ignore due
                                        // to the path being mentioned in the omission list.
                                        if (pDestinationSubKey->Key() )
                                        {
                                            if (!HKeyExistsInOmissionList((HKEY)(pDestinationSubKey->Key())))
                                            {
                                                ValueFullInfo   destinationValue( pDestinationSubKey );
                                                if ( NT_SUCCESS_EX( status = destinationValue.Status()) )
                                                {
                                                    status = destinationValue.Create( &sourceValueFullInfo );
    
                                                    NT_SUCCESS_EX( status );
                                                    // if status is error, we bail out.
                                                }
                                                //else, out of memory, var-status is set and we bail out.                                        
                                            }
                                            else
                                            {
                                                DEBUG_INFO( status, pDestinationSubKey , KEY_IGNORED  );
                                            }
                                        }
                                        else
                                        {
                                            DEBUG_INFO( status, pDestinationSubKey , NO_KEY_HANDLE  );
                                        }

                                    }                          
                                    else    // values are not missing, see if they are the same
                                    {
                                        // compare the two data buffers, if the one from SourceSubKey is
                                        // different than the one from the RefSubKey, then delete
                                        // and create one in DestinationSubKey
        
                                        ValueFullInfo   sourceValue( &SourceSubKey);
                                        ValueFullInfo   refValue   ( &RefSubKey   );

                                        if (NT_SUCCESS_EX( status = refValue.Status()) 
                                            && NT_SUCCESS_EX( status = sourceValue.Status())
                                            )
                                        {
                                            sourceValue.Query( sourceValueFullInfo.SzName() );
                                            refValue.Query   ( sourceValueFullInfo.SzName() );
            
                                            if (NT_SUCCESS( refValue.Status()) 
                                                && NT_SUCCESS( sourceValue.Status()))
                                            {
                                                BOOLEAN theSame = sourceValue.Compare( &refValue );
                
                                                if (! theSame )
                                                {

                                                    // make sure pDestinationSubKey exists, else, create the key first before we
                                                    // write a value. It is possible that even though the key did exists in the ref
                                                    // hive at the start, a new value was added for the first time, which means that the
                                                    // ts hive is getting the key and the value for the first time.
                                                    if ( !NT_SUCCESS( pDestinationSubKey->Status() ) )
                                                    {
                                                        // here is what were are doing with the strings: 
                                                        // 1) get the path below the "\Registry\User\.Default", which would be
                                                        // something like "\Software\SomeDir\SomeDirOther\etc", this is the sub-path
                                                        // 2) create a new node at the destination, which would be something like:
                                                        // \HKLM\SW\MS\Windows NT\CurrentVersion\TS\INstall + the sub path
                                                        // we got above.
                                
                                    
                                                        // this is the trailing part of the key-path missing from our TS hive
                                                        PWCHAR pwch;
                                                        SourceSubKey.GetPath( &pwch );
                                                        PWCHAR  pDestinationSubPath = &pwch[g_length_TERMSRV_USERREGISTRY_DEFAULT ];

                                                        PWCHAR  pDestinationFullPath= new WCHAR [ g_length_TERMSRV_INSTALL + 
                                                                                wcslen( pDestinationSubPath) + sizeof(WCHAR )];
                                                        wcscpy( pDestinationFullPath, TERMSRV_INSTALL );
                                                        wcscat( pDestinationFullPath, pDestinationSubPath );
                                
                                    
                                                        DELETE_AND_NULL( pDestinationSubKey ); 
                                                        // create a new KeyNode object where the root will be TERMSRV_INSTALL,
                                                        // below which we will create a sub-layer of nodes, or  a single node.
                                                        pDestinationSubKey = new KeyNode( NULL , pDestination->Masks(), pDestinationFullPath);
                                
                                                        // create the new key/branch/values
                                                        BOOL bCreate = TRUE;
                                                        if (wcslen(pDestinationFullPath) > sizeof(TERMSRV_INSTALL)/sizeof(WCHAR))
                                                        {
                                                            if (RegPathExistsInOmissionList(pDestinationFullPath + (sizeof(TERMSRV_INSTALL)/sizeof(WCHAR)) - 1))
                                                                bCreate = FALSE;
                                                        }

                                                        if (bCreate)
                                                        {
                                                            status = pDestinationSubKey->CreateEx();
                                                            if ( g_debugIO )
                                                            {
                                                                DebugKeyStamp( status,  pBasicInfo, *pIndentLevel , L"KEY WAS CREATED");
                                                            }
                                                        }
                                                        else
                                                        {
                                                            DEBUG_INFO( status, pDestinationSubKey , KEY_IGNORED  );
                                                        }

                                                    }
                                                    //else, no problem, key did exist and we don't need to create it

                                                    // By now, if we do have a key, then we create values for it but only if
                                                    // this key is not pointing to a reg path that we are suppose to ignore due
                                                    // to the path being mentioned in the omission list.
                                                    if (pDestinationSubKey->Key() )
                                                    {
                                                        if (!HKeyExistsInOmissionList((HKEY)(pDestinationSubKey->Key())))
                                                        {
                                                            ValueFullInfo   destinationValue( pDestinationSubKey );
                                                            if ( NT_SUCCESS( destinationValue.Status() ) )
                                                            {
                                                                // don't care if it exists or not, delete it first
                                                                destinationValue.Delete( sourceValueFullInfo.SzName() );
                                                            }
                                                            // else, there is no destination value to delete
    
                                                            // update/create item under destination
    
                                                            // Create a destination value identical to the source value
                                                            status = destinationValue.Create( &sourceValue );
                                                        }
                                                        else
                                                        {
                                                            DEBUG_INFO( status, pDestinationSubKey , KEY_IGNORED  );
                                                        }
                                                    }
                                                    else
                                                    {
                                                        DEBUG_INFO( status, pDestinationSubKey , NO_KEY_HANDLE  );
                                                    }

                                                    // if status is error, we will bail out
                                                    if (!NT_SUCCESS_EX( status ))
                                                    {
                                                        if (g_debugIO)
                                                        {
                                                            DebugErrorStamp(status, __LINE__,
                                                                            &sourceValue );
                                                        }
                                                    }
                                                }
                                            }
                                            // else, values don't exits, doesn't make sense, maybe some dbug code here?
                                        }
                                        // else, var-status is set, we bail out.
                                    }
                                    //if-else
                                }
                                //else, out of memory, var-status is set, we bail out
                            }
                            // for-loop
                        }
                        //else, out of memory, var-status is set, we bail out
                    }
                    else
                    {
                        // this sbould not really happen, but for now...
                        if ( g_debugIO )
                        {
                            DebugErrorStamp( status, __LINE__ );
                        }
                    }


                    // by now, either both source and destination nodes exist, or
                    // a new destination node was just created above. In any case, 
                    // we can continue the traversal.
                    if ( NT_SUCCESS( status ) )
                    {
                        status = EnumerateAndDeltaUpdateKeys( 
                            &SourceSubKey,
                            &RefSubKey,
                             pDestinationSubKey,
                            pBasicInfo ,
                            pIndentLevel);

                        NT_SUCCESS_EX( status );
                    }
                    //else, we are bailing out
                }
                // else, var-status is set, we bail out.

                // done with this sub key, 
                DELETE_AND_NULL( pDestinationSubKey );
            }
            else
            {
                status = STATUS_NO_MEMORY;
            }

            status = AlterStatus( status, __LINE__ );
        }
        // else, no more entries
    }
    // no more entries


    (*pIndentLevel)--;
    // the typical status would be: STATUS_NO_MORE_ENTRIES 
    return status;
}

// delete the ref-hive as specific by the uniRef string
NTSTATUS DeleteReferenceHive(WCHAR *uniRef)
{
    if ( g_debugIO)
    {
        fwprintf( g_debugFilePointer,L"In %ws\n",
                  L"----DeleteReferenceHive");
        fflush( g_debugFilePointer );
    }

    NTSTATUS status = STATUS_SUCCESS;

    KeyNode Old( NULL, KEY_WRITE | KEY_READ | DELETE, uniRef );
    if ( NT_SUCCESS( Old.Open() ) )
    {
        Old.DeleteSubKeys();
        status = Old.Delete();   // delete the head of the branch
    }
    Old.Close();

    return status;
}

/****************************************************************
*
* Function:
*  CreateReferenceHive
*
* Parameters:                                                          
*  uniSource (source     ) string points to the node under .Default    
*  uniRef    (ref        ) string point to TS\Install\RefHive         
*  UniDest   (Destination) string points to TS\Install\Software     
* 
* Description:
*  from the .Default (source) hive, copy into TS\install\RefHive
*  source hive is specified by the uniSoure string, and the
*  ref-hive is specified by the uniRef string.
*
* Return:
*      NTSTATUS, if successful, then STATUS_SUCCESS
*
****************************************************************/
NTSTATUS CreateReferenceHive(WCHAR *uniSource, WCHAR *uniRef)
{
    if ( g_debugIO)
    {
        fwprintf( g_debugFilePointer,L"In %ws\n",
                  L"----CreateReferenceHive");
        fflush( g_debugFilePointer );
    }

    // 1-COPY
    // copy all keys under .Default\Software into a special location 
    // under our TS hive, let's call it the RefHive
    // This will act as the reference hive

    NTSTATUS status = STATUS_SUCCESS;
    ULONG   indentLevel=0;

    // start creating our cache Ref hive

    KeyNode Ref( NULL, MAXIMUM_ALLOWED, uniRef );

    // if we were able to create our RefHive, then continue...
    if ( NT_SUCCESS_EX( status = Ref.Create() ) )
    {
        KeyNode Source(NULL, KEY_READ, uniSource );
    
        // open the source reg-key-path
        if (NT_SUCCESS_EX( status = Source.Open() ))
        {
            KeyBasicInfo    kBasicInfo;
    
            if (NT_SUCCESS_EX( status = kBasicInfo.Status() )) 
            {
                // this will be a recursive call, so we are saving allocation
                // cycles by passing kBasicInfo as scratch pad.
                status = EnumerateAndCreateRefHive(     &Source,
                                    &Ref,
                                    &kBasicInfo, 
                                    &indentLevel);
                
            }
        }
    
    }

    if ( status == STATUS_NO_MORE_ENTRIES)
    {
        status = STATUS_SUCCESS;
    }

    return status;
}

/************************************************************************
*                                                                       
* Function:                                                             
*  DeltaDeleteKeys(WCHAR *uniSource, WCHAR *uniRef, WCHAR *uniDest)     
*                                                                       
*  Parameters:                                                          
*  uniSource (source     ) string points to the node under .Default    
*  uniRef    (ref        ) string point to TS\Install\RefHive         
*  UniDest   (Destination) string points to TS\Install\Software     
*                                                                       
* Description:                                                          
*  compare .Dfeault keys to the equivalent keys in RefHive. If keys are 
*  missing from .Default, then delete the equivalent keys from our      
*  HKLM\...\TS\ hive                                                    
*                                                                      
* Return:                                                             
*      NTSTATUS, if successful, then STATS_SUCCESS                   
*                                                                   
************************************************************************/
NTSTATUS DeltaDeleteKeys(WCHAR *uniSource, WCHAR *uniRef, WCHAR *uniDest)
{
    if ( g_debugIO)
    {
        fwprintf( g_debugFilePointer,L"In %ws\n",
                  L"----DeltaDeleteKeys");
        fflush( g_debugFilePointer );
    }

    // Step2-DELETE
    // compare .Dfeault keys to the equivalent keys in RefHive. If keys are
    // missing from .Default, then delete the equivalent keys from our
    // HKLM\...\TS\ hive

    KeyNode Source( NULL, KEY_READ, uniSource );
    KeyNode Ref( NULL, MAXIMUM_ALLOWED, uniRef );
    KeyNode Destination( NULL, MAXIMUM_ALLOWED, uniDest );

    Source.Open();
    Ref.Open();
    Destination.Open();

    ULONG   indentLevel=0;
    NTSTATUS    status = STATUS_SUCCESS;

    if ( NT_SUCCESS_EX( status = Source.Status() ) &&
         NT_SUCCESS_EX( status = Ref.Status() ) && 
         NT_SUCCESS_EX( status = Destination.Status()  ) )
    {
        KeyBasicInfo     basicInfo;
        
        if( NT_SUCCESS_EX( status = basicInfo.Status() ) )
        {
            // walk and compare, if missing from Source, then delete from Destination
            status = EnumerateAndDeltaDeleteKeys( 
                &Source,
                &Ref,
                &Destination,
                &basicInfo, 
                &indentLevel);
        }
    }

    if ( status == STATUS_NO_MORE_ENTRIES)
    {
        status = STATUS_SUCCESS;
    }

    return status;
}

/************************************************************************
*                                                                       
* Function:                                                             
*  DeltaUpdateKeys(WCHAR *uniSource, WCHAR *uniRef, WCHAR *uniDest)     
*                                                                       
*  Parameters:                                                          
*  uniSource (source     ) string points to the node under .Default     
*  uniRef    (ref        ) string point to TS\Install\RefHive          
*  UniDest   (Destination) string points to TS\Install\Software       
*                                                                    
* Description:                                                      
*  Step-3 CREATE/Update keys and values
*  compare .Default keys to the equivalent keys in RefHive, if keys are
*  present in .Default that are missing from RefHive, then, add those keys
*  to our HKLM\...\TS hive. Do the same for the values.
*  Then, compare values from .Default to values in .Ref. If values have
*  changed, then delete the value from our destination hive and create a
*  new one with the appropriate data from .Default
*                                                                     
* Return:                                                             
*      NTSTATUS, if successful, then STATS_SUCCESS                   
*                                                                   
************************************************************************/
NTSTATUS DeltaUpdateKeys    (WCHAR *uniSource, WCHAR *uniRef, WCHAR *uniDest)
{
    if ( g_debugIO)
    {
        fwprintf( g_debugFilePointer,L"In %ws\n",
                  L"----DeltaUpdateKeys");
        fflush( g_debugFilePointer );
    }
    // 3-CREATE
    // compare .Default keys to the equivalent keys in RefHive, if keys are
    // present in .Default that are missing from RefHive, then, add those keys
    // to our HKLM\...\TS hive
    KeyNode Source( NULL, KEY_READ, uniSource );
    KeyNode Ref( NULL, MAXIMUM_ALLOWED, uniRef );
    KeyNode Destination( NULL, MAXIMUM_ALLOWED, uniDest );

    Source.Open();
    Ref.Open();
    Destination.Open();

    NTSTATUS status;
    ULONG   indentLevel=0;

    if ( NT_SUCCESS_EX( status = Source.Status() ) &&
         NT_SUCCESS_EX( status = Ref.Status() ) && 
         NT_SUCCESS_EX( status = Destination.Status()  ) )
    {

        KeyBasicInfo     basicInfo;

        // Constructor in KeyBasicInfo above allocates memory for pInfo 
        // check if memory allocation of pInfo succeeded
        status = basicInfo.Status();
        if (status != STATUS_SUCCESS) {
            return status;
        }

        // walk and compare, if missing from Source, then delete from Destination
        status = EnumerateAndDeltaUpdateKeys( 
            &Source,
            &Ref,
            &Destination,
            &basicInfo, 
            &indentLevel);
    }

    if ( status == STATUS_NO_MORE_ENTRIES)
    {
        status = STATUS_SUCCESS;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\keynode.h ===
/****************************************************************************/
// keynode.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#ifndef _TS_APP_CMP_KEY_NODE_H_
#define _TS_APP_CMP_KEY_NODE_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <ntregapi.h>
#include <windows.h>


// some utility macros
#define DELETE_AND_NULL( x ) {if (x) {delete x;} x = NULL;}

// ---------------- KEY BASIC INFO 
// Use this object as scratch pad when aquirng basic key information.
class   KeyBasicInfo 
{
public:
    KeyBasicInfo();
    ~KeyBasicInfo();

    ULONG               Size()      { return size ; }
    KEY_BASIC_INFORMATION   *Ptr()  { return pInfo; }
    KEY_INFORMATION_CLASS   Type()  { return KeyBasicInformation ; }
    NTSTATUS               Status() { return status; }

    PCWSTR      NameSz();// this allocates memory, so it's here for debug only


private:
    ULONG                   size;
    KEY_BASIC_INFORMATION   *pInfo;
    ULONG                   status;
    WCHAR                   *pNameSz;
};


#if 0   // not used yet!
// ---------------- KEY NODE INFO 
class   KeyNodeInfo
{
public:
    KeyNodeInfo();
    ~KeyNodeInfo();

    ULONG               Size()      { return size ; }
    KEY_NODE_INFORMATION    *Ptr()  { return pInfo; }
    KEY_INFORMATION_CLASS   Type()  { return KeyNodeInformation ; }
    NTSTATUS               Status() { return status; }

private:
    ULONG   size;
    KEY_NODE_INFORMATION    *pInfo;
    ULONG                   status;
};

#endif

// ---------------- KEY FULL INFO 
// Use this class to create objects that are used as scratch pad when 
// acquiring full-key-info.
class   KeyFullInfo
{
public:
    KeyFullInfo();      // does memory allocation, check status
    ~KeyFullInfo();

    ULONG               Size()      { return size ; }
    KEY_FULL_INFORMATION    *Ptr()  { return pInfo; }
    KEY_INFORMATION_CLASS   Type()  { return KeyFullInformation ; }
    NTSTATUS               Status() { return status; }

private:
    ULONG   size;
    KEY_FULL_INFORMATION    *pInfo;
    ULONG                   status;
};


// This class is used to describe a key-node, which is equivalent to a reg-key abstraction.
// All key operation are caried thru this class, with the exception of key-enum, which is still 
// handled as a raw NT call.
// 
// All Methods set status, which can be acquired by calling Status(), or, in most
// cases, it is returned by the Method called.
class   KeyNode
{
public:
    KeyNode(HANDLE root, ACCESS_MASK access, PCWSTR name ); // init stuff
    KeyNode(KeyNode *parent, KeyBasicInfo   *info );        // init stuff
    ~KeyNode();

    NTSTATUS GetPath( PWCHAR *pwch ); // get the full path to this key

    NTSTATUS Open();        // casue the key to be opened, as defined by params passed to the constructorA
    NTSTATUS Close();       // will close the key (presumed open)

    NTSTATUS Create(UNICODE_STRING *uClass=NULL);           // create a single new key under an existing key

    NTSTATUS CreateEx( UNICODE_STRING *uClass=NULL);        // Create a single branch that potentially has 
                                                            // a multiple levels of new keys such as 
                                                            // x1/x2/x3 under an existing key-X. 
                                                            // Key path specified to the constructire MUST be
                                                            // a full path, starting with \Registry\etc

    NTSTATUS Delete();                                  // delete an existing key
    NTSTATUS DeleteSubKeys();                           // delete the sub tree

    NTSTATUS GetFullInfo( KeyFullInfo   **p);

    NTSTATUS    Query( KEY_BASIC_INFORMATION **result , ULONG *resultSize );
    NTSTATUS    Query( KEY_NODE_INFORMATION  **result , ULONG *resultSize );
    NTSTATUS    Query( KEY_FULL_INFORMATION  **result , ULONG *resultSize );

    NTSTATUS    Status()        {return status;}
    HANDLE      Key()           {return hKey; }
    WCHAR      *Name()          {return uniName.Buffer ;}             
    ACCESS_MASK Masks()         {return accessMask ; }


    enum DebugType 
        {   
            DBG_OPEN, 
            DBG_OPEN_FAILED, 
            DBG_DELETE, 
            DBG_KEY_NAME,
            DBG_CREATE
        };

    void     Debug(DebugType );

    // if debug=TRUE, then the Debug() func will spit out stuff
static BOOLEAN debug;
   
private:                                        
    NTSTATUS EnumerateAndDeleteSubKeys( KeyNode *, KeyBasicInfo *); 
    NTSTATUS GenerateFullPath();

    PCWSTR      NameSz();   // this allocates memory, so it's here for debug 
                        // since you don't really need this,  and it's private

    WCHAR       *pNameSz;

    HANDLE  root;
    HANDLE  hKey;
    UNICODE_STRING  uniName;
    OBJECT_ATTRIBUTES ObjAttr;
    ACCESS_MASK accessMask;
    NTSTATUS    status;

    // key infos
    KeyBasicInfo        *basic;
    KeyFullInfo         *full;

    PVOID                   pFullPath;  // full reg key path, as in \Registr\...blah...blah...\Ts...\blah
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\objrules.c ===
/*************************************************************************
* objrules.c
*
* Routines for caching registry object rules and looking up object names.
*
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <objrules.h>
#include <ntverp.h>

OBJRULELIST SemaRuleList;
OBJRULELIST MutexRuleList;
OBJRULELIST SectionRuleList;
OBJRULELIST EventRuleList;
ULONG NumRuleLists;

RULEINITENTRY RuleInitTab[] =
{
    {&SemaRuleList,    USER_GLOBAL_SEMAPHORES, SYSTEM_GLOBAL_SEMAPHORES},
    {&MutexRuleList,   USER_GLOBAL_MUTEXES,    SYSTEM_GLOBAL_MUTEXES},
    {&SectionRuleList, USER_GLOBAL_SECTIONS,   SYSTEM_GLOBAL_SECTIONS},
    {&EventRuleList,   USER_GLOBAL_EVENTS,     SYSTEM_GLOBAL_EVENTS},
};

//*****************************************************************************
// InitRuleList
//
//    Initializes an object rule list to empty.
//
//    Parameters:
//        POBJRULLIST            (IN)  - ptr to object rule list 
//    Return Value:
//        None.
//*****************************************************************************
void InitRuleList(POBJRULELIST pObjRuleList)
{
    pObjRuleList->First = (POBJRULE) NULL;
    pObjRuleList->Last  = (POBJRULE) NULL;
}

//*****************************************************************************
// GetMultiSzValue
//
//    Retrieves the REG_MULTI_SZ value ValueName under key hKey.
//
//    Parameters:
//        hKey                  The registry key
//        ValueName             The registry value name (NULL Terminated)
//        pValueInfo            Pointer to Pointer receiving a
//                              PKEY_VALUE_PARTIAL_INFORMATION structure
//                              upon successful return. This structure
//                              contains the registry data and its length.
//    Return Value:
//        Returns TRUE if successful, otherwise FALSE.
//        If successful, pValueInfo is updated with a pointer to a
//        structure. The caller must free the structure.
//*****************************************************************************

BOOL GetMultiSzValue(HKEY hKey, PWSTR ValueName,
                     PKEY_VALUE_PARTIAL_INFORMATION *pValueInfo)
{
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;
    UNICODE_STRING UniString;
    ULONG BufSize;
    ULONG DataLen;
    NTSTATUS NtStatus;
    BOOL Retried = FALSE;

    // Determine the value info buffer size
    BufSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_PATH*sizeof(WCHAR);

    for (;;) {
        ValueInfo = RtlAllocateHeap(RtlProcessHeap(), 0, BufSize);

        if (ValueInfo)
        {
            RtlInitUnicodeString(&UniString, ValueName);
            NtStatus = NtQueryValueKey(hKey,
                                       &UniString,
                                       KeyValuePartialInformation,
                                       ValueInfo,
                                       BufSize,
                                       &DataLen);
        
            if (NT_SUCCESS(NtStatus) && (REG_MULTI_SZ == ValueInfo->Type)) {
                *pValueInfo = ValueInfo;
                return(TRUE);
            }
    
            if (!Retried && (NtStatus == STATUS_BUFFER_OVERFLOW)) {
                BufSize = DataLen;
                RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
                Retried = TRUE;
                continue;
            }
            // Key not present or other type of error
            RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
            return(FALSE);
        }
        else
        {
            return(FALSE);
        }
    }

}

//*****************************************************************************
// AddRule
//
//    Adds an object rule a rule list.
//
//    Parameters:
//        RuleList              The rule list.
//        ObjName               The name of the object.
//        SystemGlobalRule      If true, the object is to be SYSTEM_GLOBAL.
//    Return Value:
//        None.
//*****************************************************************************

void AddRule(POBJRULELIST RuleList, PWSTR ObjName, BOOL SystemGlobalRule) 
{
    ULONG AllocSize;
    ULONG Length;
    POBJRULE pObjRule;

#if DBG
    DbgPrint("Adding Rule: %ws SystemGlobal: %d\n",ObjName,SystemGlobalRule);
#endif
    Length = wcslen(ObjName);
    AllocSize = sizeof(OBJRULE) + (Length + 1) * sizeof(WCHAR);
    if (pObjRule = RtlAllocateHeap(RtlProcessHeap(), 0, AllocSize)) {
        wcscpy(pObjRule->ObjName, ObjName);
        pObjRule->SystemGlobal = SystemGlobalRule;
        if (ObjName[Length-1] == L'*') {
            pObjRule->WildCard = TRUE;
            pObjRule->MatchLen = Length - 1;
            // Insert rule at the end of the list
            pObjRule->Next = NULL;
            if (RuleList->First == NULL) {
                RuleList->First = RuleList->Last = pObjRule;
            } else {
                RuleList->Last->Next = pObjRule;
                RuleList->Last = pObjRule;
            }
        } else {
            pObjRule->WildCard = FALSE;
            // Insert rule at the begining
            if (RuleList->First == NULL) {
                RuleList->First = RuleList->Last = pObjRule;
                pObjRule->Next = NULL;
            } else {
                pObjRule->Next = RuleList->First;
                RuleList->First = pObjRule;
            }
        }
    }
}

//*****************************************************************************
// LoadRule
//
//    Caches all rules for a given registry value (REG_MULTI_SZ).
//
//    Parameters:
//        RuleList              The rule list.
//        hKey                  The registry key.
//        ValueName             The name of theregistry value.
//        SystemGlobalRule      If true, the object is to be SYSTEM_GLOBAL.
//    Return Value:
//        None.
//*****************************************************************************

void LoadRule (POBJRULELIST RuleList, HKEY hKey,
               PWSTR ValueName, BOOL SystemGlobalRule)
{
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo = NULL;
    PWSTR Token;
    PWSTR EndData;

    if (!GetMultiSzValue(hKey,ValueName,&ValueInfo)) {
        return;
    }
    EndData = (PWSTR) (ValueInfo->Data + ValueInfo->DataLength);
    for (Token = (PWSTR)ValueInfo->Data;
         (*Token && (Token < EndData));
         Token++) {
        AddRule(RuleList, Token, SystemGlobalRule);
        while (*Token) {
            Token++;
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
}

//*****************************************************************************
// LoadRules
//
//    Caches all rules for in an OBJECTRULES directory.
//    (e.g. Citrix\Compatibility\Applications\<APPNAME>\ObjectRules).
//
//    Parameters:
//        hKey              The registry key of the ObjectRules directory.
//    Return Value:
//        None.
//*****************************************************************************

void LoadRules (HANDLE hKey)
{
    ULONG i;
    PRULEINITENTRY pTab;

    for (i=0, pTab=RuleInitTab;i<NumRuleLists;i++,pTab++) {
        LoadRule(pTab->ObjRuleList, hKey, pTab->UserGlobalValue, FALSE);
        LoadRule(pTab->ObjRuleList, hKey, pTab->SystemGlobalValue, TRUE);
    }
}

#define BuildObjRulePath(BasePath,ModName) \
{ \
    wcscpy(KeyName,BasePath ); \
    wcscat(KeyName,ModName); \
    wcscat(KeyName,L"\\"); \
    wcscat(KeyName,TERMSRV_COMPAT_OBJRULES); \
    RtlInitUnicodeString(&UniString, KeyName); \
    InitializeObjectAttributes(&ObjectAttributes, \
                               &UniString, \
                               OBJ_CASE_INSENSITIVE, \
                               NULL, \
                               NULL); \
}

//*****************************************************************************
// CtxInitObjRuleCache
//
//    Loads all object rules for a given application. Called at DLL process
//    attach time.
//    Rules are in Citrix\Compatibility\Applications\<APPNAME>\ObjectRules
//    Also loads all rules for DLLs listed in:
//    Citrix\Compatibility\Applications\<APPNAME>\ObjectRules\Dlls
//    Parameters:
//        None.
//    Return Value:
//        None.
//*****************************************************************************

void CtxInitObjRuleCache(void)
{
    WCHAR ModName[MAX_PATH+1];
    WCHAR KeyName[sizeof(TERMSRV_COMPAT_APP)/sizeof(WCHAR)+
                  sizeof(TERMSRV_COMPAT_OBJRULES)/sizeof(WCHAR)+MAX_PATH+2];
    UNICODE_STRING UniString;
    PWSTR DllName;
    PWSTR EndData;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo = NULL;
    HKEY   hKey = 0;
    DWORD  AppType;
    ULONG i;

    // Initialize list to empty
    NumRuleLists = sizeof(RuleInitTab) / sizeof(RULEINITENTRY);
    for (i=0; i<NumRuleLists ;i++ ) {
        InitRuleList(RuleInitTab[i].ObjRuleList);
    }

    // Get the module name
    if (!GetAppTypeAndModName(&AppType,ModName, sizeof(ModName))) {
        return;
    }

    // Determine of the ObjRules Key exists for this app
    BuildObjRulePath(TERMSRV_COMPAT_APP,ModName)
    if (!NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &ObjectAttributes))) {
        return;
    }
    LoadRules(hKey);
    

    if (!GetMultiSzValue(hKey,TERMSRV_COMPAT_DLLRULES,&ValueInfo)) {
        CloseHandle(hKey);
        return;
    }

    CloseHandle(hKey);

    // Load the DLL Rules
    EndData = (PWSTR) (ValueInfo->Data + ValueInfo->DataLength);

    for(DllName = (PWSTR) ValueInfo->Data;
        (*DllName && (DllName < EndData));
        DllName++) {
        BuildObjRulePath(TERMSRV_COMPAT_DLLS, DllName)
        if (NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &ObjectAttributes))) {
            LoadRules(hKey);
            CloseHandle(hKey);
        }
        while (*DllName) {
            DllName++;
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
}

//*****************************************************************************
// CtxLookupObjectRule
//
//    Searches for an object rule for the named object. If a rule is found,
//    the object attributes are modifed to reflect the desired setting of 
//    USER_GLOBAL or SYSTEM_GLOBAL. If no rule is found, the object
//    atributes are unmodified.
//
//    Parameters:
//        RuleList          The rule list to search (based on object type)
//        ObjName           The name of the object.
//        ObjAttributes     The object attribute structure.
//        None.
//    Return Value:
//        None.
//*****************************************************************************
void CtxLookupObjectRule(POBJRULELIST RuleList, LPCWSTR ObjName, LPWSTR ObjNameExt)
{
    POBJRULE ObjRule;
    
#define ApplyRule \
{ \
    if (ObjRule->SystemGlobal) { \
        wcscpy(ObjNameExt,L"Global\\");  \
    } else { \
        wcscpy(ObjNameExt,L"Local\\");  \
    } \
}

    for (ObjRule = RuleList->First; ObjRule; ObjRule = ObjRule->Next) {
        if (!ObjRule->WildCard) {
            if (!_wcsicmp(ObjName, ObjRule->ObjName)) {
#if DBG
                DbgPrint("Object rule found for %ws System Global: %d\n",
                          ObjName, ObjRule->SystemGlobal);
#endif
                ApplyRule
                return;
            }
        } else {
            if (!_wcsnicmp(ObjName, ObjRule->ObjName, ObjRule->MatchLen)) {
#if DBG
                DbgPrint("Object rule found for %ws System Global: %d\n",
                          ObjName, ObjRule->SystemGlobal);
#endif
                ApplyRule
                return;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\objrules.h ===
/*************************************************************************
* objrules.h
*
* Defines and function declarations for Object Rule caching
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

#include <winsta.h>
#include <syslib.h>
#include <regapi.h>

// Registry keys under application compatibility section
// (CITRIX_COMPAT_APP)\\<appname>

#define TERMSRV_COMPAT_OBJRULES      REG_OBJRULES
#define TERMSRV_COMPAT_DLLRULES      REG_DLLRULES

// Registry values under ObjectRules and DllRules
#define USER_GLOBAL_SEMAPHORES      COMPAT_RULES_USER_GLOBAL_SEMAPHORES
#define USER_GLOBAL_EVENTS          COMPAT_RULES_USER_GLOBAL_EVENTS
#define USER_GLOBAL_MUTEXES         COMPAT_RULES_USER_GLOBAL_MUTEXES
#define USER_GLOBAL_SECTIONS        COMPAT_RULES_USER_GLOBAL_SECTIONS
#define SYSTEM_GLOBAL_SEMAPHORES    COMPAT_RULES_SYSTEM_GLOBAL_SEMAPHORES
#define SYSTEM_GLOBAL_EVENTS        COMPAT_RULES_SYSTEM_GLOBAL_EVENTS
#define SYSTEM_GLOBAL_MUTEXES       COMPAT_RULES_SYSTEM_GLOBAL_MUTEXES
#define SYSTEM_GLOBAL_SECTIONS      COMPAT_RULES_SYSTEM_GLOBAL_SECTIONS

// Object Rule Structure

typedef struct ObjRule {
    struct ObjRule *Next;
    BOOL WildCard;
    ULONG MatchLen;     // Wildcard match length
    BOOL SystemGlobal;  // If TRUE, object is system global, otherwise USER_GLOBAL
    WCHAR ObjName[1];
} OBJRULE, *POBJRULE;


typedef struct ObjRuleList {
    POBJRULE First;
    POBJRULE Last;
} OBJRULELIST, *POBJRULELIST;

typedef struct RuleInitEntry {
    POBJRULELIST ObjRuleList;
    PWCHAR  UserGlobalValue;
    PWCHAR  SystemGlobalValue;
} RULEINITENTRY, *PRULEINITENTRY;


extern OBJRULELIST SemaRuleList;
extern OBJRULELIST MutexRuleList;
extern OBJRULELIST SectionRuleList;
extern OBJRULELIST EventRuleList;

extern void CtxLookupObjectRule(POBJRULELIST,LPCWSTR,LPWSTR);
extern void CtxInitObjRuleCache(void);

// Macro used by object creation APIs
#define LookupObjRule(RuleList,ObjName,ObjNameExt) \
{ \
    if ((RuleList)->First) { \
        CtxLookupObjectRule(RuleList,ObjName,ObjNameExt); \
    } \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\omission.h ===
/****************************************************************************/
// omission.h
//
// Copyright (C) 2001 Microsoft Corp.
/****************************************************************************/


#ifndef _OMISSION_H_
#define _OMISSION_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define REGISTRY_ENTRIES L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Compatibility\\Registry Entries"
#define SOFTWARE_PATH L"\\Software"

BOOL RegPathExistsInOmissionList(PWCHAR pwchKeyToCheck);
BOOL HKeyExistsInOmissionList(HKEY hKeyToCheck);

BOOL ExistsInEnumeratedKeys(HKEY hOmissionKey, PKEY_FULL_INFORMATION pDefKeyInfo, PWCHAR pwchKeyToCheck);

#endif //_OMISSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\register.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    register.c

Abstract:

    Terminal server register command support functions

Author:


Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

//
// Terminal Server 4.0 has a feature that allows DLL's to be registered SYSTEM
// global. This means all named objects are in the system name space. Such
// a DLL is identified by a bit set in LoaderFlags in the image header.
//
// This module supports this feature by redirecting WIN32 named object API's
// for DLL's with this bit set to a set of functions inside of
// tsappcmp.dll. These stub functions will process the object name and
// call the real kernel32.dll WIN32 functions.
//
// The redirection is accomplished by updating the Import Address Table (IAT)
// after the loader has snapped its thunks. This results in no modification
// of the underlying program or DLL, just updating of the run time system
// linkage table for this process.
//
// ***This only occurs on Terminal Server, and for applications or DLL's
// with this bit set***
//


// \nt\public\sdk\inc\ntimage.h
// GlobalFlags in image, currently not used
#define IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL    0x01000000

#define GLOBALPATHA     "Global\\"
#define GLOBALPATHW     L"Global\\"
#define GLOBALPATHSIZE  7 * sizeof( WCHAR );


extern DWORD   g_dwFlags;              
                               
enum { 
    Index_Func_CreateEventA = 0,
    Index_Func_CreateEventW,                    
    Index_Func_OpenEventA,                      
    Index_Func_OpenEventW,                      
    Index_Func_CreateSemaphoreA,                
    Index_Func_CreateSemaphoreW,                
    Index_Func_OpenSemaphoreA,                  
    Index_Func_OpenSemaphoreW,                  
    Index_Func_CreateMutexA,                    
    Index_Func_CreateMutexW,                    
    Index_Func_OpenMutexA,                      
    Index_Func_OpenMutexW,                      
    Index_Func_CreateFileMappingA,              
    Index_Func_CreateFileMappingW,              
    Index_Func_OpenFileMappingA,                
    Index_Func_OpenFileMappingW
};

enum {
    Index_Func_LoadLibraryA = 0,
    Index_Func_LoadLibraryW    ,
    Index_Func_LoadLibraryExA  ,
    Index_Func_LoadLibraryExW 
};

typedef struct _LDR_TABLE {
    struct _LDR_TABLE       *pNext;
    PLDR_DATA_TABLE_ENTRY   pItem;
} LDR_TABLE;

LDR_TABLE   g_LDR_TABLE_LIST_HEAD;

typedef HANDLE ( APIENTRY Func_CreateEventA )( LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName );

HANDLE
APIENTRY
TCreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    );

typedef HANDLE ( APIENTRY Func_CreateEventW) ( LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName );

HANDLE
APIENTRY
TCreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );

typedef HANDLE ( APIENTRY Func_OpenEventA) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName );

HANDLE
APIENTRY
TOpenEventA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );

typedef  HANDLE ( APIENTRY Func_OpenEventW ) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName );

HANDLE
APIENTRY
TOpenEventW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

typedef HANDLE ( APIENTRY Func_CreateSemaphoreA) ( LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName );

HANDLE
APIENTRY
TCreateSemaphoreA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName
    );

typedef HANDLE ( APIENTRY Func_CreateSemaphoreW) ( LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName ) ;

HANDLE
APIENTRY
TCreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    ) ;

typedef HANDLE ( APIENTRY Func_OpenSemaphoreA) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName );

HANDLE
APIENTRY
TOpenSemaphoreA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );

typedef HANDLE ( APIENTRY Func_OpenSemaphoreW ) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName );

HANDLE
APIENTRY
TOpenSemaphoreW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

typedef HANDLE ( APIENTRY Func_CreateMutexA ) ( LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName );

HANDLE
APIENTRY
TCreateMutexA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCSTR lpName
    );


typedef HANDLE ( APIENTRY Func_CreateMutexW) ( LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName );

HANDLE
APIENTRY
TCreateMutexW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    );


typedef HANDLE ( APIENTRY Func_OpenMutexA ) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName );

HANDLE
APIENTRY
TOpenMutexA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );

typedef HANDLE ( APIENTRY Func_OpenMutexW) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName );

HANDLE
APIENTRY
TOpenMutexW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

typedef HANDLE ( APIENTRY Func_CreateFileMappingA) ( HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName );

HANDLE
APIENTRY
TCreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );


typedef HANDLE ( APIENTRY Func_CreateFileMappingW ) ( HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName );

HANDLE
APIENTRY
TCreateFileMappingW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );

typedef HANDLE ( APIENTRY Func_OpenFileMappingA ) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName ) ;

HANDLE
APIENTRY
TOpenFileMappingA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    ) ;

typedef HANDLE ( APIENTRY Func_OpenFileMappingW ) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName );

HANDLE
APIENTRY
TOpenFileMappingW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    ) ;

typedef HMODULE ( WINAPI Func_LoadLibraryExA )(LPCSTR , HANDLE , DWORD  );

HMODULE 
TLoadLibraryExA(
	LPCSTR lpLibFileName,
	HANDLE hFile,
	DWORD dwFlags
);


typedef HMODULE ( WINAPI Func_LoadLibraryExW )( LPCWSTR , HANDLE , DWORD  );

HMODULE 
TLoadLibraryExW(
	LPCWSTR lpwLibFileName,
	HANDLE hFile,
	DWORD dwFlags
);

typedef HMODULE ( WINAPI Func_LoadLibraryA )( LPCSTR );

HMODULE
TLoadLibraryA(
    LPCSTR lpLibFileName
    );

typedef HMODULE ( WINAPI Func_LoadLibraryW )( LPCWSTR );

HMODULE
TLoadLibraryW(
    LPCWSTR lpwLibFileName
    ) ;

typedef struct _TSAPPCMP_API_HOOK_TABLE
{
    PVOID   orig;   // original API to hook
    PVOID   hook;   // new hook for that API
    WCHAR   name[ 22 * sizeof( WCHAR ) ];       // longest func name
} TSAPPCMP_API_HOOK_TABLE, PTSAPPCMP_API_HOOK_TABLE;

#define NUM_OF_OBJECT_NAME_FUNCS_TO_HOOK        16

TSAPPCMP_API_HOOK_TABLE ObjectNameFuncsToHook[ NUM_OF_OBJECT_NAME_FUNCS_TO_HOOK ] = 
    {
        {NULL,          TCreateEventA,         L"TCreateEventA" },
        {NULL,          TCreateEventW,         L"TCreateEventW" },
        {NULL,            TOpenEventA,           L"TOpenEventA" },
        {NULL,            TOpenEventW,           L"TOpenEventW" },
        {NULL,      TCreateSemaphoreA,     L"TCreateSemaphoreA" },
        {NULL,      TCreateSemaphoreW,     L"TCreateSemaphoreW" },
        {NULL,        TOpenSemaphoreA,       L"TOpenSemaphoreA" },
        {NULL,        TOpenSemaphoreW,       L"TOpenSemaphoreW" },
        {NULL,          TCreateMutexA,         L"TCreateMutexA" },
        {NULL,          TCreateMutexW,         L"TCreateMutexW" },
        {NULL,            TOpenMutexA,          L"TOpenMutexA"  },
        {NULL,            TOpenMutexW,          L"TOpenMutexW"  },
        {NULL,    TCreateFileMappingA,   L"TCreateFileMappingA" },
        {NULL,    TCreateFileMappingW,   L"TCreateFileMappingW" },
        {NULL,      TOpenFileMappingA,     L"TOpenFileMappingA" },
        {NULL,      TOpenFileMappingW,     L"TOpenFileMappingW" },
    };

#define NUM_OF_LOAD_LIB_FUNCS_TO_HOOK           4

TSAPPCMP_API_HOOK_TABLE LoadLibFuncsToHook[ NUM_OF_LOAD_LIB_FUNCS_TO_HOOK ] = 
    {
        {NULL        ,    TLoadLibraryA    , L"TLoadLibraryA"    },
        {NULL        ,    TLoadLibraryW    , L"TLoadLibraryW"    },
        {NULL        ,    TLoadLibraryExA  , L"TLoadLibraryExA"  },
        {NULL        ,    TLoadLibraryExW  , L"TLoadLibraryExW"  }
    };

BOOL
TsWalkProcessDlls();

//
// we don't want to support the load-lib and object name redirection hack on ia64 machines.
//
BOOLEAN Is_X86_OS()
{
    SYSTEM_INFO SystemInfo;
    BOOLEAN bReturn = FALSE;

    ZeroMemory(&SystemInfo, sizeof(SystemInfo));

    GetSystemInfo(&SystemInfo);

    if ( SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL )
    {
        bReturn  = TRUE;
    }

    return bReturn;
}
// See if pEntry is already in our list, if so, then we have already
// processed this image, return FALSE
// Else, add entry to this list and return TRUE so that it is processed this time around.
BOOLEAN ShouldEntryBeProcessed( PLDR_DATA_TABLE_ENTRY pEntry )
{
    LDR_TABLE   *pCurrent,  *pNew ;

    // initialize our pointers to point to the head of the list
    pCurrent = g_LDR_TABLE_LIST_HEAD.pNext ;

    while (pCurrent)
    {
        if ( pEntry == pCurrent->pItem)
        {
            return FALSE;
        }

        pCurrent = pCurrent->pNext;
    }

    // we need to add to our list 
   
    pNew = LocalAlloc( LMEM_FIXED, sizeof( LDR_TABLE ) );

    pCurrent = g_LDR_TABLE_LIST_HEAD.pNext ;

    if (pNew)
    {
        pNew->pItem = pEntry;
        pNew->pNext = pCurrent;
        g_LDR_TABLE_LIST_HEAD.pNext = pNew;     // add to the head
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}

// Free memory allocated for the LDR_TABLE
void FreeLDRTable()
{
    LDR_TABLE   *pCurrent, *pTmp;

    pCurrent = g_LDR_TABLE_LIST_HEAD.pNext ;
    
    while ( pCurrent )
    {
        pTmp = pCurrent;
        pCurrent = pCurrent->pNext;
        LocalFree( pTmp );
    }

    if ( g_dwFlags &  DEBUG_IAT )
    {
        DbgPrint("tsappcmp: done with FreeLDRTable() \n");
    }
}

LPSTR
GlobalizePathA(
    LPCSTR pPath
    )

/*++

Routine Description:

    Convert an ANSI path to a GLOBAL path

--*/

{
    DWORD Len;
    LPSTR pNewPath;

    if( pPath == NULL ) {
	return( NULL );
    }

    //
    // Add code to determine if per object
    // override is in effect and do not globalize
    //

    Len = strlen(pPath) + GLOBALPATHSIZE + 1;

    pNewPath = LocalAlloc(LMEM_FIXED, Len);
    if( pNewPath == NULL ) {
        return( NULL );
    }

    strcpy( pNewPath, GLOBALPATHA );
    strcat( pNewPath, pPath );

    return( pNewPath );
}

LPWSTR
GlobalizePathW(
    LPCWSTR pPath
    )

/*++

Routine Description:

    Convert a WCHAR path to a GLOBAL path

--*/

{
    DWORD Len;
    LPWSTR pNewPath;

    if( pPath == NULL ) {
	return( NULL );
    }

    //
    // Add code to determine if per object
    // override is in effect and do not globalize.
    //

    Len = wcslen(pPath) + GLOBALPATHSIZE + 1;
    Len *= sizeof(WCHAR);

    pNewPath = LocalAlloc(LMEM_FIXED, Len);
    if( pNewPath == NULL ) {
        return( NULL );
    }

    wcscpy( pNewPath, GLOBALPATHW );
    wcscat( pNewPath, pPath );

    return( pNewPath );
}

// Thunks for WIN32 named object functions

HANDLE
APIENTRY
TCreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateEventW


--*/
{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_CreateEventA *) ObjectNameFuncsToHook[ Index_Func_CreateEventA ].orig )( lpEventAttributes, bManualReset, bInitialState, pNewPath );
    // h = CreateEventA( lpEventAttributes, bManualReset, bInitialState, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    if ( g_dwFlags &  DEBUG_IAT )
    {
        if( pNewPath )
            DbgPrint("TCreateEventW: Thunked, New name %ws\n",pNewPath);
    }

    h = ( ( Func_CreateEventW *) ObjectNameFuncsToHook[ Index_Func_CreateEventW ].orig ) ( lpEventAttributes, bManualReset, bInitialState, pNewPath );
    // h = CreateEventW( lpEventAttributes, bManualReset, bInitialState, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenEventA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenNamedEventW

--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_OpenEventA *) ObjectNameFuncsToHook[ Index_Func_OpenEventA ].orig )( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenEventA( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenEventW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_OpenEventW *) ObjectNameFuncsToHook[ Index_Func_OpenEventW ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenEventW( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateSemaphoreA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateSemaphoreW


--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_CreateSemaphoreA *) ObjectNameFuncsToHook[ Index_Func_CreateSemaphoreA ].orig )( lpSemaphoreAttributes, lInitialCount, lMaximumCount, pNewPath );
    // h = CreateSemaphoreA( lpSemaphoreAttributes, lInitialCount, lMaximumCount, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_CreateSemaphoreW *) ObjectNameFuncsToHook[ Index_Func_CreateSemaphoreW ].orig ) ( lpSemaphoreAttributes, lInitialCount, lMaximumCount, pNewPath );
    // h = CreateSemaphoreW( lpSemaphoreAttributes, lInitialCount, lMaximumCount, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenSemaphoreA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenSemaphoreW

--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_OpenSemaphoreA *) ObjectNameFuncsToHook[ Index_Func_OpenSemaphoreA ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenSemaphoreA( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenSemaphoreW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_OpenSemaphoreW *) ObjectNameFuncsToHook[ Index_Func_OpenSemaphoreW ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenSemaphoreW( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateMutexA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateMutexW

--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_CreateMutexA *) ObjectNameFuncsToHook[ Index_Func_CreateMutexA ].orig ) ( lpMutexAttributes, bInitialOwner, pNewPath );
    // h = CreateMutexA( lpMutexAttributes, bInitialOwner, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateMutexW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_CreateMutexW *) ObjectNameFuncsToHook[ Index_Func_CreateMutexW ].orig ) ( lpMutexAttributes, bInitialOwner, pNewPath );
    // h = CreateMutexW( lpMutexAttributes, bInitialOwner, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenMutexA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenMutexW

--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_OpenMutexA *) ObjectNameFuncsToHook[ Index_Func_OpenMutexA ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenMutexA( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenMutexW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_OpenMutexW *) ObjectNameFuncsToHook[ Index_Func_OpenMutexW ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenMutexW( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateFileMappingW

--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_CreateFileMappingA *) ObjectNameFuncsToHook[ Index_Func_CreateFileMappingA ].orig )( hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, pNewPath );
    // h = CreateFileMappingA( hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateFileMappingW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_CreateFileMappingW *) ObjectNameFuncsToHook[ Index_Func_CreateFileMappingW ].orig ) ( hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, pNewPath );
    // h = CreateFileMappingW( hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenFileMappingA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenFileMappingW

--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_OpenFileMappingA *) ObjectNameFuncsToHook[ Index_Func_OpenFileMappingA ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenFileMappingA( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenFileMappingW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_OpenFileMappingW *) ObjectNameFuncsToHook[ Index_Func_OpenFileMappingW ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenFileMappingW( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}



HMODULE 
TLoadLibraryExA(
	LPCSTR lpLibFileName,
	HANDLE hFile,
	DWORD dwFlags
)
{
    HMODULE h;

    h = ( (Func_LoadLibraryExA *)(LoadLibFuncsToHook[Index_Func_LoadLibraryExA ].orig) )( lpLibFileName, hFile, dwFlags );
    //     h = LoadLibraryExA( lpLibFileName, hFile, dwFlags );

    if( h ) {
        if(!TsWalkProcessDlls())
        {
            FreeLibrary(h);
            return NULL;
        }
    }

    return( h );
}


HMODULE TLoadLibraryExW(
	LPCWSTR lpwLibFileName,
	HANDLE hFile,
	DWORD dwFlags
)
{
    HMODULE h;

    h = ( ( Func_LoadLibraryExW *) LoadLibFuncsToHook[Index_Func_LoadLibraryExW ].orig )(  lpwLibFileName, hFile, dwFlags );
    // h = LoadLibraryExW( lpwLibFileName, hFile, dwFlags );

    if( h ) {
        if(!TsWalkProcessDlls())
        {
            FreeLibrary(h);
            return NULL;
        }
    }

    return( h );
}


HMODULE
TLoadLibraryA(
    LPCSTR lpLibFileName
    )

/*++

Routine Description:

   Re-walk all the DLL's in the process since a new set of DLL's may
   have been loaded.

   We must rewalk all since the new DLL lpLibFileName may bring in
   other DLL's by import reference.

--*/

{
    HMODULE h;

    h = ( ( Func_LoadLibraryA *) LoadLibFuncsToHook[Index_Func_LoadLibraryA ].orig )( lpLibFileName );
    // h = LoadLibraryA( lpLibFileName );

    if( h ) {
        if(!TsWalkProcessDlls())
        {
            FreeLibrary(h);
            return NULL;
        }
    }

    return( h );
}



HMODULE
TLoadLibraryW(
    LPCWSTR lpwLibFileName
    )

/*++

Routine Description:

   Re-walk all the DLL's in the process since a new set of DLL's may
   have been loaded.

   We must rewalk all since the new DLL lpLibFileName may bring in
   other DLL's by import reference.

--*/

{
    HMODULE h;

    h = ( ( Func_LoadLibraryW * )LoadLibFuncsToHook[Index_Func_LoadLibraryW ].orig )( lpwLibFileName );
    // h = LoadLibraryW( lpwLibFileName );

    if( h ) {
        if(!TsWalkProcessDlls())
        {
            FreeLibrary(h);
            return NULL;
        }
    }

    return( h );
}

BOOL
TsRedirectRegisteredImage(
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry , 
    BOOLEAN     redirectObjectNameFunctions,
    BOOLEAN     redirectLoadLibraryFunctions
    );


BOOL
TsWalkProcessDlls()

/*++

Routine Description:

   Walk all the DLL's in the process and redirect WIN32 named object
   functions for any that are registered SYSTEM global.

   This function is intended to be called at tsappcmp.dll init time
   to process all DLL's loaded before us.

   A hook is installed by tsappcmp.dll to process DLL's that load
   after this call.

--*/

{
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Head,Next;
    PIMAGE_NT_HEADERS NtHeaders;
    UNICODE_STRING ThisDLLName;
    BOOLEAN     rc;

    RtlInitUnicodeString( &ThisDLLName, TEXT("TSAPPCMP.DLL")) ;

    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
    __try
    {

        Head = &NtCurrentPeb()->Ldr->InLoadOrderModuleList;
        Next = Head->Flink;

        while ( Next != Head ) 
        {
            Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
            Next = Next->Flink;

            rc = ShouldEntryBeProcessed( Entry );

            if (rc)
            {
                if ( (SSIZE_T)Entry->DllBase < 0 )
                {
                    // Not hooking kernel-mode DLL 
    
                    if ( g_dwFlags &  DEBUG_IAT )
                    {
                        DbgPrint(" > Not hooking kernel mode DLL : %wZ\n",&Entry->BaseDllName);
                    }
    
                    continue;
                }
        
                if ( g_dwFlags &  DEBUG_IAT )
                {
            	    if( Entry->BaseDllName.Buffer )
                            DbgPrint("tsappcmp: examining %wZ\n",&Entry->BaseDllName);
                }
    
        	    //
                // when we unload, the memory order links flink field is nulled.
                // this is used to skip the entry pending list removal.
                //
    
                if ( !Entry->InMemoryOrderLinks.Flink ) {
                    continue;
                }
    
        	    NtHeaders = RtlImageNtHeader( Entry->DllBase );
                    if( NtHeaders == NULL ) {
                        continue;
                    }
    
                if( NtHeaders->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE)
                {
                    if ( g_dwFlags &  DEBUG_IAT )
                    {
                        DbgPrint("tsappcmp: %wZ is ts-aware, we are exiting TsWalkProcessDlls() now\n",&Entry->BaseDllName);
                    }
                    return TRUE;     // we do not mess around with the IAT of TS-aware apps.
                }
    
                if (Entry->BaseDllName.Buffer && !RtlCompareUnicodeString(&Entry->BaseDllName, &ThisDLLName, TRUE)) {
                    continue;
                }
        
        	    if( NtHeaders->OptionalHeader.LoaderFlags & IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL ) 
                {
                    // 2nd param is redirectObjectNameFunctions   
                    // 3rd param is redirectLoadLibraryFunctions   
        	        if(!TsRedirectRegisteredImage( Entry , TRUE, TRUE ))     // hooks object name and loadl lib funcs ( all of them )
                    {
                        return FALSE;
                    }
                }
                else
                {
                    if (! (g_dwFlags & TERMSRV_COMPAT_DONT_PATCH_IN_LOAD_LIBS ) )
                    {
                        // 2nd param is redirectObjectNameFunctions   
                        // 3rd param is redirectLoadLibraryFunctions   
                        if(!TsRedirectRegisteredImage( Entry , FALSE, TRUE ))   // only hook lib funcs ( comment error earlier_)
                        {
                            return FALSE;
                        }
                    }
                }
            }
            else
            {
                if ( g_dwFlags & DEBUG_IAT )
                {
                    if( Entry->BaseDllName.Buffer )
                            DbgPrint("tsappcmp: SKIPPING already walked image : %wZ\n",&Entry->BaseDllName);
                }

            }
        }
    }
    __finally
    {
        RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
    }

    return TRUE;
}


BOOL    ImageIsTsAware()
{
    PIMAGE_NT_HEADERS NtHeader = RtlImageNtHeader( NtCurrentPeb()->ImageBaseAddress );

    if ((NtHeader) && (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE)) 
    {
        return TRUE;
    } 
    else 
    {
        return FALSE;
    }
}

BOOL
InitRegisterSupport()
/*++

Routine Description:

    Initialize the register command support by walking
    all DLL's and inserting our thunks.

--*/

{
    int     i;

    g_LDR_TABLE_LIST_HEAD.pNext = NULL; 
    
    if (!Is_X86_OS() )
    {
        DbgPrint("Object name redirection not supported on non-x86 platforms\n");
        return TRUE;
    }
    
    if ( ! ImageIsTsAware() )
    {
        if ( g_dwFlags &  DEBUG_IAT )
        {
            DbgPrint("InitRegisterSupport() called with dwFlags = 0x%lx\n", g_dwFlags);
        }
    
        LoadLibFuncsToHook[ Index_Func_LoadLibraryA ].orig         = LoadLibraryA;   
        LoadLibFuncsToHook[ Index_Func_LoadLibraryW ].orig         = LoadLibraryW;  
        LoadLibFuncsToHook[ Index_Func_LoadLibraryExA ].orig       = LoadLibraryExA;
        LoadLibFuncsToHook[ Index_Func_LoadLibraryExW ].orig       = LoadLibraryExW; 
    
        ObjectNameFuncsToHook[ Index_Func_CreateEventA ].orig       = CreateEventA;
        ObjectNameFuncsToHook[ Index_Func_CreateEventW ].orig       = CreateEventW;          
        ObjectNameFuncsToHook[ Index_Func_OpenEventA ].orig         = OpenEventA;            
        ObjectNameFuncsToHook[ Index_Func_OpenEventW ].orig         = OpenEventW;            
        ObjectNameFuncsToHook[ Index_Func_CreateSemaphoreA ].orig   = CreateSemaphoreA;      
        ObjectNameFuncsToHook[ Index_Func_CreateSemaphoreW ].orig   = CreateSemaphoreW;      
        ObjectNameFuncsToHook[ Index_Func_OpenSemaphoreA ].orig     = OpenSemaphoreA;        
        ObjectNameFuncsToHook[ Index_Func_OpenSemaphoreW ].orig     = OpenSemaphoreW;        
        ObjectNameFuncsToHook[ Index_Func_CreateMutexA ].orig       = CreateMutexA;          
        ObjectNameFuncsToHook[ Index_Func_CreateMutexW ].orig       = CreateMutexW;          
        ObjectNameFuncsToHook[ Index_Func_OpenMutexA ].orig         = OpenMutexA;            
        ObjectNameFuncsToHook[ Index_Func_OpenMutexW ].orig         = OpenMutexW;            
        ObjectNameFuncsToHook[ Index_Func_CreateFileMappingA ].orig = CreateFileMappingA;    
        ObjectNameFuncsToHook[ Index_Func_CreateFileMappingW ].orig = CreateFileMappingW;    
        ObjectNameFuncsToHook[ Index_Func_OpenFileMappingA ].orig   = OpenFileMappingA;      
        ObjectNameFuncsToHook[ Index_Func_OpenFileMappingW ].orig   = OpenFileMappingW;      
    
        if ( g_dwFlags &  DEBUG_IAT )
        {
            for (i = 0; i < NUM_OF_LOAD_LIB_FUNCS_TO_HOOK ; ++i)
            {
               DbgPrint(" Use %ws at index = %2d for an indirect call to 0x%lx \n", LoadLibFuncsToHook[i].name, i, LoadLibFuncsToHook[i].orig  );
            }
        
            for (i = 0; i < NUM_OF_OBJECT_NAME_FUNCS_TO_HOOK ; ++i)
            {
               DbgPrint(" Use %ws at index = %2d for an indirect call to 0x%lx \n", ObjectNameFuncsToHook[i].name, i, ObjectNameFuncsToHook[i].orig );
            }
        }
        return TsWalkProcessDlls();
    }
    else
    {
        return TRUE; // nothing to do!
    }
}

BOOL
TsRedirectRegisteredImage(
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry , 
    BOOLEAN     redirectObjectNameFunctions,
    BOOLEAN     redirectLoadLibraryFunctions
    )
{
/*++

Routine Description:

   Redirect WIN32 named object functions from kernel32.dll to tsappcmp.dll

--*/

    PIMAGE_DOS_HEADER           pIDH;
    PIMAGE_NT_HEADERS           pINTH;
    PIMAGE_IMPORT_DESCRIPTOR    pIID;
    PIMAGE_NT_HEADERS           NtHeaders;
    PBYTE                       pDllBase;
    DWORD                       dwImportTableOffset;
    DWORD                       dwOldProtect, dwOldProtect2;
    SIZE_T                      dwProtectSize;
    NTSTATUS                    status; 



    //
    // Determine the location and size of the IAT.  If found, scan the
    // IAT address to see if any are pointing to RtlAllocateHeap.  If so
    // replace when with a pointer to a unique thunk function that will
    // replace the tag with a unique tag for this image.
    //

    if ( g_dwFlags &  DEBUG_IAT )
    {
        if( LdrDataTableEntry->BaseDllName.Buffer )
            DbgPrint("tsappcmp: walking %wZ\n",&LdrDataTableEntry->BaseDllName);
    }

    pDllBase   = LdrDataTableEntry->DllBase;
    pIDH       = (PIMAGE_DOS_HEADER)pDllBase;

    //
    // Get the import table
    //
    pINTH = (PIMAGE_NT_HEADERS)(pDllBase + pIDH->e_lfanew);

    dwImportTableOffset = pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    
    if (dwImportTableOffset == 0) {
        //
        // No import table found. This is probably ntdll.dll
        //
        return TRUE;
    }
    
    if ( g_dwFlags &  DEBUG_IAT )
    {
        DbgPrint("\n > pDllBase = 0x%lx, IAT offset = 0x%lx  \n", pDllBase, dwImportTableOffset );
    }
    pIID = (PIMAGE_IMPORT_DESCRIPTOR)(pDllBase + dwImportTableOffset);
    
    //
    // Loop through the import table and search for the APIs that we want to patch
    //
    while (TRUE) 
    {        
        
        LPSTR             pszImportEntryModule;
        PIMAGE_THUNK_DATA pITDA;

        // Return if no first thunk (terminating condition)
        
        if (pIID->FirstThunk == 0) {
            break;
        }

        if ( g_dwFlags &  DEBUG_IAT )
        {
            DbgPrint(" > pIID->FirstThunk = 0x%lx \n", pIID->FirstThunk );
        }

        pszImportEntryModule = (LPSTR)(pDllBase + pIID->Name);

                //
        // We have APIs to hook for this module!
        //
        pITDA = (PIMAGE_THUNK_DATA)(pDllBase + (DWORD)pIID->FirstThunk);

        if ( g_dwFlags &  DEBUG_IAT )
        {
            DbgPrint(" >> PITDA = 0x%lx \n", pITDA );
        }

        while (TRUE) {

            DWORD   dwDllIndex;
            PVOID   dwFuncAddr;
            int     i;

            //
            // Done with all the imports from this module? (terminating condition)
            //
            if (pITDA->u1.Ordinal == 0) 
            {
                if ( g_dwFlags &  DEBUG_IAT )
                {
                    DbgPrint(" >> Existing inner loop with PITDA = 0x%lx \n", pITDA );
                }
                break;
            }

            // Make the code page writable and overwrite new function pointer in import table
            
            dwProtectSize = sizeof(DWORD);

            dwFuncAddr = (PVOID)&pITDA->u1.Function;
            
            status = NtProtectVirtualMemory(NtCurrentProcess(),
                                            (PVOID)&dwFuncAddr,
                                            &dwProtectSize,
                                            PAGE_READWRITE,
                                            &dwOldProtect);


            if (NT_SUCCESS(status)) 
            {
                // hook API of interest.

                if (redirectObjectNameFunctions)
                {
                    for (i = 0; i < NUM_OF_OBJECT_NAME_FUNCS_TO_HOOK ; i ++)
                    {
                        if ( ObjectNameFuncsToHook[i].orig ==  (PVOID) pITDA->u1.Function  )
                        {
                            (PVOID)pITDA->u1.Function  = ObjectNameFuncsToHook[i].hook;
    
                            if ( g_dwFlags &  DEBUG_IAT )
                            {
                                DbgPrint(" > Func was hooked : 0x%lx thru %ws \n", ObjectNameFuncsToHook[i].orig ,
                                     ObjectNameFuncsToHook[i].name );
                            }
                        }
                    }
                }
                
                if (redirectLoadLibraryFunctions )
                {
                    for (i = 0; i < NUM_OF_LOAD_LIB_FUNCS_TO_HOOK ; i ++)
                    {
                        if ( LoadLibFuncsToHook[i].orig ==  (PVOID) pITDA->u1.Function  )
                        {
                            (PVOID)pITDA->u1.Function  = LoadLibFuncsToHook[i].hook;
                    
                            if ( g_dwFlags &  DEBUG_IAT )
                            {
                                DbgPrint(" > Func was hooked : 0x%lx thru %ws \n", LoadLibFuncsToHook[i].orig ,
                                     LoadLibFuncsToHook[i].name );
                            }
                        }
                    }

                }

                dwProtectSize = sizeof(DWORD);
                
                status = NtProtectVirtualMemory(NtCurrentProcess(),
                                                (PVOID)&dwFuncAddr,
                                                &dwProtectSize,
                                                dwOldProtect,
                                                &dwOldProtect2);
                if (!NT_SUCCESS(status)) 
                {
                    DbgPrint((" > Failed to change back the protection\n"));
                    return FALSE;
                }
            } 
            else 
            {
                DbgPrint(" > Failed 0x%X to change protection to PAGE_READWRITE. Addr 0x%lx \n", status, &(pITDA->u1.Function) );
                return FALSE;
            }
            pITDA++;
        }
        pIID++;
    }
    return TRUE;
}

#if 0
void
TsLoadDllCallback(
    PLDR_DATA_TABLE_ENTRY Entry
    )

/*++

Routine Description:

   This function is called when a new DLL is loaded.
   It is registered as a callback from LDR, same as WX86

   Hook goes into ntos\dll\ldrsnap.c,LdrpRunInitializeRoutines()

   This function is currently not used since a hook on LoadLibrary
   is used instead to avoid modifications to ntdll.dll.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    NtHeaders = RtlImageNtHeader( Entry->DllBase );
    if( NtHeaders == NULL ) {
        return;
    }

    if( NtHeaders->OptionalHeader.LoaderFlags & IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL ) {
	TsRedirectRegisteredImage( Entry );
    }

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\precomp.h ===
#define _HYDRA_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <tsappcmp.h>
#include "winsta.h"
#include "winbasep.h"
#include "inipath.h"
#include "syslib.h"
#include "compatfl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\omission.c ===
/****************************************************************************/
// omission.cpp
//
// Copyright (C) 2001 Microsoft Corp.
/****************************************************************************/

#include "precomp.h"

#include "omission.h"

extern NTSTATUS TermsrvGetRegPath(IN HANDLE hKey,
                           IN POBJECT_ATTRIBUTES pObjectAttr,
                           IN PWCHAR pInstPath,
                           IN ULONG  ulbuflen);

/*****************************************************************************
 *
 *  RegPathExistsInOmissionList
 *
 *   Determine whether the registry key exists in the list of registry values
 *      defined in the omission key
 *
 * ENTRY:
 *  
 *  IN PWCHAR pwchKeyToCheck:    Registry key to check
 *
 *
 * EXIT:
 *  Returns: True if the key matches one of those in the list 
 *
 ****************************************************************************/
BOOL RegPathExistsInOmissionList(PWCHAR pwchKeyToCheck)
{
    BOOL bExists = FALSE;
    HKEY hOmissionKey = NULL;
    PKEY_FULL_INFORMATION pDefKeyInfo = NULL;
    ULONG ultemp = 0;

    if (pwchKeyToCheck == NULL)
        return FALSE;

    // Get the key info
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_ENTRIES, 0, KEY_READ, &hOmissionKey) != ERROR_SUCCESS)
        return FALSE;

    // Get a buffer for the key info
    ultemp = sizeof(KEY_FULL_INFORMATION) + MAX_PATH * sizeof(WCHAR);
    pDefKeyInfo = (PKEY_FULL_INFORMATION)(RtlAllocateHeap(RtlProcessHeap(), 0, ultemp));

    if (pDefKeyInfo && hOmissionKey) 
    {
        if NT_SUCCESS(NtQueryKey(hOmissionKey,
                                  KeyFullInformation,
                                    pDefKeyInfo,
                                    ultemp,
                                    &ultemp))
        {
            bExists = ExistsInEnumeratedKeys(hOmissionKey, pDefKeyInfo, pwchKeyToCheck);
        }
    }

    if (pDefKeyInfo) 
        RtlFreeHeap(RtlProcessHeap(), 0, pDefKeyInfo);

    if (hOmissionKey)
        RegCloseKey(hOmissionKey);

    return bExists;
}

/*****************************************************************************
 *
 *  HKeyExistsInOmissionList
 *
 *   Determine whether the registry key exists in the list of registry values
 *      defined in the omission key. Assumes the key is in the TERMSRV_INSTALL path
 *
 * ENTRY:
 *  
 *  IN PHKEY phKeyToCheck:    Registry key to check
 *
 *
 * EXIT:
 *  Returns: True if the key matches one of those in the list 
 *
 ****************************************************************************/
BOOL HKeyExistsInOmissionList(HKEY hKeyToCheck)
{
    BOOL bExists = FALSE;
    ULONG ulMaxPathLength = 0;
    PWCHAR pUserPath = NULL;
    PWCHAR pUserSubPath = NULL;

    if (hKeyToCheck == NULL)
        return FALSE;

    // Get a buffer to hold the user's path in the registry
    ulMaxPathLength = MAX_PATH * sizeof(WCHAR);
    pUserPath = RtlAllocateHeap(RtlProcessHeap(), 0, ulMaxPathLength);
    if (pUserPath)
    {
        // Get the full path associated with this object attribute structure
        if NT_SUCCESS(TermsrvGetRegPath(hKeyToCheck, NULL, pUserPath, ulMaxPathLength))
        {
            // Skip over first part of path + backslash     
            if (pUserPath)
            {
                if (wcslen(pUserPath) >= (sizeof(TERMSRV_INSTALL)/sizeof(WCHAR)))
                {
                    pUserSubPath = pUserPath + (sizeof(TERMSRV_INSTALL)/sizeof(WCHAR)) - 1; 

                    if (pUserSubPath)
                    {
                        if (wcslen(pUserSubPath) >= sizeof(SOFTWARE_PATH)/sizeof(WCHAR))
                        {
                            //Make sure the next part of the key path is SOFTWARE_PATH
                            if (!_wcsnicmp(pUserSubPath, SOFTWARE_PATH, sizeof(SOFTWARE_PATH)/sizeof(WCHAR) - 1))
                                bExists = RegPathExistsInOmissionList(pUserSubPath);
                        }
                    }
                }
            }
        }
    }

    if (pUserPath)
        RtlFreeHeap(RtlProcessHeap(), 0, pUserPath);

    return bExists;
}


/*****************************************************************************
 *
 *  ExistsInEnumeratedKeys
 *
 *   Determine whether the registry key exists in the list of registry
 *      values passed in thru the pDefKeyInfo structure
 *
 * ENTRY:
 *  
 *  IN HKEY hOmissionKey: Key containing the values against which to compare pwchKeyToCheck
 *  IN PKEY_FULL_INFORMATION pDefKeyInfo: Structure containing information about
 *                                          the list of values against which 
 *                                          to compare pwchKeyToCheck
 *
 *  IN PWCHAR pwchKeyToCheck: Key to check against the list
 *
 *
 * EXIT:
 *  Returns: True if the key matches one of those in the list 
 *
 ****************************************************************************/
BOOL ExistsInEnumeratedKeys(HKEY hOmissionKey, PKEY_FULL_INFORMATION pDefKeyInfo, PWCHAR pwchKeyToCheck)
{
    BOOL bExists = FALSE;
    PKEY_VALUE_BASIC_INFORMATION pKeyValInfo = NULL;
    ULONG ulbufsize = 0;
    ULONG ulkey = 0;
    ULONG ultemp = 0;
    NTSTATUS Status;

    if (!hOmissionKey || !pDefKeyInfo || !pwchKeyToCheck)
        return FALSE;

    if (wcslen(pwchKeyToCheck) <= (sizeof(SOFTWARE_PATH)/sizeof(WCHAR)))
        return FALSE;

    pwchKeyToCheck += (sizeof(SOFTWARE_PATH)/sizeof(WCHAR));

    // Traverse the values for this key
    if (pDefKeyInfo->Values) 
    {
        ulbufsize = sizeof(KEY_VALUE_BASIC_INFORMATION) + 
                    (pDefKeyInfo->MaxValueNameLen + 1) * sizeof(WCHAR) +
                    pDefKeyInfo->MaxValueDataLen; 

        pKeyValInfo = (PKEY_VALUE_BASIC_INFORMATION)(RtlAllocateHeap(RtlProcessHeap(), 0, ulbufsize));

        // Get a buffer to hold current value of the key (for existence check)
        if (pKeyValInfo) 
        {
            for (ulkey = 0; ulkey < pDefKeyInfo->Values; ulkey++) 
            {
                Status = NtEnumerateValueKey(hOmissionKey,
                                        ulkey,
                                        KeyValueBasicInformation,
                                        pKeyValInfo,
                                        ulbufsize,
                                        &ultemp);

                if ((Status == STATUS_SUCCESS) && (pwchKeyToCheck) && (pKeyValInfo->Name))
                {
                    if (wcslen(pwchKeyToCheck) >= (pKeyValInfo->NameLength/sizeof(WCHAR)))
                    {
                        if ((pwchKeyToCheck[pKeyValInfo->NameLength/sizeof(WCHAR)] == L'\\') ||
                            (pwchKeyToCheck[pKeyValInfo->NameLength/sizeof(WCHAR)] == 0))
                        {
                            if (!_wcsnicmp(pwchKeyToCheck, pKeyValInfo->Name, (pKeyValInfo->NameLength/sizeof(WCHAR))))
                            {
                                bExists = TRUE;
                                break;
                            }
                        }
                    }
                }
            }
        }

        if (pKeyValInfo) 
            RtlFreeHeap(RtlProcessHeap(), 0, pKeyValInfo);
    }

    return bExists;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\regmap.c ===
/*************************************************************************
*
* regmap.c
*
* Handle Copy-On-Reference Registry Entry Mapping
*
* copyright notice: Copyright 1996-1997, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* Author:  Bill Madden
*
* NOTE for Hydra (butchd 9/26/97): In comments below, substitute
*
*   SOFTWARE\Citrix
*
* with
*
*   SOFTWARE\Microsoft\Windows NT\CurrentVersion\Terminal Server
*
* Here's a brief(?) summary of how the registry mapping works.  The goal is 
* that an administrator can install an application, and then all users can 
* use it, without any per-user configuration.  The current design is that 
* the administrator puts the system into installation mode (change user 
* /install), installs the application, and then returns the system to 
* execute mode (change user /execute).  There are hooks in the API's used to 
* create keys and values in the registry (BaseRegCreateKey, BaseRegSetValue, 
* BaseRegRestoreKey, etc), and the hooks create a copy of the registry keys 
* created under \HKEY_LOCAL_MACHINE\SOFTWARE\Citrix\Install (both for the 
* user specific keys and the local machine keys).  The local machine keys 
* are added so that if sometime in the future we need to know all of the 
* registry values created by an application, there is a copy of them 
* available. 
*
* When a user starts a Win32 app for the first time, the app will open the 
* keys it needs to query.  If the key doesn't exist underneath 
* HKEY_CURRENT_USER, there are hooks in the base registry API's to catch the 
* error and then search underneath the Citrix/Install section to see if the 
* key exists there.  If the key exists in the install section, we copy the 
* key, its values, and its subkeys to the current user's registry.  This 
* way we only have to hook opens, and not every registry API.  This helps 
* reduce the overhead associated with this registry mapping.
*
* Some apps (such as the office short cut bar) delete entries and need to 
* recreate the entries themselves.  When an app deletes a key and the 
* system is in execute mode, we will set a value under the key indicating 
* that we should only copy the key to the user once.  What this currently 
* means, is that if this is the only key being created, we won't create it 
* when that flag is set.  However, if we are creating this key because we 
* created its parent, we will still create the key.  
* 
* The other part of the registry mapping support is that when a user logs
* in, userinit calls a routine (CtxCheckNewRegEntries) which checks if any 
* of the system keys are newer than any of the corresponding user keys.  If 
* they are, the user keys are deleted (we're assuming that if the system 
* key is newer, than the admin has installed a newer version of an 
* application).  This deleting can be disabled by setting a value under 
* HKEY_LOCAL_MACHINE\Software\Citrix\Compatibility\IniFiles\xxx where xxx 
* is the key name, and the value should be 0x48.
*
*************************************************************************/

#include "precomp.h"
#pragma hdrstop


#include <rpc.h>
#include <regmap.h>
#include <aclapi.h>
#include "omission.h"

/* External Functions */

ULONG GetCtxAppCompatFlags(LPDWORD, LPDWORD);

/* Internal Functions */
PWCHAR GetUserSWKey(PWCHAR pPath, PBOOL fUserReg, PBOOL bClassesKey);
PWCHAR Ctxwcsistr(PWCHAR pstring1, PWCHAR pstring2);
NTSTATUS TermsrvGetRegPath(IN HANDLE hKey,
                       IN POBJECT_ATTRIBUTES pObjectAttr,
                       IN PWCHAR pInstPath,
                       IN ULONG  ulbuflen);
NTSTATUS TermsrvGetInstallPath(IN PWCHAR pUserPath,
                           IN PWCHAR *ppInstPath);
NTSTATUS TermsrvCreateKey(IN PWCHAR pSrcPath,
                      IN PWCHAR pDstPath,
                      IN BOOL fCloneValues,
                      IN BOOL fCloneSubKeys,
                      OUT PHANDLE phKey);
NTSTATUS TermsrvCloneKey(HANDLE hSrcKey,
                     HANDLE hDstKey,
                     PKEY_FULL_INFORMATION pDefKeyInfo,
                     BOOL   fCreateSubKeys);
void TermsrvLogRegInstallTime(void);


/*****************************************************************************
 *
 *  TermsrvCreateRegEntry
 *
 *   If in installation mode, create the registry entry in the citrix 
 *   install user section of the registry.  If the system is in execution 
 *   mode, verify that the key values and subkeys have been created.
 *
 * ENTRY:
 *  IN HANDLE hKey:                     Handle of new key just created
 *  IN ULONG TitleIndex:                Title Index
 *  IN PUNICODE_STRING pUniClass:       Ptr to unicode string of class
 *  IN ULONG ulCreateOpt:               Creation options
 *  
 *
 * EXIT:
 *  TRUE: Entry created in install section or cloned from install section
 *  FALSE: Entry not created or cloned
 *
 ****************************************************************************/

BOOL TermsrvCreateRegEntry(IN HANDLE hKey,
                       IN POBJECT_ATTRIBUTES pObjAttr,
                       IN ULONG TitleIndex,
                       IN PUNICODE_STRING pUniClass OPTIONAL,
                       IN ULONG ulCreateOpt)
{
    NTSTATUS Status;             
    ULONG ultemp;
    OBJECT_ATTRIBUTES InstObjectAttr;
    UNICODE_STRING UniString;
    HKEY   hNewKey = NULL;
    PWCHAR  wcbuff = NULL;
    PWCHAR pUserPath;
    BOOL fMapping;
    BOOL fUserReg;
    PKEY_FULL_INFORMATION pDefKeyInfo = NULL;

    // Get the current state of ini file mapping
    fMapping = !TermsrvAppInstallMode();

    // Get a buffer to hold the path of the key
    ultemp = sizeof(WCHAR)*MAX_PATH*2;
    pUserPath = RtlAllocateHeap(RtlProcessHeap(), 
                                0, 
                                ultemp);

    // Get the full path associated with this key
    if (pUserPath) {
        Status = TermsrvGetRegPath(hKey,
                               NULL,
                               pUserPath,
                               ultemp);
    } else {
        Status = STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(Status)) {

        // Get the corresponding path in the install section
        Status = TermsrvGetInstallPath(pUserPath, 
                                    &wcbuff);
    
        if (NT_SUCCESS(Status)) {

            // Set up an object attribute structure to point to the
            // path of the key in the install section
            RtlInitUnicodeString(&UniString, wcbuff);
            InitializeObjectAttributes(&InstObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       pObjAttr->SecurityDescriptor);

            // If we're in install mode, create the key in the default
            // install section
            if (!fMapping) {
                
                // Inherit the default security for the install section
                InstObjectAttr.SecurityDescriptor = NULL;
            
                Status = NtCreateKey(&hNewKey,
                                     KEY_WRITE,
                                     &InstObjectAttr,
                                     TitleIndex,
                                     pUniClass,
                                     ulCreateOpt,
                                     &ultemp);
        
                if (!NT_SUCCESS(Status)) {
                    // Need to build up the path to the registry key
                    Status = TermsrvCreateKey(pUserPath,
                                          wcbuff,
                                          FALSE,
                                          FALSE,
                                          &hNewKey);
                }

                // Update the registry entry for the last time a registry
                // entry was added
                if (NT_SUCCESS(Status)) {
                    TermsrvLogRegInstallTime();
                }

            // The system is in execute mode, try to copy the key from the
            // installation section
            } else {
                HANDLE hUserKey = NULL;
                ULONG ulAppType = TERMSRV_COMPAT_WIN32;

                // First verify that this is in the user software section
                if (!GetUserSWKey(pUserPath, &fUserReg, NULL)) {
                    Status = STATUS_NO_MORE_FILES;
                }

                // If mapping is on, but disabled for this app, return
                GetCtxAppCompatFlags(&ultemp, &ulAppType);
                if ((ultemp & (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32)) == 
                    (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32)) {
                    Status = STATUS_NO_MORE_FILES;
                }

                // Check if registry mapping is disabled for this key path
                GetTermsrCompatFlags(pUserPath, &ultemp, CompatibilityRegEntry);
                if ((ultemp & (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) ==
                    (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) {
                    Status = STATUS_NO_MORE_FILES;
                }

                if (NT_SUCCESS(Status)) {
                    // Open up a key for the install section 
                    Status = NtOpenKey(&hNewKey, 
                                       KEY_READ,
                                       &InstObjectAttr);
                }

                if (NT_SUCCESS(Status)) {
                    // Set an attribute structure to point at the user path
                    RtlInitUnicodeString(&UniString, pUserPath);
                    InitializeObjectAttributes(&InstObjectAttr,
                                               &UniString,
                                               OBJ_CASE_INSENSITIVE,
                                               NULL,
                                               pObjAttr->SecurityDescriptor);
    
                    // Open the user path so we can write to it
                    Status = NtOpenKey(&hUserKey, 
                                       KEY_WRITE,
                                       &InstObjectAttr);
                }
    
                // Get the key info
                if (NT_SUCCESS(Status)) {

                    // Get a buffer for the key info
                    ultemp = sizeof(KEY_FULL_INFORMATION) + 
                             MAX_PATH*sizeof(WCHAR);
                    pDefKeyInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                                  0, 
                                                  ultemp);

                    if (pDefKeyInfo) {
                        Status = NtQueryKey(hNewKey,
                                            KeyFullInformation,
                                            pDefKeyInfo,
                                            ultemp,
                                            &ultemp);
                    } else {
                        Status = STATUS_NO_MEMORY;
                    }
                } 

                // Copy all of the values and subkeys for this key from the
                // install section to the user section
                if (NT_SUCCESS(Status)) {
                    Status =  TermsrvCloneKey(hNewKey,
                                          hUserKey,
                                          pDefKeyInfo,
                                          TRUE);
                    if (pDefKeyInfo) {
                        RtlFreeHeap(RtlProcessHeap(), 0, pDefKeyInfo);
                    }
                }
                if (hUserKey) {
                    NtClose(hUserKey);
                }
            }
            if (hNewKey) {
                NtClose(hNewKey);
            }
        } 
    }

    if (pUserPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, pUserPath);
    }
    
    if (wcbuff) {
        RtlFreeHeap(RtlProcessHeap(), 0, wcbuff);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*****************************************************************************
 *
 *  TermsrvOpenRegEntry
 *
 *   If the system is in execute mode, copy application registry entries 
 *   from the default user to the current user.  
 *
 * ENTRY:
 *  OUT PHANDLE pUserKey:
 *      Pointer to return key handle if opened
 *  IN ACCESS_MASK DesiredAccess:
 *      Desired access to the key
 *  IN POBJECT_ATTRIBUTES ObjectAttributes:
 *      Object attribute structure for key to open
 *
 * EXIT:
 *  TRUE: Entry moved from install to current user
 *  FALSE: Entry not moved
 *
 ****************************************************************************/

BOOL TermsrvOpenRegEntry(OUT PHANDLE pUserhKey,
                     IN ACCESS_MASK DesiredAccess,
                     IN POBJECT_ATTRIBUTES pUserObjectAttr)
{
    NTSTATUS Status;        
    ULONG ultemp=0;
    ULONG ulAppType = TERMSRV_COMPAT_WIN32;
    HKEY   hNewKey;
    WCHAR  wcbuff[MAX_PATH*2];
    PWCHAR pwch, pUserPath;
    BOOL   fUserReg;

    // If running in install mode, return
    if (TermsrvAppInstallMode() ) {
        return(FALSE);
    }

    // If mapping is on, but disabled for this app, return
    GetCtxAppCompatFlags(&ultemp, &ulAppType);
    if ((ultemp & (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32)) == 
         (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32)) {
        return(FALSE);
    }

    // Get a buffer to hold the user's path in the registry
    ultemp = sizeof(WCHAR)*MAX_PATH*2;
    pUserPath = RtlAllocateHeap(RtlProcessHeap(), 
                                0, 
                                ultemp);
    if (pUserPath) {
        // Get the full path associated with this object attribute structure
        Status = TermsrvGetRegPath(NULL,
                               pUserObjectAttr,
                               pUserPath,
                               ultemp);
    } else {
        Status = STATUS_NO_MEMORY;
    }

    // Create the key for this user
    if (NT_SUCCESS(Status)) {
    
        Status = STATUS_NO_SUCH_FILE;

        //DbgPrint("Attempting to open key %ws\n",pUserPath);
        // Check if they are trying to open the key under HKEY_CURRENT_USER
        pwch = GetUserSWKey(pUserPath, &fUserReg, NULL);
        
        if (pwch) {
            // Check if registry mapping is disabled for this key 
            GetTermsrCompatFlags(pUserPath, &ultemp, CompatibilityRegEntry);
            if ((ultemp & (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) !=
                (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) {

                wcscpy(wcbuff, TERMSRV_INSTALL);
                wcscat(wcbuff, pwch);
    
                Status = TermsrvCreateKey(wcbuff,
                                      pUserPath,
                                      TRUE,
                                      TRUE,
                                      &hNewKey);
    
                if (NT_SUCCESS(Status)) {
                    NtClose(hNewKey);
                }
            } else {

                Status = STATUS_NO_MORE_FILES;
            }

        // App is trying to open the key under HKEY_LOCAL_MACHINE, mask off 
        // the access bits they don't have by default
        } else if (!_wcsnicmp(pUserPath,
                      TERMSRV_MACHINEREGISTRY,
                      wcslen(TERMSRV_MACHINEREGISTRY)) &&
                   (DesiredAccess & 
                    (WRITE_DAC | WRITE_OWNER | KEY_CREATE_LINK))) {
            DesiredAccess &= ~(WRITE_DAC | WRITE_OWNER | KEY_CREATE_LINK);
            Status = STATUS_SUCCESS;
        }
    } else {
        Status = STATUS_NO_SUCH_FILE;
    }

    if (pUserPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, pUserPath);
    }

    // We successfully copied the key, so actually do the open
    if (NT_SUCCESS(Status)) {
        Status = NtOpenKey(pUserhKey,
                           DesiredAccess,
                           pUserObjectAttr);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*****************************************************************************
 *
 *  TermsrvSetValueKey
 *
 *   If the system is in install (ini mapping off) mode, set the entry in 
 *   the citrix install user section of the registry.  If the system is in
 *   execute (ini mapping on) mode, do nothing.
 *
 * ENTRY:
 *  HANDLE hKey:               Open key to query value from
 *  PUNICODE_STRING ValueName: Ptr to unicode value name to set
 *  ULONG TitleIndex:          Title Index
 *  ULONG Type:                Type of data
 *  PVOID Data:                Ptr to data
 *  ULONG DataSize:            Data length
 *
 * EXIT:
 *  TRUE: Entry created in install section
 *  FALSE: Entry not created
 *
 ****************************************************************************/
BOOL TermsrvSetValueKey(HANDLE hKey,
                    PUNICODE_STRING ValueName,
                    ULONG TitleIndex,
                    ULONG Type,
                    PVOID Data,
                    ULONG DataSize)
{
    NTSTATUS Status;        
    ULONG ultemp;
    PWCHAR pwch, pUserPath;
    PWCHAR wcbuff = NULL;
    UNICODE_STRING UniString;
    OBJECT_ATTRIBUTES InstObjectAttr;
    HKEY   hNewKey;

    // If  not in install mode, return
    if ( !TermsrvAppInstallMode() ) {
        return(FALSE);
    }

    // Allocate a buffer to hold the path to the key in the registry
    ultemp = sizeof(WCHAR)*MAX_PATH*2;
    pUserPath = RtlAllocateHeap(RtlProcessHeap(), 
                                0, 
                                ultemp);

    // Get the path of this key
    if (pUserPath) {
        Status = TermsrvGetRegPath(hKey,
                               NULL,
                               pUserPath,
                               ultemp);
    } else {
        Status = STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(Status)) {
    
        // Get the path to the entry in the install section of the registry
        Status = TermsrvGetInstallPath(pUserPath,
                                   &wcbuff);

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&UniString, wcbuff);
            InitializeObjectAttributes(&InstObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);
        
            // Open the key in under the install section
            Status = NtOpenKey(&hNewKey,
                               KEY_WRITE,
                               &InstObjectAttr);
    
            // If we couldn't open it, try creating the key
            if (!NT_SUCCESS(Status)) {
                Status = TermsrvCreateKey(pUserPath, 
                                      wcbuff,
                                      TRUE,
                                      FALSE,
                                      &hNewKey);
            }

            // If the key was opened, set the value in the install section
            if (NT_SUCCESS(Status)) {
                Status = NtSetValueKey(hNewKey,
                                       ValueName,
                                       TitleIndex,
                                       Type,
                                       Data,
                                       DataSize);
                NtClose(hNewKey);

                // Update the registry entry for the last time a registry
                // entry was added
                if (NT_SUCCESS(Status)) {
                    TermsrvLogRegInstallTime();
                }
            }
        }
    }

    if (pUserPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, pUserPath);
    }
    
    if (wcbuff) {
        RtlFreeHeap(RtlProcessHeap(), 0, wcbuff);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*****************************************************************************
 *
 *  TermsrvDeleteKey
 *
 *   If the system is in install mode, delete the registry entry in the citrix 
 *   install section of the registry.  If the system is in execution mode,
 *   mark the entry in the install section as being deleted.
 *
 * ENTRY:
 *  HANDLE hKey: Handle of key in user section to delete
 *
 * EXIT:
 *  TRUE: Entry deleted in install section
 *  FALSE: Entry not created
 *
 ****************************************************************************/

BOOL TermsrvDeleteKey(HANDLE hKey)
{
    NTSTATUS Status;        
    ULONG ultemp=0;
    ULONG ulAppType = TERMSRV_COMPAT_WIN32;
    OBJECT_ATTRIBUTES ObjectAttr;
    PKEY_BASIC_INFORMATION pKeyInfo;
    UNICODE_STRING UniString;
    HKEY   hNewKey;
    PWCHAR  wcbuff = NULL;
    PWCHAR pwch, pUserPath;
    BOOL fMapping;


    // Get the current state of ini file/registry mapping, default to execute
    fMapping = !TermsrvAppInstallMode();

    // If mapping is on, but disabled for this app, return
    if (fMapping) {
        GetCtxAppCompatFlags(&ultemp, &ulAppType);
        if ((ultemp & (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32)) == 
            (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32)) {
            return(FALSE);
        }
    }

    // Allocate a buffer to hold the path of the key
    ultemp = sizeof(WCHAR)*MAX_PATH*2;
    pUserPath = RtlAllocateHeap(RtlProcessHeap(), 
                                0, 
                                ultemp);

    // Get the path to the user's key
    if (pUserPath) {
        Status = TermsrvGetRegPath(hKey,
                               NULL,
                               pUserPath,
                               ultemp);
    } else {
        Status = STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(Status)) {

        // Get the corresponding path in the install section
        Status = TermsrvGetInstallPath(pUserPath,
                                   &wcbuff);

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&UniString, wcbuff);
            InitializeObjectAttributes(&ObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);
        
            // Open the key in the install section to mark it or delete it
            if (fMapping) {
                Status = NtOpenKey(&hNewKey,
                                   KEY_READ | KEY_WRITE,
                                   &ObjectAttr);
                                  
            } else {
                Status = NtOpenKey(&hNewKey,
                                   KEY_READ | KEY_WRITE | DELETE,
                                   &ObjectAttr);
            }
        }
    
        if (NT_SUCCESS(Status)) {
    
            // If in execute mode, set the copy once flag, but preserve the
            // last write time of this key
            if (fMapping) {
                PKEY_VALUE_PARTIAL_INFORMATION pValKeyInfo;
                PKEY_BASIC_INFORMATION pKeyInfo;
                NTSTATUS SubStatus;
                ULONG ulcbuf;

                // Get a buffer 
                ulcbuf = sizeof(KEY_BASIC_INFORMATION) + MAX_PATH*sizeof(WCHAR);
                pKeyInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                           0, 
                                           ultemp);

                // If we got the buffer, see if the copy once flag exists
                if (pKeyInfo) {
                    RtlInitUnicodeString(&UniString, TERMSRV_COPYONCEFLAG);
                    pValKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)pKeyInfo;
                    SubStatus = NtQueryValueKey(hNewKey,
                                                &UniString,
                                                KeyValuePartialInformation,
                                                pValKeyInfo,
                                                ulcbuf,
                                                &ultemp);

                    // If we couldn't get the value of the key, or it's not
                    // what it should be, reset it
                    if (!NT_SUCCESS(SubStatus) || 
                        (pValKeyInfo->Type != REG_DWORD) || 
                        (*pValKeyInfo->Data != 1)) {

                        // Get the last update time of the key
                        SubStatus = NtQueryKey(hNewKey,
                                               KeyBasicInformation,
                                               pKeyInfo,
                                               ultemp,
                                               &ultemp);

                        // Set the copy once flag
                        ultemp = 1;
                        Status = NtSetValueKey(hNewKey,
                                               &UniString,
                                               0,
                                               REG_DWORD,
                                               &ultemp,
                                               sizeof(ultemp));
        
                        // Restore the lastwritetime of the key
                        if (NT_SUCCESS(SubStatus)) {
                            NtSetInformationKey(hNewKey,
                                                KeyWriteTimeInformation,
                                                &pKeyInfo->LastWriteTime,
                                                sizeof(pKeyInfo->LastWriteTime));
                        }
                    }  

                    // Free up our buffer
                    RtlFreeHeap(RtlProcessHeap(), 0, pKeyInfo);
                }

            // For install mode, delete our copy of the key
            } else {
                Status = NtDeleteKey( hNewKey );
            }
            NtClose( hNewKey );
        }
    }

    if (pUserPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, pUserPath);
    }
    
    if (wcbuff) {
        RtlFreeHeap(RtlProcessHeap(), 0, wcbuff);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*****************************************************************************
 *
 *  TermsrvDeleteValue
 *
 *   Delete the registry value in the citrix install user section of the 
 *   registry.
 *
 * ENTRY:
 *  HANDLE hKey:               Handle of key in install section
 *  PUNICODE_STRING pUniValue: Ptr to unicode value name to delete
 *
 * EXIT:
 *  TRUE: Entry deleted in install section
 *  FALSE: Entry not created
 *
 ****************************************************************************/

BOOL TermsrvDeleteValue(HANDLE hKey,
                    PUNICODE_STRING pUniValue)
{
    NTSTATUS Status;        
    OBJECT_ATTRIBUTES ObjectAttr;
    WCHAR wcUserPath[MAX_PATH*2];
    PWCHAR wcInstPath = NULL;
    UNICODE_STRING UniString;
    HANDLE  hInstKey;

    // If not in install mode, return
    if ( !TermsrvAppInstallMode() ) {
        return(FALSE);
    }

    // Get the path to the key in the user section
    Status = TermsrvGetRegPath(hKey,
                           NULL,
                           wcUserPath,
                           sizeof(wcUserPath)/sizeof(WCHAR));

    if (NT_SUCCESS(Status)) {

        // Get the corresponding path in the install section
        Status = TermsrvGetInstallPath(wcUserPath,
                                   &wcInstPath);

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&UniString, wcInstPath);
            InitializeObjectAttributes(&ObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            // Open the install path key to delete the value
            Status = NtOpenKey(&hInstKey,
                               MAXIMUM_ALLOWED,
                               &ObjectAttr);

            // Delete the value
            if (NT_SUCCESS(Status)) {
                Status = NtDeleteValueKey(hInstKey,
                                          pUniValue);
                NtClose( hInstKey );
            }
        }
    }
    
    if (wcInstPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, wcInstPath);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*****************************************************************************
 *
 *  TermsrvRestoreKey
 *
 *   If the system is in installation mode and the application is trying to
 *   restore a key into the user or machine section of the registry, also
 *   restore the key into our install section.
 *
 * ENTRY:
 *  HANDLE hKey:  Handle of key in user section
 *  HANDLE hFile: Handle of file to load in
 *  ULONG Flags:  Restore key flags
 *
 * EXIT:
 *  TRUE: Entry created in install section
 *  FALSE: Entry not created
 *
 ****************************************************************************/

BOOL TermsrvRestoreKey(IN HANDLE hKey,
                   IN HANDLE hFile,
                   IN ULONG Flags)
{
    NTSTATUS Status;        
    OBJECT_ATTRIBUTES ObjectAttr;
    WCHAR wcUserPath[MAX_PATH*2];
    PWCHAR wcInstPath = NULL;
    UNICODE_STRING UniString;
    HANDLE  hInstKey;

    // If not in install mode or it's
    // a memory only restore, return
    if ( !TermsrvAppInstallMode() ||
        (Flags & REG_WHOLE_HIVE_VOLATILE)) {
        return(FALSE);
    }

    // Get the path to the key in the user section
    Status = TermsrvGetRegPath(hKey,
                           NULL,
                           wcUserPath,
                           sizeof(wcUserPath)/sizeof(WCHAR));

    if (NT_SUCCESS(Status)) {

        // Get the corresponding path in the install section
        Status = TermsrvGetInstallPath(wcUserPath,
                                   &wcInstPath);

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&UniString, wcInstPath);
            InitializeObjectAttributes(&ObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            // Open the install path key to load the key into
            Status = NtOpenKey(&hInstKey,
                               KEY_WRITE,
                               &ObjectAttr);

            // If we couldn't open it, try creating the key
            if (!NT_SUCCESS(Status)) {
                Status = TermsrvCreateKey(wcUserPath, 
                                      wcInstPath,
                                      TRUE,
                                      FALSE,
                                      &hInstKey);
            }

            // Restore the key into the user section
            if (NT_SUCCESS(Status)) {
                Status = NtRestoreKey(hInstKey,
                                      hFile,
                                      Flags);
                NtClose( hInstKey );

                // Update the registry entry for the last time a registry
                // entry was added
                if (NT_SUCCESS(Status)) {
                    TermsrvLogRegInstallTime();
                }
            }
        }
    }
    
    if (wcInstPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, wcInstPath);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*****************************************************************************
 *
 *  TermsrvSetKeySecurity
 *
 *   If the system is in installation mode and the application is trying to
 *   set the security of an entry in the the user or machine section of the 
 *   registry, also set the security of the key in the install section.
 *
 * ENTRY:
 *  HANDLE hKey:                   Handle in user section to set security
 *  SECURITY_INFORMATION SecInfo:  Security info struct
 *  PSECURITY_DESCRIPTOR pSecDesc: Ptr to security descriptor
 *
 * EXIT:
 *  TRUE:  Security set in install section
 *  FALSE: Error
 *
 ****************************************************************************/

BOOL TermsrvSetKeySecurity(IN HANDLE hKey,  
                       IN SECURITY_INFORMATION SecInfo,
                       IN PSECURITY_DESCRIPTOR pSecDesc)
{
    NTSTATUS Status;        
    OBJECT_ATTRIBUTES ObjectAttr;
    WCHAR wcUserPath[MAX_PATH*2];
    PWCHAR wcInstPath = NULL;
    UNICODE_STRING UniString;
    HANDLE  hInstKey;

    // If not in install mode, return
    if ( !TermsrvAppInstallMode() ) {
        return(FALSE);
    }

    // Get the path to the key in the user section
    Status = TermsrvGetRegPath(hKey,
                           NULL,
                           wcUserPath,
                           sizeof(wcUserPath)/sizeof(WCHAR));

    if (NT_SUCCESS(Status)) {

        // Get the corresponding path in the install section
        Status = TermsrvGetInstallPath(wcUserPath,
                                   &wcInstPath);

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&UniString, wcInstPath);
            InitializeObjectAttributes(&ObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            // Open the install path key to load the key into
            Status = NtOpenKey(&hInstKey,
                               KEY_WRITE | WRITE_OWNER | WRITE_DAC,
                               &ObjectAttr);

            // Set the security
            if (NT_SUCCESS(Status)) {

                Status = NtSetSecurityObject(hKey,
                                             SecInfo,
                                             pSecDesc);
                NtClose( hInstKey );
            }
        }
    }
    
    if (wcInstPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, wcInstPath);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}



/*****************************************************************************
 *
 *  TermsrvGetRegPath
 *
 *   From the handle or a pointer to the object attributes, return the
 *   object's path in the registry.
 *
 * ENTRY:
 *  HANDLE hKey:       Handle of an open key to get the path of
 *  POBJECT_ATTRIBUTES Ptr to open attribute structure to get the path of
 *  PWCHAR pInstPath   Ptr to return buffer
 *  ULONG  ulbuflen    Length of return buffer
 *
 * NOTES:
 *  Either hKey or pObjectAttr must be specified, but not both.
 *
 * EXIT:
 *  NTSTATUS return code
 *
 ****************************************************************************/

NTSTATUS TermsrvGetRegPath(IN HANDLE hKey,
                       IN POBJECT_ATTRIBUTES pObjectAttr,
                       IN PWCHAR pUserPath,
                       IN ULONG  ulbuflen)
{
    NTSTATUS Status = STATUS_SUCCESS;             
    ULONG ultemp;
    ULONG ulWcharLength;          //Keep track of the WCHAR string length
    PWCHAR pwch;
    PVOID  pBuffer = NULL;

    // Make sure only one of hKey or pObjectAttr was specified
    if ((hKey && pObjectAttr) || (!hKey && !pObjectAttr)) {
        return(STATUS_INVALID_PARAMETER);
    }

    // A key handle or root directory was specified, so get its path
    if (hKey || (pObjectAttr && pObjectAttr->RootDirectory)) {
        ultemp = sizeof(UNICODE_STRING) + sizeof(WCHAR)*MAX_PATH*2;
        pBuffer = RtlAllocateHeap(RtlProcessHeap(), 
                                  0, 
                                  ultemp);

        // Got the buffer OK, query the path
        if (pBuffer) {
            // Get the path for key or root directory
            Status = NtQueryObject(hKey ? hKey : pObjectAttr->RootDirectory,
                                   ObjectNameInformation,
                                   (PVOID)pBuffer,
                                   ultemp,
                                   NULL);
            if (!NT_SUCCESS(Status)) {
                RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
                return(Status);
            }
        } else {
            return(STATUS_NO_MEMORY);
        }

        // Build the full path to the key to be created
        pwch = ((PUNICODE_STRING)pBuffer)->Buffer;

        // BBUG 417564. Bad apps close HKLM, but we might need it here.
        if (!pwch) {
            RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
            return(STATUS_INVALID_HANDLE); 
        }

        // Make sure the string is zero terminated
        ulWcharLength = ((PUNICODE_STRING)pBuffer)->Length / sizeof(WCHAR); 
        pwch[ulWcharLength] = 0;                   

        // If using Object Attributes and there's room, tack on the object name 
        if (pObjectAttr) {
            if ((((PUNICODE_STRING)pBuffer)->Length + 
                  pObjectAttr->ObjectName->Length + sizeof(WCHAR)) < ultemp) {
                wcscat(pwch, L"\\");
                //Increment the length of the string
                ulWcharLength += 1;
                //Append the relative path to the root path (Don't use wcscat. The string may not
                // be zero terminated
                wcsncpy(&pwch[ulWcharLength], pObjectAttr->ObjectName->Buffer, pObjectAttr->ObjectName->Length / sizeof (WCHAR));
                // Make sure the string is zero terminated
                ulWcharLength += (pObjectAttr->ObjectName->Length / sizeof(WCHAR));
                pwch[ulWcharLength] = 0;
            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }

    } else {

        // No root directory, they specified the entire path
        pwch = pObjectAttr->ObjectName->Buffer;
        //Make sure it is zero terminated
        pwch[pObjectAttr->ObjectName->Length / sizeof(WCHAR)] = 0;
    }

    // Make sure the path will fit in the buffer
    if ((Status == STATUS_SUCCESS) && 
        (wcslen(pwch)*sizeof(WCHAR) < ulbuflen)) {
        wcscpy(pUserPath, pwch);
    } else {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    if (pBuffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
    }

    return(Status);
}

/*****************************************************************************
 *
 *  TermsrvGetInstallPath
 *
 *   From the path to the user entry in the registry, get the path to the
 *   entry in the default install section.
 *
 * ENTRY:
 *  IN PWCHAR pUserPath:    Ptr to path of key in user section
 *  IN PWCHAR *ppInstPath:    Ptr to ptr to return path of key in install section
 *
 * NOTES:
 *  Caller must use RtlFreeHeap to free memory allocated for ppInstPath!
 *
 * EXIT:
 *  NTSTATUS return code
 *
 ****************************************************************************/

NTSTATUS TermsrvGetInstallPath(IN PWCHAR pUserPath,
                           IN PWCHAR *ppInstPath)
{
    NTSTATUS Status = STATUS_NO_SUCH_FILE;
    PWCHAR pwch = NULL;
    BOOL fUserReg;
    BOOL bClassesKey = FALSE;
    
    *ppInstPath = NULL;

    // Check if the app is accessing the user or local machine section
    pwch = GetUserSWKey(pUserPath, &fUserReg, &bClassesKey);
           
    // Copy the path to the user's buffer
    if (pwch || bClassesKey) 
    {
        ULONG  ulInstBufLen = ( wcslen(TERMSRV_INSTALL) + wcslen(SOFTWARE_PATH) + wcslen(CLASSES_PATH) +  1 )*sizeof(WCHAR);
        if (pwch)
            ulInstBufLen += wcslen(pwch) * sizeof(WCHAR);

        *ppInstPath = RtlAllocateHeap(RtlProcessHeap(), 
                                0, 
                                ulInstBufLen);
        if(*ppInstPath) {

            wcscpy(*ppInstPath, TERMSRV_INSTALL);
            if (bClassesKey)
            {
                wcscat(*ppInstPath, SOFTWARE_PATH);
                wcscat(*ppInstPath, CLASSES_PATH);
            }
            if (pwch)
                wcscat(*ppInstPath, pwch);

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_NO_MEMORY;
        }
    }

    return(Status);
}


/*****************************************************************************
 *
 *  TermsrvCreateKey
 *
 *  This routine will create (or open) the specified path in the registry.
 *  If the path doesn't exist in the registry, it will be created.
 *
 * ENTRY:
 *   PWCHAR pSrcPath:      Source path to copy keys from (optional)
 *   PWCHAR pDstPath:      Destination path to create
 *   BOOL   fCloneValues:  TRUE means to clone all values under this key
 *   BOOL   fCloneSubKeys: TRUE means to create all subkeys under this key
 *   PHANDLE phKey:        Pointer for key created
 *
 * EXIT:
 *   NTSTATUS return code
 *
 ****************************************************************************/

NTSTATUS TermsrvCreateKey(IN PWCHAR pSrcPath,
                      IN PWCHAR pDstPath,
                      BOOL fCloneValues,
                      BOOL fCloneSubKeys,
                      OUT PHANDLE phKey)
{
    NTSTATUS Status;
    PWCHAR pSource = NULL, pDest = NULL;
    HANDLE hDstKey, hDstRoot, hSrcKey, hSrcRoot;
    ULONG  ultemp, NumSubKeys, ulcnt, ulbufsize, ulkey;
    UNICODE_STRING    UniString, UniClass;
    OBJECT_ATTRIBUTES ObjectAttr;
    PKEY_FULL_INFORMATION pDefKeyInfo = NULL;
    ULONG aulbuf[4];
    PKEY_VALUE_PARTIAL_INFORMATION pValKeyInfo = 
        (PKEY_VALUE_PARTIAL_INFORMATION)aulbuf;
    BOOL fClassesKey = FALSE, fUserReg;

    // Check if we are trying to copy values into the user's registry
    pDest = GetUserSWKey(pDstPath, &fUserReg, NULL);
    if (fUserReg) {
        if (fCloneValues || fCloneSubKeys) {

            // Skip to software section of the default install user
            pSource = pSrcPath + wcslen(TERMSRV_INSTALL);

            // If copying CLASSES, set Clone to FALSE so don't clone
            // until we're at the CLASSES key

            // Actually, this func is not called for copying classes, I belive that feature is/was 
            // turned off in W2K, which means that any time this func is called, we for sure are 
            // dealing with either HKCU\SW or HKLM, but never HKCU\SW\Clasess.
            // Nov 30, 2000
            //
            if (pDest)
            {
                if (!_wcsnicmp(pDest,
                              TERMSRV_SOFTWARECLASSES,
                              wcslen(TERMSRV_SOFTWARECLASSES))) {
                   fClassesKey = TRUE;
                   fCloneValues = fCloneSubKeys = FALSE;
                }
            }
        }

    // Trying to copy to citrix install section?
    } else if (!_wcsnicmp(pDstPath,
                         TERMSRV_INSTALL,
                         wcslen(TERMSRV_INSTALL))) {

        // Skip to software section of the default install user
        pDest = pDstPath + wcslen(TERMSRV_INSTALL);

        // If copying from MACHINE\..\CLASSES, set Clone values to FALSE
        // so we don't clone until we're at the CLASSES key.
        if (pSrcPath && !_wcsnicmp(pSrcPath,
                                  TERMSRV_CLASSES,
                                  wcslen(TERMSRV_CLASSES))) {
            fClassesKey = TRUE;
            pSource = Ctxwcsistr(pSrcPath, SOFTWARE_PATH); 
            fCloneValues = fCloneSubKeys = FALSE;
        }
        // If we're cloning, set up the source path
        else if (fCloneValues || fCloneSubKeys) {

            // Is this from the user section?
            pSource = GetUserSWKey(pSrcPath, &fUserReg, NULL);

            // Must be from the local machine section
            if (!fUserReg) {
                pSource = Ctxwcsistr(pSrcPath, L"\\machine");
            }
        }
    }
                         
    // Make sure the paths are valid
    if (!pDest || ((fCloneValues || fCloneSubKeys) && !pSource)) {
        return(STATUS_NO_SUCH_FILE);
    }

    // Initialize the number of subkeys to be created
    NumSubKeys = 1;

    while ((pDest = wcschr(pDest, L'\\')) != NULL) {
        *pDest = L'\0';
        pDest++;
        NumSubKeys++;
    }

    // If we need to clone values or keys from the source path, get the
    // buffers we'll need, and tokenize the source path
    if (fCloneValues || fCloneSubKeys || fClassesKey) {

        // Allocate a buffer for the class of the source key
        ulbufsize = sizeof(KEY_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR);
        pDefKeyInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                      0, 
                                      ulbufsize);
        if (pDefKeyInfo) {
            while ((pSource = wcschr(pSource, L'\\')) != NULL) {
                *pSource = L'\0';
                pSource++;
            }
            pSource = pSrcPath;
        } else {
            fCloneValues = fCloneSubKeys = fClassesKey = FALSE;
        }
    }

    hSrcRoot = hDstRoot = NULL;
    pDest = pDstPath;

    // Go through each key in the path, creating it if it doesn't exist
    for (ulcnt = 0; ulcnt < NumSubKeys; ulcnt++) {

        if ((*pDest == L'\0') &&
            (ulcnt != NumSubKeys - 1)) {
            pDest++;
            pSource++;
            continue;
        } 
        // If we're at CLASSES key, we need to clone the whole key
        else if (fClassesKey && !_wcsicmp(pDest, L"classes")) {
            fCloneValues = fCloneSubKeys = TRUE;
        }  

        // If we're copying values from the source, open up the source so we
        // can get the values and subkeys
        // Also need to check for ClassesKey cause we'll be cloning later and
        // we need some setup done
        if (fCloneValues || fCloneSubKeys || fClassesKey) {

            // Set up the attribute structure for the source path
            RtlInitUnicodeString(&UniString, pSource);
            InitializeObjectAttributes(&ObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       hSrcRoot,
                                       NULL);

            // Open the source key
            Status = NtOpenKey(&hSrcKey, 
                               KEY_READ,
                               &ObjectAttr);

            // Get the source key info and value
            if (NT_SUCCESS(Status)) {
                // Close the source root, if necessary
                if (hSrcRoot) {
                    NtClose(hSrcRoot);
                }
                hSrcRoot = hSrcKey;

                Status = NtQueryKey(hSrcKey,
                                    KeyFullInformation,
                                    pDefKeyInfo,
                                    ulbufsize,
                                    &ultemp);

                if (NT_SUCCESS(Status)) {
                    RtlInitUnicodeString(&UniString, TERMSRV_COPYONCEFLAG);
                    Status = NtQueryValueKey(hSrcKey,
                                             &UniString,
                                             KeyValuePartialInformation,
                                             pValKeyInfo,
                                             sizeof(aulbuf),
                                             &ultemp);
                    if (NT_SUCCESS(Status) && (pValKeyInfo->Data)) {
                        break;
                    }
                }
            } else {
                break;
            }

            // Setup the unicode string for the class
            if ( pDefKeyInfo->ClassLength ) { 
                pDefKeyInfo->Class[pDefKeyInfo->ClassLength/sizeof(WCHAR)] = UNICODE_NULL;
                RtlInitUnicodeString(&UniClass, pDefKeyInfo->Class );
            } else
                RtlInitUnicodeString(&UniClass, NULL);

            // Advance to the next key
            pSource += wcslen( pSource ) + 1;
        } else {
            // Set the class to NULL
            RtlInitUnicodeString(&UniClass, NULL);
        }

        // Set up the attribute structure for the destination
        RtlInitUnicodeString(&UniString, pDest);
        InitializeObjectAttributes(&ObjectAttr,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   hDstRoot,
                                   NULL);
                       
        // Open/Create the destination key
        Status = NtCreateKey(&hDstKey,
                             MAXIMUM_ALLOWED,
                             &ObjectAttr,
                             0,
                             &UniClass,
                             REG_OPTION_NON_VOLATILE,
                             &ultemp);

        // If the key was created (NOT opened) copy the values and subkeys
        if (NT_SUCCESS(Status) && 
            ((ultemp == REG_CREATED_NEW_KEY) && 
             (fCloneSubKeys || fCloneValues))) {
            Status = TermsrvCloneKey(hSrcKey,
                                 hDstKey,
                                 pDefKeyInfo,
                                 fCloneSubKeys);
        }

        // Close the intermediate key.
        if( hDstRoot != NULL ) {
            NtClose( hDstRoot );
        }

        // Initialize the next object directory (i.e. parent key) 
        hDstRoot = hDstKey;

        // If creating the key failed, break out of the loop
        if( !NT_SUCCESS( Status )) {
            break;
        }

        pDest += wcslen( pDest ) + 1;
    }

    // Close the source root, if necessary
    if (hSrcRoot) {
        NtClose(hSrcRoot);
    }

    if ( !NT_SUCCESS( Status ) && hDstRoot) {
        NtClose(hDstRoot);
        hDstKey = NULL;
    }

    if (pDefKeyInfo) {
        RtlFreeHeap(RtlProcessHeap(), 0, pDefKeyInfo);
    }

    *phKey = hDstKey;
    return(Status);
}


/*****************************************************************************
 *
 *  TermsrvCloneKey
 *
 *  This routine will recursively create (or open) the specified path in the 
 *  registry.  If the path doesn't exist in the registry, it will be created.
 *
 * ENTRY:
 *  HANDLE hSrcKey:  Handle for source key
 *  HANDLE hDstKey:  Handle for destination key
 *  PKEY_FULL_INFORMATION pDefKeyInfo:  Ptr to key info structure of source
 *  BOOL fCreateSubKeys: TRUE means to recursively clone subkeys
 *
 * EXIT:
 *   NTSTATUS return code
 *
 ****************************************************************************/

NTSTATUS TermsrvCloneKey(HANDLE hSrcKey,
                     HANDLE hDstKey,
                     PKEY_FULL_INFORMATION pDefKeyInfo,
                     BOOL fCreateSubKeys)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulbufsize, ultemp, ulkey, ulcursize;
    UNICODE_STRING    UniString, UniClass;
    OBJECT_ATTRIBUTES ObjectAttr;
    PKEY_NODE_INFORMATION pKeyNodeInfo;
    PKEY_VALUE_FULL_INFORMATION pKeyValInfo;
    PKEY_VALUE_BASIC_INFORMATION pKeyCurInfo;
    PKEY_FULL_INFORMATION pKeyNewInfo;
    HANDLE hNewDst, hNewSrc;
    SECURITY_DESCRIPTOR SecDesc;

#ifdef CLONE_SECURITY
    // Get the security access for the source key
    Status = NtQuerySecurityObject(hSrcKey,
                                   OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION  |
                                    SACL_SECURITY_INFORMATION,
                                   &SecDesc,
                                   sizeof(SecDesc),
                                   &ultemp);

    // Set the security access for the destination key
    if (NT_SUCCESS(Status)) {
        Status = NtSetSecurityObject(hDstKey,
                                     OWNER_SECURITY_INFORMATION |
                                      GROUP_SECURITY_INFORMATION |
                                      DACL_SECURITY_INFORMATION  |
                                      SACL_SECURITY_INFORMATION,
                                     &SecDesc);
    }
#endif

    // Create the values for this key
    if (pDefKeyInfo->Values) {

        ulbufsize = sizeof(KEY_VALUE_FULL_INFORMATION) + 
                    (pDefKeyInfo->MaxValueNameLen + 1)*sizeof(WCHAR) +
                    pDefKeyInfo->MaxValueDataLen; 
    
        pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                      0, 
                                      ulbufsize);

        // Get a buffer to hold current value of the key (for existance check)
        ulcursize = sizeof(KEY_VALUE_BASIC_INFORMATION) + 
                    (pDefKeyInfo->MaxNameLen + 1)*sizeof(WCHAR);

        pKeyCurInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                      0, 
                                      ulcursize);

        if (pKeyValInfo && pKeyCurInfo) {
            for (ulkey = 0; ulkey < pDefKeyInfo->Values; ulkey++) {
                Status = NtEnumerateValueKey(hSrcKey,
                                             ulkey,
                                             KeyValueFullInformation,
                                             pKeyValInfo,
                                             ulbufsize,
                                             &ultemp);

                // If successful and this isn't our "copy once" flag, copy
                // the value to the user's keys
                if (NT_SUCCESS(Status) &&
                    (wcsncmp(pKeyValInfo->Name, TERMSRV_COPYONCEFLAG,
                             sizeof(TERMSRV_COPYONCEFLAG)/sizeof(WCHAR)-1))) {
                    UniString.Buffer = pKeyValInfo->Name;
                    UniString.Length = (USHORT)pKeyValInfo->NameLength;
                    UniString.MaximumLength = UniString.Length + 2;

                    // Check if the value exists
                    Status = NtQueryValueKey(hDstKey,
                                             &UniString,
                                             KeyValueBasicInformation,
                                             pKeyCurInfo,
                                             ulcursize,
                                             &ultemp);

                    // Value doesn't exist, go ahead and create it
                    if (!NT_SUCCESS(Status)) {
                        Status = NtSetValueKey(hDstKey,
                                               &UniString,
                                               0,
                                               pKeyValInfo->Type,
                                               (PCHAR)pKeyValInfo + 
                                                 pKeyValInfo->DataOffset,
                                               pKeyValInfo->DataLength);
                    }
                }
            }
            RtlFreeHeap(RtlProcessHeap(), 0, pKeyValInfo);
            RtlFreeHeap(RtlProcessHeap(), 0, pKeyCurInfo);
        } else {
            if (pKeyValInfo) {
                RtlFreeHeap(RtlProcessHeap(), 0, pKeyValInfo);
            }
            Status = STATUS_NO_MEMORY;
        }
    }

    // If requested, create all of the child keys
    if (fCreateSubKeys && pDefKeyInfo->SubKeys) {

        // Allocate a buffer to get name and class of key to create
        ulbufsize = sizeof(KEY_NODE_INFORMATION) + 2*MAX_PATH*sizeof(WCHAR);
        pKeyNodeInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                       0, 
                                       ulbufsize);

        // Allocate a buffer for subkey info
        ulbufsize = sizeof(KEY_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR);
        pKeyNewInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                      0, 
                                      ulbufsize);
    
        if (pKeyNodeInfo && pKeyNewInfo) {
            for (ulkey = 0; ulkey < pDefKeyInfo->SubKeys; ulkey++) {
                Status = NtEnumerateKey(hSrcKey,
                                        ulkey,
                                        KeyNodeInformation,
                                        pKeyNodeInfo,
                                        ulbufsize,
                                        &ultemp);
    
                if (NT_SUCCESS(Status)) {
                    // Init the unicode string for the class
                    UniClass.Buffer = (PWCHAR)((PCHAR)pKeyNodeInfo + 
                                               pKeyNodeInfo->ClassOffset);
                    UniClass.Length = (USHORT)pKeyNodeInfo->ClassLength;
                    UniClass.MaximumLength = UniString.Length + 2;
    
                    // Init the unicode string for the name
                    UniString.Buffer = pKeyNodeInfo->Name;
                    UniString.Length = (USHORT)pKeyNodeInfo->NameLength;
                    UniString.MaximumLength = UniString.Length + 2;
            
                    InitializeObjectAttributes(&ObjectAttr,
                                               &UniString,
                                               OBJ_CASE_INSENSITIVE,
                                               hDstKey,
                                               NULL);
                                   
                    Status = NtCreateKey(&hNewDst,
                                         MAXIMUM_ALLOWED,
                                         &ObjectAttr,
                                         0,
                                         &UniClass,
                                         REG_OPTION_NON_VOLATILE,
                                         &ultemp);
    
                    if (NT_SUCCESS(Status)) {
                        InitializeObjectAttributes(&ObjectAttr,
                                                   &UniString,
                                                   OBJ_CASE_INSENSITIVE,
                                                   hSrcKey,
                                                   NULL);
            
                        Status = NtOpenKey(&hNewSrc, 
                                           KEY_READ,
                                           &ObjectAttr);
            
                        // Get the key info
                        if (NT_SUCCESS(Status)) {
                            Status = NtQueryKey(hNewSrc,
                                                KeyFullInformation,
                                                pKeyNewInfo,
                                                ulbufsize,
                                                &ultemp);

                            if (NT_SUCCESS(Status) &&
                                (pKeyNewInfo->SubKeys || 
                                 pKeyNewInfo->Values)) {
                                Status = TermsrvCloneKey(hNewSrc, 
                                                     hNewDst, 
                                                     pKeyNewInfo, 
                                                     TRUE);
                            }
                            NtClose(hNewSrc);
                        }
                        NtClose(hNewDst);
                    }
                }
            }
            RtlFreeHeap(RtlProcessHeap(), 0, pKeyNodeInfo);
            RtlFreeHeap(RtlProcessHeap(), 0, pKeyNewInfo);
        } else {
            if (pKeyNodeInfo) {
                RtlFreeHeap(RtlProcessHeap(), 0, pKeyNodeInfo);
            }
            Status = STATUS_NO_MEMORY;
        }
    }
    return(Status);
}


/*****************************************************************************
 *
 *  Ctxwcsistr
 *
 *  This is a case insensitive version of wcsstr.
 *
 * ENTRY:
 *   PWCHAR pstring1 (In) - String to search in
 *   PWCHAR pstring2 (In) - String to search for
 *
 * EXIT:
 *   Success: 
 *       pointer to substring
 *   Failure: 
 *       NULL
 *
 ****************************************************************************/

PWCHAR 
Ctxwcsistr(PWCHAR pstring1,
           PWCHAR pstring2)
{
    PWCHAR pch, ps1, ps2;

    pch = pstring1;

    while (*pch)
    {
        ps1 = pch;
        ps2 = pstring2;
     
        while (*ps1 && *ps2 && !(towupper(*ps1) - towupper(*ps2))) {
            ps1++;
            ps2++;
        }
     
        if (!*ps2) {
            return(pch);
        }
     
        pch++;
    }
    return(NULL);
}


/*****************************************************************************
 *
 *  IsSystemLUID
 *
 *  This routines checks if we are running under the system context, and if
 *  so returns false.  We want all of the registry mapping support disable
 *  for system services.
 *
 *  Note we don't check the thread's token, so impersonation doesn't work.
 *
 * ENTRY:
 *
 * EXIT:
 *   TRUE:
 *       Called from within system context
 *   FALSE:   
 *       Regular context
 *
 ****************************************************************************/

#define SIZE_OF_STATISTICS_TOKEN_INFORMATION    \
     sizeof( TOKEN_STATISTICS ) 

BOOL IsSystemLUID(VOID)
{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_STATISTICS_TOKEN_INFORMATION ];
    ULONG       ReturnLength;
    static LUID CurrentLUID = { 0, 0 };
    LUID        SystemLUID = SYSTEM_LUID;

    if ( CurrentLUID.LowPart == 0 && CurrentLUID.HighPart == 0 ) {
        if ( !OpenProcessToken( GetCurrentProcess(),
                                TOKEN_READ,
                                &TokenHandle ))
        {
            return(TRUE);
        }
    
        if ( !GetTokenInformation( TokenHandle,
                                   TokenStatistics,
                                   TokenInformation,
                                   sizeof( TokenInformation ),
                                   &ReturnLength ))
        {
            return(TRUE);
        }
    
        CloseHandle( TokenHandle );

        RtlCopyLuid(&CurrentLUID, 
                    &(((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId));
    }

    if (RtlEqualLuid(&CurrentLUID, &SystemLUID)) {
        return(TRUE);
    } else {
        return(FALSE );
    }
}


/*****************************************************************************
 *
 *  TermsrvLogRegInstallTime
 *
 *  This routines updates the LatestRegistryKey value in the registry to
 *  contain the current time.
 *
 * ENTRY:
 *
 * EXIT:
 *   No return value
 *
 ****************************************************************************/

void TermsrvLogRegInstallTime()
{
    UNICODE_STRING UniString;
    HANDLE hKey;
    FILETIME FileTime;
    ULONG ultmp;
    NTSTATUS Status;
    WCHAR wcbuff[MAX_PATH];

    // Open up the registry key to store the last write time of the file
    wcscpy(wcbuff, TERMSRV_INIFILE_TIMES);

    // Create or open the path to the IniFile Times key
    Status = TermsrvCreateKey(NULL,
                          wcbuff,
                          FALSE,
                          FALSE,
                          &hKey);

    // Opened up the registry key, now set the value to the current time
    if (NT_SUCCESS(Status)) {

        GetSystemTimeAsFileTime(&FileTime);
        RtlTimeToSecondsSince1970((PLARGE_INTEGER)&FileTime,
                                  &ultmp);

        RtlInitUnicodeString(&UniString,
                             INIFILE_TIMES_LATESTREGISTRYKEY);

        // Now store it under the citrix key in the registry
        Status = NtSetValueKey(hKey,
                               &UniString,
                               0,
                               REG_DWORD,
                               &ultmp,
                               sizeof(ultmp));
        // Close the registry key
        NtClose(hKey);
    }
}

/*****************************************************************************
 *
 *  TermsrvOpenUserClasses
 *
 *   If the system is in execute mode, open \SOFTWARE\CLASSES key under 
 *   HKEY_CURRENT_USER.  If CLASSES doesen't exist under TERMSRV\INSTALL
 *   or HKEY_CURRENT_USER, copy it from \MACHINE\SOFTWARE\CLASSES.  
 *
 * ENTRY:
 *  IN ACCESS_MASK DesiredAccess:
 *      Desired access to the key
 *  OUT PHANDLE phKey:
 *      Pointer to return key handle if opened
 *
 * EXIT:
 *  NT_STATUS return code 
 *
 ****************************************************************************/

BOOL TermsrvOpenUserClasses(IN ACCESS_MASK DesiredAccess, 
                        OUT PHANDLE pUserhKey) 
{
    NTSTATUS Status;        
    ULONG ultemp;
    ULONG ulAppType = TERMSRV_COMPAT_WIN32;
    HKEY   hDstKey;
    WCHAR  wcbuff[MAX_PATH],wcClassbuff[TERMSRV_CLASSES_SIZE];
    PWCHAR pUserPath;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UniString;

    // set return handle to 0 cause OpenClassesRoot checks it
    *pUserhKey = 0;
    

    //Disable it for now
    return(STATUS_NO_SUCH_FILE);
    
        
        // If called under a system service or  in install mode, return
    if ( IsSystemLUID() || TermsrvAppInstallMode() ) {
        return(STATUS_NO_SUCH_FILE);
    }

    // If mapping is on, but disabled for CLASSES, return
    GetTermsrCompatFlags(TERMSRV_CLASSES, &ultemp, CompatibilityRegEntry);
    if ((ultemp & (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) ==
        (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) {
        return(STATUS_NO_SUCH_FILE);
    }


    // Open MACHINE\SOFTWARE\CLASSES key
    RtlInitUnicodeString(&UniString, TERMSRV_CLASSES);
    InitializeObjectAttributes(
        &Obja,
        &UniString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&hDstKey,
                       KEY_READ,
                       &Obja);

    if (!NT_SUCCESS(Status)) {
        return(STATUS_NO_SUCH_FILE);
    }

    NtClose(hDstKey);

    // Need to put this in buffer cause CtxCreateKey modifies the string.
    wcscpy(wcClassbuff, TERMSRV_CLASSES);

    // Try to open TERMSRV\INSTALL\SOFTWARE\CLASSES; if it doesn't exist,
    // clone it from MACHINE\SOFTWARE\CLASSES.
    wcscpy(wcbuff, TERMSRV_INSTALLCLASSES);
    Status = TermsrvCreateKey(wcClassbuff,
                          wcbuff,
                          TRUE,
                          TRUE,
                          &hDstKey);
    
    if (NT_SUCCESS(Status)) {
        NtClose(hDstKey);
    }

    // Try to open HKEY_CURRENT_USER\SOFTWARE\CLASSES; if it doesn't exist,
    // clone it from TERMSRV\INSTALL\SOFTWARE\CLASSES.
    Status = RtlOpenCurrentUser( DesiredAccess, pUserhKey );

    if (NT_SUCCESS(Status)) {
       ultemp = sizeof(WCHAR)*MAX_PATH;
       Status = TermsrvGetRegPath(*pUserhKey,
                              NULL,
                              (PWCHAR)&wcbuff,
                              ultemp);
       NtClose(*pUserhKey);
       if (NT_SUCCESS(Status)) {
          wcscat(wcbuff, TERMSRV_SOFTWARECLASSES);
          wcscpy(wcClassbuff, TERMSRV_INSTALLCLASSES);
          Status = TermsrvCreateKey(wcClassbuff,
                                wcbuff,
                                TRUE,
                                TRUE,
                                pUserhKey);
       }
    }

    return(Status);
}

/*****************************************************************************
 *
 *  TermsrvGetPreSetValue
 *
 *   Get any preset value during install.
 *
 * ENTRY:
 *  
 *  IN HANDLE hKey:               Key user wants to set
 *  IN PUNICODE_STRING pValueName: Value name user wants to set
 *  IN ULONG  Type:               Type of value
 *  OUT PVOID *Data:              Pre-set data
 *  OUT PULONG DataSize:          Size of preset data
 *
 * NOTES:
 *
 * EXIT:
 *  NTSTATUS return code
 *
 ****************************************************************************/

NTSTATUS TermsrvGetPreSetValue(  IN HANDLE hKey,
                             IN PUNICODE_STRING pValueName,
                             IN ULONG  Type,
                            OUT PVOID *Data
                           )
{

#define DEFAULT_VALUE_SIZE          128

    NTSTATUS Status = STATUS_NO_SUCH_FILE;
    PWCHAR pwch = NULL;
    WCHAR pUserPath[MAX_PATH];
    WCHAR ValuePath[2 * MAX_PATH];
    ULONG ultemp;
    UNICODE_STRING UniString;
    OBJECT_ATTRIBUTES Obja;
    ULONG BufferLength;
    PVOID KeyValueInformation;
    ULONG ResultLength;
    HANDLE hValueKey;
    BOOL fUserReg;

    // If running in execute mode, return
    if ( !TermsrvAppInstallMode() ) {
        return(STATUS_NO_SUCH_FILE);
    }

    ultemp = sizeof(WCHAR)*MAX_PATH;

    // Get the path of this key
    Status = TermsrvGetRegPath(hKey,
                           NULL,
                           pUserPath,
                           ultemp);

    if (!NT_SUCCESS(Status)) 
        return Status;

    // Check if the app is accessing the local machine section
    // or the user section.

    pwch = GetUserSWKey(pUserPath, &fUserReg, NULL);
    if (!fUserReg) {
        if (!_wcsnicmp(pUserPath,
                       TERMSRV_VALUE,
                       wcslen(TERMSRV_VALUE))) {
            Status = STATUS_NO_SUCH_FILE;
            return Status;
        } else if (!_wcsnicmp(pUserPath,
                      TERMSRV_MACHINEREGISTRY,
                      wcslen(TERMSRV_MACHINEREGISTRY))) {
            pwch = Ctxwcsistr(pUserPath, L"\\machine");
        } else {
            Status = STATUS_NO_SUCH_FILE;
            return Status;
        }
    }

    if ( pwch == NULL )
    {
        Status = STATUS_NO_SUCH_FILE;
        return Status;
    }

    // Get the path to the preset value section

    wcscpy(ValuePath, TERMSRV_VALUE);
    wcscat(ValuePath, pwch);

    // Open Value key
    RtlInitUnicodeString(&UniString, ValuePath);

    InitializeObjectAttributes(
        &Obja,
        &UniString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&hValueKey,
                       KEY_READ,
                       &Obja);

    if (!NT_SUCCESS(Status)) {
        return(STATUS_NO_SUCH_FILE);
    }

    // Allocate space for the "new" value

    BufferLength = DEFAULT_VALUE_SIZE + sizeof( KEY_VALUE_PARTIAL_INFORMATION );

    KeyValueInformation = RtlAllocateHeap( RtlProcessHeap( ), 0, BufferLength );
    if ( !KeyValueInformation ) {
         NtClose(hValueKey);
         return STATUS_NO_MEMORY;
    }

    Status = NtQueryValueKey( hValueKey,
                              pValueName,
                              KeyValuePartialInformation,
                              KeyValueInformation,
                              BufferLength,
                              &ResultLength
                            );

    // If we didn't allocate enough space, try again

    if ( Status == STATUS_BUFFER_OVERFLOW ) {

        RtlFreeHeap(RtlProcessHeap(), 0, KeyValueInformation);

        BufferLength = ResultLength;

        KeyValueInformation = RtlAllocateHeap( RtlProcessHeap( ), 0,
                                               BufferLength
                                              );
        if ( !KeyValueInformation ) {
            NtClose(hValueKey);
            return STATUS_NO_MEMORY;
        }

        //
        // This one should succeed
        //

        Status = NtQueryValueKey( hValueKey,
                                  pValueName,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  BufferLength,
                                  &ResultLength
                                );
    }

    NtClose(hValueKey);

    if (!NT_SUCCESS(Status)) {
        Status = STATUS_NO_SUCH_FILE;
    }
    else
    {
        //
        // Make sure the types match.
        // If they do, return the new value.
        //

        if ( Type == (( PKEY_VALUE_PARTIAL_INFORMATION )
                                        KeyValueInformation )->Type )
            *Data = KeyValueInformation;
        else
            Status = STATUS_NO_SUCH_FILE;
    }

    return(Status);
}


/*****************************************************************************
 *
 *  IsUserSWPath
 *
 *   Determine if user is accessing registry key user \registry\user\xxx\software
 *
 * ENTRY:
 *  
 *  IN PWCHAR pPath:    Registry path to check
 *  OUT PBOOL pUserReg: If this key is under registry\user
 *
 * NOTES:
 *
 * EXIT:
 *  Returns: pointer to \software key of user registry (or NULL if not 
 *           user software key)
 *  pUserReg:  TRUE if registry path is HKCU (\registry\user)
 *
 ****************************************************************************/
PWCHAR GetUserSWKey(PWCHAR pPath, PBOOL pUserReg, PBOOL bClassesKey) 
{
    PWCHAR pwch = NULL;
    PWCHAR pwchClassesTest = NULL;
    PWCHAR pwClassesKey = NULL;
    ULONG ultemp = 0;
   
    if (pUserReg)
        *pUserReg = FALSE;

    if (bClassesKey)
        *bClassesKey = FALSE;

    if (!pPath)
        return NULL;

    if (!_wcsnicmp(pPath,                                              
                   TERMSRV_USERREGISTRY,                               
                   sizeof(TERMSRV_USERREGISTRY)/sizeof(WCHAR) - 1))
    {      
        if (pUserReg)
            *pUserReg = TRUE;

        // Skip over first part of path + backslash                   
        pwch = pPath + (sizeof(TERMSRV_USERREGISTRY)/sizeof(WCHAR)); 

        if (pwch)
        {
            //First test for classes
            if (wcschr(pwch, L'\\'))
                pwchClassesTest = wcschr(pwch, L'\\') - sizeof(CLASSES_SUBSTRING)/sizeof(WCHAR) + 1;
            else
                pwchClassesTest = pwch + wcslen(pwch) - sizeof(CLASSES_SUBSTRING)/sizeof(WCHAR) + 1;
            if (pwchClassesTest)
            {
                if (!_wcsnicmp(pwchClassesTest, CLASSES_SUBSTRING, sizeof(CLASSES_SUBSTRING)/sizeof(WCHAR) - 1))
                {
                    ultemp = sizeof(SOFTWARE_PATH) + sizeof(CLASSES_PATH) + (wcslen(pwch) + 1) * sizeof(WCHAR);
                    pwClassesKey = RtlAllocateHeap(RtlProcessHeap(), 0, ultemp);

                    // Depending on the result of this function the calling routine either sets the status
                    // to STATUS_NO_MORE_FILES or just return FALSE. So, if we return NULL here, we are fine.
                    if (!pwClassesKey)
                    return NULL;

                    wcscpy(pwClassesKey, SOFTWARE_PATH);
                    wcscat(pwClassesKey, CLASSES_PATH);

                    // Skip over user sid
                    pwch = wcschr(pwch, L'\\');        
                    if (pwch)
                        wcscat(pwClassesKey, pwch);
                    
                    if (RegPathExistsInOmissionList(pwClassesKey))
                        pwch = NULL;
                    else
                    {
                        if (bClassesKey)
                            *bClassesKey = TRUE;
                    }

                    if (pwClassesKey) 
                        RtlFreeHeap(RtlProcessHeap(), 0, pwClassesKey);

                    return (pwch);
                }
            }

            // Skip over user sid
            pwch = wcschr(pwch, L'\\');        
            if (pwch)
            {
                if (_wcsnicmp(pwch, SOFTWARE_PATH, sizeof(SOFTWARE_PATH)/sizeof(WCHAR) - 1))
                    return NULL;                                              

                if (RegPathExistsInOmissionList(pwch))
                    return NULL;
            }
        } 
    }

    return(pwch);
}


void DeleteKeyAndSubkeys(IN HKEY hkey, IN LPCWSTR pwszSubKey)
{
    HKEY hkSubKey = NULL;

    // Open the subkey so we can enumerate any children
    if (RegOpenKeyEx(hkey, pwszSubKey, 0, MAXIMUM_ALLOWED, &hkSubKey) == ERROR_SUCCESS)
    {
        DWORD dwIndex = 0;
        WCHAR szSubKeyName[MAX_PATH + 1];

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        if (RegQueryInfoKey(hkSubKey, NULL, NULL, NULL,
                                 &dwIndex, // The # of subkeys -- all we need
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL) == NO_ERROR)
        {
            // dwIndex is now the count of subkeys, but it needs to be zero-based 
            //for RegEnumKey, so I'll pre-decrement, rather than post-decrement.
            while (ERROR_SUCCESS == RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, MAX_PATH))
                DeleteKeyAndSubkeys(hkSubKey, szSubKeyName);
        }

        RegCloseKey(hkSubKey);

        if (pwszSubKey)
            RegDeleteKey(hkey, pwszSubKey);
        else
        {
            //  we want to delete all the values by hand
            DWORD cchSubKeyName = MAX_PATH;
            while (ERROR_SUCCESS == RegEnumValue(hkey, 0, szSubKeyName, &cchSubKeyName, NULL, NULL, NULL, NULL))
            {
                //  avoid looping infinitely when we cant delete the value
                if (RegDeleteValue(hkey, szSubKeyName))
                    break;

                //Reinitialize this since cchSubKeyName is an IN/OUT parameter
                cchSubKeyName = MAX_PATH;
            }
        }
    }
}


/*****************************************************************************
 *
 *  TermsrvRemoveClassesKey
 *
 *   Delete the classes key for the current user and then set a  
 *   registry flag indicating that this has been done (we only 
 *   want this to be done the first time the user logs in).
 *
 * ENTRY: None
 *  
 *  
 *
 * EXIT: True if the classes key was deleted (even if it was empty
 *          or didn't exist) and false otherwise
 *  
 *
 ****************************************************************************/

BOOL TermsrvRemoveClassesKey(LPTSTR sSid)
{
    BOOL bDeletionPerformed = FALSE;

    HKEY hPerformed;
    HKEY hDeletionFlag;

    ULONG ulFlagPathLen = 0;
    PWCHAR pFlagPath = NULL;

    ULONG ulClassesPathLen = 0;
    PWCHAR pClassesPath = NULL;
            
    if (!sSid)
        return FALSE;

    ulFlagPathLen = (wcslen(sSid) + wcslen(TERMSRV_APP_PATH) + wcslen(CLASSES_DELETED) + 1) * sizeof(WCHAR);
    pFlagPath = RtlAllocateHeap(RtlProcessHeap(), 0, ulFlagPathLen);
    if (pFlagPath)
    {
        wcscpy(pFlagPath, sSid);
        wcscat(pFlagPath, TERMSRV_APP_PATH);
        wcscat(pFlagPath, CLASSES_DELETED);

        //Make sure the operation hasn't already been performed for this user
        if (RegOpenKeyEx(HKEY_USERS, pFlagPath, 0, KEY_READ, &hPerformed) == ERROR_FILE_NOT_FOUND)
        {
            //It hasn't, so delete the software\classes key
            ulClassesPathLen = (wcslen(TERMSRV_APP_PATH) + wcslen(SOFTWARE_PATH) + wcslen(CLASSES_PATH) + 1) * sizeof(WCHAR); 
            pClassesPath = RtlAllocateHeap(RtlProcessHeap(), 0, ulClassesPathLen);
            if (pClassesPath)
            {
                wcscpy(pClassesPath, sSid);
                wcscat(pClassesPath, SOFTWARE_PATH);
                wcscat(pClassesPath, CLASSES_PATH);

                DeleteKeyAndSubkeys(HKEY_USERS, pClassesPath);

                RegCreateKeyEx(HKEY_USERS, pFlagPath, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hDeletionFlag, NULL);
                RegCloseKey(hDeletionFlag);

                bDeletionPerformed = TRUE;
            }

            if (pClassesPath)
                RtlFreeHeap(RtlProcessHeap(), 0, pClassesPath);
        }
        else
            RegCloseKey(hPerformed);
    }

    if (pFlagPath)
        RtlFreeHeap(RtlProcessHeap(), 0, pFlagPath);

    return bDeletionPerformed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\tsappcmp.c ===
/*************** ************************************************************/
// tsappcmp.c
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern BOOL InitRegisterSupport();

PWINSTATIONQUERYINFORMATIONW pWinStationQueryInformationW;


BOOL GetDefaultUserProfileName(LPWSTR lpProfileDir, LPDWORD lpcchSize);
extern WCHAR gpwszDefaultUserName[];

extern void FreeLDRTable();

DWORD    g_dwFlags=0;


/*
 * Read flags, if flags don't exit, then assume default behavior.
 * The default behavior is the same as dwFlags = 0x0
 * The default behavior will result is the loadlib func calls to be patched by our
 * redirected func TLoadLibraryExW().
 *
 */
void ReadImportTablePatchFLagsAndAppCompatMode( DWORD *pdwFlags, BOOLEAN  *pInAppCompatMode  )
{
    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    UCHAR Buffer[100];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
    ULONG KeyValueLength = 100;
    ULONG ResultLength;

    *pdwFlags=0;
    *pInAppCompatMode=FALSE;

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Terminal Server"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        return;     // so nothing found, just return since we do have a default behavior.
    }

    RtlInitUnicodeString(
    &KeyName,
    REG_TERMSRV_APPCOMPAT 
    );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );
    
    
    if (NT_SUCCESS(NtStatus)) 
    {
    
        //
        // Check that the data is the correct size and type - a DWORD.
        //
    
        if ((KeyValueInformation->DataLength >= sizeof(DWORD)) &&
            (KeyValueInformation->Type == REG_DWORD)) 
            {
                *pInAppCompatMode = * (PBOOLEAN) KeyValueInformation->Data;
            }
    }

    RtlInitUnicodeString(
        &KeyName,
        TERMSRV_COMPAT_IAT_FLAGS 
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );


    if (NT_SUCCESS(NtStatus)) 
    {

        //
        // Check that the data is the correct size and type - a DWORD.
        //

        if ((KeyValueInformation->DataLength >= sizeof(DWORD)) &&
            (KeyValueInformation->Type == REG_DWORD)) 
            {
                *pdwFlags = * (PDWORD) KeyValueInformation->Data;
            }
    }

    NtClose(KeyHandle);

}

BOOL WINAPI LibMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{

    static ULONG    attachCount=0;
    static BOOLEAN  inAppCompatMode=FALSE;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            PWCHAR  pwch, pwchext;
            WCHAR   pwcAppName[MAX_PATH+1];
            PRTL_USER_PROCESS_PARAMETERS pUserParam;
            DWORD dwSize;

            attachCount++;

            ReadImportTablePatchFLagsAndAppCompatMode( &g_dwFlags , &inAppCompatMode );    // this will initialize our global flag for IAT and debug

            if ( g_dwFlags &  DEBUG_IAT )
            {
                DbgPrint("tsappcmp: LibMain: DLL_PROCESS_ATTACH called, attach count = %d  \n", attachCount );
            }

            if ( inAppCompatMode )
            {
                // Get the path of the executable name
                pUserParam = NtCurrentPeb()->ProcessParameters;
    
                // Get the executable name, if there's no \ just use the name as it is
                pwch = wcsrchr(pUserParam->ImagePathName.Buffer, L'\\');
                if (pwch) {
                    pwch++;
                } else {
                    pwch = pUserParam->ImagePathName.Buffer;
                }
                wcscpy(pwcAppName, pwch);
                pwch = pwcAppName;
    
    
                #if DBGX
                DbgPrint("\nApp-name : %ws\n", pwch );
                #endif
    
    
                // Check if it's a DOS or Win16 app by checking if the app is ntvdm.exe
                // Only disable ThreadLibrary calls if not ntvdm.
                if (_wcsicmp(pwch, L"ntvdm.exe")) {
    
                    DisableThreadLibraryCalls (hInstance);
                } 

                // Init support for the register command
                if (!InitRegisterSupport())
                {
                    DbgPrint("TSAPPCMP: LibMain: DLL_PROCESS_ATTACH - failed\n");
                    return FALSE;
                }
    
                dwSize = MAX_PATH;
                if (!GetDefaultUserProfileName(gpwszDefaultUserName, &dwSize)) {
                    gpwszDefaultUserName[0] = L'\0';
                }
            }

            break;
        }

    case DLL_THREAD_ATTACH:
        break;

        case DLL_PROCESS_DETACH:
        {
            attachCount--;

            if ( g_dwFlags &  DEBUG_IAT )
            {
                DbgPrint("tsappcmp: LibMain: DLL_PROCESS_DETACH called, attach count = %d  \n", attachCount );
            }

            if (inAppCompatMode )
            {
    
                if (attachCount==0 )
                {
                    FreeLDRTable();
                }
            }
        }

        break;

    }

    return TRUE;
}

PWCHAR TermsrvFormatObjectName(LPCWSTR OldName)
{

PWCHAR pstrNewObjName = NULL;

#if 0
SIZE_T Size;

    Size = ( wcslen(OldName) * sizeof(WCHAR)) + sizeof(L"Local\\") + sizeof(WCHAR);

    pstrNewObjName = RtlAllocateHeap(RtlProcessHeap(),
                                     LMEM_FIXED | LMEM_ZEROINIT,
                                     Size);


    if (pstrNewObjName) {

        swprintf(pstrNewObjName,L"Local\\%ws",OldName);

    }
#endif

    return pstrNewObjName;

}

DWORD TermsrvGetComputerName( LPWSTR lpBuffer, LPDWORD nSize )
{
    ULONG   ulCompatFlags=0, ulAppType = 0;
    WINSTATIONINFORMATIONW WSInfo;

    ULONG ValueLength;
    HMODULE hwinsta = NULL;


    GetCtxAppCompatFlags(&ulCompatFlags, &ulAppType);

    // Return the username instead of the computername?
    if ((ulCompatFlags & TERMSRV_COMPAT_USERNAME) &&
        (ulCompatFlags & ulAppType)) {

        if ( !pWinStationQueryInformationW ) {
            /*
             *  Get handle to winsta.dll
             */
            if ( (hwinsta = LoadLibraryA( "WINSTA" )) != NULL ) {

                pWinStationQueryInformationW   = (PWINSTATIONQUERYINFORMATIONW)
                    GetProcAddress( hwinsta, "WinStationQueryInformationW" );
            }
        }

        // Fetch the WinStation's basic information
        if ( pWinStationQueryInformationW ) {
            if ( (*pWinStationQueryInformationW)(SERVERNAME_CURRENT,
                                                 LOGONID_CURRENT,
                                                 WinStationInformation,
                                                 &WSInfo,
                                                 sizeof(WSInfo),
                                                 &ValueLength ) ) {

                // Check if username will fit in buffer
                if (wcslen(WSInfo.UserName) >= *nSize) {
                    return ERROR_BUFFER_OVERFLOW;
                } else {
                    wcscpy(lpBuffer, WSInfo.UserName);
                    return ERROR_SUCCESS;
                }
            }
        }
    }
    return ERROR_RETRY;



}


void TermsrvAdjustPhyMemLimits (
                 IN OUT LPDWORD TotalPhys,
                 IN OUT LPDWORD AvailPhys,
                 IN DWORD SysPageSize
                    )
{
ULONG ulAppType = 0;
DWORD PhysicalMemory;

    if ( GetCtxPhysMemoryLimits(&ulAppType, &PhysicalMemory) ) {

        if (*TotalPhys > PhysicalMemory ) {

            *TotalPhys = PhysicalMemory;
        }
    }

    if ( *AvailPhys > *TotalPhys ) {
        //  Reset the Available Physical Memory to be smaller than the
        //  Total Physical Memory.  It is made smaller to avoid
        //  possible divide by zero errors when Available and Total are
        //  equal
        *AvailPhys = *TotalPhys - SysPageSize;
    }
 return;
}


UINT
APIENTRY
TermsrvGetWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )

{
ANSI_STRING AnsiString;
NTSTATUS Status;
ULONG cbAnsiString;
UNICODE_STRING Path;


    //
    // If in install mode return the system windows dir
    //
    if (TermsrvAppInstallMode()) {

        return 0;

    }

    if (!TermsrvPerUserWinDirMapping()) {

        return 0;
    }

    // if buffer looks real, then init it to zero 
    if ( lpBuffer ) {

        *lpBuffer = '\0'; // in case we have an error, the shell folks want this to be null
                           // BUG 453487
    }


    Path.Length = 0;
    Path.MaximumLength = (USHORT)(uSize * sizeof( WCHAR ));
    if ( Path.Buffer = LocalAlloc( LPTR, Path.MaximumLength ) ) {

        Status = GetPerUserWindowsDirectory( &Path );

        if ( NT_SUCCESS(Status) ) {
            AnsiString.MaximumLength = (USHORT)(uSize);
            AnsiString.Buffer = lpBuffer;

            Status = RtlUnicodeStringToAnsiString(
                        &AnsiString,
                        &Path,
                        FALSE
                        );

        } else if ( (Status == STATUS_BUFFER_TOO_SMALL) || (Status == STATUS_BUFFER_OVERFLOW ) ) {

           DbgPrint( "KERNEL32: GetWindowsDirectoryA: User buffer too small (%u) need(%u)\n",
                     uSize, Path.Length >> 1 );

           return( Path.Length >> 1 );

        }

        LocalFree( Path.Buffer );

    } else {

       Status = STATUS_NO_MEMORY;
        DbgPrint( "KERNEL32: GetWindowsDirectoryA: No memory\n" );

    }

    if ( Status == STATUS_BUFFER_TOO_SMALL ) {

       DbgPrint( "KERNEL32: GetWindowsDirectoryA: User buffer too small (%u) need(%u)\n",
                 uSize, Path.Length >> 1 );

       return( Path.Length >> 1 );

    } else if ( !NT_SUCCESS(Status) ) {

        return 0;

    }
    return AnsiString.Length;

}


UINT
APIENTRY
TermsrvGetWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )
{

    UNICODE_STRING Path;
    NTSTATUS Status;



    //
    // If in install mode return the system windows dir
    //
    if (TermsrvAppInstallMode()) {

        return 0;

    }

    if (!TermsrvPerUserWinDirMapping()) {

        return 0;
    }


    // if buffer looks real, then init it to zero 
    if ( lpBuffer ) {

        *lpBuffer = '\0'; // in case we have an error, the shell folks want this to be null
                           // BUG 453487
    }

    /*
     * If it fails, return 0
     * If buffer too small, return len (not includding NULL)
     * If buffer ok, return len (not inc. NULL) and fill buffer
     * (GetPerUserWindowsDirectory will do all of this for us!)
     */
    Path.Length        = 0;
    Path.MaximumLength = (USHORT)(uSize * sizeof( WCHAR ));
    Path.Buffer        = lpBuffer;


    Status = GetPerUserWindowsDirectory( &Path );

    if ( Status == STATUS_SUCCESS ) {
       /*
        * Add a NULL to the end (if it fits!)
        */
       if ( Path.Length + sizeof( WCHAR ) <= Path.MaximumLength ) {
          lpBuffer[(Path.Length>>1)] = UNICODE_NULL;
       }
    }

    return( Path.Length / sizeof(WCHAR) );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\regmap.h ===
/*************************************************************************
*
* regmap.h
*
* Function declarations for Citrix registry merging/mapping
*
* copyright notice: Copyright 1996, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* Author:  Bill Madden 
*
* $Log:   N:\NT\PRIVATE\WINDOWS\SCREG\WINREG\SERVER\CITRIX\VCS\REGMAP.H  $
*  
*     Rev 1.2   06 May 1996 11:51:42   terryt
*  FaxWorks Btrieve force good install values
*  
*     Rev 1.1   29 Mar 1996 15:42:00   Charlene
*  multiuser file associations via CLASSES key
*  
*     Rev 1.0   24 Jan 1996 10:53:32   billm
*  Initial revision.
*  
*************************************************************************/


#include <winsta.h>
#include <syslib.h>

#define IS_NEWLINE_CHAR( c )  ((c == 0x0D) || (c == 0x0A))
#define CLASSES_PATH L"\\Classes"
#define CLASSES_SUBSTRING L"_Classes"
#define CLASSES_DELETED L"\\ClassesRemoved"
#define TERMSRV_APP_PATH L"\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"

BOOL TermsrvCreateRegEntry(IN HANDLE hKey,
                       IN POBJECT_ATTRIBUTES pObjAttr,
                       IN ULONG TitleIndex,
                       IN PUNICODE_STRING pUniClass OPTIONAL,
                       IN ULONG ulCreateOpt);

BOOL TermsrvOpenRegEntry(OUT PHANDLE pUserhKey,
                     IN ACCESS_MASK DesiredAccess,
                     IN POBJECT_ATTRIBUTES pUserObjectAttr);

BOOL TermsrvSetValueKey(HANDLE hKey,
                    PUNICODE_STRING ValueName,
                    ULONG TitleIndex,
                    ULONG Type,
                    PVOID Data,
                    ULONG DataSize);

BOOL TermsrvDeleteKey(HANDLE hKey);

BOOL TermsrvDeleteValue(HANDLE hKey,
                    PUNICODE_STRING pUniValue);

BOOL TermsrvRestoreKey(IN HANDLE hKey,
                   IN HANDLE hFile,
                   IN ULONG Flags);

BOOL TermsrvSetKeySecurity(IN HANDLE hKey,  
                       IN SECURITY_INFORMATION SecInfo,
                       IN PSECURITY_DESCRIPTOR pSecDesc);

BOOL TermsrvOpenUserClasses(IN ACCESS_MASK DesiredAccess, 
                        OUT PHANDLE pUserhKey) ;

NTSTATUS TermsrvGetPreSetValue(  IN HANDLE hKey,
                             IN PUNICODE_STRING pValueName,
                             IN ULONG  Type,
                            OUT PVOID *Data
                           );

BOOL TermsrvRemoveClassesKey();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tscert\inc\pubblob.h ===
unsigned char PublicKeySigBlob[] = {
// This data is generated by obj\i386\certinit.
// Key Blob - 148 bytes
0x06, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 
0x52, 0x53, 0x41, 0x31, 0x00, 0x04, 0x00, 0x00, 
0x01, 0x00, 0x01, 0x00, 0xb1, 0xb6, 0x1b, 0x6c, 
0x05, 0xa5, 0x4e, 0xd4, 0xab, 0x64, 0xdb, 0x96, 
0x56, 0x2c, 0x96, 0xfa, 0xcf, 0x15, 0x6d, 0x73, 
0x6e, 0xbb, 0x14, 0xc6, 0xe8, 0xed, 0xd8, 0x4b, 
0xb9, 0x50, 0x66, 0x30, 0x21, 0xb0, 0x00, 0x6d, 
0x4f, 0x56, 0xe6, 0xd0, 0x99, 0x28, 0xd1, 0xf0, 
0x4a, 0xde, 0x82, 0x76, 0x25, 0xd2, 0x4c, 0xff, 
0x4e, 0x07, 0x45, 0x0c, 0x09, 0x3c, 0xd4, 0x7d, 
0x79, 0x1b, 0xab, 0x94, 0x60, 0xdc, 0x5a, 0x0b, 
0xaa, 0x1b, 0xc3, 0xc1, 0x87, 0x93, 0xda, 0xbc, 
0xb1, 0xee, 0xd0, 0x66, 0x8c, 0x94, 0x2c, 0x26, 
0x1a, 0xfa, 0x0c, 0x41, 0x20, 0x59, 0x2e, 0xda, 
0x8f, 0xa2, 0x79, 0x66, 0x0f, 0xe7, 0x10, 0xc0, 
0x89, 0x61, 0xe5, 0x56, 0x94, 0xc4, 0xb9, 0x35, 
0x61, 0x2d, 0xf9, 0x2f, 0x58, 0xb2, 0xe3, 0x09, 
0x52, 0x25, 0x20, 0x1f, 0x03, 0xcd, 0xab, 0xee, 
0xe5, 0x1b, 0xa9, 0xdb, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\valinfo.cpp ===
/****************************************************************************/
// valinfo.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include "ValInfo.h"

ValueFullInfo::ValueFullInfo( KeyNode *pKey ) :
    pInfo(NULL), pSzName(NULL), pKeyNode(NULL)

{
    pKeyNode = pKey;

    KeyFullInfo    *pKeyInfo;
    if ( NT_SUCCESS ( status = pKeyNode->GetFullInfo( &pKeyInfo) ) )
    {
        size = sizeof(KEY_VALUE_FULL_INFORMATION) + 
                   (pKeyInfo->Ptr()->MaxValueNameLen + 1)*sizeof(WCHAR) +
                    pKeyInfo->Ptr()->MaxValueDataLen; 
    
        pInfo = ( KEY_VALUE_FULL_INFORMATION *)RtlAllocateHeap(RtlProcessHeap(), 0, size );
    
        if (!pInfo) {
            status = STATUS_NO_MEMORY;
        }
        else
            status = STATUS_SUCCESS;
    }
}

PCWSTR ValueFullInfo::SzName()
{
    if (!pSzName)
    {
        ULONG size =  pInfo->NameLength + sizeof(WCHAR);
        pSzName = (PWSTR) RtlAllocateHeap(RtlProcessHeap(), 0, size );

        if (!pSzName) 
        {
            status = STATUS_NO_MEMORY;
        }
        else
        {
            wcsncpy( pSzName, pInfo->Name, pInfo->NameLength/sizeof(WCHAR) );
            pSzName[ pInfo->NameLength/sizeof( WCHAR)  ] = L'\0';
            status = STATUS_SUCCESS;
        }
    }

    return pSzName;

}

BOOLEAN ValueFullInfo::Compare( ValueFullInfo *pOther )
{
    status = STATUS_SUCCESS; // we don't expect errors in here
    if ( pOther->Ptr()->Type != Ptr()->Type)
    {
        return FALSE;
    }

    if ( pOther->Ptr()->DataLength != Ptr()->DataLength)
    {
        return FALSE;
    }

    if ( pOther->Ptr()->NameLength != Ptr()->NameLength)
    {
        return FALSE;
    }


    for (ULONG i = 0; i < Ptr()->NameLength / sizeof( WCHAR) ; i++)
    {
        if ( Ptr()->Name[i] != pOther->Ptr()->Name[i])
        {
            return FALSE;
        }

    }

    for (i = 0; i < Ptr()->DataLength; i++)
    {
        if ( ((PCHAR)( (PCHAR)Ptr() + Ptr()->DataOffset ))[i] != 
             ((PCHAR) ( (PCHAR)(pOther->Ptr()) + 
                        pOther->Ptr()->DataOffset) )[i] )
            return FALSE;
    }

    return TRUE;
}

ValueFullInfo::~ValueFullInfo()
{
    if (pInfo)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pInfo);
    }

    if ( pSzName )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pSzName );
    }
}


NTSTATUS ValueFullInfo::Query(PCWSTR  pValueName )
{
    ULONG   resultSize;
    ULONG   numberOfAttempts=0;

    if ( NT_SUCCESS( pKeyNode->Status() ) )
    {
        UNICODE_STRING  tmpName;
        RtlInitUnicodeString( &tmpName, pValueName);

        status = NtQueryValueKey( pKeyNode->Key() ,
                                 &tmpName,
                                 Type(),
                                 Ptr(),
                                 Size(),
                                 &resultSize);                 

        if ( (status == STATUS_BUFFER_OVERFLOW ) || 
            ( status == STATUS_BUFFER_TOO_SMALL ) )
        {
            // @@@ this can never happen right? 
            // Since the key param imposes a max size on any valule 
            // under the key.
        }

    }
    else
        status = STATUS_OBJECT_NAME_NOT_FOUND; // need to call open or key is not found

    return status;

}

NTSTATUS ValueFullInfo::Delete(PCWSTR  pValueName )
{
    UNICODE_STRING  tmpName;
    RtlInitUnicodeString( &tmpName, pValueName);

    if (NT_SUCCESS( status = pKeyNode->Status() ) )
    {
        status = NtDeleteValueKey( pKeyNode->Key(), &tmpName );
    }

    return status;
}

NTSTATUS ValueFullInfo::Create( ValueFullInfo   *pNew )
{
    UNICODE_STRING  uniString;

    uniString.Buffer = pNew->Ptr()->Name;
    uniString.Length = (USHORT)pNew->Ptr()->NameLength;
    uniString.MaximumLength = uniString.Length + 2;

    if (NT_SUCCESS( status = pKeyNode->Status() ) )
    {
        status = NtSetValueKey( pKeyNode->Key(),
            &uniString,
            0,
            pNew->Ptr()->Type,
            (PCHAR)pNew->Ptr()+ 
            pNew->Ptr()->DataOffset,
            pNew->Ptr()->DataLength);
    }

    return status;


}

void ValueFullInfo::Print( FILE *fp )
{
    fwprintf( fp, L"name=%ws, size= %d, type=%d \n",
              SzName(), Size(), Type() );

     fwprintf( fp, L"DataOffset=%d, DataLength=%d, NameLength=%d \n",
               Ptr()->DataOffset, Ptr()->DataLength, Ptr()->NameLength );

     for ( ULONG i =0; i < Ptr()->NameLength + Ptr()->DataLength; i++)
     {
         if ( !(i % 32) )
         {
             fwprintf(fp,L"\n");
             fwprintf(fp,L"i=%3d ,",i);
         }
         fwprintf( fp, L"%2x ", ((BYTE *)(Ptr()->Name))[i] );
     }
     fwprintf(fp,L"\n");
     fflush( fp );
}

ValuePartialInfo::ValuePartialInfo( KeyNode *pKey , ULONG defaultSize ):
    pInfo(NULL), pKeyNode(NULL)
{
    pKeyNode = pKey;

    if (defaultSize)
    {
        size = defaultSize;
    } 
    else
    {
        size = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG);
        pInfo = ( KEY_VALUE_PARTIAL_INFORMATION *)RtlAllocateHeap(
            RtlProcessHeap(), 0, size );
    }

    if (!pInfo) {
        status = STATUS_NO_MEMORY;
        pInfo=NULL;
    }
    else
        status = STATUS_SUCCESS;

}

ValuePartialInfo::~ValuePartialInfo()
{
    if (pInfo)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pInfo);
    }

}


NTSTATUS ValuePartialInfo::Query( PCWSTR  pValueName )
{
    ULONG   resultSize;
    ULONG   numberOfAttempts=0;

    UNICODE_STRING  tmpName;

    if (!pKeyNode->Key())
    {
        // not having a key associated with this registry should mean that any further operation
        // must return an expected error status without calling the underlying nt apis, since 
        // appverifier will detect such as a potential bug.
        status = STATUS_INVALID_HANDLE;
        return status;
    }

    RtlInitUnicodeString( &tmpName, pValueName);

tryAgain:
    status = NtQueryValueKey(pKeyNode->Key(),
                                 &tmpName,
                                 Type(),
                                 Ptr(),
                                 Size(),
                                 &resultSize);                 

    if ( (status == STATUS_BUFFER_OVERFLOW ) || 
        ( status == STATUS_BUFFER_TOO_SMALL ) )
    {

        RtlFreeHeap( RtlProcessHeap(), 0, pInfo);

        size = resultSize;
        pInfo = ( KEY_VALUE_PARTIAL_INFORMATION *)RtlAllocateHeap(
            RtlProcessHeap(), 0, size );

        numberOfAttempts++;
        if ( numberOfAttempts < 10 )
        {
            goto tryAgain;
        }
        // else, we bail out, don't want to hang here, let the caller worry about this.
    }

    return status;
}

NTSTATUS ValuePartialInfo::Delete(PCWSTR  pValueName )
{
    UNICODE_STRING  tmpName;
    RtlInitUnicodeString( &tmpName, pValueName);

    if (!pKeyNode->Key())
    {
        // not having a key associated with this registry should mean that any further operation
        // must return an expected error status without calling the underlying nt apis, since 
        // appverifier will detect such as a potential bug.
        status = STATUS_INVALID_HANDLE;
        return status;
    }

    status = NtDeleteValueKey( pKeyNode->Key(), &tmpName );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsappcmp\valinfo.h ===
/****************************************************************************/
// valinfo.cpp
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#ifndef _TS_APP_SMP_VAL_INFO_
#define _TS_APP_SMP_VAL_INFO_

#include <stdio.h>

#include "KeyNode.h"


class   ValueFullInfo
{
public:
    ValueFullInfo(  KeyNode *pKey );  

    ~ValueFullInfo();

    ULONG                           Size()      { return size ; }
    KEY_VALUE_FULL_INFORMATION      *Ptr()  { return pInfo; }
    KEY_VALUE_INFORMATION_CLASS     Type()  { return KeyValueFullInformation; }
    NTSTATUS                        Status() { return status; }

    PCWSTR                          SzName();

    NTSTATUS                        Query(  PCWSTR  pValueName );
    NTSTATUS                        Delete( PCWSTR  pValueName );
    NTSTATUS                        Create( ValueFullInfo   *pNew );


    BOOLEAN                         Compare( ValueFullInfo *pOther ); // compare self to other, 
                                    // TRUE mean the two values are the same.

    void                            Print( FILE *fp); // for debug dump
private:
    ULONG                           size;
    KEY_VALUE_FULL_INFORMATION      *pInfo;
    ULONG                           status;
    PWSTR                           pSzName;
    KeyNode                         *pKeyNode;
};


class   ValuePartialInfo
{
public:
    ValuePartialInfo(  KeyNode *pKey , ULONG   defaultSize=0);  

    ~ValuePartialInfo();

    ULONG                           Size()      { return size ; }
    KEY_VALUE_PARTIAL_INFORMATION   *Ptr()  { return pInfo; }
    KEY_VALUE_INFORMATION_CLASS     Type()  { return KeyValuePartialInformation; }
    NTSTATUS                        Status() { return status; }

    NTSTATUS                        Query(  PCWSTR  pValueName );
    NTSTATUS                        Delete( PCWSTR  pValueName );

private:
    ULONG                           size;
    KEY_VALUE_PARTIAL_INFORMATION   *pInfo;
    ULONG                           status;
    KeyNode                         *pKeyNode;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tscert\tscrtini\pubblob.h ===
unsigned char PublicKeySigBlob[] = {
// This data is generated by obj\i386\certinit.
// Key Blob - 148 bytes
0x06, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 
0x52, 0x53, 0x41, 0x31, 0x00, 0x04, 0x00, 0x00, 
0x01, 0x00, 0x01, 0x00, 0xb1, 0xb6, 0x1b, 0x6c, 
0x05, 0xa5, 0x4e, 0xd4, 0xab, 0x64, 0xdb, 0x96, 
0x56, 0x2c, 0x96, 0xfa, 0xcf, 0x15, 0x6d, 0x73, 
0x6e, 0xbb, 0x14, 0xc6, 0xe8, 0xed, 0xd8, 0x4b, 
0xb9, 0x50, 0x66, 0x30, 0x21, 0xb0, 0x00, 0x6d, 
0x4f, 0x56, 0xe6, 0xd0, 0x99, 0x28, 0xd1, 0xf0, 
0x4a, 0xde, 0x82, 0x76, 0x25, 0xd2, 0x4c, 0xff, 
0x4e, 0x07, 0x45, 0x0c, 0x09, 0x3c, 0xd4, 0x7d, 
0x79, 0x1b, 0xab, 0x94, 0x60, 0xdc, 0x5a, 0x0b, 
0xaa, 0x1b, 0xc3, 0xc1, 0x87, 0x93, 0xda, 0xbc, 
0xb1, 0xee, 0xd0, 0x66, 0x8c, 0x94, 0x2c, 0x26, 
0x1a, 0xfa, 0x0c, 0x41, 0x20, 0x59, 0x2e, 0xda, 
0x8f, 0xa2, 0x79, 0x66, 0x0f, 0xe7, 0x10, 0xc0, 
0x89, 0x61, 0xe5, 0x56, 0x94, 0xc4, 0xb9, 0x35, 
0x61, 0x2d, 0xf9, 0x2f, 0x58, 0xb2, 0xe3, 0x09, 
0x52, 0x25, 0x20, 0x1f, 0x03, 0xcd, 0xab, 0xee, 
0xe5, 0x1b, 0xa9, 0xdb, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tscert\inc\certvfy.inc ===
#ifndef certvfy_inc
#define certvfy_inc
#include <wintrust.h>

#define WIN_CERT_TYPE_STACK_DLL_SIGNATURE WIN_CERT_TYPE_TS_STACK_SIGNED

typedef struct _DIGEST_PARA {
    HCRYPTHASH      hHash;
} DIGEST_PARA, *PDIGEST_PARA;

/*****************************************************************************
 *
 *  DigestFile
 *
 *   Callback function for ImageGetDigestStream
 *
 * ENTRY:
 *   hDigest (input)
 *     Digest handle - pointer to a DIGEST_PARA structure
 *   pb (input)
 *     Pointer to a buffer of data to hash
 *   cb (input)
 *     Number of bytes in the buffer of data pointed to by pb
 *
 * EXIT:
 *   TRUE - no error
 *   FALSE - use GetLastError() to obtain error information
 *
 ****************************************************************************/
static
BOOL
WINAPI
DigestFile(
    DIGEST_HANDLE hDigest,
    PBYTE pb,
    DWORD cb
    )
{
    PDIGEST_PARA pdp = (PDIGEST_PARA)hDigest;


    if (pb == (PBYTE)-1) {
        return( TRUE );
    } else {
        return( CryptHashData(pdp->hHash, pb, cb, 0) );
    }
}


/*****************************************************************************
 *
 *  OpenImageFile
 *
 *   Return a handle to the opened PE image file
 *
 * ENTRY:
 *   wszFile (input)
 *     Path of file to open
 *   dwAccess (input)
 *     Desired access
 *
 * EXIT:
 *   INVALID_HANDLE_VALUE - File cannot be opened for the desired access
 *
 ****************************************************************************/
static
HANDLE
OpenImageFile(
    LPCWSTR wszFile,
    DWORD dwAccess
    )
{
    HANDLE hFile;
    if (wszFile) {
        hFile = CreateFile(
            wszFile,
            dwAccess,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        return hFile;
    } else {
        return INVALID_HANDLE_VALUE;
    }
}

///////////////////////////////////////////////////////////////////////
//
// Verify Code, Data, and Resources of a PE image file
//
///////////////////////////////////////////////////////////////////////
static
BOOL
VerifyFile(
    LPWSTR wszFile,
    PRTL_CRITICAL_SECTION VfyLock
    )
{
    HCRYPTPROV  hProv;
    HCRYPTKEY   hSigPublicKey = 0;
    BOOL        fResult = FALSE;  // preset ERROR case
    HANDLE      hFile;
    DWORD       dwErr = ERROR_SUCCESS;
    DWORD       dwSignatureLen;
    DWORD       dwCert;
    DWORD       cCert;
    DWORD       dwCertIndex;
    DIGEST_PARA dp;
    LPWIN_CERTIFICATE pCertHdr;
    WIN_CERTIFICATE Hdr;

    if ( (hFile = OpenImageFile(
            wszFile,
            GENERIC_READ )) == INVALID_HANDLE_VALUE ) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during OpenImageFile\n", GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
              "Error %x during OpenImageFile\n", GetLastError()) );
#endif
        goto OpenImageFileError;
    }

    RtlEnterCriticalSection( VfyLock );
    if (!CryptAcquireContext(
            &hProv,
            NULL,
            MS_DEF_PROV,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT)) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during CryptAcquireContext\n", GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "Error %x during CryptAcquireContext\n",GetLastError()) );
#endif
        RtlLeaveCriticalSection( VfyLock );
        goto CryptAcquireContextError;
    }
    RtlLeaveCriticalSection( VfyLock );

    memset( &dp, 0, sizeof(dp));
    if (!CryptCreateHash(
            hProv,
            CALG_MD5,
            0,
            0,
            &dp.hHash)) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during CryptCreateHash\n", GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Error %x during CryptCreateHash\n", GetLastError()) );
#endif
        goto CryptCreateHashError;
    }

    if (!ImageGetDigestStream(
            hFile,
            0,
            DigestFile,
            (DIGEST_HANDLE)&dp)) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during ImageGetDigestStream\n", GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
              "Error %x during ImageGetDigestStream\n", GetLastError()) );
#endif
        goto ImageGetDigestStreamError;

    }

    cCert = 0;
    if (!ImageEnumerateCertificates(
            hFile,
            WIN_CERT_TYPE_STACK_DLL_SIGNATURE,
            &cCert,
            &dwCertIndex,
            1               // IndexCount
            )) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during ImageEnumerateCertificates\n",
            GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
              "Error %x during ImageEnumerateCertificates\n",GetLastError()) );
#endif
        goto ImageEnumerateCertificatesError;
    }
    if (cCert == 0) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error there were no Certificates of type %x found\n",
            WIN_CERT_TYPE_STACK_DLL_SIGNATURE) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Error there were no Certificates of type %x found\n",
               WIN_CERT_TYPE_STACK_DLL_SIGNATURE) );
#endif
        goto ImageEnumerateCertificatesError;
    }

    // Determine size of Certificate.
    if(!ImageGetCertificateHeader(
            hFile,
            dwCertIndex,
            &Hdr)) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during ImageGetCertificateHeader!\n",
            GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Error %x during ImageGetCertificateHeader!\n",
               GetLastError()) );
#endif
        goto ImageGetCertificateHeaderError;
    }

    dwCert = Hdr.dwLength;
    dwSignatureLen = dwCert - offsetof( WIN_CERTIFICATE, bCertificate );
#ifdef SIGN_DEBUG
    SIGN_DBGP( ("Signature length = %d\n", dwSignatureLen) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Signature length = %d\n", dwSignatureLen) );
#endif
    if (NULL == (pCertHdr = (LPWIN_CERTIFICATE) MemAlloc(dwCert))) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Out of memory Cert!\n") );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "Out of memory Cert!\n") );
#endif
        goto CertAllocError;
    }

#ifdef SIGN_DEBUG
    SIGN_DBGP( ("Requested Cert size = %d\n", dwCert) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
              "Requested Cert size = %d\n", dwCert) );
#endif
    if (!ImageGetCertificateData(
            hFile,
            dwCertIndex,
            pCertHdr,
            &dwCert)) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during ImageGetCertificate\n", GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Error %x during ImageGetCertificate\n", GetLastError()) );
#endif
        goto ImageGetCertificateError;
    }
#ifdef SIGN_DEBUG
    SIGN_DBGP( ("Returned Cert size = %d\n", dwCert) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Returned Cert size = %d\n", dwCert) );
#endif

    if (!CryptImportKey(
            hProv,
            PublicKeySigBlob,            // from #include "../inc/keyblobs.h"
            sizeof( PublicKeySigBlob ),
            0,
            0,
            &hSigPublicKey)) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during CryptImportKey!\n", GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Error %x during CryptImportKey!\n", GetLastError()) );
#endif
        goto CryptGetUserKeyError;
    }

#ifdef SIGN_DEBUG
    SIGN_DBGP( ("Signature (from Certificate):\n") );
    {
        unsigned int cnt=0;
        while ( cnt < dwSignatureLen ) {
            int i;
            for ( i=0; (i < 16) && (cnt < dwSignatureLen); cnt++,i++) {
                SIGN_DBGP( ("%02x ", pCertHdr->bCertificate[cnt]) );
            }
            SIGN_DBGP( ("\n") );
        }
    }
#endif
#ifdef SIGN_DEBUG_WINSTA
    TRACE((hTrace,TC_ICASRV,TT_API1, "Signature (from Certificate):\n") );
    {
        unsigned int cnt=0;
        while ( cnt < dwSignatureLen ) {
            int i;
            for ( i=0; (i < 16) && (cnt < dwSignatureLen); cnt++,i++) {
                TRACE((hTrace,TC_ICASRV,TT_API1, "%02x ",
                       pCertHdr->bCertificate[cnt]) );
            }
            TRACE((hTrace,TC_ICASRV,TT_API1, "\n"));
        }
    }
#endif

    // Verify signature.
    if(!CryptVerifySignature(
            dp.hHash,
            &pCertHdr->bCertificate[0],
            dwSignatureLen,
            hSigPublicKey,
            NULL,
            0)) {
        if(GetLastError() == NTE_BAD_SIGNATURE) {
#ifdef SIGN_DEBUG
            SIGN_DBGP( ("Signature did not match!\n") );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,"Signature did not match!\n") );
#endif
        } else {
#ifdef SIGN_DEBUG
            SIGN_DBGP( ("Error %x during CryptVerifySignature!\n",
                GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Error %x during CryptVerifySignature!\n", GetLastError()) );
#endif
        }
        goto CryptVerifySignatureError;
    }

    fResult = TRUE;

CryptVerifySignatureError:
    CryptDestroyKey(hSigPublicKey);

CryptGetUserKeyError:
ImageGetCertificateError:
    MemFree( pCertHdr );

CertAllocError:
ImageGetCertificateHeaderError:
ImageEnumerateCertificatesError:
ImageGetDigestStreamError:
    CryptDestroyHash( dp.hHash );

CryptCreateHashError:
    dwErr = GetLastError();
    CryptReleaseContext( hProv, 0 );
    SetLastError( dwErr );

CryptAcquireContextError:
    CloseHandle( hFile );

OpenImageFileError:
    return fResult;
}
#endif // certvfy_inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tscert\inc\privblob.h ===
unsigned char PrivateKeySigBlob[] = {
// This data is generated by obj\i386\certinit.
// Key Blob - 596 bytes
0x07, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 
0x52, 0x53, 0x41, 0x32, 0x00, 0x04, 0x00, 0x00, 
0x01, 0x00, 0x01, 0x00, 0xb1, 0xb6, 0x1b, 0x6c, 
0x05, 0xa5, 0x4e, 0xd4, 0xab, 0x64, 0xdb, 0x96, 
0x56, 0x2c, 0x96, 0xfa, 0xcf, 0x15, 0x6d, 0x73, 
0x6e, 0xbb, 0x14, 0xc6, 0xe8, 0xed, 0xd8, 0x4b, 
0xb9, 0x50, 0x66, 0x30, 0x21, 0xb0, 0x00, 0x6d, 
0x4f, 0x56, 0xe6, 0xd0, 0x99, 0x28, 0xd1, 0xf0, 
0x4a, 0xde, 0x82, 0x76, 0x25, 0xd2, 0x4c, 0xff, 
0x4e, 0x07, 0x45, 0x0c, 0x09, 0x3c, 0xd4, 0x7d, 
0x79, 0x1b, 0xab, 0x94, 0x60, 0xdc, 0x5a, 0x0b, 
0xaa, 0x1b, 0xc3, 0xc1, 0x87, 0x93, 0xda, 0xbc, 
0xb1, 0xee, 0xd0, 0x66, 0x8c, 0x94, 0x2c, 0x26, 
0x1a, 0xfa, 0x0c, 0x41, 0x20, 0x59, 0x2e, 0xda, 
0x8f, 0xa2, 0x79, 0x66, 0x0f, 0xe7, 0x10, 0xc0, 
0x89, 0x61, 0xe5, 0x56, 0x94, 0xc4, 0xb9, 0x35, 
0x61, 0x2d, 0xf9, 0x2f, 0x58, 0xb2, 0xe3, 0x09, 
0x52, 0x25, 0x20, 0x1f, 0x03, 0xcd, 0xab, 0xee, 
0xe5, 0x1b, 0xa9, 0xdb, 0x03, 0x93, 0xdb, 0x2f, 
0xc3, 0x15, 0xd1, 0xe7, 0x2e, 0xa0, 0xce, 0xb0, 
0x9b, 0x4d, 0x9f, 0x17, 0xd4, 0xe4, 0x9e, 0xfc, 
0xb0, 0x72, 0x5b, 0x78, 0x58, 0xbd, 0xef, 0x73, 
0x3c, 0xbe, 0x52, 0x09, 0xfd, 0x62, 0x08, 0x2e, 
0x7e, 0x50, 0x80, 0x6b, 0x00, 0x20, 0xbb, 0xfd, 
0xfd, 0x3b, 0x38, 0xde, 0x92, 0x5d, 0x0e, 0xf9, 
0xe4, 0xa5, 0xc6, 0x84, 0x07, 0xd8, 0xa4, 0x7a, 
0xa9, 0xf8, 0x59, 0xed, 0x3b, 0x47, 0xe9, 0x3b, 
0x03, 0x34, 0xa8, 0x54, 0xa3, 0x1c, 0x0c, 0xae, 
0x93, 0x1b, 0x1b, 0xa9, 0x27, 0xca, 0x12, 0x88, 
0xb0, 0x0c, 0xe4, 0x40, 0xbe, 0xb1, 0x4e, 0xa7, 
0x39, 0x2c, 0x62, 0x5a, 0xc7, 0x53, 0xcf, 0xb4, 
0x49, 0x20, 0x0b, 0xc5, 0x76, 0x61, 0x69, 0xa5, 
0x85, 0x17, 0xe0, 0x2b, 0x50, 0x9e, 0x57, 0xc1, 
0x5a, 0xc8, 0x6a, 0x31, 0x09, 0xd0, 0x8e, 0x2e, 
0xd0, 0x4e, 0xeb, 0xec, 0xc9, 0xda, 0x91, 0x03, 
0xf5, 0x6b, 0x64, 0x0d, 0xbc, 0x98, 0x64, 0xdc, 
0x68, 0xe7, 0x7d, 0x8c, 0x6e, 0x67, 0xcc, 0x69, 
0x9c, 0x69, 0xc0, 0x3f, 0xaa, 0xb8, 0xa9, 0x12, 
0xdc, 0x39, 0x55, 0x31, 0x83, 0xd6, 0x07, 0xf2, 
0x25, 0x9b, 0x44, 0xf4, 0xfd, 0xa2, 0xfa, 0xad, 
0xbf, 0x52, 0x1b, 0x90, 0x01, 0x8b, 0xb5, 0xd4, 
0x3d, 0x2a, 0xff, 0x60, 0x77, 0x9f, 0x56, 0xb3, 
0x36, 0xd8, 0x5a, 0x33, 0x0d, 0x3f, 0xfe, 0x92, 
0x05, 0x1d, 0x57, 0x21, 0x72, 0x65, 0x00, 0x96, 
0xc8, 0x10, 0x1c, 0xea, 0x51, 0xaf, 0xeb, 0x6a, 
0xcd, 0xc7, 0xa1, 0x5d, 0x65, 0x2d, 0x92, 0xb7, 
0x0d, 0x44, 0x50, 0x17, 0xe6, 0x93, 0xf9, 0x3e, 
0x44, 0x39, 0xcd, 0x30, 0x59, 0xb2, 0xae, 0xfd, 
0x1e, 0x9b, 0x5b, 0x64, 0x6c, 0xc7, 0xa4, 0x30, 
0x54, 0x01, 0x0f, 0x7f, 0x9d, 0xd4, 0x76, 0xc5, 
0x0d, 0xe7, 0x62, 0x99, 0x31, 0x45, 0x2c, 0x2d, 
0xf1, 0xf1, 0xf6, 0x36, 0x47, 0x32, 0x02, 0x9c, 
0xb4, 0xec, 0x6a, 0x37, 0x56, 0xee, 0x92, 0x43, 
0x3b, 0x6c, 0x51, 0xb8, 0x18, 0x09, 0x56, 0x1a, 
0x1a, 0x7c, 0xec, 0x76, 0x41, 0x44, 0xef, 0x2e, 
0x9b, 0x56, 0xcb, 0x97, 0x52, 0x29, 0x64, 0x3e, 
0x03, 0x59, 0x98, 0xe4, 0xcd, 0x4a, 0xf8, 0xd3, 
0x80, 0xb4, 0xd2, 0x4e, 0x7e, 0x58, 0x11, 0xe2, 
0x71, 0x92, 0x80, 0x45, 0xc5, 0xb2, 0xcd, 0x65, 
0xff, 0x96, 0xe9, 0xc8, 0x84, 0x58, 0x49, 0x20, 
0x26, 0x2d, 0x8e, 0x4e, 0x74, 0xd5, 0x60, 0xa5, 
0x0a, 0x7c, 0xe0, 0x3a, 0xe0, 0x1f, 0x86, 0xea, 
0xb0, 0x93, 0x5e, 0x38, 0xfb, 0xc9, 0x9d, 0xc9, 
0x13, 0xfb, 0x4e, 0x91, 0x16, 0x0a, 0x2a, 0x2a, 
0xe5, 0xb9, 0x76, 0x54, 0x9a, 0xe8, 0x35, 0x0d, 
0x32, 0x5e, 0x53, 0x5d, 0x29, 0x9b, 0x4d, 0xa5, 
0xae, 0xe5, 0xae, 0xb6, 0x67, 0xb7, 0xb2, 0xc6, 
0x6b, 0xb2, 0x37, 0x39, 0x8b, 0xd1, 0x0c, 0x6a, 
0xf3, 0x7d, 0xc6, 0xbf, 0xc1, 0x9d, 0x46, 0x96, 
0x7f, 0xa0, 0x7a, 0xc0, 0xa9, 0x36, 0x63, 0x06, 
0x9d, 0x5a, 0x21, 0x8a, 0xa3, 0x3a, 0xef, 0x44, 
0x23, 0xb2, 0xb6, 0x06, 0xcb, 0xda, 0xd1, 0x71, 
0xaf, 0x9f, 0xf9, 0x60, 0x69, 0x35, 0xc1, 0xe9, 
0xcc, 0x3f, 0x59, 0x45, 0x89, 0xa8, 0xea, 0xd2, 
0x54, 0x30, 0xaf, 0x7e, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tscert\tscrtadd\tscrtadd.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <wincrypt.h>
#include <imagehlp.h>

#ifdef IN_TERMSRV
#else
#define MemAlloc malloc
#define MemFree free
#endif

#ifdef SIGN_DEBUG
#define SIGN_DBGP(x) printf x
#else // SIGN_DEBUG
#define SIGN_DBGP(x)
#endif // SIGN_DEBUG

#include "../inc/privblob.h"

#define WIN_CERT_TYPE_STACK_DLL_SIGNATURE WIN_CERT_TYPE_TS_STACK_SIGNED

BOOL SignFile( LPWSTR wszFile );

/*****************************************************************************/
void _cdecl main(int argc, char *argv[])
{

    WCHAR szSourceFile[ MAX_PATH + 1];
    DWORD dwBc;

    if (argc != 2) {
        printf( "Usage: %s PE_File_Name\n", argv[0] );
        exit(1);
    }

    if(RtlMultiByteToUnicodeN( szSourceFile, sizeof(szSourceFile), &dwBc,
        argv[1], (strlen(argv[1]) + 1) ) == STATUS_SUCCESS)
    {

        if( szSourceFile == NULL || !SignFile(szSourceFile) ) {
	    printf("Error signing file!\n");
	    exit(1);
        }

        printf("Signature added successfully.\n");
        exit(0);
    }
    else
    {
        printf("Error conversion from Ansi to Unicode.\n");
        exit(1);
    }
}


typedef struct _DIGEST_PARA {
    HCRYPTHASH      hHash;
} DIGEST_PARA, *PDIGEST_PARA;


BOOL
WINAPI
DigestFile(
    DIGEST_HANDLE hDigest,
    PBYTE pb,
    DWORD cb )
{
    PDIGEST_PARA pdp = (PDIGEST_PARA)hDigest;

    if (pb == (PBYTE)-1) {
        return( TRUE );
    } else {
        return( CryptHashData(pdp->hHash, pb, cb, 0) );
    }
}


//////////////////////////////////////////////////////////////
//
// Open a file in the appropriate permissions / mode for doing
// our signing stuff
//
//////////////////////////////////////////////////////////////
HANDLE OpenImageFile( LPCWSTR wszFile, DWORD dwAccess )
{
    HANDLE hFile;
    if (wszFile) {
        hFile = CreateFile( wszFile,
                            dwAccess,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        return hFile;
    } else {
        return INVALID_HANDLE_VALUE;
    }
}

///////////////////////////////////////////////////////////////////////
//
// Sign Code, Data, and Resources of a PE image file, and add the
// signature to the file in the form of a "WIN_CERTIFICATE".
//
///////////////////////////////////////////////////////////////////////
BOOL
SignFile(
    LPWSTR wszFile
    )
{
    HCRYPTPROV  hProv;
    HCRYPTKEY   hPrivateKeySig = 0;
    BOOL        fResult = FALSE;  // preset ERROR case
    HANDLE      hFile;
    DWORD       dwErr = ERROR_SUCCESS;
    DWORD       dwSignatureLen;
    DWORD       dwCert;
    DWORD       dwCertIndex;
    DWORD       cCert;
    DIGEST_PARA dp;
    PBYTE       pbSignature;
    LPWIN_CERTIFICATE pCertHdr;

    if ( !(hFile = OpenImageFile( wszFile, GENERIC_WRITE | GENERIC_READ )) ) {
	printf("Error %x during OpenImageFile\n", GetLastError() );
        goto OpenImageFileError;
    }

    if (!CryptAcquireContext(
            &hProv,
            NULL,
            MS_DEF_PROV,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT))
    {
  	    SIGN_DBGP( ("Error %x during CryptAcquireContext\n", GetLastError()) );
        goto CryptAcquireContextError;
    }

    if (!CryptImportKey(
            hProv,
            PrivateKeySigBlob,  // from #include "../inc/privblob.h"
            sizeof( PrivateKeySigBlob ),
            0,
            CRYPT_EXPORTABLE,
            &hPrivateKeySig)) {
        SIGN_DBGP( ("Error %x during CryptImportKey!\n", GetLastError()) );
        goto CryptImportKeyError;
    }

    memset( &dp, 0, sizeof(dp));
    if (!CryptCreateHash(
            hProv,
            CALG_MD5,
            0,
            0,
            &dp.hHash)) {
	SIGN_DBGP( ("Error %x during CryptCreateHash\n", GetLastError()) );
        goto CryptCreateHashError;
    }

    if (!ImageGetDigestStream(
            hFile,
            0,
            DigestFile,
            (DIGEST_HANDLE)&dp)) {
	SIGN_DBGP( ("Error %x during ImageGetDigestStream\n", GetLastError()) );
        goto ImageGetDigestStreamError;

    }

    //
    // Sign hash object.
    //

    // Determine size of signature.
    dwSignatureLen = 0;
    if(!CryptSignHash(
            dp.hHash,
            AT_SIGNATURE,
            NULL,
            0,
            NULL,
            &dwSignatureLen)) {
	SIGN_DBGP( ("Error %x during CryptSignHash 1! SigLen = %d\n",
            GetLastError(),
            dwSignatureLen) );
	goto CryptSignHash1Error;
    }

    // Allocate memory for 'pbSignature'.
    if((pbSignature = MemAlloc(dwSignatureLen)) == NULL) {
	SIGN_DBGP( ("Out of memory Sig!\n") );
	goto SigAllocError;
    }

    // Sign hash object (with signature key).
    if(!CryptSignHash(
            dp.hHash,
            AT_SIGNATURE,
            NULL,
            0,
            pbSignature,
            &dwSignatureLen)) {
	SIGN_DBGP( ("Error %x during CryptSignHash 2!\n", GetLastError()) );
	goto CryptSignHash2Error;
    }

    SIGN_DBGP( ("Signature length = %d\n", dwSignatureLen) );
    dwCert = offsetof( WIN_CERTIFICATE, bCertificate ) + dwSignatureLen;
    if (NULL == (pCertHdr = (LPWIN_CERTIFICATE) MemAlloc(dwCert))) {
	SIGN_DBGP( ("Out of memory Cert!\n") );
        goto CertAllocError;
    }

    // Put the signature and key into the WIN_CERTIFICATE structure
    pCertHdr->dwLength = dwCert;
    pCertHdr->wRevision = WIN_CERT_REVISION_1_0;
    pCertHdr->wCertificateType = WIN_CERT_TYPE_STACK_DLL_SIGNATURE;
    memcpy( &pCertHdr->bCertificate[0], pbSignature, dwSignatureLen );

    {
        unsigned int cnt=0;
        while ( cnt < dwSignatureLen ) {
            int i;
            for ( i=0; (i < 16) && (cnt < dwSignatureLen); cnt++,i++) {
                SIGN_DBGP( ("%02x ", pCertHdr->bCertificate[cnt]) );
            }
            SIGN_DBGP( ("\n") );
        }
    }

    // Remove any and all Stack DLL Signature Certificates from PE file
    while (TRUE) {
        cCert = 0;
        dwCertIndex = 0;
        if (!ImageEnumerateCertificates(
                hFile,
                WIN_CERT_TYPE_STACK_DLL_SIGNATURE,
                &cCert,
                &dwCertIndex,
                1               // IndexCount
                )) {
            break;
        }
        if (cCert == 0) {
            break;
        }
        if (!ImageRemoveCertificate(hFile, dwCertIndex)) {
            SIGN_DBGP( ("Error %x during ImageRemoveCertificate\n",
                GetLastError()) );
            goto ImageRemoveCertificateError;
        }
    }

    if (!ImageAddCertificate(
            hFile,
            pCertHdr,
            &dwCertIndex)) {
	SIGN_DBGP( ("Error %x during ImageAddCertificate\n", GetLastError()) );
        goto ImageAddCertificateError;
    }

    fResult = TRUE;

ImageAddCertificateError:
ImageRemoveCertificateError:
    MemFree( pCertHdr );

CertAllocError:
CryptSignHash2Error:
    MemFree( pbSignature );

SigAllocError:
CryptSignHash1Error:
ImageGetDigestStreamError:
    CryptDestroyHash( dp.hHash );

CryptCreateHashError:
    CryptDestroyKey(hPrivateKeySig);

CryptImportKeyError:
    dwErr = GetLastError();
    CryptReleaseContext( hProv, 0 );
    SetLastError( dwErr );

CryptAcquireContextError:
    CloseHandle( hFile );

OpenImageFileError:
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tscert\tscrtdel\tscrtdel.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <wincrypt.h>
#include <imagehlp.h>

#define WIN_CERT_TYPE_STACK_DLL_SIGNATURE WIN_CERT_TYPE_TS_STACK_SIGNED

BOOL UnSignFile( LPWSTR wszFile );

/*****************************************************************************/
void _cdecl main(int argc, char *argv[])
{

    WCHAR szSourceFile[ MAX_PATH + 1];
    DWORD dwBc;
    
    if (argc != 2) {
        printf( "Usage: %s PE_File_Name\n", argv[0] );
        exit(1);
    }

    if(RtlMultiByteToUnicodeN( szSourceFile, sizeof(szSourceFile), &dwBc,
        argv[1], (strlen(argv[1]) + 1) ) == STATUS_SUCCESS)
    {

        if(!UnSignFile(szSourceFile)) {
	    printf("Error removing signature!\n");
	    exit(1);
        }

        printf("Signature removed successfully.\n");
        exit(0);
    }
    else
    {
        printf("RtlMultiByteToUnicode function failed.\n");
    }
}


//////////////////////////////////////////////////////////////
//
// Open a file in the appropriate permissions / mode for doing
// our signing stuff
//
//////////////////////////////////////////////////////////////
HANDLE OpenImageFile( LPCWSTR wszFile, DWORD dwAccess )
{
    HANDLE hFile;
    if (wszFile) {
        hFile = CreateFile( wszFile,
                            dwAccess,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        return hFile;
    } else {
        return INVALID_HANDLE_VALUE;
    }
}

///////////////////////////////////////////////////////////////////////
//
// Unsign Code, Data, and Resources of a PE image file
//
///////////////////////////////////////////////////////////////////////
BOOL
UnSignFile(
    LPWSTR wszFile
    )
{
    BOOL        fResult = FALSE;  // preset ERROR case
    HANDLE      hFile;
    DWORD       dwCertIndex;
    DWORD       cCert;

    if ( !(hFile = OpenImageFile( wszFile, GENERIC_WRITE | GENERIC_READ )) ) {
	printf("Error %x during OpenImageFile\n", GetLastError() );
        goto OpenImageFileError;
    }

    // Remove any and all Stack DLL Signature Certificates from PE file
    while (TRUE) {
        cCert = 0;
        dwCertIndex = 0;
        if (!ImageEnumerateCertificates(
                hFile,
                WIN_CERT_TYPE_STACK_DLL_SIGNATURE,
                &cCert,
                &dwCertIndex,
                1               // IndexCount
                )) {
            break;
        }

        if (cCert == 0) {
            break;
        }
        if (!ImageRemoveCertificate(hFile, dwCertIndex)) {
            goto ImageRemoveCertificateError;
        }
    }
    
    fResult = TRUE;

ImageRemoveCertificateError:
OpenImageFileError:
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tscert\tscrtini\privblob.h ===
unsigned char PrivateKeySigBlob[] = {
// This data is generated by obj\i386\certinit.
// Key Blob - 596 bytes
0x07, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 
0x52, 0x53, 0x41, 0x32, 0x00, 0x04, 0x00, 0x00, 
0x01, 0x00, 0x01, 0x00, 0xb1, 0xb6, 0x1b, 0x6c, 
0x05, 0xa5, 0x4e, 0xd4, 0xab, 0x64, 0xdb, 0x96, 
0x56, 0x2c, 0x96, 0xfa, 0xcf, 0x15, 0x6d, 0x73, 
0x6e, 0xbb, 0x14, 0xc6, 0xe8, 0xed, 0xd8, 0x4b, 
0xb9, 0x50, 0x66, 0x30, 0x21, 0xb0, 0x00, 0x6d, 
0x4f, 0x56, 0xe6, 0xd0, 0x99, 0x28, 0xd1, 0xf0, 
0x4a, 0xde, 0x82, 0x76, 0x25, 0xd2, 0x4c, 0xff, 
0x4e, 0x07, 0x45, 0x0c, 0x09, 0x3c, 0xd4, 0x7d, 
0x79, 0x1b, 0xab, 0x94, 0x60, 0xdc, 0x5a, 0x0b, 
0xaa, 0x1b, 0xc3, 0xc1, 0x87, 0x93, 0xda, 0xbc, 
0xb1, 0xee, 0xd0, 0x66, 0x8c, 0x94, 0x2c, 0x26, 
0x1a, 0xfa, 0x0c, 0x41, 0x20, 0x59, 0x2e, 0xda, 
0x8f, 0xa2, 0x79, 0x66, 0x0f, 0xe7, 0x10, 0xc0, 
0x89, 0x61, 0xe5, 0x56, 0x94, 0xc4, 0xb9, 0x35, 
0x61, 0x2d, 0xf9, 0x2f, 0x58, 0xb2, 0xe3, 0x09, 
0x52, 0x25, 0x20, 0x1f, 0x03, 0xcd, 0xab, 0xee, 
0xe5, 0x1b, 0xa9, 0xdb, 0x03, 0x93, 0xdb, 0x2f, 
0xc3, 0x15, 0xd1, 0xe7, 0x2e, 0xa0, 0xce, 0xb0, 
0x9b, 0x4d, 0x9f, 0x17, 0xd4, 0xe4, 0x9e, 0xfc, 
0xb0, 0x72, 0x5b, 0x78, 0x58, 0xbd, 0xef, 0x73, 
0x3c, 0xbe, 0x52, 0x09, 0xfd, 0x62, 0x08, 0x2e, 
0x7e, 0x50, 0x80, 0x6b, 0x00, 0x20, 0xbb, 0xfd, 
0xfd, 0x3b, 0x38, 0xde, 0x92, 0x5d, 0x0e, 0xf9, 
0xe4, 0xa5, 0xc6, 0x84, 0x07, 0xd8, 0xa4, 0x7a, 
0xa9, 0xf8, 0x59, 0xed, 0x3b, 0x47, 0xe9, 0x3b, 
0x03, 0x34, 0xa8, 0x54, 0xa3, 0x1c, 0x0c, 0xae, 
0x93, 0x1b, 0x1b, 0xa9, 0x27, 0xca, 0x12, 0x88, 
0xb0, 0x0c, 0xe4, 0x40, 0xbe, 0xb1, 0x4e, 0xa7, 
0x39, 0x2c, 0x62, 0x5a, 0xc7, 0x53, 0xcf, 0xb4, 
0x49, 0x20, 0x0b, 0xc5, 0x76, 0x61, 0x69, 0xa5, 
0x85, 0x17, 0xe0, 0x2b, 0x50, 0x9e, 0x57, 0xc1, 
0x5a, 0xc8, 0x6a, 0x31, 0x09, 0xd0, 0x8e, 0x2e, 
0xd0, 0x4e, 0xeb, 0xec, 0xc9, 0xda, 0x91, 0x03, 
0xf5, 0x6b, 0x64, 0x0d, 0xbc, 0x98, 0x64, 0xdc, 
0x68, 0xe7, 0x7d, 0x8c, 0x6e, 0x67, 0xcc, 0x69, 
0x9c, 0x69, 0xc0, 0x3f, 0xaa, 0xb8, 0xa9, 0x12, 
0xdc, 0x39, 0x55, 0x31, 0x83, 0xd6, 0x07, 0xf2, 
0x25, 0x9b, 0x44, 0xf4, 0xfd, 0xa2, 0xfa, 0xad, 
0xbf, 0x52, 0x1b, 0x90, 0x01, 0x8b, 0xb5, 0xd4, 
0x3d, 0x2a, 0xff, 0x60, 0x77, 0x9f, 0x56, 0xb3, 
0x36, 0xd8, 0x5a, 0x33, 0x0d, 0x3f, 0xfe, 0x92, 
0x05, 0x1d, 0x57, 0x21, 0x72, 0x65, 0x00, 0x96, 
0xc8, 0x10, 0x1c, 0xea, 0x51, 0xaf, 0xeb, 0x6a, 
0xcd, 0xc7, 0xa1, 0x5d, 0x65, 0x2d, 0x92, 0xb7, 
0x0d, 0x44, 0x50, 0x17, 0xe6, 0x93, 0xf9, 0x3e, 
0x44, 0x39, 0xcd, 0x30, 0x59, 0xb2, 0xae, 0xfd, 
0x1e, 0x9b, 0x5b, 0x64, 0x6c, 0xc7, 0xa4, 0x30, 
0x54, 0x01, 0x0f, 0x7f, 0x9d, 0xd4, 0x76, 0xc5, 
0x0d, 0xe7, 0x62, 0x99, 0x31, 0x45, 0x2c, 0x2d, 
0xf1, 0xf1, 0xf6, 0x36, 0x47, 0x32, 0x02, 0x9c, 
0xb4, 0xec, 0x6a, 0x37, 0x56, 0xee, 0x92, 0x43, 
0x3b, 0x6c, 0x51, 0xb8, 0x18, 0x09, 0x56, 0x1a, 
0x1a, 0x7c, 0xec, 0x76, 0x41, 0x44, 0xef, 0x2e, 
0x9b, 0x56, 0xcb, 0x97, 0x52, 0x29, 0x64, 0x3e, 
0x03, 0x59, 0x98, 0xe4, 0xcd, 0x4a, 0xf8, 0xd3, 
0x80, 0xb4, 0xd2, 0x4e, 0x7e, 0x58, 0x11, 0xe2, 
0x71, 0x92, 0x80, 0x45, 0xc5, 0xb2, 0xcd, 0x65, 
0xff, 0x96, 0xe9, 0xc8, 0x84, 0x58, 0x49, 0x20, 
0x26, 0x2d, 0x8e, 0x4e, 0x74, 0xd5, 0x60, 0xa5, 
0x0a, 0x7c, 0xe0, 0x3a, 0xe0, 0x1f, 0x86, 0xea, 
0xb0, 0x93, 0x5e, 0x38, 0xfb, 0xc9, 0x9d, 0xc9, 
0x13, 0xfb, 0x4e, 0x91, 0x16, 0x0a, 0x2a, 0x2a, 
0xe5, 0xb9, 0x76, 0x54, 0x9a, 0xe8, 0x35, 0x0d, 
0x32, 0x5e, 0x53, 0x5d, 0x29, 0x9b, 0x4d, 0xa5, 
0xae, 0xe5, 0xae, 0xb6, 0x67, 0xb7, 0xb2, 0xc6, 
0x6b, 0xb2, 0x37, 0x39, 0x8b, 0xd1, 0x0c, 0x6a, 
0xf3, 0x7d, 0xc6, 0xbf, 0xc1, 0x9d, 0x46, 0x96, 
0x7f, 0xa0, 0x7a, 0xc0, 0xa9, 0x36, 0x63, 0x06, 
0x9d, 0x5a, 0x21, 0x8a, 0xa3, 0x3a, 0xef, 0x44, 
0x23, 0xb2, 0xb6, 0x06, 0xcb, 0xda, 0xd1, 0x71, 
0xaf, 0x9f, 0xf9, 0x60, 0x69, 0x35, 0xc1, 0xe9, 
0xcc, 0x3f, 0x59, 0x45, 0x89, 0xa8, 0xea, 0xd2, 
0x54, 0x30, 0xaf, 0x7e, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tscert\tscrtvfy\tscrtvfy.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <wincrypt.h>
#include <imagehlp.h>

#define MemAlloc malloc
#define MemFree free

#ifdef SIGN_DEBUG
#define SIGN_DBGP(x) printf x
#else // SIGN_DEBUG
#define SIGN_DBGP(x)
#endif // SIGN_DEBUG

#include "../inc/pubblob.h"    // needed by certvfy.inc
#include "../inc/certvfy.inc"  // VerifyFile()

RTL_CRITICAL_SECTION VfyLock;

/*****************************************************************************/
void _cdecl main(int argc, char *argv[])
{
    WCHAR szSourceFile[ MAX_PATH + 1];
    DWORD dwBc;

    if ( argc != 2 ) {
        printf( "Usage: %s PE_File_Name\n", argv[0] );
        exit(1);
    }

    RtlMultiByteToUnicodeN( szSourceFile, sizeof(szSourceFile), &dwBc,
        argv[1], (strlen(argv[1]) + 1) ); 

    RtlInitializeCriticalSection( &VfyLock );

    if( !VerifyFile( szSourceFile, &VfyLock ) ) {
	printf("Error verifying file!\n");
	exit(1);
    }

    printf("Verification successful.\n");
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsdbg\exts.cpp ===
/*-----------------------------------------------------------------------------
   Copyright (c) 2000  Microsoft Corporation

Module:
  exts.cpp

  Sampe file showing couple of extension examples

-----------------------------------------------------------------------------*/
#include "tsdbg.h"


bool IsUserDbg()
{
/*
// Specific types of kernel debuggees.
#define DEBUG_KERNEL_CONNECTION  0
#define DEBUG_KERNEL_LOCAL       1
#define DEBUG_KERNEL_EXDI_DRIVER 2
#define DEBUG_KERNEL_SMALL_DUMP  DEBUG_DUMP_SMALL
#define DEBUG_KERNEL_DUMP        DEBUG_DUMP_DEFAULT
#define DEBUG_KERNEL_FULL_DUMP   DEBUG_DUMP_FULL

// Specific types of Windows user debuggees.
#define DEBUG_USER_WINDOWS_PROCESS        0
#define DEBUG_USER_WINDOWS_PROCESS_SERVER 1
#define DEBUG_USER_WINDOWS_SMALL_DUMP     DEBUG_DUMP_SMALL
#define DEBUG_USER_WINDOWS_DUMP           DEBUG_DUMP_DEFAULT
*/

/*
#define DEBUG_CLASS_UNINITIALIZED 0
#define DEBUG_CLASS_KERNEL        1
#define DEBUG_CLASS_USER_WINDOWS  2
*/

    ULONG Class, Qualifier;

	// Figure out if this is KD or NTSD piped to KD.
	if (S_OK != g_ExtControl->GetDebuggeeType(&Class, &Qualifier))
    {
        dprintf("*** GetDebuggeeType failed ***\n\n");
    }
	if (Class == DEBUG_CLASS_USER_WINDOWS)
        return true;
	else
        return false;
}



/*
   Sample extension to demonstrace ececuting debugger command
   
 */
HRESULT CALLBACK 
cmdsample(PDEBUG_CLIENT Client, PCSTR args)
{
    CHAR Input[256];
    INIT_API();

    UNREFERENCED_PARAMETER(args);

    //
    // Output a 10 frame stack
    //
    g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS |   // Flags on what to do with output
                                   DEBUG_OUTCTL_OVERRIDE_MASK |
                                   DEBUG_OUTCTL_NOT_LOGGED, 
                                   NULL, 
                                   10,           // number of frames to display
                                   DEBUG_STACK_FUNCTION_INFO | DEBUG_STACK_COLUMN_NAMES |
                                   DEBUG_STACK_ARGUMENTS | DEBUG_STACK_FRAME_ADDRESSES);
    //
    // Engine interface for print 
    //
    g_ExtControl->Output(DEBUG_OUTCTL_ALL_CLIENTS, "\n\nDebugger module list\n");
    
    //
    // list all the modules by executing lm command
    //
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                          DEBUG_OUTCTL_OVERRIDE_MASK |
                          DEBUG_OUTCTL_NOT_LOGGED,
                          "lm", // Command to be executed
                          DEBUG_EXECUTE_DEFAULT );
    
    //
    // Ask for user input
    //
    g_ExtControl->Output(DEBUG_OUTCTL_ALL_CLIENTS, "\n\n***User Input sample\n\nEnter Command to run : ");
    GetInputLine(NULL, &Input[0], sizeof(Input));
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                          DEBUG_OUTCTL_OVERRIDE_MASK |
                          DEBUG_OUTCTL_NOT_LOGGED,
                          Input, // Command to be executed
                          DEBUG_EXECUTE_DEFAULT );
    
    EXIT_API();
    return S_OK;
}

/*
  Sample extension to read and dump a struct on target
    
  This reads the struct _EXCEPTION_RECORD which is defined as:
  
  typedef struct _EXCEPTION_RECORD {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    ULONG NumberParameters;
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
    } EXCEPTION_RECORD;
*/
HRESULT CALLBACK 
structsample(PDEBUG_CLIENT /*Client*/, PCSTR /*args*/)
{
    /*
    ULONG64 Address;
    INIT_API();

    Address = GetExpression(args);
    
    DWORD Buffer[4], cb;

    // Read and display first 4 dwords at Address
    if (ReadMemory(Address, &Buffer, sizeof(Buffer), &cb) && cb == sizeof(Buffer)) {
        dprintf("%p: %08lx %08lx %08lx %08lx\n\n", Address,
                Buffer[0], Buffer[1], Buffer[2], Buffer[3]);
    }

    //
    // Method 1 to dump a struct
    //
    dprintf("Method 1:\n");
    // Inititalze type read from the Address
    if (InitTypeRead(Address, _EXCEPTION_RECORD) != 0) {
        dprintf("Error in reading _EXCEPTION_RECORD at %p", // Use %p to print pointer values
                Address);
    } else {
        // read and dump the fields
        dprintf("_EXCEPTION_RECORD @ %p\n", Address);
        dprintf("\tExceptionCode           : %lx\n", (ULONG) ReadField(ExceptionCode));
        dprintf("\tExceptionAddress        : %p\n", ReadField(ExceptionAddress));
        dprintf("\tExceptionInformation[1] : %I64lx\n", ReadField(ExceptionInformation[1]));
        // And so on...
    }

    //
    // Method 2 to read a struct
    //
    ULONG64 ExceptionInformation_1, ExceptionAddress, ExceptionCode;
    dprintf("\n\nMethod 2:\n");
    // Read and dump the fields by specifying type and address individually 
    if (GetFieldValue(Address, "_EXCEPTION_RECORD", "ExceptionCode", ExceptionCode)) {
        dprintf("Error in reading _EXCEPTION_RECORD at %p\n",
                Address);
    } else {
        // Pointers are read as ULONG64 values
        GetFieldValue(Address, "_EXCEPTION_RECORD", "ExceptionAddress", ExceptionAddress);
        GetFieldValue(Address, "_EXCEPTION_RECORD", "ExceptionInformation[1]", ExceptionInformation_1);
        // And so on..
        
        dprintf("_EXCEPTION_RECORD @ %p\n", Address);
        dprintf("\tExceptionCode           : %lx\n", ExceptionCode);
        dprintf("\tExceptionAddress        : %p\n", ExceptionAddress);
        dprintf("\tExceptionInformation[1] : %I64lx\n", ExceptionInformation_1);
    }

    ULONG64 Module;
    ULONG   i, TypeId;
    CHAR Name[MAX_PATH];
    //
    // To get/list field names
    //
    g_ExtSymbols->GetSymbolTypeId("_EXCEPTION_RECORD", &TypeId, &Module);
    dprintf("Fields of _EXCEPTION_RECORD\n");
    for (i=0; ;i++) {
	HRESULT Hr;
	ULONG Offset=0;

	Hr = g_ExtSymbols2->GetFieldName(Module, TypeId, i, Name, MAX_PATH, NULL);
	if (Hr == S_OK) {
	    g_ExtSymbols->GetFieldOffset(Module, TypeId, Name, &Offset);
	    dprintf("%lx (+%03lx) %s\n", i, Offset, Name);
	} else if (Hr == E_INVALIDARG) {
	    // All Fields done
	    break;
	} else {
	    dprintf("GetFieldName Failed %lx\n", Hr);
	    break;
	}
    }

    //
    // Get name for an enumerate
    //
    //     typedef enum {
    //        Enum1,
    //	      Enum2,
    //        Enum3,
    //     } TEST_ENUM;
    //
    ULONG   ValueOfEnum = 0;
    g_ExtSymbols->GetSymbolTypeId("TEST_ENUM", &TypeId, &Module);
    g_ExtSymbols2->GetConstantName(Module, TypeId, ValueOfEnum, Name, MAX_PATH, NULL);
    dprintf("Testenum %I64lx == %s\n", ExceptionCode, Name);
    // This prints out, Testenum 0 == Enum1

    //
    // Read an array
    //
    //    typedef struct FOO_TYPE {
    //      ULONG Bar;
    //      ULONG Bar2;
    //    } FOO_TYPE;
    //
    //    FOO_TYPE sampleArray[20];
    ULONG Bar, Bar2;
    CHAR TypeName[100];
    for (i=0; i<20; i++) {
	sprintf(TypeName, "sampleArray[%lx]", i);
	if (GetFieldValue(0, TypeName, "Bar", Bar)) 
	    break;
	GetFieldValue(0, TypeName, "Bar2", Bar2);
	dprintf("%16s -  Bar %2ld  Bar2 %ld\n", TypeName, Bar, Bar2);
    }

    EXIT_API();
    */
    return S_OK;
    
}

/*
  This gets called (by DebugExtensionNotify whentarget is halted and is accessible
*/
HRESULT 
NotifyOnTargetAccessible(PDEBUG_CONTROL  /* Control */)
{/*
    dprintf("Extension dll detected a break");
    if (Connected) {
        dprintf(" connected to ");
        switch (TargetMachine) { 
        case IMAGE_FILE_MACHINE_I386:
            dprintf("X86");
            break;
        case IMAGE_FILE_MACHINE_AMD64:
            dprintf("AMD64");
            break;
        case IMAGE_FILE_MACHINE_IA64:
            dprintf("IA64");
            break;
        default:
            dprintf("Other");
            break;
        }
    }
    dprintf("\n");
    
    //
    // show the top frame and execute dv to dump the locals here and return
    //
    Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                     DEBUG_OUTCTL_OVERRIDE_MASK |
                     DEBUG_OUTCTL_NOT_LOGGED,
                     ".frame", // Command to be executed
                     DEBUG_EXECUTE_DEFAULT );
    Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                     DEBUG_OUTCTL_OVERRIDE_MASK |
                     DEBUG_OUTCTL_NOT_LOGGED,
                     "dv", // Command to be executed
                     DEBUG_EXECUTE_DEFAULT );
*/
    return S_OK;
}

/*
  A built-in help for the extension dll
*/
HRESULT CALLBACK 
help(PDEBUG_CLIENT Client, PCSTR args)
{
    INIT_API();

    UNREFERENCED_PARAMETER(args);

    dprintf("Help for tsdbg.dll\n"
            "  qwinsta             - lists winstation data structures\n"
            "  help                = Shows this help\n"
            // "  structsample <addr> - This dumps a struct at given address\n"
            //"  cmdsample           - This does stacktrace and lists\n"
            );
    EXIT_API();

    return S_OK;
}


void PrintBuildNumber()
{
    ULONG64 Address;
    Address = GetExpression("poi(nt!ntbuildnumber)");

    
    if (Address & 0xf0000000)
    {
        Address &= 0x0fffffff;
        dprintf("Build Number = %d Free\n", Address);
        
    }
    else if (Address & 0xc0000000)
    {
        Address &= 0x0fffffff;
        dprintf("Build Number = %d Chk\n", Address);
     
    }
    else
    {
        dprintf("Error getting Build Number!\n");
        
    }

}




HRESULT CALLBACK 
qwinsta(PDEBUG_CLIENT Client, PCSTR args)
{
    ULONG64 winstationlisthead, FLink;
    ULONG64 TermSrvProcPerTermDD = 0;


    bool bDebugMode = false;

    INIT_API();

    dprintf("qwinsta 1.2\n");
    
    if (strstr(args, "debug"))
        bDebugMode = true;

    if (bDebugMode)
    {
        dprintf("*** in debug mode *** \n");
    }

    if (bDebugMode)
        dprintf("IsUserDebugger = %s\n", (IsUserDbg() ? "true" : "false"));


    dprintf("----------------------------------------------------------------------------------------------------\n");
    //
    // Find Termsrv proccess id.
    //
    if (!IsUserDbg())
    {
        TermSrvProcPerTermDD = GetExpression("poi(termdd!g_TermServProcessID)");
        dprintf("termsrv process    = %p \n", TermSrvProcPerTermDD);

        if (!TermSrvProcPerTermDD)
        {
            dprintf("ERROR:tsdbg failed to retrive the value for termdd!g_TermServProcessID\n");
            dprintf("please make sure that the symbols are alright\n");
            goto doneError;
        }
      
        ULONG64 ImpliciteProcess;
        g_ExtSysObjects2->GetImplicitProcessDataOffset(&ImpliciteProcess);
        dprintf("Implicit Process   = %p \n", ImpliciteProcess);

        ULONG64 CurrentProcess;
        g_ExtSysObjects2->GetCurrentProcessDataOffset(&CurrentProcess);
        dprintf("current Process    = %p \n", CurrentProcess);

        if (ImpliciteProcess != TermSrvProcPerTermDD)
        {
            dprintf("ERROR:tsdbg for this command to work current implicite process must be termsrv.\n");
            dprintf("please do .process /p %p and then try again.\n", TermSrvProcPerTermDD);
            goto doneError;
        }
    }

    //
    // get active console session id.
    //
    LONG ActiveConsoleId = STATUS_UNSUCCESSFUL;
    if (GetFieldValue((ULONG64) MM_SHARED_USER_DATA_VA, "termsrv!KUSER_SHARED_DATA", "ActiveConsoleId", ActiveConsoleId))
        ActiveConsoleId = STATUS_UNSUCCESSFUL;
    
    dprintf("ActiveConsoleId    = %d \n", ActiveConsoleId);

    //
    // winstation list head.
    //
    winstationlisthead = GetExpression("termsrv!winstationlisthead");
    if (!winstationlisthead)
    {
        dprintf("ERROR:tsdbg failed to retrive the value for termsrv!winstationlisthead\n");
        dprintf("please make sure that the symbols are alright\n");
        goto doneError;
    }

    dprintf("winstationlisthead = %p \n", winstationlisthead);

    if (GetFieldValue(winstationlisthead, "termsrv!LIST_ENTRY", "Flink", FLink))
    {
        dprintf("failed to get winstationlisthead.flink\n\n");
        goto doneError;
    }

    UINT uiWinstations = 0;

    //
    // print winstation list.
    //
    dprintf("----------------------------------------------------------------------------------------------------\n");
    dprintf("%8s", "Winsta");
    dprintf("  ");
    dprintf("%7s",  "LogonId");
    dprintf("  ");
    dprintf("%-10s", "Name");
    dprintf("  ");
    dprintf("%-22s", "State");
    dprintf("  ");
    dprintf("%8s",  "Flags");
    dprintf("  ");
    dprintf("%8s",  "SFlags");
    dprintf("  ");
    dprintf("%-10s", "Starting");
    dprintf("  ");
    dprintf("%-10s", "Terminating");
    dprintf("\n");
    while (winstationlisthead != FLink && uiWinstations < 500)
    {
        if (CheckControlC()) goto doneError;

        uiWinstations++;
        ULONG ret = 0;

        ULONG LogonId, State, Flags, StateFlags;
        WCHAR WinStationName[33];
        UCHAR Starting, Terminating;

        
        // InitTypeRead(FLink, Type)

        ret += GetFieldValue(FLink, "termsrv!_WINSTATION", "LogonId", LogonId);
        ret += GetFieldValue(FLink, "termsrv!_WINSTATION", "WinStationName", WinStationName);
        ret += GetFieldValue(FLink, "termsrv!_WINSTATION", "State", State);
        ret += GetFieldValue(FLink, "termsrv!_WINSTATION", "Flags", Flags);
        ret += GetFieldValue(FLink, "termsrv!_WINSTATION", "Starting", Starting);
        ret += GetFieldValue(FLink, "termsrv!_WINSTATION", "LogonId", LogonId);
        ret += GetFieldValue(FLink, "termsrv!_WINSTATION", "Terminating", Terminating);
        ret += GetFieldValue(FLink, "termsrv!_WINSTATION", "StateFlags", StateFlags);
        

        //
        // get string value for the enum _WINSTATIONSTATECLASS.
        //
        ULONG64 Module;
        ULONG   TypeId;
        char StateName[MAX_PATH];
        g_ExtSymbols->GetSymbolTypeId("_WINSTATIONSTATECLASS", &TypeId, &Module);
        g_ExtSymbols2->GetConstantName(Module, TypeId, State, StateName, MAX_PATH, NULL);

        if (ret)
        {
            dprintf("failed to get winstationlisthead.flink\n\n");
            goto doneError;
        }

        dprintf("%p", FLink);
        dprintf("  ");
        dprintf("%#7x",  LogonId);
        dprintf("  ");
        dprintf("%-10S", WinStationName);
        dprintf("  ");
        dprintf("%1x:%-20s", State, StateName);
        dprintf("  ");
        dprintf("%08x", Flags);
        dprintf("  ");
        dprintf("%08x", StateFlags);
        dprintf("  ");
        dprintf("%-10s", (Starting ? "True" : "False"));
        dprintf("  ");
        dprintf("%-10s", (Terminating ? "True" : "False"));
        dprintf("\n");
    
        //dprintf("%10p %7d %-10S %5d:%-20s %5d %10d %-8s %-11s\n", FLink, LogonId, WinStationName, State, StateName, Flags, StateFlags, (Starting ? "true" : "false"), (Terminating ? "true" : "false"));

        if (GetFieldValue(FLink, "termsrv!LIST_ENTRY", "Flink", FLink))
        {
            dprintf("failed to get winstationlisthead.flink\n\n");
            goto doneError;
        }


    }
    dprintf("----------------------------------------------------------------------------------------------------\n");
    // dprintf("Total Winstations = %d\n", uiWinstations);
    

doneError:

    EXIT_API();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsdbg\tsdbg.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbgexts.cpp

Abstract:

    This file contains the generic routines and initialization code
    for the debugger extensions dll.

--*/

#include "tsdbg.h"


PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYMBOLS2       g_ExtSymbols2;
PDEBUG_SYSTEM_OBJECTS g_ExtSysObjects;
PDEBUG_SYSTEM_OBJECTS2 g_ExtSysObjects2;

WINDBG_EXTENSION_APIS   ExtensionApis;

ULONG   TargetMachine;
BOOL    Connected;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                (void **)&g_ExtSymbols)) != S_OK)
    {
	goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols2),
                                (void **)&g_ExtSymbols2)) != S_OK)
    {
	goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                (void **)&g_ExtSysObjects)) != S_OK)
    {
	goto Fail;
    }
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                (void **)&g_ExtSysObjects2)) != S_OK)
    {
	goto Fail;
    }

    g_ExtClient = Client;
    

    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSymbols2);
    EXT_RELEASE(g_ExtSysObjects);
    EXT_RELEASE(g_ExtSysObjects2);
}

extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                  (void **)&DebugControl)) == S_OK)
    {

        //
        // Get the windbg-style extension APIS
        //
        ExtensionApis.nSize = sizeof (ExtensionApis);
        if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK)
            return Hr;
        
        DebugControl->Release();

    }
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    UNREFERENCED_PARAMETER(Argument);
    
    //
    // The first time we actually connect to a target
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        HRESULT Hr;
        PDEBUG_CONTROL DebugControl;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                       (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                                             &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }

                NotifyOnTargetAccessible(DebugControl);

                DebugControl->Release();
            }
 
            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tscert\tscrtini\tscrtini.c ===
/******************************************************************************\
*       Adapted by Bruce Fortune (Citrix Systems, Inc.) from MS Online Source 
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1996 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>

#define SIGKEYSIZE 1024

#define PUBBLOBFILE "pubblob.h"
#define PRIVBLOBFILE "privblob.h"

//
// LINE_VALS - maximum number of byte values printed on each line of
//             the "blob" files
//
#define LINE_VALS 8

char *pszProgname; // program name - from argv[0]


BOOL
OpenBlobFile(
    FILE **file,
    CHAR *fname
    )
{
    *file = fopen( fname, "wt" );
    if ( !*file ) {
        return(FALSE);
    }
    return(TRUE);
}

void
DumpKeyBlob(
    FILE *file,
    DWORD dwBlobType,
    HCRYPTKEY hKey,
    HCRYPTKEY hExportKey )
{
    int dwBlobCount;
    if (!CryptExportKey(
            hKey,
            hExportKey,
            dwBlobType,
            0,
            NULL,
            &dwBlobCount)) {
        printf( "Error %x during CryptExportKey 1!\n", GetLastError());
        exit(1);
    } else {
        PBYTE pBlob;
        pBlob = (PBYTE) malloc( dwBlobCount );
        if ( !pBlob || !CryptExportKey(
                hKey,
                hExportKey,
                dwBlobType,
                0,
                pBlob,
                &dwBlobCount)) {
            printf("Error %x during malloc/CryptExportKey 2!\n",
                GetLastError());
            exit(1);
        } else {
            int cnt=0;
            fprintf( file, "// This data is generated by %s.\n", pszProgname );
            fprintf( file, "// Key Blob - %d bytes\n",
                dwBlobCount );
            while ( cnt < dwBlobCount ) {
                int i;
                for ( i=0; (i < LINE_VALS) && (cnt < dwBlobCount); cnt++,i++) {
                    fprintf( file, "0x%02x, ", *(pBlob+cnt) );
                }
                fprintf( file, "\n" );
            }
            free( pBlob );
        }
    }
}

/*****************************************************************************/
void _cdecl main(int argc, char *argv[])
{
    HCRYPTPROV hProv;
    HCRYPTKEY hSigKey;
    CHAR szUserName[100];
    DWORD dwUserNameLen = 100;
    FILE *blobfile;

    pszProgname = argv[0];

    // Attempt to acquire a handle to the default key container.
    if(!CryptAcquireContext(&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, 0)) {
	// Some sort of error occured.

	// Create default key container.
	if(!CryptAcquireContext(&hProv, NULL, MS_DEF_PROV,
                PROV_RSA_FULL, CRYPT_NEWKEYSET)) {
	    printf("Error creating key container!\n");
	    exit(1);
	}

	// Get name of default key container.
	if(!CryptGetProvParam(hProv, PP_CONTAINER, szUserName,
                &dwUserNameLen, 0)) {
	    // Error getting key container name.
	    szUserName[0] = 0;
	}

	printf("Create key container '%s'\n",szUserName);
    }

    // Attempt to get handle to signature key.
    // Commented out the following 2 lines. We always gerenate a new signature key. TSE4.0
    // uses the existing key which seems to generate the same key all the time.
    //    if( !CryptGetUserKey(hProv, AT_SIGNATURE, &hSigKey)) {
    //	if( GetLastError() == NTE_NO_KEY) {
    //
    // Create signature key pair.
    //
    printf("Creating signature key pair...");

    if (!CryptGenKey( hProv,
                      AT_SIGNATURE,
                      (SIGKEYSIZE << 16 ) | CRYPT_EXPORTABLE,
                      &hSigKey)) {
        printf("Error %x during CryptGenKey!\n", GetLastError());
        exit(1);
    } else {
        // Get Public Key BLOB
        if ( !OpenBlobFile( &blobfile, PUBBLOBFILE ) ) {
            printf( "Error %x during OpenBlobFile!\n", GetLastError() );
            exit(1);
        }
        fprintf( blobfile, "unsigned char PublicKeySigBlob[] = {\n" );
        DumpKeyBlob( blobfile, PUBLICKEYBLOB, hSigKey, 0 );
        fprintf( blobfile, "};\n" );

    }

    
#if 0 // Commented out the following code. We always gerenate a new signature key. TSE4.0
      // uses the existing key which seems to generate the same key all the time.

	} else {
	    printf("Error %x during CryptGetUserKey!\n", GetLastError());
	    exit(1);
	}
    } else {
        // Get Public Key BLOB
        printf( "Using existing keys..." );
        if ( !OpenBlobFile( &blobfile, PUBBLOBFILE ) ) {
            printf( "Error %x during OpenBlobFile!\n", GetLastError() );
            exit(1);
        }
        fprintf( blobfile, "unsigned char PublicKeySigBlob[] = {\n" );
        DumpKeyBlob( blobfile, PUBLICKEYBLOB, hSigKey, 0 );
        fprintf( blobfile, "};\n" );
    }
#endif

    // Get Private Key BLOB
    if ( !OpenBlobFile( &blobfile, PRIVBLOBFILE ) ) {
        printf( "Error %x during OpenBlobFile - %s!\n",
            GetLastError(),
            PRIVBLOBFILE );
        exit(1);
    }
    fprintf( blobfile, "unsigned char PrivateKeySigBlob[] = {\n" );
    DumpKeyBlob( blobfile, PRIVATEKEYBLOB, hSigKey, 0 );
    fprintf( blobfile, "};\n" );
    CryptDestroyKey(hSigKey);

    CryptReleaseContext(hProv,0);

    printf( " successful.\n" );
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsdbg\tsdbg.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbgexts.h

--*/

#pragma warning(disable:4245)
// #pragma push(warning:C4245)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define KDEXT_64BIT
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dbgeng.h>



#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif


#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#define EXIT_API     ExtRelease


// Global variables initialized by query.
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYMBOLS2       g_ExtSymbols2;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSysObjects;
extern PDEBUG_SYSTEM_OBJECTS2 g_ExtSysObjects2;


extern BOOL  Connected;
extern ULONG TargetMachine;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

HRESULT 
NotifyOnTargetAccessible(PDEBUG_CONTROL Control);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\adstsprops.h ===
#include <ntsecapi.h>

#define USER_PROPERTY_SIGNATURE L'P'

#define NO_LIMIT  0xffff


#define USER_PROPERTY_TYPE_ITEM 1
#define USER_PROPERTY_TYPE_SET  2

extern "C" {
NTSTATUS
UsrPropGetValue(
   TCHAR * pValueName,
   PVOID pValue,
   ULONG ValueLength,
   WCHAR * pUserParms
   );

NTSTATUS
UsrPropSetValue(
   WCHAR * pValueName,
   PVOID pValue,
   USHORT ValueLength,
   BOOL fDefaultValue,
   WCHAR * pUserParms,
   ULONG UserParmsLength
   
   );

NTSTATUS
UsrPropGetString(
   TCHAR * pStringName,
   TCHAR * pStringValue,
   ULONG StringValueLength,
   WCHAR * pUserParms
   );

NTSTATUS
UsrPropSetString(
   WCHAR * pStringName,
   WCHAR * pStringValue,
   WCHAR * pUserParms,
   ULONG UserParmsLength,
   BOOL fDefaultValue
   );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\ads.cpp ===
/*++
Copyright (c) 2001  Microsoft Corporation

Module Name:

    ads.cpp

Abstract:

    This module implements ADSI extension for Terminal Server User Properties.

Author:

    Rashmi Patankar (RashmiP) 10-Aug-2001

Revision History:

--*/

#include "stdafx.h"
#include "ADsTSProps.h"
#include <ntsam.h>
#include <shlwapi.h>

#define MAX_STRING_SIZE 256
#define CTX_USER_PARAM_MAX_SIZE (3 * sizeof(USERCONFIG))
#define PARMS_SIZE 15520


#ifndef RETURN_ON_FAILURE
    #define RETURN_ON_FAILURE(expr) { \
    HRESULT HiddenHr = expr; if ( !SUCCEEDED(HiddenHr) ) { return HiddenHr; }\
}
#endif


#ifndef BREAK_ON_FAILURE
    #define BREAK_ON_FAILURE(x)  hr = x; if (!SUCCEEDED(hr)) break
#endif


#define RETURN_ON_INVALID_PARAMETER(x)  if(x!=FALSE && x!=TRUE) {return E_ADS_BAD_PARAMETER;}


// Static variables
CComTypeInfoHolder ADsTSUserEx::m_StaticHolder =
       { &__uuidof(IADsTSUserEx), &LIBID_TSUSEREXLib, 1, 0, NULL, 0 };

SERVER_TO_MODE           ADsTSUserEx::m_StaticServerMap;
CComPtr<IADsPathname>    ADsTSUserEx::m_StaticpPath(NULL);
CComAutoCriticalSection  ADsTSUserEx::m_StaticCritSec;


#define INMINUTES 60000
#define MAX_TIME_LIMIT 71580
#define ARRAYSIZE(A) ((sizeof(A))/sizeof(A[0]))
#define NCP_SET             0x02    /* Series of Object ID numbers, each 4
                                       bytes long */
#define WIN_CFGPRESENT L"CfgPresent"
#define CFGPRESENT_VALUE 0xB00B1E55

#define F1MSK_INHERITAUTOLOGON            0x80000000
#define F1MSK_INHERITRESETBROKEN          0x40000000
#define F1MSK_INHERITRECONNECTSAME        0x20000000
#define F1MSK_INHERITINITIALPROGRAM       0x10000000
#define F1MSK_INHERITCALLBACK             0x08000000
#define F1MSK_INHERITCALLBACKNUMBER       0x04000000
#define F1MSK_INHERITSHADOW               0x02000000
#define F1MSK_INHERITMAXSESSIONTIME       0x01000000
#define F1MSK_INHERITMAXDISCONNECTIONTIME 0x00800000
#define F1MSK_INHERITMAXIDLETIME          0x00400000
#define F1MSK_INHERITAUTOCLIENT           0x00200000
#define F1MSK_INHERITSECURITY             0x00100000
#define F1MSK_PROMPTFORPASSWORD           0x00080000
#define F1MSK_RESETBROKEN                 0x00040000
#define F1MSK_RECONNECTSAME               0x00020000
#define F1MSK_LOGONDISABLED               0x00010000
#define F1MSK_AUTOCLIENTDRIVES            0x00008000
#define F1MSK_AUTOCLIENTLPTS              0x00004000
#define F1MSK_FORCECLIENTLPTDEF           0x00002000
#define F1MSK_DISABLEENCRYPTION           0x00001000
#define F1MSK_HOMEDIRECTORYMAPROOT        0x00000800
#define F1MSK_USEDEFAULTGINA              0x00000400
#define F1MSK_DISABLECPM                  0x00000200
#define F1MSK_DISABLECDM                  0x00000100
#define F1MSK_DISABLECCM                  0x00000080
#define F1MSK_DISABLELPT                  0x00000040
#define F1MSK_DISABLECLIP                 0x00000020
#define F1MSK_DISABLEEXE                  0x00000010
#define F1MSK_WALLPAPERDISABLED           0x00000008
#define F1MSK_DISABLECAM                  0x00000004
#define DEFAULTFLAGS (F1MSK_INHERITAUTOLOGON|F1MSK_INHERITINITIALPROGRAM|F1MSK_INHERITAUTOCLIENT|F1MSK_AUTOCLIENTDRIVES|F1MSK_AUTOCLIENTLPTS|F1MSK_FORCECLIENTLPTDEF|F1MSK_DISABLEENCRYPTION)


#define BAIL_IF_ERROR(hr) if (FAILED(hr)) { goto cleanup; }


namespace
{
    const WCHAR OS_VERSION_4[]          = L"4.0";
    const WCHAR OS_VERSION_5[]          = L"5.0";
    const WCHAR OS_VERSION_51[]         = L"5.1";
    const WCHAR LDAP_PREFIX[]           = L"LDAP://";

    WCHAR LDAP_PARAMETERS_NAME[]        = L"UserParameters";
    WCHAR WINNT_PARAMETERS_NAME[]       = L"Parameters";

    WCHAR WIN_WFPROFILEPATH[]           = L"WFProfilePath";
    WCHAR WIN_WFHOMEDIR[]               = L"WFHomeDir";
    WCHAR WIN_WFHOMEDIRDRIVE[]          = L"WFHomeDirDrive";
    WCHAR WIN_NWLOGONSERVER[]           = L"NWLogonServer";
    WCHAR WIN_SHADOW[]                  = L"Shadow";
    WCHAR WIN_MAXCONNECTIONTIME[]       = L"MaxConnectionTime";
    WCHAR WIN_MAXDISCONNECTIONTIME[]    = L"MaxDisconnectionTime";
    WCHAR WIN_MAXIDLETIME[]             = L"MaxIdleTime";
    WCHAR WIN_FLAGS1[]                  = L"CfgFlags1";
    WCHAR WIN_INITIALPROGRAM[]          = L"InitialProgram";
    WCHAR WIN_WORKDIRECTORY[]           = L"WorkDirectory";
}

typedef struct _USER_PROPERTY {
    WCHAR   PropertyLength;     // length of property name
    WCHAR   ValueLength;        // length of property value
    WCHAR   PropertyFlag;       // type of property (1 = set, 2 = item)
    WCHAR   Property[1];        // start of property name, followed by value
} USER_PROPERTY, *PUSER_PROPERTY;

//
//  This is the structure that maps the beginning of the user's Parameters
//  field.  It is only separate so that we can do a sizeof() without including
//  the first property, which may or may not be there.
//

typedef struct _USER_PROPERTIES_HDR {
    WCHAR   BacklevelParms[48];     // RAS & Mac data stored here.
    WCHAR   PropertySignature;      // signature that we can look for.
    WCHAR   PropertyCount;          // number of properties present.
} USER_PROPERTIES_HDR, *PUSER_PROPERTIES_HDR;

//
//  This structure maps out the whole of the user's Parameters field when
//  the user properties structure is present and at least one property is
//  defined.
//

typedef struct _USER_PROPERTIES {
    USER_PROPERTIES_HDR Header;
    USER_PROPERTY   FirstProperty;
} USER_PROPERTIES, *PUSER_PROPERTIES;



ADsTSUserEx::ADsTSUserEx()
{
    HRESULT hr            = NULL;
    ITypeLib   *pITypeLib = NULL;
    m_pTypeInfo           = NULL;
    m_vbIsLDAP            = FALSE;
    m_vbUpLevelAllowed    = FALSE;
    m_pOuterDispatch      = NULL;
    m_pADs                = NULL;
    
    hr = LoadRegTypeLib(LIBID_TSUSEREXLib,
                        1,
                        0,
                        PRIMARYLANGID(GetSystemDefaultLCID()),
                        &pITypeLib );

    if ( SUCCEEDED(hr) )
    {
        hr = pITypeLib->GetTypeInfoOfGuid( IID_IADsTSUserEx, &m_pTypeInfo);
    }

    pITypeLib->Release();
}


ADsTSUserEx::~ADsTSUserEx()
{
    if ( m_pTypeInfo )
    {
        m_pTypeInfo->Release();
    }
}



/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP ADsTSUserEx::InterfaceSupportsErrorInfo(REFIID riid) throw()
{

    static const IID* arr[] =
    {
        &__uuidof(IADsTSUserEx),
    };

    for ( int i=0; i < sizeof(arr)/sizeof(arr[0]); ++i )
    {
        if (InlineIsEqualGUID(*arr[i],riid))
        {
            return S_OK;
        }
    }

    return S_FALSE;

}

//////////////////////////////////////////////////////////////////////////////
// ADsTSUserEx::InternalGetLong
//////////////////////////////////////////////////////////////////////////////
HRESULT ADsTSUserEx::InternalGetLong(/*in*/   BSTR  bstrProperty,
                                     /*out*/  LONG  *lpVal) throw()
{
    _ASSERT(lpVal);
    
    HRESULT hr       = S_OK;
    LONG    lVal     = 0;   
    LONG    UPLength = 0;
    TCHAR * pTemp    = NULL;
    VARIANT Parms;

    *lpVal = 0;

    VariantInit(&Parms);

    if( m_vbIsLDAP )
    {
        hr = m_pADs->Get(LDAP_PARAMETERS_NAME, &Parms);
    }
    else
    {
        hr = m_pADs->Get(WINNT_PARAMETERS_NAME, &Parms);
    }

    if(ERROR_SUCCESS != hr)
    {
        hr = S_OK;
        goto cleanup;
    }

    UPLength = (SysStringLen(Parms.bstrVal ) +
                        CTX_USER_PARAM_MAX_SIZE+1) * sizeof(WCHAR);

    pTemp = (TCHAR*)LocalAlloc(LPTR, UPLength);
                
    if(NULL == pTemp)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    memcpy(pTemp, V_BSTR(&Parms), SysStringLen(Parms.bstrVal)*sizeof(WCHAR));

    if( SUCCEEDED(hr) )
    {
        if(m_vbUpLevelAllowed)
        {
            NTSTATUS ntstatus = UsrPropGetValue(bstrProperty, &lVal, sizeof(lVal), pTemp);

            if( ntstatus == STATUS_SUCCESS )
            {
                *lpVal = lVal;
            }
            else if(ntstatus == STATUS_OBJECT_NAME_NOT_FOUND)
            {
                if(_wcsicmp(bstrProperty, L"Shadow") == 0)
                {
                    *lpVal = 1;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

cleanup:

    if(NULL != pTemp)
    {
        LocalFree(pTemp);
    }

    VariantClear(&Parms);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// InternalSetValue
//
// Most of the complexity of this dll is here.
//////////////////////////////////////////////////////////////////////////////
HRESULT ADsTSUserEx::InternalSetValue(/*[in]*/ WCHAR *wszProperty,
                                      /*[in]*/ LONG  lNewVal) throw()
{


    HRESULT hr       = S_OK;
    ULONG   UPLength = 0;        
    TCHAR*  pTemp    = NULL;
    VARIANT Parms;
    VARIANT var;
    ULONG ulFlags = DEFAULTFLAGS;
    ULONG CfgPresent = CFGPRESENT_VALUE;

    VariantInit(&var);
    
    ///////////////////////////
    // If the provider is LDAP
    ///////////////////////////

    if(m_vbUpLevelAllowed)
    {
        if ( m_vbIsLDAP )
        {                      
            hr = m_pADs->Get(LDAP_PARAMETERS_NAME, &Parms);

            if( ERROR_SUCCESS != hr )
            {
                Parms.bstrVal = SysAllocString(L"CtxCfgPresent"); 
                UPLength =  PARMS_SIZE;
            }

            UPLength = (SysStringLen(Parms.bstrVal) +
                        CTX_USER_PARAM_MAX_SIZE+1) *
                        sizeof(WCHAR);

            pTemp = (TCHAR*)LocalAlloc(LPTR, UPLength);

            if(NULL == pTemp)
            {
                hr = E_OUTOFMEMORY;

                goto cleanup;
            } 

            memcpy(pTemp, V_BSTR(&Parms), SysStringLen(Parms.bstrVal)*sizeof(WCHAR)); 

            hr = UsrPropGetValue( WIN_FLAGS1,
                                  &ulFlags,
                                  sizeof(ulFlags),
                                  pTemp ) ;

            if( ERROR_SUCCESS != hr )
            {       
                ulFlags = DEFAULTFLAGS;

                UsrPropSetValue( WIN_CFGPRESENT,
                                  &CfgPresent,
                                  sizeof(CfgPresent),
                                  FALSE,
                                  pTemp,
                                  UPLength );

                UsrPropSetValue(WIN_FLAGS1,
                             &ulFlags,
                             sizeof(ulFlags),
                             FALSE,
                             pTemp,
                             UPLength
                             );             
            }

            hr = UsrPropSetValue(wszProperty,
                                 &lNewVal,
                                 sizeof(lNewVal),
                                 FALSE,
                                 pTemp,
                                 UPLength
                                 );
            
            if( ERROR_SUCCESS != hr )
            {
                goto cleanup;
            }
            
            V_BSTR(&var) = SysAllocString(pTemp);
            V_VT(&var) = VT_BSTR;
            // Now set the info
            hr = m_pADs->Put(LDAP_PARAMETERS_NAME, var);

        }
        else
        {
            hr = m_pADs->Get(WINNT_PARAMETERS_NAME, &Parms);

            if( ERROR_SUCCESS != hr )
            {
                goto cleanup;
            }
        
            UPLength = (SysStringLen(Parms.bstrVal) +
                        CTX_USER_PARAM_MAX_SIZE+1) *
                        sizeof(WCHAR);

            pTemp = (TCHAR*)LocalAlloc(LPTR, UPLength);

            if(NULL == pTemp)
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }  

            memcpy(pTemp, V_BSTR(&Parms), SysStringLen(Parms.bstrVal)*sizeof(WCHAR)); 


            hr = UsrPropGetValue( WIN_FLAGS1,
                                  &ulFlags,
                                  sizeof(ulFlags),
                                  pTemp ) ;

            if( ERROR_SUCCESS != hr )
            {   
                ulFlags = DEFAULTFLAGS;

                UsrPropSetValue( WIN_CFGPRESENT,
                                  &CfgPresent,
                                  sizeof(CfgPresent),
                                  FALSE,
                                  pTemp,
                                  UPLength );

                UsrPropSetValue(WIN_FLAGS1,
                             &ulFlags,
                             sizeof(ulFlags),
                             FALSE,
                             pTemp,
                             UPLength
                             );             
            }


            hr = UsrPropSetValue(wszProperty,
                                 &lNewVal,
                                 sizeof(lNewVal),
                                 FALSE,
                                 pTemp,
                                 UPLength
                                 );

            if( ERROR_SUCCESS != hr )
            {
                goto cleanup;
            }           

            V_BSTR(&var) = SysAllocString(pTemp);
            V_VT(&var) = VT_BSTR;
            
            hr = m_pADs->Put(WINNT_PARAMETERS_NAME, var);
        }
    }
cleanup:

    if(NULL != pTemp)
    {
        LocalFree(pTemp);
    }

    VariantClear(&Parms);
    VariantClear(&var);

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// InternalSetString
//
// Most of the complexity of this dll is here.
//////////////////////////////////////////////////////////////////////////////
HRESULT ADsTSUserEx::InternalSetString(/*[in]*/ WCHAR* wszProperty,
                                       /*[in]*/ BSTR bstrNewVal) throw()
{
    if ( !bstrNewVal )
    {
        return E_INVALIDARG;
    }

    HRESULT hr         = S_OK;    
    BOOL fDefaultValue = 0;
    BOOL Update        = FALSE;
    ULONG UPLength     = 0;    
    TCHAR* pTemp       = NULL;
    VARIANT Parms;
    VARIANT var;
    ULONG ulFlags  = 0;
    ULONG CfgPresent = CFGPRESENT_VALUE;

    VariantInit(&var);

    ///////////////////////////
    // If the provider is LDAP
    ///////////////////////////

    if(wszProperty == NULL || (bstrNewVal && SysStringLen(bstrNewVal)> MAX_STRING_SIZE))
    {
        return E_ADS_BAD_PARAMETER;         
    }
    
    if ((_wcsicmp(wszProperty, L"InitialProgram") == 0) || (_wcsicmp(wszProperty, L"WorkDirectory") == 0))
    {
        InternalSetLong(F1MSK_INHERITINITIALPROGRAM, FALSE);
    }

    if(m_vbUpLevelAllowed)
    {
        if ( m_vbIsLDAP )
        {                          
            hr = m_pADs->Get(LDAP_PARAMETERS_NAME, &Parms);

            if( ERROR_SUCCESS != hr )
            {
                Parms.bstrVal = SysAllocString(L"CtxCfgPresent"); 
                UPLength =  PARMS_SIZE;
                fDefaultValue = 0;
            }
            else
            {       
                UPLength = (SysStringLen(Parms.bstrVal) +
                            CTX_USER_PARAM_MAX_SIZE+1) *
                            sizeof(WCHAR);              

                fDefaultValue =  (V_BSTR(&Parms)==0) ? 1: 0 ;
            }

            pTemp = (TCHAR*)LocalAlloc(LPTR, UPLength);
            
            if(NULL == pTemp)
            {
                hr = E_OUTOFMEMORY;

                goto cleanup;
            }

            memcpy(pTemp, V_BSTR(&Parms), SysStringLen(Parms.bstrVal)*sizeof(WCHAR));

            hr = UsrPropGetValue( WIN_FLAGS1,
                              &ulFlags,
                              sizeof(ulFlags),
                              pTemp ) ;

            if( ERROR_SUCCESS != hr )
            { 
                ulFlags = DEFAULTFLAGS;                    

                UsrPropSetValue( WIN_CFGPRESENT,
                                  &CfgPresent,
                                  sizeof(CfgPresent),
                                  FALSE,
                                  pTemp,
                                  UPLength );

                UsrPropSetValue(WIN_FLAGS1,
                             &ulFlags,
                             sizeof(ulFlags),
                             FALSE,
                             pTemp,
                             UPLength
                             );             
            }

            hr = UsrPropSetString(wszProperty,
                                 bstrNewVal,
                                 pTemp,
                                 UPLength,
                                 fDefaultValue
                                 );
            

            if( ERROR_SUCCESS != hr )
            {
                goto cleanup;
            }

            V_BSTR(&var) = SysAllocString(pTemp);
            V_VT(&var) = VT_BSTR;
            
            hr = m_pADs->Put(LDAP_PARAMETERS_NAME, var);                   
        }
        else
        {              
            hr = m_pADs->Get(WINNT_PARAMETERS_NAME, &Parms);
            
            if( ERROR_SUCCESS != hr )
            {
                 goto cleanup;                
            }
            else
            {                   

                UPLength = (SysStringLen(Parms.bstrVal) +
                            CTX_USER_PARAM_MAX_SIZE+1) *
                            sizeof(WCHAR);  

                fDefaultValue =  (V_BSTR(&Parms)==0) ? 1: 0 ;

                pTemp = (TCHAR*)LocalAlloc(LPTR, UPLength);                

                if(NULL == pTemp)
                {
                    hr = E_OUTOFMEMORY;
                    goto cleanup;
                }                            

                memcpy(pTemp, V_BSTR(&Parms), SysStringLen(Parms.bstrVal)*sizeof(WCHAR)); 
                
                hr = UsrPropGetValue( WIN_FLAGS1,
                                  &ulFlags,
                                  sizeof(ulFlags),
                                  pTemp ) ;

                if( ERROR_SUCCESS != hr )
                { 
                    ulFlags = DEFAULTFLAGS;                    

                    UsrPropSetValue( WIN_CFGPRESENT,
                                      &CfgPresent,
                                      sizeof(CfgPresent),
                                      FALSE,
                                      pTemp,
                                      UPLength );

                    UsrPropSetValue(WIN_FLAGS1,
                                 &ulFlags,
                                 sizeof(ulFlags),
                                 FALSE,
                                 pTemp,
                                 UPLength
                                 );             
                }

                hr = UsrPropSetString(wszProperty,
                                     bstrNewVal,
                                     pTemp,
                                     UPLength,
                                     fDefaultValue
                                     );
            }

            if( ERROR_SUCCESS != hr )
            {
                goto cleanup;
            } 
            
            
            V_BSTR(&var) = SysAllocString(pTemp);
            V_VT(&var) = VT_BSTR;
            
            hr = m_pADs->Put(WINNT_PARAMETERS_NAME, var);                        
        }
    }
cleanup:

    if(NULL != pTemp)
    {
        LocalFree(pTemp);
    }

    VariantClear(&Parms);
    VariantClear(&var);

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// InternalSetLong
//
// Most of the complexity of this dll is here.
//////////////////////////////////////////////////////////////////////////////
HRESULT ADsTSUserEx::InternalSetLong(/*[in]*/ LONG lProperty,
                                     /*[in]*/ LONG lNewVal) throw()
{


    HRESULT hr     = S_OK;
    ULONG ulFlags  = 0;
    ULONG UPLength = 0;    
    TCHAR* pTemp   = NULL;
    VARIANT Parms;
    VARIANT var;
    VariantInit(&var);
    ULONG CfgPresent = CFGPRESENT_VALUE;
    
   
    ///////////////////////////
    // If the provider is LDAP
    ///////////////////////////

    if(m_vbUpLevelAllowed)
    {
        if ( m_vbIsLDAP )
        {  
            hr = m_pADs->Get(LDAP_PARAMETERS_NAME, &Parms);

            if( ERROR_SUCCESS != hr )
            {
                Parms.bstrVal = SysAllocString(L"CtxCfgPresent"); 
                UPLength =  PARMS_SIZE;
            }

            UPLength = (sizeof(V_BSTR(&Parms)) +
                        CTX_USER_PARAM_MAX_SIZE) *
                        sizeof(WCHAR);

            pTemp = (TCHAR*)LocalAlloc(LPTR, UPLength);
                
            if(NULL == pTemp)
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            memcpy(pTemp, V_BSTR(&Parms), SysStringLen(Parms.bstrVal)*sizeof(WCHAR));


            hr = UsrPropGetValue( WIN_FLAGS1,
                                  &ulFlags,
                                  sizeof(ulFlags),
                                  pTemp ) ;

            if( ERROR_SUCCESS != hr )
            { 
                ulFlags = DEFAULTFLAGS;

                UsrPropSetValue( WIN_CFGPRESENT,
                                  &CfgPresent,
                                  sizeof(CfgPresent),
                                  FALSE,
                                  pTemp,
                                  UPLength );
        
            }

            if(lNewVal == 0)
            {
                ulFlags &= (~(lProperty));
            }
            else
            {
                ulFlags |= lProperty;
            }

            hr = UsrPropSetValue(WIN_FLAGS1,
                                 &ulFlags,
                                 sizeof(ulFlags),
                                 FALSE,
                                 pTemp,
                                 UPLength
                                 );

            if( ERROR_SUCCESS != hr )
            {
                return hr;
            }
            
            V_BSTR(&var) = SysAllocString(pTemp);
            V_VT(&var) = VT_BSTR;
            
            hr = m_pADs->Put(LDAP_PARAMETERS_NAME, var);
        }
        else
        {            
            hr = m_pADs->Get(WINNT_PARAMETERS_NAME, &Parms);

            if( ERROR_SUCCESS != hr )
            {
                return hr;
            }

            UPLength = (sizeof(V_BSTR(&Parms)) +
                        CTX_USER_PARAM_MAX_SIZE) *
                        sizeof(WCHAR);

            pTemp = (TCHAR*)LocalAlloc(LPTR, UPLength);
                
            if(NULL == pTemp)
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            memcpy(pTemp, V_BSTR(&Parms), SysStringLen(Parms.bstrVal)*sizeof(WCHAR));

            hr = UsrPropGetValue( WIN_FLAGS1,
                                  &ulFlags,
                                  sizeof(ulFlags),
                                  pTemp ) ;

            if( ERROR_SUCCESS != hr )
            { 
                ulFlags = DEFAULTFLAGS;

                UsrPropSetValue( WIN_CFGPRESENT,
                                  &CfgPresent,
                                  sizeof(CfgPresent),
                                  FALSE,
                                  pTemp,
                                  UPLength );                            
            }           

            if(lNewVal == 0)
            {
                ulFlags &= (~(lProperty));
            }
            else
            {
                ulFlags |= lProperty;
            }

            hr = UsrPropSetValue(WIN_FLAGS1,
                                 &ulFlags,
                                 sizeof(ulFlags),
                                 FALSE,
                                 pTemp,
                                 UPLength
                                 );

            if( ERROR_SUCCESS != hr )
            {
                return hr;
            }

            V_BSTR(&var) = SysAllocString(pTemp);
            V_VT(&var) = VT_BSTR;
           
            hr = m_pADs->Put(WINNT_PARAMETERS_NAME, var);
        }
    }
cleanup:

    if(NULL != pTemp)
    {
        LocalFree(pTemp);
    }

    VariantClear(&Parms);
    VariantClear(&var);

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// ADsTSUserEx::InternalGetString
//
// Works with
//      ProfilePath
//      HomeDirectory
//      HomeDrive
//      WorkDirectory
//      InitialProgram
//
//////////////////////////////////////////////////////////////////////////////
HRESULT ADsTSUserEx::InternalGetString(/*in*/   BSTR bstrProperty,
                                       /*out*/  BSTR *pbstrVal
                                         ) throw()
{
    _ASSERT(pbstrVal);

    HRESULT hr             = S_OK;
    TCHAR tchbuf[MAX_STRING_SIZE+1] = L"";
    TCHAR* pTemp           = NULL;
    LONG UPLength          = 0;
    VARIANT Parms;    
    *pbstrVal = NULL;

    if( m_vbIsLDAP )
    {
        hr = m_pADs->Get(LDAP_PARAMETERS_NAME, &Parms);
    }
    else
    {
        hr = m_pADs->Get(WINNT_PARAMETERS_NAME, &Parms);
    }

    if( ERROR_SUCCESS == hr )
    {
        if (m_vbUpLevelAllowed)
        {
            UPLength = (SysStringLen(Parms.bstrVal) +
                        CTX_USER_PARAM_MAX_SIZE+1) *
                        sizeof(WCHAR);

            pTemp = (TCHAR*)LocalAlloc(LPTR, UPLength);                

            if(NULL == pTemp)
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }                            

            memcpy(pTemp, V_BSTR(&Parms), SysStringLen(Parms.bstrVal)*sizeof(WCHAR));

            NTSTATUS ntstatus = UsrPropGetString(bstrProperty,
                                                 tchbuf,
                                                 sizeof(tchbuf),
                                                 pTemp
                                                 );

            if( ntstatus == STATUS_SUCCESS )
            {
                *pbstrVal = SysAllocString(tchbuf);
            }            
            else if ( ntstatus != STATUS_OBJECT_NAME_NOT_FOUND )
            {
                hr = E_FAIL;
            }
        }

    } // else return the error.

    
    if( (hr == E_ADS_PROPERTY_NOT_FOUND) || (hr == DISP_E_MEMBERNOTFOUND) )
    {       
        hr = S_OK;
    }   

cleanup:

    if(NULL != pTemp)
    {
        LocalFree(pTemp);
    }

    VariantClear(&Parms);
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// ADsTSUserEx::GetInfoWinNTComputer
//////////////////////////////////////////////////////////////////////////////
HRESULT ADsTSUserEx::GetInfoWinNTComputer(LPWSTR ServerName) throw()
{
    // This is a Computer, not a Domain that was used as a string

    // now detect if that's a w2k standalone or a NT4
    // Get the computer object to see what version of the
    // OS is used

    CComPtr<IADsComputer> pComputer;

    HRESULT hr         = S_OK;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;    
    DWORD dwAuthFlags  = 0;

    CComPtr<IADs> pDomain;
    CComBSTR      Version;

    hr = ADsOpenObject(ServerName,
                       NULL,
                       NULL,
                       0,
                       __uuidof(IADsComputer),
                       reinterpret_cast<VOID**> (&pComputer));
    BAIL_IF_ERROR(hr);


    //Get the OperatingSystemVersion attribute
    hr = pComputer->get_OperatingSystemVersion(&Version);
    BAIL_IF_ERROR(hr);

    LONG lVer = 0;   

    lVer = _wtol(Version);    

    if(lVer >= 4)
    {

        // Not a domain account and NT 5.1: standalone through WinNT
        m_vbUpLevelAllowed = VARIANT_TRUE;
    }
    else
    {
        hr = E_FAIL;
    }

cleanup:
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// ADsTSUserEx::GetInfoWinNT
//////////////////////////////////////////////////////////////////////////////
HRESULT ADsTSUserEx::GetInfoWinNT(IADsPathname* pPath) throw()
{
    if (NULL == pPath)
        return E_FAIL;

    //////////////////////////////////////////////
    // WinNT Provider: retrieve the server's name
    //////////////////////////////////////////////
    
    HRESULT  hr = S_OK;
    LONG     NbElements;
    CComBSTR Bstr;
    

    RETURN_ON_FAILURE(pPath->GetNumElements( &NbElements ));
    RETURN_ON_FAILURE(pPath->GetElement( 1, &Bstr ));

    SERVER_TO_MODE::iterator MapIterator;
    wstring TempString(Bstr);

    MapIterator = m_StaticServerMap.find(TempString);
    if ( MapIterator != m_StaticServerMap.end() )
    {
        // found in the map
        m_vbUpLevelAllowed = MapIterator->second;
        return hr;
    }

    CComBSTR ServerName = L"WinNT://";
    ServerName.AppendBSTR(Bstr);    

    /////////////////////////
    // Computer (not domain)
    /////////////////////////

    if ( NbElements == 3 ) // Computer (not domain)
    {
        hr = GetInfoWinNTComputer(ServerName.m_str);
    }
    else if ( NbElements == 2 ) // Domain
    {
        // WinNT Provider
        // AND Domain Controller
        // => No Upper-Level allowed stop there

        hr = GetInfoWinNTComputer(ServerName.m_str);        
        hr = S_OK;
    }
    else
    {
        hr =  E_FAIL;
    }

    m_StaticServerMap.insert(SERVER_TO_MODE::value_type(
                                                        TempString,
                                                        m_vbUpLevelAllowed
                                                       ));


    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// ExtractDCFromLDAP
//
// String assumed to be like
// "LDAP://DC=ntdev,DC=microsoft,DC=com" string (example)
//////////////////////////////////////////////////////////////////////////////

HRESULT ExtractDCFromLDAP(IADsPathname* pPath, CComBSTR& NewName) throw()
{
    if (NULL == pPath)
        return E_FAIL;

    LONG    Count;
    RETURN_ON_FAILURE(pPath->GetNumElements(&Count));
    NewName = LDAP_PREFIX;

    CComBSTR    Bstr;
    for ( int i = 0; i<Count; ++i )
    {
        RETURN_ON_FAILURE(pPath->GetElement(i,&Bstr));       

        WCHAR   Header[4];
        lstrcpynW(Header,Bstr, 4); // 3 plus \0
        if ( lstrcmpiW(Header, L"DC=") == 0 )
        {
            NewName.AppendBSTR(Bstr);
            NewName.Append(L",");
        }
        Bstr.Empty();
    }
    NewName[NewName.Length()-1] = L'\0';
    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
// ADsTSUserEx::GetInfoLDAP
//////////////////////////////////////////////////////////////////////////////

HRESULT ADsTSUserEx::GetInfoLDAP(IADsPathname* pPath) throw()
{
    if (NULL == pPath)
        return E_FAIL;

    // LDAP provider
    CComBSTR ServerName;
    HRESULT  hr          = S_OK;
    DWORD    dwAuthFlags = 0;

    RETURN_ON_FAILURE(ExtractDCFromLDAP(pPath, ServerName));

    SERVER_TO_MODE::iterator MapIterator;
    wstring TempString(ServerName);

    MapIterator = m_StaticServerMap.find(TempString);
    if ( MapIterator != m_StaticServerMap.end() )
    {
        // found in the map
        m_vbUpLevelAllowed = MapIterator->second;
        return S_OK;
    }

    m_vbUpLevelAllowed = VARIANT_TRUE;

    m_StaticServerMap.insert(SERVER_TO_MODE::value_type( TempString,
                                                         m_vbUpLevelAllowed
                                                         ));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// ADsTSUserEx::Operate
//
// Parameters should be varUserName, varPassword, varAuthFlags. ignored here
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ADsTSUserEx::Operate(ULONG   Code,
                                  VARIANT varData1,
                                  VARIANT varData2,
                                  VARIANT varData3) throw()
{
    HRESULT hr = S_OK;

    switch (Code)
    {
    case ADS_EXT_INITCREDENTIALS:
        {            
            
            // Initialize the IADs smart pointer
            // (member)
            RETURN_ON_FAILURE(OuterQueryInterface(
                                          __uuidof(IADs),
                                          reinterpret_cast<void**>(&m_pADs)
                                        ));
            ///////////////////////////////////////////////////////
            // Figure out the domain or server name using Pathname
            ///////////////////////////////////////////////////////
            CComBSTR     BstrPath;
            hr = m_pADs->get_ADsPath(&BstrPath);
            m_pADs.p->Release();

            if (!SUCCEEDED(hr))
                return hr;

            CComBSTR     BstrProvider;
            m_StaticCritSec.Lock();
            do
            {               
                if ( !m_StaticpPath )
                {
                    BREAK_ON_FAILURE(CoCreateInstance(
                                     __uuidof(Pathname),
                                     NULL,
                                     CLSCTX_INPROC_SERVER,
                                     __uuidof(IADsPathname),
                                     reinterpret_cast<void**>(&m_StaticpPath )
                                                     ));
                }

                /////////////////////////////////////////
                // Get the provider used (WinNT or LDAP)
                /////////////////////////////////////////
                BREAK_ON_FAILURE(m_StaticpPath->Set(
                                                      BstrPath,
                                                      ADS_SETTYPE_FULL
                                                   ));

                BREAK_ON_FAILURE(m_StaticpPath->Retrieve(
                                                         ADS_FORMAT_PROVIDER,
                                                         &BstrProvider
                                                        ));

                // Check for "WinNT" and "LDAP" 
                // return E_FAIL for other providers
                if ( lstrcmpW(BstrProvider,L"WinNT") == 0 )
                {
                    m_vbIsLDAP = VARIANT_FALSE;
                    hr = GetInfoWinNT(m_StaticpPath );
                }
                else if ( lstrcmpW(BstrProvider,L"LDAP") == 0 )
                {
                    m_vbIsLDAP = VARIANT_TRUE;
                    hr = GetInfoLDAP(m_StaticpPath );
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            while (FALSE);

            
            m_StaticCritSec.Unlock();            

            break;
        }
    case ADS_EXT_INITIALIZE_COMPLETE:
    default:
        {
            // Default case should not fail
            break;
        }
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// ADsTSUserEx::PrivateGetIDsOfNames
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ADsTSUserEx::PrivateGetIDsOfNames(const struct _GUID &riid,
                                               USHORT** rgszNames,
                                               UINT     cNames,
                                               ULONG    lcid,
                                               LONG*    rgdispid)
{
    if ( !rgdispid )
    {
        return E_POINTER;
    }

    return m_StaticHolder.GetIDsOfNames(riid, rgszNames, cNames, lcid,
                                        rgdispid);
}

//////////////////////////////////////////////////////////////////////////////
// ADsTSUserEx::PrivateInvoke
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP ADsTSUserEx::PrivateInvoke(LONG dispidMember,
                                        const struct _GUID &riid,
                                        ULONG       lcid,
                                        USHORT      wFlags,
                                        DISPPARAMS* pdispparams,
                                        VARIANT*    pvarResult,
                                        EXCEPINFO*  pexcepinfo,
                                        UINT*       puArgErr)
{
    return  m_StaticHolder.Invoke(this, dispidMember, riid, lcid, wFlags,
                                  pdispparams, pvarResult, pexcepinfo,
                                  puArgErr);
}



////////////////////////////////////////////////////
// Delegating IDispatch Methods to the aggregator
//////////////////////////////////////////////////////
STDMETHODIMP ADsTSUserEx::GetTypeInfoCount(UINT* pctinfo)
{

    if ( !m_pOuterDispatch )
    {
        RETURN_ON_FAILURE(OuterQueryInterface(
                                   __uuidof(IDispatch),
                                   reinterpret_cast<void**>(&m_pOuterDispatch)
                                             ));
    }

    return m_pOuterDispatch->GetTypeInfoCount( pctinfo );


}


STDMETHODIMP ADsTSUserEx::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{

    if ( !m_pOuterDispatch )
    {
        RETURN_ON_FAILURE(OuterQueryInterface(
                                   __uuidof(IDispatch),
                                   reinterpret_cast<void**>(&m_pOuterDispatch)
                                             ));
    }

    return m_pOuterDispatch->GetTypeInfo( itinfo, lcid, pptinfo );

}

STDMETHODIMP ADsTSUserEx::GetIDsOfNames(REFIID riid, 
                                        LPOLESTR* rgszNames, 
                                        UINT cNames, 
                                        LCID lcid, 
                                        DISPID* rgdispid)
{

    if ( !m_pOuterDispatch )
    {
        RETURN_ON_FAILURE(OuterQueryInterface(
                                   __uuidof(IDispatch),
                                   reinterpret_cast<void**>(&m_pOuterDispatch)
                                             ));
    }

    return m_pOuterDispatch->GetIDsOfNames(riid, rgszNames, cNames, lcid,
                                           rgdispid);



}

STDMETHODIMP ADsTSUserEx::Invoke(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT*
               pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
   IDispatch *pDisp;
   HRESULT    hr = S_OK;
   hr = OuterQueryInterface( IID_IDispatch, (void**) &pDisp );
   if ( SUCCEEDED(hr) )
   {
       hr = pDisp->Invoke( dispidMember, riid, lcid, wFlags,
                pdispparams, pvarResult, pexcepinfo, puArgErr);
       pDisp->Release();
   }

   return hr;
}

/////////////////////////////////////////////////////////////////////////
// End delegating IDispatch Methods
/////////////////////////////////////////////////////////////////////////


STDMETHODIMP ADsTSUserEx::get_TerminalServicesProfilePath(BSTR *pVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        return InternalGetString(WIN_WFPROFILEPATH, pVal);
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_TerminalServicesProfilePath(BSTR pNewVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        return InternalSetString(WIN_WFPROFILEPATH, pNewVal);
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}

STDMETHODIMP ADsTSUserEx::get_TerminalServicesHomeDirectory(BSTR *pVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        return InternalGetString(WIN_WFHOMEDIR, pVal);
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_TerminalServicesHomeDirectory(BSTR pNewVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        BSTR bstrVal = NULL;

        if(pNewVal && PathIsUNC(pNewVal))
        {
            //There sould be some value for HomeDrive 
            
            InternalGetString(WIN_WFHOMEDIRDRIVE, &bstrVal);
            
            if(!bstrVal || !SysStringLen(bstrVal))
            {
                if(bstrVal)
                {
                    SysFreeString(bstrVal);
                }

                bstrVal = SysAllocString(L"Z:");
            
                if(bstrVal)
                {
                    InternalSetString(WIN_WFHOMEDIRDRIVE, bstrVal);
                    SysFreeString(bstrVal);
                    bstrVal = NULL;
                }
            }
        }
        else
        {
            //Local path or empty path
            //Reset HomeDrive.
            bstrVal = SysAllocString(L"");

            if(bstrVal)
            {
                InternalSetString(WIN_WFHOMEDIRDRIVE, bstrVal);
                SysFreeString(bstrVal);
                bstrVal = NULL;
            }
        }

        return InternalSetString(WIN_WFHOMEDIR, pNewVal);
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}

STDMETHODIMP ADsTSUserEx::get_TerminalServicesHomeDrive(BSTR *pVal) throw()
{    
    HRESULT hr = S_OK;

    if (m_vbUpLevelAllowed)
    {               
        hr = InternalGetString(WIN_WFHOMEDIRDRIVE, pVal);

        if(pVal && !SysStringLen(*pVal))
        {   
            BSTR bstrVal = NULL;

            InternalGetString(WIN_WFHOMEDIR, &bstrVal);
        
            if(bstrVal && PathIsUNC(bstrVal))
            {
                *pVal = SysAllocString(L"Z:");
            }

            if(bstrVal)
            {
                SysFreeString(bstrVal);
                bstrVal = NULL;
            }
        }
        return hr;
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_TerminalServicesHomeDrive(BSTR pNewVal) throw()
{
    if (m_vbUpLevelAllowed)
    {   
        if(!pNewVal || !SysStringLen(pNewVal))
        {
            return InternalSetString(WIN_WFHOMEDIRDRIVE, pNewVal);
        }

        if(SysStringLen(pNewVal) > 2)
        {
            return E_ADS_BAD_PARAMETER;
        }
        CharUpper( pNewVal );        

        if( *pNewVal >= 'C' && *pNewVal <= 'Z' && (_tcschr(pNewVal, _T(':'))!=NULL ))
        {
            return InternalSetString(WIN_WFHOMEDIRDRIVE, pNewVal);
        }
        else
        {
            return E_ADS_BAD_PARAMETER;
        }

    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::get_AllowLogon(LONG *pVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        HRESULT hr     = S_OK;
        LONG    lLogon = 0;

        hr = InternalGetLong(WIN_FLAGS1, &lLogon);
        RETURN_ON_FAILURE(hr);

        *pVal = (lLogon & F1MSK_LOGONDISABLED) ? 0 : 1;

        return S_OK;        
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_AllowLogon(LONG NewVal) throw()
{
    RETURN_ON_INVALID_PARAMETER(NewVal);  
    NewVal = NewVal? 0 : 1;

    if (m_vbUpLevelAllowed)
    {
        return InternalSetLong(F1MSK_LOGONDISABLED, NewVal);
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::get_EnableRemoteControl(LONG *pVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        HRESULT hr = S_OK;
        LONG lShadow = 0;

        hr = InternalGetLong(WIN_SHADOW, &lShadow);

        RETURN_ON_FAILURE(hr);

        *pVal = lShadow;

        return S_OK;
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_EnableRemoteControl(LONG NewVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        if(NewVal < 0 || NewVal > 4)
        {
            return E_ADS_BAD_PARAMETER;
        }
        else
        {
            return InternalSetValue(WIN_SHADOW, NewVal);
        }
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::get_MaxDisconnectionTime(LONG *pVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        HRESULT hr = S_OK;
        hr = InternalGetLong(WIN_MAXDISCONNECTIONTIME, pVal);

        RETURN_ON_FAILURE(hr);

        *pVal /= INMINUTES;

        return S_OK;
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_MaxDisconnectionTime(LONG NewVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        if(NewVal < 0 || NewVal > MAX_TIME_LIMIT )
        {
            return E_ADS_BAD_PARAMETER;
        }
        else
        {
            return InternalSetValue(WIN_MAXDISCONNECTIONTIME, NewVal*INMINUTES);
        }
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::get_MaxConnectionTime(LONG *pVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        HRESULT hr = S_OK;
        hr = InternalGetLong(WIN_MAXCONNECTIONTIME, pVal);

        RETURN_ON_FAILURE(hr);

        *pVal /= INMINUTES;

        return S_OK;
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_MaxConnectionTime(LONG NewVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        if(NewVal < 0 || NewVal > MAX_TIME_LIMIT )
        {
            return E_ADS_BAD_PARAMETER;
        }
        else
        {
            return InternalSetValue(WIN_MAXCONNECTIONTIME, NewVal*INMINUTES);
        }
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::get_MaxIdleTime(LONG *pVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        HRESULT hr = S_OK;
        hr = InternalGetLong(WIN_MAXIDLETIME, pVal);

        RETURN_ON_FAILURE(hr);

        *pVal /= INMINUTES;

        return S_OK;
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_MaxIdleTime(LONG NewVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        if(NewVal < 0 || NewVal > MAX_TIME_LIMIT )
        {
            return E_ADS_BAD_PARAMETER;
        }
        else
        {
            return InternalSetValue(WIN_MAXIDLETIME, NewVal*INMINUTES);
        }
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::get_ReconnectionAction(LONG *pVal) throw()
{
    LONG lDisconnect;
    HRESULT hr = S_OK;

    if (m_vbUpLevelAllowed)
    {
        hr = InternalGetLong(WIN_FLAGS1, &lDisconnect);

        RETURN_ON_FAILURE(hr);

        *pVal = (lDisconnect & F1MSK_RECONNECTSAME) ? 1 : 0;
        
        return S_OK;

    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_ReconnectionAction(LONG NewVal) throw()
{
    RETURN_ON_INVALID_PARAMETER(NewVal);

    if (m_vbUpLevelAllowed)
    {        
        return InternalSetLong(F1MSK_RECONNECTSAME, NewVal);        
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}

STDMETHODIMP ADsTSUserEx::get_BrokenConnectionAction(LONG *pVal) throw()
{
    LONG lReconnect;
    HRESULT hr = S_OK;

    if (m_vbUpLevelAllowed)
    {
        hr = InternalGetLong(WIN_FLAGS1, &lReconnect);

        RETURN_ON_FAILURE(hr);

        *pVal = (lReconnect & F1MSK_RESETBROKEN) ? 1 : 0;
        
        return S_OK;

    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_BrokenConnectionAction(LONG NewVal) throw()
{
    RETURN_ON_INVALID_PARAMETER(NewVal);

    if (m_vbUpLevelAllowed)
    {                
        return InternalSetLong(F1MSK_RESETBROKEN, NewVal);
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::get_ConnectClientDrivesAtLogon(LONG *pVal) throw()
{

    LONG lAutoClientDrives;
    HRESULT hr = S_OK;

    if (m_vbUpLevelAllowed)
    {
        hr = InternalGetLong(WIN_FLAGS1, &lAutoClientDrives);

        RETURN_ON_FAILURE(hr);

        if (lAutoClientDrives & F1MSK_AUTOCLIENTDRIVES)
        {
            *pVal = 1;
        }
        else
        {
            *pVal = 0;
        }

        return S_OK;

    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_ConnectClientDrivesAtLogon(LONG NewVal) throw()
{
    RETURN_ON_INVALID_PARAMETER(NewVal);    

    if (m_vbUpLevelAllowed)
    {        
        return InternalSetLong(F1MSK_AUTOCLIENTDRIVES, NewVal);        
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}

STDMETHODIMP ADsTSUserEx::get_ConnectClientPrintersAtLogon(LONG *pVal) throw()
{

    LONG lAutoClientPrinters;
    HRESULT hr = S_OK;

    if (m_vbUpLevelAllowed)
    {
        hr = InternalGetLong(WIN_FLAGS1, &lAutoClientPrinters);

        RETURN_ON_FAILURE(hr);

        if (lAutoClientPrinters & F1MSK_AUTOCLIENTLPTS)
        {
            *pVal = 1;
        }
        else
        {
            *pVal = 0;
        }

        return S_OK;

    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_ConnectClientPrintersAtLogon(LONG NewVal) throw()
{
    RETURN_ON_INVALID_PARAMETER(NewVal);

    if (m_vbUpLevelAllowed)
    {
        return InternalSetLong(F1MSK_AUTOCLIENTLPTS, NewVal);        
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}

STDMETHODIMP ADsTSUserEx::get_DefaultToMainPrinter(LONG *pVal) throw()
{

    LONG lDefaultPrinter;
    HRESULT hr = S_OK;

    if (m_vbUpLevelAllowed)
    {
        hr = InternalGetLong(WIN_FLAGS1, &lDefaultPrinter);

        RETURN_ON_FAILURE(hr);

        if (lDefaultPrinter & F1MSK_FORCECLIENTLPTDEF)
        {
            *pVal = 1;
        }
        else
        {
            *pVal = 0;
        }

        return S_OK;

    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_DefaultToMainPrinter(LONG NewVal) throw()
{
    RETURN_ON_INVALID_PARAMETER(NewVal);

    if (m_vbUpLevelAllowed)
    {
        return InternalSetLong(F1MSK_FORCECLIENTLPTDEF, NewVal);        
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::get_TerminalServicesWorkDirectory(BSTR *pVal) throw()
{

    if (m_vbUpLevelAllowed)
    {
        return InternalGetString(WIN_WORKDIRECTORY, pVal);
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_TerminalServicesWorkDirectory(BSTR pNewVal) throw()
{    
    if (m_vbUpLevelAllowed)
    {
        return InternalSetString(WIN_WORKDIRECTORY, pNewVal);        
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::get_TerminalServicesInitialProgram(BSTR *pVal) throw()
{

    if (m_vbUpLevelAllowed)
    {
        return InternalGetString(WIN_INITIALPROGRAM, pVal);
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}


STDMETHODIMP ADsTSUserEx::put_TerminalServicesInitialProgram(BSTR pNewVal) throw()
{
    if (m_vbUpLevelAllowed)
    {
        return InternalSetString(WIN_INITIALPROGRAM, pNewVal);
    }
    else
    {
        return E_ADS_PROPERTY_NOT_FOUND;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\ads.h ===
/*++
Copyright (c) 2001  Microsoft Corporation

Module Name:

    ads.h

Abstract:

    This module defines interface methods for ADSI extension for Terminal Server User Properties.

Author:

    Rashmi Patankar (RashmiP) 10-Aug-2001

Revision History:

--*/

#ifndef __TSUSEREX_ADS_H_
#define __TSUSEREX_ADS_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"
#include <string>
#include <map>

using namespace std;
// default comparison operator is <
typedef std::map<wstring, VARIANT_BOOL> SERVER_TO_MODE;


/////////////////////////////////////////////////////////////////////////////
// ADsTSUserEx

class ADsTSUserEx :
//  public IDispatchImpl<IADsTSUserEx, &IID_IADsTSUserEx, &LIBID_ADSTSUSERLib>,
    public IADsTSUserEx,
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<ADsTSUserEx,&CLSID_ADsTSUserEx>,
    public IADsExtension
{
protected:
    ITypeInfo                      *m_pTypeInfo;
    VARIANT_BOOL                    m_vbIsLDAP;   // false = is WinNT
    VARIANT_BOOL                    m_vbUpLevelAllowed;
    CComPtr<IDispatch>              m_pOuterDispatch;
    CComPtr<IADs>                   m_pADs;

    static CComPtr<IADsPathname>    m_StaticpPath;
    static CComTypeInfoHolder       m_StaticHolder;
    static SERVER_TO_MODE           m_StaticServerMap;
    static CComAutoCriticalSection  m_StaticCritSec;

   // Methods not exposed

    HRESULT GetInfoWinNTComputer(/*in*/  LPWSTR ServerName);

    HRESULT GetInfoWinNT(/*[in]*/   IADsPathname* pPath);

    HRESULT GetInfoLDAP( /*[in]*/   IADsPathname* pPath);

    HRESULT InternalGetLong (/*[in]*/   BSTR  bstrProperty,
                            /*[out]*/   LONG* lpVal);


    HRESULT InternalSetLong(/*[in]*/    LONG  lProperty,
                            /*[out]*/   LONG  lNewVal);


    HRESULT InternalGetString(/*[in]*/   BSTR  bstrProperty,
                              /*[out]*/  BSTR* pbstrVal);

    HRESULT InternalSetString(/*[in]*/   WCHAR  *wszProperty,
                              /*[in]*/   BSTR  bstrNewVal);

    HRESULT InternalSetValue(/*[in]*/    WCHAR  *wszProperty,
                             /*[in]*/    LONG  lNewVal);

public:
    ADsTSUserEx();
    ~ADsTSUserEx();

//  ADsTSUserEx() {}
BEGIN_COM_MAP(ADsTSUserEx)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IADsTSUserEx)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IADsExtension)
END_COM_MAP()


DECLARE_REGISTRY_RESOURCEID(IDR_ADS)

    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    
// IADsTSUserEx
public:
    STDMETHOD(put_TerminalServicesProfilePath)(/*[in]*/ BSTR pNewVal);
    STDMETHOD(get_TerminalServicesProfilePath)(/*[out, retval]*/ BSTR* pVal);

    STDMETHOD(put_TerminalServicesHomeDirectory)(/*[in]*/ BSTR pNewVal);
    STDMETHOD(get_TerminalServicesHomeDirectory)(/*[out, retval]*/ BSTR* pVal);

    STDMETHOD(put_TerminalServicesHomeDrive)(/*[in]*/ BSTR pNewVal);
    STDMETHOD(get_TerminalServicesHomeDrive)(/*[out, retval]*/ BSTR* pVal);

    STDMETHOD(put_AllowLogon)(/*[in]*/ LONG NewVal);
    STDMETHOD(get_AllowLogon)(/*[out, retval]*/ LONG* pVal);

    STDMETHOD(put_EnableRemoteControl)(/*[in]*/ LONG NewVal);
    STDMETHOD(get_EnableRemoteControl)(/*[out, retval]*/ LONG* pVal);

    STDMETHOD(put_MaxDisconnectionTime)(/*[in]*/ LONG NewVal);
    STDMETHOD(get_MaxDisconnectionTime)(/*[out, retval]*/ LONG* pVal);

    STDMETHOD(put_MaxConnectionTime)(/*[in]*/ LONG NewVal);
    STDMETHOD(get_MaxConnectionTime)(/*[out, retval]*/ LONG* pVal);

    STDMETHOD(put_MaxIdleTime)(/*[in]*/ LONG NewVal);
    STDMETHOD(get_MaxIdleTime)(/*[out, retval]*/ LONG* pVal);

    STDMETHOD(put_ReconnectionAction)(/*[in]*/ LONG NewVal);
    STDMETHOD(get_ReconnectionAction)(/*[out, retval]*/ LONG* pVal);

    STDMETHOD(put_BrokenConnectionAction)(/*[in]*/ LONG NewVal);
    STDMETHOD(get_BrokenConnectionAction)(/*[out, retval]*/ LONG* pVal);

    STDMETHOD(put_ConnectClientDrivesAtLogon)(/*[in]*/ LONG NewVal);
    STDMETHOD(get_ConnectClientDrivesAtLogon)(/*[out, retval]*/ LONG* pVal);

    STDMETHOD(put_ConnectClientPrintersAtLogon)(/*[in]*/ LONG NewVal);
    STDMETHOD(get_ConnectClientPrintersAtLogon)(/*[out, retval]*/ LONG* pVal);

    STDMETHOD(put_DefaultToMainPrinter)(/*[in]*/ LONG NewVal);
    STDMETHOD(get_DefaultToMainPrinter)(/*[out, retval]*/ LONG* pVal);

    STDMETHOD(put_TerminalServicesWorkDirectory)(/*[in]*/ BSTR pNewVal);
    STDMETHOD(get_TerminalServicesWorkDirectory)(/*[out, retval]*/ BSTR* pVal);

    STDMETHOD(put_TerminalServicesInitialProgram)(/*[in]*/ BSTR pNewVal);
    STDMETHOD(get_TerminalServicesInitialProgram)(/*[out, retval]*/ BSTR* pVal);



    // IDispatch


    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo);

    STDMETHOD(GetTypeInfo)(UINT itinfo,
                           LCID lcid,
                           ITypeInfo** pptinfo
                           );

    STDMETHOD(GetIDsOfNames)(REFIID riid,
                             LPOLESTR* rgszNames,
                             UINT cNames,
                             LCID lcid,
                             DISPID* rgdispid
                             );

    STDMETHOD(Invoke)(DISPID dispidMember,
                      REFIID riid,
                      LCID lcid,
                      WORD wFlags,
                      DISPPARAMS* pdispparams,
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo,
                      UINT* puArgErr
                      );

    STDMETHOD(Operate)(ULONG dwCode,
                       VARIANT varData1,
                       VARIANT varData2,
                       VARIANT varData3
                       );

    STDMETHOD(PrivateGetIDsOfNames)(const struct _GUID &,
                                    USHORT **,
                                    UINT,
                                    ULONG,
                                    LONG *
                                    );

    STDMETHOD(PrivateInvoke)(LONG, const struct _GUID &,
                             ULONG, USHORT,
                             DISPPARAMS *,
                             VARIANT *,
                             EXCEPINFO *,
                             UINT *
                             );



};

#endif // __TSUSEREX_ADS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\creden.h ===
#ifndef _CREDEN_HXX_
#define _CREDEN_HXX_
typedef LONG NTSTATUS;
typedef NTSTATUS  SECURITY_STATUS;
#include <ntsecapi.h>

#define STRINGIZE(y)          _STRINGIZE_helper(y)
#define _STRINGIZE_helper(z)  #z


extern "C" {


    typedef VOID (*FNRTLINITUNICODESTRING) (
           PUNICODE_STRING DestinationString,
           PCWSTR SourceString
           );


    typedef VOID (*FRTLRUNENCODEUNICODESTRING) (
               PUCHAR          Seed,
               PUNICODE_STRING String
               );


    typedef VOID (*FRTLRUNDECODEUNICODESTRING) (
               UCHAR           Seed,
               PUNICODE_STRING String               
               );



    typedef NTSTATUS (*FRTLENCRYPTMEMORY) (
           PVOID Memory,
           ULONG MemoryLength,
           ULONG OptionFlags
           );


    typedef NTSTATUS (*FRTLDECRYPTMEMORY) (
               PVOID Memory,
               ULONG MemoryLength,
               ULONG OptionFlags
               );


/*
    NTSTATUS
    RtlEncryptMemory(
        IN OUT  PVOID Memory,
        IN      ULONG MemoryLength
        );

    NTSTATUS
    RtlDecryptMemory(
        IN OUT  PVOID Memory,
        IN      ULONG MemoryLength
        );
        */

}   // extern "C"
   

class CCredentials;

class CCredentials
{

public:


    CCredentials::CCredentials();

    CCredentials::CCredentials(
        LPWSTR lpszUserName,
        LPWSTR lpszPassword,
        DWORD dwAuthFlags
        );

    CCredentials::CCredentials(
        const CCredentials& Credentials
        );

    CCredentials::~CCredentials();

    HRESULT
    CCredentials::GetUserName(
        LPWSTR *  lppszUserName
        );

    HRESULT
    CCredentials::GetPassword(
        LPWSTR * lppszPassword
        );

    HRESULT
    CCredentials::SetUserName(
        LPWSTR lpszUserName
        );

    HRESULT
    CCredentials::SetPassword(
        LPWSTR lpszPassword
        );

    void
    CCredentials::operator=(
        const CCredentials& other
        );

    friend BOOL
    operator==(
        CCredentials& x,
        CCredentials& y
        );

    BOOL
    CCredentials::IsNullCredentials(
        );

    DWORD
    CCredentials::GetAuthFlags(
        );

    void
    CCredentials::SetAuthFlags(
        DWORD dwAuthFlags
        );   
    


    

private:

    LPWSTR _lpszUserName;

    LPWSTR _lpszPassword;

    DWORD  _dwAuthFlags;
    DWORD  _dwPasswordLen;


    
   
};

#endif  // ifndef _CREDEN_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\creden.cpp ===
/*++


Copyright (c) 2001  Microsoft Corporation

Module Name:

    creden.cpp

Abstract:

    This module abstracts user credentials for the multiple credential support.

Author:

    Rashmi Patankar (RashmiP) 10-Aug-2001

Revision History:

--*/
#include "stdafx.h"
#include <basetyps.h>
#include <des.h>

typedef  long HRESULT;
#include "creden.h"
#include <ntsecapi.h>
typedef NTSTATUS  SECURITY_STATUS;

UCHAR g_seed = 0 ;

#define BAIL_ON_FAILURE(hr)                             \
            if (FAILED(hr))                             \
            {                                           \
                goto error;                             \
            }


//
// This routine allocates and stores the password in the
// passed in pointer. The assumption here is that pszString
// is valid, it can be an empty string but not NULL.
// Note that this code cannot be used as is on Win2k and below
// as they do not support the newer functions.
//

HRESULT
EncryptString(
    LPWSTR pszString,
    LPWSTR *ppszSafeString,
    PDWORD pdwLen
    )
{
    HRESULT hr = S_OK;
    DWORD dwLenStr = 0;
    DWORD dwPwdLen = 0;
    LPWSTR pszTempStr = NULL;
    NTSTATUS errStatus = S_OK;
    FNRTLINITUNICODESTRING pRtlInitUnicodeString = NULL;
    FRTLRUNENCODEUNICODESTRING pRtlRunEncodeUnicodeString = NULL;
    FRTLENCRYPTMEMORY pRtlEncryptMemory = NULL;

    BOOLEAN GlobalUseScrambling = FALSE;

    if (!pszString || !ppszSafeString) 
    {
        return(E_FAIL);
    }

    *ppszSafeString = NULL;
    *pdwLen = 0;

    //
    // If the string is valid, then we need to get the length
    // and initialize the unicode string.
    //
    
    UNICODE_STRING Password;

    //
    // Determine the length of buffer taking padding into account.
    //
    dwLenStr = wcslen(pszString);

    dwPwdLen = (dwLenStr + 1) * sizeof(WCHAR) + (DES_BLOCKLEN -1);

    pszTempStr = (LPWSTR) AllocADsMem(dwPwdLen);

    if (!pszTempStr)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    wcscpy(pszTempStr, pszString);
    
    if(g_ScramblingLibraryHandle)
    {
        pRtlInitUnicodeString = (FNRTLINITUNICODESTRING) GetProcAddress( g_ScramblingLibraryHandle, "RtlInitUnicodeString" );
    }

    if(!pRtlInitUnicodeString)
    {
        hr = E_FAIL;
        goto error;
    }

    (*pRtlInitUnicodeString)(&Password, pszTempStr);
    

    USHORT usExtra = 0;

    if (usExtra = (Password.MaximumLength % DES_BLOCKLEN))
    {
        Password.MaximumLength += (DES_BLOCKLEN - usExtra);            
    }

    *pdwLen = Password.MaximumLength;        

    if (g_AdvApi32LibraryHandle || g_ScramblingLibraryHandle)
    {

        GlobalUseScrambling = FALSE;

        if (g_AdvApi32LibraryHandle)
        {
            //
            // Try to get the advapi32.dll RtlEncryptMemory/RtlDecryptMemory functions,
            // Note that RtlEncryptMemory and RtlDecryptMemory are really named
            // SystemFunction040/041, hence the macros.
            //

            pRtlEncryptMemory = (FRTLENCRYPTMEMORY) GetProcAddress( g_AdvApi32LibraryHandle, (LPCSTR) 619 );

            if (pRtlEncryptMemory)
            {

                // We want to use scrambling

                GlobalUseScrambling =  TRUE;

                // Using strong scrambling

                errStatus = (*pRtlEncryptMemory)( Password.Buffer,
                                                  Password.MaximumLength,
                                                  0
                                                  );

                if (errStatus)
                {
                    if(pszTempStr)
                    {
                        FreeADsMem(pszTempStr);
                        pszTempStr = NULL;
                    }

                    hr = HRESULT_FROM_NT(errStatus);
                    goto error;
                }


            }
            else if (g_ScramblingLibraryHandle)
            {
                //
                // Clean up so we can try falling back to the run-encode scrambling functions
                // (we keep the AdvApi32LibraryHandle around since we'll probably need it
                // later anyway)
                //

                pRtlRunEncodeUnicodeString = (FRTLRUNENCODEUNICODESTRING) GetProcAddress( g_ScramblingLibraryHandle, "RtlRunEncodeUnicodeString" );

                if(_tcslen(Password.Buffer) && pRtlRunEncodeUnicodeString)
                {

                    //  encrypt password in place

                    (*pRtlRunEncodeUnicodeString)( &g_seed, &Password );
                }
                else
                {
                    hr = E_FAIL;
                    goto error;
                }
            } 
            else
            {
                hr = E_FAIL;
                goto error;
            }
        }
        else
        {
            hr = E_FAIL;
            goto error;
        }
    }
    else
    {
        hr = E_FAIL;
        goto error;
    }

    *ppszSafeString = pszTempStr;

error:

    if (FAILED(hr) && pszTempStr)
    {
        FreeADsMem(pszTempStr);
        pszTempStr = NULL;
    }

    return(hr);
}


HRESULT
DecryptString(
    LPWSTR pszEncodedString,
    LPWSTR *ppszString,
    DWORD  dwLen
    )
{
    HRESULT hr = E_FAIL;
    LPWSTR pszTempStr = NULL;
    NTSTATUS errStatus;
    BOOLEAN GlobalUseScrambling = FALSE;
    FNRTLINITUNICODESTRING pRtlInitUnicodeString = NULL;
    FRTLRUNDECODEUNICODESTRING pRtlRunDecodeUnicodeString = NULL;
    FRTLDECRYPTMEMORY pRtlDecryptMemory = NULL;
    UNICODE_STRING UnicodePassword;


    if (!dwLen || !ppszString) 
    {
        return(E_FAIL);
    }

    *ppszString = NULL;

    if (dwLen) 
    {
        pszTempStr = (LPWSTR) AllocADsMem(dwLen);

        if (!pszTempStr) 
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }

        memcpy(pszTempStr, pszEncodedString, dwLen);


        if (g_AdvApi32LibraryHandle || g_ScramblingLibraryHandle)
        {
            hr = S_OK;

            GlobalUseScrambling = FALSE;

            if (g_AdvApi32LibraryHandle)
            {
                //
                // Try to get the advapi32.dll RtlEncryptMemory/RtlDecryptMemory functions,
                // along with ntdll's RtlInitUnicodeString.  Note that RtlEncryptMemory
                // and RtlDecryptMemory are really named SystemFunction040/041, hence
                // the macros.
                //

                pRtlDecryptMemory = (FRTLDECRYPTMEMORY) GetProcAddress( g_AdvApi32LibraryHandle, (LPCSTR) 620 );

                if (pRtlDecryptMemory)
                {
                    //
                    // We want to use scrambling
                    //

                    GlobalUseScrambling =  TRUE;

                    // Using strong scrambling

                    errStatus = (*pRtlDecryptMemory)( pszTempStr,
                                                      dwLen,
                                                      0
                                                      );

                    if (errStatus)
                    {
                        if (NULL != pszTempStr)
                        {
                            FreeADsStr(pszTempStr);
                            pszTempStr = NULL;
                        }

                        hr = HRESULT_FROM_NT(errStatus);
                        goto error;
                    }
                }
            
                else if(g_ScramblingLibraryHandle)
                {
                    //
                    // Clean up so we can try falling back to the run-encode scrambling functions
                    // (we keep the AdvApi32LibraryHandle around since we'll probably need it
                    // later anyway)
                    //

                    pRtlRunDecodeUnicodeString = (FRTLRUNDECODEUNICODESTRING) GetProcAddress( g_ScramblingLibraryHandle, "RtlRunDecodeUnicodeString" );

                    pRtlInitUnicodeString = (FNRTLINITUNICODESTRING) GetProcAddress( g_ScramblingLibraryHandle, "RtlInitUnicodeString" );

                    if(_tcslen(pszTempStr) && pRtlRunDecodeUnicodeString && pRtlInitUnicodeString)
                    {                        
                        (*pRtlInitUnicodeString)( &UnicodePassword, pszTempStr );

                        //  encrypt password in place

                        (*pRtlRunDecodeUnicodeString)(g_seed, &UnicodePassword);                    
                    }
                    else
                    {
                        hr = E_FAIL;
                        goto error;
                    }
                }
                else
                {
                    hr = E_FAIL;
                    goto error;
                }            
            }
            else
            {
                hr = E_FAIL;
                goto error;
            }
        }
        else
        {
            hr = E_FAIL;
            goto error;
        }

        *ppszString = pszTempStr;
    }

error:

    if (FAILED(hr) && (NULL != pszTempStr)) 
    {
        FreeADsStr(pszTempStr);
        pszTempStr = NULL;
    }

    return(hr);
}

//
// Static member of the class
//
CCredentials::CCredentials():
    _lpszUserName(NULL),
    _lpszPassword(NULL),
    _dwAuthFlags(0),
    _dwPasswordLen(0)
{
}

CCredentials::CCredentials(
    LPWSTR lpszUserName,
    LPWSTR lpszPassword,
    DWORD dwAuthFlags
    ):
    _lpszUserName(NULL),
    _lpszPassword(NULL),
    _dwAuthFlags(0),
    _dwPasswordLen(0)
{

    //
    // AjayR 10-04-99 we need a way to bail if the
    // alloc's fail. Since it is in the constructor this is
    // not very easy to do.
    //

    if (lpszUserName)
    {
        _lpszUserName = AllocADsStr(lpszUserName);
    }
    else
    {
        _lpszUserName = NULL;
    }

    if (lpszPassword)
    {
        //
        // The call can fail but we cannot recover from this.
        //
        EncryptString(
            lpszPassword,
            &_lpszPassword,
            &_dwPasswordLen
            );

    }
    else
    {
        _lpszPassword = NULL;
    }

    _dwAuthFlags = dwAuthFlags;

}

CCredentials::~CCredentials()
{
    if (_lpszUserName)
    {
        FreeADsStr(_lpszUserName);
    }

    if (_lpszPassword)
    {
        FreeADsStr(_lpszPassword);
    }
}



HRESULT
CCredentials::GetUserName(
    LPWSTR *lppszUserName
    )
{
    if (!lppszUserName)
    {
        return(E_FAIL);
    }


    if (!_lpszUserName)
    {
        *lppszUserName = NULL;
    }
    else
    {
        *lppszUserName = AllocADsStr(_lpszUserName);

        if (!*lppszUserName)
        {
            return(E_OUTOFMEMORY);
        }
    }

    return(S_OK);
}


HRESULT
CCredentials::GetPassword(
    LPWSTR * lppszPassword
    )
{   
    if (!lppszPassword)
    {
        return(E_FAIL);
    }

    if (!_lpszPassword)
    {
        *lppszPassword = NULL;
    }
    else
    {

        return( DecryptString( _lpszPassword,
                               lppszPassword,
                               _dwPasswordLen
                               )
              );
    }

    return(S_OK);
}


HRESULT
CCredentials::SetUserName(
    LPWSTR lpszUserName
    )
{
    if (_lpszUserName)
    {
        FreeADsStr(_lpszUserName);
    }

    if (!lpszUserName)
    {
        _lpszUserName = NULL;
        return(S_OK);
    }

    _lpszUserName = AllocADsStr(
                        lpszUserName
                        );
    if(!_lpszUserName)
    {
        return(E_FAIL);
    }

    return(S_OK);
}


HRESULT
CCredentials::SetPassword(
    LPWSTR lpszPassword
    )
{

    if (_lpszPassword)
    {
        FreeADsStr(_lpszPassword);
    }

    if (!lpszPassword)
    {
        _lpszPassword = NULL;
        return(S_OK);
    }

    return( EncryptString( lpszPassword,
                            &_lpszPassword,
                            &_dwPasswordLen
                            )
          );
}

CCredentials::CCredentials(
    const CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTmpPwd = NULL;

    _lpszUserName = NULL;
    _lpszPassword = NULL;

    _lpszUserName = AllocADsStr(
                        Credentials._lpszUserName
                        );


    if (Credentials._lpszPassword)
    {
        hr = DecryptString(
                 Credentials._lpszPassword,
                 &pszTmpPwd,
                 Credentials._dwPasswordLen
                 );
    }

    if (SUCCEEDED(hr) && pszTmpPwd)
    {
        hr = EncryptString(
                 pszTmpPwd,
                 &_lpszPassword,
                 &_dwPasswordLen
                 );
    }
    else
    {
        pszTmpPwd = NULL;
    }

    if (pszTmpPwd)
    {
        FreeADsStr(pszTmpPwd);
    }

    _dwAuthFlags = Credentials._dwAuthFlags;


}


void
CCredentials::operator=(
    const CCredentials& other
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTmpPwd = NULL;

    if ( &other == this)
    {
        return;
    }

    if (_lpszUserName)
    {
        FreeADsStr(_lpszUserName);
    }

    if (_lpszPassword)
    {
        FreeADsStr(_lpszPassword);
    }

    _lpszUserName = AllocADsStr(
                        other._lpszUserName
                        );


    if (other._lpszPassword)
    {
        hr = DecryptString(
                 other._lpszPassword,
                 &pszTmpPwd,
                 other._dwPasswordLen
                 );
    }

    if (SUCCEEDED(hr) && pszTmpPwd)
    {
        hr = EncryptString(
                 pszTmpPwd,
                 &_lpszPassword,
                 &_dwPasswordLen
                 );
    }
    else
    {
        pszTmpPwd = NULL;
    }

    if (pszTmpPwd)
    {
        FreeADsStr(pszTmpPwd);
    }

    _dwAuthFlags = other._dwAuthFlags;

    return;
}


BOOL
operator==(
    CCredentials& x,
    CCredentials& y
    )
{
    BOOL bEqualUser = FALSE;
    BOOL bEqualPassword = FALSE;
    BOOL bEqualFlags = FALSE;

    LPWSTR lpszXPassword = NULL;
    LPWSTR lpszYPassword = NULL;
    BOOL bReturnCode = FALSE;
    HRESULT hr = S_OK;


    if (x._lpszUserName &&  y._lpszUserName)
    {
        bEqualUser = !(wcscmp(x._lpszUserName, y._lpszUserName));
    }
    else  if (!x._lpszUserName && !y._lpszUserName)
    {
        bEqualUser = TRUE;
    }

    hr = x.GetPassword(&lpszXPassword);
    if (FAILED(hr))
    {
        goto error;
    }

    hr = y.GetPassword(&lpszYPassword);
    if (FAILED(hr))
    {
        goto error;
    }


    if ((lpszXPassword && lpszYPassword))
    {
        bEqualPassword = !(wcscmp(lpszXPassword, lpszYPassword));
    }
    else if (!lpszXPassword && !lpszYPassword)
    {
        bEqualPassword = TRUE;
    }


    if (x._dwAuthFlags == y._dwAuthFlags)
    {
        bEqualFlags = TRUE;
    }


    if (bEqualUser && bEqualPassword && bEqualFlags)
    {

       bReturnCode = TRUE;
    }


error:

    if (lpszXPassword)
    {
        FreeADsStr(lpszXPassword);
    }

    if (lpszYPassword)
    {
        FreeADsStr(lpszYPassword);
    }

    return(bReturnCode);

}


BOOL
CCredentials::IsNullCredentials(
    )
{
    // The function will return true even if the flags are set
    // this is because we want to try and get the default credentials
    // even if the flags were set
     if (!_lpszUserName && !_lpszPassword)
     {
         return(TRUE);
     }
     else
     {
         return(FALSE);
     }

}


DWORD
CCredentials::GetAuthFlags()
{
    return(_dwAuthFlags);
}


void
CCredentials::SetAuthFlags(
    DWORD dwAuthFlags
    )
{
    _dwAuthFlags = dwAuthFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\interfaces.h ===
// Interfaces.h: Definition of the TSUserExInterfaces class
//
//////////////////////////////////////////////////////////////////////

#if !defined(__TSUSEREX_INTERFACES__)
#define __TSUSEREX_INTERFACES__



#include "resource.h"
#include "tsusrsht.h"
//#include "configdlg.h"


#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// #include "ConfigDlg.h"    // for ConfigDlg

class TSUserExInterfaces :
        public IExtendPropertySheet,
        public ISnapinHelp,
		public IShellExtInit,
		public IShellPropSheetExt,
#ifdef _RTM_

        public ISnapinAbout,
#endif

        public CComObjectRoot,
        public CComCoClass<TSUserExInterfaces, &CLSID_TSUserExInterfaces>
{
public:

    TSUserExInterfaces();
    ~TSUserExInterfaces();


BEGIN_COM_MAP(TSUserExInterfaces)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinHelp)
		COM_INTERFACE_ENTRY(IShellExtInit)
		COM_INTERFACE_ENTRY(IShellPropSheetExt)
#ifdef _RTM_

        COM_INTERFACE_ENTRY(ISnapinAbout)
#endif

END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_USEREX_INTERFACES)

    //
    // IExtendPropertySheet
    //

    STDMETHOD(  CreatePropertyPages )(
        LPPROPERTYSHEETCALLBACK lpProvider,     // pointer to the callback interface
        LONG_PTR handle,                            // handle for routing notification
        LPDATAOBJECT lpIDataObject              // pointer to the data object);
        );

    STDMETHOD(  QueryPagesFor   )(
        LPDATAOBJECT lpDataObject               // pointer to the data object
        );
    //
    // ISnapinHelp
    //

    STDMETHOD( GetHelpTopic )(
        LPOLESTR * 
        );

	//
	// IShellExtInit
	//

	STDMETHOD( Initialize )(
		LPCITEMIDLIST pidlFolder,
		LPDATAOBJECT lpdobj,
		HKEY hkeyProgID
	);
	
	//
	// IShellPropSheetExt
	//

	STDMETHOD( AddPages )(
		LPFNADDPROPSHEETPAGE lpfnAddPage,
		LPARAM lParam
	);


	STDMETHOD( ReplacePage )(
		UINT uPageID,
		LPFNADDPROPSHEETPAGE lpfnReplacePage,
		LPARAM lParam
   );






#ifdef _RTM_

    //
    // ISnapinAbout
    //
    STDMETHOD( GetSnapinDescription )( 
            LPOLESTR * );
        
    STDMETHOD( GetProvider )( 
            LPOLESTR * );
        
    STDMETHOD( GetSnapinVersion )( 
            LPOLESTR *lpVersion );
        
    STDMETHOD( GetSnapinImage )( 
            HICON *hAppIcon );
        
    STDMETHOD( GetStaticFolderImage )( 
            /* [out] */ HBITMAP *,
            /* [out] */ HBITMAP *,
            /* [out] */ HBITMAP *,
            /* [out] */ COLORREF *);
#endif


private:

    // TSConfigDlg *m_pUserConfigPage;
    CTSUserSheet *m_pTSUserSheet;

	LPDATAOBJECT m_pDsadataobj;	
  

    //ConfigDlg  *m_pMergedPage;
};


#endif // __TSUSEREX_INTERFACES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\interfaces.cpp ===
// Interfaces.cpp : Implementation of TSUserExInterfaces class.

#include "stdafx.h"

#if 1 //POST_BETA_3
#include <sspi.h>
#include <secext.h>
#include <dsgetdc.h>
#endif //POST_BETA_3

//#include "ConfigDlg.h"    // for CTSUserProperties
#include "tsusrsht.h"

//#include "logmsg.h"
#include "limits.h" // USHRT_MAX
#ifdef _RTM_
#include <ntverp.h> // VER_PRODUCTVERSION_DW
#endif
#include <winsta.h>
//#include "ntdsapi.h" // enbable for "having some fun macro"

// clipboard format to retreive the machine name and account name associated
// with a data object created by local user manager

#define CCF_LOCAL_USER_MANAGER_MACHINE_NAME TEXT("Local User Manager Machine Focus Name")


#define ByteOffset(base, offset) (((LPBYTE)base)+offset)


BOOL g_bPagesHaveBeenInvoked = FALSE;
/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet implementation


HRESULT GetMachineAndUserName(IDataObject *pDataObject, LPWSTR pMachineName, LPWSTR pUserName , PBOOL pbDSAType , PSID *ppUserSid )
{
    ASSERT_(pUserName);
    ASSERT_(pMachineName);
    ASSERT_(pDataObject != NULL );

    // register the display formats.
    // first 2 formats supported by local user manager snapin
    static UINT s_cfMachineName =   RegisterClipboardFormat(CCF_LOCAL_USER_MANAGER_MACHINE_NAME);
    static UINT s_cfDisplayName =   RegisterClipboardFormat(CCF_DISPLAY_NAME);;
    static UINT s_cfDsObjectNames = RegisterClipboardFormat(CFSTR_DSOBJECTNAMES); // this format is supported by dsadmin snapin.

    ASSERT_(s_cfMachineName);
    ASSERT_(s_cfDisplayName);
    ASSERT_(s_cfDsObjectNames);


    FORMATETC fmte          = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    STGMEDIUM medium        = { TYMED_HGLOBAL, NULL, NULL };

    HRESULT hr = S_OK;

    ASSERT_(USHRT_MAX > s_cfDsObjectNames);

    // first we will try dsdataobject format. This means we are running in context of dsadmin

    fmte.cfFormat = ( USHORT )s_cfDsObjectNames;

    hr = pDataObject->GetData(&fmte, &medium);

    if( SUCCEEDED( hr ) )
    {
        // CFSTR_DSOBJECTNAMES is supported.
        // It means we are dealing with dsadmin
        // lets get username, and domain name from the dsadmin.

        LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)medium.hGlobal;

        *pbDSAType = TRUE;

        if( pDsObjectNames->cItems < 1 )
        {
            ODS( L"TSUSEREX : @GetMachineAndUserName DS Object names < 1\n" );

            return E_FAIL;
        }

        LPWSTR pwszObjName = ( LPWSTR )ByteOffset( pDsObjectNames , pDsObjectNames->aObjects[0].offsetName );

        KdPrint( ( "TSUSEREX : adspath is %ws\n" , pwszObjName ) );

        // first stage get the server name from the adspath
        // since IADsPathname does not live off a normal IADs Directory object
        // so me must cocreate the object set the path and then retrieve the server name
        // hey this saves us wire-tripping

        // IADsPathname *pPathname = NULL;

        IADsObjectOptions *pADsOptions = NULL;

        IADs *pADs = NULL;

        hr = ADsGetObject( pwszObjName, IID_IADs, (void**)&pADs );

        if( FAILED( hr ) )
        {
            KdPrint( ( "TSUSEREX : no means of binding to adspath -- hresult =  0x%x\n" , hr ) );

            return hr;
        }

        VARIANT varServerName;

        VariantInit(&varServerName);

        hr = pADs->QueryInterface( IID_IADsObjectOptions , ( void ** )&pADsOptions );

        KdPrint( ( "TSUSEREX : binded to adsobject queried for IID_IADsObjectOptions returned 0x%x\n" , hr ) );

        if( SUCCEEDED( hr ) )
        {
            hr = pADsOptions->GetOption( ADS_OPTION_SERVERNAME, &varServerName);

            pADsOptions->Release( );

            KdPrint( ( "TSUSEREX: GetOption returned 0x%x\n" , hr ) ) ;
        }

        if( SUCCEEDED( hr ) )
        {
            lstrcpy( pMachineName , V_BSTR( &varServerName ) );

            KdPrint( ( "TSUSEREX: Server name is %ws\n" , pMachineName ) ) ;
        }

        VariantClear( &varServerName );


        if( FAILED( hr ) )
        {
            // ADS_FORMAT_SERVER is not supported this could mean we're dealing with an WinNT format
            // or a DS Provider that is poorly implemented

            KdPrint( ( "IADsPathname could not obtain server name 0x%x\n" , hr ) );

            // let's go wire tapping to get the server name

            VARIANT v;

            LPTSTR szDName = NULL;

            ULONG ulDName = 0;

            VariantInit(&v);

            hr = pADs->Get(L"distinguishedName", &v);

            if( FAILED( hr ) )
            {
                KdPrint( ( "TSUSEREX :  pADs->Get( DN ) returned 0x%x\n", hr )  );

                pADs->Release();
                return hr;
            }

            ASSERT_( V_VT( &v ) == VT_BSTR );

            if( !TranslateNameW( V_BSTR(&v), NameFullyQualifiedDN, NameCanonical, szDName, &ulDName) )
            {
                KdPrint( ( "TSUSEREX : TranslateNameW failed with 0x%x\n", GetLastError( ) ) );

                pADs->Release();
                return E_FAIL;
            }

            szDName = ( LPTSTR )new TCHAR[ ulDName + 1 ];

            if( szDName == NULL )
            {
                KdPrint( ( "TSUSEREX : could not allocate space for szDName\n" ) );

                pADs->Release();
                return E_OUTOFMEMORY;
            }

            if( !TranslateNameW( V_BSTR(&v), NameFullyQualifiedDN, NameCanonical, szDName, &ulDName) )
            {
                KdPrint( ( "TSUSEREX : TranslateNameW failed 2nd pass with 0x%x\n", GetLastError( ) ) );

                delete[] szDName;
                pADs->Release();
                return E_FAIL;
            }


            // perform LEFT$( szDName , up to '/' )

            KdPrint( ( "TSUSEREX : TranslateNameW cracked the name to %ws\n" , szDName ) );

            LPTSTR pszTemp = szDName;

            while( pszTemp != NULL )
            {
                if( *pszTemp == L'/' )
                {
                    *pszTemp = 0;

                    break;
                }

                pszTemp++;
            }


            KdPrint( ("TranslateName with my LEFT$ returned %ws\n",szDName ) );

            // get the domaincontroller name of the remote machine

            DOMAIN_CONTROLLER_INFO *pdinfo;

            DWORD dwStatus = DsGetDcName( NULL , szDName , NULL , NULL , 0 , &pdinfo );

            KdPrint( ( "TSUSEREX : DsGetDcName: %ws returned 0x%x\n", pdinfo->DomainControllerName , dwStatus ) );

            if( dwStatus == NO_ERROR )
            {
                lstrcpy( pMachineName , pdinfo->DomainControllerName );

                NetApiBufferFree( pdinfo );
            }

            if( szDName != NULL )
            {
                delete[] szDName;
            }

            VariantClear( &v );

        } // END else


        pADs->Release( );


        IADsUser *pADsUser = NULL;

        hr = ADsGetObject( pwszObjName, IID_IADsUser, (void**)&pADsUser);

        if( FAILED( hr ) )
        {
            KdPrint( ( "TSUSEREX: ADsGetObject failed to get the user object 0x%x\n",hr ) );

            return hr;
        }

        VARIANT var;
        VARIANT varSid;

        VariantInit(&var);
        VariantInit(&varSid);

        hr = pADsUser->Get(L"ObjectSid", &varSid);

        if( FAILED( hr ) )
        {
            ODS( L"TSUSEREX : IADsUser::Get( ObjectSid ) failed \n" );
            
            pADsUser->Release();
            return hr;
        }

        if( !( varSid.vt & VT_ARRAY) )
        {
            ODS( L"TSUSEREX : Object SID is not a VT_ARRAY\n" );

            pADsUser->Release();
            return E_FAIL;
        }

        PSID pSid = NULL;

        PSID pUserSid = NULL;

        SafeArrayAccessData( varSid.parray, &pSid );

        if( !IsValidSid( pSid ) )
        {
            ODS( L"TSUSEREX : pSid is invalid\n" );

            pADsUser->Release();
            return E_FAIL;
        }

        DWORD dwSidSize = GetLengthSid( pSid );

        pUserSid = new BYTE[ dwSidSize ];

        if( pUserSid == NULL )
        {
            ODS( L"TSUSEREX : failed to allocate pUserSid\n" );

            pADsUser->Release();
            return E_FAIL;
        }

        CopySid( dwSidSize , pUserSid , pSid );

        *ppUserSid = pUserSid;

        SafeArrayUnaccessData( varSid.parray );

        VariantClear( &varSid );


        hr = pADsUser->Get( L"samAccountName" , &var );

        pADsUser->Release();

        if( FAILED( hr ) )
        {
            KdPrint( ( "TSUSEREX : ADsUser::Get( name ) failed 0x%x\n", hr ) );

            return hr;
        }


        ASSERT_( V_VT( &var ) == VT_BSTR );

        lstrcpy( pUserName , V_BSTR( &var ) );

        KdPrint( ( "TSUSEREX : Server name %ws user name is %ws\n" , pMachineName , pUserName ) );

        VariantClear( &var );

        ReleaseStgMedium(&medium);
    }
    else
    {
        // CFSTR_DSOBJECTNAMES is NOT supported.
        // It means we are dealing with local user manager.
        // we must be able to get
        // Allocate medium for GetDataHere.

        medium.hGlobal = GlobalAlloc(GMEM_SHARE, MAX_PATH * sizeof(WCHAR));

        if( !medium.hGlobal )
        {
            ODS( L"TSUSEREX : GlobalAlloc failed in GetMachineAndUserName\n" );

            return E_OUTOFMEMORY;
        }

        *pbDSAType = FALSE;

        // since we are doing data conversion.
        // check for possible data loss.

        ASSERT_(USHRT_MAX > s_cfMachineName);

        // request the machine name from the dataobject.

        fmte.cfFormat = (USHORT)s_cfMachineName;

        hr = pDataObject->GetDataHere(&fmte, &medium);

        if( FAILED( hr ) )
        {
            ODS( L"TSUSEREX : @GetMachineAndUserName GetDataHere for s_cfMachineName failed\n" );

            return hr;
        }

        // copy the machine name into our buffer

        if( ( LPWSTR )medium.hGlobal != NULL && pMachineName != NULL )
        {
            wcscpy(pMachineName, (LPWSTR)medium.hGlobal );
        }

        // administer local accounts only for Terminal Servers

        SERVER_INFO_101 *psi101;
        HANDLE hTServer = NULL;

        DWORD dwNetStatus = NetServerGetInfo( pMachineName , 101 , ( LPBYTE * )&psi101 );

        if( dwNetStatus != NERR_Success )
        {
            KdPrint( ( "TSUSEREX:GetMachineAndUserName -- NetServerGetInfo failed with 0x%x\n", dwNetStatus ) );

            return E_FAIL;
        }

        if( psi101 == NULL )
        {
            KdPrint( ( "TSUSEREX:GetMachineAndUserName -- NetServerGetInfo failed getting sinfo101 0x%x\n",dwNetStatus ) );

            return E_FAIL;
        }
        KdPrint( ("TSUSEREX:NetServerGetInfo server bits returnd 0x%x and nttype is 0x%x\n", psi101->sv101_type , SV_TYPE_SERVER_NT ) );

        BOOL fServer = ( BOOL )( psi101->sv101_type & ( DWORD )SV_TYPE_SERVER_NT );

        NetApiBufferFree( ( LPVOID )psi101 );

        if( !fServer )
        {

            KdPrint( ( "TSUSEREX : viewing local account on non-TS ( exiting )\n" ) );

            return E_FAIL;
        }

        hTServer = WinStationOpenServer( pMachineName );
        if( hTServer == NULL )
        {
            KdPrint( ( "TSUSEREX: This OS does not support terminal services\n" ) ) ;
            return E_FAIL;
        }
        WinStationCloseServer( hTServer );

        // since we are doing data conversion.
        // check for possible data loss.

        ASSERT_(USHRT_MAX > s_cfDisplayName);

        // request data  about user name.

        fmte.cfFormat = (USHORT)s_cfDisplayName;

        hr = pDataObject->GetDataHere( &fmte , &medium );

        if( FAILED( hr ) )
        {
            ODS( L"TSUSEREX : @GetMachineAndUserName GetDataHere for s_cfDisplayName failed\n" );

            return hr;
        }

        // copy the user name into our buffer and release the medium.

        if( ( LPWSTR )medium.hGlobal != NULL && pUserName != NULL )
        {
            wcscpy( pUserName , ( LPWSTR )medium.hGlobal );
        }

        ReleaseStgMedium( &medium );
    }

    return S_OK;
}

//-----------------------------------------------------------------------------------------------------
TSUserExInterfaces::TSUserExInterfaces()
{
    // LOGMESSAGE0(_T("TSUserExInterfaces::TSUserExInterfaces()..."));
    // m_pUserConfigPage = NULL;
    m_pTSUserSheet = NULL;

    m_pDsadataobj = NULL;
}

//-----------------------------------------------------------------------------------------------------
TSUserExInterfaces::~TSUserExInterfaces()
{
   ODS( L"Good bye\n" );
}

//-----------------------------------------------------------------------------------------------------
HRESULT TSUserExInterfaces::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,    // pointer to the callback interface
    LONG_PTR ,                                 // handle for routing notification
    LPDATAOBJECT lpIDataObject)            // pointer to the data object);
{
    //
    // Test for valid parameters
    //

    if( lpIDataObject == NULL || IsBadReadPtr( lpIDataObject , sizeof( LPDATAOBJECT ) ) )
    {
        ODS( L"TSUSEREX : @ CreatePropertyPages IDataObject is invalid\n " );

        return E_INVALIDARG;
    }

    if( lpProvider == NULL )
    {
        ODS( L"TSUSEREX @ CreatePropertyPages LPPROPERTYSHEETCALLBACK is invalid\n" );

        return E_INVALIDARG;
    }

    WCHAR wUserName[ MAX_PATH ];

    WCHAR wMachineName[ MAX_PATH ];

    BOOL bDSAType;



    if( g_bPagesHaveBeenInvoked )
    {
        ODS( L"TSUSEREX : TSUserExInterfaces::CreatePropertyPages pages have been invoked\n" );

        return E_FAIL;
    }


    PSID pUserSid = NULL;


    if( FAILED( GetMachineAndUserName( lpIDataObject , wMachineName , wUserName , &bDSAType , &pUserSid ) ) )
    {
        ODS( L"TSUSEREX : GetMachineAndUserName failed @CreatePropertyPages \n" );

        return E_FAIL;
    }

    //
    // Test to see if we are being called twice
    //

    if( m_pTSUserSheet != NULL )
    {
        return E_FAIL;
    }

    //
    // MMC likes to release IEXtendPropertySheet ( this object )
    // so we cannot free CTSUserSheet in TSUserExInterfaces::dtor
    // CTSUserSheet must release itself!!!
    //

    m_pTSUserSheet = new CTSUserSheet( );

    if( m_pTSUserSheet != NULL )
    {
        ODS( L"TSUSEREX : CreatePropertyPages mem allocation succeeded\n" );

        m_pTSUserSheet->SetDSAType( bDSAType );

        VERIFY_S( TRUE , m_pTSUserSheet->SetServerAndUser( &wMachineName[0] , &wUserName[0] ) );

        m_pTSUserSheet->CopyUserSid( pUserSid );

        VERIFY_S( S_OK , m_pTSUserSheet->AddPagesToPropSheet( lpProvider ) );
    }

    return S_OK;

}

//-----------------------------------------------------------------------------------------------------
HRESULT TSUserExInterfaces::QueryPagesFor(  LPDATAOBJECT /* lpDataObject */  )
{
    return S_OK;
}

//-----------------------------------------------------------------------------------------------------
// this has not been checked in yet!!!
//-----------------------------------------------------------------------------------------------------
STDMETHODIMP TSUserExInterfaces::GetHelpTopic( LPOLESTR *ppszHelp )
{
    ODS( L"TSUSEREX : GetHelpTopic\n" );

    if( ppszHelp == NULL )
    {
        return E_INVALIDARG;
    }

    TCHAR tchHelpFile[ 80 ];

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_TSUSERHELP , tchHelpFile , sizeof( tchHelpFile ) / sizeof( TCHAR ) ) );

    // mmc will call CoTaskMemFree

    *ppszHelp = ( LPOLESTR )CoTaskMemAlloc( sizeof( TCHAR ) * MAX_PATH );

    if( *ppszHelp != NULL )
    {
        if( GetSystemWindowsDirectory( *ppszHelp , MAX_PATH ) != 0 )
        {
            lstrcat( *ppszHelp , tchHelpFile );
        }
        else
        {
            lstrcpy( *ppszHelp , tchHelpFile );
        }

        ODS( *ppszHelp );

        ODS( L"\n" );

        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//-----------------------------------------------------------------------------------------------------
// IShellExtInit

STDMETHODIMP TSUserExInterfaces::Initialize(
        LPCITEMIDLIST ,
        LPDATAOBJECT lpdobj,
        HKEY
    )
{
    m_pDsadataobj = lpdobj;

    return S_OK;
}

//-----------------------------------------------------------------------------------------------------
// IShellPropSheetExt - this interface is used only for dsadmin based tools
//                      for this reason the DSAType flag is set to true.

STDMETHODIMP TSUserExInterfaces::AddPages(
        LPFNADDPROPSHEETPAGE lpfnAddPage,
        LPARAM lParam
    )
{
    //
    // Test for valid parameters
    //

    if( m_pDsadataobj == NULL )
    {
        ODS( L"TSUSEREX : @ AddPages IDataObject is invalid\n " );

        return E_INVALIDARG;
    }

    if( lpfnAddPage == NULL )
    {
        ODS( L"TSUSEREX @ AddPages LPFNADDPROPSHEETPAGE is invalid\n" );

        return E_INVALIDARG;
    }

    WCHAR wUserName[ MAX_PATH ];

    WCHAR wMachineName[ MAX_PATH ];

    BOOL bDSAType;

    PSID pUserSid = NULL;


    if( FAILED( GetMachineAndUserName( m_pDsadataobj , wMachineName , wUserName , &bDSAType , &pUserSid ) ) )
    {
        ODS( L"TSUSEREX : GetMachineAndUserName @AddPages failed \n" );

        return E_FAIL;
    }

    ODS( L"TSUSEREX : DSATYPE in AddPages\n" );

    g_bPagesHaveBeenInvoked = TRUE;

    //
    // Test to see if we are being called twice
    //

    if( m_pTSUserSheet != NULL )
    {
        return E_FAIL;
    }

    //
    // MMC likes to release IEXtendPropertySheet ( this object )
    // so we cannot free CTSUserSheet in TSUserExInterfaces::dtor
    // CTSUserSheet must release itself!!!
    //

    m_pTSUserSheet = new CTSUserSheet( );

    if( m_pTSUserSheet != NULL )
    {
        ODS( L"TSUSEREX : AddPages mem allocation succeeded\n" );

        m_pTSUserSheet->SetDSAType( bDSAType );

        m_pTSUserSheet->CopyUserSid( pUserSid );

        VERIFY_S( TRUE , m_pTSUserSheet->SetServerAndUser( &wMachineName[0] , &wUserName[0] ) );

        VERIFY_S( S_OK , m_pTSUserSheet->AddPagesToDSAPropSheet( lpfnAddPage , lParam ) );
    }
    return S_OK;
}

//-----------------------------------------------------------------------------------------------------

STDMETHODIMP TSUserExInterfaces::ReplacePage(
        UINT ,
        LPFNADDPROPSHEETPAGE ,
        LPARAM
   )
{
    return E_FAIL;
}


#ifdef _RTM_ // add ISnapinAbout
//-----------------------------------------------------------------------------------------------------
STDMETHODIMP TSUserExInterfaces::GetSnapinDescription(
            LPOLESTR *ppOlestr )
{
    TCHAR tchMessage[] = TEXT("This extension allows the administrator to configure Terminal Services user properties. This extension is only enabled on Terminal Servers.");

    ODS( L"TSUSEREX: GetSnapinDescription called\n" );

    *ppOlestr = ( LPOLESTR )CoTaskMemAlloc( ( lstrlen( tchMessage ) + 1 ) * sizeof( TCHAR ) );

    if( *ppOlestr != NULL )
    {
        lstrcpy( *ppOlestr , tchMessage );

        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//-----------------------------------------------------------------------------------------------------
STDMETHODIMP TSUserExInterfaces::GetProvider(
            LPOLESTR *ppOlestr )
{
    TCHAR tchMessage[] = TEXT("Microsoft Corporation");

    ODS( L"TSUSEREX: GetProvider called\n" );

    *ppOlestr = ( LPOLESTR )CoTaskMemAlloc( ( lstrlen( tchMessage ) + 1 ) * sizeof( TCHAR ) );

    if( *ppOlestr != NULL )
    {
        lstrcpy( *ppOlestr , tchMessage );

        return S_OK;
    }

    return E_OUTOFMEMORY;

}

//-----------------------------------------------------------------------------------------------------
STDMETHODIMP TSUserExInterfaces::GetSnapinVersion(
            LPOLESTR *ppOlestr )
{
    char chMessage[ 32 ] = VER_PRODUCTVERSION_STR;

    TCHAR tchMessage[32];

    ODS( L"TSUSEREX: GetSnapinVersion called\n" );

    int iCharCount = MultiByteToWideChar( CP_ACP , 0 , chMessage , sizeof( chMessage ) , tchMessage , sizeof( tchMessage ) / sizeof( TCHAR ) );

    //wsprintf( tchMessage , TEXT( "%d" ) , VER_PRODUCTVERSION_DW );

    *ppOlestr = ( LPOLESTR )CoTaskMemAlloc( ( iCharCount + 1 ) * sizeof( TCHAR ) );

    if( *ppOlestr != NULL )
    {
        lstrcpy( *ppOlestr , tchMessage );

        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//-----------------------------------------------------------------------------------------------------
STDMETHODIMP TSUserExInterfaces::GetSnapinImage(
            HICON * )
{
    return E_NOTIMPL;
}

//-----------------------------------------------------------------------------------------------------
STDMETHODIMP TSUserExInterfaces::GetStaticFolderImage(
            /* [out] */ HBITMAP *,
            /* [out] */ HBITMAP *,
            /* [out] */ HBITMAP *,
            /* [out] */ COLORREF *)
{
    return E_NOTIMPL;
}

#endif //_RTM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tsuserex.rc
//
#define IDD_CUSTOMIZE                   101
#define IDR_USEREX_INTERFACES           102
#define IDD_PAGE_PROFILE                102
#define IDR_EXTCOPYNOUI                 105
#define IDR_ADS                         106
#define IDD_PAGE_TIMEOUTS               133
#define IDD_PAGE_ENVIRO                 134
#define IDD_PAGE_SHADOW                 137
#define IDC_EDIT_HOURS                  1000
#define IDC_RADIO_DISCON                1001
#define IDC_EDIT_MINUTES                1001
#define IDC_RADIO_RESET                 1002
#define IDC_STATIC_ME                   1002
#define IDC_EDIT_WDIR                   1003
#define IDC_EDIT_CMDLINE                1004
#define IDC_SPIN_CTRL                   1004
#define IDC_CHECK_USEDEFAULT            1005
#define IDC_COMBO_CONNECT               1006
#define IDC_CHECK_CCDL                  1007
#define IDC_STATIC_WD                   1008
#define IDC_COMBO_DISCON                1009
#define IDC_STATIC_CMD                  1010
#define IDC_STATIC_CONNECTION           1010
#define IDC_COMBO_IDLE                  1011
#define IDC_EDIT_USRPROFILE             1012
#define IDC_STATIC_DISCON               1012
#define IDC_USER_PROFILE                1013
#define IDC_STATIC_IDLE                 1013
#define IDC_RADIO_WATCH                 1014
#define IDC_STATIC_ONBROKENCON          1014
#define IDC_RADIO_CONTROL               1015
#define IDC_STATIC_RECONDISCON          1015
#define IDC_RADIO_ANYCLIENT             1016
#define IDC_CHECK_NOTIFY                1017
#define IDC_RADIO_PREVCLIENT            1018
#define IDC_CHECK_CCPL                  1019
#define IDC_CHECK_DMCP                  1020
#define IDC_RADIO_LOCAL                 1021
#define IDC_EDIT_LOCALPATH              1022
#define IDC_CHECK_SHADOW                1023
#define IDC_RADIO_REMOTE                1024
#define IDC_EDIT_REMOTEPATH             1025
#define IDC_CHECK_ALLOWLOGON            1026
#define IDC_COMBO_DRIVES                1027
#define IDC_TSP_DRIVE                   1028
#define IDS_COMBO_TIME1                 18614
#define IDS_COMBO_TIME2                 18615
#define IDS_COMBO_TIME3                 18616
#define IDS_COMBO_TIME4                 18617
#define IDS_COMBO_TIME5                 18618
#define IDS_COMBO_TIME6                 18619
#define IDS_BACKSLASH                   18631
#define IDS_ERROR_PATH                  18632
#define IDS_ERROR_REMOTEPATH            18633
#define IDS_ERROR_NETPATH               18634
#define IDS_WARN_PATH                   18635
#define IDS_ERROR_TITLE                 18636
#define IDS_WARN_TITLE                  18637
#define IDS_HELPFILE                    18638
#define IDS_ERROR_NUMERICENTRY          18639
#define IDS_NOTIMEOUT                   18640
#define IDS_CUSTOMIZE                   18641
#define IDS_DIGIT_DOT_DIGIT_TU          18644
#define IDS_DIGIT_TU                    18645
#define IDS_DAYS                        18647
#define IDS_DAY                         18648
#define IDS_HOURS                       18649
#define IDS_HOUR                        18650
#define IDS_MINUTES                     18651
#define IDS_MINUTE                      18652
#define IDS_D                           18653
#define IDS_H                           18654
#define IDS_M                           18655
#define IDS_HR                          18656
#define IDS_HRS                         18657
#define IDS_MIN                         18658
#define IDS_ERROR_TOOMANYDIGITS         18659
#define IDS_ERROR_PARSEINVALID          18660
#define IDS_ERROR_MAXVALEXCEEDED        18661
#define IDS_NAMESTRING_SNAPIN           18662
#define IDS_PROVIDER_SNAPIN             18663
#define IDS_VERSION_SNAPIN              18664
#define IDS_TSGETPROPSFAILED            18665
#define IDS_TSGETPROPTITLE              18666
#define IDS_COMBO_CONNECTION            18667
#define IDS_COMBO_DISCONNECTION         18668
#define IDS_COMBO_IDLECONNECTION        18669
#define IDS_TSOPSFAILED                 18670
#define IDS_TSUSERHELP                  18671
#define IDS_USERNAME                    18672
#define IDS_HOME_DIR_EXISTS             18673
#define IDS_HOME_DIR_CREATE_FAILED      18674
#define IDS_HOME_DIR_CREATE_NO_ACCESS   18675
#define IDS_ERR_CREATE_DIR              18676

#define ID_WHATSTHIS_WHATSTHIS          40002

#define IDC_STATIC_LEVELOFCTRL          -2
#define IDC_STATIC                      -1
#define IDC_TSP_DIRECTORY               -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsutil\acl.c ===
/*
 *  Acl.c
 *
 *  Author: BreenH
 *
 *  Acl utilities.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutil.h"
#include "tsutilnt.h"

/*
 *  Function Implementations
 */

BOOL WINAPI
AddSidToObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    PSID pSid,
    DWORD dwNewAccess,
    ACCESS_MODE AccessMode,
    DWORD dwInheritance
    )
{
    BOOL fRet;
    DWORD dwRet;
    EXPLICIT_ACCESS ExpAccess;
    PACL pNewDacl;
    PACL pOldDacl;
    PSECURITY_DESCRIPTOR pSd;

    //
    //  Get the objects security descriptor and current Dacl.
    //

    pSd = NULL;
    pOldDacl = NULL;

    dwRet = GetSecurityInfo(
            hObject,
            ObjectType,
            DACL_SECURITY_INFORMATION,
            NULL,
            NULL,
            &pOldDacl,
            NULL,
            &pSd
            );

    if (dwRet != ERROR_SUCCESS)
    {
        return(FALSE);
    }

    //
    //  Initialize an EXPLICIT_ACCESS structure for the new ace.
    //

    ZeroMemory(&ExpAccess, sizeof(EXPLICIT_ACCESS));
    ExpAccess.grfAccessPermissions = dwNewAccess;
    ExpAccess.grfAccessMode = AccessMode;
    ExpAccess.grfInheritance = dwInheritance;
    BuildTrusteeWithSid(&(ExpAccess.Trustee), pSid);

    //
    //  Merge the new ace into the existing Dacl.
    //

    fRet = FALSE;

    dwRet = SetEntriesInAcl(
            1,
            &ExpAccess,
            pOldDacl,
            &pNewDacl
            );

    if (dwRet == ERROR_SUCCESS)
    {

        //
        //  Set the new security for the object.
        //

        dwRet = SetSecurityInfo(
                hObject,
                ObjectType,
                DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                pNewDacl,
                NULL
                );

        if (dwRet == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
    }

    if (pNewDacl != NULL)
    {
        LocalFree(pNewDacl);
    }

    if (pSd != NULL)
    {
        LocalFree(pSd);
    }

    return(fRet);
}


BOOL WINAPI
AddSidToSecurityDescriptor(
    PSECURITY_DESCRIPTOR *ppSd,
    PSID pSid,
    DWORD dwNewAccess,
    ACCESS_MODE AccessMode,
    DWORD dwInheritance
    )
{
    BOOL fAbsoluteSd;
    BOOL fDaclDefaulted;
    BOOL fDaclPresent;
    BOOL fRet;
    PACL pDacl;
    PSECURITY_DESCRIPTOR pAbsoluteSd;
    PSECURITY_DESCRIPTOR pOriginalSd;

    ASSERT(ppSd != NULL);
    ASSERT(*ppSd != NULL);

    //
    //  The security descriptors should be absolute to allow the addition of
    //  the new ace.
    //

    pOriginalSd = *ppSd;

    fAbsoluteSd = IsSecurityDescriptorAbsolute(pOriginalSd);

    if (!fAbsoluteSd)
    {
        fRet = ConvertSelfRelativeToAbsolute(&pAbsoluteSd, pOriginalSd);

        if (!fRet)
        {
            return(FALSE);
        }
    }
    else
    {
        pAbsoluteSd = pOriginalSd;
    }

    //
    //  Now that the type of security descriptor is absolute, get the Dacl.
    //

    pDacl = NULL;

    fRet = GetSecurityDescriptorDacl(
            pAbsoluteSd,
            &fDaclPresent,
            &pDacl,
            &fDaclDefaulted
            );

    if (fRet)
    {
        DWORD dwRet;
        EXPLICIT_ACCESS ExplicitAccess;
        PACL pNewDacl;

        //
        //  Initialize an EXPLICIT_ACCESS structure for the new ace.
        //

        RtlZeroMemory(&ExplicitAccess, sizeof(EXPLICIT_ACCESS));
        ExplicitAccess.grfAccessPermissions = dwNewAccess;
        ExplicitAccess.grfAccessMode = AccessMode;
        ExplicitAccess.grfInheritance = dwInheritance;
        BuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid);

        //
        //  Merge the ace into the existing Dacl. This will allocate a new
        //  Dacl. Unfortunately this API is only available as a WINAPI.
        //

        pNewDacl = NULL;

        dwRet = SetEntriesInAcl(
                1,
                &ExplicitAccess,
                pDacl,
                &pNewDacl
                );

        if (dwRet == ERROR_SUCCESS)
        {
            ASSERT(pNewDacl != NULL);

            //
            //  Point the security descriptor's Dacl to the new Dacl.
            //

            fRet = SetSecurityDescriptorDacl(
                    pAbsoluteSd,
                    TRUE,
                    pNewDacl,
                    FALSE
                    );

            if (fRet)
            {
                PULONG_PTR pBeginning;
                PULONG_PTR pEnd;
                PULONG_PTR pPtr;

                //
                //  The new Dacl has been set, free the old. Be careful here;
                //  the RTL folks like to put absolute security descriptors in
                //  one big allocation, just like a self-relative security
                //  descriptor. If the old Dacl is inside the security
                //  descriptor allocation, it cannot be freed. Essentially,
                //  that memory becomes unused, and the security descriptor
                //  takes up more space than necessary.
                //

                pBeginning = (PULONG_PTR)pAbsoluteSd;
                pEnd = (PULONG_PTR)((PBYTE)pAbsoluteSd +
                        LocalSize(pAbsoluteSd));
                pPtr = (PULONG_PTR)pDacl;

                if ((pPtr < pBeginning) || (pPtr > pEnd))
                {
                    LocalFree(pDacl);
                }
            }
            else
            {

                //
                //  A failure occurred setting the new Dacl. This should never
                //  occur, but if it does, free the newly created Dacl.
                //

                LocalFree(pNewDacl);
            }
        }
        else
        {
            fRet = FALSE;
        }
    }

    //
    //  The new security descriptor should be returned in the same format as
    //  the original security descriptor. The returned security descriptor is
    //  also dependent on the success of the function.
    //

    if (!fAbsoluteSd)
    {
        if (fRet)
        {
            PSECURITY_DESCRIPTOR pNewSd;

            //
            //  The original security descriptor was self-relative, and until
            //  now everything has succeeded. Convert the temporary absolute
            //  security descriptor back to self-relative form. This creates a
            //  third security descriptor (the other two being the original
            //  and the absolute).
            //

            pNewSd = NULL;

            fRet = ConvertAbsoluteToSelfRelative(
                    &pNewSd,
                    pAbsoluteSd,
                    NULL
                    );

            if (fRet)
            {

                //
                //  The final conversion was successful. Free the original
                //  security descriptor. The absolute security descriptor is
                //  freed later. The only possible error from destroying the
                //  security descriptor is a version mismatch, but that would
                //  have happened long ago.
                //

                *ppSd = pNewSd;

                (VOID)DestroySecurityDescriptor(&pOriginalSd);
            }
            else
            {

                //
                //  The final conversion failed. At this point, the original
                //  security descriptor is still intact. Free the absolute
                //  security descriptor that was created earlier, and leave
                //  the passed in security descriptor pointer alone. Note that
                //  with the absolute security descriptor being freed later,
                //  there is nothing to do here.
                //

            }
        }

        //
        //  Regardless of success or failure, the absolute security descriptor
        //  was created, so it must be freed. The only possible error from destroying the
        //  security descriptor is a version mismatch, but that would
        //  have happened long ago.
        //

        (VOID)DestroySecurityDescriptor(&pAbsoluteSd);

    }
    else
    {

        //
        //  Regardless of what happened, there is nothing to do here. The
        //  original security descriptor was absolute; therefore no copies
        //  were made. The only data that changed was the Dacl, and whether
        //  or not that succeeded is irrelevant, as that was handled above.
        //

    }

    return(fRet);
}

BOOL WINAPI
ConvertAbsoluteToSelfRelative(
    PSECURITY_DESCRIPTOR *ppSelfRelativeSd,
    PSECURITY_DESCRIPTOR pAbsoluteSd,
    PDWORD pcbSelfRelativeSd
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtConvertAbsoluteToSelfRelative(
        ppSelfRelativeSd,
        pAbsoluteSd,
        pcbSelfRelativeSd
        );

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}

BOOL WINAPI
ConvertSelfRelativeToAbsolute(
    PSECURITY_DESCRIPTOR *ppAbsoluteSd,
    PSECURITY_DESCRIPTOR pSelfRelativeSd
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtConvertSelfRelativeToAbsolute(ppAbsoluteSd, pSelfRelativeSd);

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}

BOOL WINAPI
DestroySecurityDescriptor(
    PSECURITY_DESCRIPTOR *ppSd
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtDestroySecurityDescriptor(ppSd);

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}

BOOL WINAPI
IsSecurityDescriptorAbsolute(
    PSECURITY_DESCRIPTOR pSd
    )
{
    BOOLEAN fAbsolute;
    BOOL fRet;
    NTSTATUS Status;

    fAbsolute = FALSE;

    Status = NtIsSecurityDescriptorAbsolute(pSd, &fAbsolute);

    fRet = ((NT_SUCCESS(Status)) && fAbsolute);

    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B52C1E46_1DD2_11D1_BC43_00C04FC31FD3__INCLUDED_)
#define AFX_STDAFX_H__B52C1E46_1DD2_11D1_BC43_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/*
#if defined(DBG) && !defined(_DEBUG)

// since we are using mfc, we should have _DEBUG defind if DBG is
// you might also want to set DEBUG_CRTS in source file to get rid of the linker errors.
#error DBG Defined but _DEBUG is not!

#endif

#if defined(_DEBUG) &&  !defined(DBG)

// since we are using mfc, we should have not have _DEBUG defind if DBG is not
#error _DEBUG defined but DBG is not!

#endif
*/



#define STRICT
/*
#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxmt.h>
#include <afxdlgs.h>
*/
/*
#include <windows.h>
//#include <tchar.h>
#include <time.h>
#include <stdio.h>
#include <setupapi.h>
#include <prsht.h>
*/
// #define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#ifdef _WIN32_IE
#undef _WIN32_IE
#endif
#define _WIN32_IE 0x0400


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef _RTM_
#include <ntsam.h>
#endif
/*#include <ntlsa.h>
*/

#include <windows.h>
#include <prsht.h>
#include <commctrl.h>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <shlobj.h>
#include <dsclient.h>
#include <mmc.h>
#include <lm.h>
#include <aclapi.h>

extern HINSTANCE g_AdvApi32LibraryHandle;
extern HINSTANCE g_ScramblingLibraryHandle;

#include <activeds.h>

//
// Interface definitions
//
#include "tsuserex.h"
#include "interfaces.h"
#ifdef _RTM_
#include "tsusrcpy.h"
#endif
#include "ads.h"

#include "winsta.h"
#ifdef _RTM_
#ifdef __cplusplus
extern "C" {
#endif
#include <regsam.h>
#ifdef __cplusplus
}
#endif
#endif
// for 'trace' debuging (sample remnants)
#ifdef DBG
#define ODS OutputDebugString
#define VERIFY_E( retval , expr ) \
    if( ( expr ) == retval ) \
    {  \
       ODS( L#expr ); \
       ODS( L" returned "); \
       ODS( L#retval ); \
       ODS( L"\n" ); \
    } \

#define VERIFY_S( retval , expr ) \
    if( ( expr ) != retval ) \
{\
      ODS( L#expr ); \
      ODS( L" failed to return " ); \
      ODS( L#retval ); \
      ODS( L"\n" ); \
}\

#define ASSERT_( expr ) \
    if( !( expr ) ) \
    { \
       char tchAssertErr[ 256 ]; \
       wsprintfA( tchAssertErr , "Assertion in expression ( %s ) failed\nFile - %s\nLine - %d\nDo you wish to Debug?", #expr , (__FILE__) , __LINE__ ); \
       if( MessageBoxA( NULL , tchAssertErr , "ASSERTION FAILURE" , MB_YESNO | MB_ICONERROR )  == IDYES ) \
       {\
            DebugBreak( );\
       }\
    } \

#else

#define ODS
#define VERIFY_E( retval , expr ) ( expr )
#define VERIFY_S( retval , expr ) ( expr )
#define ASSERT_( expr )

#endif

//#define ASSERT _ASSERT
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B52C1E46_1DD2_11D1_BC43_00C04FC31FD3__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsutil\lsa.c ===
/*
 *  Lsa.c
 *
 *  Author: BreenH
 *
 *  LSA utilities.
 */

/*
 *  Includes
 */

#include "precomp.h"

/*
 *  Function Implementations
 */

VOID NTAPI
InitLsaString(
    PLSA_UNICODE_STRING pLsaString,
    PCWSTR pString
    )
{
    ULONG cchString;

    //
    //  Unicode strings do not require NULL terminators. Length should relay
    //  the number of bytes in the string, with MaximumLength set to the
    //  number of bytes in the entire buffer.
    //

    if (pString != NULL)
    {
        cchString = lstrlenW(pString);
        pLsaString->Buffer = (PWSTR)pString;
        pLsaString->Length = (USHORT)(cchString * sizeof(WCHAR));
        pLsaString->MaximumLength = (USHORT)((cchString + 1) * sizeof(WCHAR));
    }
    else
    {
        pLsaString->Buffer = (PWSTR)NULL;
        pLsaString->Length = 0;
        pLsaString->MaximumLength = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\tsuserex.cpp ===
// tsuserex.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f tsexusrmps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include <shlwapi.h>
#include "tsuserex_i.c"     // generated file. class ids.

#define GUIDSIZE 40

TCHAR tchSnapinRegKey[] = TEXT( "Software\\Microsoft\\MMC\\SnapIns\\" );

TCHAR tchNodeRegKey[] = TEXT( "Software\\Microsoft\\MMC\\NodeTypes\\" );

TCHAR tchExtKey[] = TEXT( "\\Extensions\\PropertySheet" );

HRESULT Local_RegisterNodeType( const GUID *pGuidNodeType , const GUID *pGuidExtension  , LPTSTR szDescription );

HRESULT Local_RegisterSnapinExt( const GUID *pGuidToRegister , const GUID *pAboutGuid , LPTSTR szNameString , LPTSTR szNameStringIndirect , LPTSTR szProvider , LPTSTR szVersion );

HRESULT Local_VerifyNodeType( const GUID *pGuidSnapin , const GUID *pGuidSnapinNodeTypeToVerify );

HINSTANCE ghInstance;
HINSTANCE GetInstance()
{
    return ghInstance;
}

/////////////////////////////////////////////////////////////////////////////
// Register the class

STDAPI RegisterADsExt(void)
{
    HRESULT hr;
    HKEY hKey = NULL;
    DWORD dwDisposition;

    /////////////////////
    // Register the class
    ////////////////////
    hr = RegCreateKeyEx( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\ADs\\Providers\\LDAP\\Extensions\\User\\{E2E9CAE6-1E7B-4B8E-BABD-E9BF6292AC29}"),
     0,
     NULL,
     REG_OPTION_NON_VOLATILE,
     KEY_WRITE,
     NULL,
     &hKey,
     &dwDisposition );
    ///////////////////////////////////////////
    // Register the Interface
    //////////////////////////////////////////// 
    const wchar_t szIf[] = L"{C4930E79-2989-4462-8A60-2FCF2F2955EF}";

    if(ERROR_SUCCESS == hr)
    {
        hr = RegSetValueEx( hKey, _T("Interfaces"), 0, REG_MULTI_SZ, (const BYTE *) szIf, sizeof(szIf));
    }

    if(NULL != hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    hr = RegCreateKeyEx( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\ADs\\Providers\\WinNT\\Extensions\\User\\{E2E9CAE6-1E7B-4B8E-BABD-E9BF6292AC29}"),
     0,
     NULL,
     REG_OPTION_NON_VOLATILE,
     KEY_WRITE,
     NULL,
     &hKey,
     &dwDisposition );

    if(ERROR_SUCCESS == hr)
    {
        hr = RegSetValueEx( hKey, _T("Interfaces"), 0, REG_MULTI_SZ, (const BYTE *) szIf, sizeof(szIf));
    }

    if(NULL != hKey)
    {
        RegCloseKey(hKey);
    }

    return S_OK;
}


CComModule _Module;

// this object has IExtendPropertySheet interface.
BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_TSUserExInterfaces, TSUserExInterfaces)
#ifdef _RTM_
    OBJECT_ENTRY(CLSID_ExtCopyNoUI, CExtCopyNoUI )
#endif
    OBJECT_ENTRY(CLSID_ADsTSUserEx, ADsTSUserEx)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        ghInstance = hInstance;

        _Module.Init(ObjectMap, hInstance);

        DisableThreadLibraryCalls(hInstance);


    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        // LOGMESSAGE0(_T("DllMain::Process being Detached..."));
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    // LOGMESSAGE1(_T("DllCanUnloadNow..Returing %s"), _Module.GetLockCount()==0 ? _T("S_OK") : _T("S_FALSE"));
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    // LOGMESSAGE0(_T("DllGetClassObject.."));
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

/* extern */ const CLSID CLSID_LocalUser =
{  /* 5d6179c8-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179c8,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};
/* extern */ const GUID NODETYPE_User =
{ /* 5d6179cc-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179cc,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};


// /* extern */ const GUID NODETYPE_DSUser =
//{ /* 228D9A84-C302-11CF-9AA4-00AA004A5691 */
//   0x228D9A84,
//   0xC302,
//   0x11CF,
//   {0x9A, 0xA4, 0x00, 0xAA, 0x00, 0x4A, 0x56, 0x91}
//};


// DS Snapin CLSID - {E355E538-1C2E-11d0-8C37-00C04FD8FE93}
const GUID CLSID_DSSnapin =
{
    0xe355e538,
    0x1c2e,
    0x11d0,
    {0x8c, 0x37, 0x0, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};


/* extern */ const GUID NODETYPE_DSUser =
{ /* BF967ABA-0DE6-11D0-A285-00AA003049E2 */
   0xBF967ABA,
   0x0DE6,
   0x11D0,
   {0xA2, 0x85, 0x00, 0xAA, 0x00, 0x30, 0x49, 0xE2}
};
// bf967aba0de611d0a28500aa003049e2



STDAPI DllRegisterServer(void)
{
    TCHAR tchNameString[ 160 ];
    TCHAR tchSysDllPathName[ MAX_PATH ];
    TCHAR tchNameStringIndirect[ MAX_PATH ];
    TCHAR tchProvider[ 160 ];
    TCHAR tchVersion[ 16 ];

    HRESULT hr = _Module.RegisterServer(TRUE);

    RegisterADsExt();

    if( SUCCEEDED( hr ) )
    {
        //  register it as extension to localsecurity snapin

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NAMESTRING_SNAPIN , tchNameString , sizeof( tchNameString ) / sizeof( TCHAR ) ) );

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROVIDER_SNAPIN , tchProvider , sizeof( tchProvider ) / sizeof( TCHAR ) ) );

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_VERSION_SNAPIN , tchVersion , sizeof( tchVersion ) / sizeof( TCHAR ) ) );

        GetModuleFileName(_Module.GetResourceInstance(), tchSysDllPathName, sizeof(tchSysDllPathName) / sizeof(TCHAR));

        tchSysDllPathName[(sizeof(tchSysDllPathName)/sizeof(tchSysDllPathName[0]))-1] = L'\0';

        wsprintf(tchNameStringIndirect, L"@%s,-%d", tchSysDllPathName, IDS_NAMESTRING_SNAPIN);

        hr = Local_RegisterSnapinExt( &CLSID_TSUserExInterfaces ,
                                      &CLSID_TSUserExInterfaces ,
                                      tchNameString ,
                                      tchNameStringIndirect ,
                                      tchProvider ,
                                      tchVersion
                                     );
    }

    if( SUCCEEDED( hr ) )
    {
        hr = Local_RegisterNodeType( &NODETYPE_User , &CLSID_TSUserExInterfaces , _T( "Terminal Server property page extension" ) );
    }

    if( SUCCEEDED( hr ) )
    {
        // the dsadmin snapin does not list all its node, as there are lot of them
        // so before registring ourself to extend the node,
        // lets write the nodeType we are going to extend into registry ourselves

        hr = Local_VerifyNodeType( &CLSID_DSSnapin , &NODETYPE_DSUser );
    }

    if( SUCCEEDED( hr ) )
    {
        hr = Local_RegisterNodeType( &NODETYPE_DSUser , &CLSID_TSUserExInterfaces , _T( "Terminal Server property page extension" ) );
    }

    return hr;
}

//---------------------------------------------------------------------------
// Local_VerifyNodeType
// Checks first to see if NodeType exists, if not it'll create it
//---------------------------------------------------------------------------
HRESULT Local_VerifyNodeType( const GUID *pGuidSnapin , const GUID *pGuidSnapinNodeTypeToVerify )
{
    OLECHAR szSnapin[ GUIDSIZE ];

    OLECHAR szSnapinNodeType[ GUIDSIZE ];

    HKEY hKey;

    ASSERT_( pGuidSnapin != NULL );

    ASSERT_( pGuidSnapinNodeTypeToVerify != NULL );

    TCHAR tchRegKeyName[ MAX_PATH ];

    if( StringFromGUID2( *pGuidSnapin , szSnapin , GUIDSIZE ) == 0 )
    {
        return E_INVALIDARG;
    }

    if( StringFromGUID2( *pGuidSnapinNodeTypeToVerify , szSnapinNodeType , GUIDSIZE ) == 0 )
    {
        return E_INVALIDARG;
    }

    lstrcpy( tchRegKeyName , tchSnapinRegKey );

    lstrcat( tchRegKeyName , szSnapin );

    lstrcat( tchRegKeyName , _T( "\\NodeTypes\\" ) );

    lstrcat( tchRegKeyName , szSnapinNodeType );

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE , tchRegKeyName , 0 , KEY_READ , &hKey ) != ERROR_SUCCESS )
    {
        // Key does not exist
        // Create the nodetype in snapin and in NodeType

        DWORD disp;

        if( RegCreateKeyEx( HKEY_LOCAL_MACHINE , tchRegKeyName , 0 , NULL , REG_OPTION_NON_VOLATILE , KEY_ALL_ACCESS , NULL , &hKey , &disp ) != ERROR_SUCCESS )
        {
            return E_FAIL;
        }

        RegCloseKey( hKey );

        lstrcpy( tchRegKeyName , tchNodeRegKey );

        lstrcat( tchRegKeyName , szSnapinNodeType );

        if( RegCreateKeyEx( HKEY_LOCAL_MACHINE , tchRegKeyName , 0 , NULL , REG_OPTION_NON_VOLATILE , KEY_ALL_ACCESS , NULL , &hKey , &disp ) != ERROR_SUCCESS )
        {
            return E_FAIL;
        }

    }

    RegCloseKey( hKey );

    return S_OK;
}

//---------------------------------------------------------------------------
// Local_RegisterSnapinExt
// Creates the extension node reg keys
//---------------------------------------------------------------------------
HRESULT Local_RegisterSnapinExt( const GUID *pGuidToRegister , const GUID *pAboutGuid , LPTSTR szNameString , LPTSTR szNameStringIndirect , LPTSTR szProvider , LPTSTR szVersion )
{
    OLECHAR szGuid[ GUIDSIZE ];

    TCHAR tchRegKeyName[ MAX_PATH ];

    HKEY hKey;

    HKEY hSubKey = NULL;

    HRESULT hr = E_FAIL;

    ASSERT_( pGuidToRegister != NULL );
    ASSERT_( pAboutGuid != NULL );
    ASSERT_( szNameString != NULL );
    ASSERT_( szProvider != NULL );
    ASSERT_( szVersion != NULL );

    lstrcpy( tchRegKeyName , tchSnapinRegKey );

    if( StringFromGUID2( *pGuidToRegister , szGuid , GUIDSIZE ) == 0 )
    {
        return E_INVALIDARG;
    }

    lstrcat( tchRegKeyName , szGuid );

    DWORD disp;

    do
    {
        if( RegCreateKeyEx( HKEY_LOCAL_MACHINE , tchRegKeyName , 0 , NULL , REG_OPTION_NON_VOLATILE , KEY_ALL_ACCESS , NULL , &hKey , &disp ) == ERROR_SUCCESS )
        {
            // if the key exist overwrite any and all values

            OLECHAR szAboutGuid[ GUIDSIZE ];

            if( StringFromGUID2( *pAboutGuid , szAboutGuid , GUIDSIZE ) > 0 )
            {
                RegSetValueEx( hKey , L"About" , 0 , REG_SZ , ( LPBYTE )szAboutGuid , sizeof( szAboutGuid ) );
            }

            // these calls should not fail but I'll test for it

            VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKey , L"NameString" , 0 , REG_SZ , ( LPBYTE )szNameString , sizeof( TCHAR ) * ( lstrlen( szNameString ) + 1 ) ) );

            VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKey , L"NameStringIndirect" , 0 , REG_SZ , ( LPBYTE )szNameStringIndirect , sizeof( TCHAR ) * ( lstrlen( szNameStringIndirect ) + 1 ) ) );
            
            VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKey , L"Provider" , 0 , REG_SZ , ( LPBYTE )szProvider , sizeof( TCHAR ) * ( lstrlen( szProvider ) + 1 ) ) );

            VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKey , L"Version" , 0 , REG_SZ , ( LPBYTE )szVersion , sizeof( TCHAR ) * ( lstrlen( szVersion ) + 1 ) ) );

            /*
            lstrcpy( tchRegKeyName , L"NodeTypes\\" );

            lstrcat( tchRegKeyName , szGuid );

            if( RegCreateKeyEx( hKey , tchRegKeyName , 0 , NULL , REG_OPTION_NON_VOLATILE , KEY_ALL_ACCESS , NULL , &hSubKey , &disp ) == ERROR_SUCCESS )
            {
                hr = S_OK;
            }
            */
            hr = S_OK;
        }

    } while( 0 );

    RegCloseKey( hSubKey );

    RegCloseKey( hKey );

    return hr;

}

//---------------------------------------------------------------------------
// Local_RegisterNodeType
// pGuidToExt is the snapin we want to extend
// pGuidNodeType is the node in the snapin we'll register under
// pGuidExtension is us the property sheet extension
//---------------------------------------------------------------------------
HRESULT Local_RegisterNodeType( const GUID *pGuidNodeType , const GUID *pGuidExtension  , LPTSTR szDescription )
{
    OLECHAR szGuidNode[ GUIDSIZE ];

    OLECHAR szGuidExt[ GUIDSIZE ];

    TCHAR tchRegKeyName[ MAX_PATH ];

    HKEY hKey;

    ASSERT_( pGuidNodeType != NULL );
    ASSERT_( pGuidExtension != NULL );
    ASSERT_( szDescription != NULL );

    lstrcpy( tchRegKeyName , tchNodeRegKey );


    if( StringFromGUID2( *pGuidNodeType , szGuidNode , GUIDSIZE ) == 0 )
    {
        return E_INVALIDARG;
    }

    if( StringFromGUID2( *pGuidExtension , szGuidExt , GUIDSIZE ) == 0 )
    {
        return E_INVALIDARG;
    }

    lstrcat( tchRegKeyName , szGuidNode );

    lstrcat( tchRegKeyName , tchExtKey );

    if( RegCreateKey( HKEY_LOCAL_MACHINE , tchRegKeyName , &hKey ) != ERROR_SUCCESS )
    {
        return E_FAIL;
    }

    RegSetValueEx( hKey , szGuidExt , 0 , REG_SZ , ( LPBYTE )szDescription , sizeof( TCHAR ) * ( lstrlen( szDescription ) + 1 ) );

    RegCloseKey( hKey );

    return S_OK;
}

//---------------------------------------------------------------------------
// Delete a key and all of its descendents.
//---------------------------------------------------------------------------
LONG RecursiveDeleteKey( HKEY hKeyParent , LPTSTR lpszKeyChild )
{
    // Open the child.
    HKEY hKeyChild;

    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild , 0 , KEY_ALL_ACCESS, &hKeyChild);

    if (lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    // Enumerate all of the decendents of this child.

    FILETIME time;

    TCHAR szBuffer[256];

    DWORD dwSize = sizeof( szBuffer ) / sizeof( TCHAR );

    while( RegEnumKeyEx( hKeyChild , 0 , szBuffer , &dwSize , NULL , NULL , NULL , &time ) == S_OK )
    {
        // Delete the decendents of this child.

        lRes = RecursiveDeleteKey(hKeyChild, szBuffer);

        if (lRes != ERROR_SUCCESS)
        {
            RegCloseKey(hKeyChild);

            return lRes;
        }

        dwSize = sizeof( szBuffer ) / sizeof( TCHAR );
    }

    // Close the child.

    RegCloseKey( hKeyChild );

    // Delete this child.

    return RegDeleteKey( hKeyParent , lpszKeyChild );
}

//---------------------------------------------------------------------------
// Local_UnRegisterSnapinExt
// reconstruct the enter key then delete key
//---------------------------------------------------------------------------
HRESULT Local_UnRegisterSnapinExt( const GUID *pGuidExt )
{
    TCHAR tchRegKeyName[ MAX_PATH ];

    OLECHAR szGuidExt[ GUIDSIZE ];

    ASSERT_( pGuidExt != NULL );

    lstrcpy( tchRegKeyName , tchSnapinRegKey );

    if( StringFromGUID2( *pGuidExt , szGuidExt , GUIDSIZE ) == 0 )
    {
        return E_INVALIDARG;
    }

    lstrcat( tchRegKeyName , szGuidExt );

    if( RecursiveDeleteKey( HKEY_LOCAL_MACHINE , tchRegKeyName ) == ERROR_SUCCESS )
    {
        return S_OK;
    }

    return S_FALSE;
}

//---------------------------------------------------------------------------
// Local_UnregisterNodeType
//---------------------------------------------------------------------------
HRESULT Local_UnregisterNodeType( const GUID *pGuid , const GUID *pDeleteThisGuid )
{
    OLECHAR szGuid[ GUIDSIZE ];

    OLECHAR szDeleteThisGuid[ GUIDSIZE ];

    HKEY hKey;

    ASSERT_( pGuid != NULL );
    ASSERT_( pDeleteThisGuid != NULL );

    TCHAR tchRegKeyName[ MAX_PATH ];

    lstrcpy( tchRegKeyName , tchNodeRegKey );

    if( StringFromGUID2( *pGuid , szGuid , GUIDSIZE ) == 0 )
    {
        return E_FAIL;
    }

    if( StringFromGUID2( *pDeleteThisGuid , szDeleteThisGuid , GUIDSIZE ) == 0 )
    {
        return E_FAIL;
    }

    lstrcat( tchRegKeyName , szGuid );

    lstrcat( tchRegKeyName , tchExtKey );

    if( RegOpenKey( HKEY_LOCAL_MACHINE , tchRegKeyName , &hKey ) != ERROR_SUCCESS )
    {
        return E_FAIL;
    }

    if( RegDeleteValue( hKey , szDeleteThisGuid ) == ERROR_SUCCESS )
    {
        RegCloseKey( hKey );

        return S_OK;
    }

    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    Local_UnRegisterSnapinExt( &CLSID_TSUserExInterfaces );

    Local_UnregisterNodeType( &NODETYPE_User , &CLSID_TSUserExInterfaces );

    Local_UnregisterNodeType( &NODETYPE_DSUser , &CLSID_TSUserExInterfaces );

    SHDeleteKey(  HKEY_LOCAL_MACHINE,        
		_T("SOFTWARE\\Microsoft\\ADs\\Providers\\LDAP\\Extensions\\User\\{E2E9CAE6-1E7B-4B8E-BABD-E9BF6292AC29}") );

    SHDeleteKey(  HKEY_LOCAL_MACHINE,        
		_T("SOFTWARE\\Microsoft\\ADs\\Providers\\WinNT\\Extensions\\User\\{E2E9CAE6-1E7B-4B8E-BABD-E9BF6292AC29}") );
	


    try
    {

    _Module.UnregisterServer();

    }

    catch( ... )
    {
        ODS( L"TSUSEREX : Exception thrown" );

        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\tsusrsht.h ===
#ifndef _TSUSERSHEET_H
#define _TSUSERSHEET_H

#include <winsta.h>

#define NUM_OF_PAGES 4

class CDialogBase;

#ifdef UNICODE

#define COPYWCHAR2TCHAR( SRC , DEST ) \
            wcscpy( SRC , DEST );
#else

#define COPYWCHAR2TCHAR( SRC , DEST ) \
        { \
           DWORD dwLen; \
           dwLen = wcslen( DEST ); \
           WideCharToMultiByte( CP_ACP , 0 , DEST , dwLen , SRC , dwLen / sizeof( WCHAR ) , 0 , 0 ); \
        }
#endif

#define ALN_APPLY ( WM_USER + 900 )

const ULONG kMilliMinute = 60000;
const ULONG kMaxTimeoutMinute = 71580;

#define E_PARSE_VALUEOVERFLOW   0x80000000
#define E_PARSE_INVALID         0xffffffff
#define E_SUCCESS               0
#define E_PARSE_MISSING_DIGITS  0X7fffffff

enum TOKEN { TOKEN_DAY , TOKEN_HOUR , TOKEN_MINUTE };

//---------------------------------------------------------------------
// Class for managing user manager for Terminal server extensions
//---------------------------------------------------------------------
class CTSUserSheet
{
private:
    LPTSTR m_pstrMachinename;

    LPTSTR m_pstrUsername;

    CDialogBase *m_pDlg[ NUM_OF_PAGES ];

    BOOL m_bDC;             // domain controller

    BOOL m_bIsConfigLoaded;

    BOOL GetUserConfig( PDWORD );

    TCHAR m_szRemoteServerName[ MAX_PATH ];

    BOOL m_bDSAType;	

	PSID m_pUserSid;


public:
    CTSUserSheet();

    ~CTSUserSheet();

    BOOL SetServerAndUser( LPWSTR , LPWSTR );
    BOOL GetServer(PWSTR *);

    HRESULT AddPagesToPropSheet( LPPROPERTYSHEETCALLBACK pProvider );

	HRESULT AddPagesToDSAPropSheet( LPFNADDPROPSHEETPAGE , LPARAM );


    BOOL SetUserConfig( USERCONFIG& , PDWORD );

    USERCONFIG& GetCurrentUserConfig( PDWORD );

    LPTSTR GetUserName( ) { return m_pstrUsername; }

    void SetDSAType( BOOL bT ) { m_bDSAType = bT; }

    BOOL GetDSAType( void ) { return m_bDSAType; }

	void CopyUserSid( PSID );

	PSID GetUserSid( ) { return m_pUserSid; }


    //
    // public data
    //

    USERCONFIG m_userconfig;

    UINT m_cref;
};

//---------------------------------------------------------------------
// CDialogBase - as the name implies base class for all the dialogs
//---------------------------------------------------------------------
class CDialogBase
{
protected:
    BOOL m_bPersisted;

    HWND m_hWnd;

    CTSUserSheet *m_pUSht;

    static UINT CALLBACK PageCallback(HWND hDlg, UINT uMsg, LPPROPSHEETPAGE ppsp);

public:
    virtual BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    virtual BOOL OnDestroy( ){ return TRUE; }

    virtual BOOL GetPropertySheetPage( PROPSHEETPAGE& ){ return FALSE;}

    virtual BOOL PersistSettings( HWND ){ return FALSE;}

    virtual BOOL IsValidSettings( HWND ){ return TRUE;}

    virtual BOOL OnNotify( int , LPNMHDR , HWND );

    virtual BOOL OnContextMenu( HWND , POINT& );

    virtual BOOL OnHelp( HWND , LPHELPINFO );

    CDialogBase( );

    //virtual ~CDialogBase( );
};

//---------------------------------------------------------------------
// Dialog for profile page
//---------------------------------------------------------------------
class CEnviroDlg : public CDialogBase
{
public:
    CEnviroDlg( CTSUserSheet *);

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL PersistSettings( HWND );

    void OnCommand( WORD , WORD , HWND );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );
};

//---------------------------------------------------------------------
// retains object state for the timeout dlg combx
//---------------------------------------------------------------------
typedef struct _cbxstate
{
    int icbxSel;

    BOOL bEdit;

} CBXSTATE;

//---------------------------------------------------------------------
// keeps a list of the time unit abbreviations and full names
// ie: h hr hrs hour hours
//---------------------------------------------------------------------
typedef struct _toktable
{
    LPTSTR pszAbbrv;

    DWORD dwresourceid;

} TOKTABLE, *PTOKTABLE;

//---------------------------------------------------------------------
// Dialog for Timeout settings page
//---------------------------------------------------------------------
class CTimeOutDlg : public CDialogBase
{
    static WNDPROC m_pfWndproc;

    CBXSTATE m_cbxst[ 3 ];

    WORD m_wAction;

    WORD m_wCon;

    TOKTABLE m_tokday[ 4 ];

    TOKTABLE m_tokhour[ 6 ];

    TOKTABLE m_tokmin[ 5 ];

public:

    CTimeOutDlg( CTSUserSheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL PersistSettings( HWND );

    BOOL IsValidSettings( HWND );

    void OnCommand( WORD , WORD , HWND );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL ConvertToMinutes( HWND , PULONG );

    BOOL InsertSortedAndSetCurSel( HWND , DWORD );

    BOOL RestorePreviousValue( HWND );

    BOOL SaveChangedSelection( HWND );

    void OnCBNSELCHANGE( HWND );

    BOOL ConvertToDuration ( ULONG , LPTSTR );

    LRESULT ParseDurationEntry( LPTSTR , PULONG );

    int GetCBXSTATEindex( HWND );

    void OnCBEditChange( HWND );

    BOOL DoesContainDigits( LPTSTR );

    BOOL OnCBDropDown( HWND );

    BOOL IsToken( LPTSTR , TOKEN );

    BOOL LoadAbbreviates( );

    BOOL xxxLoadAbbreviate( PTOKTABLE );

    BOOL xxxUnLoadAbbreviate( PTOKTABLE );

    void InitTokTables( );

};


//---------------------------------------------------------------------
// Dialog for Shadowing settings page
//---------------------------------------------------------------------
class CShadowDlg : public CDialogBase
{
    WORD m_wOldRad;

public:

    CShadowDlg( CTSUserSheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    void OnCommand( WORD , WORD , HWND );

    // BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL PersistSettings( HWND );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );
};


//---------------------------------------------------------------------
// Dialog for profile page
//---------------------------------------------------------------------
class CProfileDlg : public CDialogBase
{
    int m_ncbxOld;

    WORD m_wOldRadio;

    BOOL m_bTSHomeFolderChanged;    

public:

    CProfileDlg( CTSUserSheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    void OnCommand( WORD , WORD , HWND );

    BOOL EnableRemoteHomeDirectory( HWND , BOOL );

    BOOL SetWTSProfilePath( HWND , USERCONFIG& );

    BOOL SetWTSLocalPath( HWND , USERCONFIG& );

    BOOL SetWTSRemotePath( HWND , USERCONFIG& );

    BOOL IsPathValid( LPTSTR , BOOL );

    BOOL PersistSettings( HWND );

    BOOL IsValidSettings( HWND );

    BOOL IsLocalPathValid( HWND );

    BOOL IsRemotePathValid( HWND hDlg );

    void ExpandUserName( LPTSTR );

    BOOL createdir( LPTSTR  , BOOL , PDWORD );
    BOOL CreateSecureDir(LPTSTR szPath ,  PDWORD pdwErr);

    BOOL IsLocalComputer(WCHAR*);

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    HRESULT CreateRemoteFolder(LPCTSTR path);
    BOOL CreateSystemPath(TCHAR* tchPath);
};


#endif //_TSUSERSHEET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsuserex\tsusrsht.cpp ===
//---------------------------------------------------------------------------
// Copyright (c) 1998, Microsoft Corporation
// All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential
//
// Author: alhen
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "tsusrsht.h"
//#include <dsgetdc.h>
#include <icanon.h>
#include <shlwapi.h>

// extern BOOL g_bPagesHaveBeenInvoked;
/*NTSTATUS GetDomainName( PWCHAR ServerNamePtr, // name of server to get domain of
                        LPTSTR DomainNamePtr // alloc and set ptr (free with NetApiBufferFree)
                       );
*/

WNDPROC CTimeOutDlg::m_pfWndproc = 0;

//-------------------------------------------------------------------------------
/*
static TOKTABLE tokday[ 4 ] = {
    { NULL , IDS_D },
    { NULL , IDS_DAY },
    { NULL , IDS_DAYS },
    { NULL , ( DWORD )-1 }
};

static TOKTABLE tokhour[ 6 ] = {
    { NULL , IDS_H     },
    { NULL , IDS_HR    },
    { NULL , IDS_HRS   },
    { NULL , IDS_HOUR  },
    { NULL , IDS_HOURS },
    { NULL , ( DWORD )-1 }
};

static TOKTABLE tokmin[ 5 ] = {
    { NULL , IDS_M       },
    { NULL , IDS_MIN     },
    { NULL , IDS_MINUTE  },
    { NULL , IDS_MINUTES },
    { NULL , ( DWORD )-1 }
};

  */
TCHAR * GetNextToken( TCHAR *pszString , TCHAR *tchToken );

void ErrorMessage1( HWND hParent , DWORD dwStatus );
void ErrorMessage2( HWND hParent , DWORD dwStatus );
void xxErrorMessage( HWND hParent , DWORD dwStatus , UINT );


//-------------------------------------------------------------------------------
// CTUSerDlg::ctor
//-------------------------------------------------------------------------------
CTSUserSheet::CTSUserSheet( )
{
    m_pstrMachinename = NULL;

    m_pstrUsername    = NULL;

    m_cref            = 0;

    m_bIsConfigLoaded = FALSE;

    m_szRemoteServerName[0] = 0;

	m_pUserSid = NULL;

    for( int tt = 0 ; tt < NUM_OF_PAGES ; ++tt )
    {
        m_pDlg[ tt ] = NULL;
    }
}

//-------------------------------------------------------------------------------
// CTUSerDlg::dtor
//-------------------------------------------------------------------------------
CTSUserSheet::~CTSUserSheet()
{
    if( m_pstrMachinename != NULL )
    {
        delete[] m_pstrMachinename;
    }

    if( m_pstrUsername != NULL )
    {
        delete[] m_pstrUsername;
    }

    for( int tt = 0 ; tt < NUM_OF_PAGES ; ++tt )
    {
        if( m_pDlg[ tt ] != NULL )
        {
            delete m_pDlg[ tt ];
        }
    }

	if( m_pUserSid != NULL )
	{
		delete[] m_pUserSid;		
	}

    ODS( TEXT("Main object released!\n") );
}

//ptstrMachineName will be allocated by this routine so it is up 
//to the calling function to delete it. FALSE will be returned
//if the parameter is not allocated
BOOL CTSUserSheet::GetServer(PWSTR *ptstrMachineName)
{
    if (m_pstrMachinename)
    {
        DWORD dwLen = wcslen(m_pstrMachinename);
        *ptstrMachineName = new WCHAR[dwLen + 1];

        if (*ptstrMachineName)
        {
            wcscpy(*ptstrMachineName, m_pstrMachinename);
            return TRUE;
        }
    }

    return FALSE;
}


//-------------------------------------------------------------------------------
// SetServerAndUser
//-------------------------------------------------------------------------------
BOOL CTSUserSheet::SetServerAndUser( LPWSTR pwstrMachineName , LPWSTR pwstrUserName )
{
    if( pwstrMachineName != NULL && pwstrUserName != NULL )
    {
        KdPrint( ("TSUSEREX : SystemName %ws UserName %ws\n",pwstrMachineName,pwstrUserName) );

        DWORD dwLen = wcslen( pwstrMachineName );

        m_pstrMachinename = ( LPTSTR )new TCHAR [ dwLen + 1 ];

        if( m_pstrMachinename != NULL )
        {
            COPYWCHAR2TCHAR( m_pstrMachinename , pwstrMachineName );
        }

        dwLen = wcslen( pwstrUserName );

        m_pstrUsername = ( LPTSTR )new TCHAR[ dwLen + 1 ];

        if( m_pstrUsername != NULL )
        {
            COPYWCHAR2TCHAR( m_pstrUsername , pwstrUserName );
        }

        return TRUE;
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// AddPagesToPropSheet
//-------------------------------------------------------------------------------
HRESULT CTSUserSheet::AddPagesToPropSheet( LPPROPERTYSHEETCALLBACK pProvider )
{
    PROPSHEETPAGE psp;

    //
    // List of objects goes here
    //

    m_pDlg[0] = new CEnviroDlg( this );

    m_pDlg[1] = new CTimeOutDlg( this );

    m_pDlg[2] = new CShadowDlg( this );

    m_pDlg[3] = new CProfileDlg( this );

    //
    // Let each object initialize there own propsheet
    //

    for( int idx = 0; idx < NUM_OF_PAGES; ++idx )
    {
        if( m_pDlg[ idx ] != NULL )
        {
            if( !m_pDlg[ idx ]->GetPropertySheetPage( psp ) )
            {
                continue;
            }

            if( FAILED( pProvider->AddPage( CreatePropertySheetPage( &psp ) ) ) )
            {
                return E_FAIL;
            }

        }

    }

    return S_OK;
}

//-------------------------------------------------------------------------------
// AddPagesToDSAPropSheet
//-------------------------------------------------------------------------------
HRESULT CTSUserSheet::AddPagesToDSAPropSheet( LPFNADDPROPSHEETPAGE lpfnAddPage , LPARAM lp )
{
	PROPSHEETPAGE psp;

    //
    // List of objects goes here
    //

    m_pDlg[0] = new CEnviroDlg( this );

    m_pDlg[1] = new CTimeOutDlg( this );

    m_pDlg[2] = new CShadowDlg( this );

    m_pDlg[3] = new CProfileDlg( this );

    //
    // Let each object initialize there own propsheet
    //

    for( int idx = 0; idx < NUM_OF_PAGES; ++idx )
    {
        if( m_pDlg[ idx ] != NULL )
        {
            if( !m_pDlg[ idx ]->GetPropertySheetPage( psp ) )
            {
                continue;
            }

            lpfnAddPage( CreatePropertySheetPage( &psp ) , lp );
        }

    }

    return S_OK;
}

//-------------------------------------------------------------------------------
// SetUserConfig
//-------------------------------------------------------------------------------
BOOL CTSUserSheet::SetUserConfig( USERCONFIG& uc , PDWORD pdwStatus )
{
    ASSERT_( pdwStatus != NULL );

    if( IsBadReadPtr( &uc , sizeof( USERCONFIG ) ) )
    {
        return FALSE;
    }

    //
    //
    // mov         esi,dword ptr [uc]
    // mov         edi,dword ptr [this]
    // add         edi,1Ch
    // mov         ecx,27Ah
    // rep movs    dword ptr es:[edi],dword ptr [esi]
    //
    // is the codegen for struct = struct
    //
    m_userconfig = uc;

#if BETA_3

    TCHAR tchServerName[ MAX_PATH ];

    if( m_bDC )
    {
        ODS( L"TSUSEREX - Saving settings on remote or local-dc system\n" );

        lstrcpy( tchServerName , m_szRemoteServerName );
    }
    else
    {
        lstrcpy( tchServerName , m_pstrMachinename );
    }

#endif // BETA_3

    if( ( *pdwStatus = RegUserConfigSet( m_pstrMachinename , m_pstrUsername ,  &m_userconfig , sizeof( USERCONFIG ) ) ) == ERROR_SUCCESS )
    {
        return TRUE;
    }

    return FALSE;

}

//-------------------------------------------------------------------------------
// GetCurrentUserConfig
//-------------------------------------------------------------------------------
USERCONFIG& CTSUserSheet::GetCurrentUserConfig( PDWORD pdwStatus )
{
    *pdwStatus = ERROR_SUCCESS;

    if( !m_bIsConfigLoaded )
    {
        m_bIsConfigLoaded = GetUserConfig( pdwStatus );
    }

    // ASSERT_( m_bIsConfigLoaded );

    return m_userconfig;
}

//-------------------------------------------------------------------------------
// GetUserConfig
//-------------------------------------------------------------------------------
BOOL CTSUserSheet::GetUserConfig( PDWORD pdwStatus )
{
    ASSERT_( pdwStatus != NULL );
    //
    // This should only be called once
    //

    DWORD cbWritten = 0;

#if BETA_3

    PSERVER_INFO_101 psinfo;

    // check to see if we're trying to administer a local system that happens to be a dc

    *pdwStatus = NetServerGetInfo( NULL , 101 , ( LPBYTE * )&psinfo );

    KdPrint( ("TSUSEREX : NetServerGetInfo returned 0x%x\n",*pdwStatus ) );

    KdPrint( ("TSUSEREX : LastError was 0x%x\n",GetLastError( ) ) );

    if( *pdwStatus == NERR_Success )
    {
        // used to avoid access violation

        if( psinfo != NULL )
        {
            KdPrint( ("TSUSEREX : PSERVER_INFO_101 returned 0x%x\n",psinfo->sv101_type ) );

            m_bDC = ( BOOL )( psinfo->sv101_type & ( SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL ) );

            if( m_bDC )
            {
                // get the domaincontroller name of the remote machine

                DOMAIN_CONTROLLER_INFO *pdinfo;

                // m_pstrMachinename is really the domain name.  This was obtain
                // from LookUpAccountSid in interfaces.cpp

                *pdwStatus = DsGetDcName( NULL , m_pstrMachinename , NULL , NULL , DS_PDC_REQUIRED , &pdinfo );

                KdPrint( ( "TSUSEREX : DsGetDcName: %ws returned 0x%x\n", pdinfo->DomainControllerName , *pdwStatus ) );

                if( *pdwStatus == NO_ERROR )
                {
                    lstrcpy( m_szRemoteServerName , pdinfo->DomainControllerName );

                    NetApiBufferFree( pdinfo );
                }
                else
                {
                    m_szRemoteServerName[0] = 0;
                }

            }

            // not documented in the docs but NetServerGetInfo leaves it up to the caller to free up this blob

            NetApiBufferFree( psinfo );

        }

        TCHAR tchServerName[ MAX_PATH ];

        if( m_bDC )
        {
            lstrcpy( tchServerName , m_szRemoteServerName );
        }
        else
        {
            lstrcpy( tchServerName , m_pstrMachinename );
        }



        if( ( *pdwStatus = ( DWORD )RegUserConfigQuery( tchServerName , m_pstrUsername , &m_userconfig , sizeof( USERCONFIG ) , &cbWritten ) ) == ERROR_SUCCESS )
        {
            return TRUE;
        }

    }

#endif // BETA_3

    if( ( *pdwStatus = ( DWORD )RegUserConfigQuery( m_pstrMachinename , m_pstrUsername , &m_userconfig , sizeof( USERCONFIG ) , &cbWritten ) ) == ERROR_SUCCESS )
    {
        return TRUE;
    }


    ODS( L"TSUSEREX: We're getting default properties\n" );

    RegDefaultUserConfigQuery( m_pstrMachinename , &m_userconfig , sizeof( USERCONFIG ) , &cbWritten );

    return FALSE;
}

void CTSUserSheet::CopyUserSid( PSID psid )
{
	if( !IsValidSid( psid ) )
	{
		ODS( L"TSUSEREX : CTSUserSheet::CopyUserSid invalid arg\n" ) ;

		return;
	}

	m_pUserSid = psid;

}


//----------------------------------------------------------
// This provides reference counting for the dialog boxes
// and destroys the sheet (thus destroying the dialog boxes)
// when the ref count reaches 0
//----------------------------------------------------------
UINT CALLBACK CDialogBase::PageCallback(HWND hDlg, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    if (!ppsp)
        return FALSE;

    // We need to recover a pointer to the current instance.  We can't just use
    // "this" because we are in a static function
    CDialogBase* pMe = reinterpret_cast<CDialogBase*>(ppsp->lParam);
    if (!pMe)
        return FALSE;

    if (uMsg == 0)
        ++(pMe->m_pUSht->m_cref);

    if (uMsg == PSPCB_RELEASE)
    {
        if( --(pMe->m_pUSht->m_cref) == 0 )
            delete (pMe->m_pUSht);
    }

    return TRUE;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

//-------------------------------------------------------------------------------
// Base class initi
//-------------------------------------------------------------------------------
CDialogBase::CDialogBase( )
{
     m_hWnd = NULL;
}

//-------------------------------------------------------------------------------
// Base initialization
//-------------------------------------------------------------------------------
BOOL CDialogBase::OnInitDialog( HWND hwnd , WPARAM , LPARAM )
{
    m_hWnd = hwnd;

    return FALSE;
}

//-------------------------------------------------------------------------------
// OnNotify - base class method
//-------------------------------------------------------------------------------
BOOL CDialogBase::OnNotify( int , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_APPLY )
    {
        if( !m_bPersisted )
        {
            m_bPersisted = PersistSettings( hDlg );
        }
    }

    else if( pnmh->code == PSN_KILLACTIVE )
    {
        if( !m_bPersisted )
        {
            if( !IsValidSettings( hDlg ) )
            {
                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , PSNRET_INVALID_NOCHANGEPAGE );

                return TRUE;
            }

        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// OnCOntextMenu -- base class operation
//-------------------------------------------------------------------------------
BOOL CDialogBase::OnContextMenu( HWND hwnd , POINT& )
{
    TCHAR tchHelpFile[ MAX_PATH ];

    if( m_hWnd == GetParent( hwnd ) )
    {
        //
        // Make sure its not a dummy window
        //

        if( GetDlgCtrlID( hwnd ) <= ( int )-1 )
        {
            return FALSE;
        }

        DWORD rgdw[ 2 ];

        rgdw[ 0 ] = GetDlgCtrlID( hwnd );

        rgdw[ 1 ] = GetWindowContextHelpId( hwnd );

        LoadString( _Module.GetModuleInstance( ) , IDS_HELPFILE , tchHelpFile , sizeof( tchHelpFile ) / sizeof( TCHAR ) );

        WinHelp( hwnd , tchHelpFile , HELP_CONTEXTMENU , (ULONG_PTR)&rgdw );

    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// Each control has a helpid assign to them.  Some controls share the same topic
// check for these.
//-------------------------------------------------------------------------------
BOOL CDialogBase::OnHelp( HWND hwnd , LPHELPINFO lphi )
{
    TCHAR tchHelpFile[ MAX_PATH ];

    //
    // For the information to winhelp api
    //

    if( IsBadReadPtr( lphi , sizeof( HELPINFO ) ) )
    {
        return FALSE;
    }

    if( (short)lphi->iCtrlId <= -1 )
    {
        return FALSE;
    }

    LoadString( _Module.GetModuleInstance( ) , IDS_HELPFILE , tchHelpFile , sizeof( tchHelpFile ) / sizeof( TCHAR ) );

    WinHelp( hwnd , tchHelpFile , HELP_CONTEXTPOPUP , lphi->dwContextId );

    return TRUE;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

//-------------------------------------------------------------------------------
// CEnviroDlg::ctor
//-------------------------------------------------------------------------------
CEnviroDlg::CEnviroDlg( CTSUserSheet *pUSht )
{
    m_pUSht = pUSht;
}

//-------------------------------------------------------------------------------
// InitDialog for ProfileDlg
//-------------------------------------------------------------------------------
BOOL CEnviroDlg::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht ,sizeof(  CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    // This means any true problems from obtaining user info from the sam
    // will disable this dialog

    if( dwStatus != ERROR_FILE_NOT_FOUND && dwStatus != ERROR_SUCCESS )
    {
        INT nId[ ] = {
                        IDC_CHECK_USEDEFAULT,
                        IDC_EDIT_CMDLINE,
                        IDC_EDIT_WDIR,
                        IDC_CHECK_CCDL,
                        IDC_CHECK_CCPL,
                        IDC_CHECK_DMCP,
                        -1
        };

        for( int idx = 0; nId[ idx ] != -1 ; ++idx )
        {
            EnableWindow( GetDlgItem( hwnd , nId[ idx ] ) , FALSE );
        }

        ErrorMessage1( hwnd , dwStatus );

        return FALSE;
    }

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_CMDLINE  ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_WDIR  ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );

    //
    // Set controls to default status
    //

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_USEDEFAULT ) , BM_SETCHECK , !( WPARAM )uc.fInheritInitialProgram , 0 );

    SetWindowText( GetDlgItem( hwnd , IDC_EDIT_WDIR ) , uc.WorkDirectory );

    SetWindowText( GetDlgItem( hwnd , IDC_EDIT_CMDLINE ) , uc.InitialProgram ) ;

    EnableWindow( GetDlgItem( hwnd , IDC_EDIT_WDIR ) , !uc.fInheritInitialProgram );

    EnableWindow( GetDlgItem( hwnd , IDC_EDIT_CMDLINE ) , !uc.fInheritInitialProgram );

    EnableWindow( GetDlgItem( hwnd , IDC_STATIC_WD ) , !uc.fInheritInitialProgram );

    EnableWindow( GetDlgItem( hwnd , IDC_STATIC_CMD ) , !uc.fInheritInitialProgram );

    //
    // The controls are initially enabled - - resetting them is done
    // via WM_COMMAND
    //

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_CCDL ) , BM_SETCHECK , ( WPARAM )uc.fAutoClientDrives , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_CCPL ) , BM_SETCHECK , ( WPARAM )uc.fAutoClientLpts , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_DMCP ) , BM_SETCHECK , ( WPARAM )uc.fForceClientLptDef , 0 );

    m_bPersisted = TRUE;

    return CDialogBase::OnInitDialog( hwnd , wp , lp );
}

//-------------------------------------------------------------------------------
// Environment Dialog Page
// -- static methods lacks this ptr
//-------------------------------------------------------------------------------
INT_PTR CALLBACK CEnviroDlg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CEnviroDlg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CEnviroDlg *pDlg = ( CEnviroDlg * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CEnviroDlg ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CEnviroDlg * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CEnviroDlg ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_RBUTTONUP:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            HWND hChild = ChildWindowFromPoint( hwnd , pt );

            ClientToScreen( hwnd , &pt );

            pDlg->OnContextMenu( hChild , pt );
        }

        break;

     case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

    }

    return 0;
}

//-------------------------------------------------------------------------------
// Basic control notification handler
//-------------------------------------------------------------------------------
void CEnviroDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtl )
{
    switch( wNotifyCode )
    {

    case BN_CLICKED:

        if( wID == IDC_CHECK_USEDEFAULT )
        {
            //
            // Remember if its checked we want to disable the options
            //
            HWND hwnd = GetParent( hwndCtl );

            BOOL bChecked = SendMessage( hwndCtl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

            EnableWindow( GetDlgItem( hwnd , IDC_EDIT_WDIR ) , bChecked );

            EnableWindow( GetDlgItem( hwnd , IDC_EDIT_CMDLINE ) , bChecked );

            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_WD ) , bChecked );

            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_CMD ) , bChecked );

        }   // FALL THROUGH !!!!

    case EN_CHANGE:

        m_bPersisted = FALSE;

        break;

    case ALN_APPLY:

        //This is being removed for consinstency with the rest of MMC dialogs, even though it would
        //make more sense to the user for Cancel to be disabled after applying the changes, since
        //cancellation is not a real option at that point.
        //SendMessage( GetParent( hwndCtl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        break;
    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
    }

}

//-------------------------------------------------------------------------------
// OnDestroy
//-------------------------------------------------------------------------------
BOOL CEnviroDlg::OnDestroy( )
{
    return CDialogBase::OnDestroy( );
}

//-------------------------------------------------------------------------------
// GetPropertySheetPage - each dialog object should be responsible for its own data
//-------------------------------------------------------------------------------
BOOL CEnviroDlg::GetPropertySheetPage( PROPSHEETPAGE &psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;

    psp.hInstance   = _Module.GetModuleInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_PAGE_ENVIRO );

    psp.lParam      = (LPARAM)this;

    psp.pfnCallback = CDialogBase::PageCallback;

    psp.pfnDlgProc  = CEnviroDlg::DlgProc;

    return TRUE;
}


//-------------------------------------------------------------------------------
// PersistSettings
//-------------------------------------------------------------------------------
BOOL CEnviroDlg::PersistSettings( HWND hDlg )
{
    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    TCHAR tchBuffer[ DIRECTORY_LENGTH + 1 ];

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    //
    // if use default is checked -- lets flag it and move on to client devices
    //

    //
    // if the chkbx is unchecked we inherit from client side settings
    //

    uc.fInheritInitialProgram = SendMessage( GetDlgItem( hDlg , IDC_CHECK_USEDEFAULT ) , BM_GETCHECK ,
        0 , 0 ) == BST_CHECKED ? FALSE : TRUE;

    if( !uc.fInheritInitialProgram )
    {
        //
        // Read buffer and commit to USERCONFIG buffer
        //

        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_WDIR ) , &tchBuffer[ 0 ] , sizeof( tchBuffer ) / sizeof( TCHAR ) );

        lstrcpy( uc.WorkDirectory , tchBuffer );

        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_CMDLINE ) , &tchBuffer[ 0 ] , sizeof( tchBuffer ) / sizeof( TCHAR ) );

        lstrcpy( uc.InitialProgram , tchBuffer );
    }
    else
    {
        lstrcpy(uc.WorkDirectory, L"");
        lstrcpy(uc.InitialProgram, L"");
    }

    uc.fAutoClientDrives  = SendMessage( GetDlgItem( hDlg , IDC_CHECK_CCDL ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

    uc.fAutoClientLpts    = SendMessage( GetDlgItem( hDlg , IDC_CHECK_CCPL ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

    uc.fForceClientLptDef = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DMCP ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

    if( !m_pUSht->SetUserConfig( uc , &dwStatus ) )
    {
        ErrorMessage2( hDlg , dwStatus );

        return TRUE;
    }


    PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY ) , ( LPARAM )hDlg );

    SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

    return TRUE;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

DWORD rgdwTime[] = { 0 , 1 , 5 , 10 , 15 , 30 , 60 , 120 , 180 , 1440 , 2880 , ( DWORD )-1 };

//-------------------------------------------------------------------------------
// CTimeOutDlg::ctor
//-------------------------------------------------------------------------------
CTimeOutDlg::CTimeOutDlg( CTSUserSheet *pUSht )
{
    m_pUSht = pUSht;

    ZeroMemory( &m_cbxst , sizeof( CBXSTATE ) * 3 );

    m_wAction = ( WORD)-1;

    m_wCon = ( WORD )-1;

    ZeroMemory( &m_tokday , sizeof( TOKTABLE ) * 4  );

    ZeroMemory( &m_tokhour , sizeof( TOKTABLE ) * 6 );

    ZeroMemory( &m_tokmin , sizeof( TOKTABLE ) * 5 );
}

//-------------------------------------------------------------------------------
void CTimeOutDlg::InitTokTables( )
{
    TOKTABLE tday[4] = { { NULL , IDS_D },
                         { NULL , IDS_DAY },
                         { NULL , IDS_DAYS },
                         { NULL , ( DWORD )-1 }
                       };

    TOKTABLE thour[ 6 ] = {
                            { NULL , IDS_H     },
                            { NULL , IDS_HR    },
                            { NULL , IDS_HRS   },
                            { NULL , IDS_HOUR  },
                            { NULL , IDS_HOURS },
                            { NULL , ( DWORD )-1 }
                          };

    TOKTABLE tmin[ 5 ] = {
                            { NULL , IDS_M       },
                            { NULL , IDS_MIN     },
                            { NULL , IDS_MINUTE  },
                            { NULL , IDS_MINUTES },
                            { NULL , ( DWORD )-1 }
                         };

    CopyMemory( &m_tokday[0] , &tday[0] , sizeof( TOKTABLE )  * 4 );
    CopyMemory( &m_tokhour[0] , &thour[0] , sizeof( TOKTABLE )  * 6 );
    CopyMemory( &m_tokmin[0] , &tmin[0] , sizeof( TOKTABLE )  * 5 );


}
//-------------------------------------------------------------------------------
// InitDialog for TimeOutDlg
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    TCHAR tchBuffer[ 80 ];

    DWORD dwStatus;

    USERCONFIG uc;

    if( IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        return FALSE;
    }

    InitTokTables( );

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    if( dwStatus != ERROR_FILE_NOT_FOUND && dwStatus != ERROR_SUCCESS )
    {
        INT nId[ ] = {
                        IDC_COMBO_CONNECT,
                        IDC_COMBO_DISCON,
                        IDC_COMBO_IDLE,
                        IDC_RADIO_RESET,
                        IDC_RADIO_DISCON,
                        IDC_RADIO_PREVCLIENT,
                        IDC_RADIO_ANYCLIENT,
                        -1
        };

        for( int idx = 0; nId[ idx ] != -1 ; ++idx )
        {
            EnableWindow( GetDlgItem( hwnd , nId[ idx ] ) , FALSE );
        }

        ErrorMessage1( hwnd , dwStatus );

        return FALSE;
    }
    //
    // First thing is to set the default values for all the controls
    //

    HWND hCombo[ 3 ] =
    {

        GetDlgItem( hwnd , IDC_COMBO_CONNECT ),

        GetDlgItem( hwnd , IDC_COMBO_DISCON ),

        GetDlgItem( hwnd , IDC_COMBO_IDLE )
    };


    for( int idx = 0; rgdwTime[ idx ] != ( DWORD)-1; ++idx )
    {
        if( rgdwTime[ idx ] == 0 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchBuffer , sizeof( tchBuffer ) / sizeof( TCHAR ) );
        }
        else
        {
            ConvertToDuration( rgdwTime[ idx ] , tchBuffer );
        }

        for( int inner = 0 ; inner < 3 ; ++inner )
        {
            SendMessage( hCombo[ inner ] , CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );

            SendMessage( hCombo[ inner ] , CB_SETITEMDATA , idx , rgdwTime[ idx ] );
        }
    }

    ULONG ulTime;

    if( uc.MaxConnectionTime > 0 )
    {
        ulTime = uc.MaxConnectionTime / kMilliMinute;

        // hCombo[ 0 ] == IDC_COMBO_CONNECT

        InsertSortedAndSetCurSel( hCombo[ 0 ] , ulTime );

    }
    else
    {
        SendMessage( hCombo[ 0 ] , CB_SETCURSEL , 0 , 0 );
    }

    //
    // Set the current or default disconnection timeout
    //

    if( uc.MaxDisconnectionTime > 0 )
    {
        ulTime = uc.MaxDisconnectionTime / kMilliMinute;

        // hCombo[ 1 ] == IDC_COMBO_DISCON

        InsertSortedAndSetCurSel( hCombo[ 1 ] , ulTime );

    }
    else
    {
        SendMessage( hCombo[ 1] , CB_SETCURSEL , 0 , 0 );
    }

    //
    // Set the current or default idle timeout
    //

    if( uc.MaxIdleTime > 0 )
    {
        ulTime = uc.MaxIdleTime / kMilliMinute;

        // hCombo[ 2 ] == IDC_COMBO_IDLE

        InsertSortedAndSetCurSel( hCombo[ 2 ] , ulTime );

    }
    else
    {
        SendMessage( hCombo[ 2 ] , CB_SETCURSEL , 0 , 0 );
    }

    //
    // Set remaining controls to current settings
    //

    if( uc.fResetBroken )
    {
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_RESET ) , BM_CLICK , 0 , 0 );

        m_wAction = IDC_RADIO_RESET;
    }
    else
    {
       SendMessage( GetDlgItem( hwnd , IDC_RADIO_DISCON ) , BM_CLICK , 0 , 0 );

       m_wAction = IDC_RADIO_DISCON;
    }

    if( uc.fReconnectSame )
    {
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_PREVCLIENT ) , BM_CLICK , 0 ,0 );

        m_wCon = IDC_RADIO_PREVCLIENT;
    }
    else
    {
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_ANYCLIENT ) , BM_CLICK , 0 , 0 );

        m_wCon = IDC_RADIO_ANYCLIENT;

    }

    LoadAbbreviates( );

    m_bPersisted = TRUE;

    return CDialogBase::OnInitDialog( hwnd , wp , lp );

}

//-------------------------------------------------------------------------------
// TimeOutDlg Dialog Page
// -- static methods lacks this ptr
//-------------------------------------------------------------------------------
INT_PTR CALLBACK CTimeOutDlg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CTimeOutDlg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CTimeOutDlg *pDlg = ( CTimeOutDlg * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CTimeOutDlg ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CTimeOutDlg * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CTimeOutDlg ) ) )
        {
            return FALSE;
        }
    }


    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_RBUTTONUP:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            HWND hChild = ChildWindowFromPoint( hwnd , pt );

            ClientToScreen( hwnd , &pt );

            pDlg->OnContextMenu( hChild , pt );
        }

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }
    }

    return 0;
}

BOOL CTimeOutDlg::OnDestroy( )
{
    xxxUnLoadAbbreviate( &m_tokday[0] );

    xxxUnLoadAbbreviate( &m_tokhour[0] );

    xxxUnLoadAbbreviate( &m_tokmin[0] );

    return CDialogBase::OnDestroy( );
}

//-------------------------------------------------------------------------------
// GetPropertySheetPage - each dialog object should be responsible for its own data
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::GetPropertySheetPage( PROPSHEETPAGE &psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;

    psp.hInstance   = _Module.GetModuleInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_PAGE_TIMEOUTS );

    psp.lParam      = (LPARAM)this;

    psp.pfnCallback = CDialogBase::PageCallback;

    psp.pfnDlgProc  = CTimeOutDlg::DlgProc;

    return TRUE;
}

//-------------------------------------------------------------------------------
// OnCommand
//-------------------------------------------------------------------------------
void CTimeOutDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtl )
{
    switch( wNotifyCode )
    {

    case CBN_EDITCHANGE:

        OnCBEditChange( hwndCtl );

        m_bPersisted = FALSE;

        break;

    case CBN_SELCHANGE:

        if( SendMessage( hwndCtl , CB_GETDROPPEDSTATE , 0 ,0  ) == TRUE )
        {
            return;
        }

        OnCBNSELCHANGE( hwndCtl );    // FALLTHROUGH

//        m_bPersisted = FALSE;

        break;

    case BN_CLICKED:

        if( wID == IDC_RADIO_DISCON || wID == IDC_RADIO_RESET )
        {
            if( m_wAction != wID )
            {
                m_wAction = wID;

                m_bPersisted = FALSE;
            }
        }
        else if( wID == IDC_RADIO_PREVCLIENT || wID == IDC_RADIO_ANYCLIENT )
        {
            if( m_wCon != wID )
            {
                m_wCon = wID;

                m_bPersisted = FALSE;
            }
        }



        break;

    //case CBN_DROPDOWN:               // FALLTHROUGH

    case CBN_KILLFOCUS:

        ODS( L"CBN_KILLFOCUS\n");

        if( !OnCBDropDown( hwndCtl ) )
        {
            return;
        }

        m_bPersisted = FALSE;

        break;

    case ALN_APPLY:

        //This is being removed for consinstency with the rest of MMC dialogs, even though it would
        //make more sense to the user for Cancel to be disabled after applying the changes, since
        //cancellation is not a real option at that point.
        //SendMessage( GetParent( hwndCtl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return;

    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
    }

}

//-------------------------------------------------------------------------------
// Update the entry if it has been modified by user
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnCBDropDown( HWND hCombo )
{
    TCHAR tchBuffer[ 80 ];

    ULONG ulTime = 0;

    int i = GetCBXSTATEindex( hCombo );

    if( i < 0 )
    {
        return FALSE;
    }

    if( m_cbxst[ i ].bEdit )
    {
        GetWindowText( hCombo , tchBuffer , sizeof( tchBuffer ) / sizeof( TCHAR ) );

        if( ParseDurationEntry( tchBuffer , &ulTime ) == E_SUCCESS )
        {
            InsertSortedAndSetCurSel( hCombo , ulTime );
        }
    }

    return m_cbxst[ i ].bEdit;

}
//-------------------------------------------------------------------------------
// Use this flag to distinguish between hand entry or listbox selection
// setting it to true implies that the use has edit the cbx via typing
//-------------------------------------------------------------------------------
void CTimeOutDlg::OnCBEditChange( HWND hCombo )
{
    int i = GetCBXSTATEindex( hCombo );

    if( i > -1 )
    {
        m_cbxst[ i ].bEdit = TRUE;
    }
}

//-------------------------------------------------------------------------------
// Determine if user wants to enter a custom time
//-------------------------------------------------------------------------------
void CTimeOutDlg::OnCBNSELCHANGE( HWND hwnd )
{
    if( SaveChangedSelection( hwnd ) )
    {
        m_bPersisted = FALSE;
    }
}

//-------------------------------------------------------------------------------
// Saves selected item.
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::SaveChangedSelection( HWND hCombo )
{
    LRESULT idx = SendMessage( hCombo , CB_GETCURSEL , 0 , 0 );

    int i = GetCBXSTATEindex( hCombo );

    if( i > -1 )
    {
        if( idx != ( LRESULT )m_cbxst[ i ].icbxSel )
        {
            m_cbxst[ i ].icbxSel = (int)idx;

            m_cbxst[ i ].bEdit = FALSE;

            return TRUE;
        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// Restore previous setting
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::RestorePreviousValue( HWND hwnd )
{
    int iSel;

    if( ( iSel = GetCBXSTATEindex( hwnd ) ) > -1 )
    {
        SendMessage( hwnd , CB_SETCURSEL , m_cbxst[ iSel ].icbxSel , 0 );

        return TRUE;
    }

    return FALSE;
}
//-------------------------------------------------------------------------------
// returns the indx in m_cbxst of which hcombo is assoc. with
//-------------------------------------------------------------------------------
int CTimeOutDlg::GetCBXSTATEindex( HWND hCombo )
{
    int idx = -1;

    switch( GetDlgCtrlID( hCombo ) )
    {
    case IDC_COMBO_CONNECT:

        idx = 0;

        break;

    case IDC_COMBO_DISCON:

        idx = 1;

        break;

    case IDC_COMBO_IDLE:

        idx = 2;

        break;
    }

    return idx;
}

//-------------------------------------------------------------------------------
// ConvertToMinutes -- helper for CTimeOutDlg::OnNotify
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ConvertToMinutes( HWND hwndCtl , PULONG pulMinutes )
{
    TCHAR tchBuffer[ 80 ];

    TCHAR tchErrTitle[ 80 ];

    TCHAR tchErrMsg[ 256 ];

    TCHAR tchErrItem[ 80 ];

    TCHAR tchErrTot[ 336 ];

    int nComboResID[] = { IDS_COMBO_CONNECTION , IDS_COMBO_DISCONNECTION , IDS_COMBO_IDLECONNECTION };

    int idx = GetCBXSTATEindex( hwndCtl );

    if( idx < 0 )
    {
        return FALSE;
    }

    LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , sizeof( tchErrTitle ) / sizeof( TCHAR ) );

    if( m_cbxst[ idx ].bEdit )
    {
        ODS( TEXT( "Manual Entry parsing\n") );

        if( GetWindowText( hwndCtl , tchBuffer , sizeof( tchBuffer ) / sizeof( TCHAR ) ) < 1 )
        {
            *pulMinutes = 0;

            return TRUE;
        }

        LRESULT lr = ParseDurationEntry( tchBuffer , pulMinutes );

        if( lr != E_SUCCESS )
        {
            LoadString( _Module.GetResourceInstance( ) , nComboResID[ idx ] , tchErrItem , sizeof( tchErrItem ) / sizeof( TCHAR ) );

            if( lr == E_PARSE_VALUEOVERFLOW )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TOOMANYDIGITS , tchErrMsg , sizeof( tchErrMsg ) / sizeof( TCHAR ) );

                wsprintf( tchErrTot , tchErrMsg , tchErrItem );

                MessageBox( hwndCtl , tchErrTot , tchErrTitle , MB_OK | MB_ICONERROR );

                SetFocus( hwndCtl );
            }
            else if( lr == E_PARSE_MISSING_DIGITS || lr == E_PARSE_INVALID )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_PARSEINVALID , tchErrMsg , sizeof( tchErrMsg ) / sizeof( TCHAR ) );

                wsprintf( tchErrTot , tchErrMsg , tchErrItem );

                MessageBox( hwndCtl , tchErrTot , tchErrTitle , MB_OK | MB_ICONERROR );

                SetFocus( hwndCtl );
            }
            return FALSE;
        }
    }
    else
    {
        ODS( L"Getting current selection\n" );

        LONG_PTR iCurSel = SendMessage( hwndCtl , CB_GETCURSEL , 0 , 0 );
        LONG_PTR lData;

        // See if user wants "No Timeout"

        if( iCurSel == 0 )
        {
            *pulMinutes = 0;

           return TRUE;
        }

        if( ( lData = SendMessage( hwndCtl , CB_GETITEMDATA , iCurSel , 0 ) ) == CB_ERR  )
        {
            *pulMinutes = 0;
        } else {

            *pulMinutes = (ULONG)lData;
        }
    }

    if( *pulMinutes > kMaxTimeoutMinute )
    {
        LoadString( _Module.GetResourceInstance( ) , nComboResID[ idx ] , tchErrItem , sizeof( tchErrItem ) / sizeof( TCHAR ) );

        LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_MAXVALEXCEEDED , tchErrMsg , sizeof( tchErrMsg ) / sizeof( TCHAR ) );

        wsprintf( tchErrTot , tchErrMsg , tchErrItem );

        MessageBox( hwndCtl , tchErrTot , tchErrTitle , MB_OK | MB_ICONERROR );

        SetFocus( hwndCtl );

        return FALSE;
    }

    *pulMinutes *= kMilliMinute;

    return TRUE;
}


//-------------------------------------------------------------------------------
// PersistSettings
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::PersistSettings( HWND hDlg )
{
    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_CONNECT ) , &uc.MaxConnectionTime ) )
    {
        return FALSE;
    }

    if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_DISCON ) , &uc.MaxDisconnectionTime ) )
    {
        return FALSE;
    }

    if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_IDLE ) , &uc.MaxIdleTime ) )
    {
        return FALSE;
    }   

    uc.fResetBroken = SendMessage( GetDlgItem( hDlg , IDC_RADIO_RESET ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

    uc.fReconnectSame = SendMessage( GetDlgItem( hDlg , IDC_RADIO_PREVCLIENT ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

    if( !m_pUSht->SetUserConfig( uc , &dwStatus ) )
    {
        ErrorMessage2( hDlg , dwStatus );

        return TRUE;
    }

    PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

    SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

    return TRUE;

}

//-------------------------------------------------------------------------------
// Making sure the user has entered valid info
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::IsValidSettings( HWND hDlg )
{
    DWORD dwDummy;

    if( IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    uc = m_pUSht->GetCurrentUserConfig( &dwDummy );

    if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_CONNECT ) , &uc.MaxConnectionTime ) )
    {
        return FALSE;
    }

    if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_DISCON ) , &uc.MaxDisconnectionTime ) )
    {
        return FALSE;
    }

    if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_IDLE ) , &uc.MaxIdleTime ) )
    {
        return FALSE;
    }

    return TRUE;
}

#if 0
//-------------------------------------------------------------------------------
// Lets cut to the chase and find out if this is even worth parsing
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::DoesContainDigits( LPTSTR pszString )
{
    while( *pszString )
    {
        if( iswdigit( *pszString ) )
        {
            return TRUE;
        }

        pszString++;
    }

    return FALSE;
}


//-------------------------------------------------------------------------------
LRESULT CTimeOutDlg::ParseDurationEntry( LPTSTR pszTime , PULONG pTime )
{
    TCHAR tchNoTimeout[ 80 ];

    LPTSTR pszTemp = pszTime;

    UINT uDec = 0;

    float fFrac = 0.0f;

    float fT;

    UINT uPos = 1;

    LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchNoTimeout , sizeof( tchNoTimeout ) / sizeof( TCHAR ) );

    if( lstrcmpi( pszTime , tchNoTimeout ) == 0 )
    {
        *pTime = 0;

        return E_SUCCESS;
    }

    if( !DoesContainDigits( pszTime ) )
    {
        return E_PARSE_MISSING_DIGITS;
    }

    while( *pszTemp )
    {
        if( !iswdigit( *pszTemp ) )
        {
            break;
        }

        // check for overflow

        if( uDec >= 1000000000 )
        {
            return E_PARSE_VALUEOVERFLOW ;
        }

        uDec *= 10;

        uDec += ( *pszTemp - '0' );

        pszTemp++;

    }

    TCHAR tchSDecimal[ 5 ];

    GetLocaleInfo( LOCALE_USER_DEFAULT , LOCALE_SDECIMAL , tchSDecimal , sizeof( tchSDecimal ) / sizeof( TCHAR ) );

    if( *pszTemp == *tchSDecimal )
    {
        pszTemp++;

        while( *pszTemp )
        {
            if( !iswdigit( *pszTemp ) )
            {
                break;
            }

            // check for overflow

            if( uDec >= 1000000000 )
            {
                return E_PARSE_VALUEOVERFLOW;
            }

            uPos *= 10;

            fFrac += ( ( float )( *pszTemp - '0' ) ) / ( float )uPos; //+ 0.05f;

            pszTemp++;
        }
    }

    // remove white space

    while( *pszTemp == L' ' )
    {
        pszTemp++;
    }


    if( *pszTemp != NULL )
    {
        if( IsToken( pszTemp , TOKEN_DAY ) )
        {
            *pTime = uDec * 24 * 60;

            fT = ( fFrac * 1440.0f + 0.5f );

            *pTime += ( ULONG )fT;

            return E_SUCCESS;
        }
        else if( IsToken( pszTemp , TOKEN_HOUR ) )
        {
            *pTime = uDec * 60;

            fT = ( fFrac * 60.0f + 0.5f );

            *pTime += ( ULONG )fT;

            return E_SUCCESS;
        }
        else if( IsToken( pszTemp , TOKEN_MINUTE ) )
        {
            // minutes are rounded up in the 1/10 place

            fT = fFrac + 0.5f;

            *pTime = uDec;

            *pTime += ( ULONG )( fT );

            return E_SUCCESS;

        }

    }

    if( *pszTemp == NULL )
    {

        // if no text is defined considered the entry in hours

        *pTime = uDec * 60;

         fT = ( fFrac * 60.0f + 0.5f );

        *pTime += ( ULONG )fT ;

        return E_SUCCESS;
    }


    return E_PARSE_INVALID;

}

#endif


//-------------------------------------------------------------------------------
// Adds strings to table from resource
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::LoadAbbreviates( )
{
    xxxLoadAbbreviate( &m_tokday[0] );

    xxxLoadAbbreviate( &m_tokhour[0] );

    xxxLoadAbbreviate( &m_tokmin[0] );

    return TRUE;
}

//-------------------------------------------------------------------------------
// Take cares some repetitive work for us
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::xxxLoadAbbreviate( PTOKTABLE ptoktbl )
{
    int idx;

    int nSize;

    TCHAR tchbuffer[ 80 ];

    if( ptoktbl == NULL )
    {
        return FALSE;
    }

    for( idx = 0; ptoktbl[ idx ].dwresourceid != ( DWORD )-1 ; ++idx )
    {
        nSize = LoadString( _Module.GetResourceInstance( ) , ptoktbl[ idx ].dwresourceid , tchbuffer , sizeof( tchbuffer ) / sizeof( TCHAR ) );

        if( nSize > 0 )
        {
            ptoktbl[ idx ].pszAbbrv = ( TCHAR *)new TCHAR[ nSize + 1 ];

            if( ptoktbl[ idx ].pszAbbrv != NULL )
            {
                lstrcpy( ptoktbl[ idx ].pszAbbrv , tchbuffer );
            }
        }
    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// Frees up allocated resources
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::xxxUnLoadAbbreviate( PTOKTABLE ptoktbl )
{
    if( ptoktbl == NULL )
    {
        return FALSE;
    }

    for( int idx = 0; ptoktbl[ idx ].dwresourceid != ( DWORD )-1 ; ++idx )
    {
        if( ptoktbl[ idx ].pszAbbrv != NULL )
        {
            delete[] ptoktbl[ idx ].pszAbbrv;

        }
    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// tear-off token tables
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::IsToken( LPTSTR pszString , TOKEN tok )
{
    TOKTABLE *ptoktable;

    if( tok == TOKEN_DAY )
    {
        ptoktable = &m_tokday[0];
    }
    else if( tok == TOKEN_HOUR )
    {
        ptoktable = &m_tokhour[0];
    }
    else if( tok == TOKEN_MINUTE )
    {
        ptoktable = &m_tokmin[0];
    }
    else
    {
        return FALSE;
    }


    for( int idx = 0 ; ptoktable[ idx ].dwresourceid != -1 ; ++idx )
    {
        if( lstrcmpi( pszString , ptoktable[ idx ].pszAbbrv ) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;

}

#if 0
//-------------------------------------------------------------------------------
// Converts the number minutes into a formated string
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ConvertToDuration( ULONG ulTime , LPTSTR pszDuration )
{
    INT_PTR dw[3];

    TCHAR tchTimeUnit[ 40 ];

    TCHAR tchTimeFormat[ 40 ];

    TCHAR tchOutput[ 80 ];

    ASSERT_( ulTime != 0 );

    int iHour= ( int ) ( ( float )ulTime / 60.0f );

    int iDays = iHour / 24;

    dw[ 2 ] = ( INT_PTR )&tchTimeUnit[ 0 ];

    LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_DOT_DIGIT_TU , tchTimeFormat , sizeof( tchTimeFormat ) / sizeof( TCHAR ) );

    if( iDays != 0 )
    {
        int iRemainingHours = iHour % 24;

        float fx = ( float )iRemainingHours / 24.0f + 0.05f;

        int iRemainingMinutes = ulTime % 60;

        float mfx = ( float )iRemainingMinutes / 60.0f + 0.05f;

        //if( ( iRemainingHours != 0 || iRemainingMinutes != 0 ) && iDays < 2 )

        if( mfx > 0.05f || ( fx > 0.05f && fx < 0.10f && iDays < 2 ) )//
        {
            iRemainingMinutes = ( int ) ( mfx * 10 );

            dw[ 0 ] = iHour;

            dw[ 1 ] = iRemainingMinutes;

            iDays = 0;

            LoadString( _Module.GetResourceInstance( ) , IDS_HOURS , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );

        }
        else
        {
            iRemainingHours = ( int )( fx * 10 );

            LoadString( _Module.GetResourceInstance( ) , IDS_DAYS , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );

            dw[ 0 ] = iDays;

            dw[ 1 ] = iRemainingHours;
        }

        if( dw[ 1 ] == 0 )
        {
            // formatted string requires two arguments

            dw[ 1 ] = ( INT_PTR )&tchTimeUnit[ 0 ];

            LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , sizeof( tchTimeFormat ) / sizeof( TCHAR ) );

            if( iDays == 1 )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_DAY , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
            }
        }

    }

    else if( iHour != 0 )
    {
        int iRemainingMinutes = ulTime % 60;

        float fx = ( float )iRemainingMinutes / 60.0f ;//+ 0.05f;

        if( fx > 0.0f && fx < 0.10f && iHour < 2 )//
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );

            LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , sizeof( tchTimeFormat ) / sizeof( TCHAR ) );

            dw[ 0 ] = ulTime ;

            dw[ 1 ] = ( INT_PTR )&tchTimeUnit[ 0 ];

            if( ulTime > 1 )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
            }
            else
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_MINUTE , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
            }
        }//
        else
        {
            fx += 0.05f;

            iRemainingMinutes = ( int ) ( fx * 10 );

            dw[ 0 ] = iHour;

            dw[ 1 ] = iRemainingMinutes;

            LoadString( _Module.GetResourceInstance( ) , IDS_HOURS , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );

            if( iRemainingMinutes == 0 )
            {
                dw[ 1 ] = ( INT_PTR )&tchTimeUnit[ 0 ];

                LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , sizeof( tchTimeFormat ) / sizeof( TCHAR ) );

                if( iHour == 1 )
                {
                    LoadString( _Module.GetResourceInstance( ) , IDS_HOUR , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
                }
            }
        }
    }
    else
    {
        LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );

        LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , sizeof( tchTimeFormat ) / sizeof( TCHAR ) );

        dw[ 0 ] = ulTime ;

        dw[ 1 ] = ( INT_PTR )&tchTimeUnit[ 0 ];

        if( ulTime > 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTE , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }
    }

    FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchTimeFormat , 0 , 0 , tchOutput , sizeof( tchOutput )/sizeof( TCHAR ) , ( va_list * )&dw );

    lstrcpy( pszDuration , tchOutput );

    return TRUE;
}

#endif

//-------------------------------------------------------------------------------
// Place entry in listbox and set as current selection
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::InsertSortedAndSetCurSel( HWND hCombo , DWORD dwMinutes )
{
    ASSERT_( dwMinutes != ( DWORD )-1 );

    TCHAR tchBuffer[ 80 ];

    LRESULT iCount = SendMessage( hCombo , CB_GETCOUNT , 0 , 0 );

    for( INT_PTR idx = 0 ; idx < iCount ; ++idx )
    {
        // Don't insert an item that's already in the list

        if( dwMinutes == ( DWORD )SendMessage( hCombo , CB_GETITEMDATA , idx , 0 ) )
        {
            SendMessage( hCombo , CB_SETCURSEL , idx , 0 ) ;

            SaveChangedSelection( hCombo );

            return TRUE;
        }

        if( dwMinutes < ( DWORD )SendMessage( hCombo , CB_GETITEMDATA , idx , 0 ) )
        {
            break;
        }
    }

    // hey if the value has exceeded the max timeout don't bother entering it in our list

    if( dwMinutes > kMaxTimeoutMinute )
    {
        return FALSE;
    }

    if( ConvertToDuration ( dwMinutes , tchBuffer ) )
    {
        idx = SendMessage( hCombo , CB_INSERTSTRING , idx , ( LPARAM )&tchBuffer[ 0 ] );

        if( idx != CB_ERR )
        {
            SendMessage( hCombo , CB_SETITEMDATA , idx , dwMinutes );

        }

        SendMessage( hCombo , CB_SETCURSEL , idx , 0 ) ;
    }

    // must call this here because CB_SETCURSEL does not send CBN_SELCHANGE

    SaveChangedSelection( hCombo );

    return TRUE;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

//-------------------------------------------------------------------------------
// CShadowDlg::ctor
//-------------------------------------------------------------------------------
CShadowDlg::CShadowDlg( CTSUserSheet *pUSht )
{
    m_pUSht = pUSht;

    m_wOldRad = ( WORD )-1;
}

//-------------------------------------------------------------------------------
// CShadowDlg Dialog Page
// -- static methods lacks this ptr
//-------------------------------------------------------------------------------
INT_PTR CALLBACK CShadowDlg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CShadowDlg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CShadowDlg *pDlg = ( CShadowDlg * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CShadowDlg ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CShadowDlg * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CShadowDlg ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_RBUTTONUP:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            HWND hChild = ChildWindowFromPoint( hwnd , pt );

            ClientToScreen( hwnd , &pt );

            pDlg->OnContextMenu( hChild , pt );
        }

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

    }

    return 0;
}

//-------------------------------------------------------------------------------
// InitDialog for CShadowDlg
//-------------------------------------------------------------------------------
BOOL CShadowDlg::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht ,sizeof(  CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    // No userconfig loaded most likey access denied donot allow users to modify anything

    if( dwStatus != ERROR_FILE_NOT_FOUND && dwStatus != ERROR_SUCCESS )
    {
        INT nId[ ] = {
                        IDC_CHECK_SHADOW,
                        IDC_RADIO_WATCH,
                        IDC_RADIO_CONTROL,
                        IDC_CHECK_NOTIFY,
                        -1
        };

        for( int idx = 0; nId[ idx ] != -1 ; ++idx )
        {
            EnableWindow( GetDlgItem( hwnd , nId[ idx ] ) , FALSE );
        }

        ErrorMessage1( hwnd , dwStatus );

        return FALSE;
    }

    if( uc.Shadow == Shadow_Disable )
    {
        SendMessage( GetDlgItem( hwnd , IDC_CHECK_SHADOW ) , BM_SETCHECK , ( WPARAM )FALSE , 0  );

        EnableWindow( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , FALSE );

        EnableWindow( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , FALSE );

        EnableWindow( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , FALSE );

        EnableWindow( GetDlgItem( hwnd , IDC_STATIC_LEVELOFCTRL ) , FALSE );
    }
    else
    {
        //
        // Controls are initially enabled,  set current status
        //

        SendMessage( GetDlgItem( hwnd , IDC_CHECK_SHADOW ) , BM_SETCHECK , ( WPARAM )TRUE , 0  );

        switch( uc.Shadow )
        {
        case Shadow_EnableInputNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , BM_CLICK , 0 , 0 );

            break;

        case Shadow_EnableInputNoNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )FALSE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , BM_CLICK , 0 , 0 );

            break;

        case Shadow_EnableNoInputNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , BM_CLICK , 0 , 0 );

            break;

        case Shadow_EnableNoInputNoNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )FALSE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , BM_CLICK , 0 , 0 );

            break;
        }

        m_wOldRad = ( WORD )( IsDlgButtonChecked( hwnd , IDC_RADIO_WATCH ) ? IDC_RADIO_WATCH : IDC_RADIO_CONTROL ) ;

    }

    m_bPersisted = TRUE;

    return CDialogBase::OnInitDialog( hwnd , wp , lp );
}


BOOL CShadowDlg::OnDestroy( )
{
    return CDialogBase::OnDestroy( );
}

//-------------------------------------------------------------------------------
// GetPropertySheetPage - each dialog object should be responsible for its own data
//-------------------------------------------------------------------------------
BOOL CShadowDlg::GetPropertySheetPage( PROPSHEETPAGE &psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;

    psp.hInstance   = _Module.GetModuleInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_PAGE_SHADOW );

    psp.lParam      = (LPARAM)this;

    psp.pfnCallback = CDialogBase::PageCallback;

    psp.pfnDlgProc  = CShadowDlg::DlgProc;

    return TRUE;
}

//-------------------------------------------------------------------------------
// Basic control notification handler
//-------------------------------------------------------------------------------
void CShadowDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtl )
{
    switch( wNotifyCode )
    {
    case BN_CLICKED:
        if( wID == IDC_CHECK_SHADOW )
        {
            HWND hwnd = GetParent( hwndCtl );

            BOOL bChecked = SendMessage( hwndCtl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_SHADOW ) , BM_SETCHECK , ( WPARAM )bChecked , 0  );

            EnableWindow( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , bChecked );

            EnableWindow( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , bChecked );

            EnableWindow( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , bChecked );

            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_LEVELOFCTRL ) , bChecked );

            //
            // if neither radio buttons are selected force IDC_RADIO_CONTROL to be selected
            //

            if(
                ( SendMessage( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , BM_GETSTATE , 0 , 0 ) == BST_UNCHECKED )
                &&
                ( SendMessage( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , BM_GETSTATE , 0 , 0 ) == BST_UNCHECKED )
               )
            {
                SendMessage( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , BM_SETCHECK , ( WPARAM )BST_CHECKED , 0 );

                m_wOldRad = IDC_RADIO_CONTROL;
            }

            m_bPersisted = FALSE;

            SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );

        }
        else if( wID == IDC_RADIO_WATCH || wID == IDC_RADIO_CONTROL )
        {
            if( wID != m_wOldRad )
            {
                m_wOldRad = wID;

                m_bPersisted = FALSE;

                SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
            }
        }
        else if( wID == IDC_CHECK_NOTIFY )
        {
            m_bPersisted = FALSE;

            SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
        }


        break;

    case ALN_APPLY:

        //This is being removed for consinstency with the rest of MMC dialogs, even though it would
        //make more sense to the user for Cancel to be disabled after applying the changes, since
        //cancellation is not a real option at that point.
        //SendMessage( GetParent( hwndCtl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        break;
    }
}

//-------------------------------------------------------------------------------
// PersisitSettings
//-------------------------------------------------------------------------------
BOOL CShadowDlg::PersistSettings( HWND hDlg )
{
    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    //
    // Record all changes
    //

    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_SHADOW ) , BM_GETCHECK , 0 , 0 ) != BST_CHECKED )
    {
        uc.Shadow = Shadow_Disable;
    }

    else
    {
        BOOL bCheckNotify = (BOOL)SendMessage( GetDlgItem( hDlg , IDC_CHECK_NOTIFY ) , BM_GETCHECK , 0 , 0 );

        BOOL bRadioControl = (BOOL)SendMessage( GetDlgItem( hDlg , IDC_RADIO_CONTROL ) , BM_GETCHECK , 0 , 0 );

        if( bCheckNotify )
        {
            if( bRadioControl )
            {
                uc.Shadow = Shadow_EnableInputNotify;
            }
            else
            {
                uc.Shadow = Shadow_EnableNoInputNotify;
            }
        }
        else
        {
            if( bRadioControl )
            {
                uc.Shadow = Shadow_EnableInputNoNotify;
            }
            else
            {
                uc.Shadow = Shadow_EnableNoInputNoNotify;
            }
        }
    }

    if( !m_pUSht->SetUserConfig( uc , &dwStatus ) )
    {
        ErrorMessage2( hDlg , dwStatus );

        return TRUE;
    }

    PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

    SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

    return TRUE;

}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

CProfileDlg::CProfileDlg( CTSUserSheet *pUsh )
{
    m_pUSht = pUsh;

    m_wOldRadio = ( WORD )-1;
    
    m_ncbxOld = -1;
}

//-------------------------------------------------------------------------------
// GetPropertySheetPage - each dialog object should be responsible for its own data
//-------------------------------------------------------------------------------
BOOL CProfileDlg::GetPropertySheetPage( PROPSHEETPAGE &psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;

    psp.hInstance   = _Module.GetModuleInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_PAGE_PROFILE );

    psp.lParam      = (LPARAM)this;

    psp.pfnCallback = CDialogBase::PageCallback;

    psp.pfnDlgProc  = CProfileDlg::DlgProc;

    return TRUE;
}

//-------------------------------------------------------------------------------
// CProfileDlg Dialog Page
// -- static methods lacks this ptr
//-------------------------------------------------------------------------------
INT_PTR CALLBACK CProfileDlg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CProfileDlg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CProfileDlg *pDlg = ( CProfileDlg * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CProfileDlg ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CProfileDlg * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CProfileDlg ) ) )
        {
            return FALSE;
        }
    }


    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_RBUTTONUP:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            HWND hChild = ChildWindowFromPoint( hwnd , pt );

            ClientToScreen( hwnd , &pt );

            pDlg->OnContextMenu( hChild , pt );
        }

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

    }

    return 0;
}

//-------------------------------------------------------------------------------
// InitDialog for CProfileDlg
//-------------------------------------------------------------------------------
BOOL CProfileDlg::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    TCHAR tchDrv[3];

    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht ,sizeof(  CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    if( dwStatus != ERROR_FILE_NOT_FOUND && dwStatus != ERROR_SUCCESS )
    {
        INT nId[ ] = {
                        IDC_CHECK_ALLOWLOGON,
                        IDC_COMBO_DRIVES,
                        IDC_EDIT_REMOTEPATH,
                        IDC_RADIO_REMOTE,
                        IDC_EDIT_LOCALPATH,
                        IDC_RADIO_LOCAL,
                        IDC_EDIT_USRPROFILE,
                        -1
        };

        for( int idx = 0; nId[ idx ] != -1 ; ++idx )
        {
            EnableWindow( GetDlgItem( hwnd , nId[ idx ] ) , FALSE );
        }

        ErrorMessage1( hwnd , dwStatus );

        return FALSE;
    }

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_ALLOWLOGON ) , BM_SETCHECK , ( WPARAM )( !uc.fLogonDisabled ) , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_LOCALPATH  ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_REMOTEPATH  ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_USRPROFILE  ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );


    for( TCHAR DrvLetter = 'C'; DrvLetter <= 'Z'; DrvLetter++ )
    {
        tchDrv[0] = DrvLetter;

        tchDrv[1] = ':';

        tchDrv[2] = 0;

        SendMessage( GetDlgItem( hwnd , IDC_COMBO_DRIVES ) , CB_ADDSTRING , 0 , ( LPARAM )&tchDrv[ 0 ] );
    }

	if( PathIsUNC( uc.WFHomeDir ) )
	{
		ODS( L"TSUSEREX: Path is UNC\n" );

		CharUpper( &uc.WFHomeDirDrive[0] );

		if( uc.WFHomeDirDrive[ 0 ] >= 'C' && uc.WFHomeDirDrive[ 0 ] <= 'Z' )
        {
            m_ncbxOld = (int)SendMessage( GetDlgItem( hwnd , IDC_COMBO_DRIVES ) , CB_SETCURSEL , ( WPARAM )( uc.WFHomeDirDrive[ 0 ] - 'C' ) , 0 );
        }
		else
		{
			// default it to Z drive

			m_ncbxOld = (int)SendMessage( GetDlgItem( hwnd , IDC_COMBO_DRIVES ) , CB_SETCURSEL , ( WPARAM )( 'Z' - 'C' ) , 0 );
		}


        SetWindowText( GetDlgItem( hwnd , IDC_EDIT_REMOTEPATH ) , uc.WFHomeDir );

        //SendMessage( GetDlgItem( hwnd , IDC_RADIO_REMOTE ) , BM_CLICK , 0 , 0 );
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_REMOTE ) , BM_SETCHECK , ( WPARAM )BST_CHECKED , 0 );
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_LOCAL ) , BM_SETCHECK , ( WPARAM )BST_UNCHECKED , 0 );

        m_wOldRadio = IDC_RADIO_REMOTE;
    }
	else
    {
		ODS( L"TSUSEREX: Path is Local\n" );
        SendMessage( GetDlgItem( hwnd , IDC_EDIT_LOCALPATH ) , WM_SETTEXT , 0 , ( LPARAM )&uc.WFHomeDir[ 0 ] );

        // SendMessage( GetDlgItem( hwnd , IDC_RADIO_LOCAL ) , BM_CLICK , 0 , 0 );
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_LOCAL ) , BM_SETCHECK , ( WPARAM )BST_CHECKED , 0 );
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_REMOTE ) , BM_SETCHECK , ( WPARAM )BST_UNCHECKED , 0 );

        m_wOldRadio = IDC_RADIO_LOCAL;
    }

    EnableRemoteHomeDirectory( hwnd , ( BOOL )( m_wOldRadio == IDC_RADIO_REMOTE ) );


    SendMessage( GetDlgItem( hwnd , IDC_EDIT_USRPROFILE ) , WM_SETTEXT , 0 , ( LPARAM )&uc.WFProfilePath[ 0 ] );

    m_bPersisted = TRUE;

    m_bTSHomeFolderChanged = FALSE;

    return CDialogBase::OnInitDialog( hwnd , wp , lp );
}

//-------------------------------------------------------------------------------
// EnableRemoteHomeDirectory -- basically enables or disables dlg controls
//-------------------------------------------------------------------------------
BOOL CProfileDlg::EnableRemoteHomeDirectory( HWND hwnd , BOOL bHDMR )
{
    //
    // Local home directory
    //

    EnableWindow( GetDlgItem( hwnd , IDC_EDIT_LOCALPATH ) , !bHDMR );

    //
    // Network'd home directory
    //

    EnableWindow( GetDlgItem( hwnd , IDC_COMBO_DRIVES ) , bHDMR );
   
    EnableWindow( GetDlgItem( hwnd , IDC_EDIT_REMOTEPATH ) , bHDMR );
    
    return TRUE;
}


BOOL CProfileDlg::OnDestroy( )
{
    return CDialogBase::OnDestroy( );
}

//-------------------------------------------------------------------------------
// Basic control notification handler
//-------------------------------------------------------------------------------
void CProfileDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtl )
{
    switch( wNotifyCode )
    {
    case EN_CHANGE:

        m_bPersisted = FALSE;

        if( wID == IDC_EDIT_REMOTEPATH || wID == IDC_EDIT_LOCALPATH )
        {
            ODS( L"EN_CHANGE m_bTSHomeFolderChanged = TRUE;\n" );

            m_bTSHomeFolderChanged = TRUE;
        }

        SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );

        break;

    //case CBN_DROPDOWN:
    case CBN_SELCHANGE:
        {
            int nCurSel = (int)SendMessage( hwndCtl , CB_GETCURSEL , 0 , 0 );
        
            if( m_ncbxOld != nCurSel )
            {
                m_ncbxOld = nCurSel;

                ODS( L"CBN_SELCHANGE m_bTSHomeFolderChanged = TRUE;\n" );

                m_bTSHomeFolderChanged = TRUE;

                m_bPersisted = FALSE;
            
                SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
            }
        }
        
        break;        

    case BN_CLICKED:

        if( wID == IDC_RADIO_REMOTE || wID == IDC_RADIO_LOCAL )
        {
            if( wID != m_wOldRadio )
            {
                EnableRemoteHomeDirectory( GetParent( hwndCtl ) , ( BOOL )( wID == IDC_RADIO_REMOTE ) );

                m_wOldRadio = wID;

                m_bPersisted = FALSE;
                
                ODS( L"Setting m_bTSHomeFolderChanged to true\n" );

                m_bTSHomeFolderChanged = TRUE;

                SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
            }

            if( wID == IDC_RADIO_LOCAL )
            {
                SetFocus( GetDlgItem( GetParent( hwndCtl ) , IDC_EDIT_LOCALPATH ) );

                SendMessage( GetDlgItem( GetParent( hwndCtl ) , IDC_EDIT_LOCALPATH ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );
            }
            else if( wID == IDC_RADIO_REMOTE )
            {
                if( SendMessage( GetDlgItem( GetParent( hwndCtl ) , IDC_COMBO_DRIVES ) , 
                                 CB_GETCURSEL,
                                 0,
                                 0 ) == CB_ERR )
                {
                    SendMessage( GetDlgItem( GetParent( hwndCtl ) , IDC_COMBO_DRIVES ) ,
                                 CB_SETCURSEL,
                                 ( WPARAM )( 'Z' - 'C' ),
                                 0 );
                }

                SetFocus( GetDlgItem( GetParent( hwndCtl ) , IDC_COMBO_DRIVES ) );
            }

        }
        else if( wID == IDC_CHECK_ALLOWLOGON )
        {
            m_bPersisted = FALSE;

            SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
        }

        break;

    case ALN_APPLY:

        //This is being removed for consinstency with the rest of MMC dialogs, even though it would
        //make more sense to the user for Cancel to be disabled after applying the changes, since
        //cancellation is not a real option at that point.
        //SendMessage( GetParent( hwndCtl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        break;
    }


}

//-------------------------------------------------------------------------------
// PersistSettings -- remember TRUE is bad FALSE is good
//-------------------------------------------------------------------------------
BOOL CProfileDlg::PersistSettings( HWND hDlg )
{
    BOOL bRet = TRUE;;

    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        return TRUE;
    }


    USERCONFIG uc;


    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    //
    // expensive but necessary id34393
    //
    if( !m_pUSht->SetUserConfig( uc , &dwStatus ) )
    {
        ErrorMessage2( hDlg , dwStatus );

        m_bTSHomeFolderChanged = FALSE;

        return TRUE;
    }

    //
    // Determine whether to enable user to logon to a terminal server
    //

    uc.fLogonDisabled = SendMessage( GetDlgItem( hDlg , IDC_CHECK_ALLOWLOGON ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? FALSE : TRUE;
    
    //
    // Profile path is under the admin discretion
    //

    SetWTSProfilePath( hDlg , uc );

    //
    // Parse and flag corrupt data
    //

    if( m_bTSHomeFolderChanged )
    {
        ODS( L"Persisting home folder settings\n" );

        if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_LOCAL ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
        {
            bRet = SetWTSLocalPath( hDlg , uc );
            // Set WFHomeDirDrive to NULL because Home folder is a Local folder
            wcscpy(uc.WFHomeDirDrive, L"\0");
        }
        else
        {
            bRet = SetWTSRemotePath( hDlg , uc );
        }

        m_bTSHomeFolderChanged = FALSE;
    }

    if( bRet )
    {
        if( !m_pUSht->SetUserConfig( uc , &dwStatus ) )
        {
            ErrorMessage2( hDlg , dwStatus );

            return TRUE;
        }
        
        PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

        SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

    }

    return bRet;
}

//-------------------------------------------------------------------------------
// IsValidSettings doesnot persist the information
//-------------------------------------------------------------------------------
BOOL CProfileDlg::IsValidSettings( HWND hDlg )
{
    BOOL bRet = TRUE;

    //
    // Parse and flag corrupt data
    //

    if( m_bTSHomeFolderChanged )
    {
        ODS( L"Checking validity of home folders\n" );

        if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_LOCAL ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
        {
            bRet = IsLocalPathValid( hDlg );
        }
        else
        {
            bRet = IsRemotePathValid( hDlg );
        }
    }

    return bRet;
}


//-------------------------------------------------------------------------------
// SetWTSProfilePath
//-------------------------------------------------------------------------------
BOOL CProfileDlg::SetWTSProfilePath( HWND hDlg , USERCONFIG& uc )
{
    //
    // It looks like we don't care what the user enters
    // I'm borrowing the behavior from the current usrmgr profile page
    //

    GetWindowText( GetDlgItem( hDlg , IDC_EDIT_USRPROFILE ) , uc.WFProfilePath , sizeof( uc.WFProfilePath ) / sizeof( TCHAR ) );

    ExpandUserName( uc.WFProfilePath );

    SetWindowText( GetDlgItem( hDlg , IDC_EDIT_USRPROFILE ) , uc.WFProfilePath );

    return TRUE;
}

// Create all the folders required, up to and including the leaf folder.
// Path is expected to be of the form \\server\share\...
HRESULT CProfileDlg::CreateRemoteFolder(LPCTSTR path)
{
    HRESULT hr = S_OK;

    LPTSTR current = (LPTSTR)path;
    DWORD  dwError;

    //Find the first whack after the 1st 2
    current = wcschr(current + 2, L'\\');

    //Now find the next one. We should be at the end of the share name
    current = wcschr(current + 1, L'\\');

    //Now find the next one. We should be at the end of the drive name
    current = wcschr(current + 1, L'\\');

    while (SUCCEEDED(hr))
    {
        //Mark the trailing backslash as the end of the string.  This
        //makes path point to a truncated path (containing only the folder
        //names we have walked thru so far).
        if (current)
            *current = 0;



        // create a secure ACL'd directory if it already exists it will
        // return a success
        if (!CreateSecureDir((LPTSTR)path , &dwError))
        {
            ODS(L"CreateSecureDir failed\n");
            hr = E_FAIL;
        }

        if (current)
        {
            //Replace the original trailing backslash, and move on to the
            //next backslash after that.
            *current = L'\\';
            current = wcschr(current + 1, L'\\');
        }
        else
        {
            //No more folders are on the path.  We're done.
            break;
        }
    }

    return hr;
}

BOOL CProfileDlg::IsLocalComputer(WCHAR* pwchMachinename)
{
    BOOL bLocal = FALSE;

    WCHAR pwchComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    DWORD dwLen = sizeof(pwchComputerName)/sizeof(WCHAR);

    if (GetComputerNameEx(ComputerNameNetBIOS, pwchComputerName, &dwLen))
    {
        if (_wcsicmp(pwchComputerName, pwchMachinename) == 0)
            bLocal = TRUE;
    }

    if (GetComputerNameEx(ComputerNameDnsFullyQualified, pwchComputerName, &dwLen))
    {
        if (_wcsicmp(pwchComputerName, pwchMachinename) == 0)
            bLocal = TRUE;
    }

    return bLocal;
}



//Put the absolute path into the form \\machinename\drive$\path
BOOL CProfileDlg::CreateSystemPath(WCHAR* chPath)
{
    WCHAR* pstrMachinename = NULL;

    if (m_pUSht->GetServer(&pstrMachinename))
    {
        if (pstrMachinename)
        {
            //Start constructing the system path
            WCHAR chSystemPath[MAX_PATH];
            wcscpy(chSystemPath, L"\\\\");
            wcsncat(chSystemPath, pstrMachinename, MAX_PATH - wcslen(chSystemPath) - 1);

            //Now set the local flag accordingly
            BOOL bLocalMachine = IsLocalComputer(pstrMachinename);

            //We've got no use for this anymore
            if (pstrMachinename)
                delete[] pstrMachinename;

            if (bLocalMachine)
            {
                DWORD dwErr = 0;
                return createdir(chPath, FALSE, &dwErr);
            }

            //It's not local so continue contructing the path
            wcsncat(chSystemPath, L"\\", MAX_PATH - wcslen(chSystemPath) - 1);

            //The path should be valid by this point, but we might 
            //as well verify that for ourselves
            if ((wcslen(chPath) >= 4) && 
                (IsCharAlpha(chPath[0])) &&
                (chPath[1] == L':') &&
                (chPath[2] == L'\\') &&
                (IsCharAlpha(chPath[3])))
            {
                size_t nCurrentLength = wcslen(chSystemPath);
                if (nCurrentLength < (MAX_PATH - 2))
                {
                    chSystemPath[nCurrentLength] = chPath[0];
                    chSystemPath[nCurrentLength + 1] = L'\0';

                    wcsncat(chSystemPath, L"$", MAX_PATH - wcslen(chSystemPath) - 1);
                    wcsncat(chSystemPath, chPath + 2, MAX_PATH - wcslen(chSystemPath) - 1);
                }

                //Now that the system path is constructed, let's create the folder
                return SUCCEEDED(CreateRemoteFolder(chSystemPath));
            }
        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// IsLocalPathValid
//-------------------------------------------------------------------------------
BOOL CProfileDlg::IsLocalPathValid( HWND hDlg )
{
    LPVOID tchBuf = NULL;

    TCHAR tchErr[ MAX_PATH ] = { 0 };

    TCHAR tchErrTitle[ 80 ]= { 0 };

    TCHAR tchPath[ MAX_PATH ]= { 0 };

    INT_PTR dw = ( INT_PTR )&tchPath[0];

    if( SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOCALPATH ) , WM_GETTEXT , sizeof( tchPath ) / sizeof( TCHAR ) , ( LPARAM )&tchPath[ 0 ] ) > 0 )
    {
        ExpandUserName( tchPath );

        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOCALPATH ) , tchPath );

        if( !IsPathValid( tchPath , FALSE ) )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_PATH , tchErr , sizeof( tchErr ) / sizeof( TCHAR ) );

            LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , sizeof( tchErrTitle ) / sizeof( TCHAR ) );

            FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            tchErr , 0 , 0 , (WCHAR*)&tchBuf , sizeof( tchErr ) / sizeof( TCHAR ) , ( va_list * )&dw );

            if (tchBuf)
            {
                MessageBox(hDlg, (WCHAR*)tchBuf, tchErrTitle, MB_OK | MB_ICONERROR);
                LocalFree(tchBuf);
            }
            else
                MessageBox(hDlg, tchErr, tchErrTitle, MB_OK | MB_ICONERROR);

            return FALSE;
        }
    }

    return TRUE;
}


//-------------------------------------------------------------------------------
// SetWTSLocalPath - copies the contents over - IsPathValid would have return
// true inorder for us to get here!
//-------------------------------------------------------------------------------
BOOL CProfileDlg::SetWTSLocalPath( HWND hDlg , USERCONFIG& uc )
{
    SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOCALPATH ) , WM_GETTEXT , sizeof( uc.WFHomeDir ) / sizeof( TCHAR ) , ( LPARAM )&uc.WFHomeDir[ 0 ] );

    if (!m_pUSht->GetDSAType())
    {
        //We won't return the result from this because,
        //even if the path isn't created, the setting
        //may still be persisted and the admin can add
        //the directory after the fact
        CreateSystemPath(uc.WFHomeDir);
    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// IsRemotePathValid - verifies UNC is correct
//-------------------------------------------------------------------------------
BOOL CProfileDlg::IsRemotePathValid( HWND hDlg )
{
    TCHAR tchErr1[ 768 ] = { 0 };

    TCHAR tchError[ 768 ] = { 0 };

    TCHAR tchHomeDir[ MAX_PATH ] = { 0 };

    if( GetWindowText( GetDlgItem( hDlg , IDC_EDIT_REMOTEPATH ) , tchHomeDir , sizeof( tchHomeDir ) / sizeof( TCHAR ) ) > 0 )
    {
        ExpandUserName( tchHomeDir );

        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_REMOTEPATH ) , tchHomeDir );

        if( !IsPathValid( tchHomeDir , TRUE ) )
        {
            if( LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_REMOTEPATH , tchErr1 , sizeof( tchErr1 ) / sizeof( TCHAR ) ) > 0 )
            {
                INT_PTR dw = ( INT_PTR )&tchHomeDir[ 0 ];

                FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchErr1 , 0 , 0 , tchError , sizeof( tchError ) / sizeof( TCHAR ) , ( va_list * )&dw );

                LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErr1 , sizeof( tchErr1 ) / sizeof( TCHAR ) );

                MessageBox( hDlg , tchError , tchErr1 , MB_OK | MB_ICONERROR );
            }

            return FALSE;
        }
    }
    else
    {
        LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_NETPATH , tchError , sizeof( tchError ) / sizeof( TCHAR ) );

        LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErr1 , sizeof( tchErr1 ) / sizeof( TCHAR ) );

        MessageBox( hDlg , tchError , tchErr1 , MB_OK | MB_ICONERROR );

        return FALSE;
    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// SetWTSRemotePath - IsRemotePathValid must return TRUE in order to get here
//-------------------------------------------------------------------------------
BOOL CProfileDlg::SetWTSRemotePath( HWND hDlg , USERCONFIG& uc )
{
    TCHAR tchErr1[ 768 ] = { 0 };

    TCHAR tchError[ 768 ] = { 0 };

    GetWindowText( GetDlgItem( hDlg , IDC_EDIT_REMOTEPATH ) , uc.WFHomeDir , sizeof( uc.WFHomeDir ) / sizeof( TCHAR ) );

    if( GetWindowText( GetDlgItem( hDlg , IDC_COMBO_DRIVES ) ,  uc.WFHomeDirDrive , sizeof( uc.WFHomeDirDrive ) / sizeof( TCHAR ) ) == 0 )
    {
        SendMessage( GetDlgItem( hDlg , IDC_COMBO_DRIVES ) , CB_GETLBTEXT , 0 , ( LPARAM )&uc.WFHomeDirDrive );
    }

    DWORD dwErr = 0;

    if( !createdir( uc.WFHomeDir , TRUE , &dwErr ) )
	{
		if( dwErr != 0 )
		{

			UINT rId;

			switch( dwErr )
			{
			case ERROR_ALREADY_EXISTS:
			case ERROR_LOGON_FAILURE:
			case ERROR_PATH_NOT_FOUND:
				{
					rId = ( ERROR_ALREADY_EXISTS == dwErr) ?
							IDS_HOME_DIR_EXISTS :
							( ERROR_PATH_NOT_FOUND == dwErr ) ?
							IDS_HOME_DIR_CREATE_FAILED :
							IDS_HOME_DIR_CREATE_NO_ACCESS;

					LoadString( _Module.GetResourceInstance( ) , rId , tchErr1 , sizeof( tchErr1 ) / sizeof( TCHAR ) );
					
					wsprintf( tchError , tchErr1 , uc.WFHomeDir );

					LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErr1 , sizeof( tchErr1 ) / sizeof( TCHAR ) );

					MessageBox( hDlg , tchError , tchErr1 , MB_OK | MB_ICONERROR );
				}
				break;

			default:
				xxErrorMessage( hDlg , dwErr , IDS_ERR_CREATE_DIR );				
			}

		}
	}

    // uc.fHomeDirectoryMapRoot = TRUE;

    return TRUE;
}


//-------------------------------------------------------------------------------
// This is cool - I_NetPathType really does a lot of work for us
//-------------------------------------------------------------------------------
BOOL CProfileDlg::IsPathValid( LPTSTR pszPath , BOOL bUnc )
{
    DWORD dwRetflags;

    if( I_NetPathType( NULL, pszPath, &dwRetflags, 0) != NERR_Success )
        return FALSE;

    if( !bUnc )
        return ((dwRetflags == ITYPE_PATH_ABSD) ? TRUE : FALSE);

    return ((dwRetflags == ITYPE_UNC) ? TRUE : FALSE);

}

//-------------------------------------------------------------------------------
// If the string contains %username% expand it to the current user.
//-------------------------------------------------------------------------------
void CProfileDlg::ExpandUserName( LPTSTR szPath )
{
    TCHAR tchSubPath[ MAX_PATH];
    TCHAR szUserName[ 40 ];

    if( szPath == NULL )
    {
        return;
    }

    // remove any leading or trailing spaces

    TCHAR tchTrim[] = TEXT( " " );

    StrTrim( szPath , tchTrim );

    int nSz = LoadString( _Module.GetResourceInstance( ) , IDS_USERNAME , szUserName , sizeof( szUserName ) / sizeof( TCHAR ) );

    //CharLowerBuff( szPath , lstrlen( szPath ) );

    // Find %username%

    LPTSTR pFound = StrStrI( szPath , szUserName ); //_tcsstr( szPath , szUserName );

    if( pFound != NULL )
    {
        INT_PTR nPos = ( INT_PTR )( pFound - szPath );

        lstrcpy( tchSubPath , ( szPath + nPos + nSz ) );

        szPath[ nPos ] = 0;

        lstrcat( szPath , m_pUSht->GetUserName() );

        lstrcat( szPath , tchSubPath );
    }

}

//-------------------------------------------------------------------------------
// Removing decimal entries
//-------------------------------------------------------------------------------
LRESULT CTimeOutDlg::ParseDurationEntry( LPTSTR pszTime , PULONG pTime )
{
    TCHAR tchNoTimeout[ 80 ];

    LPTSTR pszTemp = pszTime;

    UINT uDec = 0;

    BOOL bSetDay  = FALSE;
    BOOL bSetHour = FALSE;
    BOOL bSetMin  = FALSE;
    BOOL bEOL     = FALSE;
    BOOL bHasDigit= FALSE;

    *pTime = 0;

    LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchNoTimeout , sizeof( tchNoTimeout ) / sizeof( TCHAR ) );

    if( lstrcmpi( pszTime , tchNoTimeout ) == 0 )
    {
        // *pTime = 0;

        return E_SUCCESS;
    }

    while( !bEOL )
    {
        // remove leading white spaces

        while( *pszTemp == L' ' )
        {
            pszTemp++;
        }

        while( *pszTemp )
        {
            if( !iswdigit( *pszTemp ) )
            {
                if( !bHasDigit )
                {
                    return E_PARSE_MISSING_DIGITS;
                }

                break;
            }

            // check for overflow

            if( uDec >= 1000000000 )
            {
                return E_PARSE_VALUEOVERFLOW ;
            }

            uDec *= 10;

            uDec += ( *pszTemp - '0' );

            if( !bHasDigit )
            {
                bHasDigit = TRUE;
            }

            pszTemp++;
        }

        // remove intermediate white spaces

        while( *pszTemp == L' ' )
        {
            pszTemp++;
        }

        if( *pszTemp != NULL )
        {
            // Get next token

            TCHAR tchToken[ 80 ];

            pszTemp = GetNextToken( pszTemp , tchToken );


            if( IsToken( tchToken , TOKEN_DAY ) )
            {
                if( !bSetDay )
                {
                    *pTime += uDec * 1440;

                    bSetDay = TRUE;
                }

            }
            else if( IsToken( tchToken , TOKEN_HOUR ) )
            {
                if( !bSetHour )
                {
                    *pTime += uDec * 60;

                    bSetHour = TRUE;
                }

            }
            else if( IsToken( tchToken , TOKEN_MINUTE ) )
            {
                if( !bSetMin )
                {
                    *pTime += uDec;

                    bSetMin = TRUE;
                }

            }
            else
            {
                return E_PARSE_INVALID;
            }

        }
        else
        {
            if( !bSetHour )
            {
                *pTime += uDec * 60;
            }

            bEOL = TRUE;
        }

        uDec = 0;

        bHasDigit = FALSE;

    }

    return E_SUCCESS;
}

//-------------------------------------------------------------------------------
// replacing older api
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ConvertToDuration( ULONG ulTime , LPTSTR pszDuration )
{
//    TCHAR dw[] = L"dhm";

    TCHAR tchTimeUnit[ 40 ];

    TCHAR tchTimeFormat[ 40 ];

    TCHAR tchOutput[ 80 ];

    ASSERT_( ulTime != 0 );

    int iHour = ( ulTime / 60 );

    int iDays = iHour / 24;

    int iMinute = ulTime % 60;

    // Resolve format

    tchOutput[0] = 0;


    if( iDays > 0 )
    {
        if( iDays == 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_DAY , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_DAYS , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }

        iHour = iHour % 24;

        wsprintf( tchTimeFormat , L"%d %s", iDays , tchTimeUnit );

        lstrcat( tchOutput , tchTimeFormat );

        lstrcat( tchOutput , L" " );
    }

    if( iHour > 0 )
    {
        if( iHour == 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_HOUR , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_HOURS , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }

        wsprintf( tchTimeFormat , L"%d %s", iHour , tchTimeUnit );

        lstrcat( tchOutput , tchTimeFormat );

        lstrcat( tchOutput , L" " );
    }

    if( iMinute > 0 )
    {
        if( iMinute == 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTE , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }

        wsprintf( tchTimeFormat , L"%d %s", iMinute , tchTimeUnit );

        lstrcat( tchOutput , tchTimeFormat );

        lstrcat( tchOutput , L" " );
    }

    lstrcpy( pszDuration , tchOutput );

    return TRUE;

}

//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::DoesContainDigits( LPTSTR pszString )
{
    while( *pszString )
    {
        if( *pszString != L' ')
        {
            if( iswdigit( *pszString ) )
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }

            pszString++;
        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
TCHAR * GetNextToken( TCHAR *pszString , TCHAR *tchToken )
{
    while( *pszString )
    {
        if( IsCharAlpha( *pszString ) )
        {
            *tchToken = *pszString;
        }
        else
        {
            break;
        }

        tchToken++;

        pszString++;
    }

    *tchToken = '\0';

    return pszString;
}

//-------------------------------------------------------------------------------
void ErrorMessage1( HWND hParent , DWORD dwStatus )
{
    xxErrorMessage( hParent , dwStatus , IDS_TSGETPROPSFAILED );
}

//-------------------------------------------------------------------------------
void ErrorMessage2( HWND hParent , DWORD dwStatus )
{
    xxErrorMessage( hParent , dwStatus , IDS_TSOPSFAILED );
}

//-------------------------------------------------------------------------------
void xxErrorMessage( HWND hParent , DWORD dwStatus , UINT nResID )
{
    LPTSTR pBuffer = NULL;

    TCHAR tchBuffer[ 256 ];

    TCHAR tchErr[ 128 ];

    TCHAR tchTitle[ 80 ];

    LoadString( _Module.GetModuleInstance( ) , nResID , tchErr , sizeof( tchErr ) / sizeof( TCHAR ) );

    LoadString( _Module.GetModuleInstance( ) , IDS_TSGETPROPTITLE , tchTitle , sizeof( tchTitle ) / sizeof( TCHAR ) );

    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                 FORMAT_MESSAGE_FROM_SYSTEM,
                 NULL,                                          //ignored
                 dwStatus    ,                                //message ID
                 MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ), //message language
                 (LPTSTR)&pBuffer,                              //address of buffer pointer
                 0,                                             //minimum buffer size
                 NULL);                                         //no other arguments

    wsprintf( tchBuffer , tchErr , pBuffer );

    ::MessageBox( hParent , tchBuffer , tchTitle , MB_OK | MB_ICONERROR );

    if( pBuffer != NULL )
    {
        LocalFree( pBuffer );
    }

}




#if 0
//-------------------------------------------------------------------------------
NTSTATUS GetDomainName( PWCHAR ServerNamePtr, // name of server to get domain of
                        LPTSTR DomainNamePtr // alloc and set ptr (free with NetApiBufferFree)
                       )

/*++

Routine Description:

    Returns the name of the domain or workgroup this machine belongs to.

Arguments:

    DomainNamePtr - The name of the domain or workgroup

    IsWorkgroupName - Returns TRUE if the name is a workgroup name.
        Returns FALSE if the name is a domain name.

Return Value:

   NERR_Success - Success.
   NERR_CfgCompNotFound - There was an error determining the domain name

--*/
{
    NTSTATUS status;
    LSA_HANDLE PolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo;
    OBJECT_ATTRIBUTES ObjAttributes;
    UNICODE_STRING UniServerName;


    //
    // Check for caller's errors.
    //
    if ( DomainNamePtr == NULL ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    RtlInitUnicodeString( &UniServerName, ServerNamePtr );
    status = LsaOpenPolicy(
                   &UniServerName,
                   &ObjAttributes,
                   POLICY_VIEW_LOCAL_INFORMATION,
                   &PolicyHandle
                   );


    KdPrint( ( "TSUSEREX - GetDomainName: LsaOpenPolicy returned NTSTATUS = 0x%x\n", status ) );



    if (! NT_SUCCESS(status)) {
        return( status );
    }

    //
    // Get the name of the primary domain from LSA
    //
    status = LsaQueryInformationPolicy(
                   PolicyHandle,
                   PolicyAccountDomainInformation,
                   (PVOID *)&DomainInfo
                   );


    KdPrint( ( "TSUSEREX - GetDomainName: LsaQueryInformationPolicy returned NTSTATUS = 0x%x\n", status ) );



    if (! NT_SUCCESS(status)) {
        (void) LsaClose(PolicyHandle);
        return( status );
    }

    (void) LsaClose(PolicyHandle);

    lstrcpy( DomainNamePtr , DomainInfo->DomainName.Buffer );

    (void) LsaFreeMemory((PVOID) DomainInfo);

    return( STATUS_SUCCESS );
}
#endif


BOOL CProfileDlg::createdir( LPTSTR szPath , BOOL bIsRemote , PDWORD pdwErr )
{
    int npos = 0;

    *pdwErr = ERROR_INVALID_NAME;

    if( bIsRemote )
    {
        // skip over three four whacks		

        npos = 2;

        if( szPath[0] != TEXT( '\\' ) && szPath[1] != TEXT( '\\' ) )
        {
            return FALSE;
        }

        for( int n = 0; n < 2 ; n++ )
        {
            while( szPath[ npos ] != TEXT( '\\' ) && szPath[ npos ] != TEXT( '\0' ) )
            {
                npos++;
            }

            if( szPath[ npos ] == TEXT( '\0' ) )
            {
                return FALSE;
            }

            npos++;
        }

    }
    else
    {
        if( szPath[1] != TEXT( ':' ) && szPath[2] != TEXT( '\\' ) )
        {
            return FALSE;
        }

        npos = 3;
    }

    SECURITY_ATTRIBUTES securityAttributes;

    ZeroMemory( &securityAttributes , sizeof( SECURITY_ATTRIBUTES ) );

    // its redundant to check the bIsRemote flag since for dsadmin createdir is only called for
    // UNC paths

    if( m_pUSht->GetDSAType() && bIsRemote )
    {
        //
        // From EricB's DSPROP_CreateHomeDirectory
        PSID psidAdmins = NULL;

        SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;

        if (!AllocateAndInitializeSid(&NtAuth,
                                      2,
                                      SECURITY_BUILTIN_DOMAIN_RID,
                                      DOMAIN_ALIAS_RID_ADMINS,
                                      0, 0, 0, 0, 0, 0,
                                      &psidAdmins  ) )
        {
            ODS( L"AllocateAndInitializeSid failed\n");
            *pdwErr = GetLastError( );
            return FALSE;
        }
        // build a DACL

        PACL pDacl;

        static const int nAceCount = 2;
        PSID pAceSid[nAceCount];

        pAceSid[0] = m_pUSht->GetUserSid( );
        pAceSid[1] = psidAdmins;

        EXPLICIT_ACCESS rgAccessEntry[nAceCount] = {0};

        for (int i = 0 ; i < nAceCount; i++)
        {
            rgAccessEntry[i].grfAccessPermissions = GENERIC_ALL;
            rgAccessEntry[i].grfAccessMode = GRANT_ACCESS;
            rgAccessEntry[i].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

            // build the trustee structs
            //
            BuildTrusteeWithSid(&(rgAccessEntry[i].Trustee),
                                pAceSid[i]);
        }

        // add the entries to the ACL
        //
        *pdwErr = SetEntriesInAcl( nAceCount, rgAccessEntry, NULL, &pDacl );

        if( *pdwErr != 0 )
        {
	        ODS( L"SetEntriesInAcl() failed\n" );

	        return FALSE;
        }

        // build a security descriptor and initialize it
        // in absolute format

        SECURITY_DESCRIPTOR securityDescriptor;
        PSECURITY_DESCRIPTOR pSecurityDescriptor = &securityDescriptor;

        if( !InitializeSecurityDescriptor( pSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) )
        {
            ODS( L"InitializeSecurityDescriptor() failed\n" );

            *pdwErr = GetLastError( );

            return FALSE;
        }

        // add DACL to security descriptor (must be in absolute format)

        if( !SetSecurityDescriptorDacl( pSecurityDescriptor,
                                        TRUE, // bDaclPresent
                                        pDacl,
                                        FALSE // bDaclDefaulted
                                        ) )
        {

            ODS( L"SetSecurityDescriptorDacl() failed\n" );

            *pdwErr = GetLastError( );

            return FALSE;
        }


        // set the owner of the directory
        if( !SetSecurityDescriptorOwner( pSecurityDescriptor ,
                                         m_pUSht->GetUserSid( ) ,
                                         FALSE // bOwnerDefaulted
                                         ) )
        {

            ODS( L"SetSecurityDescriptorOwner() failed\n" );

            *pdwErr = GetLastError( );

            return FALSE;
        }

        ASSERT_( IsValidSecurityDescriptor( pSecurityDescriptor ) );

        // build a SECURITY_ATTRIBUTES struct as argument for
        // CreateDirectory()

        securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);

        securityAttributes.lpSecurityDescriptor = pSecurityDescriptor;

        securityAttributes.bInheritHandle = FALSE;

        if( !CreateDirectory( szPath , &securityAttributes ) )
        {
            *pdwErr = GetLastError( );

            if( psidAdmins != NULL )
            {
                FreeSid( psidAdmins );
            }

            return FALSE;
        }	

        FreeSid( psidAdmins );
    }
	else
    {	
        while( szPath[ npos ] != TEXT( '\0' ) )
        {
            while( szPath[ npos ] != TEXT( '\\' ) && szPath[ npos ] != TEXT( '\0' ) )
            {
                npos++;
            }

            if( szPath[ npos ] == TEXT( '\0' ) )
            {
                if (!CreateSecureDir(szPath , pdwErr))
                {
                    ODS(L"CreateSecureDir failed\n");
                    return FALSE;
                }
            }
            else
            {
                szPath[ npos ] = 0;

                if (!CreateSecureDir(szPath , pdwErr))
                {
                    ODS(L"CreateSecureDir failed\n");
                    return FALSE;
                }

                szPath[ npos ] = TEXT( '\\' );

                npos++;
            }
        }
    }

    *pdwErr = 0;

    return TRUE;
}

DWORD
GetUserSid(LPCTSTR pwszAccountName, 
           LPCTSTR pwszServerName, 
           PSID* ppUserSid)
{
    DWORD        cbSid     = 0;
    DWORD        cbDomain  = 0;
    PSID         pSID      = NULL;
    LPTSTR       pszDomain = NULL;
    BOOL         bStatus;
    DWORD        dwStatus  = ERROR_SUCCESS;    
    SID_NAME_USE seUse;   

    bStatus = LookupAccountName(pwszServerName,
                                pwszAccountName,
                                NULL,
                                &cbSid,
                                NULL,
                                &cbDomain,
                                &seUse);
    if(!bStatus)
    {
        dwStatus = GetLastError();
        if(dwStatus != ERROR_INSUFFICIENT_BUFFER)
        {
            goto Cleanup;
        }
    }

    dwStatus = ERROR_SUCCESS;

    pSID = (PSID)LocalAlloc(LMEM_FIXED, cbSid );
    pszDomain = (LPTSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (cbDomain + 1));

    if(pSID == NULL || pszDomain == NULL)
    {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    bStatus = LookupAccountName(pwszServerName,
                                pwszAccountName,
                                pSID,
                                &cbSid,
                                pszDomain,
                                &cbDomain,
                                &seUse);

    if(!bStatus)
    {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    *ppUserSid = pSID;
    pSID = NULL;


Cleanup:
    if(pszDomain != NULL)
    {
        LocalFree(pszDomain);
    }

    if(pSID != NULL)
    {
        LocalFree(pSID);
    }

    return dwStatus;
} 


BOOL 
CProfileDlg::CreateSecureDir(LPTSTR szPath ,  PDWORD pdwErr)
{
    BOOL                     bRetVal    = TRUE;
    static const int         nAceCount  = 2;
    PACL                     pDacl      = NULL;
    PSID                     psidAdmins = NULL;
    PSID                     psidUser   = NULL;
    PSECURITY_DESCRIPTOR     pSD        = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuth     = SECURITY_NT_AUTHORITY;
    EXPLICIT_ACCESS          rgAccessEntry[nAceCount] = {0};
    SECURITY_ATTRIBUTES      securityAttributes;
    DWORD                    dwStatus;
    LPWSTR                   pszServer  = NULL;

    
    _ASSERT(szPath);   


    // Make sure a valid string is passed in
    if (szPath == NULL)
    {
        ODS( L"Path not valid.\n");
        return FALSE;
    }

    // Create a SID for the BUILTIN Administrators group.
    if (!AllocateAndInitializeSid(&NtAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &psidAdmins))
    {		
        ODS( L"AllocateAndInitializeSid failed\n");
        goto Error;
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow the Administrators group full access to the key.
    rgAccessEntry[0].grfAccessPermissions = GENERIC_ALL;
    rgAccessEntry[0].grfAccessMode = GRANT_ACCESS;
    rgAccessEntry[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

    // build the trustee structs  
    BuildTrusteeWithSid(&(rgAccessEntry[0].Trustee), psidAdmins);

    // Get the SID for the user
    m_pUSht->GetServer(&pszServer);
    if (pszServer == NULL)
    {
        ODS(L"GetServer() failed\n");
        bRetVal = FALSE;
        goto Cleanup;
    }

    dwStatus = GetUserSid(m_pUSht->GetUserName(), pszServer, &psidUser);
    if (dwStatus != ERROR_SUCCESS)
    {
        ODS(L"GetUserSid() failed\n");
        bRetVal = FALSE;
        goto Cleanup;
    }

    // Specify the access control for the selected User, (full access)
    rgAccessEntry[1].grfAccessPermissions = GENERIC_ALL;
    rgAccessEntry[1].grfAccessMode = GRANT_ACCESS;
    rgAccessEntry[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    rgAccessEntry[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    rgAccessEntry[1].Trustee.TrusteeType = TRUSTEE_IS_USER;  
    rgAccessEntry[1].Trustee.ptstrName = (LPWSTR)psidUser;
        
    // Create a new ACL that contains the new ACEs.
    *pdwErr = SetEntriesInAcl(nAceCount, rgAccessEntry, NULL, &pDacl);
    if(*pdwErr != 0)
    {   
        ODS(L"SetEntriesInAcl() failed\n");
        bRetVal = FALSE;
        goto Cleanup;
    }

    // Initialize a security descriptor.
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                                            SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pSD == NULL) 
    { 
        ODS( L"LocalAlloc Error\n" );
        goto Error;
    } 
     
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) {  
        ODS( L"InitializeSecurityDescriptor() failed\n" );
        goto Error;
    } 

    // Add the ACL to the security descriptor
    if(!SetSecurityDescriptorDacl(pSD,
                                  TRUE,   // bDaclPresent
                                  pDacl,
                                  FALSE)) // bDaclDefaulted
    {		
        ODS( L"SetSecurityDescriptorDacl() failed\n" );
        goto Error;
    }

    // Initialize a security attributes structure.
    ZeroMemory(&securityAttributes , sizeof(SECURITY_ATTRIBUTES));

    securityAttributes.nLength              = sizeof(pSD);
    securityAttributes.lpSecurityDescriptor = pSD;
    securityAttributes.bInheritHandle       = FALSE;

    if(!CreateDirectory(szPath, &securityAttributes))
    {
        *pdwErr = GetLastError();

        // If the directory already exists it's ok
        if (*pdwErr != ERROR_ALREADY_EXISTS)
        {
            ODS(L"CreateDirectory failed\n");
            ODS(szPath);
            goto Error;
        }
    }	

    *pdwErr = 0;


Cleanup:
    if (pDacl != NULL)
        LocalFree(pDacl);

    if (pSD != NULL)
        LocalFree(pSD); 
    
    if (psidAdmins != NULL)
        FreeSid(psidAdmins);

    if (pszServer != NULL)
        delete[] pszServer;

    if (psidUser != NULL)
        LocalFree(psidUser);

    return bRetVal;

Error:
    *pdwErr = GetLastError();
    bRetVal = FALSE;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsutil\aclnt.c ===
/*
 *  AclNt.c
 *
 *  Author: BreenH
 *
 *  Acl utilities in the NT flavor.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutilnt.h"

/*
 *  Function Implementations
 */

NTSTATUS NTAPI
NtConvertAbsoluteToSelfRelative(
    PSECURITY_DESCRIPTOR *ppSelfRelativeSd,
    PSECURITY_DESCRIPTOR pAbsoluteSd,
    PULONG pcbSelfRelativeSd
    )
{
#if DBG
    BOOLEAN fAbsoluteSd;
#endif
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR pSd;
    ULONG cbSd;

    ASSERT(ppSelfRelativeSd != NULL);
    ASSERT(pAbsoluteSd != NULL);
    ASSERT(NT_SUCCESS(NtIsSecurityDescriptorAbsolute(pAbsoluteSd,
            &fAbsoluteSd)));
    ASSERT(fAbsoluteSd);

    //
    //  Determine the buffer size needed to convert the security descriptor.
    //  Catch any exceptions due to an invalid descriptor.
    //

    cbSd = 0;

    __try
    {
        Status = RtlAbsoluteToSelfRelativeSD(
                pAbsoluteSd,
                NULL,
                &cbSd
                );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(STATUS_INVALID_SECURITY_DESCR);
    }

    //
    //  Allocate memory for the self-relative security descriptor.
    //

    pSd = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSd);

    if (pSd != NULL)
    {

        //
        //  Now convert the security descriptor using the allocated buffer.
        //  Catch any exceptions due to an invalid descriptor.
        //

        __try
        {
            Status = RtlAbsoluteToSelfRelativeSD(
                    pAbsoluteSd,
                    pSd,
                    &cbSd
                    );
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = STATUS_INVALID_SECURITY_DESCR;
        }

    }
    else
    {
        return(STATUS_NO_MEMORY);
    }

    if (NT_SUCCESS(Status))
    {

        //
        //  If the conversion succeeded, save the pointer to the security
        //  descriptor and return the size.
        //

        *ppSelfRelativeSd = pSd;

        if (pcbSelfRelativeSd != NULL)
        {
            *pcbSelfRelativeSd = cbSd;
        }
    }
    else
    {

        //
        //  If the conversion failed, free the memory and leave the input
        //  parameters alone.
        //

        LocalFree(pSd);
    }

    return(Status);
}

NTSTATUS NTAPI
NtConvertSelfRelativeToAbsolute(
    PSECURITY_DESCRIPTOR *ppAbsoluteSd,
    PSECURITY_DESCRIPTOR pSelfRelativeSd
    )
{
#if DBG
    BOOLEAN fAbsoluteSd;
#endif
    NTSTATUS Status;
    PACL pDacl;
    PACL pSacl;
    PSID pGroup;
    PSID pOwner;
    PSECURITY_DESCRIPTOR pSd;
    ULONG cbDacl;
    ULONG cbGroup;
    ULONG cbOwner;
    ULONG cbSacl;
    ULONG cbSd;

    ASSERT(ppAbsoluteSd != NULL);
    ASSERT(pSelfRelativeSd != NULL);
    ASSERT(NT_SUCCESS(NtIsSecurityDescriptorAbsolute(pSelfRelativeSd,
            &fAbsoluteSd)));
    ASSERT(!fAbsoluteSd);

    //
    //  Determine the size of each buffer needed to convert the security
    //  descriptor. Catch any exceptions due to an invalid descriptor.
    //

    cbDacl = 0;
    cbGroup = 0;
    cbOwner = 0;
    cbSacl = 0;
    cbSd = 0;

    __try
    {
        Status = RtlSelfRelativeToAbsoluteSD(
                pSelfRelativeSd,
                NULL, &cbSd,
                NULL, &cbDacl,
                NULL, &cbSacl,
                NULL, &cbOwner,
                NULL, &cbGroup
                );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(STATUS_INVALID_SECURITY_DESCR);
    }

    //
    //  Allocate memory for the security descriptor and its components.
    //

    pDacl = NULL;
    pGroup = NULL;
    pOwner = NULL;
    pSacl = NULL;

    if (cbDacl > 0)
    {
        pDacl = (PACL)LocalAlloc(LMEM_FIXED, cbDacl);

        if (pDacl == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto allocerror;
        }
    }

    if (cbGroup > 0)
    {
        pGroup = (PSID)LocalAlloc(LMEM_FIXED, cbGroup);

        if (pGroup == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto allocerror;
        }
    }

    if (cbOwner > 0)
    {
        pOwner = (PSID)LocalAlloc(LMEM_FIXED, cbOwner);

        if (pOwner == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto allocerror;
        }
    }

    if (cbSacl > 0)
    {
        pSacl = (PACL)LocalAlloc(LMEM_FIXED, cbSacl);

        if (pSacl == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto allocerror;
        }
    }

    ASSERT(cbSd > 0);

    pSd = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSd);

    if (pSd == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto allocerror;
    }

    //
    //  Now convert the security descriptor using the allocated buffer.
    //  Catch any exceptions due to an invalid descriptor.
    //

    __try
    {
        Status = RtlSelfRelativeToAbsoluteSD(
                pSelfRelativeSd,
                pSd, &cbSd,
                pDacl, &cbDacl,
                pSacl, &cbSacl,
                pOwner, &cbOwner,
                pGroup, &cbGroup
                );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INVALID_SECURITY_DESCR;
    }

    if (NT_SUCCESS(Status))
    {
        *ppAbsoluteSd = pSd;
        return(Status);
    }

    LocalFree(pSd);

allocerror:
    if (pSacl != NULL)
    {
        LocalFree(pSacl);
    }

    if (pOwner != NULL)
    {
        LocalFree(pOwner);
    }

    if (pGroup != NULL)
    {
        LocalFree(pGroup);
    }

    if (pDacl != NULL)
    {
        LocalFree(pDacl);
    }

    return(Status);
}

NTSTATUS NTAPI
NtDestroySecurityDescriptor(
    PSECURITY_DESCRIPTOR *ppSd
    )
{
    BOOLEAN fAbsolute;
    NTSTATUS Status;

    ASSERT(ppSd != NULL);
    ASSERT(*ppSd != NULL);

    Status = NtIsSecurityDescriptorAbsolute(*ppSd, &fAbsolute);

    if (NT_SUCCESS(Status))
    {
        if (fAbsolute)
        {
            PISECURITY_DESCRIPTOR pSd;
            PULONG_PTR pBeginning;
            PULONG_PTR pDacl;
            PULONG_PTR pEnd;
            PULONG_PTR pGroup;
            PULONG_PTR pOwner;
            PULONG_PTR pSacl;

            //
            //  An absolute security descriptor is much more complicated. The
            //  descriptor contains pointers to the other items (instead of
            //  offsets). This does not mean, however, that it is made up of
            //  more than one allocation. In fact, almost all absolute
            //  descriptors from the NT RTL are made of one allocation, with
            //  the internal pointers set to areas of memory inside the one
            //  allocation. This makes completely freeing a security
            //  descriptor a heinous effort. (As an aside, whats the point of
            //  creating an absolute security descriptor out of one chunk of
            //  memory? Just make it relative!)
            //
            //  Each component of the security descriptor may be NULL. For the
            //  Dacl and the Sacl, the f[D,S]aclPresent variable may be TRUE
            //  with a NULL [D,S]acl. Therefore, compare all pointers to NULL
            //  and against the security descriptor allocation before freeing.
            //
            //  The check to NtIsSecurityDescriptorAbsolute verifies that this
            //  is a valid security descriptor. Therefore it is safe to type
            //  cast here instead of making several RtlGetXSecurityDescriptor
            //  calls.
            //

            pSd = (PISECURITY_DESCRIPTOR)(*ppSd);

            pBeginning = (PULONG_PTR)(pSd);
            pEnd = (PULONG_PTR)((PBYTE)pBeginning + LocalSize(pSd));

            pDacl = (PULONG_PTR)(pSd->Dacl);
            pGroup = (PULONG_PTR)(pSd->Group);
            pOwner = (PULONG_PTR)(pSd->Owner);
            pSacl = (PULONG_PTR)(pSd->Sacl);

            //
            //  Handle the Dacl.
            //

            if (pDacl != NULL)
            {
                if ((pDacl > pEnd) || (pDacl < pBeginning))
                {
                    LocalFree(pDacl);
                }
            }

            //
            //  Handle the Group.
            //

            if (pGroup != NULL)
            {
                if ((pGroup > pEnd) || (pGroup < pBeginning))
                {
                    LocalFree(pGroup);
                }
            }

            //
            //  Handle the Owner.
            //

            if (pOwner != NULL)
            {
                if ((pOwner > pEnd) || (pOwner < pBeginning))
                {
                    LocalFree(pOwner);
                }
            }

            //
            //  Handle the Sacl.
            //

            if (pSacl != NULL)
            {
                if ((pSacl > pEnd) || (pSacl < pBeginning))
                {
                    LocalFree(pSacl);
                }
            }

        }
    }
    else
    {
        return(Status);
    }

    //
    //  If the security descriptor was absolute, the individual components
    //  have been freed, and now the security descriptor itself can be freed.
    //  If the security descriptor was self-relative, all the components are
    //  stored in the same block of memory, so free it all at once.
    //

    LocalFree(*ppSd);
    *ppSd = NULL;

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
NtIsSecurityDescriptorAbsolute(
    PSECURITY_DESCRIPTOR pSd,
    PBOOLEAN pfAbsolute
    )
{
    NTSTATUS Status;
    ULONG ulRevision;
    SECURITY_DESCRIPTOR_CONTROL wSdControl;

    ASSERT(pSd != NULL);
    ASSERT(pfAbsolute != NULL);

    Status = RtlGetControlSecurityDescriptor(pSd, &wSdControl, &ulRevision);

    if (NT_SUCCESS(Status))
    {

        //
        //  Don't cast away the TRUE into a FALSE when dropping from a DWORD
        //  to a UCHAR.
        //

        *pfAbsolute = (BOOLEAN)((wSdControl & SE_SELF_RELATIVE) ? TRUE : FALSE);
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsutil\misc.c ===
/*
 *  Misc.c
 *
 *  Author: BreenH
 *
 *  Miscellaneous utilities.
 */

/*
 *  Includes
 */

#include "precomp.h"

/*
 *  Function Implementations
 */

BOOL WINAPI
LoadStringResourceW(
    HMODULE hModule,
    UINT uiResourceId,
    PWSTR *ppString,
    PDWORD pcchString
    )
{
    BOOL fRet;
    INT iRet;
    PWSTR pROString;
    PWSTR pString;

    ASSERT(ppString != NULL);

    //
    //  Get a pointer to the string in memory. This string is the actual read-
    //  only memory into which the module is loaded. This string is not NULL
    //  terminated, so allocate a buffer and copy the exact number of bytes,
    //  then set the NULL terminator.
    //

    fRet = FALSE;
    pROString = NULL;

    iRet = LoadStringW(
            hModule,
            uiResourceId,
            (PWSTR)(&pROString),
            0
            );

    if (iRet > 0)
    {

        //
        //  For better performance, don't zero out the entire allocation just
        //  to copy the string. Zero out the last WCHAR to terminate the
        //  string.
        //

        pString = (PWSTR)LocalAlloc(LMEM_FIXED, (iRet + 1) * sizeof(WCHAR));

        if (pString != NULL)
        {
            RtlCopyMemory(pString, pROString, iRet * sizeof(WCHAR));

            pString[iRet] = (WCHAR)0;

            *ppString = pString;

            if (pcchString != NULL)
            {
                *pcchString = (DWORD)iRet;
            }

            fRet = TRUE;
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }
    }

    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsutil\user.c ===
/*
 *  User.c
 *
 *  Author: BreenH
 *
 *  User account utilities.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutil.h"
#include "tsutilnt.h"

/*
 *  Function Implementations
 */

BOOL WINAPI
CreateAdminSid(
    PSID *ppAdminSid
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtCreateAdminSid(ppAdminSid);

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}

BOOL WINAPI
CreateSystemSid(
    PSID *ppSystemSid
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtCreateSystemSid(ppSystemSid);

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}

BOOL WINAPI
IsUserMember(
    PSID pSid
    )
{
    BOOL fMember;
    BOOL fRet;

    ASSERT(pSid != NULL);

    fMember = FALSE;

    fRet = CheckTokenMembership(NULL, pSid, &fMember);

    return(fRet && fMember);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsutil\stringnt.c ===
/*
 *  String.c
 *
 *  Author: BreenH
 *
 *  String utilities in the NT flavor.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutilnt.h"

/*
 *  Function Implementations
 */

NTSTATUS NTAPI
NtAllocateAndCopyStringA(
    PSTR *ppDestination,
    PCSTR pString
    )
{
    NTSTATUS Status;
    PSTR pCopy;
    ULONG cbString;

    ASSERT(ppDestination != NULL);

    cbString = (lstrlenA(pString) + 1) * sizeof(CHAR);

    pCopy = LocalAlloc(LMEM_FIXED, cbString);

    if (pCopy != NULL)
    {
        RtlCopyMemory(pCopy, pString, cbString);
        *ppDestination = pCopy;
        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = STATUS_NO_MEMORY;
    }

    return(Status);
}

NTSTATUS NTAPI
NtAllocateAndCopyStringW(
    PWSTR *ppDestination,
    PCWSTR pString
    )
{
    NTSTATUS Status;
    PWSTR pCopy;
    ULONG cbString;

    ASSERT(ppDestination != NULL);
    ASSERT(pString != NULL);

    cbString = (lstrlenW(pString) + 1) * sizeof(WCHAR);

    pCopy = LocalAlloc(LMEM_FIXED, cbString);

    if (pCopy != NULL)
    {
        RtlCopyMemory(pCopy, pString, cbString);
        *ppDestination = pCopy;
        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = STATUS_NO_MEMORY;
    }

    return(Status);
}

NTSTATUS NTAPI
NtConvertAnsiToUnicode(
    PWSTR *ppUnicodeString,
    PCSTR pAnsiString
    )
{
    NTSTATUS Status;
    PWSTR pUnicodeString;
    ULONG cbAnsiString;
    ULONG cbBytesWritten;
    ULONG cbUnicodeString;

    ASSERT(ppUnicodeString != NULL);
    ASSERT(pAnsiString != NULL);

    //
    //  Get the number of bytes in the ANSI string, then get the number of
    //  bytes needed for the Unicode version. None of the Rtl... APIs include
    //  the NULL terminator in their calculations.
    //

    cbAnsiString = lstrlenA(pAnsiString);

    Status = RtlMultiByteToUnicodeSize(
            &cbUnicodeString,
            (PCHAR)pAnsiString,
            cbAnsiString
            );

    if (Status == STATUS_SUCCESS)
    {

        //
        //  Allocate a buffer for the Unicode string and its NULL terminator,
        //  then convert the string.
        //

        cbUnicodeString += sizeof(WCHAR);

        pUnicodeString = (PWSTR)LocalAlloc(LPTR, cbUnicodeString);

        if (pUnicodeString != NULL)
        {
            Status = RtlMultiByteToUnicodeN(
                    pUnicodeString,
                    cbUnicodeString,
                    &cbBytesWritten,
                    (PCHAR)pAnsiString,
                    cbAnsiString
                    );

            if (Status == STATUS_SUCCESS)
            {
                *ppUnicodeString = pUnicodeString;
            }
            else
            {
                LocalFree(pUnicodeString);
            }
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }

    return(Status);
}

NTSTATUS NTAPI
NtConvertUnicodeToAnsi(
    PSTR *ppAnsiString,
    PCWSTR pUnicodeString
    )
{
    NTSTATUS Status;
    PSTR pAnsiString;
    ULONG cbAnsiString;
    ULONG cbBytesWritten;
    ULONG cbUnicodeString;

    ASSERT(ppAnsiString != NULL);
    ASSERT(pUnicodeString != NULL);

    //
    //  Get the number of bytes in the ANSI string, then get the number of
    //  bytes needed for the Unicode version. None of the Rtl... APIs include
    //  the NULL terminator in their calculations.
    //

    cbUnicodeString = lstrlenW(pUnicodeString) * sizeof(WCHAR);

    Status = RtlUnicodeToMultiByteSize(
            &cbAnsiString,
            (PWSTR)pUnicodeString,
            cbUnicodeString
            );

    if (Status == STATUS_SUCCESS)
    {

        //
        //  Allocate a buffer for the Unicode string and its NULL terminator,
        //  then convert the string.
        //

        cbAnsiString += sizeof(CHAR);

        pAnsiString = (PSTR)LocalAlloc(LPTR, cbAnsiString);

        if (pAnsiString != NULL)
        {
            Status = RtlUnicodeToMultiByteN(
                    pAnsiString,
                    cbAnsiString,
                    &cbBytesWritten,
                    (PWSTR)pUnicodeString,
                    cbUnicodeString
                    );

            if (Status == STATUS_SUCCESS)
            {
                *ppAnsiString = pAnsiString;
            }
            else
            {
                LocalFree(pAnsiString);
            }
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsutil\string.c ===
/*
 *  String.c
 *
 *  Author: BreenH
 *
 *  String utilities.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutil.h"
#include "tsutilnt.h"

/*
 *  Function Implementations
 */

PSTR WINAPI
AllocateAndCopyStringA(
    PCSTR pString
    )
{
    NTSTATUS Status;
    PSTR pCopy;

    ASSERT(pString != NULL);

    pCopy = NULL;

    Status = NtAllocateAndCopyStringA(&pCopy, pString);

    if (NT_SUCCESS(Status))
    {
        return(pCopy);
    }
    else
    {
        SetLastError(RtlNtStatusToDosError(Status));
        return(NULL);
    }
}

PWSTR WINAPI
AllocateAndCopyStringW(
    PCWSTR pString
    )
{
    NTSTATUS Status;
    PWSTR pCopy;

    ASSERT(pString != NULL);

    pCopy = NULL;

    Status = NtAllocateAndCopyStringW(&pCopy, pString);

    if (NT_SUCCESS(Status))
    {
        return(pCopy);
    }
    else
    {
        SetLastError(RtlNtStatusToDosError(Status));
        return(NULL);
    }
}

BOOL WINAPI
ConvertAnsiToUnicode(
    PWSTR *ppUnicodeString,
    PCSTR pAnsiString
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtConvertAnsiToUnicode(ppUnicodeString, pAnsiString);

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}

BOOL WINAPI
ConvertUnicodeToAnsi(
    PSTR *ppAnsiString,
    PCWSTR pUnicodeString
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtConvertUnicodeToAnsi(ppAnsiString, pUnicodeString);

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsutil\usernt.c ===
/*
 *  UserNt.c
 *
 *  Author: BreenH
 *
 *  User account utilities in the NT flavor.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutilnt.h"

/*
 *  Function Implementations
 */

NTSTATUS NTAPI
NtCreateAdminSid(
    PSID *ppAdminSid
    )
{
    NTSTATUS Status;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    ASSERT(ppAdminSid != NULL);

    Status = RtlAllocateAndInitializeSid(
            &SidAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &pSid
            );

    if (NT_SUCCESS(Status))
    {
        *ppAdminSid = pSid;
    }

    return(Status);
}

NTSTATUS NTAPI
NtCreateSystemSid(
    PSID *ppSystemSid
    )
{
    NTSTATUS Status;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    ASSERT(ppSystemSid != NULL);

    Status = RtlAllocateAndInitializeSid(
            &SidAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pSid
            );

    if (NT_SUCCESS(Status))
    {
        *ppSystemSid = pSid;
    }

    return(Status);
}

NTSTATUS NTAPI
NtCreateAnonymousSid(
    PSID *ppAnonymousSid
    )
{
    NTSTATUS Status;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    ASSERT(ppAnonymousSid != NULL);

    Status = RtlAllocateAndInitializeSid(
            &SidAuthority,
            1,
            SECURITY_ANONYMOUS_LOGON_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pSid
            );

    if (NT_SUCCESS(Status))
    {
        *ppAnonymousSid = pSid;
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsutil\precomp.h ===
/*
 *  Precomp.h
 *
 *  Author: BreenH
 *
 *  Precompiled header for TS Util.
 */

//
//  Remove warning 4514: unreferenced inline function has been removed.
//  This comes up due to the code being compiled at /W4, even though the
//  precompiled header is at /W3.
//

#pragma warning(disable: 4514)

//
//  Most SDK headers can't survive /W4.
//

#pragma warning(push, 3)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#include <aclapi.h>
#include <ntlsapi.h>

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\tsutil\tsutil.c ===
/*
 *  TSUtil.c
 *
 *  Author: BreenH
 *
 *  Terminal Services utilities.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutil.h"

/*
 *  Function Implementations
 */

BOOL WINAPI
IsFullTerminalServicesEnabled(
    VOID
    )
{
    BOOL fRet;
    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wProductType = VER_NT_SERVER;
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    fRet = VerifyVersionInfo(
            &osVersionInfo,
            VER_PRODUCT_TYPE | VER_SUITENAME,
            dwlConditionMask
            );

    return(fRet);
}

BOOL WINAPI
IsPersonalTerminalServicesEnabled(
    VOID
    )
{
    BOOL fRet;
    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wProductType = VER_NT_WORKSTATION;
    osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    fRet = VerifyVersionInfo(
            &osVersionInfo,
            VER_PRODUCT_TYPE | VER_SUITENAME,
            dwlConditionMask
            );

    return(fRet);
}

BOOL WINAPI
IsTerminalServicesEnabled(
    VOID
    )
{
    BOOL fRet;
    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    fRet = VerifyVersionInfo(&osVersionInfo, VER_SUITENAME, dwlConditionMask);

    return(fRet);
}

BOOL WINAPI
IsPersonalWorkstation(
    VOID
    )
{
    BOOL fRet;
    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wProductType = VER_NT_WORKSTATION;
    osVersionInfo.wSuiteMask = VER_SUITE_PERSONAL;

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    fRet = VerifyVersionInfo(
            &osVersionInfo,
            VER_PRODUCT_TYPE | VER_SUITENAME,
            dwlConditionMask
            );

    return(fRet);
}

// Is this machine an Advanced Server or above
BOOL WINAPI
IsAdvancedServer(
    VOID
    )
{
    BOOL fRet;
    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;
    BOOL fSuiteAdvancedServer = FALSE;
    BOOL fSuiteDataCenter = FALSE;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_AND);

    osVersionInfo.wSuiteMask = VER_SUITE_ENTERPRISE;
    fSuiteAdvancedServer = VerifyVersionInfo(&osVersionInfo, VER_SUITENAME, dwlConditionMask);

    osVersionInfo.wSuiteMask = VER_SUITE_DATACENTER;
    fSuiteDataCenter = VerifyVersionInfo(&osVersionInfo,VER_SUITENAME,dwlConditionMask);

    fRet = fSuiteAdvancedServer || fSuiteDataCenter;

    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\import.h ===
/*++

Copyright Microsoft Corporation. 1998

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/

#ifdef MIDL_PASS
#define WIN32_LEAN_AND_MEAN
#endif

//#ifndef _NTDEF_
//typedef LONG NTSTATUS, *PNTSTATUS;
//#endif

//typedef unsigned long   DWORD;
//typedef unsigned char   BYTE;

//#include <windows.h>
//#include <winnt.h>
//#include <ntdef.h>
//#include <ntseapi.h>
//#include <ntpsapi.h>
//#include <ntkeapi.h>

#ifdef MIDL_PASS
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
//#include <windef.h>
//#include <wtypes.h>
typedef unsigned long   DWORD;
typedef unsigned char   BYTE, *PBYTE;
#endif

#include <allproc.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define PSECURITY_DESCRIPTOR DWORD
#define BOOL        DWORD
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\client\lcrpc-c.c ===
#include <lcrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\client\server.c ===
/*************************************************************************
*
* server.c
*
* Client side APIs for server-level administration
*
* Copyright Microsoft Corporation, 1999
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <allproc.h>

#include <winsta.h>

/*
 * Include the RPC generated common header
 */

#include "tsrpc.h"

#include "rpcwire.h"

#ifdef NTSDDEBUG
#define NTSDDBGPRINT(x) DbgPrint x
#else
#define NTSDDBGPRINT(x)
#endif

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*
 * This handle is returned when there is no terminal
 * server present on the system. (Non-Hydra)
 */
#define RPC_HANDLE_NO_SERVER (HANDLE)IntToPtr( 0xFFFFFFFD )


/*
 *  Private Procedures defined here
 */

/*
 *  Global data
 */

/*
 *  other internal Procedures used (not defined here)
 */

VOID WinStationConfigU2A( PWINSTATIONCONFIGA, PWINSTATIONCONFIGW );
ULONG CheckUserBuffer(WINSTATIONINFOCLASS,
                      PVOID,
                      ULONG,
                      PVOID *,
                      PULONG,
                      BOOLEAN *);

BOOLEAN
RpcLocalAutoBind(
    VOID
    );

/*
 * Check to see that caller does not hold the loader critsec.
 * WinStation APIs must NOT be called while holding the loader critsec
 * since deadlock may occur.
 */
#define CheckLoaderLock() \
        ASSERT( NtCurrentTeb()->ClientId.UniqueThread != \
            ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread );

/*
 * Handle the SERVERNAME_CURRENT for auto local binding.
 */
#define HANDLE_CURRENT_BINDING( hServer )                       \
    CheckLoaderLock();                                          \
    if( hServer == SERVERNAME_CURRENT ) {                       \
        if( IcaApi_IfHandle == NULL ) {                         \
            if( !RpcLocalAutoBind() ) {                         \
                return FALSE;                                   \
            }                                                   \
        }                                                       \
        hServer = IcaApi_IfHandle;                              \
    }                                                           \
    if( hServer == RPC_HANDLE_NO_SERVER ) {                     \
        *pResult = ERROR_APP_WRONG_OS;                          \
        return FALSE;                                           \
    }

/******************************************************************************
 *
 *  ServerGetInternetConnectorStatus
 *
 *    Returns whether Internet Connector licensing is being used
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and pfEnabled contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is in pResult
 *
 ******************************************************************************/

BOOLEAN
ServerGetInternetConnectorStatus(
    HANDLE   hServer,
    DWORD    *pResult,
    PBOOLEAN pfEnabled
    )
{
    BOOLEAN rc = FALSE;

    if (pResult == NULL)
    {
        goto Done;
    }

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcServerGetInternetConnectorStatus(hServer,
                                                 pResult,
                                                 pfEnabled
                                                 );

        *pResult = RtlNtStatusToDosError( *pResult );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        *pResult = RpcExceptionCode();
    }
    RpcEndExcept

Done:
    return rc;
}

/******************************************************************************
 *
 *  ServerSetInternetConnectorStatus
 *
 *    This function will (if fEnabled has changed from its previous setting):
 *       Check that the caller has administrative privileges,
 *       Modify the corresponding value in the registry,
 *       Change licensing mode (between normal per-seat and Internet Connector.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is in pResult
 *
 ******************************************************************************/

BOOLEAN
ServerSetInternetConnectorStatus(
    HANDLE   hServer,
    DWORD    *pResult,
    BOOLEAN  fEnabled
    )
{
    BOOLEAN rc = FALSE;

    if (pResult == NULL)
    {
        goto Done;
    }

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcServerSetInternetConnectorStatus(hServer,
                                                 pResult,
                                                 fEnabled
                                                 );

        // STATUS_LICENSE_VIOLATION has no DOS error to map to
        if (*pResult != STATUS_LICENSE_VIOLATION)
            *pResult = RtlNtStatusToDosError( *pResult );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        *pResult = RpcExceptionCode();
    }
    RpcEndExcept

Done:
    return rc;
}

/*******************************************************************************
 *
 *  ServerQueryInetConnectorInformationA (ANSI stub)
 *
 *    Queries the server for internet connector configuration information.
 *
 * ENTRY:
 *
 *    see ServerQueryInetConnectorInformationW
 *
 * EXIT:
 *
 *    see ServerQueryInetConnectorInformationW
 *
 ******************************************************************************/

BOOLEAN
ServerQueryInetConnectorInformationA(
        HANDLE hServer,
        PVOID  pWinStationInformation,
        ULONG WinStationInformationLength,
        PULONG  pReturnLength
        )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

/*******************************************************************************
 *
 *  ServerQueryInetConnectorInformationW (UNICODE)
 *
 *    Queries the server for internet connector configuration information.
 *
 * ENTRY:
 *
 *    WinStationHandle (input)
 *       Identifies the window station object. The handle must have
 *       WINSTATION_QUERY access.
 *
 *    pWinStationInformation (output)
 *       A pointer to a buffer that will receive information about the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being queried.
 *
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 *    pReturnLength (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes placed in the window station information buffer.
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
ServerQueryInetConnectorInformationW(
        HANDLE hServer,
        PVOID  pWinStationInformation,
        ULONG WinStationInformationLength,
        PULONG  pReturnLength
        )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\client\icarpc.c ===
/****************************************************************************/
// icarpc.c
//
// winsta.dll RPC client code for interaction with termsrv.exe.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <winsta.h>
#include <icadd.h>

#include "rpcwire.h"


/****************************************************************************
 * ValidUserBuffer
 *
 *   This function verifies that the caller if WinStationQueryInformation/
 *   WinStationSetInformation has the correct structure size (i.e. client
 *   application built with the same header files as winsta.dll).
 *
 * ENTRY:
 *   BufferSize
 *     The size of the bufferr.
 *
 *   InfoClass
 *     The WinStationQuery/Set information class.
 *
 * EXIT:
 *     Retures TRUE if the buffer is valid, otherwise FALSE.
 ****************************************************************************/
BOOLEAN ValidUserBuffer(ULONG BufferSize, WINSTATIONINFOCLASS InfoClass)
{
    switch (InfoClass) {
        case WinStationLoadIndicator:
            return(BufferSize >= sizeof(WINSTATIONLOADINDICATORDATA));

        case WinStationCreateData:
            return(BufferSize == sizeof(WINSTATIONCREATEW));

        case WinStationConfiguration:
            return(BufferSize == sizeof(WINSTATIONCONFIGW));

        case WinStationPdParams:
            return(BufferSize == sizeof(PDPARAMSW));

        case WinStationWd:
            return(BufferSize == sizeof(WDCONFIGW));

        case WinStationPd:
            return(BufferSize == sizeof(PDCONFIGW));

        case WinStationPrinter:
            return(BufferSize == sizeof(WINSTATIONPRINTERW));

        case WinStationClient:
            return(BufferSize == sizeof(WINSTATIONCLIENTW));

        case WinStationModules:
            return(TRUE);

        case WinStationInformation:
            return(BufferSize == sizeof(WINSTATIONINFORMATIONW));

        case WinStationTrace:
            return(BufferSize == sizeof(ICA_TRACE));

        case WinStationBeep:
            return(BufferSize == sizeof(BEEPINPUT));

        case WinStationEncryptionOff:
        case WinStationEncryptionPerm:
        case WinStationNtSecurity:
            return(TRUE);

        case WinStationUserToken:
            return(BufferSize == sizeof(WINSTATIONUSERTOKEN));

        case WinStationVideoData:
        case WinStationInitialProgram:
        case WinStationCd:
        case WinStationSystemTrace:
        case WinStationVirtualData:
            return(TRUE); // Not Implemented - let server handle it

        case WinStationClientData:
            return(BufferSize >= sizeof(WINSTATIONCLIENTDATA));

        case WinStationLoadBalanceSessionTarget:
            return (BufferSize >= sizeof(ULONG));

        case WinStationShadowInfo:
            return(BufferSize == sizeof(WINSTATIONSHADOW));

        case WinStationDigProductId:
                        return(BufferSize >= sizeof(WINSTATIONPRODID));

        case WinStationLockedState:
             return(BufferSize >= sizeof(BOOL));

        case WinStationRemoteAddress:
            return(BufferSize >= sizeof(WINSTATIONREMOTEADDRESS));

        case WinStationIdleTime:
             return(BufferSize >= sizeof(ULONG));

        case WinStationLastReconnectType: 
            return(BufferSize >= sizeof(ULONG));       

        case WinStationDisallowAutoReconnect: 
            return(BufferSize >= sizeof(BOOLEAN));      
            
        case WinStationExecSrvSystemPipe:
            return(BufferSize >= ( EXECSRVPIPENAMELEN * sizeof(WCHAR) ) );

        case WinStationMprNotifyInfo: 
            return(BufferSize >= sizeof(ExtendedClientCredentials));

        case WinStationSDRedirectedSmartCardLogon: 
            return(BufferSize >= sizeof(BOOLEAN));      

        case WinStationIsAdminLoggedOn: 
            return(BufferSize >= sizeof(BOOLEAN));      

        default:
            return(FALSE);
    }
}


/****************************************************************************
 * CreateGenericWireBuf
 *
 *   This function creates a generic wire buffer for structures which may
 *   have new fields added to the end.
 *
 * ENTRY:
 *
 *   DataSize (input)
 *     The size of the structure.
 *   pBuffer (output)
 *     Pointer to the allocated buffer.
 *   pBufSize (output)
 *     Pointer to the wire buffer size.
 *
 * EXIT:
 *     Returns ERROR_SUCCESS if successful. If successful, pBuffer
 *     contains the generic wire buffer.
 ****************************************************************************/
ULONG CreateGenericWireBuf(ULONG DataSize, PVOID *ppBuffer, PULONG pBufSize)
{
    ULONG BufSize;
    PVARDATA_WIRE pVarData;

    BufSize = sizeof(VARDATA_WIRE) + DataSize;
    if ((pVarData = (PVARDATA_WIRE)LocalAlloc(0,BufSize)) == NULL)
        return(ERROR_NOT_ENOUGH_MEMORY);

    InitVarData(pVarData, DataSize, sizeof(VARDATA_WIRE));
    *ppBuffer = (PVOID) pVarData;
    *pBufSize = BufSize;
    return ERROR_SUCCESS;
}


/****************************************************************************
 * CheckUserBuffer
 *
 *   This function determines if the buffer type should be converted to a
 *   wire format. If so, a wire buffer is allocated.
 *
 * ENTRY:
 *   InfoClass (input)
 *     WinStationQuery/Set information class.
 *
 *   UserBuf(input)
 *     The client bufferr.
 *
 *   UserBufLen (input)
 *     The client buffer length.
 *
 *   ppWireBuf(output)
 *     Pointer to wirebuf pointer, updated with allocated wire buffer if
 *     BufAllocated is TRUE.
 *  pWireBufLen (output)
 *     Pointer to the length of the wire buffer allocated, updated if
 *     BufAllocated is TRUE.
 *  pBufAllocated (output)
 *     Pointer to flag indicating if a wire buffer was allocated.
 * EXIT:
 *     Returns ERROR_SUCCESS if successful. If successful, BufAllocated
 *     indicated whether a wire buffer was allocated.
 *     on failure, an error code is returned.
 ****************************************************************************/
ULONG CheckUserBuffer(
        WINSTATIONINFOCLASS InfoClass,
        PVOID UserBuf,
        ULONG UserBufLen,
        PVOID *ppWireBuf,
        PULONG pWireBufLen,
        BOOLEAN *pBufAllocated)
{
    ULONG BufSize;
    ULONG Error;
    PPDCONFIGWIREW PdConfigWire;
    PPDCONFIGW PdConfig;
    PPDPARAMSWIREW PdParamsWire;
    PPDPARAMSW PdParam;
    PWINSTACONFIGWIREW WinStaConfigWire;
    PWINSTATIONCONFIGW WinStaConfig;
    PVOID WireBuf;

    if (!ValidUserBuffer(UserBufLen, InfoClass)) {
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    switch (InfoClass) {
        case WinStationPd:
            BufSize = sizeof(PDCONFIGWIREW) + sizeof(PDCONFIG2W) + sizeof(PDPARAMSW);
            if ((WireBuf = (PCHAR)LocalAlloc(0,BufSize)) == NULL)
                return(ERROR_NOT_ENOUGH_MEMORY);

            PdConfigWire = (PPDCONFIGWIREW)WireBuf;
            InitVarData(&PdConfigWire->PdConfig2W,
                        sizeof(PDCONFIG2W),
                        sizeof(PDCONFIGWIREW));
            InitVarData(&PdConfigWire->PdParams.SdClassSpecific,
                        sizeof(PDPARAMSW) - sizeof(SDCLASS),
                        NextOffset(&PdConfigWire->PdConfig2W));
            break;
        case WinStationPdParams:
            BufSize = sizeof(PDPARAMSWIREW) + sizeof(PDPARAMSW);
            if ((WireBuf = (PCHAR)LocalAlloc(0,BufSize)) == NULL)
                return(ERROR_NOT_ENOUGH_MEMORY);

            PdParamsWire = (PPDPARAMSWIREW)WireBuf;
            InitVarData(&PdParamsWire->SdClassSpecific,
                        sizeof(PDPARAMSW),
                        sizeof(PDPARAMSWIREW));
            break;

        case WinStationConfiguration:
            BufSize = sizeof(WINSTACONFIGWIREW) + sizeof(USERCONFIGW);
            if ((WireBuf = (PCHAR)LocalAlloc(0,BufSize)) == NULL)
                return(ERROR_NOT_ENOUGH_MEMORY);

            WinStaConfigWire = (PWINSTACONFIGWIREW)WireBuf;
            InitVarData(&WinStaConfigWire->UserConfig,
                        sizeof(USERCONFIGW),
                        sizeof(WINSTACONFIGWIREW));
            InitVarData(&WinStaConfigWire->NewFields,
                        0,
                        NextOffset(&WinStaConfigWire->UserConfig));
            break;

        case WinStationInformation:
            if ((Error = CreateGenericWireBuf(sizeof(WINSTATIONINFORMATIONW),
                                              &WireBuf,
                                              &BufSize)) != ERROR_SUCCESS)
                return(Error);
            break;

        case WinStationWd:
            if ((Error = CreateGenericWireBuf(sizeof(WDCONFIGW),
                                              &WireBuf,
                                              &BufSize)) != ERROR_SUCCESS)
                return(Error);
            break;

         case WinStationClient:
            if ((Error = CreateGenericWireBuf(sizeof(WINSTATIONCLIENTW),
                                              &WireBuf,
                                              &BufSize)) != ERROR_SUCCESS)
                return(Error);
            break;
 
        default:
            *ppWireBuf = NULL;
            *pBufAllocated = FALSE;
            return ERROR_SUCCESS;
    }

    *pWireBufLen = BufSize;
    *ppWireBuf = WireBuf;
    *pBufAllocated = TRUE;
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\rpcwire.h ===
/***************************************************************************
*
*  RPCWIRE.H
*
*  This module contains structures passed over the wire between winsta.dll 
*  and icasrv.
*
*  Copyright Microsoft Corporation. 1998
*
****************************************************************************/

#ifndef __RPCWIRE_H__
#define __RPCWIRE_H__

#ifdef __cplusplus
extern "C" {
#endif

// Common structure for variable length data
typedef struct _VARDATA_WIRE {
    USHORT Size;
    USHORT Offset;
} VARDATA_WIRE, *PVARDATA_WIRE;

// Wire structure for WINSTATIONCONFIGW
// WinStationQuery/SetInfo ( WinStationConfiguration )
typedef struct _WINSTACONFIGWIREW {
    WCHAR Comment[WINSTATIONCOMMENT_LENGTH + 1];
    char OEMId[4];
    VARDATA_WIRE UserConfig;  // Embedded structure
    VARDATA_WIRE NewFields;   // For any new fields added after UserConfig
    // Variable length data follows - UserConfig and new fields added
} WINSTACONFIGWIREW, *PWINSTACONFIGWIREW;

// Wire structure for PDPARAMSW
// WinStationQueryInformation( WinStationPdParams )
typedef struct _PDPARAMSWIREW {
    SDCLASS SdClass;
    VARDATA_WIRE SdClassSpecific;  // Embedded union
    // Variable length PdClass specific data follows
} PDPARAMSWIREW, *PPDPARAMSWIREW;

// Wire structure for PDCONFIGW
// WinStationQueryInformation( WinStationPd)
typedef struct _PDCONFIGWIREW {
    VARDATA_WIRE PdConfig2W;  // Embedded structure
    PDPARAMSWIREW PdParams;   // Enbedded structure
    // Variable length data follows
} PDCONFIGWIREW, *PPDCONFIGWIREW;

// Wire structure for WLX_CLIENT_CREDENTIALS_V2_0
typedef struct _WLXCLIENTCREDWIREW {
    DWORD dwType;
    BOOL fDisconnectOnLogonFailure;
    BOOL fPromptForPassword;
    VARDATA_WIRE UserNameData;
    VARDATA_WIRE DomainData;
    VARDATA_WIRE PasswordData;
    // Variable data starts here
} WLXCLIENTCREDWIREW, *PWLXCLIENTCREDWIREW;

// common routines
VOID InitVarData(PVARDATA_WIRE pVarData, ULONG Size, ULONG Offset);
ULONG NextOffset(PVARDATA_WIRE PrevData);
ULONG CopySourceToDest(PCHAR SourceBuf, ULONG SourceSize,
                       PCHAR DestBuf, ULONG DestSize);
VOID CopyPdParamsToWire(PPDPARAMSWIREW PdParamsWire, PPDPARAMSW PdParams);
VOID CopyPdParamsFromWire(PPDPARAMSWIREW PdParamsWire, PPDPARAMSW PdParams);
VOID CopyPdConfigToWire(PPDCONFIGWIREW PdConfigWire, PPDCONFIGW PdConfig);
VOID CopyPdConfigFromWire(PPDCONFIGWIREW PdConfigWire, PPDCONFIGW PdConfig);
VOID CopyWinStaConfigToWire(PWINSTACONFIGWIREW WinStaConfigWire,
                            PWINSTATIONCONFIGW WinStaConfig);
VOID CopyWinStaConfigFromWire(PWINSTACONFIGWIREW WinStaConfigWire,
                              PWINSTATIONCONFIGW WinStaConfig);
BOOLEAN CopyInWireBuf(WINSTATIONINFOCLASS InfoClass,
                      PVOID UserBuf, PVOID WireBuf);
BOOLEAN CopyOutWireBuf(WINSTATIONINFOCLASS InfoClass,
                       PVOID UserBuf,PVOID WireBuf);
ULONG AllocateAndCopyCredToWire(PWLXCLIENTCREDWIREW *ppWire,
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCredentials);
BOOLEAN CopyCredFromWire(PWLXCLIENTCREDWIREW pWire,
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCredentials);

/*
 *  Licensing Core wire typedefs and function prototypes
 */

typedef struct {
    ULONG ulVersion;
    VARDATA_WIRE PolicyNameData;
    VARDATA_WIRE PolicyDescriptionData;
    //  Variable data begins here.
} LCPOLICYINFOWIRE_V1, *LPLCPOLICYINFOWIRE_V1;

ULONG
CopyPolicyInformationToWire(
    LPLCPOLICYINFOGENERIC *ppWire,
    LPLCPOLICYINFOGENERIC pPolicyInfo
    );

BOOLEAN
CopyPolicyInformationFromWire(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo,
    LPLCPOLICYINFOGENERIC pWire
    );

#ifdef __cplusplus
}
#endif

#endif  // __RPCWIRE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\client\tsrpc-c.c ===
#include <tsrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\client\lscore.c ===
/*
 *  LsCore.c
 *
 *  Author: BreenH
 *
 *  Client side functions to call the licensing core RPC interface.
 */

/*
 *  Includes
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsta.h>
#include <license.h>
#include "lcrpc.h"
#include "rpcwire.h"

/*
 *  External Globals and Function Prototypes
 */

extern RTL_CRITICAL_SECTION WstHandleLock;
extern LPWSTR pszOptions;
extern LPWSTR pszProtocolSequence;
extern LPWSTR pszRemoteProtocolSequence;

RPC_STATUS
RpcWinStationBind(
    LPWSTR pszUuid,
    LPWSTR pszProtocolSequence,
    LPWSTR pszNetworkAddress,
    LPWSTR pszEndPoint,
    LPWSTR pszOptions,
    RPC_BINDING_HANDLE *pHandle
    );

/*
 *  Internal Function Prototypes
 */

BOOLEAN
ConvertAnsiToUnicode(
    LPWSTR *ppUnicodeString,
    LPSTR pAnsiString
    );

BOOLEAN
ConvertUnicodeToAnsi(
    LPSTR *ppAnsiString,
    LPWSTR pUnicodeString
    );

BOOLEAN
ConvertPolicyInformationA2U(
    LPLCPOLICYINFOGENERIC *ppPolicyInfoW,
    LPLCPOLICYINFOGENERIC pPolicyInfoA
    );

BOOLEAN
ConvertPolicyInformationU2A(
    LPLCPOLICYINFOGENERIC *ppPolicyInfoA,
    LPLCPOLICYINFOGENERIC pPolicyInfoW
    );

BOOLEAN
LcRpcBindLocal(
    VOID
    );

/*
 *  Macros borrowed from winsta.c. RPC_HANDLE_NO_SERVER is not supported
 *  for the license core RPC calls. This means that no license core RPC call
 *  to the local machine will differentiate between "not a TS box" and "server
 *  not available".
 */

#define CheckLoaderLock() \
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread != \
        ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread);

#define HANDLE_CURRENT_BINDING(hServer) \
    CheckLoaderLock(); \
    if (hServer == SERVERNAME_CURRENT) \
    { \
        if (LCRPC_IfHandle == NULL) \
        { \
            if (!LcRpcBindLocal()) \
            { \
                return(FALSE); \
            } \
        } \
        hServer = LCRPC_IfHandle; \
    }

/*
 *  Function Implementations
 */

BOOLEAN
ConvertAnsiToUnicode(
    LPWSTR *ppUnicodeString,
    LPSTR pAnsiString
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;
    ULONG cbAnsiString;
    ULONG cbBytesWritten;
    ULONG cbUnicodeString;

    ASSERT(ppUnicodeString != NULL);
    ASSERT(pAnsiString != NULL);

    cbAnsiString = lstrlenA(pAnsiString);

    Status = RtlMultiByteToUnicodeSize(
        &cbUnicodeString,
        pAnsiString,
        cbAnsiString
        );

    if (Status == STATUS_SUCCESS)
    {
        cbUnicodeString += sizeof(WCHAR);

        *ppUnicodeString = (LPWSTR)LocalAlloc(LPTR, cbUnicodeString);

        if (*ppUnicodeString != NULL)
        {
            Status = RtlMultiByteToUnicodeN(
                *ppUnicodeString,
                cbUnicodeString,
                &cbBytesWritten,
                pAnsiString,
                cbAnsiString
                );

            if (Status == STATUS_SUCCESS)
            {
                fRet = TRUE;
            }
            else
            {
                LocalFree(*ppUnicodeString);
                *ppUnicodeString = NULL;
                SetLastError(RtlNtStatusToDosError(Status));
                fRet = FALSE;
            }
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            fRet = FALSE;
        }
    }
    else
    {
        SetLastError(RtlNtStatusToDosError(Status));
        fRet = FALSE;
    }

    return(fRet);
}

BOOLEAN
ConvertUnicodeToAnsi(
    LPSTR *ppAnsiString,
    LPWSTR pUnicodeString
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;
    ULONG cbAnsiString;
    ULONG cbBytesWritten;
    ULONG cbUnicodeString;

    ASSERT(ppAnsiString != NULL);
    ASSERT(pUnicodeString != NULL);

    cbUnicodeString = lstrlenW(pUnicodeString) * sizeof(WCHAR);

    Status = RtlUnicodeToMultiByteSize(
        &cbAnsiString,
        pUnicodeString,
        cbUnicodeString
        );

    if (Status == STATUS_SUCCESS)
    {
        cbAnsiString += sizeof(CHAR);

        *ppAnsiString = (LPSTR)LocalAlloc(LPTR, cbAnsiString);

        if (*ppAnsiString != NULL)
        {
            Status = RtlUnicodeToMultiByteN(
                *ppAnsiString,
                cbAnsiString,
                &cbBytesWritten,
                pUnicodeString,
                cbUnicodeString
                );

            if (Status == STATUS_SUCCESS)
            {
                fRet = TRUE;
            }
            else
            {
                LocalFree(*ppAnsiString);
                *ppAnsiString = NULL;
                SetLastError(RtlNtStatusToDosError(Status));
                fRet = FALSE;
            }
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            fRet = FALSE;
        }
    }
    else
    {
        SetLastError(RtlNtStatusToDosError(Status));
        fRet = FALSE;
    }

    return(fRet);
}

BOOLEAN
ConvertPolicyInformationA2U(
    LPLCPOLICYINFOGENERIC *ppPolicyInfoW,
    LPLCPOLICYINFOGENERIC pPolicyInfoA
    )
{
    BOOLEAN fRet;

    ASSERT(ppPolicyInfoW != NULL);
    ASSERT(pPolicyInfoA != NULL);

    if (pPolicyInfoA->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        LPLCPOLICYINFO_V1W *ppPolicyInfoV1W;
        LPLCPOLICYINFO_V1A pPolicyInfoV1A;

        ppPolicyInfoV1W = (LPLCPOLICYINFO_V1W*)ppPolicyInfoW;
        pPolicyInfoV1A = (LPLCPOLICYINFO_V1A)pPolicyInfoA;

        *ppPolicyInfoV1W = LocalAlloc(LPTR, sizeof(LPLCPOLICYINFO_V1W));

        if (*ppPolicyInfoV1W != NULL)
        {
            (*ppPolicyInfoV1W)->ulVersion = LCPOLICYINFOTYPE_V1;

            fRet = ConvertAnsiToUnicode(
                &((*ppPolicyInfoV1W)->lpPolicyName),
                pPolicyInfoV1A->lpPolicyName
                );

            if (fRet)
            {
                fRet = ConvertAnsiToUnicode(
                    &((*ppPolicyInfoV1W)->lpPolicyDescription),
                    pPolicyInfoV1A->lpPolicyDescription
                    );
            }

            if (fRet)
            {
                goto exit;
            }

            if ((*ppPolicyInfoV1W)->lpPolicyName != NULL)
            {
                LocalFree((*ppPolicyInfoV1W)->lpPolicyName);
            }

            if ((*ppPolicyInfoV1W)->lpPolicyDescription != NULL)
            {
                LocalFree((*ppPolicyInfoV1W)->lpPolicyDescription);
            }

            LocalFree(*ppPolicyInfoV1W);
            *ppPolicyInfoV1W = NULL;
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            fRet = FALSE;
        }
    }
    else
    {
        SetLastError(ERROR_UNKNOWN_REVISION);
        fRet = FALSE;
    }

exit:
    return(fRet);
}

BOOLEAN
ConvertPolicyInformationU2A(
    LPLCPOLICYINFOGENERIC *ppPolicyInfoA,
    LPLCPOLICYINFOGENERIC pPolicyInfoW
    )
{
    BOOLEAN fRet;

    ASSERT(ppPolicyInfoA != NULL);
    ASSERT(pPolicyInfoW != NULL);

    if (pPolicyInfoW->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        LPLCPOLICYINFO_V1A *ppPolicyInfoV1A;
        LPLCPOLICYINFO_V1W pPolicyInfoV1W;

        ppPolicyInfoV1A = (LPLCPOLICYINFO_V1A*)ppPolicyInfoA;
        pPolicyInfoV1W = (LPLCPOLICYINFO_V1W)pPolicyInfoW;

        *ppPolicyInfoV1A = LocalAlloc(LPTR, sizeof(LPLCPOLICYINFO_V1W));

        if (*ppPolicyInfoV1A != NULL)
        {
            (*ppPolicyInfoV1A)->ulVersion = LCPOLICYINFOTYPE_V1;

            fRet = ConvertUnicodeToAnsi(
                &((*ppPolicyInfoV1A)->lpPolicyName),
                pPolicyInfoV1W->lpPolicyName
                );

            if (fRet)
            {
                fRet = ConvertUnicodeToAnsi(
                    &((*ppPolicyInfoV1A)->lpPolicyDescription),
                    pPolicyInfoV1W->lpPolicyDescription
                    );
            }

            if (fRet)
            {
                goto exit;
            }

            if ((*ppPolicyInfoV1A)->lpPolicyName != NULL)
            {
                LocalFree((*ppPolicyInfoV1A)->lpPolicyName);
            }

            if ((*ppPolicyInfoV1A)->lpPolicyDescription != NULL)
            {
                LocalFree((*ppPolicyInfoV1A)->lpPolicyDescription);
            }

            LocalFree(*ppPolicyInfoV1A);
            *ppPolicyInfoV1A = NULL;
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            fRet = FALSE;
        }
    }
    else
    {
        SetLastError(ERROR_UNKNOWN_REVISION);
        fRet = FALSE;
    }

exit:
    return(fRet);
}

BOOLEAN
LcRpcBindLocal(
    VOID
    )
{
    //
    //  Borrow the TSRPC handle critical section.
    //

    RtlEnterCriticalSection(&WstHandleLock);

    if (LCRPC_IfHandle == NULL)
    {
        LCRPC_IfHandle = ServerLicensingOpenW(NULL);

        if (LCRPC_IfHandle == NULL)
        {
            SetLastError(RPC_S_INVALID_BINDING);
            RtlLeaveCriticalSection(&WstHandleLock);
            return(FALSE);
        }
    }

    RtlLeaveCriticalSection(&WstHandleLock);

    return(TRUE);
}

HANDLE WINAPI
ServerLicensingOpenW(
    LPWSTR pServerName
    )
{
    BOOLEAN fRet;
    HANDLE hServer;
    NTSTATUS Status;
    RPC_STATUS RpcStatus;
    RPC_BINDING_HANDLE RpcHandle;

    if (pServerName == NULL)
    {
        if (!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer)))
        {
            return(NULL);
        }

        RpcStatus = RpcWinStationBind(
            LC_RPC_UUID,
            pszProtocolSequence,
            NULL,
            LC_RPC_LRPC_EP,
            pszOptions,
            &RpcHandle
            );
    }  
    else
    {
        SetLastError(RPC_S_SERVER_UNAVAILABLE);
        return(NULL);
    }

    if (RpcStatus != RPC_S_OK)
    {
        SetLastError(RPC_S_SERVER_UNAVAILABLE);
        RpcBindingFree(&RpcHandle);
        return(NULL);
    }

    __try
    {
        hServer = NULL;

        fRet = RpcLicensingOpenServer(RpcHandle, &hServer, &Status);

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    RpcBindingFree(&RpcHandle);

    return(fRet ? hServer : NULL);
}

HANDLE WINAPI
ServerLicensingOpenA(
    LPSTR pServerName
    )
{
    BOOLEAN fRet;
    HANDLE hServer;
    ULONG cchServerName;

    if (pServerName == NULL)
    {
        return(ServerLicensingOpenW(NULL));
    }
    else
    {
        hServer = NULL;
        SetLastError(RPC_S_SERVER_UNAVAILABLE);
    }
    
    return(hServer);
}

VOID WINAPI
ServerLicensingClose(
    HANDLE hServer
    )
{
    //
    //  Don't try to close the define for the local server, and don't allow
    //  the auto-binding handle to be closed.
    //

    if ((hServer == SERVERNAME_CURRENT) || (hServer == LCRPC_IfHandle))
    {
        return;
    }

    __try
    {
        RpcLicensingCloseServer(&hServer);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
}

BOOLEAN WINAPI
ServerLicensingLoadPolicy(
    HANDLE hServer,
    ULONG ulPolicyId
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;

    HANDLE_CURRENT_BINDING(hServer);

    __try
    {
        fRet = RpcLicensingLoadPolicy(hServer, ulPolicyId, &Status);

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    return(fRet);
}

BOOLEAN WINAPI
ServerLicensingUnloadPolicy(
    HANDLE hServer,
    ULONG ulPolicyId
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;

    HANDLE_CURRENT_BINDING(hServer);

    __try
    {
        fRet = RpcLicensingUnloadPolicy(hServer, ulPolicyId, &Status);

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    return(fRet);
}

DWORD WINAPI
ServerLicensingSetPolicy(
    HANDLE hServer,
    ULONG ulPolicyId,
    LPDWORD lpNewPolicyStatus
    )
{
    BOOLEAN fRet;
    DWORD dwRet;
    NTSTATUS Status;
    NTSTATUS NewPolicyStatus;

    HANDLE_CURRENT_BINDING(hServer);

    if (lpNewPolicyStatus == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    __try
    {
        Status = RpcLicensingSetPolicy(hServer, ulPolicyId, &NewPolicyStatus);

        dwRet = RtlNtStatusToDosError(Status);
        *lpNewPolicyStatus = RtlNtStatusToDosError(NewPolicyStatus);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwRet = GetExceptionCode();
        *lpNewPolicyStatus = ERROR_SUCCESS;
    }

    return(dwRet);
}

BOOLEAN WINAPI
ServerLicensingGetAvailablePolicyIds(
    HANDLE hServer,
    PULONG *ppulPolicyIds,
    PULONG pcPolicies
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;

    HANDLE_CURRENT_BINDING(hServer);

    if ((ppulPolicyIds == NULL) || (pcPolicies == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    *pcPolicies = 0;

    __try
    {
        fRet = RpcLicensingGetAvailablePolicyIds(hServer, ppulPolicyIds, pcPolicies, &Status);

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    return(fRet);
}

BOOLEAN WINAPI
ServerLicensingGetPolicy(
    HANDLE hServer,
    PULONG pulPolicyId
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;

    HANDLE_CURRENT_BINDING(hServer);

    if (pulPolicyId == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    __try
    {
        fRet = RpcLicensingGetPolicy(hServer, pulPolicyId, &Status);

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    return(fRet);
}

BOOLEAN WINAPI
ServerLicensingGetPolicyInformationW(
    HANDLE hServer,
    ULONG ulPolicyId,
    PULONG pulVersion,
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    )
{
    BOOLEAN fRet;
    LPLCPOLICYINFOGENERIC pWire;
    NTSTATUS Status;
    ULONG cbPolicyInfo;

    HANDLE_CURRENT_BINDING(hServer);

    if ((ppPolicyInfo == NULL) || (pulVersion == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    *pulVersion = min(*pulVersion, LCPOLICYINFOTYPE_CURRENT);

    pWire = NULL;
    cbPolicyInfo = 0;

    __try
    {
        fRet = RpcLicensingGetPolicyInformation(
            hServer,
            ulPolicyId,
            pulVersion,
            (PCHAR*)&pWire,
            &cbPolicyInfo,
            &Status
            );

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    if (fRet)
    {
        fRet = CopyPolicyInformationFromWire(ppPolicyInfo, pWire);

        MIDL_user_free(pWire);
    }

    return(fRet);
}

BOOLEAN WINAPI
ServerLicensingGetPolicyInformationA(
    HANDLE hServer,
    ULONG ulPolicyId,
    PULONG pulVersion,
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    )
{
    BOOLEAN fRet;
    LPLCPOLICYINFOGENERIC pPolicyInfoW;
    NTSTATUS Status;

    if (ppPolicyInfo == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pPolicyInfoW = NULL;

    fRet = ServerLicensingGetPolicyInformationW(
        hServer,
        ulPolicyId,
        pulVersion,
        &pPolicyInfoW
        );

    if (fRet)
    {
        fRet = ConvertPolicyInformationU2A(ppPolicyInfo, pPolicyInfoW);

        ServerLicensingFreePolicyInformation(&pPolicyInfoW);
    }

    return(fRet);
}

VOID
ServerLicensingFreePolicyInformation(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    )
{
    if ((ppPolicyInfo != NULL) && (*ppPolicyInfo != NULL))
    {
        if ((*ppPolicyInfo)->ulVersion == LCPOLICYINFOTYPE_V1)
        {
            LPLCPOLICYINFO_V1 pPolicyInfoV1 = (LPLCPOLICYINFO_V1)(*ppPolicyInfo);

            if (pPolicyInfoV1->lpPolicyName != NULL)
            {
                LocalFree(pPolicyInfoV1->lpPolicyName);
            }

            if (pPolicyInfoV1->lpPolicyDescription != NULL)
            {
                LocalFree(pPolicyInfoV1->lpPolicyDescription);
            }

            LocalFree(pPolicyInfoV1);
            pPolicyInfoV1 = NULL;
        }
    }
}

BOOLEAN WINAPI
ServerLicensingDeactivateCurrentPolicy(
    HANDLE hServer
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;

    HANDLE_CURRENT_BINDING(hServer);

    __try
    {
        fRet = RpcLicensingDeactivateCurrentPolicy(hServer, &Status);

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\rpcwire.c ===
/*************************************************************************
*
* rpcwire.c
*
* Common functions for converting internal WinStation API structures 
* to/from a wire format which enables interoperability between various
* releases of icasrv and winsta.dll.
*
* Copyright Microsoft Corporation. 1998
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <wincrypt.h>
#include <winsta.h>

#include "rpcwire.h"

//
//  Allocation routines as defined by the client/server.
//
extern void * MIDL_user_allocate(size_t);
extern void MIDL_user_free( void * ); 


/*****************************************************************************
 *
 *  InitVarData
 *
 *   Initialize a generic structure which describes variable length data
 *   within a wire buffer.
 *
 * ENTRY:
 *   pVarData (input)
 *     The structure to initialize.
 *   Size (input)
 *     The size of the variable length data.
 *   Offset (input)
 *     The offset to the start of the data in the wire buffer.
 *
 ****************************************************************************/

VOID InitVarData(PVARDATA_WIRE pVarData,
                 ULONG Size,
                 ULONG Offset)
{
    pVarData->Size = (USHORT) Size;
    pVarData->Offset = (USHORT) Offset;
}

/*****************************************************************************
 *
 *  NextOffset
 *
 *   Returns the offset to the next variable length data area.
 *
 * ENTRY:
 *   PrevData (input)
 *     The current last variable length data area.
 *
 *****************************************************************************/

ULONG NextOffset(PVARDATA_WIRE PrevData)
{
    return(PrevData->Offset + PrevData->Size);
}

/*****************************************************************************
 *
 *  SdClassSize
 *
 *   Returns the actual size of the data associated with a given SdClass.
 *
 * ENTRY:
 *   SdClass (input)
 *     The type of Sd.
 *
 * EXIT
 *   Returns the data size if known otherwise 0.
 *****************************************************************************/

ULONG SdClassSize(SDCLASS SdClass)
{
    switch (SdClass) {
    case SdNetwork:   return(sizeof(NETWORKCONFIGW));
    case SdAsync:     return(sizeof(ASYNCCONFIGW));
    case SdNasi:      return(sizeof(NASICONFIGW));
    case SdOemFilter: return(sizeof(OEMTDCONFIGW));
#ifdef notdef
    // These cases are valid in 1.7
    case SdConsole:   return(sizeof(CONSOLECONFIGW));
    case SdFrame:     return(sizeof(FRAMECONFIG));
    case SdReliable:  return(sizeof(RELIABLECONFIG));
    case SdCompress:  return(sizeof(COMPRESSCONFIG));
    case SdModem:     return(sizeof(MODEMCONFIGW));
#endif
    default:
        return(0);
    }
}

/*****************************************************************************
 *
 *  CopySourceToDest
 *
 *   Copies variable length data to/from local/wire buffers. If the source
 *   buffer is smaller than the destination buffer, the destination buffer
 *   is zero filled after SourceSize, upto DestSize. (e.g. client queries
 *   down-level icasrv).  If the source buffer is larger than the
 *   destination buffer, the data is truncated at DestSize (e.g. down-level
 *   client queries newer icasrv). 
 *
 * ENTRY:
 *   SourceBuf (input)
 *     Source buffer 
 *   SourceSize (input)
 *     Source buffer size
 *   DestBuf (input)
 *     Destination buffer
 *   DestSize (input)
 *     Destiantion buffer size
 *
 * EXIT
 *   Returns the amount of data copied.
 *****************************************************************************/

ULONG CopySourceToDest(PCHAR SourceBuf, ULONG SourceSize,
                       PCHAR DestBuf, ULONG DestSize)
{
    ULONG DataSize;

    if (SourceSize >= DestSize ) {
        memcpy(DestBuf, SourceBuf, DestSize);
        DataSize = DestSize;
    } 
    else {
        // Down-level server/client (zero fill)
        memcpy(DestBuf, SourceBuf, SourceSize);
        memset(DestBuf+SourceSize, 0, DestSize - SourceSize);
        DataSize = SourceSize;
    }
    return(DataSize);
}

/*****************************************************************************
 *
 *  CopyPdParamsToWire
 *
 *   Copies a PDPARAMSW structure to a wire buffer.
 *
 * ENTRY:
 *   PdParamsWire (input)
 *     Destination wire buffer 
 *   PdParams (input)
 *     Source PDPARAMSW structure
 *
 *****************************************************************************/

VOID
CopyPdParamsToWire(PPDPARAMSWIREW PdParamsWire, PPDPARAMSW PdParams)
{
    ULONG Size;
    ULONG DataSize;

    PdParamsWire->SdClass = PdParams->SdClass; 
    Size = SdClassSize(PdParams->SdClass);
    DataSize = CopySourceToDest((PCHAR)&PdParams->Network,
                                Size,
                                (PCHAR)PdParamsWire +
                                PdParamsWire->SdClassSpecific.Offset,
                                PdParamsWire->SdClassSpecific.Size);

    PdParamsWire->SdClassSpecific.Size = (USHORT)DataSize;
}

/*****************************************************************************
 *
 *  CopyPdParamsFromWire
 *
 *   Copies a wire buffer to a PDPARAMSW structure.
 *
 * ENTRY:
 *   PdParamsWire (input)
 *     Source wire buffer 
 *   PdParams (input)
 *     Destination PDPARAMSW structure.
 *
 *****************************************************************************/

VOID
CopyPdParamsFromWire(PPDPARAMSWIREW PdParamsWire, PPDPARAMSW PdParams)
{
    ULONG Size;

    PdParams->SdClass = PdParamsWire->SdClass; 
    Size = SdClassSize(PdParams->SdClass);
    CopySourceToDest((PCHAR)PdParamsWire + PdParamsWire->SdClassSpecific.Offset,
                     PdParamsWire->SdClassSpecific.Size,
                     (PCHAR)&PdParams->Network,
                     Size);
}

/*****************************************************************************
 *
 *  CopyPdConfigToWire
 *
 *   Copies a PDCONFIGW structure to a wire buffer.
 *
 * ENTRY:
 *   PdConfigWire (input)
 *     Destination wire buffer 
 *   PdConfig (input)
 *     Source PDCONFIGW structure
 *
 *****************************************************************************/

VOID CopyPdConfigToWire(PPDCONFIGWIREW PdConfigWire, PPDCONFIGW PdConfig)
{
    CopySourceToDest((PCHAR) &PdConfig->Create, sizeof(PDCONFIG2W),
                     (PCHAR)PdConfigWire + PdConfigWire->PdConfig2W.Offset,
                     PdConfigWire->PdConfig2W.Size);
    CopyPdParamsToWire(&PdConfigWire->PdParams,&PdConfig->Params);

}

/*****************************************************************************
 *
 *  CopyPdConfigFromWire
 *
 *   Copies a wire buffer to a PDCONFIGW structure.
 *
 * ENTRY:
 *   PdConfigWire (input)
 *     Destination wire buffer 
 *   PdConfig (input)
 *     Source PDCONFIGW structure
 *
 *****************************************************************************/

VOID CopyPdConfigFromWire(PPDCONFIGWIREW PdConfigWire, PPDCONFIGW PdConfig)
{
    CopySourceToDest((PCHAR)PdConfigWire + PdConfigWire->PdConfig2W.Offset,
                     PdConfigWire->PdConfig2W.Size,
                     (PCHAR) &PdConfig->Create, sizeof(PDCONFIG2W));
    CopyPdParamsFromWire(&PdConfigWire->PdParams,&PdConfig->Params);
}

/*****************************************************************************
 *
 *  CopyWinStaConfigToWire
 *
 *   Copies a WINSTATIONCONFIGW structure to a wire buffer.
 *
 * ENTRY:
 *   WinStaConfigWire (input)
 *     Destination wire buffer 
 *   WinStaConfig (input)
 *     Source WINSTATIONCONFIGW structure
 *
 *****************************************************************************/

VOID CopyWinStaConfigToWire(PWINSTACONFIGWIREW WinStaConfigWire,
                            PWINSTATIONCONFIGW WinStaConfig)
{
    CopySourceToDest((PCHAR) &WinStaConfig->User, sizeof(USERCONFIGW),
                     (PCHAR)WinStaConfigWire+WinStaConfigWire->UserConfig.Offset,
                     WinStaConfigWire->UserConfig.Size);
    CopySourceToDest((PCHAR)&WinStaConfig->Comment,
                     sizeof(WinStaConfig->Comment),
                     (PCHAR)&WinStaConfigWire->Comment,
                     sizeof(WinStaConfigWire->Comment));
    CopySourceToDest((PCHAR)&WinStaConfig->OEMId,
                     sizeof(WinStaConfig->OEMId),
                     (PCHAR)&WinStaConfigWire->OEMId,
                     sizeof(WinStaConfigWire->OEMId));
    CopySourceToDest((PCHAR)&WinStaConfig + sizeof(WINSTATIONCONFIGW),
                     0, // Change this when new fields are added
                     (PCHAR)WinStaConfigWire+WinStaConfigWire->NewFields.Offset,
                     WinStaConfigWire->NewFields.Size);

}

/*****************************************************************************
 *
 *  CopyWinStaConfigFromWire
 *
 *   Copies a wire buffer to a WINSTATIONCONFIGW structure.
 *
 * ENTRY:
 *   WinStaConfigWire (input)
 *     Source wire buffer 
 *   WinStaConfig (input)
 *     Destiantion WINSTATIONCONFIGW structure
 *
 *****************************************************************************/

VOID CopyWinStaConfigFromWire(PWINSTACONFIGWIREW WinStaConfigWire,
                              PWINSTATIONCONFIGW WinStaConfig)
{
    CopySourceToDest((PCHAR)WinStaConfigWire+WinStaConfigWire->UserConfig.Offset,
                     WinStaConfigWire->UserConfig.Size,
                     (PCHAR) &WinStaConfig->User, sizeof(USERCONFIGW));

    CopySourceToDest((PCHAR)&WinStaConfigWire->Comment,
                     sizeof(WinStaConfigWire->Comment),
                     (PCHAR)&WinStaConfig->Comment,
                     sizeof(WinStaConfig->Comment));

    CopySourceToDest((PCHAR)&WinStaConfigWire->OEMId,
                     sizeof(WinStaConfigWire->OEMId),
                     (PCHAR)&WinStaConfig->OEMId,
                     sizeof(WinStaConfig->OEMId));

    CopySourceToDest((PCHAR)WinStaConfigWire+WinStaConfigWire->NewFields.Offset,
                     WinStaConfigWire->NewFields.Size,
                     (PCHAR) &WinStaConfig + sizeof(WINSTATIONCONFIGW),
                     0); // Change this when new fields are added
    
}

/*****************************************************************************
 *
 *  CopyGenericToWire
 *
 *   Copies a single variable length structure to a wire buffer.
 *
 * ENTRY:
 *   WireBuf (input)
 *     Destination wire buffer 
 *   LocalBuf (input)
 *     Source structure
 *   LocalBufLength (input)
 *     Source structure length
 *****************************************************************************/

VOID CopyGenericToWire(PVARDATA_WIRE WireBuf, PVOID LocalBuf, ULONG LocalBufLen)
{
    CopySourceToDest((PCHAR)LocalBuf,
                     LocalBufLen,
                     (PCHAR) WireBuf + WireBuf->Offset,
                     WireBuf->Size);
}

/*****************************************************************************
 *
 *  CopyGenericFromWire
 *
 *   Copies a wire buffer to a single variable length structure.
 *
 * ENTRY:
 *   WireBuf (input)
 *     Source wire buffer 
 *   LocalBuf (input)
 *     Destination structure
 *   LocalBufLength (input)
 *     Destination structure length
 *****************************************************************************/

VOID CopyGenericFromWire(PVARDATA_WIRE WireBuf, PVOID LocalBuf, ULONG LocalBufLen)
{
    CopySourceToDest((PCHAR) WireBuf + WireBuf->Offset,
                     WireBuf->Size,
                     (PCHAR)LocalBuf,
                     LocalBufLen);
}

/*****************************************************************************
 *
 *  CopyOutWireBuf
 *
 *   Copies a wire buffer to a local structure.
 *
 * ENTRY:
 *   InfoClass (input)
 *     WinStationQuery/Set information class
 *   UserBuf (input)
 *     Destination local structure
 *   WireBuf
 *     Source wire buffer 
 *****************************************************************************/

BOOLEAN
CopyOutWireBuf(WINSTATIONINFOCLASS InfoClass,
               PVOID UserBuf,
               PVOID WireBuf)
{
    ULONG BufSize;
    PPDCONFIGWIREW PdConfigWire;
    PPDCONFIGW PdConfig;
    PPDPARAMSWIREW PdParamsWire;
    PPDPARAMSW PdParam;
    PWINSTACONFIGWIREW WinStaConfigWire;
    PWINSTATIONCONFIGW WinStaConfig;

    switch (InfoClass) {
    case WinStationPd:
        PdConfigWire = (PPDCONFIGWIREW)WireBuf;
        PdConfig = (PPDCONFIGW)UserBuf;
        CopyPdConfigFromWire(PdConfigWire, PdConfig);
        break;
    case WinStationPdParams:
        PdParamsWire = (PPDPARAMSWIREW)WireBuf;

        CopyPdParamsFromWire(PdParamsWire,
                             (PPDPARAMS)UserBuf);
        break;

    case WinStationConfiguration:
        WinStaConfigWire = (PWINSTACONFIGWIREW)WireBuf;
        WinStaConfig = (PWINSTATIONCONFIGW)UserBuf;

        CopyWinStaConfigFromWire(WinStaConfigWire, WinStaConfig);
        break;

    case WinStationInformation:
        CopyGenericFromWire((PVARDATA_WIRE)WireBuf,
                            UserBuf,
                            sizeof(WINSTATIONINFORMATIONW));
        break;

    case WinStationWd:
        CopyGenericFromWire((PVARDATA_WIRE)WireBuf,
                            UserBuf,
                            sizeof(WDCONFIGW));
        break;

    case WinStationClient:
        CopyGenericFromWire((PVARDATA_WIRE)WireBuf,
                            UserBuf,
                            sizeof(WINSTATIONCLIENTW));
        break;

    default:
        return(FALSE);

    }

    return(TRUE);
}

/*****************************************************************************
 *
 *  CopyInWireBuf
 *
 *   Copies a local structure to a wire buffer.
 *
 * ENTRY:
 *   InfoClass (input)
 *     WinStationQuery/Set information class
 *   WireBuf (input)
 *     Destination wire buffer
 *   UserBuf (input)
 *     Destination local structure
 *****************************************************************************/

BOOLEAN
CopyInWireBuf(WINSTATIONINFOCLASS InfoClass,
              PVOID UserBuf,
              PVOID WireBuf)
{
    ULONG BufSize;
    PPDCONFIGWIREW PdConfigWire;
    PPDCONFIGW PdConfig;
    PPDPARAMSWIREW PdParamsWire;
    PPDPARAMSW PdParam;
    PWINSTACONFIGWIREW WinStaConfigWire;
    PWINSTATIONCONFIGW WinStaConfig;

    switch (InfoClass) {
    case WinStationPd:
        PdConfigWire = (PPDCONFIGWIREW)WireBuf;
        PdConfig = (PPDCONFIGW)UserBuf;
        CopyPdConfigToWire(PdConfigWire, PdConfig);
        break;
    case WinStationPdParams:
        PdParamsWire = (PPDPARAMSWIREW)WireBuf;

        CopyPdParamsToWire(PdParamsWire,
                           (PPDPARAMS)UserBuf);
        break;

    case WinStationConfiguration:
        WinStaConfigWire = (PWINSTACONFIGWIREW)WireBuf;
        WinStaConfig = (PWINSTATIONCONFIGW)UserBuf;

        CopyWinStaConfigToWire(WinStaConfigWire, WinStaConfig);
        break;

    case WinStationInformation:
        CopyGenericToWire((PVARDATA_WIRE)WireBuf,
                          UserBuf,
                          sizeof(WINSTATIONINFORMATIONW));
        break;

    case WinStationWd:
        CopyGenericToWire((PVARDATA_WIRE)WireBuf,
                          UserBuf,
                          sizeof(WDCONFIGW));
        break;

    case WinStationClient:
        CopyGenericToWire((PVARDATA_WIRE)WireBuf,
                          UserBuf,
                          sizeof(WINSTATIONCLIENTW));
        break;

    default:
        return(FALSE);

    }

    return(TRUE);
}

/*****************************************************************************
 *
 *  AllocateAndCopyCredToWire
 *
 *   Allocates a buffer big enough for the credentials and then copies them in.
 *
 *****************************************************************************/

ULONG
AllocateAndCopyCredToWire(
    PWLXCLIENTCREDWIREW *ppWire,
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCredentials
    )
{
    ULONG cchUserName;
    ULONG cchDomain;
    ULONG cchPassword;
    ULONG cbWireBuf;
    //Password length in characrters alligned by CRYPTPROTECTMEMORY_BLOCK_SIZE
    ULONG cchPasswordEx;

    cchUserName = lstrlenW(pCredentials->pszUserName) + 1;
    cchDomain = lstrlenW(pCredentials->pszDomain) + 1;
    cchPassword = lstrlenW(pCredentials->pszPassword) + 1;
    
    //Make it multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE (for encryption)
    cchPasswordEx =cchPassword + CRYPTPROTECTMEMORY_BLOCK_SIZE - 
        (cchPassword%CRYPTPROTECTMEMORY_BLOCK_SIZE);

    cbWireBuf = sizeof(WLXCLIENTCREDWIREW) +
        (cchUserName + cchDomain + cchPasswordEx) * sizeof(WCHAR);

    *ppWire = MIDL_user_allocate(cbWireBuf);

    if (*ppWire != NULL)
    {
        ZeroMemory(*ppWire, cbWireBuf);
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(0);
    }

    (*ppWire)->dwType = pCredentials->dwType;
    (*ppWire)->fDisconnectOnLogonFailure = pCredentials->fDisconnectOnLogonFailure;
    (*ppWire)->fPromptForPassword = pCredentials->fPromptForPassword;

    InitVarData(
        &((*ppWire)->UserNameData),
        cchUserName * sizeof(WCHAR),
        sizeof(WLXCLIENTCREDWIREW)
        );
    CopyMemory(
        (LPBYTE)(*ppWire) + (*ppWire)->UserNameData.Offset,
        pCredentials->pszUserName,
        (*ppWire)->UserNameData.Size
        );

    InitVarData(
        &((*ppWire)->DomainData),
        cchDomain * sizeof(WCHAR),
        NextOffset(&((*ppWire)->UserNameData))
        );
    CopyMemory(
        (LPBYTE)(*ppWire) + (*ppWire)->DomainData.Offset,
        pCredentials->pszDomain,
        (*ppWire)->DomainData.Size
        );

    InitVarData(
        &((*ppWire)->PasswordData),
        cchPasswordEx * sizeof(WCHAR),
        NextOffset(&((*ppWire)->DomainData))
        );
    CopyMemory(
        (LPBYTE)(*ppWire) + (*ppWire)->PasswordData.Offset,
        pCredentials->pszPassword,
        cchPassword * sizeof(WCHAR)
        );
    
    //Encrypt password, so it won't hang around in clear text in RPC internal buffers.
    if(!CryptProtectMemory((LPBYTE)(*ppWire) + (*ppWire)->PasswordData.Offset,
        (*ppWire)->PasswordData.Size, CRYPTPROTECTMEMORY_SAME_LOGON))
    {
        DWORD Err = GetLastError();
        RtlSecureZeroMemory((LPBYTE)(*ppWire) + (*ppWire)->PasswordData.Offset,
            (*ppWire)->PasswordData.Size);
        MIDL_user_free(*ppWire);
        *ppWire = NULL;
        SetLastError(Err);
        return 0;
    }

    return(cbWireBuf);
}

/*****************************************************************************
 *
 *  CopyCredFromWire
 *
 *   Copies credentials from the wire buffer.
 *
 *****************************************************************************/

BOOLEAN
CopyCredFromWire(
    PWLXCLIENTCREDWIREW pWire,
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCredentials
    )
{
    BOOLEAN fRet;

    pCredentials->pszUserName = LocalAlloc(
        LMEM_FIXED,
        pWire->UserNameData.Size
        );

    if (pCredentials->pszUserName != NULL)
    {
        CopyMemory(
            (LPBYTE)(pCredentials->pszUserName),
            (LPBYTE)pWire + pWire->UserNameData.Offset,
            pWire->UserNameData.Size
            );
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fRet = FALSE;
        goto exit;
    }

    pCredentials->pszDomain = LocalAlloc(
        LMEM_FIXED,
        pWire->DomainData.Size
        );

    if (pCredentials->pszDomain != NULL)
    {
        CopyMemory(
            (LPBYTE)(pCredentials->pszDomain),
            (LPBYTE)pWire + pWire->DomainData.Offset,
            pWire->DomainData.Size
            );
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fRet = FALSE;
        goto exit;
    }

    pCredentials->pszPassword = LocalAlloc(
        LMEM_FIXED,
        pWire->PasswordData.Size
        );

    if (pCredentials->pszPassword != NULL)
    {
        if(CryptUnprotectMemory((LPBYTE)pWire + pWire->PasswordData.Offset,
            pWire->PasswordData.Size, 
            CRYPTPROTECTMEMORY_SAME_LOGON))
        {
            CopyMemory(
                (LPBYTE)(pCredentials->pszPassword),
                (LPBYTE)pWire + pWire->PasswordData.Offset,
                pWire->PasswordData.Size
                );
        }
        else
        {
            fRet = FALSE;
            goto exit;
        }
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fRet = FALSE;
        goto exit;
    }

    pCredentials->dwType = pWire->dwType;
    pCredentials->fDisconnectOnLogonFailure = pWire->fDisconnectOnLogonFailure;
    pCredentials->fPromptForPassword = pWire->fPromptForPassword;

    fRet = TRUE;

exit:
    if (!fRet)
    {
        if (pCredentials->pszUserName != NULL)
        {
            LocalFree(pCredentials->pszUserName);
            pCredentials->pszUserName = NULL;
        }

        if (pCredentials->pszDomain != NULL)
        {
            LocalFree(pCredentials->pszDomain);
            pCredentials->pszDomain = NULL;
        }

        if (pCredentials->pszPassword != NULL)
        {
            LocalFree(pCredentials->pszPassword);
            pCredentials->pszPassword = NULL;
        }
    }

    return(fRet);
}

/*
 *  Licensing Core functions
 */

ULONG
CopyPolicyInformationToWire(
    LPLCPOLICYINFOGENERIC *ppWire,
    LPLCPOLICYINFOGENERIC pPolicyInfo
    )
{
    ULONG ulReturn;

    ASSERT(ppWire != NULL);
    ASSERT(pPolicyInfo != NULL);

    if (pPolicyInfo->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        LPLCPOLICYINFOWIRE_V1 *ppWireV1;
        LPLCPOLICYINFO_V1W pPolicyInfoV1;
        ULONG cbPolicyName;
        ULONG cbPolicyDescription;

        ppWireV1 = (LPLCPOLICYINFOWIRE_V1*)ppWire;
        pPolicyInfoV1 = (LPLCPOLICYINFO_V1W)pPolicyInfo;
        cbPolicyName = (lstrlenW(pPolicyInfoV1->lpPolicyName) + 1) * sizeof(WCHAR);
        cbPolicyDescription = (lstrlenW(pPolicyInfoV1->lpPolicyDescription) + 1) * sizeof(WCHAR);

        ulReturn = sizeof(LCPOLICYINFOWIRE_V1);
        ulReturn += cbPolicyName;
        ulReturn += cbPolicyDescription;

        *ppWireV1 = MIDL_user_allocate(ulReturn);

        if (*ppWireV1 != NULL)
        {
            (*ppWireV1)->ulVersion = LCPOLICYINFOTYPE_V1;

            InitVarData(
                &((*ppWireV1)->PolicyNameData),
                cbPolicyName,
                sizeof(LCPOLICYINFOWIRE_V1)
                );
            CopyMemory(
                (LPBYTE)(*ppWireV1) + (*ppWireV1)->PolicyNameData.Offset,
                pPolicyInfoV1->lpPolicyName,
                (*ppWireV1)->PolicyNameData.Size
                );

            InitVarData(
                &((*ppWireV1)->PolicyDescriptionData),
                cbPolicyDescription,
                NextOffset(&((*ppWireV1)->PolicyNameData))
                );
            CopyMemory(
                (LPBYTE)(*ppWireV1) + (*ppWireV1)->PolicyDescriptionData.Offset,
                pPolicyInfoV1->lpPolicyDescription,
                (*ppWireV1)->PolicyDescriptionData.Size
                );
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            ulReturn = 0;
        }
    }
    else
    {
        SetLastError(ERROR_UNKNOWN_REVISION);
        ulReturn = 0;
    }

    return(ulReturn);
}

BOOLEAN
CopyPolicyInformationFromWire(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo,
    LPLCPOLICYINFOGENERIC pWire
    )
{
    BOOLEAN fRet;

    ASSERT(ppPolicyInfo != NULL);
    ASSERT(pWire != NULL);

    if (pWire->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        LPLCPOLICYINFO_V1W *ppPolicyInfoV1;
        LPLCPOLICYINFOWIRE_V1 pWireV1;

        ppPolicyInfoV1 = (LPLCPOLICYINFO_V1W*)ppPolicyInfo;
        pWireV1 = (LPLCPOLICYINFOWIRE_V1)pWire;

        *ppPolicyInfoV1 = LocalAlloc(LPTR, sizeof(LCPOLICYINFO_V1W));

        if (*ppPolicyInfoV1 != NULL)
        {
            (*ppPolicyInfoV1)->ulVersion = LCPOLICYINFOTYPE_V1;

            (*ppPolicyInfoV1)->lpPolicyName = LocalAlloc(LPTR, pWireV1->PolicyNameData.Size);

            if ((*ppPolicyInfoV1)->lpPolicyName != NULL)
            {
                CopyMemory(
                    (LPBYTE)((*ppPolicyInfoV1)->lpPolicyName),
                    (LPBYTE)pWireV1 + pWireV1->PolicyNameData.Offset,
                    pWireV1->PolicyNameData.Size
                    );
            }
            else
            {
                SetLastError(ERROR_OUTOFMEMORY);
                fRet = FALSE;
                goto V1error;
            }

            (*ppPolicyInfoV1)->lpPolicyDescription = LocalAlloc(LPTR, pWireV1->PolicyDescriptionData.Size);

            if ((*ppPolicyInfoV1)->lpPolicyDescription != NULL)
            {
                CopyMemory(
                    (LPBYTE)((*ppPolicyInfoV1)->lpPolicyDescription),
                    (LPBYTE)pWireV1 + pWireV1->PolicyDescriptionData.Offset,
                    pWireV1->PolicyDescriptionData.Size
                    );
            }
            else
            {
                SetLastError(ERROR_OUTOFMEMORY);
                fRet = FALSE;
                goto V1error;
            }

            fRet = TRUE;
            goto exit;

V1error:
            if ((*ppPolicyInfoV1)->lpPolicyName != NULL)
            {
                LocalFree((*ppPolicyInfoV1)->lpPolicyName);
                (*ppPolicyInfoV1)->lpPolicyName = NULL;
            }

            if ((*ppPolicyInfoV1)->lpPolicyDescription != NULL)
            {
                LocalFree((*ppPolicyInfoV1)->lpPolicyDescription);
                (*ppPolicyInfoV1)->lpPolicyDescription = NULL;
            }

            LocalFree(*ppPolicyInfoV1);
            *ppPolicyInfoV1 = NULL;
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            fRet = FALSE;
        }
    }
    else
    {
        SetLastError(ERROR_UNKNOWN_REVISION);
        fRet = FALSE;
    }

exit:
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\idl\sessdir\tssduuid.cpp ===
/****************************************************************************/
// tssduuid.c
//
// Terminal Server Session Directory (ITSSessionDirectory) UUID
// instantiations.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>

#define INITGUID
#include <ole2.h>
#include <objbase.h>
#include <comdef.h>

#include "itssd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\client\winsta.c ===
/*************************************************************************
*
* winsta.c
*
* Client side APIs for window stations objects
*
* Copyright Microsoft Corporation, 1998
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <allproc.h>

#include <winsta.h>
#include <winwlx.h>
#include <malloc.h>
#include <stdio.h>
#include <dbt.h>
#include <lm.h>

/*
 * Include the RPC generated common header
 */

#include "tsrpc.h"

#include "rpcwire.h"

#ifdef NTSDDEBUG
#define NTSDDBGPRINT(x) DbgPrint x
#else
#define NTSDDBGPRINT(x)
#endif

#if DBG
#define VERIFY(x) ASSERT(x)     // we already have ASSERT;
#else
#define VERIFY(x) (x)
#endif


#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*
 * This handle is returned when there is no terminal
 * server present on the system. (Non-Hydra)
 */
#define RPC_HANDLE_NO_SERVER (HANDLE)IntToPtr( 0xFFFFFFFD )


/*
 *  Private Procedures defined here
 */

BOOLEAN DllInitialize(IN PVOID, IN ULONG, IN PCONTEXT OPTIONAL);

RPC_STATUS
RpcWinStationBind(
    LPWSTR pszUuid,
    LPWSTR pszProtocolSequence,
    LPWSTR pszNetworkAddress,
    LPWSTR pszEndPoint,
    LPWSTR pszOptions,
    RPC_BINDING_HANDLE *pHandle
    );

RPC_STATUS
RpcWinStationBindSecure(
    LPWSTR pszUuid,
    LPWSTR pszProtocolSequence,
    LPWSTR pszNetworkAddress,
    LPWSTR pszEndPoint,
    LPWSTR pszOptions,
    RPC_BINDING_HANDLE *pHandle
    );

BOOLEAN
RpcLocalAutoBind(
    VOID
    );

/*
 *  Global data
 */

// Critical section to protect the handlelist from multiple threads
RTL_CRITICAL_SECTION   WstHandleLock;

/*
 * RPC program identifier and security options
 */
LPWSTR pszUuid = L"5ca4a760-ebb1-11cf-8611-00a0245420ed"; // From ICAAPI.IDL
LPWSTR pszOptions          = L"Security=Impersonation Dynamic False";

/*
 * RPC over LPC binding information
 */
LPWSTR pszProtocolSequence = L"ncalrpc";   // RPC over LPC
LPWSTR pszEndPoint         = L"IcaApi";

/*
 * RPC over named pipes binding information
 */
LPWSTR pszRemoteProtocolSequence = L"ncacn_np";   // RPC over Named pipes
LPWSTR pszRemoteEndPoint         = L"\\pipe\\Ctx_WinStation_API_service";


/*
 *  other internal Procedures used (not defined here)
 */
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
VOID PdConfig2U2A( PPDCONFIG2A, PPDCONFIG2W );
VOID PdConfig2A2U( PPDCONFIG2W, PPDCONFIG2A );
VOID PdParamsU2A( PPDPARAMSA, PPDPARAMSW );
VOID PdParamsA2U( PPDPARAMSW, PPDPARAMSA );
VOID WdConfigU2A( PWDCONFIGA, PWDCONFIGW );
VOID WdConfigA2U( PWDCONFIGW, PWDCONFIGA );
VOID WinStationCreateU2A( PWINSTATIONCREATEA, PWINSTATIONCREATEW );
VOID WinStationCreateA2U( PWINSTATIONCREATEW, PWINSTATIONCREATEA );
VOID WinStationConfigU2A( PWINSTATIONCONFIGA, PWINSTATIONCONFIGW );
VOID WinStationConfigA2U( PWINSTATIONCONFIGW, PWINSTATIONCONFIGA );
VOID WinStationPrinterU2A( PWINSTATIONPRINTERA, PWINSTATIONPRINTERW );
VOID WinStationPrinterA2U( PWINSTATIONPRINTERW, PWINSTATIONPRINTERA );
VOID WinStationInformationU2A( PWINSTATIONINFORMATIONA,
                               PWINSTATIONINFORMATIONW );
VOID WinStationInformationA2U( PWINSTATIONINFORMATIONW,
                               PWINSTATIONINFORMATIONA );
VOID WinStationClientU2A( PWINSTATIONCLIENTA, PWINSTATIONCLIENTW );
VOID WinStationProductIdU2A( PWINSTATIONPRODIDA, PWINSTATIONPRODIDW );

ULONG CheckUserBuffer(WINSTATIONINFOCLASS,
                      PVOID,
                      ULONG,
                      PVOID *,
                      PULONG,
                      BOOLEAN *);
BOOLEAN CloseContextHandle(HANDLE *pHandle, DWORD *pdwResult);

/*
 * Check to see that caller does not hold the loader critsec.
 * WinStation APIs must NOT be called while holding the loader critsec
 * since deadlock may occur.
 */
#define CheckLoaderLock() \
        ASSERT( NtCurrentTeb()->ClientId.UniqueThread != \
            ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread );


/*
 * Handle the SERVERNAME_CURRENT for auto local binding.
 */
#define HANDLE_CURRENT_BINDING( hServer )                       \
    CheckLoaderLock();                                          \
    if( hServer == SERVERNAME_CURRENT ) {                       \
        if( IcaApi_IfHandle == NULL ) {                         \
            if( !RpcLocalAutoBind() ) {                         \
                return FALSE;                                   \
            }                                                   \
        }                                                       \
        hServer = IcaApi_IfHandle;                              \
    }                                                           \
    if( hServer == RPC_HANDLE_NO_SERVER ) {                     \
        SetLastError( ERROR_APP_WRONG_OS );                     \
        return FALSE;                                           \
    }


#define HANDLE_CURRENT_BINDING_BUFFER( hServer, pBuffer )       \
    CheckLoaderLock();                                          \
    if( hServer == SERVERNAME_CURRENT ) {                       \
        if( IcaApi_IfHandle == NULL ) {                         \
            if( !RpcLocalAutoBind() ) {                         \
                if (pBuffer != NULL) {                          \
                    LocalFree(pBuffer);                         \
                }                                               \
                return FALSE;                                   \
            }                                                   \
        }                                                       \
        hServer = IcaApi_IfHandle;                              \
    }                                                           \
    if( hServer == RPC_HANDLE_NO_SERVER ) {                     \
        if (pBuffer != NULL) {                                  \
            LocalFree(pBuffer);                                 \
        }                                                       \
        SetLastError( ERROR_APP_WRONG_OS );                     \
        return FALSE;                                           \
    }


/*
 * Handle the SERVERNAME_CURRENT for auto local binding that
 * allows the RPC_HANDLE_NO_SERVER handle.
 */
#define HANDLE_CURRENT_BINDING_NO_SERVER( hServer )             \
    CheckLoaderLock();                                          \
    if( hServer == SERVERNAME_CURRENT ) {                       \
        if( IcaApi_IfHandle == NULL ) {                         \
            if( !RpcLocalAutoBind() ) {                         \
                return FALSE;                                   \
            }                                                   \
        }                                                       \
        hServer = IcaApi_IfHandle;                              \
    }




/****************************************************************************
 *
 * DllInitialize
 *
 *   Function is called when the DLL is loaded. The only work we do here
 *   is initialize our CriticalSection.
 *
 * ENTRY:
 *
 *   DllHandle
 *     Loaded handle to our DLL image
 *
 *   Reason
 *     Reason for notifying us
 *
 *   Context
 *     Reason specific parameter from NT
 *
 ****************************************************************************/

BOOLEAN
DllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )
{

    BOOLEAN rc;
    DWORD Result;
    RPC_STATUS Status;
    BOOLEAN Success;
    NTSTATUS ntStatus;
    static BOOLEAN sbIniOK = FALSE;

    (VOID)Context;

    Success = TRUE;

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:


/*
        // some instrumentation for catching the bug #
        // 145378   TRACKING: Winsta.dll getting loaded into csrss

        DBGPRINT(("Checking if winsta is being loaded into csrss.exe\n"));
        if(NULL != wcsstr(GetCommandLine(), TEXT("csrss.exe")))
        {
            DBGPRINT(("**** will break because csrss.exe loaded winsta.dll ***** \n"));
            DebugBreak();
        }
*/
        ntStatus = RtlInitializeCriticalSection( &WstHandleLock );
        IcaApi_IfHandle = NULL;
        if (!NT_SUCCESS(ntStatus)) {
           Success = FALSE;
        }else {
           sbIniOK = TRUE;
        }
        break;

    case DLL_PROCESS_DETACH:

        if (sbIniOK) {

            if( (IcaApi_IfHandle != NULL) && (IcaApi_IfHandle != RPC_HANDLE_NO_SERVER) )
            {
                HANDLE hTmp = InterlockedExchangePointer(&IcaApi_IfHandle,NULL);
                if( hTmp && !IcaApi_IfHandle )
                {
                    
                    //
                    // making RPC call in DLL_PROCESS_DETACH is bad.
                    // threrefore we cannot do CloseContextHandle(&hTmp, &Result);
                    // lets just call RpcSsDestroyClientContext, which will cause 
                    // rundown to run at server end.

                    RpcTryExcept {

                        RpcSsDestroyClientContext(&hTmp);
                    }
                    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                        ASSERT(FALSE);
                    }
                    RpcEndExcept
                  
                }
            }

           RtlDeleteCriticalSection( &WstHandleLock );
        }

        break;

    default:
        break;
    }

    return Success;

}

/*****************************************************************************
 *
 *  RpcWinStationBind
 *
 *   Perform the RPC binding sequence.
 *
 *   This is an internal function.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

RPC_STATUS
RpcWinStationBind(
    LPWSTR pszUuid,
    LPWSTR pszProtocolSequence,
    LPWSTR pszNetworkAddress,
    LPWSTR pszEndPoint,
    LPWSTR pszOptions,
    RPC_BINDING_HANDLE *pHandle
    )
{
    RPC_STATUS Status;
    LPWSTR pszString = NULL;

    /*
     * Compose the binding string using the helper routine
     * and our protocol sequence, security options, UUID, etc.
     */
    Status = RpcStringBindingCompose(
                 pszUuid,
                 pszProtocolSequence,
                 pszNetworkAddress,
                 pszEndPoint,
                 pszOptions,
                 &pszString
                 );

    if( Status != RPC_S_OK ) {
        DBGPRINT(("Error %d in RpcStringBindingCompose\n",Status));
        return( Status );
    }

    /*
     * Now generate the RPC binding from the cononical RPC
     * binding string.
     */
    Status = RpcBindingFromStringBinding(
                 pszString,
                 pHandle
                 );

    if( Status != RPC_S_OK ) {
        DBGPRINT(("Error %d in RpcBindingFromStringBinding\n",Status));
        RpcStringFree( &pszString );
        return( Status );
    }

    /*
     * Free the memory returned from RpcStringBindingCompose()
     */
    RpcStringFree( &pszString );

    return( Status );
}

BOOL
PrepareServerSPN(
        LPWSTR pszNetworkAddress,
        LPWSTR *wszServerSPN)
{
    PWKSTA_INFO_100 pwi;
    NET_API_STATUS net_status;
    LPWSTR wszTemplate = L"%s\\%s$";
    *wszServerSPN = NULL;

    net_status = NetWkstaGetInfo(
                      pszNetworkAddress,  
                      100,        
                      (LPBYTE *)&pwi);
    
    if(net_status == NERR_Success)
    {
        if(pwi->wki100_computername &&
            pwi->wki100_langroup)
        {
            *wszServerSPN = (LPWSTR)LocalAlloc(LPTR,
                (wcslen(wszTemplate)+wcslen(pwi->wki100_computername)+wcslen(pwi->wki100_langroup))*sizeof(WCHAR));
        
            if(*wszServerSPN)
            {
                swprintf(*wszServerSPN, wszTemplate, pwi->wki100_langroup, pwi->wki100_computername);
                NetApiBufferFree(pwi);
                return TRUE;
            }
        }
        NetApiBufferFree(pwi);
    }
    
    return FALSE;
}

/*****************************************************************************
 *
 *  RpcWinStationBindSecure
 *
 *   Performs the RPC binding sequence. 
 *   It also specifies authentication level and SSP used.
 *
 *   This is an internal function.
 *
 * ENTRY:
 *   
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

RPC_STATUS
RpcWinStationBindSecure(
    LPWSTR pszUuid,
    LPWSTR pszProtocolSequence,
    LPWSTR pszNetworkAddress,
    LPWSTR pszEndPoint,
    LPWSTR pszOptions,
    RPC_BINDING_HANDLE *pHandle
    )
{
    RPC_STATUS Status;
    RPC_SECURITY_QOS qos;
    LPWSTR wszServerSPN = NULL;

    Status = RpcWinStationBind(
                    pszUuid,
                    pszProtocolSequence,
                    pszNetworkAddress,
                    pszEndPoint,
                    pszOptions,
                    pHandle);

    if( Status != RPC_S_OK ) {
        DBGPRINT(("Error %d in RpcWinStationBind\n",Status));
        return Status;
    }
    
    qos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    qos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
    qos.Version = RPC_C_SECURITY_QOS_VERSION;
    
    if(PrepareServerSPN(pszNetworkAddress,&wszServerSPN))
    {
        Status = RpcBindingSetAuthInfoEx(
                        *pHandle,                      
                        wszServerSPN,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                        RPC_C_AUTHN_GSS_NEGOTIATE,
                        NULL,
                        RPC_C_AUTHZ_NAME,
                        &qos);

        LocalFree(wszServerSPN);
    }
    else
    {
        Status = RpcBindingSetAuthInfoEx(
                        *pHandle,                      
                        pszNetworkAddress,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                        RPC_C_AUTHN_GSS_NEGOTIATE,
                        NULL,
                        RPC_C_AUTHZ_NAME,
                        &qos);
    }

    if(Status != RPC_S_OK)
    {
        DBGPRINT(("Error %d in RpcBindingSetAuthInfoEx\n",Status));
        RpcBindingFree(pHandle);
        return Status;
    }
    
    return Status;
}
/*****************************************************************************
 *
 *  WinStationOpenLocalServer (Private)
 *
 *   Connect to the local RPC over LPC server for WINSTATION API's.
 *
 *   On non-terminal server machines, it returns a handle that allows
 *   a subset of the DLL's functions to operate locally.
 *
 * ENTRY:
 *
 * EXIT:
 *
 ****************************************************************************/

HANDLE WINAPI
WinStationOpenLocalServer(
    )
{
    RPC_STATUS Status;
    DWORD      Result;
    BOOLEAN    rc;
    RPC_BINDING_HANDLE RpcHandle;
    HANDLE             ContextHandle;
    RPC_SECURITY_QOS RpcSecQos;

    if( !(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer)) ) {
        return( RPC_HANDLE_NO_SERVER );
    }

    /*
     * Do the RPC bind to the local server.
     *
     * We use explict binding handles since we want
     * to allow a single application to talk to multiple
     * WinFrame servers at a time.
     *
     * NOTE: We use the auto handle from the .ACF file
     *       for our local connections.
     */
    Status = RpcWinStationBind(
                 NULL,
                 pszProtocolSequence,
                 NULL,     // ServerName
                 pszEndPoint,
                 pszOptions,
                 &RpcHandle
                 );

    if( Status != RPC_S_OK ) {
        SetLastError( RtlNtStatusToDosError(RPC_NT_SERVER_UNAVAILABLE) );
        return( NULL );
    }
    
    //
    //Demand mutual authentication
    //We only want to work with service running by LocalSystem
    //
    RpcSecQos.Capabilities= RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    RpcSecQos.IdentityTracking= RPC_C_QOS_IDENTITY_DYNAMIC;      
    RpcSecQos.ImpersonationType= RPC_C_IMP_LEVEL_IMPERSONATE;   
    RpcSecQos.Version= RPC_C_SECURITY_QOS_VERSION;

    Status= RpcBindingSetAuthInfoExW(RpcHandle,
                                    L"NT AUTHORITY\\SYSTEM",
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    RPC_C_AUTHZ_NONE,
                                    &RpcSecQos);
    if( Status != RPC_S_OK ) {
        RpcBindingFree( &RpcHandle );
        SetLastError( Status );
        DBGPRINT(("RpcBindingSetAuthInfoExW failed %d\n", Status));
        return( NULL );
    }

    //
    // Get a context handle from the server so it can
    // manage the connections state
    //
    // NOTE: This can fail due to authentication failure.
    //
    RpcTryExcept {
        rc = RpcWinStationOpenServer( RpcHandle, &Result, &ContextHandle );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        rc = FALSE;
#if DBG
        if ( Result != RPC_S_SERVER_UNAVAILABLE ) {
            DBGPRINT(("RPC Exception %d\n",Result));
        }
#endif
    }
    RpcEndExcept

    if( rc ) {
        //
        // Close the server binding handle now that we
        // have a client specific context handle
        //
        RpcBindingFree( &RpcHandle );

        return( (HANDLE)ContextHandle );
    }
    else {
#if DBG
        if ( Result != RPC_S_SERVER_UNAVAILABLE ) {
            DBGPRINT(("WinStationOpenLocalServer: Error %d getting context handle\n",Result));
        }
#endif

        RpcBindingFree( &RpcHandle );

        SetLastError( Result );
        return( NULL );
    }
}

/*****************************************************************************
 *
 *  RpcLocalAutoBind
 *
 *   Handle auto binding to the local server.
 *
 * ENTRY:
 *
 * EXIT:
 *   TRUE - Success
 *   FALSE - Error, Use GetLastError() to retrieve reason.
 *
 ****************************************************************************/

BOOLEAN
RpcLocalAutoBind(void)
{
    if( IcaApi_IfHandle == NULL ) {

        DWORD Result;
        HANDLE hTmp = WinStationOpenLocalServer();

        if( hTmp == NULL ) {
            SetLastError( RPC_S_INVALID_BINDING );
            return( FALSE );
        }

        InterlockedCompareExchangePointer(&IcaApi_IfHandle,hTmp,NULL);

        if(IcaApi_IfHandle != hTmp) {
            CloseContextHandle(&hTmp, &Result);
        }
    }
    
    return( TRUE );
}

/*****************************************************************************
 *
 *  WinStationOpenServerA
 *
 *   Connect to a WinFrame computer in order to issue
 *   ICA API's
 *
 *   NULL for machine name means local system.
 *
 * ENTRY:
 *   Machine (input)
 *     Name of WinFrame computer to connect to
 *
 * EXIT:
 *   handle to server (or NULL on error)
 *
 ****************************************************************************/

HANDLE WINAPI
WinStationOpenServerA(
    LPSTR pServerName
    )
{
    HANDLE hServer;
    ULONG NameLength;
    PWCHAR pServerNameW = NULL;

    if( pServerName == NULL ) {
        return( WinStationOpenServerW( NULL ) );
    }

    NameLength = strlen( pServerName ) + 1;

    pServerNameW = LocalAlloc( 0, NameLength * sizeof(WCHAR) );
    if( pServerNameW == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( NULL );
    }

    AnsiToUnicode( pServerNameW, NameLength*sizeof(WCHAR), pServerName );

    hServer = WinStationOpenServerW( pServerNameW );

    LocalFree( pServerNameW );

    return( hServer );
}

/*****************************************************************************
 *
 *  WinStationOpenServerW
 *
 *   Connect to a WinFrame computer in order to issue
 *   ICA API's
 *
 *   NULL for machine name means local system.
 *
 * ENTRY:
 *   Machine (input)
 *     Name of WinFrame computer to connect to
 *
 * EXIT:
 *   handle to server (or NULL on error)
 *
 ****************************************************************************/

HANDLE WINAPI
WinStationOpenServerW(
    LPWSTR pServerName
    )
{
    DWORD      Result = ERROR_ACCESS_DENIED;
    BOOLEAN    rc;
    RPC_STATUS Status;
    RPC_BINDING_HANDLE RpcHandle;
    HANDLE             ContextHandle;
    BOOL       bTryAgain = TRUE;
    /*
     * If the server name is NULL, attempt to open
     * the local machines ICA server over LPC.
     */
    if( pServerName == NULL ) {
        return( WinStationOpenLocalServer() );
    }

    /*
     * Do the RPC bind to the server.
     *
     * We use explict binding handles since we want
     * to allow a single application to talk to multiple
     * WinFrame servers at a time.
     */
    Status = RpcWinStationBindSecure(
                 pszUuid,
                 pszRemoteProtocolSequence,
                 pServerName,
                 pszRemoteEndPoint,
                 pszOptions,
                 &RpcHandle
                 );

    if( Status != RPC_S_OK ) {
        SetLastError( RtlNtStatusToDosError(RPC_NT_SERVER_UNAVAILABLE) );
        return( NULL );
    }
    
    for(;;)
    {
        //
        // Get a context handle from the server so it can
        // manage the connections state
        //
        // NOTE: This can fail due to authentication failure.
        //
        RpcTryExcept {
            rc = RpcWinStationOpenServer( RpcHandle, &Result, &ContextHandle );
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            Result = RpcExceptionCode();
            rc = FALSE;
            DBGPRINT(("RPC Exception %d\n",Result));
        }
        RpcEndExcept
        
        //
        // Close the server binding handle now that we
        // have a client specific context handle
        //
        RpcBindingFree( &RpcHandle );

        //RPC_S_UNKNOWN_AUTHN_SERVICE - it's an old server and does not use Kerberos
        //for authentication
        //We get ERROR_ACCESS_DENIED if the client runs under wrong (local) user account,
        //but we can still succeed if we drop authentication if we have a net session
        //opened on the target computer
        if( !rc && 
            (Result == RPC_S_UNKNOWN_AUTHN_SERVICE || Result == ERROR_ACCESS_DENIED) &&
            bTryAgain ) {

            bTryAgain = FALSE;
            
            //Try again with no security set
            Status = RpcWinStationBind(
                         pszUuid,
                         pszRemoteProtocolSequence,
                         pServerName,
                         pszRemoteEndPoint,
                         pszOptions,
                         &RpcHandle
                         );

            if(Status == RPC_S_OK){
                DBGPRINT(("Using nonsecure connection!!!\n"));
                continue;
            }
        }

        break;
    }

    if( rc ) {
        return( (HANDLE)ContextHandle );
    }
    else {
        DBGPRINT(("WinStationOpenServerW: Error %d getting context handle\n",Result));
        SetLastError( Result );
        return( NULL );
    }
}

/*****************************************************************************
 *
 *  WinStationCloseServer
 *
 *   Close a connection to a WinFrame computer.
 *
 * ENTRY:
 *   hServer (input)
 *     Handle to close
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
WinStationCloseServer(
    HANDLE hServer
    )
{
    BOOLEAN    rc;
    DWORD      Result;
    //
    // Do not close the implicit handles
    //
    if( (hServer == IcaApi_IfHandle) ||
        (hServer == RPC_HANDLE_NO_SERVER) ) {
        return( TRUE );
    }

    
    //
    // Send the close to the remote side so it clean
    // cleanup its context
    //
    rc = CloseContextHandle(&hServer, &Result);

    if( rc ) {
        return( TRUE );
    }
    else {
        DBGPRINT(("WinStationCloseServer: Error %d closing context handle\n",Result));
        SetLastError( Result );
        return( FALSE );
    }
}

/*****************************************************************************
 *
 *  MIDL_user_allocate
 *
 *    Handles RPC's allocation of argument data structures
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

void __RPC_FAR * __RPC_USER
MIDL_user_allocate(
    size_t Size
    )
{
    return( LocalAlloc(LMEM_FIXED,Size) );
}

/*****************************************************************************
 *
 *  MIDL_user_allocate
 *
 *    Handles RPC's de-allocation of argument data structures
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

void __RPC_USER
MIDL_user_free(
    void __RPC_FAR *p
    )
{
    LocalFree( p );
}

/*****************************************************************************
 *
 *  WinStationServerPing
 *
 *   Ping the given WinFrame server handle to see if it is still up.
 *
 * ENTRY:
 *   hServer (input)
 *    Open RPC server handle
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
WinStationServerPing(
    HANDLE hServer
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    /*
     * Do the RPC
     *
     * NOTE: This must be done under an RPC exception handler,
     *       since the RPC runtime code throws exceptions if
     *       network errors occur, or the server can not be
     *       reached.
     */
    RpcTryExcept {

        rc = RpcIcaServerPing(
                     hServer,
                     &Result
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);

        TRACE0(("RpcIcaServerPing rc 0x%x, Result 0x%x\n",rc, Result));
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationEnumerateA (ANSI stub)
 *
 *     Returns a list of window station objects.
 *
 * ENTRY:
 *
 *    see WinStationEnumerateW
 *
 * EXIT:
 *
 *    see WinStationEnumerateW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationEnumerateA(
        HANDLE  hServer,
        PLOGONIDA  *ppLogonId,
        PULONG  pEntries
        )
{
    PLOGONIDW pLogonIdW, pLogonIdBaseW;
    PLOGONIDA pLogonIdA;
    BOOLEAN Status;
    ULONG Count;

    /*
     * Call UNICODE WinStationEnumerateW first.
     */
    *pEntries = 0;
    *ppLogonId = NULL;
    Status = WinStationEnumerateW( hServer, &pLogonIdBaseW, &Count );
    if ( !Status )
        goto badenumerate;

    /*
     * Allocate buffer and perform conversion from UNICODE to ANSI.
     */
    if ( !(pLogonIdA = (PLOGONIDA)LocalAlloc( 0, Count * sizeof(LOGONIDA) )) ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        Status = FALSE;
        goto nomemory;
    }

    *pEntries = Count;
    *ppLogonId = pLogonIdA;

    for ( pLogonIdW = pLogonIdBaseW; Count; Count-- ) {

        pLogonIdA->LogonId = pLogonIdW->LogonId;

        UnicodeToAnsi( pLogonIdA->WinStationName,
                       sizeof(WINSTATIONNAMEA),
                       pLogonIdW->WinStationName );

        pLogonIdA->State = pLogonIdW->State;

        pLogonIdA++;
        pLogonIdW++;
    }

nomemory:
    /*
     * Free the UNICODE enumerate buffer.
     */
    WinStationFreeMemory( pLogonIdBaseW );

badenumerate:
    return(Status);
}

/*******************************************************************************
 *
 *  WinStationEnumerateW (UNICODE)
 *
 *     Returns a list of window station objects.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    ppLogonId (output)
 *       Points to a pointer to a buffer to receive the enumeration results,
 *       which are returned as an array of LOGONID structures.  The buffer is
 *       allocated within this API and is disposed of using
 *       WinStationFreeMemory.
 *    pEntries (output)
 *       Points to a variable specifying the number of entries read.
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationEnumerateW(
        HANDLE  hServer,
        PLOGONIDW  *ppLogonId,
        PULONG  pEntries
        )
{
    DWORD Result;
    BOOLEAN rc;
    ULONG LogonIdCount = 50;
    PLOGONIDW pLogonId, pLogonIdTemp;
    ULONG Length;
    ULONG Index = 0;
    ULONG ByteCount = 0;

    HANDLE_CURRENT_BINDING( hServer );

    *pEntries = 0;
    *ppLogonId = NULL;
    Length = LogonIdCount * sizeof(LOGONIDW);
    if ( !(pLogonId = (PLOGONIDW)LocalAlloc( 0, Length)) ) {
        Result = ERROR_NOT_ENOUGH_MEMORY;
        goto nomemexit;
    }

    /*
     *  get list of all WinStations
     */
    for (;;) {

        if ( Index ) {

           ByteCount = *pEntries * sizeof(LOGONIDW);
           *pEntries += LogonIdCount;
           if ( !(pLogonIdTemp = (PSESSIONIDW)LocalAlloc( 0,
                                            (*pEntries * sizeof(LOGONIDW)))) ) {

               Result = ERROR_NOT_ENOUGH_MEMORY;
               goto errexit;
           }

           if ( *ppLogonId ) {

               MoveMemory( pLogonIdTemp, *ppLogonId, ByteCount );
               LocalFree(*ppLogonId);
           }

           MoveMemory( ((PBYTE)pLogonIdTemp + ByteCount), pLogonId,
                       (LogonIdCount * sizeof(LOGONIDW)) );
           *ppLogonId = pLogonIdTemp;
        }

        RpcTryExcept {

            rc = RpcWinStationEnumerate(
                         hServer,
                         &Result,
                         &LogonIdCount,
                         (PCHAR)pLogonId,
                         &Length,
                         &Index
                         );

            Result = RtlNtStatusToDosError( Result );
            if ( Result == ERROR_NO_MORE_ITEMS) {
                Result = ERROR_SUCCESS;
                break;
            }
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            Result = RpcExceptionCode();
            DBGPRINT(("RPC Exception %d\n",Result));
            goto nomemexit;
        }
        RpcEndExcept
    }

errexit:
    LocalFree( pLogonId );

nomemexit:
    if ( Result ) {

        if ( *ppLogonId ) {

            LocalFree( *ppLogonId );
            *ppLogonId = NULL;
        }

        SetLastError(Result);
        return(FALSE);

    } else {

        return(TRUE);
    }
}


/*******************************************************************************
 *
 *  WinStationEnumerate_IndexedA (ANSI stub)
 *
 *     Returns a list of window station objects (multi-call indexed).
 *
 *     NOTE: this API used to be WinStationEnumerateA in WinFrame 1.6 and
 *           earlier.  It is provided now for backward compatibility with
 *           Citrix code built around the indexed enumeration procedure.
 *           New code should use the WinStationEnumerateA call.
 *
 * ENTRY:
 *
 *    see WinStationEnumerate_IndexedW
 *
 * EXIT:
 *
 *    see WinStationEnumerate_IndexedW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationEnumerate_IndexedA(
        HANDLE  hServer,
        PULONG  pEntries,
        PLOGONIDA  pLogonId,
        PULONG  pByteCount,
        PULONG  pIndex
        )
{
    PLOGONIDW pBuffer = NULL, pLogonIdW;
    BOOLEAN Status;
    ULONG Count, ByteCountW = (*pByteCount << 1);

    /*
     * If the caller supplied a buffer and the length is not 0,
     * allocate a corresponding (*2) buffer for UNICODE strings.
     */
    if ( pLogonId && ByteCountW ) {
        if ( !(pBuffer = LocalAlloc(0, ByteCountW)) ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }
    }

    /*
     * Enumerate WinStations
     */
    pLogonIdW = pBuffer;
    Status = WinStationEnumerate_IndexedW( hServer, pEntries, pLogonIdW,
                                           &ByteCountW, pIndex );

    /*
     * Always /2 the resultant ByteCount (whether sucessful or not).
     */
    *pByteCount = (ByteCountW >> 1);

    /*
     * If the function completed sucessfully and caller
     * (and stub) defined a buffer to copy into, perform conversion
     * from UNICODE to ANSI.
     */
    if ( Status && pLogonIdW && pLogonId ) {

        for ( Count = *pEntries; Count; Count-- ) {

            pLogonId->LogonId = pLogonIdW->LogonId;

            UnicodeToAnsi( pLogonId->WinStationName,
                           sizeof(WINSTATIONNAMEA),
                           pLogonIdW->WinStationName );

            pLogonId->State = pLogonIdW->State;

            (char*)pLogonId += sizeof(LOGONIDA);
            (char*)pLogonIdW += sizeof(LOGONIDW);
        }
    }

    /*
     * If we defined a buffer, free it now, then return the status of
     * the WinStationEnumerateW call.
     */
    if ( pBuffer )
        LocalFree(pBuffer);

    return(Status);
}


/*******************************************************************************
 *
 *  WinStationEnumerate_IndexedW (UNICODE)
 *
 *     Returns a list of window station objects (multi-call indexed).
 *
 *     NOTE: this API used to be WinStationEnumerateW in WinFrame 1.6 and
 *           earlier.  It is provided now for backward compatibility with
 *           Citrix code built around the indexed enumeration procedure.
 *           New code should use the WinStationEnumerateW call.
 *
 * ENTRY:
 *
 *    pEntries (input/output)
 *       Points to a variable specifying the number of entries requested.
 *       If the number requested is 0xFFFFFFFF, the function returns as
 *       many entries as possible. When the function finishes successfully,
 *       the variable pointed to by the pEntries parameter contains the
 *       number of entries actually read.
 *
 *    pLogonId (output)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of LOGONID structures.  If the window
 *       station is disconnected the name is null.
 *
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pLogonId parameter. If the buffer is too small to receive even
 *       one entry, this variable receives the required size of the buffer.
 *
 *    pIndex (input/output)
 *       Points to a ULONG that specifies where to start the enumeration.
 *       The only user visible value is 0, for starting at the begining.
 *       Each call will update this so that the next call will return the
 *       next WinStation in the list, till end of list.
 *       The user should not interpret, or use the internal values, other
 *       than the special case 0.
 *
 * EXIT:
 *
 *    TRUE  - The enumeration succeeded, and the buffer contains the
 *            requested data. The calling application can continue to call
 *            the WinStationEnumerate function to complete the enumeration.
 *
 *    FALSE - The operation failed.  Extended error status is available using
 *            GetLastError. Possible return values from GetLastError include
 *            the following:
 *
 *            ERROR_NO_MORE_ITEMS - There are no more entries. The buffer
 *                                  contents are undefined.
 *            ERROR_MORE_DATA     - The buffer is too small for even one entry.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationEnumerate_IndexedW(
        HANDLE  hServer,
        PULONG  pEntries,
        PLOGONIDW  pLogonId,
        PULONG  pByteCount,
        PULONG  pIndex
        )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationEnumerate(
                     hServer,
                     &Result,
                     pEntries,
                     (PCHAR)pLogonId,
                     pByteCount,
                     pIndex
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationGetAllProcesses (UNICODE)
 *
 *     Returns a structure containing TS_SYS_PROCESS_INFORMATION structures
 *     for each process on the specified server.
 *
 * ENTRY:
 *
 * EXIT:
 *    TRUE  - The enumeration succeeded, and the buffer contains the
 *            requested data.
 *    FALSE - The operation failed.  Extended error status is available using
 *            GetLastError.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationGetAllProcesses(
                          HANDLE    hServer,
                          ULONG     Level,
                          ULONG    *pNumberOfProcesses,
                          PVOID    *ppProcessArray
                          )
{
    BOOLEAN       bGetAllProcessesOk = FALSE;
    DWORD         dwResult;

    if (Level != GAP_LEVEL_BASIC)
    {
            dwResult = RtlNtStatusToDosError( STATUS_NOT_IMPLEMENTED );
            SetLastError(dwResult);
            return FALSE;
    }

    HANDLE_CURRENT_BINDING( hServer );

    // The Win2K server uses PTS_ALL_PROCESSES_INFO structure for the process information. 
    // And the whistler server uses PTS_SYS_PROCESS_INFORMATION_NT6 structure for the same.
    // So, we have to try two different RPC APIs. Assume initially that the server is a 
    // Whistler server and use RpcWinStationGetAllProcesses_NT6. If it is Win2K server, this
    // call will fail, because this API does not exist on Win2K server. In that case we will 
    // use RpcWinStationGetAllProcesses.

    // Try out Whistler interface first.

    RpcTryExcept {
        bGetAllProcessesOk = RpcWinStationGetAllProcesses_NT6(hServer,
                                                         (ULONG *)&dwResult,
                                                         Level,
                                                         pNumberOfProcesses,
                                                         (PTS_ALL_PROCESSES_INFO_NT6 *)ppProcessArray);
        if( !bGetAllProcessesOk )
        {
            dwResult = RtlNtStatusToDosError( dwResult );
            SetLastError(dwResult);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        dwResult = RpcExceptionCode();
		if (dwResult == RPC_S_PROCNUM_OUT_OF_RANGE)
			// Whistler interface failed.
			goto TryW2KInterface;
        SetLastError( dwResult );
        DBGPRINT(("RPC Exception %d\n",dwResult));
        bGetAllProcessesOk = FALSE;
    }
    RpcEndExcept

    return( bGetAllProcessesOk );

TryW2KInterface:
    // Try out Win2K interface now.
    RpcTryExcept {
        bGetAllProcessesOk = RpcWinStationGetAllProcesses(hServer,
                                                         (ULONG *)&dwResult,
                                                         Level,
                                                         pNumberOfProcesses,
                                                         (PTS_ALL_PROCESSES_INFO *)ppProcessArray);
        if( !bGetAllProcessesOk )
        {
            dwResult = RtlNtStatusToDosError( dwResult );
            SetLastError(dwResult);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        dwResult = RpcExceptionCode();
        SetLastError( dwResult );
        DBGPRINT(("RPC Exception %d\n",dwResult));
        bGetAllProcessesOk = FALSE;
    }
    RpcEndExcept

    return( bGetAllProcessesOk );
}


/*******************************************************************************
 *  WinStationGetProcessSid()
 *  username for the requested process
 *  For identifying correct process processid and start
 *  time are required
 *
 *  hServer         - input, Handle of the server to find info about,
 *                    if NULL use local.
 *  ProcessId       - input, ProcessID
 *  ProcessStartTime- input, Process start time, (identifies unique process
 *                    together with ProcessID)
 *  pProcessUserSid - output, process user sid
 *  dwSidSize       - input, memory allocated for pProcessUserSid
 *
 *  returns TURE if succeeded, FALSE if failed. in case of failure
 *  GetLastError() will gives more infromation about failure.
 *
 ******************************************************************************/
BOOLEAN WINAPI
WinStationGetProcessSid(
        HANDLE   hServer,
        DWORD    ProcessId,
        FILETIME ProcessStartTime,
        PBYTE    pProcessUserSid,
        DWORD    *pdwSidSize
        )
{
    BOOLEAN         rc;
    LARGE_INTEGER   CreateTime;
    DWORD           Result;
    NTSTATUS        Status;


    HANDLE_CURRENT_BINDING( hServer );

    CreateTime.LowPart  = ProcessStartTime.dwLowDateTime;
    CreateTime.HighPart = ProcessStartTime.dwHighDateTime;

    RpcTryExcept
    {
        rc = RpcWinStationGetProcessSid(
            hServer,
            ProcessId,
            CreateTime,
            &Status,
            pProcessUserSid,
            *pdwSidSize,
            pdwSidSize
            );

        if( !rc )
        {
            Result = RtlNtStatusToDosError( Status );
            SetLastError(Result);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        Result = RpcExceptionCode();
        SetLastError(Result);
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept


    return( rc );
}

/*******************************************************************************
 *
 *  WinStationGetLanAdapterNameW (UNICODE)
 *
 *     Returns a Network Adapter name
 *
 * ENTRY:
 *
 * EXIT:
 *    TRUE  - The Query succeeded, and the buffer contains the
 *            requested data.
 *    FALSE - The operation failed.  Extended error status is available using
 *            GetLastError.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationGetLanAdapterNameW(
                          HANDLE    hServer,
                          ULONG     LanAdapter,
                                                  ULONG     pdNameLength,
                          PWCHAR  pPdName,
                          ULONG   *pLength,
                          PWCHAR  *ppLanAdapter
                         )
{
    BOOLEAN       bGetLanAdapter = FALSE;
    DWORD         dwResult;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept
    {
        bGetLanAdapter =  RpcWinStationGetLanAdapterName(hServer,
                                                         &dwResult,
                                                         pdNameLength,
                                                         pPdName,
                                                         LanAdapter,
                                                         pLength,
                                                         ppLanAdapter
                                                         );

        if( !bGetLanAdapter )
        {
            dwResult = RtlNtStatusToDosError( dwResult );
            SetLastError(dwResult);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwResult = RpcExceptionCode();
        SetLastError( dwResult );
        DBGPRINT(("RPC Exception %d\n",dwResult));
        bGetLanAdapter = FALSE;
    }
    RpcEndExcept

    return( bGetLanAdapter );
}

/*******************************************************************************
 *
 *  WinStationGetLanAdapterNameA
 *
 *     Returns a Network Adapter name - Ansi equivalent for WinStationGetLanAdapterNameW
 *
 * ENTRY:
 *
 * EXIT:
 *    TRUE  - The Query succeeded, and the buffer contains the
 *            requested data.
 *    FALSE - The operation failed.  Extended error status is available using
 *            GetLastError.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationGetLanAdapterNameA(
                          HANDLE    hServer,
                          ULONG     LanAdapter,
                                                  ULONG     pdNameLength,
                          PCHAR  pPdName,
                          ULONG   *pLength,
                          PCHAR  *ppLanAdapter
                         )
{
    BOOLEAN  bGetLanAdapter = FALSE;
    PWCHAR pPdNameW = NULL;
    PWCHAR pLanAdapterW = NULL;
    ULONG Size = 0;


    *ppLanAdapter = NULL;
    *pLength = 0;

        pPdNameW = LocalAlloc(0,pdNameLength * sizeof(WCHAR));
    if (NULL == pPdNameW)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    AnsiToUnicode(pPdNameW, pdNameLength * sizeof(WCHAR), pPdName );

    bGetLanAdapter =  WinStationGetLanAdapterNameW(hServer,LanAdapter,pdNameLength * sizeof(WCHAR),pPdNameW,&Size,&pLanAdapterW);
    if(bGetLanAdapter )
    {
        *ppLanAdapter = LocalAlloc(0,lstrlen(pLanAdapterW) + 1);
        if(NULL == *ppLanAdapter)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            bGetLanAdapter = FALSE;

        }
        else
        {
            UnicodeToAnsi(*ppLanAdapter,lstrlen(pLanAdapterW) + 1,pLanAdapterW);
            *pLength = lstrlen(pLanAdapterW) + 1;
        }
        WinStationFreeMemory(pLanAdapterW);


    }

    LocalFree(pPdNameW);

    return( bGetLanAdapter );
}

#if defined(_WIN64)
void ConvertFromX86(PTS_SYS_PROCESS_INFORMATION pTSProcessInfo)
{

    //
    // this function is called from WinStationEnumerateProcesses, which is used only for TS4 machines.
    // This structure has to be marshalled correctly to convert from x86 to ia64 when running on ia64.
    // 
    typedef struct _WIRE_UNICODE_STRING
    {
        USHORT Length;
        USHORT MaximumLength;
        ULONG  Buffer;
    } X86_UNICODE_STRING, *PX86_UNICODE_STRING;

    typedef struct TS_SYS_PROCESS_INFORMATION_X86 
    {
        ULONG NextEntryOffset;
        ULONG NumberOfThreads;
        LARGE_INTEGER SpareLi1;
        LARGE_INTEGER SpareLi2;
        LARGE_INTEGER SpareLi3;
        LARGE_INTEGER CreateTime;
        LARGE_INTEGER UserTime;
        LARGE_INTEGER KernelTime;
        X86_UNICODE_STRING ImageName;
        LONG BasePriority;                     // KPRIORITY in ntexapi.h
        DWORD UniqueProcessId;                 // HANDLE in ntexapi.h
        DWORD InheritedFromUniqueProcessId;    // HANDLE in ntexapi.h
        ULONG HandleCount;
        ULONG SessionId;
        ULONG SpareUl3;
        ULONG PeakVirtualSize;
        ULONG  VirtualSize;
        ULONG PageFaultCount;
        ULONG PeakWorkingSetSize;
        ULONG WorkingSetSize;
        ULONG QuotaPeakPagedPoolUsage;
        ULONG QuotaPagedPoolUsage;
        ULONG QuotaPeakNonPagedPoolUsage;
        ULONG QuotaNonPagedPoolUsage;
        ULONG PagefileUsage;
        ULONG PeakPagefileUsage;
        ULONG PrivatePageCount;
    }    
    TS_SYS_PROCESS_INFORMATION_X86, *PTS_SYS_PROCESS_INFORMATION_X86;

    TS_SYS_PROCESS_INFORMATION_X86 TSProcInfoX86; 

    TSProcInfoX86 = * (PTS_SYS_PROCESS_INFORMATION_X86) pTSProcessInfo;
    
    pTSProcessInfo->NextEntryOffset         = TSProcInfoX86.NextEntryOffset ;
    pTSProcessInfo->NumberOfThreads         = TSProcInfoX86.NumberOfThreads ;
    pTSProcessInfo->SpareLi1                = TSProcInfoX86.SpareLi1 ;
    pTSProcessInfo->SpareLi2                = TSProcInfoX86.SpareLi2 ;
    pTSProcessInfo->SpareLi3                = TSProcInfoX86.SpareLi3 ;
    pTSProcessInfo->CreateTime              = TSProcInfoX86.CreateTime ;
    pTSProcessInfo->UserTime                = TSProcInfoX86.UserTime ;
    pTSProcessInfo->KernelTime              = TSProcInfoX86.KernelTime ;
    pTSProcessInfo->ImageName.Length        = TSProcInfoX86.ImageName.Length;
    pTSProcessInfo->ImageName.MaximumLength = TSProcInfoX86.ImageName.MaximumLength;
    pTSProcessInfo->ImageName.Buffer        = UlongToPtr(TSProcInfoX86.ImageName.Buffer);
    pTSProcessInfo->BasePriority            = TSProcInfoX86.BasePriority ;
    pTSProcessInfo->UniqueProcessId         = TSProcInfoX86.UniqueProcessId ;
    pTSProcessInfo->InheritedFromUniqueProcessId = TSProcInfoX86.InheritedFromUniqueProcessId ;
    pTSProcessInfo->HandleCount             = TSProcInfoX86.HandleCount ;
    pTSProcessInfo->SessionId               = TSProcInfoX86.SessionId ;

    //
    // Following members are not used so we dont need to copy their values.
    // if we did so, we overwrite data past the original structure, as the strucutre comes from x86 
    // its smaller than the WIN64 version.
    //

    //pTSProcessInfo->SpareUl3                = TSProcInfoX86.SpareUl3 ;
    //pTSProcessInfo->PeakVirtualSize         = TSProcInfoX86.PeakVirtualSize ;
    //pTSProcessInfo->VirtualSize             = TSProcInfoX86.VirtualSize ;
    //pTSProcessInfo->PageFaultCount          = TSProcInfoX86.PageFaultCount ;
    //pTSProcessInfo->PeakWorkingSetSize      = TSProcInfoX86.PeakWorkingSetSize ;
    //pTSProcessInfo->WorkingSetSize          = TSProcInfoX86.WorkingSetSize ;
    //pTSProcessInfo->QuotaPeakPagedPoolUsage = TSProcInfoX86.QuotaPeakPagedPoolUsage ;
    //pTSProcessInfo->QuotaPagedPoolUsage     = TSProcInfoX86.QuotaPagedPoolUsage ;
    //pTSProcessInfo->QuotaPeakNonPagedPoolUsage = TSProcInfoX86.QuotaPeakNonPagedPoolUsage ;
    //pTSProcessInfo->QuotaNonPagedPoolUsage  = TSProcInfoX86.QuotaNonPagedPoolUsage ;
    //pTSProcessInfo->PagefileUsage           = TSProcInfoX86.PagefileUsage ;
    //pTSProcessInfo->PeakPagefileUsage       = TSProcInfoX86.PeakPagefileUsage ;
    //pTSProcessInfo->PrivatePageCount        = TSProcInfoX86.PrivatePageCount ;
}
#endif

/*******************************************************************************
 *
 *  WinStationEnumerateProcesses (UNICODE)
 *
 *     Returns a buffer containing SYSTEM_PROCESS_INFORMATION structures
 *     for each process on the specified server.
 *
 *  IMPORTANT:  This API can ONLY be used to access TS 4.0 servers.
 *              The process structure has changed in Windows 2000 !
 *
 * ENTRY:
 *    ppProcessBuffer (output)
 *       Points to a variable that will be set to the beginning of the
 *       process buffer on success.  The buffer is allocated within this
 *       API and is disposed of using WinStationFreeMemory.
 *
 * EXIT:
 *    TRUE  - The enumeration succeeded, and the buffer contains the
 *            requested data.
 *    FALSE - The operation failed.  Extended error status is available using
 *            GetLastError.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationEnumerateProcesses(
        HANDLE  hServer,
        PVOID *ppProcessBuffer
        )
{
    DWORD Result;
    BOOLEAN rc;
    PBYTE pBuffer;
    ULONG ByteCount;

// From pstat.c
#define BUFFER_SIZE 32*1024

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        ByteCount = BUFFER_SIZE;
        *ppProcessBuffer = NULL;

        for(;;) {

            if ( (pBuffer = LocalAlloc( 0, ByteCount )) == NULL ) {
                Result = (DWORD)STATUS_NO_MEMORY;
                rc = FALSE;
                break;
            }

//#ifdef notdef
            /*
             *  get process info from server
             */
            rc = RpcWinStationEnumerateProcesses(
                        hServer,
                        &Result,
                        pBuffer,
                        ByteCount
                     );
//#else
#ifdef notdef
            Result = NtQuerySystemInformation( SystemProcessInformation,
                                               (PVOID)pBuffer,
                                               ByteCount,
                                               NULL );

            rc = (Result == STATUS_SUCCESS) ? TRUE : FALSE;
#endif

            if ( rc || (Result != STATUS_INFO_LENGTH_MISMATCH) )
                break;

            LocalFree( pBuffer );
            ByteCount *= 2;
        }

        if( !rc ) {

            Result = RtlNtStatusToDosError( Result );
            SetLastError(Result);
            LocalFree( pBuffer );
            *ppProcessBuffer = NULL;

        } else {

//#ifdef notdef
            PTS_SYS_PROCESS_INFORMATION ProcessInfo;
            PCITRIX_PROCESS_INFORMATION CitrixInfo;

            ULONG TotalOffset;

            /*
             * Walk the returned buffer (it's in PTS_SYS_PROCESS_INFORMATION
             * format) and fixup the addresses (now containing
             * offsets) to pointers in our address space within pBuffer.
             */
            ProcessInfo = (PTS_SYS_PROCESS_INFORMATION)pBuffer;
            TotalOffset = 0;
            for(;;) {

    
#if defined(_WIN64)     
                ConvertFromX86(ProcessInfo);
#endif

                /*
                 * Fixup image name buffer address
                 */
                if ( ProcessInfo->ImageName.Buffer )
                    ProcessInfo->ImageName.Buffer =
                        (PWSTR)&pBuffer[(ULONG_PTR)(ProcessInfo->ImageName.Buffer)];


                /*
                 * Fixup ProcessSid address
                 */
                //
                //  Note: this is necessary because we may access to a Hydra 4 server
                //  the MagicNumber should prevent us from doing wrong.
                //
                CitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                             (((PUCHAR)ProcessInfo) +
                              SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION +
                              (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * (int)ProcessInfo->NumberOfThreads));

#if defined(_WIN64)  
                //The pointer to SID came from x86 machine, so upper
                //32 bits contain garbage. Set them to 0.
                //This overrides original Pad value, bu it's okay,
                //because it is not used.
                (ULONG_PTR)CitrixInfo->ProcessSid &=0x00000000FFFFFFFF;
#endif

                if( (CitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC) &&
                        (CitrixInfo->ProcessSid) ) {
                    
                    CitrixInfo->ProcessSid =
                        (PVOID)&pBuffer[(ULONG_PTR)(CitrixInfo->ProcessSid)];
                }

                if( ProcessInfo->NextEntryOffset == 0 )
                    break;
                else
                    TotalOffset += ProcessInfo->NextEntryOffset;

                ProcessInfo = (PTS_SYS_PROCESS_INFORMATION)&pBuffer[TotalOffset];
            }
//#endif
            *ppProcessBuffer = (PVOID)pBuffer;
        }

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}


/*******************************************************************************
 *
 *  WinStationRenameA (ANSI stub)
 *
 *    Renames a window station object in the session manager.
 *    (see WinStationRenameW)
 *
 * ENTRY:
 *
 *    see WinStationRenameW
 *
 * EXIT:
 *
 *    see WinStationRenameW
 *
 ******************************************************************************/

BOOLEAN
WinStationRenameA(
        HANDLE hServer,
        PWINSTATIONNAMEA pWinStationNameOld,
        PWINSTATIONNAMEA pWinStationNameNew
        )
{
    WINSTATIONNAMEW WinStationNameOldW;
    WINSTATIONNAMEW WinStationNameNewW;

    /*
     * Convert ANSI WinStationNames to UNICODE.
     */
    AnsiToUnicode( WinStationNameOldW, sizeof(WINSTATIONNAMEW), pWinStationNameOld );
    AnsiToUnicode( WinStationNameNewW, sizeof(WINSTATIONNAMEW), pWinStationNameNew );

    /*
     * Call WinStationRenameW & return it's status.
     */
    return ( WinStationRenameW( hServer, WinStationNameOldW, WinStationNameNewW ) );
}

/*******************************************************************************
 *
 *  WinStationRenameW (UNICODE)
 *
 *    Renames a window station object in the session manager.
 *
 * ENTRY:
 *
 *    pWinStationNameOld (input)
 *       Old name of window station.
 *
 *    pWinStationNameNew (input)
 *       New name of window station.
 *
 *
 * EXIT:
 *
 *    TRUE  -- The rename operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationRenameW(
        HANDLE hServer,
        PWINSTATIONNAMEW pWinStationNameOld,
        PWINSTATIONNAMEW pWinStationNameNew
        )
{
    DWORD Result;
    BOOLEAN rc;
    WCHAR*  rpcBufferOld;
    WCHAR*  rpcBufferNew;

    HANDLE_CURRENT_BINDING( hServer );

//  Since, due to legacy clients, we cannot change the interface,
//  as a workarround to bug#265954, we double the size of RPC Buffers.

#pragma prefast(suppress:260, legacy servers expect this behaviour  (http://searchraid/ntbug/265954.asp))
    rpcBufferOld = LocalAlloc(LPTR, sizeof(WINSTATIONNAMEW) * sizeof(WCHAR));
    if (rpcBufferOld != NULL) {
        CopyMemory(rpcBufferOld, pWinStationNameOld, sizeof(WINSTATIONNAMEW));
    } else {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

#pragma prefast(suppress:260, legacy clients expect this behaviour  (http://searchraid/ntbug/229753.asp))
    rpcBufferNew = LocalAlloc(LPTR, sizeof(WINSTATIONNAMEW) * sizeof(WCHAR));
    if (rpcBufferNew != NULL) {
        CopyMemory(rpcBufferNew, pWinStationNameNew, sizeof(WINSTATIONNAMEW));
    } else {
        LocalFree(rpcBufferOld);
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }



    RpcTryExcept {

        rc = RpcWinStationRename(
                     hServer,
                     &Result,
                     (PWCHAR)rpcBufferOld,
                     sizeof(WINSTATIONNAMEW),
                     (PWCHAR)rpcBufferNew,
                     sizeof(WINSTATIONNAMEW)
                     );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    LocalFree(rpcBufferOld);
    LocalFree(rpcBufferNew);
    if( !rc ) SetLastError(Result);
    return( rc );
}


/*******************************************************************************
 *
 *  WinStationQueryInformationA (ANSI stub)
 *
 *    Queries configuration information about a window station object.
 *
 * ENTRY:
 *
 *    see WinStationQueryInformationW
 *
 * EXIT:
 *
 *    see WinStationQueryInformationW
 *
 ******************************************************************************/

BOOLEAN
WinStationQueryInformationA(
        HANDLE hServer,
        ULONG  LogonId,
        WINSTATIONINFOCLASS WinStationInformationClass,
        PVOID  pWinStationInformation,
        ULONG WinStationInformationLength,
        PULONG  pReturnLength
        )
{
    PVOID pInfo;
    ULONG InfoLength, ValidInputLength;
    struct {
        union {
            WINSTATIONCREATEW      CreateData;
            WINSTATIONCONFIGW      Configuration;
            PDPARAMSW              PdParams;
            WDCONFIGW              Wd;
            PDCONFIGW              Pd;
            WINSTATIONPRINTERW     Printer;
            WINSTATIONINFORMATIONW Information;
            WINSTATIONCLIENTW      Client;
            WINSTATIONPRODIDW            DigProdId;
        };
    } Info;

    /*
     * Validate the caller supplied buffer length and set up for
     * call to WinStationQueryInformationW.
     */
    switch ( WinStationInformationClass ) {

        case WinStationCreateData:
            pInfo = &Info.CreateData;
            InfoLength = sizeof(Info.CreateData);
            ValidInputLength = sizeof(WINSTATIONCREATEA);
            break;

        case WinStationConfiguration:
            pInfo = &Info.Configuration;
            InfoLength = sizeof(Info.Configuration);
            ValidInputLength = sizeof(WINSTATIONCONFIGA);
            break;

        case WinStationPdParams:
            pInfo = &Info.PdParams;
            ((PPDPARAMSW)pInfo)->SdClass = ((PPDPARAMSA)pWinStationInformation)->SdClass;
            InfoLength = sizeof(Info.PdParams);
            ValidInputLength = sizeof(PDPARAMSA);
            break;

        case WinStationWd:
            pInfo = &Info.Wd;
            InfoLength = sizeof(Info.Wd);
            ValidInputLength = sizeof(WDCONFIGA);
            break;

        case WinStationPd:
            pInfo = &Info.Pd;
            InfoLength = sizeof(Info.Pd);
            ValidInputLength = sizeof(PDCONFIGA);
            break;

        case WinStationPrinter:
            pInfo = &Info.Printer;
            InfoLength = sizeof(Info.Printer);
            ValidInputLength = sizeof(WINSTATIONPRINTERA);
            break;

        case WinStationInformation:
            pInfo = &Info.Information;
            InfoLength = sizeof(Info.Information);
            ValidInputLength = sizeof(WINSTATIONINFORMATIONA);
            break;

        case WinStationClient:
            pInfo = &Info.Client;
            InfoLength = sizeof(Info.Client);
            ValidInputLength = sizeof(WINSTATIONCLIENTA);
            break;
        case WinStationDigProductId:
                pInfo = &Info.DigProdId;
                InfoLength = sizeof(Info.DigProdId);
                ValidInputLength = sizeof(WINSTATIONPRODIDA);
                break;

        /*
         * The other WINSTATIONINFOCLASSes don't need converting.
         */
        default:
            pInfo = pWinStationInformation;
            ValidInputLength = InfoLength = WinStationInformationLength;
            break;
    }

    /*
     * If the caller-supplied buffer is not the proper size, set error
     * and return FALSE.
     */
    if ( WinStationInformationLength != ValidInputLength )
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    }

    /*
     * Call the WinStationQueryInformationW function, returning if
     * failure.
     */
    if ( !WinStationQueryInformationW( hServer, LogonId,
                                       WinStationInformationClass,
                                       pInfo, InfoLength, pReturnLength ) )
        return(FALSE);


    /*
     * Convert the returned UNICODE information to ANSI, if needed.
     */
    switch ( WinStationInformationClass ) {

        case WinStationCreateData:
            WinStationCreateU2A( (PWINSTATIONCREATEA)pWinStationInformation,
                                 (PWINSTATIONCREATEW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationConfiguration:
            WinStationConfigU2A( (PWINSTATIONCONFIGA)pWinStationInformation,
                                 (PWINSTATIONCONFIGW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationPdParams:
            PdParamsU2A( (PPDPARAMSA)pWinStationInformation,
                          (PPDPARAMSW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationWd:
            WdConfigU2A( (PWDCONFIGA)pWinStationInformation,
                               (PWDCONFIGW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationPd:
            PdConfig2U2A( &((PPDCONFIGA)pWinStationInformation)->Create,
                           &((PPDCONFIGW)pInfo)->Create );
            PdParamsU2A( &((PPDCONFIGA)pWinStationInformation)->Params,
                          &((PPDCONFIGW)pInfo)->Params );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationPrinter:
            WinStationPrinterU2A( (PWINSTATIONPRINTERA)pWinStationInformation,
                                  (PWINSTATIONPRINTERW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationInformation:
            WinStationInformationU2A( (PWINSTATIONINFORMATIONA)pWinStationInformation,
                                      (PWINSTATIONINFORMATIONW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationClient:
            WinStationClientU2A( (PWINSTATIONCLIENTA)pWinStationInformation,
                                 (PWINSTATIONCLIENTW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationDigProductId:
                WinStationProductIdU2A( (PWINSTATIONPRODIDA)pWinStationInformation, 
                                                                (PWINSTATIONPRODIDW)pInfo );
                        *pReturnLength = ValidInputLength;
                        break;

        default:
            break;
    }
    return(TRUE);
}

/*******************************************************************************
 *
 *  WinStationQueryInformationW (UNICODE)
 *
 *    Queries configuration information about a window station object.
 *
 * ENTRY:
 *
 *    WinStationHandle (input)
 *       Identifies the window station object. The handle must have
 *       WINSTATION_QUERY access.
 *
 *    WinStationInformationClass (input)
 *       Specifies the type of information to retrieve from the specified
 *       window station object.
 *
 *    pWinStationInformation (output)
 *       A pointer to a buffer that will receive information about the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being queried.
 *
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 *    pReturnLength (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes placed in the window station information buffer.
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationQueryInformationW(
        HANDLE hServer,
        ULONG  LogonId,
        WINSTATIONINFOCLASS WinStationInformationClass,
        PVOID  pWinStationInformation,
        ULONG WinStationInformationLength,
        PULONG  pReturnLength
        )
{
    DWORD Result;
    BOOLEAN rc;
    PCHAR RpcBuf;
    ULONG RpcBufLen;
    PVOID WireBuf;
    PVOID AllocatedBuff = NULL;
    ULONG WireBufLen;
    BOOLEAN WireBufAllocated;
    ULONG Status;
    static UINT AlreadyWaitedForTermsrv = 0; // a flag which helps to determine if we already waited for TermSrv to be up

    if ((Status = CheckUserBuffer(WinStationInformationClass,
                                  pWinStationInformation,
                                  WinStationInformationLength,
                                  &WireBuf,
                                  &WireBufLen,
                                  &WireBufAllocated)) != ERROR_SUCCESS) {
        SetLastError(Status);
        return(FALSE);
    }

    if (WireBufAllocated) {
        AllocatedBuff = WireBuf;
        RpcBuf = (PCHAR) WireBuf;
        RpcBufLen = WireBufLen;
        CopyInWireBuf(WinStationInformationClass,
                      pWinStationInformation,
                      WireBuf);
    } else {
        RpcBuf = (PCHAR) pWinStationInformation;
        RpcBufLen = WinStationInformationLength;
    }


    HANDLE_CURRENT_BINDING_BUFFER( hServer, AllocatedBuff );

    // First wait for termsrv to get started if User Token is queried
    // This is for Session 0 only where termsrv is started after 60 seconds on Per and Pro
    // Need to do this only for the first time - AlreadyWaitedForTermsrv flag helps to determine this

    if ( (LogonId == 0) && (WinStationInformationClass == WinStationUserToken) && (AlreadyWaitedForTermsrv == 0) ) {

        HANDLE ReadyEventHandle ;

        ReadyEventHandle = OpenEvent(SYNCHRONIZE, FALSE, TEXT("Global\\TermSrvReadyEvent"));
        if (ReadyEventHandle != NULL) {
            DWORD dwTimeOut = 1000*60*3;   // 3 minutes
            AlreadyWaitedForTermsrv++;
            // wait until termsrv is actually ready.
            WaitForSingleObject(ReadyEventHandle, dwTimeOut);
            CloseHandle(ReadyEventHandle);
        } 
    }
     

    RpcTryExcept {

        rc = RpcWinStationQueryInformation(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     (DWORD)WinStationInformationClass,
                     RpcBuf,
                     RpcBufLen,
                     pReturnLength
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (WireBufAllocated) {
        if (rc) {
            CopyOutWireBuf(WinStationInformationClass,
                           pWinStationInformation,
                           WireBuf);
            *pReturnLength = WinStationInformationLength;
        }
        LocalFree(WireBuf);
    }

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationSetInformationA (ANSI stub)
 *
 *    Sets configuration information for a window station object.
 *
 * ENTRY:
 *
 *    see WinStationSetInformationW
 *
 * EXIT:
 *
 *    see WinStationSetInformationW
 *
 ******************************************************************************/

BOOLEAN
WinStationSetInformationA(
        HANDLE hServer,
        ULONG  LogonId,
        WINSTATIONINFOCLASS WinStationInformationClass,
        PVOID pWinStationInformation,
        ULONG WinStationInformationLength
        )
{
    PVOID pInfo;
    ULONG InfoLength;
    struct {
        union {
            WINSTATIONCREATEW      CreateData;
            WINSTATIONCONFIGW      Configuration;
            PDPARAMSW              PdParams;
            WDCONFIGW              Wd;
            PDCONFIGW              Pd;
            WINSTATIONPRINTERW     Printer;
            WINSTATIONINFORMATIONW Information;
        };
    } Info;

    /*
     * Validate the caller supplied buffer length and convert to the
     * appropriate UNICODE buffer for call to WinStationSetInformationW.
     */
    switch ( WinStationInformationClass ) {

        case WinStationCreateData:
            pInfo = &Info.CreateData;
            InfoLength = sizeof(Info.CreateData);
            if ( WinStationInformationLength != sizeof(WINSTATIONCREATEA) )
                goto BadBufferLength;
            WinStationCreateA2U( (PWINSTATIONCREATEW)pInfo,
                                 (PWINSTATIONCREATEA)pWinStationInformation );
            break;

        case WinStationConfiguration:
            pInfo = &Info.Configuration;
            InfoLength = sizeof(Info.Configuration);
            if ( WinStationInformationLength != sizeof(WINSTATIONCONFIGA) )
                goto BadBufferLength;
            WinStationConfigA2U( (PWINSTATIONCONFIGW)pInfo,
                                 (PWINSTATIONCONFIGA)pWinStationInformation );
            break;

        case WinStationPdParams:
            pInfo = &Info.PdParams;
            InfoLength = sizeof(Info.PdParams);
            if ( WinStationInformationLength != sizeof(PDPARAMSA) )
                goto BadBufferLength;
            PdParamsA2U( (PPDPARAMSW)pInfo,
                          (PPDPARAMSA)pWinStationInformation );
            break;

        case WinStationWd:
            pInfo = &Info.Wd;
            InfoLength = sizeof(Info.Wd);
            if ( WinStationInformationLength != sizeof(WDCONFIGA) )
                goto BadBufferLength;
            WdConfigA2U( (PWDCONFIGW)pInfo,
                               (PWDCONFIGA)pWinStationInformation );
            break;

        case WinStationPd:
            pInfo = &Info.Pd;
            InfoLength = sizeof(Info.Pd);
            if ( WinStationInformationLength != sizeof(PDCONFIGA) )
                goto BadBufferLength;
            PdConfig2A2U( &((PPDCONFIGW)pInfo)->Create,
                           &((PPDCONFIGA)pWinStationInformation)->Create );
            PdParamsA2U( &((PPDCONFIGW)pInfo)->Params,
                          &((PPDCONFIGA)pWinStationInformation)->Params );
            break;

        case WinStationPrinter:
            pInfo = &Info.Printer;
            InfoLength = sizeof(Info.Printer);
            if ( WinStationInformationLength != sizeof(WINSTATIONPRINTERA) )
                goto BadBufferLength;
            WinStationPrinterA2U( (PWINSTATIONPRINTERW)pInfo,
                                  (PWINSTATIONPRINTERA)pWinStationInformation );
            break;

        case WinStationInformation:
            pInfo = &Info.Information;
            InfoLength = sizeof(Info.Information);
            if ( WinStationInformationLength != sizeof(WINSTATIONINFORMATIONA) )
                goto BadBufferLength;
            WinStationInformationA2U( (PWINSTATIONINFORMATIONW)pInfo,
                                      (PWINSTATIONINFORMATIONA)pWinStationInformation );
            break;

        /*
         * The other WINSTATIONINFOCLASSes don't need converting.
         */
        default:
            pInfo = pWinStationInformation;
            InfoLength = WinStationInformationLength;
            break;
    }

    /*
     * Call the WinStationSetInformationW function and return it's
     * status.
     */
    return ( WinStationSetInformationW( hServer, LogonId,
                                          WinStationInformationClass,
                                          pInfo, InfoLength ) );

/*--------------------------------------
 * Error clean-up and return...
 */
BadBufferLength:
    SetLastError(ERROR_INSUFFICIENT_BUFFER);
    return(FALSE);
}

/*******************************************************************************
 *
 *  WinStationSetInformationW (UNICODE)
 *
 *    Sets configuration information for a window station object.
 *
 * ENTRY:
 *
 *    WinStationHandle (input)
 *       Identifies the window station object. The handle must have
 *       WINSTATION_SET access.
 *
 *    WinStationInformationClass (input)
 *       Specifies the type of information to retrieve from the specified
 *       window station object.
 *
 *    pWinStationInformation (input)
 *       A pointer to a buffer that contains information to set for the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being set.
 *
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 * EXIT:
 *
 *    TRUE  -- The set operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationSetInformationW(
        HANDLE hServer,
        ULONG  LogonId,
        WINSTATIONINFOCLASS WinStationInformationClass,
        PVOID pWinStationInformation,
        ULONG WinStationInformationLength
        )
{
    DWORD Result;
    BOOLEAN rc;
    PCHAR RpcBuf;
    ULONG RpcBufLen;
    PVOID WireBuf;
    PVOID AllocatedBuff = NULL;
    ULONG WireBufLen;
    BOOLEAN WireBufAllocated;
    ULONG Status;

    if ((Status = CheckUserBuffer(WinStationInformationClass,
                                  pWinStationInformation,
                                  WinStationInformationLength,
                                  &WireBuf,
                                  &WireBufLen,
                                  &WireBufAllocated)) != ERROR_SUCCESS) {
        SetLastError(Status);
        return(FALSE);
    }

    if (WireBufAllocated) {
        AllocatedBuff = WireBuf;
        RpcBuf = (PCHAR) WireBuf;
        RpcBufLen = WireBufLen;
        CopyInWireBuf(WinStationInformationClass,
                      pWinStationInformation,
                      WireBuf);
    } else {
        RpcBuf = (PCHAR) pWinStationInformation;
        RpcBufLen = WinStationInformationLength;
    }

    HANDLE_CURRENT_BINDING_BUFFER( hServer, AllocatedBuff );

    RpcTryExcept {

        rc = RpcWinStationSetInformation(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     (DWORD)WinStationInformationClass,
                     RpcBuf,
                     RpcBufLen
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (WireBufAllocated) {
        LocalFree(WireBuf);
    }

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationSendMessageA (ANSI stub)
 *
 *    Sends a message to the specified window station object and optionally
 *    waits for a reply.  The reply is returned to the caller of
 *    WinStationSendMessage.
 *
 * ENTRY:
 *
 *    see WinStationSendMessageW
 *
 * EXIT:
 *
 *    see WinStationSendMessageW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

BOOLEAN
WinStationSendMessageA(
        HANDLE hServer,
        ULONG  LogonId,
        LPSTR  pTitle,
        ULONG TitleLength,
        LPSTR  pMessage,
        ULONG MessageLength,
        ULONG Style,
        ULONG Timeout,
        PULONG pResponse,
        BOOLEAN DoNotWait
        )
{
    BOOLEAN status;
    LPWSTR pTitleW, pMessageW;
    ULONG TitleLengthW, MessageLengthW;

    /*
     * Allocate a buffer for UNICODE version of Title and convert.
     */
    if ( !(pTitleW = LocalAlloc( 0,
                                 TitleLengthW =
                                    (TitleLength*sizeof(WCHAR)) )) ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    AnsiToUnicode( pTitleW, TitleLengthW, pTitle );

    /*
     * Allocate a buffer for UNICODE version of Message and convert.
     */
    if ( !(pMessageW = LocalAlloc( 0,
                                 MessageLengthW =
                                    (MessageLength*sizeof(WCHAR)) )) ) {
        LocalFree(pTitleW);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    AnsiToUnicode( pMessageW, MessageLengthW, pMessage );

    /*
     * Call WinStationSendMessageW
     */
    status = WinStationSendMessageW( hServer,
                                     LogonId,
                                     pTitleW,
                                     TitleLengthW,
                                     pMessageW,
                                     MessageLengthW,
                                     Style,
                                     Timeout,
                                     pResponse,
                                     DoNotWait );

    /*
     * Free allocated buffers and return status.
     */
    LocalFree(pTitleW);
    LocalFree(pMessageW);
    return(status);
}

/*******************************************************************************
 *
 *  WinStationSendMessageW (UNICODE)
 *
 *    Sends a message to the specified window station object and optionally
 *    waits for a reply.  The reply is returned to the caller of
 *    WinStationSendMessage.
 *
 * ENTRY:
 *
 *    WinStationHandle (input)
 *       Specifies the window station object to send a message to.
 *
 *    pTitle (input)
 *       Pointer to title for message box to display.
 *
 *    TitleLength (input)
 *       Length of title to display in bytes.
 *
 *    pMessage (input)
 *       Pointer to message to display.
 *
 *    MessageLength (input)
 *       Length of message in bytes to display at the specified window station.
 *
 *    Style (input)
 *       Standard Windows MessageBox() style parameter.
 *
 *    Timeout (input)
 *       Response timeout in seconds.  If message is not responded to in
 *       Timeout seconds then a response code of IDTIMEOUT (cwin.h) is
 *       returned to signify the message timed out.
 *
 *    pResponse (output)
 *       Address to return selected response.
 *
 *    DoNotWait (input)
 *       Do not wait for the response. Causes pResponse to be set to
 *       IDASYNC (cwin.h) if no errors queueing the message.
 *
 * EXIT:
 *
 *    TRUE  -- The send message operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationSendMessageW(
        HANDLE hServer,
        ULONG  LogonId,
        LPWSTR  pTitle,
        ULONG TitleLength,
        LPWSTR  pMessage,
        ULONG MessageLength,
        ULONG Style,
        ULONG Timeout,
        PULONG pResponse,
        BOOLEAN DoNotWait
        )
{
    DWORD Result;
    BOOLEAN rc;
    WCHAR*  rpcBuffer1;
    WCHAR*  rpcBuffer2;


    HANDLE_CURRENT_BINDING( hServer );

//  Since, due to legacy clients, we cannot change the interface,
//  as a workarround to bug#265954, we double the size of RPC Buffers.

    rpcBuffer1 = LocalAlloc(LPTR, MessageLength * sizeof(WCHAR));
    if (rpcBuffer1 != NULL) {
        CopyMemory(rpcBuffer1, pMessage, MessageLength);
    } else {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    rpcBuffer2 = LocalAlloc(LPTR, TitleLength * sizeof(WCHAR));
    if (rpcBuffer2 != NULL) {
        CopyMemory(rpcBuffer2, pTitle, TitleLength);
    } else {
        LocalFree(rpcBuffer1);
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }


    RpcTryExcept {

        rc = RpcWinStationSendMessage(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     rpcBuffer2,
                     TitleLength,
                     rpcBuffer1,
                     MessageLength,
                     Style,
                     Timeout,
                     pResponse,
                     DoNotWait
                     );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    LocalFree(rpcBuffer1);
    LocalFree(rpcBuffer2);
    if (!rc) {
        SetLastError( Result );
    }

    return( rc );
}

/*******************************************************************************
 *
 *  LogonIdFromWinStationNameA (ANSI stub)
 *
 *    Returns the LogonId for the specified window station name.
 *
 * ENTRY:
 *
 *    see LogonIdFromWinStationNameW
 *
 * EXIT:
 *
 *    see LogonIdFromWinStationNameW
 *
 ******************************************************************************/

BOOLEAN
LogonIdFromWinStationNameA(
        HANDLE hServer,
        PWINSTATIONNAMEA pWinStationName,
        PULONG pLogonId
        )
{
    WINSTATIONNAMEW WinStationNameW;

    /*
     * Convert ANSI WinStationName to UNICODE.
     */
    AnsiToUnicode( WinStationNameW, sizeof(WINSTATIONNAMEW), pWinStationName );

    /*
     * Call LogonIdFromWinStationNameW & return it's status.
     */
    return ( LogonIdFromWinStationNameW( hServer, WinStationNameW, pLogonId ) );
}

/*******************************************************************************
 *
 *  LogonIdFromWinStationNameW (UNICODE)
 *
 *    Returns the LogonId for the specified window station name.
 *
 * ENTRY:
 *
 *    pWinStationName (input)
 *       Window station name.
 *
 *    pLogonId (output)
 *       Pointer to where to place the LogonId if found
 *
 * EXIT:
 *
 *    If the function succeeds, the return value is TRUE, otherwise, it is
 *    FALSE.
 *    To get extended error information, use the GetLastError function.
 *
 ******************************************************************************/

BOOLEAN
LogonIdFromWinStationNameW(
        HANDLE hServer,
        PWINSTATIONNAMEW pWinStationName,
        PULONG pLogonId
        )
{
    DWORD   Result;
    BOOLEAN rc;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    /*
     *  rpcBuffer is a workaround for bug 229753. The bug can't be fixed
     *  completely without breaking TS4 clients.
     */

#pragma prefast(suppress:260, legacy clients expect this (http://searchraid/ntbug/229753.asp))
    rpcBuffer = LocalAlloc(LPTR, sizeof(WINSTATIONNAMEW) * sizeof(WCHAR));
    if (rpcBuffer != NULL) {
        CopyMemory(rpcBuffer, pWinStationName, sizeof(WINSTATIONNAMEW));
    } else {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    RpcTryExcept {

        rc = RpcLogonIdFromWinStationName(
                    hServer,
                    &Result,
                    rpcBuffer,
                    sizeof(WINSTATIONNAMEW),
                    pLogonId
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*******************************************************************************
 *
 *  WinStationNameFromLogonIdA (ANSI stub)
 *
 *    Returns the WinStation name for the specified LogonId.
 *
 * ENTRY:
 *
 *    see WinStationNameFromLogonIdW
 *
 * EXIT:
 *
 *    see WinStationNameFromLogonIdW
 *
 ******************************************************************************/

BOOLEAN
WinStationNameFromLogonIdA(
        HANDLE hServer,
        ULONG LogonId,
        PWINSTATIONNAMEA pWinStationName
        )
{
    BOOLEAN Result;
    WINSTATIONNAMEW WinStationNameW;

    /*
     * Call WinStationNameFromLogonIdW
     */
    Result = WinStationNameFromLogonIdW( hServer, LogonId, WinStationNameW );

    /*
     * if successful, convert UNICODE WinStationName to ANSI.
     */
    if ( Result ) {
        UnicodeToAnsi( pWinStationName, sizeof(WINSTATIONNAMEA), WinStationNameW );
    }

    return( Result );
}

/*******************************************************************************
 *
 *  WinStationNameFromLogonIdW (UNICODE)
 *
 *    Returns the WinStation name for the specified LogonId.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       LogonId to query
 *
 *    pWinStationName (output)
 *       Location to return WinStation name
 *
 * EXIT:
 *
 *    If the function succeeds, the return value is TRUE, otherwise, it is
 *    FALSE.
 *    To get extended error information, use the GetLastError function.
 *
 ******************************************************************************/

BOOLEAN
WinStationNameFromLogonIdW(
        HANDLE hServer,
        ULONG LogonId,
        PWINSTATIONNAMEW pWinStationName
        )
{
    DWORD   Result;
    BOOLEAN rc;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    /*
     *  rpcBuffer is a workaround for bug 229753. The bug can't be fixed
     *  completely without breaking TS4 clients.
     */

#pragma prefast(suppress:260, legacy clients expect this (http://searchraid/ntbug/229753.asp))
    rpcBuffer = LocalAlloc(LPTR, sizeof(WINSTATIONNAMEW) * sizeof(WCHAR));
    if (rpcBuffer == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    RpcTryExcept {

        rc = RpcWinStationNameFromLogonId(
                    hServer,
                    &Result,
                    (LogonId == LOGONID_CURRENT) ?
                        NtCurrentPeb()->SessionId : LogonId,
                    rpcBuffer,
                    sizeof(WINSTATIONNAMEW)
                    );

        Result = RtlNtStatusToDosError( Result );
        if (rc) {
            CopyMemory(pWinStationName, rpcBuffer, sizeof(WINSTATIONNAMEW));
        }

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*******************************************************************************
 *
 *  WinStationConnectA (ANSI stub)
 *
 *    Connects a window station object to the configured terminal and Pd.
 *
 * ENTRY:
 *
 *    see WinStationConnectW
 *
 * EXIT:
 *
 *    see WinStationConnectW
 *
 ******************************************************************************/

BOOLEAN
WinStationConnectA( HANDLE hServer,
                    ULONG LogonId,
                    ULONG TargetLogonId,
                    PCHAR pPassword,
                    BOOLEAN bWait )
{
    WCHAR PasswordW[ PASSWORD_LENGTH + 1 ];

    /*
     * Convert ANSI Password to UNICODE.
     */

    AnsiToUnicode( PasswordW, sizeof(PasswordW), pPassword );

    /*
     * Call WinStationConnectW & return it's status.
     */
    return ( WinStationConnectW( hServer, LogonId, TargetLogonId, PasswordW, bWait ) );
}

/*******************************************************************************
 *
 *  WinStationConnectW (UNICODE)
 *
 *    Connects a window station object to the configured terminal and Pd.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       ID of window station object to connect.
 *
 *    TargetLogonId (input)
 *       ID of target window station.
 *
 *    pPassword (input)
 *       password of LogonId window station (not needed if same domain/username)
 *
 *    bWait (input)
 *       Specifies whether or not to wait for connect to complete
 *
 * EXIT:
 *
 *    TRUE  -- The connect operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationConnectW(
    HANDLE hServer,
    ULONG LogonId,
    ULONG TargetLogonId,
    PWCHAR pPassword,
    BOOLEAN bWait
    )
{
    DWORD   Result;
    BOOLEAN rc;
    DWORD   PasswordLength;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        if( pPassword ) {
            PasswordLength = (lstrlenW( pPassword ) + 1) * sizeof(WCHAR);

            /*
             *  rpcBuffer is a workaround for bug 229753. The bug can't be
             *  fixed completely without breaking TS4 clients.
             */

            rpcBuffer = LocalAlloc(LPTR, PasswordLength * sizeof(WCHAR));
            if (rpcBuffer != NULL) {
                CopyMemory(rpcBuffer, pPassword, PasswordLength);
            } else {
                SetLastError(ERROR_OUTOFMEMORY);
                return(FALSE);
            }

        } else {
            PasswordLength = 0;
            rpcBuffer = NULL;
        }

        rc = RpcWinStationConnect(
                    hServer,
                    &Result,
                    NtCurrentPeb()->SessionId,
                    (LogonId == LOGONID_CURRENT) ?
                        NtCurrentPeb()->SessionId : LogonId,
                    (TargetLogonId == LOGONID_CURRENT) ?
                        NtCurrentPeb()->SessionId : TargetLogonId,
                    rpcBuffer,
                    PasswordLength,
                    bWait
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************
 *
 *  WinStationVirtualOpen
 *
 *   Open a virtual channel
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

HANDLE WINAPI
WinStationVirtualOpen(
    HANDLE hServer,
    ULONG LogonId,
    PVIRTUALCHANNELNAME pVirtualName   /* ascii name */
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   NameLength;
    ULONG_PTR VirtualHandle = (ULONG_PTR)0;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        if( pVirtualName )
            NameLength = strlen( pVirtualName ) + 1;
        else
            NameLength = 0;

        rc = RpcWinStationVirtualOpen(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     GetCurrentProcessId(),
                     (PCHAR)pVirtualName,
                     NameLength,
                     &VirtualHandle
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) {
            SetLastError(Result);
            VirtualHandle = (ULONG_PTR)0;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( (HANDLE) ( VirtualHandle ) );
}

/*****************************************************************************
 *
 *  _WinStationBeepOpen
 *
 *   Open a beep channel
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

HANDLE WINAPI
_WinStationBeepOpen(
    ULONG LogonId
    )
{
    BOOLEAN rc;
    DWORD   Result;
    ULONG_PTR VirtualHandle = (ULONG_PTR)0;
    HANDLE hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationBeepOpen(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     GetCurrentProcessId(),
                     &VirtualHandle
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) {
            SetLastError(Result);
            VirtualHandle = (ULONG_PTR)0;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( (HANDLE) ( VirtualHandle ) );
}

/*******************************************************************************
 *
 *  WinStationDisconnect
 *
 *    Disconects a window station object from the configured terminal and Pd.
 *    While disconnected all window station i/o is bit bucketed.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       ID of window station object to disconnect.
 *    bWait (input)
 *       Specifies whether or not to wait for disconnect to complete
 *
 * EXIT:
 *
 *    TRUE  -- The disconnect operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationDisconnect(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN bWait
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationDisconnect(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     bWait
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationReset
 *
 *    Reset the specified window station.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       Identifies the window station object to reset.
 *    bWait (input)
 *       Specifies whether or not to wait for reset to complete
 *
 * EXIT:
 *
 *    TRUE  -- The reset operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationReset(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN bWait
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationReset(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     bWait
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationShadowStop
 *
 *    Stop the shadow on the specified window station.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       Identifies the window station object to stop the shadow on.
 *    bWait (input)
 *       Specifies whether or not to wait for reset to complete
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationShadowStop(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN bWait
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationShadowStop(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     bWait
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationShutdownSystem
 *
 *    Shutdown the system and optionally logoff all WinStations
 *    and/or reboot the system.
 *
 * ENTRY:
 *
 *    ShutdownFlags (input)
 *       Flags which specify shutdown options.
 *
 * EXIT:
 *
 *    TRUE  -- The shutdown operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationShutdownSystem(
    HANDLE hServer,
    ULONG ShutdownFlags
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationShutdownSystem(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     ShutdownFlags
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationTerminateProcess
 *
 *    Terminate the specified process
 *
 * ENTRY:
 *
 *    hServer (input)
 *       handle to winframe server
 *    ProcessId (input)
 *       process id of the process to terminate
 *    ExitCode (input)
 *       Termination status for each thread in the process
 *
 *
 * EXIT:
 *
 *    TRUE  -- The terminate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationTerminateProcess(
    HANDLE hServer,
    ULONG ProcessId,
    ULONG ExitCode
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationTerminateProcess(
                     hServer,
                     &Result,
                     ProcessId,
                     ExitCode
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}


/*******************************************************************************
 *
 *  WinStationWaitSystemEvent
 *
 *    Waits for an event (WinStation create, delete, connect, etc) before
 *    returning to the caller.
 *
 * ENTRY:
 *
 *    EventFlags (input)
 *       Bit mask that specifies which event(s) to wait for.
 *    pEventFlags (output)
 *       Bit mask of event(s) that occurred.
 *
 * EXIT:
 *
 *    TRUE  -- The wait event operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationWaitSystemEvent(
    HANDLE hServer,
    ULONG EventMask,
    PULONG pEventFlags
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationWaitSystemEvent(
                     hServer,
                     &Result,
                     EventMask,
                     pEventFlags
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  WinStationShadow
 *
 *   Start a Winstation shadow operation
 *
 * ENTRY:
 *   hServer (input)
 *     open RPC server handle
 *   pTargetServerName (input)
 *     name of target WinFrame server
 *   TargetLogonId (input)
 *     shadow target login id (where the app is running)
 *   HotkeyVk (input)
 *     virtual key to press to stop shadow
 *   HotkeyModifiers (input)
 *     virtual modifer to press to stop shadow (i.e. shift, control)
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
WinStationShadow(
    HANDLE hServer,
    LPWSTR pTargetServerName,
    ULONG TargetLogonId,
    BYTE HotkeyVk,
    USHORT HotkeyModifiers
    )
{
    DWORD   NameSize;
    DWORD   Result;
    BOOLEAN rc;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        if ( pTargetServerName && *pTargetServerName ) {
            NameSize = (lstrlenW( pTargetServerName ) + 1) * sizeof(WCHAR);

            /*
             *  rpcBuffer is a workaround for bug 229753. The bug can't be
             *  fixed completely without breaking TS4 clients.
             */

            rpcBuffer = LocalAlloc(LPTR, NameSize * sizeof(WCHAR));
            if (rpcBuffer != NULL) {
                CopyMemory(rpcBuffer, pTargetServerName, NameSize);
            } else {
                SetLastError(ERROR_OUTOFMEMORY);
                return(FALSE);
            }

        } else {
            NameSize = 0;
            rpcBuffer = NULL;
        }

        rc = RpcWinStationShadow(
                    hServer,
                    &Result,
                    NtCurrentPeb()->SessionId,
                    rpcBuffer,
                    NameSize,
                    TargetLogonId,
                    HotkeyVk,
                    HotkeyModifiers
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}


/*****************************************************************************
 *
 *  _WinStationShadowTargetSetup
 *
 *   private api used to initialize the target size of a shadow
 *
 * ENTRY:
 *   hServer (input)
 *      target server
 *   LogonId (input)
 *      target logon id
 *   pClientName (input)
 *      pointer to client name string (domain/username)
 *   ClientNameLength (input)
 *      length of client name string
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationShadowTargetSetup(
    HANDLE hServer,
    ULONG LogonId
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationShadowTargetSetup(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId
                     );

        //Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(RtlNtStatusToDosError(Result));
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}


/*****************************************************************************
 *
 *  _WinStationShadowTarget
 *
 *   private api used to initialize the target size of a shadow
 *
 * ENTRY:
 *   hServer (input)
 *      target server
 *   LogonId (input)
 *      target logon id
 *   pConfig (input)
 *      pointer to WinStation config data (to configure shadow stack)
 *   pAddress (input)
 *      address of shadow client
 *   pModuleData (input)
 *      pointer to client module data
 *   ModuleDataLength (input)
 *      length of client module data
 *   pThinwireData (input)
 *      pointer to thinwire module data
 *   ThinwireDataLength (input)
 *      length of thinwire module data
 *   pClientName (input)
 *      pointer to client name string (domain/username)
 *   ClientNameLength (input)
 *      length of client name string
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS WINAPI
_WinStationShadowTarget(
    HANDLE hServer,
    ULONG LogonId,
    PWINSTATIONCONFIG2 pConfig,
    PICA_STACK_ADDRESS pAddress,
    PVOID pModuleData,
    ULONG ModuleDataLength,
    PVOID pThinwireData,
    ULONG ThinwireDataLength,
    PVOID pClientName,
    ULONG ClientNameLength
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationShadowTarget(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     (PBYTE) pConfig,
                     sizeof(*pConfig),
                     (PBYTE) pAddress,
                     sizeof(*pAddress),
                     pModuleData,
                     ModuleDataLength,
                     pThinwireData,
                     ThinwireDataLength,
                     pClientName,
                     ClientNameLength
                     );

        // Since a program has called us, we need to set the last error code such
        // that extended error information is available
        if (!rc)
            SetLastError(RtlNtStatusToDosError(Result));
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return Result;
}


/*******************************************************************************
 *
 *  WinStationFreeMemory
 *
 *  Called to free memory which was allocated by a WinStation API.
 *
 * ENTRY:
 *       pBuffer (input)
 *
 * EXIT:
 *    TRUE  -- The install operation succeeded.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationFreeMemory(
    PVOID pBuffer
    )
{
    if ( pBuffer )
        LocalFree( pBuffer );
    return( TRUE );
}

/*******************************************************************************
 *
 *  WinStationFreeGAPMemory
 *
 *  Called to free memory which was allocated by the WinStationGetAllProcesses API.
 *
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationFreeGAPMemory(ULONG   Level,
                        PVOID   pProcArray,
                        ULONG   NumberOfProcesses)
{
    ULONG   i;
    PTS_ALL_PROCESSES_INFO  pProcessArray = (PTS_ALL_PROCESSES_INFO)pProcArray;

    if (Level == GAP_LEVEL_BASIC)   // only level supported right now
    {
        if ( pProcessArray != NULL)
        {
            for (i=0; i < NumberOfProcesses ; i++)
            {
                if (pProcessArray[i].pTsProcessInfo != NULL)
                {
                    if (((pProcessArray[i].pTsProcessInfo)->ImageName).Buffer  != NULL)
                    {
                        //
                        //  free the ImageName string
                        //
                        LocalFree(((pProcessArray[i].pTsProcessInfo)->ImageName).Buffer);
                    }
                    //
                    //  free the Process Info buffer
                    //
                    LocalFree(pProcessArray[i].pTsProcessInfo);
                }

                if (pProcessArray[i].pSid != NULL)
                {
                    //
                    //  free the SID
                    //
                    LocalFree(pProcessArray[i].pSid);
                }
            }

        LocalFree(pProcessArray);
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/*******************************************************************************
 *
 *  WinStationGenerateLicense
 *
 *  Called to generate a license from a given serial number string.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pSerialNumberString (input)
 *       Pointer to a null-terminated, wide-character Serial Number string
 *    pLicense (output)
 *       Pointer to a License structure that will be filled in with
 *       information based on pSerialNumberString
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *
 *    TRUE  -- The install operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationGenerateLicense(
    HANDLE hServer,
    PWCHAR pSerialNumberString,
    PVOID  pLicense,
    DWORD  LicenseSize
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   Length;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        if ( pSerialNumberString ) {
            Length = (lstrlenW( pSerialNumberString ) + 1) * sizeof(WCHAR);

            /*
             *  rpcBuffer is a workaround for 229753.
             */

            rpcBuffer = LocalAlloc(LPTR, Length * sizeof(WCHAR));
            if (rpcBuffer != NULL) {
                CopyMemory(rpcBuffer, pSerialNumberString, Length);
            } else {
                SetLastError(ERROR_OUTOFMEMORY);
                return(FALSE);
            }

        } else {
            Length = 0;
            rpcBuffer = NULL;
        }

        rc = RpcWinStationGenerateLicense(
                    hServer,
                    &Result,
                    rpcBuffer,
                    Length,
                    (PCHAR)pLicense,
                    LicenseSize
                    );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*******************************************************************************
 *
 *  WinStationInstallLicense
 *
 *  Called to install a license.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input)
 *       Pointer to a License structure containing the license to
 *       be installed
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *
 *    TRUE  -- The install operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationInstallLicense(
    HANDLE hServer,
    PVOID  pLicense,
    DWORD  LicenseSize
    )
{
    BOOLEAN rc;
    DWORD   Result;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationInstallLicense(
                     hServer,
                     &Result,
                     (PCHAR) pLicense,
                     LicenseSize
                     );

        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationEnumerateLicenses
 *
 *  Called to return the list of valid licenses.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    ppLicense (output)
 *       Points to a pointer to a buffer to receive the enumeration results,
 *       which are returned as an array of LICENSE structures.  The buffer is
 *       allocated within this API and is disposed of using
 *       WinStationFreeMemory.
 *    pEntries (output)
 *       Points to a variable specifying the number of entries read.
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

#define _LICENSE_REQUEST_SIZE 10
#define _LICENSE_SIZE         1024  // This is arbitrary
BOOLEAN
WinStationEnumerateLicenses(
    HANDLE hServer,
    PVOID  *ppLicense,
    DWORD  *pEntries
    )
{
    ULONG ByteCount;
    ULONG BumpSize;
    ULONG TotalSize;
    LONG Index;
    int i;
    BOOLEAN rc;
    DWORD   Result;

    HANDLE_CURRENT_BINDING( hServer );

    BumpSize =  _LICENSE_SIZE * _LICENSE_REQUEST_SIZE;
    TotalSize = 0;
    *ppLicense = NULL;
    *pEntries = 0;
    Index = 0;
    for ( ;; ) {
        PVOID pNewLicense;
        LONG BumpEntries;

        /*
         *  Allocate a enough memory for _LICENSE_REQUEST_SIZE more
         *  entries.
         */
        pNewLicense = LocalAlloc( 0, TotalSize + BumpSize );
        if ( !pNewLicense ) {
            if ( *ppLicense )
                WinStationFreeMemory( *ppLicense );
            SetLastError( ERROR_OUTOFMEMORY );
            return( FALSE );
        }

        /*
         * If this is not the first pass through, then copy
         * the previous buffer's contents to the new buffer.
         */
        if ( TotalSize ) {
            RtlCopyMemory( pNewLicense, *ppLicense, TotalSize );
            WinStationFreeMemory( *ppLicense );
        }
        *ppLicense = pNewLicense;

        /*
         *  Get up to _LICENSE_REQUEST_SIZE Licenses
         */
        ByteCount = BumpSize;
        BumpEntries = _LICENSE_REQUEST_SIZE;

        RpcTryExcept {

            rc = RpcWinStationEnumerateLicenses(
                         hServer,
                         &Result,
                         &Index,
                         &BumpEntries,
                         (PCHAR) (((PCHAR) *ppLicense) + TotalSize),
                         ByteCount,
                         &ByteCount
                         );

            Result = rc ? ERROR_SUCCESS : Result;
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            Result = RpcExceptionCode();
            DBGPRINT(("RPC Exception %d\n",Result));
        }
        RpcEndExcept

        if ( Result != ERROR_SUCCESS && Result != ERROR_NO_MORE_ITEMS ) {

            SetLastError( Result );
            return( FALSE );

        }
        else {
            /*
             *  Bump the Total Size of the License buffer by the size of
             *  the request
             */
            TotalSize += BumpSize;

            /*
             *  Include the new Licenses in the entry count
             */
            *pEntries += BumpEntries;

            if ( Result == ERROR_NO_MORE_ITEMS ) {
                return( TRUE );
            }
        }
    } // for ( ;; )
}

/*******************************************************************************
 *
 *  WinStationActivateLicense
 *
 *  Called to Activate a license for a given License
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input/output)
 *       Pointer to a License structure that will be activated
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *    pActivationCode (input)
 *       Pointer to a null-terminated, wide-character Activation Code string
 *
 * EXIT:
 *
 *    TRUE  -- The install operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationActivateLicense(
    HANDLE hServer,
    PVOID  pLicense,
    DWORD  LicenseSize,
    PWCHAR pActivationCode
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   Length;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        if ( pActivationCode ) {
            Length = (lstrlenW( pActivationCode ) + 1) * sizeof(WCHAR);

            /*
             *  rpcBuffer is a workaround for 229753.
             */

            rpcBuffer = LocalAlloc(LPTR, Length * sizeof(WCHAR));
            if (rpcBuffer != NULL) {
                CopyMemory(rpcBuffer, pActivationCode, Length);
            } else {
                SetLastError(ERROR_OUTOFMEMORY);
                return(FALSE);
            }

        } else {
            Length = 0;
            rpcBuffer = NULL;
        }

        rc = RpcWinStationActivateLicense(
                    hServer,
                    &Result,
                    (PCHAR)pLicense,
                    LicenseSize,
                    rpcBuffer,
                    Length
                    );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}


/*****************************************************************************
 *
 *  WinStationQueryLicense
 *
 *   Query the license(s) on the WinFrame server and the network
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicenseCounts (output)
 *       pointer to buffer to return license count structure
 *    ByteCount (input)
 *       length of buffer in bytes
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
WinStationQueryLicense(
    HANDLE hServer,
    PVOID pLicenseCounts,
    ULONG ByteCount
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        memset( pLicenseCounts, 0, ByteCount );

        rc = RpcWinStationQueryLicense(
                     hServer,
                     &Result,
                     (PCHAR) pLicenseCounts,
                     ByteCount
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  WinStationQueryUpdateRequired
 *
 *   Query the license(s) on the WinFrame server and determine if an
 *   update is required. (worker)
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pUpdateFlag (output)
 *       Update flag, set if an update is required
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
WinStationQueryUpdateRequired(
    HANDLE hServer,
    PULONG pUpdateFlag
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationQueryUpdateRequired(
                     hServer,
                     &Result,
                     pUpdateFlag
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationRemoveLicense
 *
 *  Called to remove a license diskette.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input)
 *       Pointer to a License structure containing the license to
 *       be removed
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *
 *    TRUE  -- The install operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationRemoveLicense(
    HANDLE hServer,
    PVOID  pLicense,
    DWORD  LicenseSize
    )
{
    BOOLEAN rc;
    DWORD   Result;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationRemoveLicense(
                     hServer,
                     &Result,
                     (PCHAR) pLicense,
                     LicenseSize
                     );

        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationSetPoolCount
 *
 *  Called to change the PoolCount for a given License
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input/output)
 *       Pointer to a License structure that will be changed
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *
 *    TRUE  -- The change operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationSetPoolCount(
    HANDLE hServer,
    PVOID  pLicense,
    DWORD  LicenseSize
    )
{
    BOOLEAN rc;
    DWORD   Result;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationSetPoolCount(
                     hServer,
                     &Result,
                     (PCHAR) pLicense,
                     LicenseSize
                     );

        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}


/*****************************************************************************
 *
 *  _WinStationAnnoyancePopup
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationAnnoyancePopup(
    HANDLE hServer,
    ULONG LogonId
    )
{
    BOOLEAN rc;
    DWORD   Result;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationAnnoyancePopup(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationCallback
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationCallback(
    HANDLE hServer,
    ULONG LogonId,
    LPWSTR pPhoneNumber
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   Length;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        if( pPhoneNumber ) {
            Length = (lstrlenW( pPhoneNumber ) + 1) * sizeof(WCHAR);

            /*
             *  rpcBuffer is a workaround for 229753.
             */

            rpcBuffer = LocalAlloc(LPTR, Length * sizeof(WCHAR));
            if (rpcBuffer != NULL) {
                CopyMemory(rpcBuffer, pPhoneNumber, Length);
            } else {
                SetLastError(ERROR_OUTOFMEMORY);
                return(FALSE);
            }

        } else {
            Length = 0;
            rpcBuffer = NULL;
        }

        rc = RpcWinStationCallback(
                    hServer,
                    &Result,
                    (LogonId == LOGONID_CURRENT) ?
                        NtCurrentPeb()->SessionId : LogonId,
                    rpcBuffer,
                    Length
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationBreakPoint
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationBreakPoint(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN KernelFlag
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationBreakPoint(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     KernelFlag
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationReadRegistry
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationReadRegistry(
    HANDLE  hServer
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        rc = RpcWinStationReadRegistry(
                     hServer,
                     &Result
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationUpdateSettings
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationUpdateSettings(
    HANDLE  hServer,
    WINSTATIONUPDATECFGCLASS SettingsClass,
    DWORD SettingsParameters
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        rc = RpcWinStationUpdateSettings(
                     hServer,
                     &Result,
                     (DWORD)SettingsClass,
                     SettingsParameters
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}


/*****************************************************************************
 *
 *  _WinStationReInitializeSecurity
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationReInitializeSecurity(
    HANDLE  hServer
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        rc = RpcWinStationReInitializeSecurity(
                     hServer,
                     &Result
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationWaitForConnect
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationWaitForConnect(
    VOID
    )
{
    DWORD Result;
    BOOLEAN rc;
    HANDLE hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        if (NtCurrentPeb()->SessionId != 0) {
            DbgPrint("hServer == RPC_HANDLE_NO_SERVER for SessionId %d\n",NtCurrentPeb()->SessionId);
            ASSERT(FALSE);
            return FALSE;
        } else {
            return TRUE;
        }
    }

    RpcTryExcept {

        rc = RpcWinStationWaitForConnect(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId()
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationNotifyLogon
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationNotifyLogon(
    BOOLEAN fUserIsAdmin,
    HANDLE UserToken,
    PWCHAR pDomain,
    PWCHAR pUserName,
    PWCHAR pPassword,
    UCHAR Seed,
    PUSERCONFIGW pUserConfig,
    BOOLEAN *pfIsRedirected
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   DomainLength;
    DWORD   UserNameLength;
    DWORD   PasswordLength;
    HANDLE hServer = SERVERNAME_CURRENT;
    HANDLE ReadyEventHandle;
    DWORD TermSrvWaitTime = 180 * 1000;  // 3 Minutes
    WCHAR*  rpcBuffer1 = NULL;
    WCHAR*  rpcBuffer2 = NULL;
    WCHAR*  rpcBuffer3 = NULL;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    //
    // Wait for the TermSrvReadyEvent to be set by TERMSRV.EXE.  This
    // event indicates that TermSrv is initialized to the point that
    // the data used by _WinStationNotifyLogon() is available.
    //
    ReadyEventHandle = OpenEvent(SYNCHRONIZE, FALSE, TEXT("Global\\TermSrvReadyEvent"));
    if (ReadyEventHandle != NULL)
       {
       if (WaitForSingleObject(ReadyEventHandle, TermSrvWaitTime) != 0)
          {
          DBGPRINT(("WinLogon:  Wait for ReadyEventHandle failed\n"));
          }
       CloseHandle(ReadyEventHandle);
       }
    else
       {
       DBGPRINT(("WinLogon:  Create failed for ReadyEventHandle\n"));
       }


    RpcTryExcept {

        if( pDomain ) {
            DomainLength = (lstrlenW( pDomain ) + 1) * sizeof(WCHAR);

            /*
             *  rpcBuffer[1,2,3] is a workaround for 229753.
             */

            rpcBuffer1 = LocalAlloc(LPTR, DomainLength * sizeof(WCHAR));
            if (rpcBuffer1 != NULL) {
                CopyMemory(rpcBuffer1, pDomain, DomainLength);
            } else {
                Result = ERROR_OUTOFMEMORY;
                rc = FALSE;
                goto Error;
            }

        } else {
            DomainLength = 0;
            rpcBuffer1 = NULL;
        }

        if( pUserName ) {
            UserNameLength = (lstrlenW( pUserName ) + 1) * sizeof(WCHAR);

            rpcBuffer2 = LocalAlloc(LPTR, UserNameLength * sizeof(WCHAR));
            if (rpcBuffer2 != NULL) {
                CopyMemory(rpcBuffer2, pUserName, UserNameLength);
            } else {
                Result = ERROR_OUTOFMEMORY;
                rc = FALSE;
                goto Error;
            }

        } else {
            UserNameLength = 0;
            rpcBuffer2 = NULL;
        }

        if( pPassword ) {
            PasswordLength = (lstrlenW( pPassword ) + 1) * sizeof(WCHAR);

            rpcBuffer3 = LocalAlloc(LPTR, PasswordLength * sizeof(WCHAR));
            if (rpcBuffer3 != NULL) {
                CopyMemory(rpcBuffer3, pPassword, PasswordLength);
            } else {
                Result = ERROR_OUTOFMEMORY;
                rc = FALSE;
                goto Error;
            }

        } else {
            PasswordLength = 0;
            rpcBuffer3 = NULL;
        }

        rc = RpcWinStationNotifyLogon(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId(),
                     fUserIsAdmin,
                     (DWORD)(INT_PTR)UserToken,
                     rpcBuffer1,
                     DomainLength,
                     rpcBuffer2,
                     UserNameLength,
                     rpcBuffer3,
                     PasswordLength,
                     Seed,
                     (PCHAR)pUserConfig,
                     sizeof(*pUserConfig),
                     pfIsRedirected
                     );

        if( !rc ) {
            Result = RtlNtStatusToDosError( Result );

        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

Error:
    if (rpcBuffer1 != NULL) {
        LocalFree(rpcBuffer1);
    }

    if (rpcBuffer2 != NULL) {
        LocalFree(rpcBuffer2);
    }

    if (rpcBuffer3 != NULL) {
        LocalFree(rpcBuffer3);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationNotifyLogoff
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationNotifyLogoff(
    VOID
    )
{
    DWORD Result;
    BOOLEAN rc;
    HANDLE hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        rc = RpcWinStationNotifyLogoff(
                     hServer,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId(),
                     &Result
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}


/*****************************************************************************
 *
 *  _WinStationNotifyNewSession
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationNotifyNewSession(
    HANDLE hServer,
    ULONG  LogonId
    )
{
    DWORD Result;
    BOOLEAN rc;

    //
    //  If the local machine has no TSRPC interface running, this is most
    //  likely the console winlogon attempting to logon before termsrv.exe
    //  is running.
    //

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER )
    {
        return(TRUE);
    }
    
    RpcTryExcept {

        rc = RpcWinStationNotifyNewSession(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}



/*****************************************************************************
 *
 *  _RpcServerNWLogonSetAdmin
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_NWLogonSetAdmin(
    HANDLE hServer,
    PWCHAR pServerName,
    PNWLOGONADMIN pNWLogon
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   ServerNameLength;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    if (pServerName) {
        ServerNameLength = (lstrlenW(pServerName) + 1) * sizeof(WCHAR);

        /*
         *  rpcBuffer is a workaround for bug 229753. The bug can't be fixed
         *  completely without breaking TS4 clients.
         */

        rpcBuffer = LocalAlloc(LPTR, ServerNameLength * sizeof(WCHAR));
        if (rpcBuffer != NULL) {
            CopyMemory(rpcBuffer, pServerName, ServerNameLength);
        } else {
            SetLastError(ERROR_OUTOFMEMORY);
            return(FALSE);
        }

    } else {
        ServerNameLength = 0;
        rpcBuffer = NULL;
    }

    RpcTryExcept {

        rc = RpcServerNWLogonSetAdmin(
                    hServer,
                    &Result,
                    rpcBuffer,
                    ServerNameLength,
                    (PCHAR)pNWLogon,
                    sizeof(NWLOGONADMIN)
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************
 *
 *  _RpcServerNWLogonQueryAdmin
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_NWLogonQueryAdmin(
    HANDLE hServer,
    PWCHAR pServerName,
    PNWLOGONADMIN pNWLogon
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   ServerNameLength;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    if (pServerName) {
        ServerNameLength = (lstrlenW(pServerName) + 1) * sizeof(WCHAR);

        /*
         *  rpcBuffer is a workaround for bug 229753. The bug can't be fixed
         *  completely without breaking TS4 clients.
         */

        rpcBuffer = LocalAlloc(LPTR, ServerNameLength * sizeof(WCHAR));
        if (rpcBuffer != NULL) {
            CopyMemory(rpcBuffer, pServerName, ServerNameLength);
        } else {
            SetLastError(ERROR_OUTOFMEMORY);
            return(FALSE);
        }

    } else {
        ServerNameLength = 0;
        rpcBuffer = NULL;
    }

    RpcTryExcept {

        rc = RpcServerNWLogonQueryAdmin(
                    hServer,
                    &Result,
                    rpcBuffer,
                    ServerNameLength,
                    (PCHAR)pNWLogon,
                    sizeof(NWLOGONADMIN)
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*******************************************************************************
 *
 *  _WinStationCheckForApplicationName
 *
 *    Handles published applications.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
_WinStationCheckForApplicationName(
    HANDLE hServer,
    ULONG  LogonId,
    PWCHAR pUserName,
    DWORD  UserNameSize,
    PWCHAR pDomain,
    DWORD  DomainSize,
    PWCHAR pPassword,
    DWORD  *pPasswordSize,
    DWORD  MaxPasswordSize,
    PCHAR  pSeed,
    PBOOLEAN pfPublished,
    PBOOLEAN pfAnonymous
    )
{
    DWORD Result;
    BOOLEAN rc;
    WCHAR*  rpcBufferName;
    WCHAR*  rpcBufferDomain;
    WCHAR*  rpcBufferPassword;


    HANDLE_CURRENT_BINDING( hServer );

//  Since, due to legacy clients, we cannot change the interface,
//  as a workarround to bug#265954, we double the size of RPC Buffers.

    rpcBufferName = LocalAlloc(LPTR, UserNameSize * sizeof(WCHAR));
    if (rpcBufferName != NULL) {
        CopyMemory(rpcBufferName, pUserName, UserNameSize);
    } else {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    rpcBufferDomain = LocalAlloc(LPTR, DomainSize * sizeof(WCHAR));
    if (rpcBufferDomain != NULL) {
        CopyMemory(rpcBufferDomain, pDomain, DomainSize);
    } else {
        LocalFree(rpcBufferName);
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    rpcBufferPassword = LocalAlloc(LPTR,MaxPasswordSize * sizeof(WCHAR));
    if (rpcBufferPassword != NULL) {
        CopyMemory(rpcBufferPassword, pPassword, MaxPasswordSize);
    } else {
        LocalFree(rpcBufferName);
        LocalFree(rpcBufferDomain);
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }




    RpcTryExcept {

        rc = RpcWinStationCheckForApplicationName(
                 hServer,
                 &Result,
                 LogonId,
                 rpcBufferName,
                 UserNameSize,
                 rpcBufferDomain,
                 DomainSize,
                 rpcBufferPassword,
                 pPasswordSize,
                 MaxPasswordSize,
                 pSeed,
                 pfPublished,
                 pfAnonymous
                 );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    LocalFree(rpcBufferName);
    LocalFree(rpcBufferDomain);
    LocalFree(rpcBufferPassword);

    if( !rc ) SetLastError(Result);
    return( rc );


}

/*******************************************************************************
 *
 *  _WinStationGetApplicationInfo
 *
 *    Gets info about published applications.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
_WinStationGetApplicationInfo(
    HANDLE hServer,
    ULONG  LogonId,
    PBOOLEAN pfPublished,
    PBOOLEAN pfAnonymous
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationGetApplicationInfo(
                 hServer,
                 &Result,
                 LogonId,
                 pfPublished,
                 pfAnonymous
                 );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationNtsdDebug
 *
 *    Set up a debug connection for ntsd
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The function succeeds
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationNtsdDebug(
    ULONG  LogonId,
    LONG   ProcessId,
    ULONG  DbgProcessId,
    ULONG  DbgThreadId,
    PVOID  AttachCompletionRoutine
    )
{
    DWORD Result;
    BOOLEAN rc;
    HANDLE hServer = SERVERNAME_CURRENT;

    NTSDDBGPRINT(("In WinStationNtsdDebug command\n"));
    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationNtsdDebug(
                 hServer,
                 &Result,
                 LogonId,
                 ProcessId,
                 DbgProcessId,
                 DbgThreadId,
                 (DWORD_PTR) AttachCompletionRoutine
                 );

        DbgPrint("RpcWinStationNtsdDebug: returned 0x%x\n", rc);
        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    NTSDDBGPRINT(("WinStationNtsdDebug returning %d\n", rc));
    return( rc );
}

/*******************************************************************************
 *
 *  WinStationGetTermSrvCountersValue
 *
 *    Gets TermSrv Counters value
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationGetTermSrvCountersValue(
    HANDLE hServer,
    ULONG  dwEntries,
    PVOID  pCounter
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {
        rc = RpcWinStationGetTermSrvCountersValue(
                hServer,
                &Result,
                dwEntries,
                (PTS_COUNTER)pCounter
                );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}
/*****************************************************************************
 *
 *  WinStationBroadcastSystemMessageWorker
 *
 *   Perform the the equivalent to Window's standard API BroadcastSystemMessage to
 *        all Hydra sessions.  This is an exported function, at least used by the PNP manager to
 *         send a device  change message to all sessions.
 *
 * LIMITATIONS:
 *          some messages, such as WM_COPYDATA send an address pointer to some user data as lParam.
 *          In this API. the only such case that is currently supported is for WM_DEVICECHANGE
 *          No error code will be returned if you try to use such an unsupported message, simply the
 *          lParam will be ignored.
 *
 * ENTRY:
 *        hServer
 *            this is a handle which identifies a Hydra server. For the local server, hServer
 *            should be set to SERVERNAME_CURRENT
 *
 *        sendToAllWinstations
 *          This should be set to TRUE if you want to broadcast message to all winstations
 *
 *        sessionID,
 *          if sendToAllWinstations = FALSE, then message is only sent to only the
 *          winstation with the specified sessionID
 *
 *        timeOut
 *          set this to the amount of time you are willing to wait to get a response
 *          from the specified winstation. Even though Window's SendMessage API
 *          is blocking, the call from this side MUST choose how long it is willing to
 *          wait for a response.
 *
 *        dwFlags
 *          see MSDN on BroadcastSystemMessage(). Be aware that POST is not allowed on any
 *          where the wparam is a pointer to some user mode data structure.
 *          For more info, see ntos\...\client\ntstubs.c
 *
 *        lpdwRecipients
 *          Pointer to a variable that contains and receives information about the recipients of the message.
 *          see MSDN for more info
 *
 *        uiMessage
 *          the window's message to send, limited to WM_DEVICECHANGE and WM_SETTINGSCHANGE
 *          at this time.
 *
 *        wParam
 *            first message param
 *
 *        lParam
 *            second message parameter
 *
 *        pResponse
 *          this is the response to the message sent, see MSDN
 *
 *        idOfSessionBeingIgnored
 *          if -1, then no sessions are ignored. Else, the id of the session passed in is ignored
 *
 * EXIT:
 *        TRUE    if all went well or
 *        FALSE   if something went wrong.
 *
 * WARNINGs:
 *        since the RPC call never blocks, you need to specify a reasonable timeOut if you want to wait for
 *         a response. Please remember that since this message is being sent to all winstations, the timeOut value
 *        will be on per-winstation.
 *
 *        Also, Do not use flag  BSF_POSTMESSAGE, since an app/window on a
 *        winstation is not setup to send back a response to the
 *        query in an asynchronous fashion.
 *        You must wait for the response (until the time out period).
 *
 * Comments:
 *      For more info, please see MSDN for BroadcastSystemMessage()
 *
 ****************************************************************************/

LONG WinStationBroadcastSystemMessageWorker(
        HANDLE hServer,
        BOOL    sendToAllWinstations,
        ULONG   sessionID,
        ULONG   timeOut,
        DWORD   dwFlags,
        DWORD   *lpdwRecipients,
        ULONG   uiMessage,
        WPARAM  wParam,
        LPARAM  lParam,
        LONG    *pResponse,             // this is the response to the message sent
        DWORD   idOfSessionBeingIgnored
    )
{

    DWORD   Result = ERROR_SUCCESS;
    LONG rc;
    LONG    status;
    ULONG   i;
    LONG    response=0;

    PLOGONID    pWd;
    ULONG       ByteCount, Index;
    UINT        WdCount;

    // these are used for PNP messages
    PBYTE   rpcBuffer=NULL;
    ULONG   bufferSize=0;
    ULONG   maxSize;

    BOOLEAN fBufferHasValidData = FALSE;

    // Since the PNP message uses the lparam to pass the address of a user memory location, we
    // need to handle this by creating our own copy of that data, and then pass it to
    // termServ

    // we may want to make this general for the future... hence use switch
    switch( uiMessage )
    {
            // if this is a PNP message
    case    WM_DEVICECHANGE:

            if ( lParam )   // see if the PNP message has a pointer to some user data
            {
                bufferSize = ( (DEV_BROADCAST_HDR *)(lParam))->dbch_size;
                rpcBuffer = LocalAlloc( LPTR, bufferSize );
                if ( rpcBuffer )
                {
                    // copy from user-space into our local rpc buffer
                    CopyMemory(rpcBuffer, (PBYTE)lParam, bufferSize );
                    fBufferHasValidData = TRUE;
                }
                else
                {
                    SetLastError( ERROR_OUTOFMEMORY );
                    return ( FALSE );
                }
            }
    break;


    // if this is a settings change message the system-CPL sends out
    // when an Admin changes the system env vars...
    case WM_SETTINGCHANGE:
            if ( lParam )   // see if message has a string data
            {
                // put some artificial limit on how large a buffer we are willing to use
                // in order to protect against malicious use of this api
                maxSize = 4096;

                bufferSize = lstrlenW( (PWCHAR) lParam ) * sizeof( WCHAR );
                if ( bufferSize < maxSize )
                {
                    rpcBuffer = LocalAlloc( LPTR, bufferSize );
                    if ( rpcBuffer )
                    {
                        // copy from user-space into our local rpc buffer
                        CopyMemory(rpcBuffer, (PBYTE) lParam, bufferSize );
                        fBufferHasValidData = TRUE;

                    }
                    else
                    {
                        SetLastError( ERROR_OUTOFMEMORY );
                        return ( FALSE );
                    }
                }
                else
                {
                    // we have too many
                    // vars in the user's profile.
                    KdPrint(("lParam length too big = %d \n", bufferSize));
                    break;
                    SetLastError( ERROR_MESSAGE_EXCEEDS_MAX_SIZE );
                    return ( FALSE );
                }
            }

    break;

    }

    //
    // if the rpcBuffer is still empty (meaning, this was not a PNP message), we must fill it up
    // with some bogus data, otherwise, we will get an RPC error of RPC_X_NULL_REF_POINTER
    // (error code of 1780). It looks like Rpc does not check the
    // bufferSize value, and it just throws an exception if the buffer is NULL.
    //
    if ( !rpcBuffer )
    {
        rpcBuffer = LocalAlloc( LPTR, sizeof(UINT) );
        if (!rpcBuffer)
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return ( FALSE );
        }
        bufferSize = sizeof(UINT);
        fBufferHasValidData = FALSE;    // note that this is set to FALSE, which means, the recepient will
                                        // not use the buffer. We do free the alloc below in either case.
    }

    HANDLE_CURRENT_BINDING_BUFFER( hServer, rpcBuffer );

    WdCount = 1000;
    pWd = NULL; // it will be allocated  by Winstation Enumerate()
    rc = WinStationEnumerate( hServer, &pWd, &WdCount );

    /*
     * Do not use this flag, since no process on the session side can respond back to a console process
     * thru the post message mechanism, since there is no session ID abstraction in that call.
     */
    dwFlags &= ~BSF_POSTMESSAGE;

    if ( rc != TRUE )
    {
        status = GetLastError();
        DBGPRINT(( "WinstationEnumerate = %d, failed at %s %d\n", status,__FILE__,__LINE__));
        if ( pWd )
        {
            WinStationFreeMemory(pWd);
        }

        ASSERT(rpcBuffer);
        LocalFree( rpcBuffer );
        return(FALSE);
    }


    //
    // the loop for sending data to each winstation
    //
    for ( i=0; i < WdCount; i++ )
    {
            // id of the session being ignored
            if ( pWd[i].SessionId == idOfSessionBeingIgnored)
                continue;

            // either send to all winstations, or to a specific winstation
            if ( sendToAllWinstations ||  pWd[i].SessionId == sessionID )
            {
                // don't send message to any winstation unless it is either Active or in the disconnect state
                if ( pWd[i].State == State_Active ||
                        pWd[i].State == State_Disconnected)
                {
                    RpcTryExcept
                    {
                        rc = RpcWinStationBroadcastSystemMessage(
                                        hServer,
                                        pWd[i].SessionId,
                                        timeOut,
                                        dwFlags,
                                        lpdwRecipients,
                                        uiMessage,
                                        wParam,
                                        lParam,
                                        rpcBuffer,
                                        bufferSize,
                                        fBufferHasValidData,
                                        &response   );

                        DBGPRINT(("done with call RpcWinStationBroadcastSystemMessage() for sessionID= %d\n",  pWd[i].SessionId ));
                        *pResponse |= response;        // keep an OR of all return values

                        // @@@
                        // if response is -1 from any winstation, maybe we should give up and return ?
                    }
                    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
                    {
                        Result = RpcExceptionCode();
                        DBGPRINT(("RPC Exception %d in RpcWinStationBroadcastSystemMessage() for sessionID = %d \n",Result, sessionID));
                        rc = FALSE;        // change rc to FALSE
                        break;    // get out of the for-loop, we have a problem with at least one of the winstations
                    }
                    RpcEndExcept

            }    // end if winstation state check

        }   // if ( sendToAllWinstations ||  pWd[i].SessionId == sessionID )

    }    // end of the for loop

    WinStationFreeMemory(pWd);

    LocalFree( rpcBuffer );

    SetLastError( Result );

    return( rc );
}

/*************************************************************************
*                                                                        *
* This struct is used to pack data passed into a workder thread which is *
* altimetly passed to WinStationBroadcastSystemMessageWorker()           *
*                                                                        *
*************************************************************************/
typedef struct {
        HANDLE hServer;
        BOOL    sendToAllWinstations;
        ULONG   sessionID;
        ULONG   timeOut;
        DWORD   dwFlags;
        DWORD   *lpdwRecipients;
        ULONG   uiMessage;
        WPARAM  wParam;
        LPARAM  lParam;
        LONG    *pResponse;
        DWORD   idOfSessionBeingIgnored ;
} BSM_DATA_PACKAGE;

/***********************************************************************************************
*                                                                                              *
* This is a workder thread used to make a call into WinStationBroadcastSystemMessageWorker()   *
* The reason for this is in certain cases, we don't want to block the caller of this func from *
* processing window messages                                                                   *
* DWORD WINAPI WinStationBSMWorkerThread( LPVOID p )                                           *
*
***********************************************************************************************/
DWORD WINAPI WinStationBSMWorkerThread( LPVOID p )
{
    DWORD rc;
    BSM_DATA_PACKAGE *pd = (BSM_DATA_PACKAGE *)p;

    rc  = WinStationBroadcastSystemMessageWorker(
             pd->hServer              ,
             pd->sendToAllWinstations ,
             pd->sessionID            ,
             pd->timeOut              ,
             pd->dwFlags              ,
             pd->lpdwRecipients       ,
             pd->uiMessage            ,
             pd->wParam               ,
             pd->lParam               ,
             pd->pResponse            ,
             pd->idOfSessionBeingIgnored);

    return rc;
}

/**************************************************************************************************
*                                                                                                 *
* This func is used to wait on a thread, and still allow the user of this thread (aka the creator *
* of this thread) to process window messages                                                      *
*                                                                                                 *
**************************************************************************************************/
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent, DWORD dwTimeout)
{
    while (1)
    {
        MSG msg;

        DWORD dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE, dwTimeout, QS_ALLEVENTS);

        // Are we done waiting?
        switch (dwObject)
        {
            case WAIT_OBJECT_0:
            case WAIT_FAILED:
                return dwObject;

            case WAIT_TIMEOUT:
                return WAIT_TIMEOUT;

            case WAIT_OBJECT_0 + 1:
                // This PeekMessage has the side effect of processing any broadcast messages.
                // It doesn't matter what message we actually peek for but if we don't peek
                // then other threads that have sent broadcast sendmessages will hang until
                // hEvent is signaled.  Since the process we're waiting on could be the one
                // that sent the broadcast message that could cause a deadlock otherwise.
                PeekMessage(&msg, NULL, WM_NULL, WM_USER, PM_NOREMOVE);
            break;
        }
    }
    // never gets here
    // return dwObject;
}

/*****************************************************************************
 *
 *  WinStationBroadcastSystemMessage
 *
 *   Perform the the equivalent to Window's standard API BroadcastSystemMessage to
 *        all Hydra sessions.  This is an exported function, at least used by the PNP manager to
 *         send a device  change message to all sessions.
 *
 * LIMITATIONS:
 *          some messages, such as WM_COPYDATA send an address pointer to some user data as lParam.
 *          In this API. the only such case that is currently supported is for WM_DEVICECHANGE
 *          No error code will be returned if you try to use such an unsupported message, simply the
 *          lParam will be ignored.
 *
 *          This func will only allow WM_DEVICECHNAGE and WM_SETTINGSCHANGE to go thru.
 *
 * ENTRY:
 *        hServer
 *            this is a handle which identifies a Hydra server. For the local server, hServer
 *            should be set to SERVERNAME_CURRENT
 *
 *        sendToAllWinstations
 *          This should be set to TRUE if you want to broadcast message to all winstations
 *
 *        sessionID,
 *          if sendToAllWinstations = FALSE, then message is only sent to only the
 *          winstation with the specified sessionID
 *
 *        timeOut [ IN SECONDS ]
 *          set this to the amount of time you are willing to wait to get a response
 *          from the specified winstation. Even though Window's SendMessage API
 *          is blocking, the call from this side MUST choose how long it is willing to
 *          wait for a response.
 *
 *        dwFlags
 *          see MSDN on BroadcastSystemMessage(). Be aware that POST is not allowed on any
 *          where the wparam is a pointer to some user mode data structure.
 *          For more info, see ntos\...\client\ntstubs.c
 *
 *        lpdwRecipients
 *          Pointer to a variable that contains and receives information about the recipients of the message.
 *          see MSDN for more info
 *
 *        uiMessage
 *          the window's message to send, limited to WM_DEVICECHANGE and WM_SETTINGSCHANGE
 *          at this time.
 *
 *        wParam
 *            first message param
 *
 *        lParam
 *            second message parameter
 *
 *        pResponse
 *          this is the response to the message sent, see MSDN
 *
 * EXIT:
 *        TRUE    if all went well or
 *        FALSE   if something went wrong.
 *
 * WARNINGs:
 *        since the RPC call never blocks, you need to specify a reasonable timeOut if you want to wait for
 *         a response. Please remember that since this message is being sent to all winstations, the timeOut value
 *        will be on per-winstation.
 *
 *        Also, Do not use flag  BSF_POSTMESSAGE, since an app/window on a
 *        winstation is not setup to send back a response to the
 *        query in an asynchronous fashion.
 *        You must wait for the response (until the time out period).
 *
 *       For WM_SETTINGGSCHNAGE, a second therad is used to allow the caller to still process windows
 *       messages.
 *       For WM_DEVICECHANGE, no such thread is used.
 *
 * Comments:
 *      For more info, please see MSDN for BroadcastSystemMessage()
 *
 ****************************************************************************/
LONG WinStationBroadcastSystemMessage(
        HANDLE hServer,
        BOOL    sendToAllWinstations,
        ULONG   sessionID,
        ULONG   timeOut,
        DWORD   dwFlags,
        DWORD   *lpdwRecipients,
        ULONG   uiMessage,
        WPARAM  wParam,
        LPARAM  lParam,
        LONG    *pResponse        // this is the response to the message sent
    )
{

    LONG    rc;
    DWORD   dwRecipients=0;        // caller may be passing null, so use a local var 1st, and then set
                                   // value passed in by caller if an only if the caller's address is not null.

    BOOLEAN fBufferHasValidData = FALSE;

    BOOL bIsTerminalServer = !!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer));
    if (!bIsTerminalServer)
    {
        return TRUE;    // all is well, but we are not on a Hydra server
    }

    if (lpdwRecipients) // if caller passed in a non-NULL pointer for lpdwRec, use it's value
    {
       dwRecipients = *lpdwRecipients ;
    }


    // we may want to make this general for the future, but for now...
    // we only let WM_DEVICECHANGE or WM_SETTINGCHANGE messages to go thru
    switch ( uiMessage)
    {
        case    WM_DEVICECHANGE:
            rc = WinStationBroadcastSystemMessageWorker(
                hServer,
                sendToAllWinstations,
                sessionID,
                timeOut,
                dwFlags,
                &dwRecipients,
                uiMessage,
                wParam,
                lParam,
                pResponse,
                NtCurrentPeb()->SessionId   // ID of the session to be ignored.
                );

                if (lpdwRecipients) // if caller passed in a non-NULL pointer for lpdwRec, then set value
                {
                    *lpdwRecipients = dwRecipients;
                }

        break;
    
        case    WM_SETTINGCHANGE:
    
                {
                    BSM_DATA_PACKAGE    d;
                    ULONG               threadID;
                    HANDLE              hThread;
    
                    //pack the data passed to the thread proc
                    d.hServer              = hServer ;
                    d.sendToAllWinstations = sendToAllWinstations;
                    d.sessionID            = sessionID;
                    d.timeOut              = timeOut;
                    d.dwFlags              = dwFlags;
                    d.lpdwRecipients       = &dwRecipients;
                    d.uiMessage            = uiMessage;
                    d.wParam               = wParam;
                    d.lParam               = lParam;
                    d.pResponse            = pResponse;
                    d.idOfSessionBeingIgnored = NtCurrentPeb()->SessionId ;    
                                                    // a remote admin may change env-settings
                                                    // and expect all sessions includin the
                                                    // console session to be updated
                                                    // A -1 means no sessions are ignored
                                                    // Call from shell\cpls\system\envvar.c already sent the message to the current session
    
    
                    hThread = CreateThread( NULL, 0, WinStationBSMWorkerThread,
                        (void *) &d, 0 , &threadID );
    
                    if ( hThread )
                    {
                        MsgWaitForMultipleObjectsLoop( hThread, INFINITE );
                        if (lpdwRecipients) // if caller passed in a non-NULL pointer for lpdwRec, then set value
                        {
                            *lpdwRecipients = *d.lpdwRecipients ;
                        }
                        GetExitCodeThread( hThread, &rc );
                        CloseHandle( hThread );
                    }
                    else
                    {
                        rc = FALSE;
                    }
                }
        break;
    
    
        default:
            DBGPRINT(("Request is rejected \n"));
            rc = FALSE;
        break;
    }

    return rc;

}


/*****************************************************************************
 *
 *  WinStationSendWindowMessage
 *
 *   Perform the the equivalent to SendMessage to a specific winstation as
 *        identified by the session ID.  This is an exported function, at least used
 *        by the PNP manager to send a device change message (or any other window's message)
 *
 * LIMITATIONS:
 *          some messages, such as WM_COPYDATA send an address pointer to some user data as lParam.
 *          In this API, the only such case that is currently supported is for WM_DEVICECHANGE
 *          No error code will be returned if you try to use such an unsupported message, simply the
 *          lParam will be ignored.
 *
 * ENTRY:
 *        hServer
 *            this is a handle which identifies a Hydra server. For the local server, hServer
 *            should be set to SERVERNAME_CURRENT
 *        sessionID
 *            this idefntifies the hydra session to which message is being sent
 *
 *        timeOut [ IN SECONDS ]
 *            set this to the amount of time you are willing to wait to get a response
 *            from the specified winstation. Even though Window's SendMessage API
 *            is blocking, the call from this side MUST choose how long it is willing to
 *            wait for a response.
 *
 *        hWnd
 *            This is the HWND of the target window in the specified session that
 *            a message will be sent to.
 *        Msg
 *            the window's message to send
 *        wParam
 *            first message param
 *        lParam
 *            second message parameter
 *        pResponse
 *          this is the response to the message sent, it depends on the type of message sent, see MSDN
 *
 *
 * EXIT:
 *        TRUE if all went well , check presponse for the actual response to the send message
 *        FALSE if something went wrong, the value of pResponse is not altered.
 *
 * WARNINGs:
 *        since the RPC call never blocks, you need to specify a reasonable timeOut if you want to wait for
 *         a response. Please remember that since this message is being sent to all winstations, the timeOut value
 *        will be on per-winstation.
 *
 *
 * Comments:
 *      For more info, please see MSDN for SendMessage()
 *
 ****************************************************************************/
LONG    WinStationSendWindowMessage(
        HANDLE  hServer,
        ULONG   sessionID,
        ULONG   timeOut,
        ULONG   hWnd,        // handle of destination window
        ULONG   Msg,         // message to send
        WPARAM  wParam,      // first message parameter
        LPARAM  lParam,      // second message parameter
        LONG    *pResponse
  )
{

    DWORD   Result = ERROR_SUCCESS;
    LONG    rc = TRUE ;

    // these are used for PNP messages
    PBYTE   rpcBuffer=NULL;
    ULONG   bufferSize=0;
    PWCHAR  lpStr;
    ULONG   maxSize;


    BOOLEAN fBufferHasValidData=FALSE;

    BOOL bIsTerminalServer = !!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer));
    if (!bIsTerminalServer)
    {
        return TRUE;    // all is well, but we are not on a Hydra server
    }

    // we may want to make this general for the future, but for now...
    // since we only alloc/copy the lparam in case of an WM_DEVICECHANGE msg, then, only
    // let message with either lparam=0 to go thru, or any WM_DEVICECHANGE msg.
    if (lParam)
    {
        switch ( Msg)
        {
        case        WM_DEVICECHANGE:
        case        WM_SETTINGCHANGE:
        case        WM_APPCOMMAND:
        case        WM_KEYDOWN:
        case        WM_KEYUP:
            // these are ok
        break;

        default:
            DBGPRINT(("Request is rejected \n"));
            return FALSE;
        break;
        }
    }

    HANDLE_CURRENT_BINDING( hServer );

    // Since the PNP message uses the lparam to pass the address of a user memory location, we
    // need to handle this by creating our own copy of that data, and then pass it to
    // termServ

    switch( Msg )
    {
            // if this is a PNP message
    case    WM_DEVICECHANGE:

            if ( lParam )   // see if the PNP message has a pointer to some user data
            {
                bufferSize = ( (DEV_BROADCAST_HDR *)(lParam))->dbch_size;
                rpcBuffer = LocalAlloc( LPTR, bufferSize );
                if ( rpcBuffer )
                {
                    // copy from user-space into our local rpc buffer
                    CopyMemory(rpcBuffer, (PBYTE) lParam, bufferSize );
                    fBufferHasValidData = TRUE;

                }
                else
                {
                    SetLastError( ERROR_OUTOFMEMORY );
                    return ( FALSE );
                }
            }
    break;

            // if this is a settings change message the system-CPL sends out
            // when an Admin changes the system env vars...
    case WM_SETTINGCHANGE:
            if ( lParam )   // see if message has a string data
            {
                // put some artificial limit on how large a buffer we are willing to use
                // in order to protect against malicious use of this api
                maxSize = 4096;

                bufferSize = lstrlenW( (PWCHAR) lParam ) * sizeof( WCHAR );
                if ( bufferSize < maxSize )
                {
                    rpcBuffer = LocalAlloc( LPTR, bufferSize );
                    if ( rpcBuffer )
                    {
                        // copy from user-space into our local rpc buffer
                        CopyMemory(rpcBuffer, (PBYTE) lParam, bufferSize );
                        fBufferHasValidData = TRUE;

                    }
                    else
                    {
                        SetLastError( ERROR_OUTOFMEMORY );
                        return ( FALSE );
                    }
                }
                else
                {
                    // we have too many
                    // vars in the user's profile.
                    KdPrint(("lParam length too big = %d \n", bufferSize));
                    break;
                    SetLastError( ERROR_MESSAGE_EXCEEDS_MAX_SIZE );
                    return ( FALSE );
                }
            }

    break;


    }

    // if the rpcBuffer is still empty, we must fill it up with some bogus data, otherwise, we will get
    // an RPC error of RPC_X_NULL_REF_POINTER (error code of 1780). It looks like Rpc does not check the
    // bufferSize value, and it just throws an exception if the buffer is NULL.
    if ( !rpcBuffer )
    {
        rpcBuffer = LocalAlloc( LPTR, sizeof(UINT) );
        if ( !rpcBuffer )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return ( FALSE );
        }

        bufferSize = sizeof(UINT);
        fBufferHasValidData = FALSE;    // note that this is set to FALSE, which means, the recepient will
                                        // not use the buffer. We do free the alloc below in either case.
    }


    RpcTryExcept {

        // rc is set to TRUE for a successful call, else, FALSE
        rc = RpcWinStationSendWindowMessage(
            hServer,
            sessionID ,
            timeOut,
            hWnd,
            Msg,
            wParam,
            lParam  ,
            rpcBuffer ,
            bufferSize,
            fBufferHasValidData,
            pResponse );

        //DBGPRINT(("done with call RpcWinStationSendWindowMessage() for sessionID= %d\n", sessionID ));
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d in RpcWinStationSendWindowMessage()  for sessionID = %d \n",Result, sessionID ));
        rc = FALSE;
    }
    RpcEndExcept

    LocalFree( rpcBuffer );

    SetLastError( Result );

    return( rc );

}

/****************************************************************************
*
*  _WinStationUpdateUserConfig()
*     Used by notify when shell is about to start
*     This will cause an update to the userconfig of the session by loading the user profile
*     and reading policy data from their HKCU
*
*  Params:
*     [in] UserToken,
*     [in] pDomain,
*     [in] pUserName
*
*  Return:
*     TRUE if no errors, FALSE in case of error, use GetLastError() for more info
*
****************************************************************************/
BOOLEAN WINAPI
_WinStationUpdateUserConfig(
    HANDLE UserToken
    )
{
    DWORD Result;
    BOOLEAN rc = TRUE;
    HANDLE hServer = SERVERNAME_CURRENT;

    DWORD   result;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return FALSE;
    }

    RpcTryExcept {

        rc = RpcWinStationUpdateUserConfig(
                     hServer, 
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId(),
                     (DWORD)(INT_PTR) UserToken,
                     &result
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*
 *  WinStationQueryLogonCredentialsW
 *
 *  Used by Winlogon to get auto-logon credentials from termsrv. This replaces
 *  the dual calls to WinStationQueryInformation and
 *  ServerQueryInetConnectorInformation.
 */

BOOLEAN WINAPI
WinStationQueryLogonCredentialsW(
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCredentials
    )
{
    BOOLEAN fRet;
    HANDLE hServer;
    NTSTATUS Status;
    PCHAR pWire;
    ULONG cbWire;

    if (pCredentials == NULL)
    {
        return(FALSE);
    }

    if (pCredentials->dwType != WLX_CREDENTIAL_TYPE_V2_0)
    {
        return(FALSE);
    }

    hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING(hServer);

    pWire = NULL;
    cbWire = 0;

    __try
    {
        fRet = RpcWinStationQueryLogonCredentials(
            hServer,
            NtCurrentPeb()->SessionId,
            &pWire,
            &cbWire
            );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
    }

    if (fRet)
    {
        fRet = CopyCredFromWire((PWLXCLIENTCREDWIREW)pWire, pCredentials);
    }

    if (pWire != NULL)
    {
        MIDL_user_free(pWire);
    }

    return(fRet);
}

BOOL WINAPI WinStationUnRegisterNotificationEvent (
    ULONG_PTR   NotificationId
    )
{
    HANDLE hServer = SERVERNAME_CURRENT;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    BOOL bResult = FALSE;
    
    HANDLE_CURRENT_BINDING(hServer);

    RpcTryExcept {

            bResult =  RpcWinStationUnRegisterNotificationEvent(
                            hServer,
                            &Status,
                            NotificationId,
                            NtCurrentPeb()->SessionId
                            );

            if (!bResult) {

                //
                // Convert NTSTATUS to winerror, and set last error here.
                //
                SetLastError(RtlNtStatusToDosError(Status));
            }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
    }
    RpcEndExcept

    return (bResult);
}

BOOL WINAPI WinStationRegisterNotificationEvent (
                        HANDLE hEventHandle,
                        ULONG_PTR *pNotificationId,
                        DWORD   dwFlags,
                        DWORD   dwMask
                        )
{
    HANDLE hServer = SERVERNAME_CURRENT;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    BOOL bResult = FALSE;
    
    if (!pNotificationId)
    {
        return FALSE;
    }

    HANDLE_CURRENT_BINDING(hServer);

    RpcTryExcept {

            ULONG_PTR Notificationid;

            bResult =  RpcWinStationRegisterNotificationEvent(
                            hServer,
                            &Status,
                            pNotificationId,
                            (ULONG_PTR)hEventHandle,
                            dwFlags,
                            dwMask,
                            NtCurrentPeb()->SessionId,
                            GetCurrentProcessId()
                            );

            if (!bResult) {

                //
                // Convert NTSTATUS to winerror, and set last error here.
                //
                SetLastError(RtlNtStatusToDosError(Status));
            }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
    }
    RpcEndExcept

    return (bResult);

}


BOOL WINAPI WinStationRegisterConsoleNotification (
                        HANDLE  hServer,
                        HWND    hWnd,
                        DWORD   dwFlags
                        )
{
    return WinStationRegisterConsoleNotificationEx(hServer, hWnd, dwFlags, WTS_ALL_NOTIFICATION_MASK);
}

BOOL WINAPI WinStationRegisterConsoleNotificationEx (
                        HANDLE  hServer,
                        HWND    hWnd,
                        DWORD   dwFlags,
                        DWORD   dwMask
                        )
{
        NTSTATUS Status = STATUS_UNSUCCESSFUL;
        BOOL bResult = FALSE;

        HANDLE_CURRENT_BINDING( hServer );

        RpcTryExcept {

                bResult =  RpcWinStationRegisterConsoleNotification (
                                hServer,
                                &Status,
                                NtCurrentPeb()->SessionId,
                                HandleToUlong(hWnd),
                                dwFlags, 
                                dwMask
                                );
                if (!bResult) {

                        //
                        // Convert NTSTATUS to winerror, and set last error here.
                        //
                        SetLastError(RtlNtStatusToDosError(Status));
                }
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                SetLastError(RpcExceptionCode());
        }
        RpcEndExcept

        return (bResult);
}

BOOL WINAPI WinStationUnRegisterConsoleNotification (
                        HANDLE  hServer,
                        HWND    hWnd
                        )
{

        NTSTATUS Status = STATUS_UNSUCCESSFUL;
        BOOL     bResult = FALSE;

        HANDLE_CURRENT_BINDING( hServer );

        RpcTryExcept {

                bResult =  RpcWinStationUnRegisterConsoleNotification (
                                hServer,
                                &Status,
                                NtCurrentPeb()->SessionId,
                                HandleToUlong(hWnd)
                                );
                if (!bResult) {
                        SetLastError(RtlNtStatusToDosError(Status));
                }


        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                SetLastError(RpcExceptionCode());
        }
        RpcEndExcept

        return (bResult);
}


BOOLEAN CloseContextHandle(HANDLE *pHandle, DWORD *pdwResult)
{
    BOOLEAN bSuccess;
    ASSERT(pHandle);
    ASSERT(pdwResult);

    RpcTryExcept {

       bSuccess = RpcWinStationCloseServerEx( pHandle, pdwResult );
       if( !bSuccess ) *pdwResult = RtlNtStatusToDosError( *pdwResult );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        *pdwResult = RpcExceptionCode();
        bSuccess = FALSE;
    }
    RpcEndExcept

    if (!bSuccess && (*pdwResult == RPC_S_PROCNUM_OUT_OF_RANGE))        {
        //
        // most probabaly we are calling an older server which does not have
        // RpcWinStationCloseServerEx, so lets give a try to RpcWinStationCloseServer
        //
        RpcTryExcept {

           bSuccess = RpcWinStationCloseServer( *pHandle, pdwResult );
           if( !bSuccess ) *pdwResult = RtlNtStatusToDosError( *pdwResult );

        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            *pdwResult = RpcExceptionCode();
            bSuccess = FALSE;
            DBGPRINT(("RPC Exception %d\n", *pdwResult));
        }
        RpcEndExcept

        //
        // RpcWinStationCloseServer does not take care of destroying the context handle.
        // we we have to do it here at client end.
        //
        RpcTryExcept {

            RpcSsDestroyClientContext(pHandle);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ASSERT(FALSE);
        }
        RpcEndExcept

    }

    return (bSuccess);
}

BOOLEAN WINAPI
RemoteAssistancePrepareSystemRestore(
	HANDLE hServer
    )
/*++

--*/
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcRemoteAssistancePrepareSystemRestore(
                     hServer,
                     &Result
                     );

        // TermSrv RpcRemoteAssistancePrepareSystemRestore() return
        // win32 ERROR code or actual HRESULT code.
        SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return rc;
}

BOOLEAN WinStationIsHelpAssistantSession(
    SERVER_HANDLE   hServer,
    ULONG           LogonId
    )
/*++

--*/
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationIsHelpAssistantSession(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId
                     );

        // Since a program has called us, we need to set the last error code such
        // that extended error information is available

        //
        // Ticket might be invalid so we set last error but we still
        // return TRUE
        //
        SetLastError(RtlNtStatusToDosError(Result));
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return rc;
}

/*
*
*   WinStationGetMachinePolicy
*       Pass it a pointer to the callers ALREADY allocated policy struct, and this func
*       will fill it up from the current machine policy known to TermSrv
*
*   Params:
*        hServer
*            this is a handle which identifies a Hydra server. For the local server, hServer
*            should be set to SERVERNAME_CURRENT
*
*         pPolicy
*            pointer to POLICY_TS_MACHINE already allocated by the caller.
*
*/
BOOLEAN    WinStationGetMachinePolicy (
        HANDLE              hServer,
        POLICY_TS_MACHINE   *pPolicy
  )
{

    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    BOOLEAN     bResult = FALSE;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

            bResult =  RpcWinStationGetMachinePolicy  (
                            hServer,
                            (PBYTE)pPolicy,
                            sizeof( POLICY_TS_MACHINE )
                            );

            if (!bResult) {
                    SetLastError(RtlNtStatusToDosError(Status));
            }


    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
    }
    RpcEndExcept

    return (bResult);

}

/*****************************************************************************************************************
 *
 *  _WinStationUpdateClientCachedCreadentials
 *
 *   Comment
 *      Msgina calls this routine to notify TermSrv about the exact credentials specified by the User during logon
 *      Gina also notifies us if a SmartCard was used for logging into this particular TS session
 *      TermSrv uses this information to send back notification information to the client
 *      This call was introduced because the notification used before did not support UPN Names
 *
 * ENTRY:
 *   [in] pDomain 
 *   [in] pUserName  
 *   [in] fSmartCard
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ******************************************************************************************************************/

BOOLEAN WINAPI
_WinStationUpdateClientCachedCredentials(
    PWCHAR pDomain,
    PWCHAR pUserName,
    BOOLEAN fSmartCard
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   DomainLength;
    DWORD   UserNameLength;
    HANDLE hServer = SERVERNAME_CURRENT;
    HANDLE ReadyEventHandle;
    DWORD TermSrvWaitTime = 0;  

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    //
    // Wait for the TermSrvReadyEvent to be set by TERMSRV.EXE.  This
    // event indicates that TermSrv is initialized to the point that
    // the data used by _WinStationUpdateClientCachedCredentials() is available.
    //
    ReadyEventHandle = OpenEvent(SYNCHRONIZE, FALSE, TEXT("Global\\TermSrvReadyEvent"));
    if (ReadyEventHandle != NULL) {
       if (WaitForSingleObject(ReadyEventHandle, TermSrvWaitTime) != 0) {
          DBGPRINT(("WinLogon:  Wait for ReadyEventHandle failed\n"));
          return TRUE;
       }
       CloseHandle(ReadyEventHandle);
    } else {
       DBGPRINT(("WinLogon:  Create failed for ReadyEventHandle\n"));
       return TRUE;
    }

    RpcTryExcept {

        if( pDomain ) {
            DomainLength = lstrlenW(pDomain) + 1; 
        } else {
            DomainLength = 0;
        }

        if( pUserName ) {
            UserNameLength = lstrlenW(pUserName) + 1;
        } else {
            UserNameLength = 0;
        }

        rc = RpcWinStationUpdateClientCachedCredentials(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId(),
                     pDomain,
                     DomainLength,
                     pUserName,
                     UserNameLength,
                     fSmartCard
                     );

        if( !rc ) {
            Result = RtlNtStatusToDosError( Result );

        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************************************************
 *
 *  _WinStationFUSCanRemoteUserDisconnect
 *
 *   Comment
 *      FUS specific call when a remote user wants to connect and hence disconnect the present User
 *      Winlogon calls this routine so that we can ask the present user if it is ok to disconnect him
 *      The Target LogonId, Username and Domain of the remote user are passed on from Winlogon (useful to display the MessageBox)
 *
 * ENTRY:
 *   [in] LogonId - Session Id of the new session
 *   [in] pDomain - Domain name of the remote user trying to connect
 *   [in] pUserName  - Username of the remote user trying to connect
 *
 * EXIT:
 *   TRUE when local user allows the remote user to connect. FALSE otherwise.
 *
 ******************************************************************************************************************/


BOOLEAN WINAPI
_WinStationFUSCanRemoteUserDisconnect(
    ULONG  LogonId,
    PWCHAR pDomain,
    PWCHAR pUserName
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   DomainLength;
    DWORD   UserNameLength;
    HANDLE hServer = SERVERNAME_CURRENT;
    HANDLE ReadyEventHandle;
    DWORD TermSrvWaitTime = 0;  

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        if( pDomain ) {
            DomainLength = lstrlenW(pDomain) + 1; 
        } else {
            DomainLength = 0;
        }

        if( pUserName ) {
            UserNameLength = lstrlenW(pUserName) + 1;
        } else {
            UserNameLength = 0;
        }

        rc = RpcWinStationFUSCanRemoteUserDisconnect(
                     hServer,
                     &Result,
                     LogonId,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId(),
                     pDomain,
                     DomainLength,
                     pUserName,
                     UserNameLength
                     );

        if( !rc ) {
            Result = RtlNtStatusToDosError( Result );

        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************
 *
 *  WinStationCheckLoopBack
 *
 *   Check if there is a loopback when a client tries to connect 
 *
 * ENTRY:
 *   IN hServer : open RPC server handle
 *   IN ClientSessionId : ID of the Session from which the Client was started
 *   IN TargetLogonId : Session ID to which the client is trying to connect to 
 *   IN pTargetServerName : name of target server
 *
 * EXIT:
 *   TRUE if there is a Loopback. FALSE otherwise.
 *
 ****************************************************************************/

BOOLEAN WINAPI
WinStationCheckLoopBack(
    HANDLE hServer,
    ULONG ClientSessionId,
    ULONG TargetLogonId,
    LPWSTR pTargetServerName
    )
{
    DWORD   NameSize;
    DWORD   Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    } 

    RpcTryExcept {

        if (pTargetServerName) {
            NameSize = lstrlenW(pTargetServerName) + 1;
        } else {
            NameSize = 0;
        }

        rc = RpcWinStationCheckLoopBack(
                    hServer,
                    &Result,
                    ClientSessionId,
                    TargetLogonId,
                    pTargetServerName,
                    NameSize
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if( !rc ) SetLastError(Result);
    return( rc );
}

//
// generic routine that can support all kind of protocol but this will
// require including tdi.h
//
BOOLEAN
WinStationConnectCallback(
    HANDLE hServer,
    DWORD  Timeout,
    ULONG  AddressType,
	PBYTE  pAddress,
	ULONG  AddressSize
    )
{
    BOOLEAN rc;
    DWORD   Result;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcConnectCallback(
                     hServer,
                     &Result,
                     Timeout,
                     AddressType,
                     pAddress,
                     AddressSize
                     );

        if( !rc ) SetLastError( RtlNtStatusToDosError(Result) );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************************************************
 *
 *  _WinStationNotifyDisconnectPipe
 *
 *   Comment
 *     This routine is called by the temperory winlogon created during console reconnect, when it wants to inform
 *     the session 0 winlogon to disconnect the autologon Named Pipe. This can happen in some error handling paths
 *     during console reconnect.
 *
 * ENTRY: None
 *
 * EXIT:
 *   TRUE when notification succeeded. FALSE otherwise.
 *
 ******************************************************************************************************************/


BOOLEAN WINAPI
_WinStationNotifyDisconnectPipe(
    VOID
    )
{
    BOOLEAN rc;
    DWORD   Result;
    HANDLE hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        rc = RpcWinStationNotifyDisconnectPipe(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId()
                     );

        if( !rc ) {
            Result = RtlNtStatusToDosError( Result );

        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************************************************
 *
 *  _WinStationSessionInitialized
 *
 *   Comment
 *     This routine is called by the winlogon of a newly created session after it is done creating the 
 *     windowstation and desktops for the new session 
 *
 * ENTRY: None
 *
 * EXIT:
 *   TRUE when everything goes fine. FALSE otherwise.
 *
 ******************************************************************************************************************/


BOOLEAN WINAPI
_WinStationSessionInitialized(
    VOID
    )
{
    BOOLEAN rc;
    DWORD   Result;
    HANDLE hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        rc = RpcWinStationSessionInitialized(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId()
                     );

        if( !rc ) {
            Result = RtlNtStatusToDosError( Result );

        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if( !rc ) SetLastError(Result);
    return( rc );
}


/*******************************************************************************
 *
 *  WinStationAutoReconnect
 *
 *    Atomically:
 *    1) Queries a winstation to see if it should be autoreconnected
 *       and which session ID to autoreconnect to
 *    2) Performs security checks to ensure session is authorized to ARC
 *    3) Auto reconnect is done
 *
 * ENTRY:
 *
 *    flags (input)
 *       Extra settings, currently unused
 *
 * EXIT:
 *    The return value is an NTSTATUS code which could have the infromational
 *    class set to specify the call succeeded but autoreconnect did not happen
 *
 ******************************************************************************/
ULONG WINAPI
WinStationAutoReconnect(
    ULONG         flags
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationAutoReconnect(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     flags
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( Result );
}

/*****************************************************************************************************************
 *
 *  WinStationCheckAccess
 *
 *   Comment
 *      Check if the User has the desired access to a WinStation
 *
 * ENTRY:
 *      [in] UserToken - token of the user against whom Access Check is made
 *      [in] TargetLogonId - Target Session for which access needs to be determined
 *      [in] AccessMask - The desired access (eg WINSTATION_LOGON )
 *
 * EXIT:
 *   TRUE when the User has required Access ; FALSE when not.
 *
 ******************************************************************************************************************/


BOOLEAN WINAPI
WinStationCheckAccess(
    HANDLE  UserToken, 
    ULONG   TargetLogonId,
    ULONG   AccessMask
    )
{
    BOOLEAN rc;
    DWORD   Result;
    HANDLE hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return FALSE;
    }

    RpcTryExcept {

        rc = RpcWinStationCheckAccess(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     (DWORD)(INT_PTR)UserToken,
                     TargetLogonId,
                     AccessMask
                     );

        if( !rc ) {
            Result = RtlNtStatusToDosError( Result );

        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if( !rc ) SetLastError(Result);
    return( rc );
}



/*****************************************************************************
 *
 *  _WinStationOpenSessionDirectory
 *
 *   Call to Session Directory server to see if if it's accessible
 *
 * ENTRY:
 *    hServer: SERVERNAME_CURRENT
 *    pszServerName: Session Directory server name
 * EXIT:
 *   ERROR_SUCCESS if Session Directory server is accessible
 *      otherwise NT error code is returned
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationOpenSessionDirectory(
    HANDLE hServer,
    LPWSTR pszServerName
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    RpcTryExcept {

        rc = RpcWinStationOpenSessionDirectory(
                 hServer,
                 &Result,
                 pszServerName
                 );

        if( !rc ) {
            Result = RtlNtStatusToDosError( Result );
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if( !rc ) SetLastError(Result);
    return( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\inc\wsxmgr.h ===
/*************************************************************************
*
* wsxmgr.h
*
* Data to manage Window Station extensions.
*
* Copyright Microsoft Corporation, 1998
*
*  
*************************************************************************/


/*=============================================================================
==   ICA Server supplied procs
=============================================================================*/

/*
 *  Callback workers
 */

typedef VOID (WINAPI * PCALLBACK_PRIMARY)(PVOID, PVOID, PVOID);
typedef VOID (WINAPI * PCALLBACK_COMPLETION)(PVOID);


/*
 *  ICASRV Exported Functions
 */

typedef VOID (WINAPI * PICASRV_NOTIFYSYSTEMEVENT)(ULONG);
typedef VOID (WINAPI * PICASRV_SENDWINSTATIONMESSAGE)(ULONG, PWCHAR, PWCHAR, ULONG);
typedef VOID (WINAPI * PICASRV_GETCONTEXTFORLOGONID)(ULONG, PVOID *);
typedef VOID (WINAPI * PICASRV_WINSTATIONENUMCALLBACK)(PCALLBACK_PRIMARY,
                                                       PCALLBACK_COMPLETION,
                                                       PVOID);

/*
 * Typedefs and structures
 */
typedef struct _ICASRVPROCADDR {

    ULONG                           cbProcAddr;

    PICASRV_NOTIFYSYSTEMEVENT       pNotifySystemEvent;
    PICASRV_SENDWINSTATIONMESSAGE   pSendWinStationMessage;
    PICASRV_GETCONTEXTFORLOGONID    pGetContextForLogonId;
    PICASRV_WINSTATIONENUMCALLBACK  pWinStationEnumCallBack;

} ICASRVPROCADDR, * PICASRVPROCADDR;



/*
 * Exported function prototypes
 */

//  Initialization

typedef BOOL (WINAPI * PWSX_INITIALIZE)(PICASRVPROCADDR);
typedef NTSTATUS (WINAPI * PWSX_WINSTATIONINITIALIZE)(PVOID *);
typedef NTSTATUS (WINAPI * PWSX_WINSTATIONREINITIALIZE)(PVOID, PVOID);
typedef NTSTATUS (WINAPI * PWSX_WINSTATIONRUNDOWN)(PVOID);



//  Client Drive Mapping Extensions

typedef NTSTATUS (WINAPI * PWSX_CDMCONNECT)(PVOID, ULONG, HANDLE);
typedef NTSTATUS (WINAPI * PWSX_CDMDISCONNECT)(PVOID, ULONG, HANDLE);



//  License Extensions

typedef NTSTATUS (WINAPI * PWSX_VERIFYCLIENTLICENSE)(PVOID, SDCLASS);
typedef NTSTATUS (WINAPI * PWSX_GETLICENSE)(PVOID, HANDLE, ULONG, BOOL);
typedef NTSTATUS (WINAPI * PWSX_QUERYLICENSE)(PVOID, ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONGENERATELICENSE)(PWCHAR, ULONG, PCHAR, ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONINSTALLLICENSE)(PCHAR, ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONENUMERATELICENSES)(PULONG, PULONG, PCHAR, PULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONACTIVATELICENSE)(PCHAR, ULONG, PWCHAR, ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONREMOVELICENSE)(PCHAR, ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONSETPOOLCOUNT)(PCHAR, ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONQUERYUPDATEREQUIRED)(PULONG);
typedef NTSTATUS (WINAPI * PWSX_WINSTATIONLOGONANNOYANCE)(ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONANNOYANCETHREAD)(PVOID);


//  Context 


typedef NTSTATUS (WINAPI * PWSX_DUPLICATECONTEXT)(PVOID, PVOID *);
typedef NTSTATUS (WINAPI * PWSX_COPYCONTEXT)(PVOID, PVOID);
typedef NTSTATUS (WINAPI * PWSX_CLEARCONTEXT)(PVOID);


//  Other


typedef NTSTATUS (WINAPI * PWSX_VIRTUALCHANNELSECURITY)(PVOID, HANDLE, PUSERCONFIG);
typedef NTSTATUS (WINAPI * PWSX_ICASTACKIOCONTROL)(PVOID, HANDLE, HANDLE, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG);
typedef NTSTATUS (WINAPI * PWSX_INITIALIZECLIENTDATA)(PVOID, HANDLE, HANDLE, HANDLE,
                                                      BYTE *, ULONG, PUSERCONFIG, 
                                                      PUSHORT, PUSHORT, PUSHORT,
                                                      WINSTATIONDOCONNECTMSG *);
typedef NTSTATUS (WINAPI * PWSX_INITIALIZEUSERCONFIG)(PVOID, HANDLE, HANDLE, PUSERCONFIG,
                                                      PUSHORT, PUSHORT, PUSHORT);
typedef NTSTATUS (WINAPI * PWSX_CONVERTPUBLISHEDAPP)(PVOID, PUSERCONFIG);
typedef NTSTATUS (WINAPI * PWSX_CHECKFORAPPLICATIONNAME)(PVOID, PWCHAR, ULONG, PWCHAR, ULONG,  
                                                         PWCHAR, PULONG, ULONG, PCHAR, PBOOLEAN, PBOOLEAN ); 
typedef NTSTATUS (WINAPI * PWSX_GETAPPLICATIONINFO)(PVOID, PBOOLEAN, PBOOLEAN); 
typedef NTSTATUS (WINAPI * PWSX_BROKENCONNECTION)(PVOID, HANDLE, PICA_BROKEN_CONNECTION); 
typedef NTSTATUS (WINAPI * PWSX_LOGONNOTIFY)(PVOID, ULONG, HANDLE, PWCHAR, PWCHAR); 
typedef NTSTATUS (WINAPI * PWSX_SETERRORINFO)(PVOID, UINT32, BOOL); 
typedef NTSTATUS (WINAPI * PWSX_SENDAUTORECONNECTSTATUS)(PVOID, UINT32, BOOL); 
// added for long UserName, Password support
typedef NTSTATUS (WINAPI * PWSX_ESCAPE) (PVOID, INFO_TYPE, PVOID, ULONG, PVOID, ULONG, PULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\lcreg.cpp ===
/*
 *  LCReg.cpp
 *
 *  Author: BreenH
 *
 *  Registry constants and functions for the licensing core.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lcreg.h"

/*
 *  Constants
 */

#define LCREG_BASEKEY L"System\\CurrentControlSet\\Control\\Terminal Server\\Licensing Core"

/*
 *  Globals
 */

HKEY g_hBaseKey;

/*
 *  Function Implementations
 */

HKEY
GetBaseKey(
    )
{
    return(g_hBaseKey);
}

NTSTATUS
RegistryInitialize(
    )
{
    DWORD dwStatus;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    dwStatus = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        LCREG_BASEKEY,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &g_hBaseKey,
        NULL
        );

    if (dwStatus == ERROR_SUCCESS)
    {
        Status = STATUS_SUCCESS;
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\lcreg.h ===
/*
 *  LCReg.h
 *
 *  Author: BreenH
 *
 *  Registry constants and functions for the licensing core.
 */

#ifndef __LC_LCREG_H__
#define __LC_LCREG_H__

/*
 *  Base Licensing Core Key Constants
 */

#define LCREG_TRACEVALUE L"TraceLevel"
#define LCREG_ACONMODE L"PolicyAcOn"
#define LCREG_ACOFFMODE L"PolicyAcOff"

/*
 *  Policy Key Constants
 */

#define LCREG_POLICYDLLVALUE L"DllName"
#define LCREG_POLICYCREATEFN L"CreationFunction"

/*
 *  Function Prototypes
 */

HKEY
GetBaseKey(
    );

NTSTATUS
RegistryInitialize(
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\concurrent.cpp ===
/*
 *  Concurrent.cpp
 *
 *  Author: RobLeit
 *
 *  The Concurrent (renamed to Per Session) licensing policy.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "concurrent.h"
#include "util.h"
#include "lctrace.h"
#include <icaevent.h>
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"


/*
 *  Typedefs
 */

#define CONCURRENTLICENSEINFO_TYPE_V1 (1)

typedef struct {
    DWORD dwStructVer;
    DWORD dwLicenseVer;
    LONG lLicenseCount;
    HWID hwid;
} CONCURRENTLICENSEINFO_V1, *PCONCURRENTLICENSEINFO_V1;

typedef struct {
    ULARGE_INTEGER ulSerialNumber;
    FILETIME ftNotAfter;
    DWORD cchServerName;
    WCHAR szServerName[MAX_COMPUTERNAME_LENGTH + 2];
} LSERVERINFO, *PLSERVERINFO;

/*
 * Function declarations
 */

NTSTATUS
ReturnLicenseToLS(
    LONG nNum
    );

LICENSE_STATUS
GetLicenseFromStore(
                    PLONG LicenseCount,
                    PHWID phwid,
                    DWORD dwLicenseVer
                    );

LICENSE_STATUS
SetLicenseInStore(
                  LONG LicenseCount,
                  HWID hwid,
                  DWORD dwLicenseVer
                  );


/*
 *  extern globals
 */
extern "C"
extern HANDLE hModuleWin;

/*
 *  globals
 */
FILETIME g_ftNotAfter = {0,0};

HANDLE g_hOkayToAdd = NULL;

DWORD g_dwWaitTimeAdd;
DWORD g_dwWaitTimeRemove;
DWORD g_dwIncrement;

HANDLE g_rgWaitEvents[4] = {NULL,NULL,NULL,NULL};

CRITICAL_SECTION g_csAddLicenses;
RTL_RESOURCE g_rwLockLicense;
BOOL g_fLockLicenseInitialized = FALSE;

LONG g_lSessionCount = 0;
LONG g_lSessionMax;

/*
 *  Constants
 */

//
// Dynamic licensing parameters
//
#define LC_POLICY_CONCURRENT_LICENSE_COUNT_INCREMENT    1
#define LC_POLICY_CONCURRENT_WAIT_TIME_ADD              (60)
#define LC_POLICY_CONCURRENT_WAIT_TIME_REMOVE           (60*30)

//
// The LSA secret store for the Concurrent licenses
//

// L$ means only readable from the local machine

#define CONCURRENT_LICENSE_STORE_5_1 L"L$CONCURRENT_LICENSE_STORE_AFF8D0DE-BF56-49e2-89F8-1F188C0ACEDD"

#define CONCURRENT_LICENSE_STORE_LATEST_VERSION CONCURRENT_LICENSE_STORE_5_1

//
// The LSA secret store for the license server info
//

#define CONCURRENT_LSERVER_STORE L"L$CONCURRENT_LSERVER_STORE_AFF8D0DE-BF56-49e2-89F8-1F188C0ACEDD"

// 
// Registry keys
//

#define LCREG_CONCURRENTKEY         L"System\\CurrentControlSet\\Control\\Terminal Server\\Licensing Core\\Policies\\Concurrent"

#define LCREG_INCREMENT         L"Increment"
#define LCREG_WAIT_TIME_ADD     L"WaitTimeAdd"
#define LCREG_WAIT_TIME_REMOVE  L"WaitTimeRemove"

//
// Events used to trigger license returns
//
#define RETURN_LICENSE_START_WAITING    0
#define RETURN_LICENSE_IMMEDIATELY      1
#define RETURN_LICENSE_EXIT             2
#define RETURN_LICENSE_WAITING_DONE     3

/*
 *  Class Implementation
 */

/*
 *  Creation Functions
 */

CConcurrentPolicy::CConcurrentPolicy(
    ) : CPolicy()
{
}

CConcurrentPolicy::~CConcurrentPolicy(
    )
{
}

/*
 *  Administrative Functions
 */

ULONG
CConcurrentPolicy::GetFlags(
    )
{
    return(LC_FLAG_INTERNAL_POLICY | LC_FLAG_REQUIRE_APP_COMPAT);
}

ULONG
CConcurrentPolicy::GetId(
    )
{
    return(5);
}

NTSTATUS
CConcurrentPolicy::GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    )
{
    NTSTATUS Status;

    ASSERT(lpPolicyInfo != NULL);

    if (lpPolicyInfo->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        int retVal;
        LPLCPOLICYINFO_V1 lpPolicyInfoV1 = (LPLCPOLICYINFO_V1)lpPolicyInfo;
        LPWSTR pName;
        LPWSTR pDescription;

        ASSERT(lpPolicyInfoV1->lpPolicyName == NULL);
        ASSERT(lpPolicyInfoV1->lpPolicyDescription == NULL);

        //
        //  The strings loaded in this fashion are READ-ONLY. They are also
        //  NOT NULL terminated. Allocate and zero out a buffer, then copy the
        //  string over.
        //

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_CONCURRENT_NAME,
            (LPWSTR)(&pName),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyName = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyName != NULL)
            {
                StringCbCopyN(lpPolicyInfoV1->lpPolicyName, (retVal+1) * sizeof(WCHAR), pName, (retVal+1) * sizeof(WCHAR));
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_CONCURRENT_DESC,
            (LPWSTR)(&pDescription),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyDescription = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyDescription != NULL)
            {
                StringCbCopyN(lpPolicyInfoV1->lpPolicyDescription, (retVal+1) * sizeof(WCHAR), pDescription, (retVal+1) * sizeof(WCHAR));
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        Status = STATUS_SUCCESS;
        goto exit;

V1error:

        //
        //  An error occurred loading/copying the strings.
        //

        if (lpPolicyInfoV1->lpPolicyName != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyName);
            lpPolicyInfoV1->lpPolicyName = NULL;
        }

        if (lpPolicyInfoV1->lpPolicyDescription != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyDescription);
            lpPolicyInfoV1->lpPolicyDescription = NULL;
        }
    }
    else
    {
        Status = STATUS_REVISION_MISMATCH;
    }

exit:
    return(Status);
}

DWORD WINAPI ReturnLicenseWorker(
                                 LPVOID lpParameter
                                 )
{
    DWORD dwWait;
    HANDLE * rgWaitEvents = (HANDLE *) lpParameter;
    LONG lLicensesToReturn, lLastBlock;

    for (;;)
    {
        //
        // wait for events signalling when to return licenses
        // or start waiting to return licenses
        //

        dwWait = WaitForMultipleObjects(4,            // nCount
                                        rgWaitEvents,
                                        FALSE,        // fWaitAll
                                        INFINITE
                                        );

        switch (dwWait)
        {
            case WAIT_OBJECT_0+RETURN_LICENSE_START_WAITING:
                LARGE_INTEGER liWait;

                // relative wait, in 100 nanosecond intervals
                liWait.QuadPart = (__int64) g_dwWaitTimeRemove * (-10 * 1000 * 1000);

                SetWaitableTimer(rgWaitEvents[RETURN_LICENSE_WAITING_DONE],
                                 &liWait,
                                 0,             // lPeriod
                                 NULL,          // pfnCompletionRoutine
                                 NULL,          // lpArgToCompletionRoutine
                                 FALSE          // fResume (from suspended)
                                 );
                                 
                break;

            case WAIT_OBJECT_0+RETURN_LICENSE_WAITING_DONE:

                RtlAcquireResourceShared(&g_rwLockLicense,TRUE);

                lLastBlock = g_lSessionMax - ((g_lSessionMax / g_dwIncrement) * g_dwIncrement);
                if (lLastBlock == 0) 
                    lLastBlock = g_dwIncrement;

                if (g_lSessionCount + lLastBlock <= g_lSessionMax )
                {
                    lLicensesToReturn = lLastBlock + (((g_lSessionMax - g_lSessionCount - lLastBlock) / g_dwIncrement) * g_dwIncrement);

                    (VOID)ReturnLicenseToLS(lLicensesToReturn);
                }

                RtlReleaseResource(&g_rwLockLicense);
                break;

            case WAIT_OBJECT_0+RETURN_LICENSE_IMMEDIATELY:

                RtlAcquireResourceShared(&g_rwLockLicense,TRUE);

                lLastBlock = g_lSessionMax - ((g_lSessionMax / g_dwIncrement) * g_dwIncrement);
                if (lLastBlock == 0) 
                    lLastBlock = g_dwIncrement;

                if (g_lSessionCount + lLastBlock + g_dwIncrement <= (DWORD)g_lSessionMax )
                {
                    lLicensesToReturn = ((g_lSessionMax - g_lSessionCount - lLastBlock) / g_dwIncrement) * g_dwIncrement;

                    (VOID)ReturnLicenseToLS(lLicensesToReturn);
                }

                RtlReleaseResource(&g_rwLockLicense);
                break;

            case WAIT_OBJECT_0+RETURN_LICENSE_EXIT:

                if (NULL != rgWaitEvents[RETURN_LICENSE_START_WAITING])
                {
                    CloseHandle(rgWaitEvents[RETURN_LICENSE_START_WAITING]);
                    rgWaitEvents[RETURN_LICENSE_START_WAITING] = NULL;
                }

                if (NULL != rgWaitEvents[RETURN_LICENSE_IMMEDIATELY])
                {
                    CloseHandle(rgWaitEvents[RETURN_LICENSE_IMMEDIATELY]);
                    rgWaitEvents[RETURN_LICENSE_IMMEDIATELY] = NULL;
                }

                if (NULL != rgWaitEvents[RETURN_LICENSE_EXIT])
                {
                    CloseHandle(rgWaitEvents[RETURN_LICENSE_EXIT]);
                    rgWaitEvents[RETURN_LICENSE_EXIT] = NULL;
                }

                if (NULL != rgWaitEvents[RETURN_LICENSE_WAITING_DONE])
                {
                    CloseHandle(rgWaitEvents[RETURN_LICENSE_WAITING_DONE]);
                    rgWaitEvents[RETURN_LICENSE_WAITING_DONE] = NULL;
                }

                if (g_fLockLicenseInitialized)
                {
                    // make sure no one else is using it

                    RtlAcquireResourceExclusive(&g_rwLockLicense,TRUE);

                    RtlDeleteResource(&g_rwLockLicense);
                    g_fLockLicenseInitialized = FALSE;
                }

                return STATUS_SUCCESS;
                break;

            default:
            {                
                DWORD dwRet = 0;
                DWORD dwErr = GetLastError();
                LPTSTR lpszError;
                BOOL fFree = TRUE;

                dwRet=FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    NULL,
                                    dwErr,
                                    LANG_NEUTRAL,
                                    (LPTSTR)&lpszError,
                                    0,
                                    NULL);

                if (dwRet == 0)
                {
                    lpszError = (LPTSTR) LocalAlloc(LPTR,12 * sizeof(WCHAR));

                    if (NULL != lpszError)
                    {
                        wsprintf(lpszError,L"%#lX",dwErr);
                    }
                    else
                    {
                        lpszError = L"";
                        fFree = FALSE;
                    }
                }

                LicenseLogEvent(EVENTLOG_ERROR_TYPE,
                                EVENT_LICENSING_CONCURRENT_NOT_DYNAMIC,
                                1,
                                &lpszError );

                if (fFree)
                {
                    LocalFree(lpszError);
                }

                return dwErr;
                break;
            }
        }
    }
}


/*
 *  Loading and Activation Functions
 */

NTSTATUS
CConcurrentPolicy::Load(
    )
{
    NTSTATUS Status;

    g_rgWaitEvents[RETURN_LICENSE_START_WAITING] = NULL;
    g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY] = NULL;
    g_rgWaitEvents[RETURN_LICENSE_EXIT] = NULL;
    g_rgWaitEvents[RETURN_LICENSE_WAITING_DONE] = NULL;

    Status = RtlInitializeCriticalSection(&g_csAddLicenses);
    if (STATUS_SUCCESS != Status)
    {
        return Status;
    }

    __try
    {
        RtlInitializeResource(&g_rwLockLicense);
        g_fLockLicenseInitialized = TRUE;
        Status = STATUS_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }

    if (STATUS_SUCCESS != Status)
    {
        RtlDeleteCriticalSection(&g_csAddLicenses);
        return Status;
    }

    g_hOkayToAdd = CreateWaitableTimer(NULL,         // SecurityAttributes,
                                       TRUE,         // bManualReset
                                       NULL          // lpName
                                       );

    if (NULL == g_hOkayToAdd)
    {
        RtlDeleteCriticalSection(&g_csAddLicenses);
        g_fLockLicenseInitialized = FALSE;
        RtlDeleteResource(&g_rwLockLicense);
        return GetLastError();
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
CConcurrentPolicy::Unload(
    )
{
    // signal worker thread to cleanup and exit
    if (NULL != g_rgWaitEvents[RETURN_LICENSE_EXIT])
    {
        SetEvent(g_rgWaitEvents[RETURN_LICENSE_EXIT]);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
CConcurrentPolicy::Activate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hThread;
    HWID hwidEncrypted;
    LICENSE_STATUS LsStatus;
    LARGE_INTEGER liWait;
    BOOL fRet;

    if (NULL != pulAlternatePolicy)
    {
        // don't set an explicit alternate policy
        
        *pulAlternatePolicy = ULONG_MAX;
    }

    ReadLicensingParameters();

    liWait.QuadPart = -1;

    // Ensure that timer is set
    fRet = SetWaitableTimer(g_hOkayToAdd,
                     &liWait,           // pDueTime
                     1,                 // lPeriod
                     NULL,              // pfnCompletionRoutine
                     NULL,              // lpArgToCompletionRoutine
                     FALSE              // fResume (from suspended)
                     );

    if (!fRet)
    {
        Status = GetLastError();
        
        goto check_status;
    }

    //
    // Read number of licenses from LSA secret
    //
    LsStatus = GetLicenseFromStore(&g_lSessionMax,
                                   &hwidEncrypted,
                                   CURRENT_TERMINAL_SERVER_VERSION
                                   );

    if (LsStatus != LICENSE_STATUS_OK)
    {
        g_lSessionMax = 0;
    }

    Status = StartCheckingGracePeriod();

    if (Status == STATUS_SUCCESS)
    {
        g_rgWaitEvents[RETURN_LICENSE_START_WAITING]
            = CreateEvent(NULL,         // SecurityAttributes,
                          FALSE,        // bManualReset
                          FALSE,        // bInitialState
                          NULL          // lpName
                          );

        if (NULL == g_rgWaitEvents[RETURN_LICENSE_START_WAITING])
        {
            Status = GetLastError();
            
            goto check_status;
        }

        g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY]
            = CreateEvent(NULL,         // SecurityAttributes,
                          FALSE,        // bManualReset
                          FALSE,        // bInitialState
                          NULL          // lpName
                          );

        if (NULL == g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY])
        {
            Status = GetLastError();
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_START_WAITING]);
            g_rgWaitEvents[RETURN_LICENSE_START_WAITING] = NULL;
            
            goto check_status;
        }

        g_rgWaitEvents[RETURN_LICENSE_EXIT]
            = CreateEvent(NULL,         // SecurityAttributes,
                          FALSE,        // bManualReset
                          FALSE,        // bInitialState
                          NULL          // lpName
                          );

        if (NULL == g_rgWaitEvents[RETURN_LICENSE_EXIT])
        {
            Status = GetLastError();
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_START_WAITING]);
            g_rgWaitEvents[RETURN_LICENSE_START_WAITING] = NULL;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY]);
            g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY] = NULL;
            
            goto check_status;
        }

        g_rgWaitEvents[RETURN_LICENSE_WAITING_DONE]
            = CreateWaitableTimer(NULL,         // SecurityAttributes,
                                  FALSE,        // bManualReset
                                  NULL          // lpName
                                  );
        
        if (NULL == g_rgWaitEvents[RETURN_LICENSE_WAITING_DONE])
        {
            Status = GetLastError();
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_START_WAITING]);
            g_rgWaitEvents[RETURN_LICENSE_START_WAITING] = NULL;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY]);
            g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY] = NULL;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_EXIT]);
            g_rgWaitEvents[RETURN_LICENSE_EXIT] = NULL;
            
            goto check_status;
        }

        hThread = CreateThread( NULL,               // SecurityAttributes
                                0,                  // StackSize
                                ReturnLicenseWorker,
                                (LPVOID)g_rgWaitEvents,
                                0,                  // CreationFlags
                                NULL                // ThreadId
                                );

        if (NULL != hThread)
        {
            CloseHandle(hThread);
        }
        else
        {
            Status = STATUS_BAD_INITIAL_PC;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_START_WAITING]);
            g_rgWaitEvents[RETURN_LICENSE_START_WAITING] = NULL;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY]);
            g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY] = NULL;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_EXIT]);
            g_rgWaitEvents[RETURN_LICENSE_EXIT] = NULL;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_WAITING_DONE]);
            g_rgWaitEvents[RETURN_LICENSE_WAITING_DONE] = NULL;

            goto check_status;
        }
    }

check_status:

    if (Status != STATUS_SUCCESS)
    {
        StopCheckingGracePeriod();

        if (!fStartup)
        {
            DWORD dwRet = 0;
            LPTSTR lpszError;
            BOOL fFree = TRUE;

            dwRet=FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                NULL,
                                RtlNtStatusToDosError(Status),
                                LANG_NEUTRAL,
                                (LPTSTR)&lpszError,
                                0,
                                NULL);

            if (dwRet == 0)
            {
                lpszError = (LPTSTR) LocalAlloc(LPTR,12 * sizeof(WCHAR));

                if (NULL != lpszError)
                {
                    wsprintf(lpszError,L"%#lX",RtlNtStatusToDosError(Status));
                }
                else
                {
                    lpszError = L"";
                    fFree = FALSE;
                }
            }

            LicenseLogEvent(EVENTLOG_ERROR_TYPE,
                            EVENT_LICENSING_CONCURRENT_CANT_START,
                            1,
                            &lpszError
                            );

            if (fFree)
            {
                LocalFree(lpszError);
            }
        }
    }

    return Status;
}

NTSTATUS
CConcurrentPolicy::Deactivate(
    BOOL fShutdown
    )
{
    NTSTATUS Status;

    if (fShutdown)
    {
        Status = STATUS_SUCCESS;
    }
    else
    {
        RtlAcquireResourceShared(&g_rwLockLicense,TRUE);
        Status = ReturnLicenseToLS(0);
        RtlReleaseResource(&g_rwLockLicense);

        if (Status != STATUS_SUCCESS)
        {
            LPTSTR lpszError;
            DWORD dwRet = 0;
            BOOL fFree = TRUE;

            dwRet=FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                NULL,
                                RtlNtStatusToDosError(Status),
                                LANG_NEUTRAL,
                                (LPTSTR)&lpszError,
                                0,
                                NULL);

            if (dwRet == 0)
            {
                lpszError = (LPTSTR) LocalAlloc(LPTR,12 * sizeof(WCHAR));

                if (NULL != lpszError)
                {
                    wsprintf(lpszError,L"%#lX",RtlNtStatusToDosError(Status));
                }
                else
                {
                    lpszError = L"";
                    fFree = FALSE;
                }
            }

            LicenseLogEvent(EVENTLOG_ERROR_TYPE,
                            EVENT_LICENSING_CONCURRENT_NOT_RETURNED,
                            1,
                            &lpszError
                            );

            if (fFree)
            {
                LocalFree(lpszError);
            }
        }

        StopCheckingGracePeriod();
    }

    return(Status);
}

/*
 *  Licensing Functions
 */

NTSTATUS
CConcurrentPolicy::Logon(
    CSession& Session
    )
{
    if (!Session.IsSessionZero()
        && !Session.IsUserHelpAssistant())
    {
        return LicenseClient(Session);
    }
    else
    {
        return STATUS_SUCCESS;
    }
}

NTSTATUS
CConcurrentPolicy::Reconnect(
    CSession& Session,
    CSession& TemporarySession
    )
{
    UNREFERENCED_PARAMETER(Session);

    if (!Session.IsSessionZero()
        && !Session.IsUserHelpAssistant()
        && !Session.GetLicenseContext()->fTsLicense)
    {
        return LicenseClient(TemporarySession);
    }
    else
    {
        return STATUS_SUCCESS;
    }
}

NTSTATUS
CConcurrentPolicy::Logoff(
    CSession& Session
    )
{
    if (!Session.IsSessionZero() && !Session.IsUserHelpAssistant())
    {
        LONG lSessions, lLastBlock;

        ASSERT(Session.GetLicenseContext()->fTsLicense == TRUE);

        lSessions = InterlockedDecrement(&g_lSessionCount);

        ASSERT(lSessions >= 0);

        RtlAcquireResourceShared(&g_rwLockLicense,TRUE);
        lLastBlock = g_lSessionMax - ((g_lSessionMax / g_dwIncrement) * g_dwIncrement);
        if (lLastBlock == 0) 
            lLastBlock = g_dwIncrement;

        if (lSessions + lLastBlock <= g_lSessionMax)
        {
            TryToReturnLicenses(g_lSessionMax-lSessions);
        }
        RtlReleaseResource(&g_rwLockLicense);
    }

    return(STATUS_SUCCESS);
}

/*
 *  Private License Functions
 */

NTSTATUS
CConcurrentPolicy::LicenseClient(
    CSession& Session
    )
{
    NTSTATUS Status;
    LONG lSessions;

    lSessions = InterlockedIncrement(&g_lSessionCount);

    RtlAcquireResourceShared(&g_rwLockLicense,TRUE);

    if (lSessions > g_lSessionMax)
    {
        DWORD cBlocks = (lSessions - g_lSessionMax) / g_dwIncrement;
        DWORD nLeftover = (lSessions - g_lSessionMax) % g_dwIncrement;

        if (nLeftover > 0)
        {
            cBlocks++;
        }

        TryToAddLicenses(cBlocks * g_dwIncrement + g_lSessionMax);

        if (lSessions > g_lSessionMax)
        {
            if (!AllowLicensingGracePeriodConnection())
            {
                InterlockedDecrement(&g_lSessionCount);
                RtlReleaseResource(&g_rwLockLicense);
                return STATUS_CTX_LICENSE_NOT_AVAILABLE;
            }
        }
    }

    Status = CheckExpiration();

    RtlReleaseResource(&g_rwLockLicense);

    if (Status == STATUS_SUCCESS)
    {
        Status = GetLlsLicense(Session);

        if (Status == STATUS_SUCCESS)
        {
            Session.GetLicenseContext()->fTsLicense = TRUE;
        }
        else
        {
            InterlockedDecrement(&g_lSessionCount);
        }
    }
    else
    {
        InterlockedDecrement(&g_lSessionCount);
    }

    if (Status != STATUS_SUCCESS)
    {
        // 
        // Gina doesn't understand many error codes
        //
        Status = STATUS_CTX_LICENSE_NOT_AVAILABLE;
    }

    return(Status);
}

LONG
CConcurrentPolicy::CheckInstalledLicenses(
                                          DWORD dwWanted
    )
{
    CONCURRENTLICENSEINFO_V1 LicenseInfo;
    LICENSE_STATUS LsStatus;
    ULONG cbSecretLen;

    cbSecretLen = sizeof(LicenseInfo);
    ZeroMemory(&LicenseInfo, cbSecretLen);

    //
    // Get the concurrent license count from the LSA secret
    //

    LsStatus = LsCsp_RetrieveSecret( 
        CONCURRENT_LICENSE_STORE_LATEST_VERSION,
        (LPBYTE)&LicenseInfo,
        &cbSecretLen
        );

    if ((LsStatus != LICENSE_STATUS_OK) ||
        (cbSecretLen < sizeof(CONCURRENTLICENSEINFO_V1)) ||
        (LicenseInfo.dwLicenseVer != CURRENT_TERMINAL_SERVER_VERSION))
    {
        //
        // We determine that the license pack for this version is
        // not installed if:
        //
        // (1) we cannot retrieve the license info from the LSA secret
        // (2) we cannot read at least the size of version 1 of the license
        // info structure, or
        // (3) the license pack version is different from that requested.
        //

        return dwWanted;
    }
    else
    {
        LSERVERINFO LServerInfo;
        ULONG cbLServerInfo;

        cbLServerInfo = sizeof(LSERVERINFO);

        LsStatus = LsCsp_RetrieveSecret(
                                        CONCURRENT_LSERVER_STORE,
                                        (LPBYTE)&LServerInfo,
                                        &cbLServerInfo
                                        );

        if (LsStatus == LICENSE_STATUS_OK)
        {
            g_ftNotAfter = LServerInfo.ftNotAfter;

            if (0 == TimeToHardExpiration())
            {
                return dwWanted;
            }
        }

        return (dwWanted - LicenseInfo.lLicenseCount);
    }
}

VOID
CConcurrentPolicy::TryToReturnLicenses(
    DWORD dwReturnCount
    )
{
    ASSERT(dwReturnCount != 0);

    if (dwReturnCount > g_dwIncrement)
    {
        // Immediately return all but one block
        if (NULL != g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY])
            SetEvent(g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY]);
    }

    // Wait before returning one block
    if (NULL != g_rgWaitEvents[RETURN_LICENSE_START_WAITING])
        SetEvent(g_rgWaitEvents[RETURN_LICENSE_START_WAITING]);
}

//
// Must have shared lock to call this
//

NTSTATUS
ReturnLicenseToLS(
    LONG nNum
    )
{
    HANDLE hProtocol = NULL;
    HWID hwid;
    LICENSEREQUEST LicenseRequest;
    LICENSE_STATUS LsStatus;
    LONG CurrentCount;
    LSERVERINFO LServerInfo;
    ULONG cbLServerInfo;
    Product_Info ProductInfo;

    LsStatus = InitProductInfo(
        &ProductInfo,
        PRODUCT_INFO_CONCURRENT_SKU_PRODUCT_ID
        );

    if (LsStatus != LICENSE_STATUS_OK)
    {
        return(LsStatusToNtStatus(LsStatus));
    }

    //
    //  Get the current license count and HWID from the store.
    //

    LsStatus = GetLicenseFromStore(
        &CurrentCount,
        &hwid,
        CURRENT_TERMINAL_SERVER_VERSION
        );

    if (LsStatus == LICENSE_STATUS_OK)
    {
        if ((0 == nNum) || (nNum > CurrentCount))
        {
            nNum = CurrentCount;
        }

        if (CurrentCount == 0)
        {
            // We don't check for status from the following calls as we don't want to fail.

            LsCsp_StoreSecret( CONCURRENT_LICENSE_STORE_LATEST_VERSION, NULL, 0 );
            LsCsp_StoreSecret( CONCURRENT_LSERVER_STORE, NULL, 0 );
            return(STATUS_SUCCESS);
        }
    }
    else
    {
        return(LsStatusToNtStatus(LsStatus));
    }

    //
    //  Initialize the license request structure.
    //

    ZeroMemory(&LicenseRequest, sizeof(LICENSEREQUEST));

    LicenseRequest.pProductInfo = &ProductInfo;
    LicenseRequest.dwLanguageID = GetSystemDefaultLCID();
    LicenseRequest.dwPlatformID = CURRENT_TERMINAL_SERVER_VERSION;    
    LicenseRequest.cbEncryptedHwid = sizeof(HWID);
    LicenseRequest.pbEncryptedHwid = (PBYTE)&hwid;

    cbLServerInfo = sizeof(LSERVERINFO);

    LsStatus = LsCsp_RetrieveSecret(
        CONCURRENT_LSERVER_STORE,
        (LPBYTE)&LServerInfo,
        &cbLServerInfo
        );

    if (LsStatus == LICENSE_STATUS_OK)
    {
        LsStatus = CreateProtocolContext(NULL, &hProtocol);
    }
    else
    {
        goto done;
    }

    if (LsStatus == LICENSE_STATUS_OK)
    {
        LsStatus = ReturnInternetLicense(
            hProtocol,
            LServerInfo.szServerName,
            &LicenseRequest,
            LServerInfo.ulSerialNumber,
            nNum
            );
    }
    else
    {
        goto done;
    }

    if (LsStatus == LICENSE_STATUS_OK)
    {
        if( (CurrentCount-nNum) > 0 )
        {         
            LsStatus = SetLicenseInStore(
                CurrentCount-nNum,
                hwid,
                CURRENT_TERMINAL_SERVER_VERSION
                );
        }
        else
        {
            // We don't check for status from the following calls as we don't want to fail.

            LsCsp_StoreSecret( CONCURRENT_LICENSE_STORE_LATEST_VERSION, NULL, 0 );
            LsCsp_StoreSecret( CONCURRENT_LSERVER_STORE, NULL, 0 );
        }

        RtlConvertSharedToExclusive(&g_rwLockLicense);
        g_lSessionMax = CurrentCount - nNum;
        RtlConvertExclusiveToShared(&g_rwLockLicense);
    }

done:
    if (hProtocol != NULL)
    {
        DeleteProtocolContext(hProtocol);
    }

    if (ProductInfo.pbCompanyName)
    {
        LocalFree(ProductInfo.pbCompanyName);
    }

    if (ProductInfo.pbProductID)
    {
        LocalFree(ProductInfo.pbProductID);
    }

    return(LsStatusToNtStatus(LsStatus));
}

DWORD
CConcurrentPolicy::GenerateHwidFromComputerName(
    HWID *hwid
    )
{
    MD5_CTX HashState;
    WCHAR wszName[MAX_COMPUTERNAME_LENGTH * 9]; // buffer we hope is big enough
    DWORD cbName = sizeof(wszName) / sizeof(TCHAR);
    BOOL fRet;

    //
    // get computer name
    //

    fRet = GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified,
                 wszName,
                 &cbName);

    if (!fRet)
    {
        return GetLastError();
    }

    //
    // generate the hash on the data.
    //
    MD5Init( &HashState );
    MD5Update( &HashState, (LPBYTE)wszName, cbName );
    MD5Final( &HashState );

    memcpy((LPBYTE)hwid,HashState.digest,sizeof(HashState.digest));

    // fill in the rest with characters from computer name

    lstrcpyn((LPWSTR)(((LPBYTE)hwid)+sizeof(HashState.digest)),
             wszName,
             (sizeof(HWID)-sizeof(HashState.digest))/sizeof(WCHAR));

    return ERROR_SUCCESS;
}

//
// Must have shared lock to call this
//
VOID
CConcurrentPolicy::TryToAddLicenses(
                                    DWORD dwTotalWanted
    )
{
    NTSTATUS Status;
    BOOL fRetrievedAll;

    // Releasing g_rwLockLicense that other threads may be sharing, avoiding
    // possibility of deadlock if a thread calls RtlConvertSharedToExclusive 
    // while holding g_csAddLicenses

    RtlReleaseResource(&g_rwLockLicense);
    
    RtlEnterCriticalSection(&g_csAddLicenses);

    // Reacquiring the shared lock that was released
    RtlAcquireResourceShared(&g_rwLockLicense,TRUE);

    if (WAIT_TIMEOUT == WaitForSingleObject(g_hOkayToAdd,0))
    {
        // We're in waiting period
        RtlLeaveCriticalSection(&g_csAddLicenses);
        return;
    }

    if (g_lSessionMax >= (LONG) dwTotalWanted)
    {
        // we already have enough
        RtlLeaveCriticalSection(&g_csAddLicenses);
        return;
    }


    Status = GetLicenseFromLS(dwTotalWanted - g_lSessionMax,
                              FALSE,    // fIgnoreCurrentCount
                              &fRetrievedAll);

    if ((Status != STATUS_SUCCESS) || (!fRetrievedAll))
    {
        LARGE_INTEGER liWait;

        // wait before adding more

        liWait.QuadPart = (__int64) g_dwWaitTimeAdd * (-10 * 1000 * 1000);

        SetWaitableTimer(g_hOkayToAdd,
                         &liWait,                   // pDueTime
                         g_dwWaitTimeAdd * 1000,    // lPeriod
                         NULL,                      // pfnCompletionRoutine
                         NULL,                      // lpArgToCompletionRoutine
                         FALSE                      // fResume (from suspended)
                         );
    }

    RtlLeaveCriticalSection(&g_csAddLicenses);
}

//
// Must have shared lock to call this
//
NTSTATUS
CConcurrentPolicy::GetLicenseFromLS(
                                    LONG nNumToAdd,
                                    BOOL fIgnoreCurrentCount,
                                    BOOL *pfRetrievedAll
    )
{
    BOOL fHwidSet;
    BOOL fRet;
    DWORD cbLicense;
    DWORD cbSecretKey;
    DWORD cchComputerName = MAX_COMPUTERNAME_LENGTH + 1;
    DWORD dwNumLicensedProduct = 0;
    DWORD dwStatus;
    HANDLE hProtocol;
    HWID hwid;
    HWID hwidEncrypted;
    LICENSE_STATUS LsStatus;
    LICENSEREQUEST LicenseRequest;
    LONG CurrentCount;
    LSERVERINFO LServerInfo;
    ULONG cbLServerInfo;
    NTSTATUS Status;
    PBYTE pbLicense;
    PBYTE pbSecretKey;
    PLICENSEDPRODUCT pLicensedProduct;
    Product_Info ProductInfo;
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    TCHAR *pszLicenseServerName = LServerInfo.szServerName;
    DWORD dwNumLicensesRetrieved = 0;

    if (nNumToAdd < 0)
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (nNumToAdd == 0)
    {
        if (NULL != pfRetrievedAll)
            *pfRetrievedAll = TRUE;

        return STATUS_SUCCESS;
    }

    if (NULL != pfRetrievedAll)
        *pfRetrievedAll = FALSE;

    //
    //  These variables must be initialized here, or else any of the gotos
    //  below may cause them to be used without initialization.
    //

    hProtocol = NULL;
    pbLicense = NULL;
    pbSecretKey = NULL;
    pLicensedProduct = NULL;
    Status = STATUS_SUCCESS;
    ZeroMemory(&ProductInfo, sizeof(Product_Info));

    //
    //  Get the current license count and HWID from the store. Failure is not
    //  fatal.
    //

    LsStatus = GetLicenseFromStore(
        &CurrentCount,
        &hwidEncrypted,
        CURRENT_TERMINAL_SERVER_VERSION
        );

    if (LsStatus == LICENSE_STATUS_OK)
    {
        fHwidSet = TRUE;

        if (fIgnoreCurrentCount)
        {
            CurrentCount = 0;
        }
    }
    else
    {
        CurrentCount = 0;
        fHwidSet = FALSE;
    }

    //
    //  Initialize the product info.
    //

    LsStatus = InitProductInfo(
        &ProductInfo,
        PRODUCT_INFO_CONCURRENT_SKU_PRODUCT_ID
        );

    if (LsStatus == LICENSE_STATUS_OK)
    {
        //
        //  Initialize the license request structure.
        //

        ZeroMemory(&LicenseRequest, sizeof(LicenseRequest));

        LicenseRequest.pProductInfo = &ProductInfo;
        LicenseRequest.dwLanguageID = GetSystemDefaultLCID();
        LicenseRequest.dwPlatformID = CURRENT_TERMINAL_SERVER_VERSION;    
        LicenseRequest.cbEncryptedHwid = sizeof(HWID);
    }
    else
    {
        goto done;
    }


    if (!fHwidSet)
    {
        //
        // No hardware ID yet - create one
        //

        dwStatus = GenerateHwidFromComputerName(&hwid);

        if (dwStatus == ERROR_SUCCESS)
        {
            LsStatus = LsCsp_EncryptHwid(
                &hwid,
                (PBYTE)&hwidEncrypted,
                &(LicenseRequest.cbEncryptedHwid)
                );

            if (LsStatus == LICENSE_STATUS_OK)
            {
                fHwidSet = TRUE;
            }
            else
            {
                goto done;
            }
        }
        else
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            goto done;
        }
    }

    LicenseRequest.pbEncryptedHwid = (PBYTE)&hwidEncrypted;

    //
    // get our computer name
    //

    fRet = GetComputerName(szComputerName, &cchComputerName);

    if (fRet)
    {
        LsStatus = CreateProtocolContext(NULL, &hProtocol);
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    if (0 == CurrentCount)
    {
        // any license server will do

        pszLicenseServerName = NULL;
    }
    else
    {
        cbLServerInfo = sizeof(LSERVERINFO);

        LsStatus = LsCsp_RetrieveSecret(
                                        CONCURRENT_LSERVER_STORE,
                                        (LPBYTE)&LServerInfo,
                                        &cbLServerInfo
                                        );

        if (LsStatus != LICENSE_STATUS_OK)
        {
            // no license server known; any will do

            pszLicenseServerName = NULL;
        }
    }

    cbLicense = 0;

    if (LsStatus == LICENSE_STATUS_OK)
    {
        //
        // NB: even if CurrentCount>0, license server will know about
        // existing licenses, and do a proper upgrade
        //

        dwNumLicensesRetrieved = nNumToAdd+CurrentCount;

        LsStatus = RequestNewLicense(
                           hProtocol,
                           pszLicenseServerName,
                           &LicenseRequest,
                           szComputerName,
                           szComputerName,
                           FALSE,       // bAcceptTemporaryLicense
                           TRUE,        // bAcceptFewerLicenses
                           &dwNumLicensesRetrieved,
                           &cbLicense,
                           &pbLicense
                           );

        if ((NULL != pfRetrievedAll)
            && (LsStatus == LICENSE_STATUS_OK)
            && ((LONG)dwNumLicensesRetrieved == nNumToAdd+CurrentCount))
        {
            *pfRetrievedAll = TRUE;
        }

    }
    else
    {
        goto done;
    }

    if (LsStatus == LICENSE_STATUS_OK)
    {
        //
        // Get the secret key that is used to decode the license
        //

        cbSecretKey = 0;

        LicenseGetSecretKey(&cbSecretKey, NULL);

        pbSecretKey = (PBYTE)LocalAlloc(LPTR, cbSecretKey);

        if (pbSecretKey != NULL)
        {
            LsStatus = LicenseGetSecretKey(&cbSecretKey, pbSecretKey);
        }
        else
        {
            Status = STATUS_NO_MEMORY;
            goto done;
        }

    }
    else
    {
        goto done;
    }

    //
    //  Decode license issued by hydra license server certificate engine.
    //

    __try
    {
        //
        //  Check size of decoded licenses.
        //

        LsStatus = LSVerifyDecodeClientLicense(
            pbLicense, 
            cbLicense, 
            pbSecretKey, 
            cbSecretKey,
            &dwNumLicensedProduct,
            NULL
            );

        if (LsStatus == LICENSE_STATUS_OK)
        {
            pLicensedProduct = (PLICENSEDPRODUCT)LocalAlloc(
                    LPTR,
                    sizeof(LICENSEDPRODUCT) * dwNumLicensedProduct
                    );
        }
        else
        {
            goto done;
        }
        
        if (pLicensedProduct != NULL)
        {
            //
            //  Decode the license.
            //

            LsStatus = LSVerifyDecodeClientLicense(
                pbLicense, 
                cbLicense, 
                pbSecretKey, 
                cbSecretKey,
                &dwNumLicensedProduct,
                pLicensedProduct
                );
        }
        else
        {
            Status = STATUS_NO_MEMORY;
            goto done;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        LsStatus = LICENSE_STATUS_CANNOT_DECODE_LICENSE;
    }

    if (LsStatus == LICENSE_STATUS_OK)
    {
        ReceivedPermanentLicense();

        LServerInfo.cchServerName = lstrlen(pLicensedProduct->szIssuer);

        lstrcpynW(
            LServerInfo.szServerName,
            pLicensedProduct->szIssuer,
            sizeof(LServerInfo.szServerName) / sizeof(WCHAR)
            );

        LServerInfo.ulSerialNumber = pLicensedProduct->ulSerialNumber;

        LServerInfo.ftNotAfter = pLicensedProduct->NotAfter;

        g_ftNotAfter = LServerInfo.ftNotAfter;

        LsStatus = LsCsp_StoreSecret(
            CONCURRENT_LSERVER_STORE,
            (LPBYTE)&LServerInfo,
            sizeof(LServerInfo)
            );

    }
    else
    {
        goto done;
    }

    if (LsStatus == LICENSE_STATUS_OK)
    {
        //
        //  Adjust the license count in the local LSA store.
        //

        LsStatus = SetLicenseInStore(
            dwNumLicensesRetrieved,
            hwidEncrypted,
            CURRENT_TERMINAL_SERVER_VERSION
            );

        RtlConvertSharedToExclusive(&g_rwLockLicense);
        g_lSessionMax = dwNumLicensesRetrieved;
        RtlConvertExclusiveToShared(&g_rwLockLicense);
    }

done:
    if (hProtocol != NULL)
    {
        DeleteProtocolContext(hProtocol);
    }

    if (pbLicense != NULL)
    {
        LocalFree(pbLicense);
    }

    if (pbSecretKey != NULL)
    {
        LocalFree(pbSecretKey);
    }

    if (pLicensedProduct != NULL)
    {
        for (DWORD dwCount = 0; dwCount < dwNumLicensedProduct; dwCount++)
        {
            LSFreeLicensedProduct(pLicensedProduct+dwCount);
        }
    }

    if (ProductInfo.pbCompanyName != NULL)
    {
        LocalFree(ProductInfo.pbCompanyName);
    }

    if (ProductInfo.pbProductID != NULL)
    {
        LocalFree(ProductInfo.pbProductID);
    }

    if (Status == STATUS_SUCCESS)
    {
        return(LsStatusToNtStatus(LsStatus));
    }
    else
    {
        return(Status);
    }
}

LICENSE_STATUS
GetLicenseFromStore(
    PLONG pLicenseCount,
    PHWID phwid,
    DWORD dwLicenseVer
    )
{
    CONCURRENTLICENSEINFO_V1 LicenseInfo;
    LICENSE_STATUS LsStatus;
    ULONG cbSecretLen;

    ASSERT(pLicenseCount != NULL);
    ASSERT(phwid != NULL);

    cbSecretLen = sizeof(CONCURRENTLICENSEINFO_V1);    
    ZeroMemory(&LicenseInfo, cbSecretLen);

    //
    // Get the license count from the LSA secret
    //

    LsStatus = LsCsp_RetrieveSecret( 
        CONCURRENT_LICENSE_STORE_LATEST_VERSION,
        (LPBYTE)&LicenseInfo,
        &cbSecretLen
        );

    if ((LsStatus != LICENSE_STATUS_OK) ||
        (cbSecretLen < sizeof(CONCURRENTLICENSEINFO_V1)) ||
        (LicenseInfo.dwLicenseVer != dwLicenseVer))
    {
        //
        // We determine that the license pack for this version is
        // not installed if we:
        //
        // (1) cannot retrieve the license info from the LSA secret
        // (2) cannot read at least the size of version 1 of the license info
        // structure.
        // (3) the license pack version is different from that requested.
        //

        LsStatus = LICENSE_STATUS_NO_LICENSE_ERROR;

        // We don't check for status from the following as we don't want to fail.

        LsCsp_StoreSecret( CONCURRENT_LICENSE_STORE_LATEST_VERSION, NULL, 0 );
        LsCsp_StoreSecret( CONCURRENT_LSERVER_STORE, NULL, 0 );
    }
    else
    {
        *pLicenseCount = LicenseInfo.lLicenseCount;
        *phwid = LicenseInfo.hwid;
    }
        
    return(LsStatus);
}

LICENSE_STATUS
SetLicenseInStore(
    LONG LicenseCount,
    HWID hwid,
    DWORD dwLicenseVer
    )
{
    CONCURRENTLICENSEINFO_V1 LicenseInfo;
    LICENSE_STATUS LsStatus;

    //
    // verify that the license count to set is not negative.
    //

    ASSERT(LicenseCount >= 0);

    //
    // initialize the license information to store
    //

    LicenseInfo.dwStructVer = CONCURRENTLICENSEINFO_TYPE_V1;
    LicenseInfo.dwLicenseVer = dwLicenseVer;
    LicenseInfo.hwid = hwid;
    LicenseInfo.lLicenseCount = LicenseCount;

    //
    // store the new license count
    //

    LsStatus = LsCsp_StoreSecret(
        CONCURRENT_LICENSE_STORE_LATEST_VERSION,
        (LPBYTE)&LicenseInfo,
        sizeof(CONCURRENTLICENSEINFO_V1)
        );

    return(LsStatus);
}

/*
 *  Private Functions
 */

//
// Must have shared lock to call this
//

NTSTATUS
CConcurrentPolicy::CheckExpiration(
    )
{
    DWORD dwWait = TimeToSoftExpiration();
    NTSTATUS Status = STATUS_SUCCESS;

    if (0 == dwWait)
    {
        // Soft expiration reached, time to renew
        Status = GetLicenseFromLS(g_lSessionMax,
                                  TRUE,         // fIgnoreCurrentCount
                                  NULL);

        if ((STATUS_SUCCESS != Status) && (0 == TimeToHardExpiration()))
        {
            // Couldn't renew and we're past hard expiration

            LicenseLogEvent(EVENTLOG_ERROR_TYPE,
                            EVENT_LICENSING_CONCURRENT_EXPIRED,
                            0,
                            NULL
                            );

            RtlConvertSharedToExclusive(&g_rwLockLicense);
            g_lSessionMax = 0;
            RtlConvertExclusiveToShared(&g_rwLockLicense);
        }
        else
        {
            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}

/*
 *  Global Static Functions
 */

DWORD
CConcurrentPolicy::TimeToSoftExpiration(
    )
{
    SYSTEMTIME stNow;
    FILETIME ftNow;
    ULARGE_INTEGER ullNotAfterLeeway;
    ULARGE_INTEGER ullNow;
    ULARGE_INTEGER ullDiff;
    DWORD dwDiff = 0;

    GetSystemTime(&stNow);
    SystemTimeToFileTime(&stNow,&ftNow);

    ullNow.LowPart = ftNow.dwLowDateTime;
    ullNow.HighPart = ftNow.dwHighDateTime;

    ullNotAfterLeeway.LowPart = g_ftNotAfter.dwLowDateTime;
    ullNotAfterLeeway.HighPart = g_ftNotAfter.dwHighDateTime;

    ullNotAfterLeeway.QuadPart -= (__int64) LC_POLICY_CONCURRENT_EXPIRATION_LEEWAY * 10 * 1000;

    if (ullNotAfterLeeway.QuadPart > ullNow.QuadPart)
    {
        ullDiff.QuadPart = ullNotAfterLeeway.QuadPart - ullNow.QuadPart;

        ullDiff.QuadPart /= (10 * 1000);

        if (ullDiff.HighPart == 0)
        {
            dwDiff = ullDiff.LowPart;
        }
        else
        {
            // too big, return max

            dwDiff = ULONG_MAX;
        }
    }

    return dwDiff;
}

DWORD
CConcurrentPolicy::TimeToHardExpiration(
    )
{
    SYSTEMTIME stNow;
    FILETIME ftNow;
    ULARGE_INTEGER ullNotAfterLeeway;
    ULARGE_INTEGER ullNow;
    ULARGE_INTEGER ullDiff;
    DWORD dwDiff = 0;

    GetSystemTime(&stNow);
    SystemTimeToFileTime(&stNow,&ftNow);

    ullNow.LowPart = ftNow.dwLowDateTime;
    ullNow.HighPart = ftNow.dwHighDateTime;

    ullNotAfterLeeway.LowPart = g_ftNotAfter.dwLowDateTime;
    ullNotAfterLeeway.HighPart = g_ftNotAfter.dwHighDateTime;

    if (ullNotAfterLeeway.QuadPart > ullNow.QuadPart)
    {
        ullDiff.QuadPart = ullNotAfterLeeway.QuadPart - ullNow.QuadPart;

        ullDiff.QuadPart /= (10 * 1000);

        if (ullDiff.HighPart == 0)
        {
            dwDiff = ullDiff.LowPart;
        }
        else
        {
            // too big, return max

            dwDiff = ULONG_MAX;
        }
    }

    return dwDiff;
}

VOID
CConcurrentPolicy::ReadLicensingParameters(
    )
{
    HKEY hKey = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwBuffer;
    DWORD cbBuffer;

    g_dwIncrement = LC_POLICY_CONCURRENT_LICENSE_COUNT_INCREMENT;
    g_dwWaitTimeAdd = LC_POLICY_CONCURRENT_WAIT_TIME_ADD;
    g_dwWaitTimeRemove = LC_POLICY_CONCURRENT_WAIT_TIME_REMOVE;
        
    dwStatus =RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    LCREG_CONCURRENTKEY,
                    0,
                    KEY_READ,
                    &hKey
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        cbBuffer = sizeof(dwBuffer);
        dwStatus = RegQueryValueEx(
                    hKey,
                    LCREG_INCREMENT,
                    NULL,
                    NULL,
                    (LPBYTE)&dwBuffer,
                    &cbBuffer
                    );

        if (dwStatus == ERROR_SUCCESS)
        {
            g_dwIncrement = max(dwBuffer, 1);
        }

        cbBuffer = sizeof(dwBuffer);
        dwStatus = RegQueryValueEx(
                    hKey,
                    LCREG_WAIT_TIME_ADD,
                    NULL,
                    NULL,
                    (LPBYTE)&dwBuffer,
                    &cbBuffer
                    );

        if (dwStatus == ERROR_SUCCESS)
        {
            g_dwWaitTimeAdd = max(dwBuffer, 1);
        }

        cbBuffer = sizeof(dwBuffer);
        dwStatus = RegQueryValueEx(
                    hKey,
                    LCREG_WAIT_TIME_REMOVE,
                    NULL,
                    NULL,
                    (LPBYTE)&dwBuffer,
                    &cbBuffer
                    );

        if (dwStatus == ERROR_SUCCESS)
        {
            g_dwWaitTimeRemove = max(dwBuffer, 1);
        }

        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\lcrpcint.cpp ===
/*
 *  LCRpcInt.cpp
 *
 *  Author: BreenH
 *
 *  Internal functions to support the RPC interface.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "lscorep.h"
#include "lcrpcint.h"
#include "lcrpc.h"
#include "rpcwire.h"

/*
 *  Globals
 */

ULONG g_ulRpcContext = 0;

/*
 *  TERMSRV.EXE Function Prototypes
 */

extern "C" BOOL
IsCallerAdmin(
    VOID
    );


//
// Returns RPC_S_OK if the binding represents a local administrator on this box,
// AND if the binding is local. 
//
RPC_STATUS
TermsrvSecurityCallback(void * Interface, void *Context)
{
    BOOL          fIsImpersonatingClient  = FALSE; 
    RPC_STATUS    rpcStatus;
    unsigned int  RpcClientLocalFlag;

    rpcStatus = I_RpcBindingIsClientLocal(NULL, &RpcClientLocalFlag);
    if (rpcStatus != RPC_S_OK)
	goto error; 

    if (!RpcClientLocalFlag) { 
	rpcStatus = RPC_S_ACCESS_DENIED; 
	goto error; 
    }

    rpcStatus = RpcImpersonateClient(NULL); 
    if (rpcStatus != RPC_S_OK)
	goto error; 
    fIsImpersonatingClient = TRUE; 

    if (!IsCallerAdmin()) { 
	rpcStatus = RPC_S_ACCESS_DENIED; 
	goto error; 
    }
    
    rpcStatus = RPC_S_OK; 
 error:
    if (fIsImpersonatingClient) { 
	RpcRevertToSelf(); 
    }
    return rpcStatus; 
}


/*
 *  Function Implementations
 */

RPC_STATUS
InitializeRpcInterface(
    )
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcServerUseProtseqEp(
        L"ncalrpc",
        LC_RPC_MAX_THREADS,
        LC_RPC_LRPC_EP,
        NULL
        );

    if (RpcStatus == RPC_S_OK)
    {
        RpcStatus = RpcServerRegisterIfEx(
            LCRPC_v1_0_s_ifspec,
            NULL,
            NULL,
            0,
            RPC_C_LISTEN_MAX_CALLS_DEFAULT,          
            TermsrvSecurityCallback
            );
    }
    else
    {
        goto exit;
    }

exit:
    return(RpcStatus);
}

/*
 *  RPC Interface Functions
 */

extern "C" void
LCRPC_HANDLE_rundown(
    LCRPC_HANDLE hServer
    )
{
    RpcLicensingCloseServer(&hServer);
}

BOOLEAN
RpcLicensingOpenServer(
    handle_t hBinding,
    HANDLE *phServer,
    PLONG pStatus
    )
{
    BOOLEAN fReturn;
    PULONG pulContext;
    RPC_STATUS RpcStatus;

    UNREFERENCED_PARAMETER(hBinding);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pStatus != NULL);
    ASSERT(phServer != NULL);

    //
    //  Impersonate client.
    //

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        *pStatus = STATUS_CANNOT_IMPERSONATE;
        return(FALSE);
    }

    //
    //  Check for administration privileges.
    //

    if (!IsCallerAdmin())
    {
        RpcStatus = RpcRevertToSelf();
        *pStatus = STATUS_ACCESS_DENIED;
        return(FALSE);
    }

    RpcStatus = RpcRevertToSelf();
    if(RpcStatus != RPC_S_OK)
    {
        *pStatus = STATUS_CANNOT_IMPERSONATE;
        return (FALSE);
    }

    pulContext = (PULONG)MIDL_user_allocate(sizeof(ULONG));

    //
    //  Currently, RPC contexts are not necessary, but in case they are
    //  needed in the future, the RPC calls today must pass them. For
    //  now, just increment a ULONG for a context value.
    //

    if (pulContext != NULL)
    {
        *pulContext = g_ulRpcContext++;
        *phServer = pulContext;
        *pStatus = STATUS_SUCCESS;
        fReturn = TRUE;
    }
    else
    {
        *pStatus = STATUS_INSUFF_SERVER_RESOURCES;
        fReturn = FALSE;
    }

    return(fReturn);
}

VOID
RpcLicensingCloseServer(
    HANDLE *phServer
    )
{
    ASSERT(phServer != NULL);
    ASSERT(*phServer != NULL);
    RPC_STATUS RpcStatus;
    //
    //  Impersonate client.
    //

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        return;
    }

    //
    //  Check for administration privileges.
    //

    if (!IsCallerAdmin())
    {
        RpcStatus = RpcRevertToSelf();
        return;
    }

    RpcStatus = RpcRevertToSelf();    

    MIDL_user_free(*phServer);
    *phServer = NULL;
}

BOOLEAN
RpcLicensingLoadPolicy(
    HANDLE hServer,
    ULONG ulPolicyId,
    PLONG pStatus
    )
{
    UNREFERENCED_PARAMETER(hServer);
    UNREFERENCED_PARAMETER(ulPolicyId);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pStatus != NULL);

    *pStatus = STATUS_NOT_IMPLEMENTED;
    return(FALSE);
}

BOOLEAN
RpcLicensingUnloadPolicy(
    HANDLE hServer,
    ULONG ulPolicyId,
    PLONG pStatus
    )
{
    UNREFERENCED_PARAMETER(hServer);
    UNREFERENCED_PARAMETER(ulPolicyId);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pStatus != NULL);

    *pStatus = STATUS_NOT_IMPLEMENTED;
    return(FALSE);
}

LONG
RpcLicensingSetPolicy(
    HANDLE hServer,
    ULONG ulPolicyId,
    PLONG pNewPolicyStatus
    )
{
    NTSTATUS Status;
    RPC_STATUS RpcStatus;

    UNREFERENCED_PARAMETER(hServer);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pNewPolicyStatus != NULL);

    //
    //  Impersonate client.
    //

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        Status = STATUS_CANNOT_IMPERSONATE;
        *pNewPolicyStatus = STATUS_SUCCESS;
        return(Status);
    }

    //
    //  Check for administration privileges.
    //

    if (!IsCallerAdmin())
    {
        RpcStatus = RpcRevertToSelf();
        Status = STATUS_ACCESS_DENIED;
        *pNewPolicyStatus = STATUS_SUCCESS;
        return(Status);
    }

    RpcStatus = RpcRevertToSelf();
   
    if(RpcStatus != RPC_S_OK)
    {
        Status = STATUS_CANNOT_IMPERSONATE;
        return (Status);
    }
    Status = LCSetPolicy(ulPolicyId, pNewPolicyStatus);
    

    return(Status);
}

BOOLEAN
RpcLicensingGetAvailablePolicyIds( 
    HANDLE hServer,
    PULONG *ppulPolicyIds,
    PULONG pcPolicies,
    PLONG pStatus
    )
{
    UNREFERENCED_PARAMETER(hServer);
    RPC_STATUS RpcStatus;

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(ppulPolicyIds != NULL);
    ASSERT(pcPolicies != NULL);
    ASSERT(pStatus != NULL);

    //
    //  Impersonate client.
    //

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        *pStatus = STATUS_CANNOT_IMPERSONATE;
        return(FALSE);
    }

    //
    //  Check for administration privileges.
    //

    if (!IsCallerAdmin())
    {
        RpcStatus = RpcRevertToSelf();
        *pStatus = STATUS_ACCESS_DENIED;
        return(FALSE);
    }

    RpcStatus = RpcRevertToSelf();
    if(RpcStatus != RPC_S_OK)
    {
        *pStatus = STATUS_CANNOT_IMPERSONATE;
        return (FALSE);
    }

    *pStatus = LCGetAvailablePolicyIds(ppulPolicyIds, pcPolicies);

    return(*pStatus == STATUS_SUCCESS);
}

BOOLEAN
RpcLicensingGetPolicy( 
    HANDLE hServer,
    PULONG pulPolicyId,
    PLONG pStatus
    )
{
    UNREFERENCED_PARAMETER(hServer);
    RPC_STATUS RpcStatus;

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pulPolicyId != NULL);
    ASSERT(pStatus != NULL);


    //
    //  Impersonate client.
    //

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        *pStatus = STATUS_CANNOT_IMPERSONATE;
        return(FALSE);
    }

    //
    //  Check for administration privileges.
    //

    if (!IsCallerAdmin())
    {
        RpcStatus = RpcRevertToSelf();
        *pStatus = STATUS_ACCESS_DENIED;
        return(FALSE);
    }

    RpcStatus = RpcRevertToSelf();
    if(RpcStatus != RPC_S_OK)
    {
        *pStatus = STATUS_CANNOT_IMPERSONATE;
        return (FALSE);
    }

    *pulPolicyId = LCGetPolicy();
    *pStatus = STATUS_SUCCESS;

    return(TRUE);
}

BOOLEAN
RpcLicensingGetPolicyInformation( 
    HANDLE hServer,
    ULONG ulPolicyId,
    PULONG pulVersion,
    PCHAR *ppWire,
    PULONG pcbWire,
    PLONG pStatus
    )
{
    BOOLEAN fRet;
    LPLCPOLICYINFOGENERIC lpPolicyInfo;
    NTSTATUS Status;
    RPC_STATUS RpcStatus;

    UNREFERENCED_PARAMETER(hServer);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pulVersion != NULL);
    ASSERT(ppWire != NULL);
    ASSERT(pcbWire != NULL);
    ASSERT(pStatus != NULL);

    fRet = FALSE;
    *pulVersion = min(*pulVersion, LCPOLICYINFOTYPE_CURRENT);
    *ppWire = NULL;

    //
    //  Impersonate client.
    //

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        *pStatus = STATUS_CANNOT_IMPERSONATE;
        return(FALSE);
    }

    //
    //  Check for administration privileges.
    //

    if (!IsCallerAdmin())
    {
        RpcStatus = RpcRevertToSelf();
        *pStatus = STATUS_ACCESS_DENIED;
        return(FALSE);
    }

    RpcStatus = RpcRevertToSelf();
    if(RpcStatus != RPC_S_OK)
    {
        *pStatus = STATUS_CANNOT_IMPERSONATE;
        return(FALSE);
    }

    Status = AllocatePolicyInformation(&lpPolicyInfo, *pulVersion);

    if (Status == STATUS_SUCCESS)
    {
        Status = LCGetPolicyInformation(ulPolicyId, lpPolicyInfo);

        if (Status == STATUS_SUCCESS)
        {
            *pcbWire = CopyPolicyInformationToWire(
                (LPLCPOLICYINFOGENERIC*)ppWire,
                lpPolicyInfo
                );

            if (*pcbWire != 0)
            {
                fRet = TRUE;
                Status = STATUS_SUCCESS;
            }
            else
            {
                Status = STATUS_INSUFF_SERVER_RESOURCES;
            }

            FreePolicyInformation(&lpPolicyInfo);
        }
        else if (Status == STATUS_NO_MEMORY)
        {
            Status = STATUS_INSUFF_SERVER_RESOURCES;
        }
    }

    *pStatus = Status;

    return(fRet);
}

BOOLEAN
RpcLicensingDeactivateCurrentPolicy(
    HANDLE hServer,
    PLONG pStatus
    )
{
    RPC_STATUS RpcStatus;

    UNREFERENCED_PARAMETER(hServer);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pStatus != NULL);

    //
    //  Impersonate client.
    //

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        *pStatus = STATUS_CANNOT_IMPERSONATE;
        return(FALSE);
    }

    //
    //  Check for administration privileges.
    //

    if (!IsCallerAdmin())
    {
        RpcStatus = RpcRevertToSelf();
        *pStatus = STATUS_ACCESS_DENIED;
        return(FALSE);
    }

    RpcStatus = RpcRevertToSelf();

    if (RpcStatus != RPC_S_OK)
    {
        *pStatus = STATUS_CANNOT_IMPERSONATE;
        return (FALSE);
    }

    *pStatus = LCDeactivateCurrentPolicy();


    return(*pStatus == STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\concurrent.h ===
/*
 *  Concurrent.h
 *
 *  Author: RobLeit
 *
 *  The Concurrent licensing policy.
 */

#ifndef __LC_Concurrent_H__
#define __LC_Concurrent_H__

/*
 *  Includes
 */

#include "policy.h"

/*
 *  Constants
 */

#define LC_POLICY_CONCURRENT_EXPIRATION_LEEWAY (1000*60*60*24*7)

/*
 *  Class Definition
 */

class CConcurrentPolicy : public CPolicy
{
public:

/*
 *  Creation Functions
 */

    CConcurrentPolicy(
    );

    ~CConcurrentPolicy(
    );

/*
 *  Administrative Functions
 */

    ULONG
    GetFlags(
    );

    ULONG
    GetId(
    );

    NTSTATUS
    GetInformation(
                   LPLCPOLICYINFOGENERIC lpPolicyInfo
                   );

/*
 *  Loading and Activation Functions
 */

    NTSTATUS
    Load(
    );

    NTSTATUS
    Unload(
    );

    NTSTATUS
    Activate(
             BOOL fStartup,
             ULONG *pulAlternatePolicy
             );

    NTSTATUS
    Deactivate(
               BOOL fShutdown
               );

/*
 *  Licensing Functions
 */

    NTSTATUS
    Logon(
          CSession& Session
          );


    NTSTATUS
    Reconnect(
          CSession& Session,
          CSession& TemporarySession
          );

    NTSTATUS
    Logoff(
          CSession& Session
          );


/*
 *  Private License Functions
 */

private:

    NTSTATUS
    LicenseClient(
          CSession& Session
          );

    NTSTATUS
    CheckExpiration(
          );

    LONG
    CheckInstalledLicenses(
                           DWORD dwWanted
                           );

    VOID
    ReadLicensingParameters(
    );


/*
 *  Global Static Functions for checking license expiration.
 */

    static DWORD
    TimeToSoftExpiration(
    );
    
    static DWORD
    TimeToHardExpiration(
    );
    
    static NTSTATUS
    GetLicenseFromLS(
                     LONG nNum,
                     BOOL fIgnoreCurrentCount,
                     BOOL *pfRetrievedAll
                     );

    static DWORD
    GenerateHwidFromComputerName(
                                 HWID *hwid
                                 );

    static VOID
    TryToAddLicenses(
                     DWORD dwTotalWanted
                     );


    static VOID
    TryToReturnLicenses(
                        DWORD dwWanted
                        );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\lcrpcint.h ===
/*
 *  LCRpcInt.h
 *
 *  Author: BreenH
 *
 *  Internal functions to support the RPC interface.
 */

#ifndef __LC_LCRPCINT_H__
#define __LC_LCRPCINT_H__

/*
 *  Function Prototypes
 */

NTSTATUS
InitializeRpcInterface(
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\lctrace.cpp ===
/*
 *  LCTrace.cpp
 *
 *  Author: BreenH
 *
 *  Tracing code for the licensing core.
 */

#ifdef DBG

/*
 *  Includes
 */

#include "precomp.h"
#include "lctrace.h"
#include "lcreg.h"

/*
 *  Constants
 */

#define LCTRACE_FMT_MSG_SIZE 256

/*
 *  Globals
 */

ULONG g_ulTraceLevel;

/*
 *  Function Prototypes
 */

LPCSTR
TraceLevelString(
    ULONG ulTraceLevel
    );

/*
 *  Function Implementations
 */

VOID
TraceInitialize(
    VOID
    )
{
    DWORD cbSize;
    DWORD dwStatus;
    DWORD dwType;

    g_ulTraceLevel = LCTRACETYPE_NONE;
    cbSize = sizeof(DWORD);

    dwStatus = RegQueryValueEx(
        GetBaseKey(),
        LCREG_TRACEVALUE,
        NULL,
        &dwType,
        (LPBYTE)&g_ulTraceLevel,
        &cbSize
        );

    if (dwStatus == ERROR_SUCCESS)
    {
        ASSERT(cbSize == sizeof(DWORD));
        ASSERT(dwType == REG_DWORD);

        if (g_ulTraceLevel != LCTRACETYPE_NONE)
        {
            DbgPrint("LSCORE: Trace Message: Trace initialized to 0x%x\n", g_ulTraceLevel);
        }
    }
}

VOID __cdecl
TracePrint(
    ULONG ulTraceLevel,
    LPCSTR pFormat,
    ...
    )
{
    int cbPrinted;
    va_list vaList;
    CHAR szFormattedMessage[LCTRACE_FMT_MSG_SIZE];

    if ((ulTraceLevel & g_ulTraceLevel) == 0)
    {
        return;
    }

    va_start(vaList, pFormat);
    cbPrinted = _vsnprintf(szFormattedMessage, LCTRACE_FMT_MSG_SIZE, pFormat, vaList);
    va_end(vaList);

    if (cbPrinted == -1)
    {
        DbgPrint("LSCORE: Trace Message: Next trace message too long.\n");
        szFormattedMessage[LCTRACE_FMT_MSG_SIZE - 1] = (CHAR)NULL;
    }

    DbgPrint("LSCORE: %s: %s\n", TraceLevelString(ulTraceLevel), szFormattedMessage);
}

LPCSTR
TraceLevelString(
    ULONG ulTraceLevel
    )
{
#define TLS_CASE(x) case x: return(#x)

    switch(ulTraceLevel)
    {
        TLS_CASE(LCTRACETYPE_API);
        TLS_CASE(LCTRACETYPE_INFO);
        TLS_CASE(LCTRACETYPE_WARNING);
        TLS_CASE(LCTRACETYPE_ERROR);
        TLS_CASE(LCTRACETYPE_ALL);
        default: return("Trace Level Unknown");
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\lscorep.h ===
/*
 *  LSCoreP.h
 *
 *  Author: BreenH
 *
 *  Internal functions for the core.
 */

#ifndef __LC_LSCOREP_H__
#define __LC_LSCOREP_H__

/*
 *  Function Prototypes
 */

NTSTATUS
AllocatePolicyInformation(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo,
    ULONG ulVersion
    );

VOID
FreePolicyInformation(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    );

ULONG
GetHardcodedPolicyId(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    );

ULONG
GetInitialPolicy(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    );

NTSTATUS
InitializePolicies(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    );

NTSTATUS
SetInitialPolicy(
    ULONG ulPolicyId,
    BOOL fAppCompat
    );

VOID
ShutdownPolicies(
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\lctrace.h ===
/*
 *  LCTrace.h
 *
 *  Author: BreenH
 *
 *  Tracing code for the licensing core.
 */

#ifndef __LC_LCTRACE_H__
#define __LC_LCTRACE_H__

#ifdef DBG

/*
 *  Constants
 */

#define LCTRACETYPE_NONE ((ULONG)(0x0))
#define LCTRACETYPE_API ((ULONG)(0x1))
#define LCTRACETYPE_INFO ((ULONG)(0x2))
#define LCTRACETYPE_WARNING ((ULONG)(0x4))
#define LCTRACETYPE_ERROR ((ULONG)(0x8))
#define LCTRACETYPE_ALL ((ULONG)(0xFFFF))

/*
 *  Function Prototypes
 */

VOID
TraceInitialize(
    VOID
    );

VOID __cdecl
TracePrint(
    ULONG ulTraceLevel,
    LPCSTR pFormat,
    ...
    );

#define TRACEPRINT(x) TracePrint x;

#else

#define TRACEPRINT(x)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\lscore.cpp ===
/*
 *  LSCore.cpp
 *
 *  Author: BreenH
 *
 *  The licensing core.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "lscorep.h"
#include "lcreg.h"
#include "lcrpcint.h"
#include "session.h"
#include "policy.h"
#include "pollist.h"
#include "lctrace.h"
#include "util.h"

/*
 *  Globals
 */

extern "C" BOOL g_fAppCompat;
CRITICAL_SECTION g_PolicyCritSec;
LCINITMODE g_lcInitMode;
CPolicy *g_pCurrentPolicy = NULL;
BOOL g_fInitialized = FALSE;

/*
 *  Initialization Function Implementations
 */

extern "C"
NTSTATUS
LCInitialize(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    )
{
    CPolicy *pPolicy;
    DWORD dwStatus;
    LICENSE_STATUS LsStatus;
    NTSTATUS Status;
    ULONG ulPolicyId;
    ULONG ulAlternatePolicyId = ULONG_MAX;

    Status = RegistryInitialize();

    if (Status == STATUS_SUCCESS)
    {
#if DBG
        TraceInitialize();
#endif

        TRACEPRINT((LCTRACETYPE_API, "LCInitialize: Entered with lcInitMode: %d", lcInitMode));

        Status = RtlInitializeCriticalSection(&g_PolicyCritSec);
    }
    else
    {
        goto errorreginit;
    }

    if (Status == STATUS_SUCCESS)
    {
        dwStatus = TLSInit();
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to RtlInitializeCriticalSection: 0x%x", Status));

        goto errorcritsecalloc;
    }

    if (dwStatus == ERROR_SUCCESS)
    {
        LsStatus = InitializeProtocolLib();
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to TLSInit: %d", dwStatus));

        Status = STATUS_UNSUCCESSFUL;
        goto errortlsinit;
    }

    if ( (lcInitMode == LC_INIT_ALL ) && fAppCompat)
    {
        dwStatus = TLSStartDiscovery();

        if (dwStatus != ERROR_SUCCESS)
        {
            //
            //  This error is not fatal.
            //

            TRACEPRINT((LCTRACETYPE_WARNING, "LCInitialize: Failed to TLSStartDiscovery: %d", dwStatus));
        }
    }

    if (LsStatus == LICENSE_STATUS_OK)
    {
        Status = PolicyListInitialize();
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to InitializeProtocolLib: 0x%x", LsStatus));

        Status = STATUS_UNSUCCESSFUL;
        goto errorprotlib;
    }

    if (Status == STATUS_SUCCESS)
    {
        Status = InitializePolicies(lcInitMode, fAppCompat);
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to PolicyListInitialize: 0x%x", Status));

        goto errorinitpollist;
    }

    if (Status == STATUS_SUCCESS)
    {
        ulPolicyId = GetInitialPolicy(lcInitMode, fAppCompat);
        pPolicy = PolicyListFindById(ulPolicyId);
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to InitializePolicies: 0x%x", Status));

        goto errorinitpol;
    }

    ASSERT(pPolicy != NULL);

    if(pPolicy == NULL)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: pPolicy is NULL"));
        goto errorinitpol;
    }

    Status = pPolicy->CoreActivate(TRUE,&ulAlternatePolicyId);

    if (Status != STATUS_SUCCESS)
    {
        if ((ulAlternatePolicyId != ULONG_MAX)
            && (ulAlternatePolicyId != ulPolicyId))
        {
            TRACEPRINT((LCTRACETYPE_WARNING, "LCInitialize: Trying to activate the alternate policy, ID: %d, Status: 0x%x", ulAlternatePolicyId, Status));

            pPolicy = PolicyListFindById(ulAlternatePolicyId);

            if (NULL != pPolicy)
            {

                Status = pPolicy->CoreActivate(TRUE,NULL);
                
                if (Status == STATUS_SUCCESS)
                {
                    goto foundpolicy;
                }
            }
            else
            {
                TRACEPRINT((LCTRACETYPE_WARNING, "LCInitialize: Alternate policy could not be loaded, ID: %d", ulAlternatePolicyId));
            }

        }

        {
            ULONG ulNewPolicyId;

            TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to activate the initial policy, ID: %d, Status: 0x%x", ulPolicyId, Status));

            ulNewPolicyId = GetHardcodedPolicyId(lcInitMode, fAppCompat);

            if ((ulNewPolicyId != ulPolicyId)
                && (ulNewPolicyId != ulAlternatePolicyId))
            {
                TRACEPRINT((LCTRACETYPE_WARNING, "LCInitialize: Trying to activate the default policy, ID: %d, Status: 0x%x", ulNewPolicyId, Status));

                pPolicy = PolicyListFindById(ulNewPolicyId);

                ASSERT(pPolicy != NULL);

                Status = pPolicy->CoreActivate(TRUE,NULL);
            }
            else
            {
                TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed policy is default policy!"));
            }
        }
    }

    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to activate any policy!"));

        goto erroractpol;
    }

foundpolicy:
    g_pCurrentPolicy = pPolicy;

    if (lcInitMode == LC_INIT_ALL)
    {
        Status = InitializeRpcInterface();

        if (Status != STATUS_SUCCESS)
        {
            TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to InitializeRpcInterface: 0x%x", Status));

            goto errorrpcinit;
        }
    }

    g_lcInitMode = lcInitMode;

    TRACEPRINT((LCTRACETYPE_API, "LCInitialize: Returning success"));

    g_fInitialized = TRUE;

    return(STATUS_SUCCESS);

errorrpcinit:
erroractpol:
    ShutdownPolicies();
errorinitpol:
    ShutdownProtocolLib();
errorinitpollist:
errorprotlib:
    TLSShutdown();
errortlsinit:
    RtlDeleteCriticalSection(&g_PolicyCritSec);
errorcritsecalloc:
errorreginit:
    TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Returning: 0x%x", Status));

    return(Status);
}

// This function should invoke only the most important and required
// destruction code, since we're on a strict time limit on system shutdown.
extern "C"
VOID
LCShutdown(
    )
{
    // Note: this can be called without LCInitialize having been called

    if (g_fInitialized)
    {
        g_fInitialized = FALSE;

        RtlEnterCriticalSection(&g_PolicyCritSec);
    
        if (NULL != g_pCurrentPolicy)
        {
            g_pCurrentPolicy->CoreDeactivate(TRUE);
            g_pCurrentPolicy = NULL;
        }

        ShutdownPolicies();

        RtlLeaveCriticalSection(&g_PolicyCritSec);
    }
}

/*
 *  Policy Activation Function Implementations
 */

extern "C"
NTSTATUS
LCDeactivateCurrentPolicy(
    )
{
    NTSTATUS Status;

    TRACEPRINT((LCTRACETYPE_API, "LCDeactivateCurrentPolicy:"));

    RtlEnterCriticalSection(&g_PolicyCritSec);

    Status = g_pCurrentPolicy->CoreDeactivate(FALSE);

    RtlLeaveCriticalSection(&g_PolicyCritSec);

    return(Status);
}

extern "C"
NTSTATUS
LCSetPolicy(
    ULONG ulPolicyId,
    PNTSTATUS pNewPolicyStatus
    )
{
    CPolicy *pNewPolicy;
    NTSTATUS Status;

    TRACEPRINT((LCTRACETYPE_API, "LCSetPolicy: Entered with ulPolicyId: %d, pNewPolicyStatus: 0x%p", ulPolicyId, pNewPolicyStatus));
    ASSERT(pNewPolicyStatus != NULL);

    *pNewPolicyStatus = STATUS_SUCCESS;

    RtlEnterCriticalSection(&g_PolicyCritSec);

    if (ulPolicyId == g_pCurrentPolicy->GetId())
    {
        Status = STATUS_SUCCESS;
        goto exit;
    }

    pNewPolicy = PolicyListFindById(ulPolicyId);

    if (pNewPolicy == NULL)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto exit;
    }

    *pNewPolicyStatus = pNewPolicy->CoreActivate(FALSE,NULL);

    if (*pNewPolicyStatus == STATUS_SUCCESS)
    {
        Status = SetInitialPolicy(ulPolicyId, g_fAppCompat);

        if (Status == STATUS_SUCCESS)
        {
            g_pCurrentPolicy->CoreDeactivate(FALSE);
            g_pCurrentPolicy = pNewPolicy;
        }
        else
        {
            pNewPolicy->CoreDeactivate(FALSE);
        }
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCSetPolicy: Failed to pNewPolicy->CoreActivate: 0x%x", *pNewPolicyStatus));

        Status = STATUS_UNSUCCESSFUL;
    }

exit:
    RtlLeaveCriticalSection(&g_PolicyCritSec);

    TRACEPRINT((LCTRACETYPE_API, "LCSetPolicy: Returning 0x%x", Status));

    return(Status);
}

/*
 *  Administrative Function Implementations
 */

extern "C"
VOID
LCAssignPolicy(
    PWINSTATION pWinStation
    )
{
    LPLCCONTEXT lpContext;

    ASSERT(pWinStation != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCAssignPolicy: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    ASSERT(lpContext != NULL);
    ASSERT(lpContext->pPolicy == NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCAssignPolicy: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    //
    //  Always enter the context critical section first.
    //

    RtlEnterCriticalSection(&(lpContext->CritSec));

    RtlEnterCriticalSection(&g_PolicyCritSec);

    ASSERT(g_pCurrentPolicy != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCAssignPolicy: Session: %d, Assigning policy: %d", pWinStation->LogonId, g_pCurrentPolicy->GetId()));

    lpContext->pPolicy = g_pCurrentPolicy;
    lpContext->pPolicy->IncrementReference();

    RtlLeaveCriticalSection(&g_PolicyCritSec);

    RtlLeaveCriticalSection(&(lpContext->CritSec));

    TRACEPRINT((LCTRACETYPE_API, "LCAssignPolicy: Session: %d, Returning", pWinStation->LogonId));
}

extern "C"
NTSTATUS
LCCreateContext(
    PWINSTATION pWinStation
    )
{
    LPLCCONTEXT lpContext;
    NTSTATUS Status;

    ASSERT(pWinStation != NULL);
    ASSERT(pWinStation->lpLicenseContext == NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCCreateContext: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)LocalAlloc(LPTR, sizeof(LCCONTEXT));

    if (lpContext != NULL)
    {
        Status = RtlInitializeCriticalSection(&(lpContext->CritSec));

        if (Status == STATUS_SUCCESS)
        {
            TRACEPRINT((LCTRACETYPE_INFO, "LCCreateContext: Session: %d, Context initialized", pWinStation->LogonId));

            pWinStation->lpLicenseContext = (LPARAM)lpContext;
        }
        else
        {
            TRACEPRINT((LCTRACETYPE_ERROR, "LCCreateContext: Session: %d, Failed RtlInitializeCriticalSection: 0x%x", pWinStation->LogonId, Status));

            LocalFree(lpContext);
        }
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCCreateContext: Session: %d, Failed lpContext allocation", pWinStation->LogonId));

        Status = STATUS_NO_MEMORY;
    }

    TRACEPRINT((LCTRACETYPE_API, "LCCreateContext: Session: %d, Returning 0x%x", pWinStation->LogonId, Status));

    return(Status);
}

extern "C"
VOID
LCDestroyContext(
    PWINSTATION pWinStation
    )
{
    LPLCCONTEXT lpContext;

    ASSERT(pWinStation != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCDestroyContext: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    if (lpContext != NULL)
    {
        TRACEPRINT((LCTRACETYPE_INFO, "LCDestroyContext: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

        //
        //  Idle winstations may not have a policy assigned.
        //

        if (lpContext->pPolicy != NULL)
        {
            TRACEPRINT((LCTRACETYPE_INFO, "LCDestroyContext: Session: %d, Policy: %d", pWinStation->LogonId, lpContext->pPolicy->GetId()));

            if (lpContext->lPrivate != NULL)
            {
                lpContext->pPolicy->DestroyPrivateContext(lpContext);
            }

            RtlEnterCriticalSection(&g_PolicyCritSec);

            lpContext->pPolicy->DecrementReference();

            RtlLeaveCriticalSection(&g_PolicyCritSec);

            lpContext->pPolicy = NULL;
        }
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_INFO, "LCDestroyContext: Session: %d, lpContext is NULL", pWinStation->LogonId));

        goto exit;
    }

    //
    //  The lPrivate member should have been freed and set to NULL by the
    //  policy during the DestroyPrivateContext call.
    //

    ASSERT(lpContext->lPrivate == NULL);

    if (lpContext->hProtocolLibContext != NULL)
    {
        DeleteProtocolContext(lpContext->hProtocolLibContext);
    }


    if (lpContext->fLlsLicense)
    {
        NtLSFreeHandle(lpContext->hLlsLicense);
    }

    RtlDeleteCriticalSection(&(lpContext->CritSec));

#if DBG
    RtlFillMemory(lpContext, sizeof(LCCONTEXT), (BYTE)0xFE);
#endif

    LocalFree(lpContext);

    pWinStation->lpLicenseContext = (LPARAM)NULL;

exit:
    TRACEPRINT((LCTRACETYPE_API, "LCDestroyContext: Session: %d, Returning", pWinStation->LogonId));
}

extern "C"
NTSTATUS
LCGetAvailablePolicyIds(
    PULONG *ppulPolicyIds,
    PULONG pcPolicies
    )
{
    NTSTATUS Status;

    TRACEPRINT((LCTRACETYPE_API, "LCGetAvailablePolicyIds: Entered with ppulPolicyIds: 0x%p, pcPolicies: 0x%p", ppulPolicyIds, pcPolicies));
    ASSERT(ppulPolicyIds != NULL);
    ASSERT(pcPolicies != NULL);

    RtlEnterCriticalSection(&g_PolicyCritSec);

    Status = PolicyListEnumerateIds(ppulPolicyIds, pcPolicies);

    RtlLeaveCriticalSection(&g_PolicyCritSec);

    TRACEPRINT((LCTRACETYPE_API, "LCGetAvailablePolicyIds: Returning 0x%x", Status));

    return(Status);
}

extern "C"
ULONG
LCGetPolicy(
    VOID
    )
{
    ULONG ulPolicyId;

    TRACEPRINT((LCTRACETYPE_API, "LCGetPolicy: Entered"));
    ASSERT(g_pCurrentPolicy != NULL);

    RtlEnterCriticalSection(&g_PolicyCritSec);

    ulPolicyId = g_pCurrentPolicy->GetId();

    RtlLeaveCriticalSection(&g_PolicyCritSec);

    TRACEPRINT((LCTRACETYPE_API, "LCGetPolicy: Returning %d", ulPolicyId));

    return(ulPolicyId);
}

extern "C"
NTSTATUS
LCGetPolicyInformation(
    ULONG ulPolicyId,
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    )
{
    CPolicy *pPolicy;
    NTSTATUS Status;

    TRACEPRINT((LCTRACETYPE_API, "LCGetPolicyInformation: Entered with ulPolicyId: %d, lpPolicyInfo: 0x%p", ulPolicyId, lpPolicyInfo));
    ASSERT(lpPolicyInfo != NULL);

    RtlEnterCriticalSection(&g_PolicyCritSec);

    pPolicy = PolicyListFindById(ulPolicyId);

    if (pPolicy != NULL)
    {
        Status = pPolicy->GetInformation(lpPolicyInfo);
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
    }

    RtlLeaveCriticalSection(&g_PolicyCritSec);

    TRACEPRINT((LCTRACETYPE_API, "LCGetPolicyInformation: Returning 0x%x", Status));

    return(Status);
}

/*
 *  Licensing Event Function Implementations
 */

extern "C"
NTSTATUS
LCProcessConnectionProtocol(
    PWINSTATION pWinStation
    )
{
    CSession Session(pWinStation);
    LICENSE_CAPABILITIES lcCap;
    LICENSE_STATUS LsStatus;
    LPLCCONTEXT lpContext;
    NTSTATUS Status;
    ULONG cbReturned;
    WCHAR szClientName[CLIENTNAME_LENGTH + 1];
    UINT32 dwClientError;

    ASSERT(pWinStation != NULL);

    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionProtocol: Entered with Session: %d", pWinStation->LogonId));
    TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionProtocol: Session: %d, Current Policy ID: 0x%x", pWinStation->LogonId, g_pCurrentPolicy->GetId()));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    ASSERT(lpContext != NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionProtocol: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    RtlEnterCriticalSection(&(lpContext->CritSec));

    //
    //  Get the client capabilities.
    //

    ZeroMemory(&lcCap, sizeof(LICENSE_CAPABILITIES));
    lcCap.pbClientName = (LPBYTE)szClientName;
    lcCap.cbClientName = sizeof(szClientName);

    Status = _IcaStackIoControl(
        pWinStation->hStack,
        IOCTL_ICA_STACK_QUERY_LICENSE_CAPABILITIES,
        NULL,
        0,
        &lcCap,
        sizeof(LICENSE_CAPABILITIES),
        &cbReturned
        );

    if (Status == STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionProtocol: Session: %d, Queried license capabilities", pWinStation->LogonId));

        //
        //  Save the protocol version for later use.
        //

        lpContext->ulClientProtocolVersion = lcCap.ProtocolVer;
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionProtocol: Session: %d, Failed to query license capabilities: 0x%x", pWinStation->LogonId, Status));

        dwClientError = NtStatusToClientError(Status);

        goto error;
    }

    //
    //  Create the protocol library context.
    //

    LsStatus = CreateProtocolContext(&lcCap, &(lpContext->hProtocolLibContext));

    if (LsStatus == LICENSE_STATUS_OK)
    {
        TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionProtocol: Session: %d, Created protocol context", pWinStation->LogonId));

        //
        //  Pass the call to the policy assigned to the connection.
        //

        Status = lpContext->pPolicy->Connect(Session, dwClientError);
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionProtocol: Session: %d, Failed to CreateProtocolContext: 0x%x", pWinStation->LogonId, LsStatus));

        dwClientError = LsStatusToClientError(LsStatus);

        Status = LsStatusToNtStatus(LsStatus);
    }

#if DBG
    if (Status == STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionProtocol: Session: %d, Succeeded pPolicy->Protocol", pWinStation->LogonId));
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionProtocol: Session: %d, Failed pPolicy->Protocol: 0x%x", pWinStation->LogonId, Status));
    }
#endif

error:
    RtlLeaveCriticalSection(&(lpContext->CritSec));

    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionProtocol: Session: %d, Reporting: 0x%x", pWinStation->LogonId, dwClientError));

        Session.SetErrorInfo(dwClientError);

    }

    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionProtocol: Session: %d, Returning: 0x%x", pWinStation->LogonId, Status));

    return(Status);
}

extern "C"
NTSTATUS
LCProcessConnectionPostLogon(
    PWINSTATION pWinStation
    )
{
    CSession Session(pWinStation);
    LPLCCONTEXT lpContext;
    NTSTATUS Status;

    ASSERT(pWinStation != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionPostLogon: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    ASSERT(lpContext != NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionPostLogon: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    RtlEnterCriticalSection(&(lpContext->CritSec));

    //
    //  Pass the call to the policy assigned to the connection.
    //

    Status = lpContext->pPolicy->Logon(Session);

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionPostLogon: Session: %d, Failed to pPolicy->Logon: 0x%x", pWinStation->LogonId, Status));
    }

#endif

    RtlLeaveCriticalSection(&(lpContext->CritSec));

    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionPostLogon: Session: %d, Returning: 0x%x", pWinStation->LogonId, Status));

    return(Status);
}

extern "C"
NTSTATUS
LCProcessConnectionDisconnect(
    PWINSTATION pWinStation
    )
{
    CSession Session(pWinStation);
    LPLCCONTEXT lpContext;
    NTSTATUS Status;

    ASSERT(pWinStation != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionDisconnect: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    //
    //  Console licensing is not yet supported.
    //

    ASSERT(lpContext != NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionDisconnect: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    RtlEnterCriticalSection(&(lpContext->CritSec));

    //
    //  Pass the call to the policy assigned to the connection.
    //

    Status = lpContext->pPolicy->Disconnect(Session);

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionDisconnect: Session: %d, Failed to pPolicy->Disconnect: 0x%x", pWinStation->LogonId, Status));
    }

#endif

    RtlLeaveCriticalSection(&(lpContext->CritSec));

    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionDisconnect: Session: %d, Returning: 0x%x", pWinStation->LogonId, Status));

    return(Status);
}

extern "C"
NTSTATUS
LCProcessConnectionReconnect(
    PWINSTATION pWinStation,
    PWINSTATION pTemporaryWinStation
    )
{
    CSession Session(pWinStation);
    CSession TemporarySession(pTemporaryWinStation);
    LPLCCONTEXT lpContext;
    NTSTATUS Status;

    ASSERT(pWinStation != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionReconnect: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    ASSERT(lpContext != NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionReconnect: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    RtlEnterCriticalSection(&(lpContext->CritSec));

    //
    //  Pass the call to the policy assigned to the connection.
    //

    Status = lpContext->pPolicy->Reconnect(Session, TemporarySession);

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionReconnect: Session: %d, Failed to pPolicy->Reconnect: 0x%x", pWinStation->LogonId, Status));
    }

#endif

    RtlLeaveCriticalSection(&(lpContext->CritSec));

    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionReconnect: Session: %d, Returning: 0x%x", pWinStation->LogonId, Status));

    return(Status);
}

extern "C"
NTSTATUS
LCProcessConnectionLogoff(
    PWINSTATION pWinStation
    )
{
    CSession Session(pWinStation);
    LPLCCONTEXT lpContext;
    NTSTATUS Status;

    ASSERT(pWinStation != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionLogoff: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    ASSERT(lpContext != NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionLogoff: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    RtlEnterCriticalSection(&(lpContext->CritSec));

    //
    //  Pass the call to the policy assigned to the connection.
    //

    Status = lpContext->pPolicy->Logoff(Session);

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionLogoff: Session: %d, Failed to pPolicy->Reconnect: 0x%x", pWinStation->LogonId, Status));
    }

#endif

    RtlLeaveCriticalSection(&(lpContext->CritSec));

    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionLogoff: Session: %d, Returning: 0x%x", pWinStation->LogonId, Status));

    return(Status);
}

extern "C"
NTSTATUS
LCProvideAutoLogonCredentials(
    PWINSTATION pWinStation,
    LPBOOL lpfUseCredentials,
    LPLCCREDENTIALS lpCredentials
    )
{
    CSession Session(pWinStation);
    LPLCCONTEXT lpContext;
    NTSTATUS Status;

    ASSERT(pWinStation != NULL);
    ASSERT(lpfUseCredentials != NULL);
    ASSERT(lpCredentials != NULL);
    ASSERT(lpCredentials->pUserName == NULL);
    ASSERT(lpCredentials->pDomain == NULL);
    ASSERT(lpCredentials->pPassword == NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCProvideAutoLogonCredentials: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    ASSERT(lpContext != NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCProvideAutoLogonCredentials: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    RtlEnterCriticalSection(&(lpContext->CritSec));

    //
    //  Pass the call to the policy assigned to the connection.
    //

    Status = lpContext->pPolicy->AutoLogon(Session, lpfUseCredentials, lpCredentials);

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProvideAutoLogonCredentials: Session: %d, Failed to pPolicy->AutoLogon: 0x%x", pWinStation->LogonId, Status));
    }
#endif

    RtlLeaveCriticalSection(&(lpContext->CritSec));

    TRACEPRINT((LCTRACETYPE_API, "LCProvideAutoLogonCredentials: Session: %d, Returning: 0x%x", pWinStation->LogonId, Status));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\lscore.h ===
/*
 *  LSCore.h
 *
 *  Author: BreenH
 *
 *  API for the licensing core.
 */

#ifndef __LC_LSCORE_H__
#define __LC_LSCORE_H__

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  Typedefs
 */

typedef enum {
    LC_INIT_LIMITED = 0,
    LC_INIT_ALL
} LCINITMODE, *LPLCINITMODE;

typedef struct {
    LPWSTR pUserName;
    LPWSTR pDomain;
    LPWSTR pPassword;
} LCCREDENTIALS, *LPLCCREDENTIALS;

/*
 *  Initialization Function Prototypes
 */

NTSTATUS
LCInitialize(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    );

VOID
LCShutdown(
    );

/*
 *  Policy Activation Function Prototypes
 */


NTSTATUS
LCSetPolicy(
    ULONG ulPolicyId,
    PNTSTATUS pNewPolicyStatus
    );

/*
 *  Administrative Function Prototypes
 */

VOID
LCAssignPolicy(
    PWINSTATION pWinStation
    );

NTSTATUS
LCCreateContext(
    PWINSTATION pWinStation
    );

VOID
LCDestroyContext(
    PWINSTATION pWinStation
    );

NTSTATUS
LCGetAvailablePolicyIds(
    PULONG *ppulPolicyIds,
    PULONG pcPolicies
    );

ULONG
LCGetPolicy(
    VOID
    );

NTSTATUS
LCGetPolicyInformation(
    ULONG ulPolicyId,
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    );

/*
 *  Licensing Event Function Prototypes
 */

NTSTATUS
LCProcessConnectionProtocol(
    PWINSTATION pWinStation
    );

NTSTATUS
LCProcessConnectionPostLogon(
    PWINSTATION pWinStation
    );

NTSTATUS
LCProcessConnectionDisconnect(
    PWINSTATION pWinStation
    );

NTSTATUS
LCProcessConnectionReconnect(
    PWINSTATION pWinStation,
    PWINSTATION pTemporaryWinStation
    );

NTSTATUS
LCProcessConnectionLogoff(
    PWINSTATION pWinStation
    );

NTSTATUS
LCProvideAutoLogonCredentials(
    PWINSTATION pWinStation,
    LPBOOL lpfUseCredentials,
    LPLCCREDENTIALS lpCredentials
    );

NTSTATUS
LCDeactivateCurrentPolicy(
    );

#ifdef __cplusplus
}   // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\lscorep.cpp ===
/*
 *  LSCoreP.cpp
 *
 *  Author: BreenH
 *
 *  Internal functions for the core.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "lscorep.h"
#include "lcreg.h"
#include "lctrace.h"
#include "session.h"
#include "policy.h"
#include "pollist.h"
#include "perseat.h"
#include "peruser.h"
#include "pts.h"
#include "ra.h"
#include <icaevent.h>

/*
 *  Internal Function Prototypes
 */

ULONG
InitializeBuiltinPolicies(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    );

ULONG
InitializeExternalPolicies(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    );

/*
 *  Function Implementations
 */

NTSTATUS
AllocatePolicyInformation(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo,
    ULONG ulVersion
    )
{
    NTSTATUS Status;

    ASSERT(ppPolicyInfo != NULL);

    if (ulVersion == LCPOLICYINFOTYPE_V1)
    {
        *ppPolicyInfo = (LPLCPOLICYINFOGENERIC)LocalAlloc(LPTR, sizeof(LCPOLICYINFO_V1));

        if (*ppPolicyInfo != NULL)
        {
            (*ppPolicyInfo)->ulVersion = LCPOLICYINFOTYPE_V1;
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }
    else
    {
        Status = STATUS_REVISION_MISMATCH;
    }

    return(Status);
}

VOID
FreePolicyInformation(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    )
{
    ASSERT(ppPolicyInfo != NULL);
    ASSERT(*ppPolicyInfo != NULL);
    ASSERT((*ppPolicyInfo)->ulVersion <= LCPOLICYINFOTYPE_CURRENT);

    if ((*ppPolicyInfo)->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        LPLCPOLICYINFO_V1 pPolicyInfoV1 = (LPLCPOLICYINFO_V1)(*ppPolicyInfo);

        ASSERT(pPolicyInfoV1->lpPolicyName != NULL);
        ASSERT(pPolicyInfoV1->lpPolicyDescription != NULL);

        LocalFree(pPolicyInfoV1->lpPolicyName);
        LocalFree(pPolicyInfoV1->lpPolicyDescription);
        LocalFree(pPolicyInfoV1);
        *ppPolicyInfo = NULL;
    }
}

ULONG
GetHardcodedPolicyId(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    )
{
    //
    //  WARNING: HARDCODED VALUES:
    //
    //  This function will return the ID of the default policy to activate upon
    //  system boot. It will return the ID for Remote Admin or Per Seat based
    //  on fAppCompat, or PTS, based on lcInitMode. Theoretically, the core
    //  should not know these ID values, but it is necessary in this case.
    //

    return(lcInitMode == LC_INIT_LIMITED ? 0 : (fAppCompat ? 2 : 1));
}

ULONG
GetInitialPolicy(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    )
{
    ULONG ulPolicyId;

    if (lcInitMode == LC_INIT_ALL)
    {
        DWORD cbSize;
        DWORD dwStatus;
        DWORD dwType;

        cbSize = sizeof(ULONG);

        //
        //  Query the value for the current App Compat mode.
        //

        dwStatus = RegQueryValueEx(
            GetBaseKey(),
            fAppCompat ? LCREG_ACONMODE : LCREG_ACOFFMODE,
            NULL,
            &dwType,
            (LPBYTE)&ulPolicyId,
            &cbSize
            );

        //
        //  Make sure that the data type is good.
        //

        if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD))
        {
            BOOL fLimitedInit;
            BOOL fRequireAC;
            CPolicy *pPolicy;

            //
            // Internet Connector is no longer supported; switch to Per User.
            //
            if (3 == ulPolicyId)
            {                
                ulPolicyId = 4;                
                SetInitialPolicy(ulPolicyId,fAppCompat);

                LicenseLogEvent(EVENTLOG_ERROR_TYPE,
                                EVENT_LICENSING_IC_TO_PER_USER,
                                0,
                                NULL );            
            }

            //
            //  Make sure that the policy specified actually exists, and
            //  that it matches the settings.
            //

            pPolicy = PolicyListFindById(ulPolicyId);

            if (NULL != pPolicy)
            {
                fLimitedInit = pPolicy->GetFlags() & LC_FLAG_LIMITED_INIT_ONLY;
                fRequireAC = pPolicy->GetFlags() & LC_FLAG_REQUIRE_APP_COMPAT;

                if (!fLimitedInit)
                {
                    if ((fRequireAC && fAppCompat) || (!fRequireAC && !fAppCompat))
                    {
                        goto exit;
                    }
                }
            }
        }
    }

    //
    //  For LC_INIT_LIMITED or for failure from above, get the hardcoded
    //  value.
    //

    ulPolicyId = GetHardcodedPolicyId(lcInitMode, fAppCompat);

exit:
    return(ulPolicyId);
}

NTSTATUS
InitializePolicies(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    )
{
    ULONG cLoadedPolicies;

    cLoadedPolicies = InitializeBuiltinPolicies(lcInitMode, fAppCompat);
    cLoadedPolicies += InitializeExternalPolicies(lcInitMode, fAppCompat);

    return(cLoadedPolicies > 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}

NTSTATUS
SetInitialPolicy(
    ULONG ulPolicyId,
    BOOL fAppCompat
    )
{
    DWORD cbSize;
    DWORD dwStatus;

    //
    //  Set the value based on the app compat mode.
    //

    cbSize = sizeof(ULONG);

    dwStatus = RegSetValueEx(
        GetBaseKey(),
        fAppCompat ? LCREG_ACONMODE : LCREG_ACOFFMODE,
        NULL,
        REG_DWORD,
        (LPBYTE)&ulPolicyId,
        cbSize
        );

    return(dwStatus == ERROR_SUCCESS ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}

VOID
ShutdownPolicies(
    )
{
    CPolicy *pPolicy;

    while ((pPolicy = PolicyListPop()) != NULL)
    {
        pPolicy->CoreUnload();

        delete pPolicy;
    }
}

/*
 *  Internal Function Implementations
 */

ULONG
InitializeBuiltinPolicies(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    )
{
    CPolicy *ppPolicy[3];
    NTSTATUS Status;
    ULONG cLoadedPolicies = 0;
    ULONG cPolicyArray;
    ULONG i;

    cPolicyArray = (lcInitMode == LC_INIT_LIMITED ? 1 : (fAppCompat ? 2 : 1));

    //
    //  WARNING: HARDCODED POLICY NAMES (and flags, as this will
    //  only load policies that will work in the current environment, even
    //  though the core shouldn't know this)
    //

    if (lcInitMode == LC_INIT_ALL)
    {
        if (fAppCompat)
        {
            ppPolicy[0] = new CPerSeatPolicy();
            ppPolicy[1] = new CPerUserPolicy();
        }
        else
        {
            ppPolicy[0] = new CRAPolicy();
        }
    }
    else
    {
        ppPolicy[0] = new CPtsPolicy();
    }

    for (i = 0; i < cPolicyArray; i++)
    {
        if (ppPolicy[i] != NULL)
        {
            Status = ppPolicy[i]->CoreLoad(LC_VERSION_CURRENT);

            if (Status == STATUS_SUCCESS)
            {
                Status = PolicyListAdd(ppPolicy[i]);

                if (Status == STATUS_SUCCESS)
                {
                    cLoadedPolicies++;
                    continue;
                }
            }

            delete ppPolicy[i];
            ppPolicy[i] = NULL;
        }
    }

    return(cLoadedPolicies);
}

ULONG
InitializeExternalPolicies(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    )
{
    DBG_UNREFERENCED_PARAMETER(lcInitMode);
    DBG_UNREFERENCED_PARAMETER(fAppCompat);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\perseat.h ===
/*
 *  PerSeat.h
 *
 *  Author: BreenH
 *
 *  The Per-Seat licensing policy.
 */

#ifndef __LC_PERSEAT_H__
#define __LC_PERSEAT_H__

/*
 *  Includes
 */

#include "policy.h"

/*
 *  Constants
 */

#define LC_POLICY_PS_DEFAULT_LICENSE_SIZE 8192

/*
 *  Class Definition
 */

class CPerSeatPolicy : public CPolicy
{
private:

/*
 *  Licensing Functions
 */
NTSTATUS
MarkLicense(
    CSession& Session
    );

public:

/*
 *  Creation Functions
 */

CPerSeatPolicy(
    );

~CPerSeatPolicy(
    );

/*
 *  Administrative Functions
 */

ULONG
GetFlags(
    );

ULONG
GetId(
    );

NTSTATUS
GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    );

/*
 *  Loading and Activation Functions
 */

NTSTATUS
Activate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    );

NTSTATUS
Deactivate(
    BOOL fShutdown
    );

/*
 *  Licensing Functions
 */

NTSTATUS
Connect(
    CSession& pSession,
    UINT32 &dwClientError
    );

NTSTATUS
Logon(
    CSession& Session
    );


NTSTATUS
Reconnect(
    CSession& Session,
    CSession& TemporarySession
    );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\perseat.cpp ===
/*
 *  PerSeat.cpp
 *
 *  Author: BreenH
 *
 *  The Per-Seat licensing policy.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "perseat.h"
#include "lctrace.h"
#include "util.h"
#include <tserrs.h>

#define ISSUE_LICENSE_WARNING_PERIOD    15      // days to expiration when warning should be issued

// Size of strings to be displayed to user
#define MAX_MESSAGE_SIZE    512
#define MAX_TITLE_SIZE      256

/*
 *  extern globals
 */
extern "C"
extern HANDLE hModuleWin;

/*
 *  Class Implementation
 */

/*
 *  Creation Functions
 */

CPerSeatPolicy::CPerSeatPolicy(
    ) : CPolicy()
{
}

CPerSeatPolicy::~CPerSeatPolicy(
    )
{
}

/*
 *  Administrative Functions
 */

ULONG
CPerSeatPolicy::GetFlags(
    )
{
    return(LC_FLAG_INTERNAL_POLICY | LC_FLAG_REQUIRE_APP_COMPAT);
}

ULONG
CPerSeatPolicy::GetId(
    )
{
    return(2);
}

NTSTATUS
CPerSeatPolicy::GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    )
{
    NTSTATUS Status;

    ASSERT(lpPolicyInfo != NULL);

    if (lpPolicyInfo->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        int retVal;
        LPLCPOLICYINFO_V1 lpPolicyInfoV1 = (LPLCPOLICYINFO_V1)lpPolicyInfo;
        LPWSTR pName;
        LPWSTR pDescription;

        ASSERT(lpPolicyInfoV1->lpPolicyName == NULL);
        ASSERT(lpPolicyInfoV1->lpPolicyDescription == NULL);

        //
        //  The strings loaded in this fashion are READ-ONLY. They are also
        //  NOT NULL terminated. Allocate and zero out a buffer, then copy the
        //  string over.
        //

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_PERSEAT_NAME,
            (LPWSTR)(&pName),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyName = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyName != NULL)
            {
                lstrcpynW(lpPolicyInfoV1->lpPolicyName, pName, retVal + 1);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_PERSEAT_DESC,
            (LPWSTR)(&pDescription),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyDescription = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyDescription != NULL)
            {
                lstrcpynW(lpPolicyInfoV1->lpPolicyDescription, pDescription, retVal + 1);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        Status = STATUS_SUCCESS;
        goto exit;

V1error:

        //
        //  An error occurred loading/copying the strings.
        //

        if (lpPolicyInfoV1->lpPolicyName != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyName);
            lpPolicyInfoV1->lpPolicyName = NULL;
        }

        if (lpPolicyInfoV1->lpPolicyDescription != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyDescription);
            lpPolicyInfoV1->lpPolicyDescription = NULL;
        }
    }
    else
    {
        Status = STATUS_REVISION_MISMATCH;
    }

exit:
    return(Status);
}

/*
 *  Loading and Activation Functions
 */

NTSTATUS
CPerSeatPolicy::Activate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    )
{
    UNREFERENCED_PARAMETER(fStartup);

    if (NULL != pulAlternatePolicy)
    {
        // don't set an explicit alternate policy

        *pulAlternatePolicy = ULONG_MAX;
    }

    return(StartCheckingGracePeriod());
}

NTSTATUS
CPerSeatPolicy::Deactivate(
    BOOL fShutdown
    )
{
    if (!fShutdown)
    {
        return(StopCheckingGracePeriod());
    }
    else
    {
        return STATUS_SUCCESS;
    }
}

/*
 *  Licensing Functions
 */

NTSTATUS
CPerSeatPolicy::Connect(
    CSession& Session,
    UINT32 &dwClientError
    )
{
    LICENSE_STATUS LsStatus = LICENSE_STATUS_OK;
    LPBYTE lpReplyBuffer;
    LPBYTE lpRequestBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cbReplyBuffer;
    ULONG cbRequestBuffer;
    ULONG cbReturned;
    BOOL fExtendedError = FALSE;

    //
    // Check for client redirected to session 0
    //

    if (Session.IsSessionZero())
    {
        // Allow client to connect unlicensed

        return CPolicy::Connect(Session,dwClientError);
    }

    lpRequestBuffer = NULL;
    lpReplyBuffer = (LPBYTE)LocalAlloc(LPTR, LC_POLICY_PS_DEFAULT_LICENSE_SIZE);

    if (lpReplyBuffer != NULL)
    {
        cbReplyBuffer = LC_POLICY_PS_DEFAULT_LICENSE_SIZE;
    }
    else
    {
        Status = STATUS_NO_MEMORY;
        goto errorexit;
    }

    LsStatus = AcceptProtocolContext(
        Session.GetLicenseContext()->hProtocolLibContext,
        0,
        NULL,
        &cbRequestBuffer,
        &lpRequestBuffer,
        &fExtendedError
        );

    while(LsStatus == LICENSE_STATUS_CONTINUE)
    {
        cbReturned = 0;

        ASSERT(cbRequestBuffer > 0);

        Status = _IcaStackIoControl(
            Session.GetIcaStack(),
            IOCTL_ICA_STACK_REQUEST_CLIENT_LICENSE,
            lpRequestBuffer,
            cbRequestBuffer,
            lpReplyBuffer,
            cbReplyBuffer,
            &cbReturned
            );

        if (Status != STATUS_SUCCESS)
        {
            if (Status == STATUS_BUFFER_TOO_SMALL)
            {
                TRACEPRINT((LCTRACETYPE_WARNING, "CPerSeatPolicy::Connect: Reallocating license buffer: %lu, %lu", cbReplyBuffer, cbReturned));

                LocalFree(lpReplyBuffer);
                lpReplyBuffer = (LPBYTE)LocalAlloc(LPTR, cbReturned);

                if (lpReplyBuffer != NULL)
                {
                    cbReplyBuffer = cbReturned;
                }
                else
                {
                    Status = STATUS_NO_MEMORY;
                    goto errorexit;
                }

                Status = _IcaStackIoControl(
                    Session.GetIcaStack(),
                    IOCTL_ICA_STACK_GET_LICENSE_DATA,
                    NULL,
                    0,
                    lpReplyBuffer,
                    cbReplyBuffer,
                    &cbReturned
                    );

                if (Status != STATUS_SUCCESS)
                {
                    goto errorexit;
                }
            }
            else
            {
                goto errorexit;
            }
        }

        if (cbReturned != 0)
        {
            if (lpRequestBuffer != NULL)
            {
                LocalFree(lpRequestBuffer);
                lpRequestBuffer = NULL;
                cbRequestBuffer = 0;
            }

            LsStatus = AcceptProtocolContext(
                Session.GetLicenseContext()->hProtocolLibContext,
                cbReturned,
                lpReplyBuffer,
                &cbRequestBuffer,
                &lpRequestBuffer,
                &fExtendedError
                );
        }
    }

    cbReturned = 0;

    if ((LsStatus == LICENSE_STATUS_ISSUED_LICENSE) || (LsStatus == LICENSE_STATUS_OK))
    {
        Status = _IcaStackIoControl(
            Session.GetIcaStack(),
            IOCTL_ICA_STACK_SEND_CLIENT_LICENSE,
            lpRequestBuffer,
            cbRequestBuffer,
            NULL,
            0,
            &cbReturned
            );

        if (Status == STATUS_SUCCESS)
        {
            ULONG ulLicenseResult;

            ulLicenseResult = LICENSE_PROTOCOL_SUCCESS;

            Status = _IcaStackIoControl(
                Session.GetIcaStack(),
                IOCTL_ICA_STACK_LICENSE_PROTOCOL_COMPLETE,
                &ulLicenseResult,
                sizeof(ULONG),
                NULL,
                0,
                &cbReturned
                );
        }
    }
    else if (LsStatus != LICENSE_STATUS_SERVER_ABORT)
    {
        DWORD dwClientResponse;
        LICENSE_STATUS LsStatusT;
        UINT32 uiExtendedErrorInfo = TS_ERRINFO_NOERROR;

        if (AllowLicensingGracePeriodConnection())
        {
            dwClientResponse = LICENSE_RESPONSE_VALID_CLIENT;
        }
        else
        {
            dwClientResponse = LICENSE_RESPONSE_INVALID_CLIENT;
            uiExtendedErrorInfo = LsStatusToClientError(LsStatus);
        }

        if (lpRequestBuffer != NULL)
        {
            LocalFree(lpRequestBuffer);
            lpRequestBuffer = NULL;
            cbRequestBuffer = 0;
        }

        LsStatusT = ConstructProtocolResponse(
            Session.GetLicenseContext()->hProtocolLibContext,
            dwClientResponse,
            uiExtendedErrorInfo,
            &cbRequestBuffer,
            &lpRequestBuffer,
            fExtendedError
            );

        if (LsStatusT == LICENSE_STATUS_OK)
        {
            Status = _IcaStackIoControl(
                Session.GetIcaStack(),
                IOCTL_ICA_STACK_SEND_CLIENT_LICENSE,
                lpRequestBuffer,
                cbRequestBuffer,
                NULL,
                0,
                &cbReturned
                );
        }
        else
        {
            Status = STATUS_CTX_LICENSE_CLIENT_INVALID;
            goto errorexit;
        }

        if (Status == STATUS_SUCCESS)
        {
            if (dwClientResponse == LICENSE_RESPONSE_VALID_CLIENT)
            {
                ULONG ulLicenseResult;

                //
                //  Grace period allowed client to connect
                //  Tell the stack that the licensing protocol has completed
                //

                ulLicenseResult = LICENSE_PROTOCOL_SUCCESS;

                Status = _IcaStackIoControl(
                     Session.GetIcaStack(),
                     IOCTL_ICA_STACK_LICENSE_PROTOCOL_COMPLETE,
                     &ulLicenseResult,
                     sizeof(ULONG),
                     NULL,
                     0,
                     &cbReturned
                     );            
            }
            else
            {
                //
                //  If all IO works correctly, adjust the status to reflect
                //  that the connection attempt is failing.
                //

                Status = STATUS_CTX_LICENSE_CLIENT_INVALID;
            }
        }
    }
    else
    {       
        TRACEPRINT((LCTRACETYPE_ERROR, "Connect: LsStatus: %d", LsStatus));
        Status = STATUS_CTX_LICENSE_CLIENT_INVALID;
    }

errorexit:
    if (Status != STATUS_SUCCESS)
    {
        if ((LsStatus != LICENSE_STATUS_OK) && (LsStatus != LICENSE_STATUS_CONTINUE))
        {
            dwClientError = LsStatusToClientError(LsStatus);
        }
        else
        {
            dwClientError = NtStatusToClientError(Status);
        }
    }

    if (lpRequestBuffer != NULL)
    {
        LocalFree(lpRequestBuffer);
    }

    if (lpReplyBuffer != NULL)
    {
        LocalFree(lpReplyBuffer);
    }

    return(Status);
}

NTSTATUS
CPerSeatPolicy::MarkLicense(
                            CSession& Session
    )
{
    LICENSE_STATUS Status;

    Status = MarkLicenseFlags(
                   Session.GetLicenseContext()->hProtocolLibContext,
                   MARK_FLAG_USER_AUTHENTICATED);

    return (Status == LICENSE_STATUS_OK
            ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}

NTSTATUS
CPerSeatPolicy::Logon(
    CSession& Session
    )
{
    NTSTATUS Status;
    PTCHAR
        ptszMsgText = NULL, 
        ptszMsgTitle = NULL; 


    if (!Session.IsSessionZero()
        && !Session.IsUserHelpAssistant())
    {
        Status = GetLlsLicense(Session);
    }
    else
    {
        Status = STATUS_SUCCESS;
        goto done;
    }

    if (Status != STATUS_SUCCESS)
    {
        // TODO: put up new error message - can't logon
        // also useful when we do post-logon licensing
        //
        // NB: eventually this should be done through client-side
        // error reporting
    }
    else
    {
        ULONG_PTR
            dwDaysLeftPtr;
        DWORD
            dwDaysLeft,
            cchMsgText;
        BOOL
            fTemporary;
        LICENSE_STATUS
            LsStatus;
        int
            ret,
            cchMsgTitle;
        WINSTATION_APIMSG
            WMsg;

        //
        // Allocate memory
        //
        ptszMsgText = (PTCHAR) LocalAlloc(LPTR, MAX_MESSAGE_SIZE * sizeof(TCHAR));
        if (NULL == ptszMsgText) {
            Status = STATUS_NO_MEMORY;
            goto done;
        }

        ptszMsgTitle = (PTCHAR) LocalAlloc(LPTR, MAX_TITLE_SIZE * sizeof(TCHAR));
        if (NULL == ptszMsgTitle) {
            Status = STATUS_NO_MEMORY;
            goto done;
        }

        ptszMsgText[0] = L'\0'; 
        ptszMsgTitle[0] = L'\0';
        
        //
        // check whether to give an expiration warning
        //

        LsStatus = DaysToExpiration(
                Session.GetLicenseContext()->hProtocolLibContext,
                &dwDaysLeft, &fTemporary);

        if ((LICENSE_STATUS_OK != LsStatus) || (!fTemporary))
        {
            goto done;
        }

        if ((dwDaysLeft == 0xFFFFFFFF) ||
            (dwDaysLeft > ISSUE_LICENSE_WARNING_PERIOD))
        {
            goto done;
        }

        //
        // Display an expiration warning
        //

        cchMsgTitle = LoadString((HINSTANCE)hModuleWin,
                                 STR_TEMP_LICENSE_MSG_TITLE,
                                 ptszMsgTitle, MAX_TITLE_SIZE );

        if (0 == cchMsgTitle)
        {
            goto done;
        }

        ret = LoadString((HINSTANCE)hModuleWin,
                         STR_TEMP_LICENSE_EXPIRATION_MSG,
                         ptszMsgText, MAX_MESSAGE_SIZE );


        if (0 == ret)
        {
            goto done;
        }

        dwDaysLeftPtr = dwDaysLeft;
        cchMsgText = FormatMessage(FORMAT_MESSAGE_FROM_STRING
                                   | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   ptszMsgText,
                                   0,
                                   0,
                                   ptszMsgText,
                                   MAX_MESSAGE_SIZE,
                                   (va_list * )&dwDaysLeftPtr );

        if (0 == cchMsgText)
        {
            goto done;
        }

        WMsg.u.SendMessage.pTitle = ptszMsgTitle;
        WMsg.u.SendMessage.TitleLength = (cchMsgTitle + 1) * sizeof(TCHAR);
        WMsg.u.SendMessage.pMessage = ptszMsgText;
        WMsg.u.SendMessage.MessageLength = (cchMsgText + 1) * sizeof(TCHAR);

        WMsg.u.SendMessage.Style = MB_OK;
        WMsg.u.SendMessage.Timeout = 60;
        WMsg.u.SendMessage.DoNotWait = TRUE;
        WMsg.u.SendMessage.DoNotWaitForCorrectDesktop = FALSE;
        WMsg.u.SendMessage.pResponse = NULL;

        WMsg.ApiNumber = SMWinStationDoMessage;
        WMsg.u.SendMessage.hEvent = NULL;
        WMsg.u.SendMessage.pStatus = NULL; 
        WMsg.u.SendMessage.pResponse = NULL;

        Session.SendWinStationCommand( &WMsg );

    }

done:
    if ((STATUS_SUCCESS == Status)
        && (Session.GetLicenseContext()->hProtocolLibContext != NULL))
    {
        if (!Session.IsUserHelpAssistant())
        {
            //
            // Mark the license to show user has logged on
            //

            MarkLicense(Session);
        }
    }

    if (ptszMsgText != NULL) {
        LocalFree(ptszMsgText);
        ptszMsgText = NULL;
    }

    if (ptszMsgTitle != NULL) {
        LocalFree(ptszMsgTitle);
        ptszMsgTitle = NULL;
    }

    return(Status);
}

NTSTATUS
CPerSeatPolicy::Reconnect(
    CSession& Session,
    CSession& TemporarySession
    )
{
    UNREFERENCED_PARAMETER(Session);

    if (TemporarySession.GetLicenseContext()->hProtocolLibContext != NULL)
    {
        //
        // Mark the license to show user has logged on
        //

        MarkLicense(TemporarySession);
    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\peruser.cpp ===
/*
 *  peruser.cpp
 *
 *  Author: Rashmip
 *
 *  The Per User licensing policy.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "peruser.h"
#include "util.h"
#include "lctrace.h"
#include <icaevent.h>
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"


/*
 *  extern globals
 */
extern "C"
extern HANDLE hModuleWin;

/*
 *  Class Implementation
 */

/*
 *  Creation Functions
 */

CPerUserPolicy::CPerUserPolicy(
    ) : CPolicy()
{
}

CPerUserPolicy::~CPerUserPolicy(
    )
{
}

/*
 *  Administrative Functions
 */

ULONG
CPerUserPolicy::GetFlags(
    )
{
    return(LC_FLAG_INTERNAL_POLICY | LC_FLAG_REQUIRE_APP_COMPAT);
}

ULONG
CPerUserPolicy::GetId(
    )
{
    return(4);
}

NTSTATUS
CPerUserPolicy::GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    )
{
    NTSTATUS Status;

    ASSERT(lpPolicyInfo != NULL);

    if (lpPolicyInfo->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        int retVal;
        LPLCPOLICYINFO_V1 lpPolicyInfoV1 = (LPLCPOLICYINFO_V1)lpPolicyInfo;
        LPWSTR pName;
        LPWSTR pDescription;

        ASSERT(lpPolicyInfoV1->lpPolicyName == NULL);
        ASSERT(lpPolicyInfoV1->lpPolicyDescription == NULL);

        //
        //  The strings loaded in this fashion are READ-ONLY. They are also
        //  NOT NULL terminated. Allocate and zero out a buffer, then copy the
        //  string over.
        //

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_PERUSER_NAME,
            (LPWSTR)(&pName),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyName = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyName != NULL)
            {
                StringCbCopyN(lpPolicyInfoV1->lpPolicyName, (retVal+1) * sizeof(WCHAR), pName, (retVal+1) * sizeof(WCHAR));
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_PERUSER_DESC,
            (LPWSTR)(&pDescription),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyDescription = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyDescription != NULL)
            {
                StringCbCopyN(lpPolicyInfoV1->lpPolicyDescription, (retVal+1) * sizeof(WCHAR), pDescription, (retVal+1) * sizeof(WCHAR));
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        Status = STATUS_SUCCESS;
        goto exit;

V1error:

        //
        //  An error occurred loading/copying the strings.
        //

        if (lpPolicyInfoV1->lpPolicyName != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyName);
            lpPolicyInfoV1->lpPolicyName = NULL;
        }

        if (lpPolicyInfoV1->lpPolicyDescription != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyDescription);
            lpPolicyInfoV1->lpPolicyDescription = NULL;
        }
    }
    else
    {
        Status = STATUS_REVISION_MISMATCH;
    }

exit:
    return(Status);
}

/*
 *  Loading and Activation Functions
 */


NTSTATUS
CPerUserPolicy::Activate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    )
{
    UNREFERENCED_PARAMETER(fStartup);

    if (NULL != pulAlternatePolicy)
    {
        // don't set an explicit alternate policy

        *pulAlternatePolicy = ULONG_MAX;
    }

    return(StartCheckingGracePeriod());
}

NTSTATUS
CPerUserPolicy::Deactivate(
    BOOL fShutdown
    )
{
    if (!fShutdown)
    {
        return(StopCheckingGracePeriod());
    }
    else
    {
        return STATUS_SUCCESS;
    }
}

/*
 *  Licensing Functions
 */

NTSTATUS
CPerUserPolicy::Logon(
    CSession& Session
    )
{   
    if (!Session.IsSessionZero()
        && !Session.IsUserHelpAssistant())
    {
        if (!AllowLicensingGracePeriodConnection())
        {
            if(FALSE == RegisteredWithLicenseServer())
            {
                LicenseLogEvent(EVENTLOG_WARNING_TYPE,
                                EVENT_NO_LICENSE_SERVER,
                                0,
                                NULL
                               );
                return STATUS_CTX_WINSTATION_ACCESS_DENIED;
            }
            else
            {
                return STATUS_SUCCESS;
            }
        }
	    else
	    {
		    return STATUS_SUCCESS;
	    }
	}
    return STATUS_SUCCESS;    
}

NTSTATUS
CPerUserPolicy::Reconnect(
    CSession& Session,
    CSession& TemporarySession
    )
{
    UNREFERENCED_PARAMETER(Session);

    if (!Session.IsSessionZero()
        && !Session.IsUserHelpAssistant())
    {
  	    if (!AllowLicensingGracePeriodConnection())
        {
            if(FALSE == RegisteredWithLicenseServer())
            {
                LicenseLogEvent(EVENTLOG_WARNING_TYPE,
                                EVENT_NO_LICENSE_SERVER,
                                0,
                                NULL
                               );

                return STATUS_CTX_WINSTATION_ACCESS_DENIED;
            }
            else
            {
                return STATUS_SUCCESS;
            }
        }
        else
        {
            return STATUS_SUCCESS;
        }
	}
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\peruser.h ===
/*
 *  Concurrent.h
 *
 *  Author: RashmiP
 *
 *  The Per User licensing policy.
 */

#ifndef __LC_PerUser_H__
#define __LC_PerUser_H__

/*
 *  Includes
 */

#include "policy.h"

/*
 *  Class Definition
 */

class CPerUserPolicy : public CPolicy
{
public:

/*
 *  Creation Functions
 */

    CPerUserPolicy(
    );

    ~CPerUserPolicy(
    );

/*
 *  Administrative Functions
 */

    ULONG
    GetFlags(
    );

    ULONG
    GetId(
    );

    NTSTATUS
    GetInformation(
                   LPLCPOLICYINFOGENERIC lpPolicyInfo
                   );

/*
 *  Loading and Activation Functions
 */


    NTSTATUS
    Activate(
             BOOL fStartup,
             ULONG *pulAlternatePolicy
             );

    NTSTATUS
    Deactivate(
               BOOL fShutdown
               );

/*
 *  Licensing Functions
 */

    NTSTATUS
    Logon(
          CSession& Session
          );


    NTSTATUS
    Reconnect(
          CSession& Session,
          CSession& TemporarySession
          );    


/*
 *  Private License Functions
 */

private:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\pollist.h ===
/*
 *  PolRef.h
 *
 *  Author: BreenH
 *
 *  Private header for the policy reference list.
 */

#ifndef __POLLIST_H__
#define __POLLIST_H__

/*
 *  Typedefs
 */

typedef struct {
    LIST_ENTRY ListEntry;
    CPolicy *pPolicy;
} LCPOLICYREF, *LPLCPOLICYREF;

/*
 *  Function Prototypes
 */

NTSTATUS
PolicyListAdd(
    CPolicy *pPolicy
    );

VOID
PolicyListDelete(
    ULONG ulPolicyId
    );

NTSTATUS
PolicyListEnumerateIds(
    PULONG *ppulPolicyIds,
    PULONG pcPolicies
    );

CPolicy *
PolicyListFindById(
    ULONG ulPolicyId
    );

CPolicy *
PolicyListPop(
    VOID
    );

NTSTATUS
PolicyListInitialize(
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\policy.cpp ===
/*
 *  Policy.cpp
 *
 *  Author: BreenH
 *
 *  The policy base class definition.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "policy.h"
#include "util.h"
#include <tserrs.h>

/*
 *  Globals
 */

extern "C" WCHAR g_wszProductVersion[];

/*
 *  Class Implementation
 */

/*
 *  Creation Functions
 */

CPolicy::CPolicy(
    )
{
    m_fActivated = FALSE;
    m_RefCount = 0;
}

CPolicy::~CPolicy(
    )
{
    ASSERT(!m_fActivated);
    ASSERT(m_RefCount == 0);
}

/*
 *  Core Loading and Activation Functions
 */

NTSTATUS
CPolicy::CoreActivate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    )
{
    NTSTATUS Status;

    //
    //  CoreActivate is protected by the g_PolicyCritSec.
    //

    ASSERT(!m_fActivated);

    Status = Activate(fStartup,pulAlternatePolicy);

    if (Status == STATUS_SUCCESS)
    {
        m_fActivated = TRUE;
    }

    return(Status);
}

NTSTATUS
CPolicy::CoreDeactivate(
    BOOL fShutdown
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    //  CoreDeactivate is protected by the g_PolicyCritSec.
    //

    if (m_fActivated)
    {
        Status = Deactivate(fShutdown);

        m_fActivated = FALSE;
    }

    return(Status);
}

NTSTATUS
CPolicy::CoreLoad(
    ULONG ulCoreVersion
    )
{
    NTSTATUS Status;

    //
    //  CoreLoad is protected by the g_PolicyCritSec.
    //

    if (ulCoreVersion == LC_VERSION_CURRENT)
    {
        Status = Load();
    }
    else
    {
        Status = STATUS_NOT_SUPPORTED;
    }

    return(Status);
}

NTSTATUS
CPolicy::CoreUnload(
    )
{
    NTSTATUS Status;

    //
    //  CoreUnload is protected by the g_PolicyCritSec.
    //

    ASSERT(!m_fActivated);

    if (m_RefCount > 0)
    {
        Status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        Status = Unload();
    }

    return(Status);
}

/*
 *  Subclass Loading and Activation Functions
 */

NTSTATUS
CPolicy::Activate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    )
{
    UNREFERENCED_PARAMETER(fStartup);
    UNREFERENCED_PARAMETER(pulAlternatePolicy);

    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Deactivate(
    BOOL fShutdown
    )
{
    UNREFERENCED_PARAMETER(fShutdown);

    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Load(
    )
{
    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Unload(
    )
{
    return(STATUS_SUCCESS);
}

/*
 *  Reference Functions
 */

LONG
CPolicy::IncrementReference(
    )
{
    //
    //  IncrementReference is protected by the g_PolicyCritSec. No need to
    //  protect it again here, or do an InterlockedIncrement.
    //

    return(++m_RefCount);
}

LONG
CPolicy::DecrementReference(
    )
{
    //
    //  DecrementReference is protected by the g_PolicyCritSec. No need to
    //  protect it again here, or do an InterlockedDecrement. 
    //

    return(--m_RefCount);
}

/*
 *  Administrative Functions
 */

NTSTATUS
CPolicy::DestroyPrivateContext(
    LPLCCONTEXT lpContext
    )
{
    UNREFERENCED_PARAMETER(lpContext);

    ASSERT(lpContext->lPrivate == NULL);

    return(STATUS_SUCCESS);
}

/*
 *  Licensing Functions
 */

NTSTATUS
CPolicy::Connect(
    CSession& Session,
    UINT32 &dwClientError
    )
{
    LICENSE_STATUS LsStatus;
    NTSTATUS Status;
    PBYTE pBuffer;
    ULONG cbBuffer;
    ULONG cbReturned;
    BOOL fExtendedError = FALSE;

    pBuffer = NULL;
    cbBuffer = 0;

    LsStatus = ConstructProtocolResponse(
        Session.GetLicenseContext()->hProtocolLibContext,
        LICENSE_RESPONSE_VALID_CLIENT,
        TS_ERRINFO_NOERROR,
        &cbBuffer,
        &pBuffer,
        fExtendedError
        );

    if (LsStatus == LICENSE_STATUS_OK)
    {
        ASSERT(pBuffer != NULL);
        ASSERT(cbBuffer > 0);

        Status = _IcaStackIoControl(
            Session.GetIcaStack(),
            IOCTL_ICA_STACK_SEND_CLIENT_LICENSE,
            pBuffer,
            cbBuffer,
            NULL,
            0,
            &cbReturned
            );
    }
    else
    {
        dwClientError = LsStatusToClientError(LsStatus);
        
        Status = LsStatusToNtStatus(LsStatus);
        goto errorexit;
    }

    if (Status == STATUS_SUCCESS)
    {
        ULONG ulLicenseStatus;

        ulLicenseStatus = LICENSE_PROTOCOL_SUCCESS;
        
        Status = _IcaStackIoControl(
            Session.GetIcaStack(),
            IOCTL_ICA_STACK_LICENSE_PROTOCOL_COMPLETE,
            &ulLicenseStatus,
            sizeof(ULONG),
            NULL,
            0,
            &cbReturned
            );
    }

    if (Status != STATUS_SUCCESS)
    {
        dwClientError = NtStatusToClientError(Status);
    }

errorexit:
    if (pBuffer != NULL)
    {
        LocalFree(pBuffer);
    }

    return(Status);
}

NTSTATUS
CPolicy::AutoLogon(
    CSession& Session,
    LPBOOL lpfUseCredentials,
    LPLCCREDENTIALS lpCredentials
    )
{
    UNREFERENCED_PARAMETER(Session);
    UNREFERENCED_PARAMETER(lpCredentials);

    ASSERT(lpfUseCredentials != NULL);
    ASSERT(lpCredentials != NULL);

    *lpfUseCredentials = FALSE;

    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Logon(
    CSession& Session
    )
{
    UNREFERENCED_PARAMETER(Session);

    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Disconnect(
    CSession& Session
    )
{
    UNREFERENCED_PARAMETER(Session);

    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Reconnect(
    CSession& Session,
    CSession& TemporarySession
    )
{
    UNREFERENCED_PARAMETER(Session);
    UNREFERENCED_PARAMETER(TemporarySession);

    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Logoff(
    CSession& Session
    )
{
    UNREFERENCED_PARAMETER(Session);

    return(STATUS_SUCCESS);
}

/*
 *  Common Helper Functions
 */

NTSTATUS
CPolicy::GetLlsLicense(
    CSession& Session
    )
{
    LS_STATUS_CODE LlsStatus;
    NTSTATUS Status;
    NT_LS_DATA LsData;

    ASSERT(!(Session.GetLicenseContext()->fLlsLicense));

    LsData.DataType = NT_LS_USER_NAME;
    LsData.Data = (PVOID)(Session.GetUserName());
    LsData.IsAdmin = Session.IsUserAdmin();

    LlsStatus = NtLicenseRequest(
        LC_LLS_PRODUCT_NAME,
        g_wszProductVersion,
        &(Session.GetLicenseContext()->hLlsLicense),
        &LsData
        );

    if (LlsStatus == LS_SUCCESS)
    {
        Session.GetLicenseContext()->fLlsLicense = TRUE;
        Status = STATUS_SUCCESS;
    }
    else
    {
        if (LlsStatus == LS_INSUFFICIENT_UNITS)
        {
            Status = STATUS_CTX_LICENSE_NOT_AVAILABLE;
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\pts.cpp ===
/*
 *  Pts.cpp
 *
 *  Author: BreenH
 *
 *  A dummy licensing policy for Personal TS.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "pts.h"

/*
 *  Class Implementation
 */

/*
 *  Creation Functions
 */

CPtsPolicy::CPtsPolicy(
    ) : CPolicy()
{
}

CPtsPolicy::~CPtsPolicy(
    )
{
}

/*
 *  Administrative Functions
 */

ULONG
CPtsPolicy::GetFlags(
    )
{
    return(LC_FLAG_INTERNAL_POLICY | LC_FLAG_LIMITED_INIT_ONLY);
}

ULONG
CPtsPolicy::GetId(
    )
{
    return(0);
}

NTSTATUS
CPtsPolicy::GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    )
{
    UNREFERENCED_PARAMETER(lpPolicyInfo);

    return(STATUS_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\precomp.h ===
/*
 *  precomp.h
 *
 *  Author: BreenH
 *
 *  Precompiled header for the licensing core.
 */

//
//  Remove warning 4514: unreferenced inline function has been removed.
//  This comes up due to the code being compiled at /W4, even though the
//  precompiled header is at /W3.
//

#pragma warning(disable: 4514)

//
//  Most SDK headers can't survive /W4.
//

#pragma warning(push, 3)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#include <stdio.h>
#include <ntlsapi.h>
#include <limits.h>
#include <time.h>
#include <winsta.h>
#include <wstmsg.h>
#include <icadd.h>
#include <icaapi.h>
#include <license.h>
#include <tlsapi.h>
#include <licprot.h>
#include <hslice.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <dsrole.h>
#include <cryptkey.h>
#include <certutil.h>
#include <lscsp.h>
#include <tsutilnt.h>
#include <md5.h>

#include "..\inc\wsxmgr.h"
#define LSCORE_NO_ICASRV_GLOBALS
#include "..\server\icasrv.h"
#include "..\server\helpasst.h"

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\pollist.cpp ===
/*
 *  PolRef.cpp
 *
 *  Author: BreenH
 *
 *  Policy reference list code.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "policy.h"
#include "pollist.h"

/*
 *  Globals
 */

LIST_ENTRY g_PolicyList;
ULONG g_cPolicies;

/*
 *  Internal Function Prototypes
 */

LPLCPOLICYREF
FindPolicyListEntry(
    ULONG ulPolicyId
    );

/*
 *  Function Implementations
 */

NTSTATUS
PolicyListAdd(
    CPolicy *pPolicy
    )
{
    LPLCPOLICYREF lpPolicyRef;

    ASSERT(pPolicy != NULL);

    lpPolicyRef = (LPLCPOLICYREF)LocalAlloc(LPTR, sizeof(LCPOLICYREF));

    if (lpPolicyRef != NULL)
    {
        lpPolicyRef->pPolicy = pPolicy;

        g_cPolicies++;
        InsertTailList(&g_PolicyList, &(lpPolicyRef->ListEntry));
        return(STATUS_SUCCESS);
    }
    else
    {
        return(STATUS_NO_MEMORY);
    }
}

VOID
PolicyListDelete(
    ULONG ulPolicyId
    )
{
    LPLCPOLICYREF lpPolicyRef;

    lpPolicyRef = FindPolicyListEntry(ulPolicyId);

    if (lpPolicyRef != NULL)
    {
        g_cPolicies--;
        RemoveEntryList(&(lpPolicyRef->ListEntry));
        LocalFree(lpPolicyRef);
    }
}

NTSTATUS
PolicyListEnumerateIds(
    PULONG *ppulPolicyIds,
    PULONG pcPolicies
    )
{
    NTSTATUS Status;

    *ppulPolicyIds = (PULONG)MIDL_user_allocate(g_cPolicies * sizeof(ULONG));

    if (*ppulPolicyIds != NULL)
    {
        LPLCPOLICYREF pTemp;
        ULONG i;

        pTemp = CONTAINING_RECORD(g_PolicyList.Flink, LCPOLICYREF, ListEntry);

        for (i = 0; i < g_cPolicies; i++)
        {
            (*ppulPolicyIds)[i] = pTemp->pPolicy->GetId();

            pTemp = CONTAINING_RECORD(pTemp->ListEntry.Flink, LCPOLICYREF, ListEntry);
        }

        *pcPolicies = g_cPolicies;
        Status = STATUS_SUCCESS;
    }
    else
    {
        *pcPolicies = 0;
        Status = STATUS_NO_MEMORY;
    }

    return(Status);
}

CPolicy *
PolicyListFindById(
    ULONG ulPolicyId
    )
{
    LPLCPOLICYREF lpPolicyRef;

    lpPolicyRef = FindPolicyListEntry(ulPolicyId);

    return(lpPolicyRef != NULL ? lpPolicyRef->pPolicy : NULL);
}

NTSTATUS
PolicyListInitialize(
    VOID
    )
{
    g_cPolicies = 0;
    InitializeListHead(&g_PolicyList);

    return(STATUS_SUCCESS);
}

CPolicy *
PolicyListPop(
    VOID
    )
{
    CPolicy *pPolicy;
    PLIST_ENTRY pTemp;
    LPLCPOLICYREF lpCurrentRef;

    if (!IsListEmpty(&g_PolicyList))
    {
        pTemp = RemoveHeadList(&g_PolicyList);

        lpCurrentRef = CONTAINING_RECORD(pTemp, LCPOLICYREF, ListEntry);
        pPolicy = lpCurrentRef->pPolicy;
        LocalFree(lpCurrentRef);
    }
    else
    {
        pPolicy = NULL;
    }

    return(pPolicy);
}

/*
 *  Internal Function Implementations
 */

LPLCPOLICYREF
FindPolicyListEntry(
    ULONG ulPolicyId
    )
{
    PLIST_ENTRY pNext;
    LPLCPOLICYREF lpPolicyRef, lpCurrentRef;

    lpPolicyRef = NULL;

    for (pNext = g_PolicyList.Flink; pNext != &g_PolicyList; pNext = pNext->Flink)
    {
        lpCurrentRef = CONTAINING_RECORD(pNext, LCPOLICYREF, ListEntry);

        if (lpCurrentRef->pPolicy->GetId() == ulPolicyId)
        {
            lpPolicyRef = lpCurrentRef;
            break;
        }
    }

    return(lpPolicyRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\policy.h ===
/*
 *  Policy.h
 *
 *  Author: BreenH
 *
 *  The policy base class definition.
 */

#ifndef __LC_POLICY_H__
#define __LC_POLICY_H__

/*
 *  Defines
 */

#define LC_VERSION_V1 0x1
#define LC_VERSION_CURRENT LC_VERSION_V1

#define LC_FLAG_INTERNAL_POLICY 0x1
#define LC_FLAG_LIMITED_INIT_ONLY 0x2
#define LC_FLAG_REQUIRE_APP_COMPAT 0x4

#define LC_LLS_PRODUCT_NAME L"TermService"

/*
 *  Typedefs
 */

class CPolicy;

/*
 *  Class Definition
 */

class CPolicy
{
public:

/*
 *  Creation Functions
 */

CPolicy(
    );

virtual
~CPolicy(
    );

/*
 *  Core Loading and Activation Functions
 */

NTSTATUS
CoreActivate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    );

NTSTATUS
CoreDeactivate(
    BOOL fShutdown
    );

NTSTATUS
CoreLoad(
    ULONG ulCoreVersion
    );

NTSTATUS
CoreUnload(
    );

/*
 *  Subclass Loading and Activation Functions
 */

protected:

virtual NTSTATUS
Activate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    );

virtual NTSTATUS
Deactivate(
    BOOL fShutdown
    );

virtual NTSTATUS
Load(
    );

virtual NTSTATUS
Unload(
    );

/*
 *  Reference Functions
 */

public:

LONG
IncrementReference(
    );

LONG
DecrementReference(
    );

/*
 *  Administrative Functions
 */

virtual NTSTATUS
DestroyPrivateContext(
    LPLCCONTEXT lpContext
    );

virtual ULONG
GetFlags(
    ) = 0;

virtual ULONG
GetId(
    ) = 0;

virtual NTSTATUS
GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    ) = 0;

/*
 *  Licensing Functions
 */

virtual NTSTATUS
Connect(
    CSession& Session,
    UINT &dwClientError
    );

virtual NTSTATUS
AutoLogon(
    CSession& Session,
    LPBOOL lpfUseCredentials,
    LPLCCREDENTIALS lpCredentials
    );

virtual NTSTATUS
Logon(
    CSession& Session
    );

virtual NTSTATUS
Disconnect(
    CSession& Session
    );

virtual NTSTATUS
Reconnect(
    CSession& Session,
    CSession& TemporarySession
    );

virtual NTSTATUS
Logoff(
    CSession& Session
    );

/*
 *  Common Helper Functions
 */

protected:

NTSTATUS
CPolicy::GetLlsLicense(
    CSession& Session
    );

/*
 *  Private Variables
 */

private:

BOOL m_fActivated;
LONG m_RefCount;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\pts.h ===
/*
 *  Pts.h
 *
 *  Author: BreenH
 *
 *  A dummy policy for Personal TS.
 */

#ifndef __LC_PTS_H__
#define __LC_PTS_H__

/*
 *  Includes
 */

#include "policy.h"

/*
 *  Class Definition
 */

class CPtsPolicy : public CPolicy
{
public:

/*
 *  Creation Functions
 */

CPtsPolicy(
    );

~CPtsPolicy(
    );

/*
 *  Administrative Functions
 */

ULONG
GetFlags(
    );

ULONG
GetId(
    );

NTSTATUS
GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\ra.h ===
/*
 *  RA.h
 *
 *  Author: BreenH
 *
 *  The Remote Administration policy.
 */

#ifndef __LC_RA_H__
#define __LC_RA_H__

/*
 *  Includes
 */

#include "policy.h"

/*
 *  Constants
 */

#define LC_POLICY_RA_MAX_SESSIONS 2

/*
 *  Class Definition
 */

class CRAPolicy : public CPolicy
{
public:

/*
 *  Creation Functions
 */

CRAPolicy(
    );

~CRAPolicy(
    );

/*
 *  Administrative Functions
 */

ULONG
GetFlags(
    );

ULONG
GetId(
    );

NTSTATUS
GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    );

/*
 *  Licensing Functions
 */

NTSTATUS
Logon(
    CSession& Session
    );

NTSTATUS
Logoff(
    CSession& Session
    );

/*
 *  Private Functions
 */

private:

NTSTATUS
ReleaseLicense(
    CSession& Session
    );

NTSTATUS
UseLicense(
    CSession& Session
    );

LONG m_SessionCount;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\ra.cpp ===
/*
 *  RA.cpp
 *
 *  Author: BreenH
 *
 *  The Remote Administration policy.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "ra.h"

/*
 *  extern globals
 */
extern "C"
extern HANDLE hModuleWin;

/*
 *  Class Implementation
 */

/*
 *  Creation Functions
 */

CRAPolicy::CRAPolicy(
    ) : CPolicy()
{
    m_SessionCount = 0;
}

CRAPolicy::~CRAPolicy(
    )
{
    ASSERT(m_SessionCount == 0);
}

/*
 *  Administrative Functions
 */

ULONG
CRAPolicy::GetFlags(
    )
{
    return(LC_FLAG_INTERNAL_POLICY);
}

ULONG
CRAPolicy::GetId(
    )
{
    return(1);
}

NTSTATUS
CRAPolicy::GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    )
{
    NTSTATUS Status;

    ASSERT(lpPolicyInfo != NULL);

    if (lpPolicyInfo->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        int retVal;
        LPLCPOLICYINFO_V1 lpPolicyInfoV1 = (LPLCPOLICYINFO_V1)lpPolicyInfo;
        LPWSTR pName;
        LPWSTR pDescription;

        ASSERT(lpPolicyInfoV1->lpPolicyName == NULL);
        ASSERT(lpPolicyInfoV1->lpPolicyDescription == NULL);

        //
        //  The strings loaded in this fashion are READ-ONLY. They are also
        //  NOT NULL terminated. Allocate and zero out a buffer, then copy the
        //  string over.
        //

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_RA_NAME,
            (LPWSTR)(&pName),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyName = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyName != NULL)
            {
                lstrcpynW(lpPolicyInfoV1->lpPolicyName, pName, retVal + 1);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_RA_DESC,
            (LPWSTR)(&pDescription),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyDescription = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyDescription != NULL)
            {
                lstrcpynW(lpPolicyInfoV1->lpPolicyDescription, pDescription, retVal + 1);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        Status = STATUS_SUCCESS;
        goto exit;

V1error:

        //
        //  An error occurred loading/copying the strings.
        //

        if (lpPolicyInfoV1->lpPolicyName != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyName);
            lpPolicyInfoV1->lpPolicyName = NULL;
        }

        if (lpPolicyInfoV1->lpPolicyDescription != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyDescription);
            lpPolicyInfoV1->lpPolicyDescription = NULL;
        }
    }
    else
    {
        Status = STATUS_REVISION_MISMATCH;
    }

exit:
    return(Status);
}

/*
 *  Licensing Functions
 */

NTSTATUS
CRAPolicy::Logon(
    CSession& Session
    )
{
    NTSTATUS Status;

    if ((!Session.IsSessionZero()) && (!(Session.IsUserHelpAssistant())))
    {
        Status = UseLicense(Session);
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

    return(Status);
}

NTSTATUS
CRAPolicy::Logoff(
    CSession& Session
    )
{
    NTSTATUS Status;

    if (Session.GetLicenseContext()->fTsLicense)
    {
        Status = ReleaseLicense(Session);
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

    return(Status);
}

/*
 *  Private Functions
 */

NTSTATUS
CRAPolicy::ReleaseLicense(
    CSession& Session
    )
{
    LONG lSessions;

    ASSERT(Session.GetLicenseContext()->fTsLicense);

    lSessions = InterlockedDecrement(&m_SessionCount);
    Session.GetLicenseContext()->fTsLicense = FALSE;

    ASSERT(lSessions >= 0);

    return(STATUS_SUCCESS);
}

NTSTATUS
CRAPolicy::UseLicense(
    CSession& Session
    )
{
    NTSTATUS Status;
    LONG lSessions;

    ASSERT(!(Session.GetLicenseContext()->fTsLicense));

    lSessions = InterlockedIncrement(&m_SessionCount);

    if (lSessions <= LC_POLICY_RA_MAX_SESSIONS)
    {
        Session.GetLicenseContext()->fTsLicense = TRUE;
        Status = STATUS_SUCCESS;
    }
    else
    {
        InterlockedDecrement(&m_SessionCount);
        Status = STATUS_CTX_LICENSE_NOT_AVAILABLE;
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\util.h ===
/*
 *  Util.h
 *
 *  Author: BreenH
 *
 *  Utility functions for the licensing core and its policies.
 */

#ifndef __LC_UTIL_H__
#define __LC_UTIL_H__

/*
 *  Typedefs
 */

typedef VOID (*PSSL_GEN_RAND_BITS)(PUCHAR, LONG);

/*
 *  Function Prototypes
 */

NTSTATUS
LsStatusToNtStatus(
    LICENSE_STATUS LsStatus
    );

UINT32
LsStatusToClientError(
    LICENSE_STATUS LsStatus
    );

UINT32
NtStatusToClientError(
    NTSTATUS Status
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\rpc\lcimport.h ===
//
//  Win32 Headers
//  Note: MIDL includes windows.h in a separate fashion, define _INC_WINDOWS
//  to prevent other header files from re-including.
//

#define _INC_WINDOWS
#include <windef.h>
#include <winbase.h>
#include <license.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\util.cpp ===
/*
 *  Util.h
 *
 *  Author: BreenH
 *
 *  Utility functions for the licensing core and its policies.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include <stdlib.h>
#include <time.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmapibuf.h>
#define SECURITY_WIN32
#include <security.h>
#include <rpc.h>
#include <tserrs.h>
#include "util.h"
#include "lctrace.h"

/*
 *  Function Definitions
 */

NTSTATUS
LsStatusToNtStatus(
    LICENSE_STATUS LsStatus
    )
{
    NTSTATUS Status;

    switch (LsStatus)
    {
    case LICENSE_STATUS_OK:
        Status = STATUS_SUCCESS;
        break;

    case LICENSE_STATUS_OUT_OF_MEMORY:
        Status = STATUS_NO_MEMORY;
        break;
        
    case LICENSE_STATUS_INSUFFICIENT_BUFFER:
        Status = STATUS_BUFFER_TOO_SMALL;
        break;

    case LICENSE_STATUS_INVALID_INPUT:
        Status = STATUS_INVALID_PARAMETER;
        break;

    case LICENSE_STATUS_NO_LICENSE_SERVER:
        Status = RPC_NT_SERVER_UNAVAILABLE;
        break;

    case LICENSE_STATUS_CANNOT_UPGRADE_LICENSE:
    case LICENSE_STATUS_NO_LICENSE_ERROR:
        Status = STATUS_LICENSE_VIOLATION;
        break;

    default:
        Status = STATUS_INTERNAL_ERROR;
        break;
    }

    return Status;
}


UINT32
LsStatusToClientError(
    LICENSE_STATUS LsStatus
    )
{
    UINT32 dwClientError;

    switch (LsStatus)
    {
    case LICENSE_STATUS_OK:
        dwClientError = TS_ERRINFO_NOERROR;
        break;

    case LICENSE_STATUS_OUT_OF_MEMORY:
        dwClientError = TS_ERRINFO_OUT_OF_MEMORY;
        break;
        
    case LICENSE_STATUS_NO_LICENSE_SERVER:
        dwClientError = TS_ERRINFO_LICENSE_NO_LICENSE_SERVER;
        break;

    case LICENSE_STATUS_NO_LICENSE_ERROR:       
    case LICENSE_STATUS_AUTHENTICATION_ERROR:
        dwClientError = TS_ERRINFO_LICENSE_NO_LICENSE;
        break;

    case LICENSE_STATUS_INVALID_RESPONSE:
        dwClientError = TS_ERRINFO_LICENSE_BAD_CLIENT_MSG;
        break;

    case LICENSE_STATUS_INVALID_MAC_DATA:
        dwClientError = TS_ERRINFO_LICENSE_BAD_CLIENT_MSG;
        break;

    case LICENSE_STATUS_CANNOT_DECODE_LICENSE:
        dwClientError = TS_ERRINFO_LICENSE_BAD_CLIENT_LICENSE;
        break;

    case LICENSE_STATUS_CANNOT_VERIFY_HWID:
        dwClientError = TS_ERRINFO_LICENSE_HWID_DOESNT_MATCH_LICENSE;
        break;

    case LICENSE_STATUS_SERVER_ABORT:
        dwClientError = TS_ERRINFO_LICENSE_CANT_FINISH_PROTOCOL;
        break;

    case LICENSE_STATUS_CLIENT_ABORT:
        dwClientError = TS_ERRINFO_LICENSE_CLIENT_ENDED_PROTOCOL;
        break;

    case LICENSE_STATUS_CANNOT_UPGRADE_LICENSE:
        dwClientError = TS_ERRINFO_LICENSE_CANT_UPGRADE_LICENSE;
        break;

    case LICENSE_STATUS_INSUFFICIENT_BUFFER:
    case LICENSE_STATUS_INVALID_INPUT:
    case LICENSE_STATUS_INVALID_SERVER_CONTEXT:
    case LICENSE_STATUS_NO_CERTIFICATE:
    case LICENSE_STATUS_NO_PRIVATE_KEY:
    case LICENSE_STATUS_INVALID_CRYPT_STATE:
    default:
        dwClientError = TS_ERRINFO_LICENSE_INTERNAL;
        break;
    }

    return dwClientError;
}

UINT32
NtStatusToClientError(
    NTSTATUS Status
    )
{
    UINT32 dwClientError;

    switch (Status)
    {
    case STATUS_SUCCESS:
        dwClientError = TS_ERRINFO_NOERROR;
        break;

    case STATUS_NO_MEMORY:
        dwClientError = TS_ERRINFO_OUT_OF_MEMORY;
        break;
        
    case RPC_NT_SERVER_UNAVAILABLE:
        dwClientError = TS_ERRINFO_LICENSE_NO_LICENSE_SERVER;
        break;

    case STATUS_LICENSE_VIOLATION:
        dwClientError = TS_ERRINFO_LICENSE_NO_LICENSE;
        break;

    case STATUS_NET_WRITE_FAULT:
    case STATUS_IO_TIMEOUT:
        dwClientError = TS_ERRINFO_LICENSE_CANT_FINISH_PROTOCOL;
        break;


    case STATUS_CTX_CLOSE_PENDING:
    case STATUS_INVALID_PARAMETER:
    case STATUS_BUFFER_TOO_SMALL:
    case STATUS_NO_DATA_DETECTED:
    default:
        dwClientError = TS_ERRINFO_LICENSE_INTERNAL;
        break;
    }

    return dwClientError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\acl.c ===
/*************************************************************************
*
* acl.c
*
* Routines to manage Window Station Security.
*
*
* Copyright Microsoft Corporation, 1998
*
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <winsta.h>

#include <rpc.h>
#include <seopaque.h>

/*
 * NOTE: Please keep all security code for ICASRV and CITRIX WINSTATIONS
 *       in this file. This helps to compartmentilize the security routines
 *       to make it easier to update/debug our policies.
 *
 */

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif



/*
 * Forward references
 */
NTSTATUS 
AddUserAce( 
    PWINSTATION 
    );

VOID
CleanUpSD(
   PSECURITY_DESCRIPTOR pSD
   );

NTSTATUS IcaRegWinStationEnumerate( PULONG, PWINSTATIONNAME, PULONG );

NTSTATUS
ConfigureSecurity(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
ConfigureConsoleSecurity(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

PSECURITY_DESCRIPTOR
CreateWinStationDefaultSecurityDescriptor();

NTSTATUS
RpcGetClientLogonId(
    PULONG pLogonId
    );

NTSTATUS
RpcCheckSystemClientEx(
    PWINSTATION pWinStation
    );

BOOL
IsCallerSystem( VOID );

BOOL
IsCallerAdmin( VOID );

BOOL
IsServiceLoggedAsSystem( VOID );


BOOL
IsSystemToken( HANDLE TokenHandle );


NTSTATUS
RpcCheckSystemClientNoLogonId(
    PWINSTATION pWinStation
    );

NTSTATUS
RpcCheckClientAccessLocal(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    );

BOOL
AddAccessToDirectory(
    PWCHAR pPath,
    DWORD  NewAccess,
    PSID   pSid
    );

NTSTATUS
AddAccessToDirectoryObjects(
    HANDLE DirectoryHandle,
    DWORD  NewAccess,
    PSID   pSid
    );

BOOL
AddAceToSecurityDescriptor(
    PSECURITY_DESCRIPTOR *ppSd,
    PACL                 *ppDacl,
    DWORD                Access,
    PSID                 pSid,
    BOOLEAN              InheritOnly
    );

BOOL
SelfRelativeToAbsoluteSD(
    PSECURITY_DESCRIPTOR SecurityDescriptorIn,
    PSECURITY_DESCRIPTOR *SecurityDescriptorOut,
    PULONG ReturnedLength
    );

BOOL
AbsoluteToSelfRelativeSD(
    PSECURITY_DESCRIPTOR SecurityDescriptorIn,
    PSECURITY_DESCRIPTOR *SecurityDescriptorOut,
    PULONG ReturnedLength
    );

NTSTATUS ApplyWinStaMappingToSD( 
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );



/*
 * Global data
 */
PSECURITY_DESCRIPTOR DefaultWinStationSecurityDescriptor = NULL;
PSECURITY_DESCRIPTOR DefaultConsoleSecurityDescriptor = NULL;

/*
 * Structure to lookup the default security descriptor
 * for WINSTATIONS.
 */
RTL_QUERY_REGISTRY_TABLE DefaultSecurityTable[] = {

    {NULL, RTL_QUERY_REGISTRY_SUBKEY,
     REG_WINSTATIONS, NULL,
     REG_NONE, NULL, 0},

    {ConfigureSecurity,      RTL_QUERY_REGISTRY_REQUIRED,
     REG_DEFAULTSECURITY, NULL,
     REG_NONE, NULL, 0},

    {NULL, 0,
     NULL, NULL,
     REG_NONE, NULL, 0}

};

/*
 * Structure to lookup the default console security descriptor
 */
RTL_QUERY_REGISTRY_TABLE ConsoleSecurityTable[] = {

    {NULL, RTL_QUERY_REGISTRY_SUBKEY,
     REG_WINSTATIONS, NULL,
     REG_NONE, NULL, 0},

    {ConfigureConsoleSecurity,      RTL_QUERY_REGISTRY_REQUIRED,
     REG_CONSOLESECURITY, NULL,
     REG_NONE, NULL, 0},

    {NULL, 0,
     NULL, NULL,
     REG_NONE, NULL, 0}

};

extern PSID gSystemSid;
extern PSID gAdminSid;
extern PSID gAnonymousSid;
extern RTL_RESOURCE WinStationSecurityLock;

/*
 * Structure to lookup the security on a specific WINSTATION
 * type name in the registry.
 *
 * This is control\Terminal Server\WinStations\<name>\Security
 *
 * <name> is the transport type. IE: TCP, IPX, etc.
 */
RTL_QUERY_REGISTRY_TABLE WinStationSecurityTable[] = {

    {ConfigureSecurity,         RTL_QUERY_REGISTRY_REQUIRED,
     REG_SECURITY,               NULL,
     REG_NONE, NULL, 0},

    {NULL, 0,
     NULL, NULL,
     REG_NONE, NULL, 0}

};

LPCWSTR szTermsrv = L"Termsrv";
LPCWSTR szTermsrvSession = L"Termsrv Session";

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for Window Station objects.
//

GENERIC_MAPPING WinStaMapping = {
    STANDARD_RIGHTS_READ |
        WINSTATION_QUERY,
    STANDARD_RIGHTS_WRITE |
        WINSTATION_SET,
    STANDARD_RIGHTS_EXECUTE,
        WINSTATION_ALL_ACCESS
};


/*******************************************************************************
 *
 *  WinStationSecurityInit
 *
 *  Initialize the WinStation security.
 *
 * ENTRY:
 *   nothing
 *
 * EXIT:
 *   STATUS_SUCCESS
 *
 ******************************************************************************/

NTSTATUS
WinStationSecurityInit( VOID )
{
    NTSTATUS Status;
    /*
     * Get the default security descriptor from the registry
     *
     * This is placed on WinStations that do not have specific
     * security placed on them by WinAdmin.
     *
     * This key is in CurrentControlSet\Control\Terminal Server\WinStations\DefaultSecurity
     */
    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     REG_TSERVER,
                                     DefaultSecurityTable,
                                     NULL,
                                     DefaultEnvironment
                                   );

    /*
     * If the key does not exist, create a default security descriptor.
     *
     * NOTE: This is now created by default always by SM manager. The
     *       SM default must match the default here.
     *       This is so that the console is created with the right SD.
     */
    if (   ( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        || ( DefaultWinStationSecurityDescriptor == NULL ) ) {
        PSECURITY_DESCRIPTOR Default;
        ULONG Length;

        Default = CreateWinStationDefaultSecurityDescriptor();
        ASSERT( Default != NULL );
        if (Default == NULL) {
            return STATUS_NO_MEMORY;
        }

        Length = RtlLengthSecurityDescriptor(Default);

        // Ensure the complete path exists
        RtlCreateRegistryKey( RTL_REGISTRY_CONTROL, REG_TSERVER );
        RtlCreateRegistryKey( RTL_REGISTRY_CONTROL, REG_TSERVER_WINSTATIONS );

        Status = RtlWriteRegistryValue( RTL_REGISTRY_CONTROL,
                                        REG_TSERVER_WINSTATIONS,
                                        REG_DEFAULTSECURITY, REG_BINARY,
                                        Default, Length );

        DefaultWinStationSecurityDescriptor = Default;
    }

    if (!NT_SUCCESS( Status )) {
        DBGPRINT(( "TERMSRV: RtlQueryRegistryValues(Terminal Server) failed - Status == %lx\n", Status ));
    }

    ASSERT( DefaultWinStationSecurityDescriptor != NULL );
    
    //Just do the same for default console security descriptor
    //--------------------------------------------------------------------------------------
    /*
     * Get the default console security descriptor from the registry
     *
     * This is placed on WinStations that do not have specific
     * security placed on them by WinAdmin.
     *
     * This key is in CurrentControlSet\Control\Terminal Server\WinStations\ConsoleSecurity
     */
    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     REG_TSERVER,
                                     ConsoleSecurityTable,
                                     NULL,
                                     DefaultEnvironment
                                   );

    /*
     * If the key does not exist, set default console SD to be equal to 
     * default SD
     */
    if (   ( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        || ( DefaultConsoleSecurityDescriptor == NULL ) ) {

        PSECURITY_DESCRIPTOR ConsoleDefault;
        
        //This function creates security descriptor with following ACL:
        //SYSTEM - All Access; Administrators - All Access.
        ConsoleDefault = CreateWinStationDefaultSecurityDescriptor();
        ASSERT( ConsoleDefault != NULL );
        if (ConsoleDefault == NULL) {
            return STATUS_NO_MEMORY;
        }

        DefaultConsoleSecurityDescriptor = ConsoleDefault;       
    }

    ASSERT( DefaultConsoleSecurityDescriptor != NULL );
    //--------------------------------------------------------------------------------------

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  ReadWinStationSecurityDescriptor
 *
 *   Read the security descriptor from the registry for the
 *   WINSTATION name.
 *
 *   The WINSTATION name is the base protocol name, or the one shot name.
 *   IE: "TCP", or "COM3". It is not an instance name such as "TCP#4".
 *
 *   This is called by the WSF_LISTEN thread to get any specific ACL's
 *   for the WINSTATION protocol type.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
ReadWinStationSecurityDescriptor(
    PWINSTATION pWinStation
    )
{
    LONG cb;
    LPWSTR PathBuf;
    NTSTATUS Status;
    ULONG Length;
    PACL Dacl, NewDacl = NULL;
    BOOLEAN DaclPresent, DaclDefaulted;
    ACL_SIZE_INFORMATION AclInfo;
    PACE_HEADER CurrentAce;
    ULONG i;
    PWINSTATIONNAMEW WinStationName = &(pWinStation->WinStationName[0]);

        
    if(pWinStation->LogonId == 0)
    {
        //For session 0 always use Console Security Descriptor
        WinStationName = L"Console";
    }

    /*
     * If no name, we can not lookup the security descriptor.
     */
    if( WinStationName[0] == UNICODE_NULL ) {
        TRACE0(("TERMSRV: ReadWinStationSecurityDescriptor: No name on WinStation LogonId %d\n",pWinStation->LogonId));
        return( STATUS_NO_SECURITY_ON_OBJECT );
    }

    TRACE0(("TERMSRV: ReadWinStationSecurityDescriptor: Name %ws\n",WinStationName));

    cb = sizeof( REG_TSERVER_WINSTATIONS ) +
         sizeof( L"\\" ) +
         sizeof(WINSTATIONNAME)             +
         sizeof(UNICODE_NULL);

    PathBuf = MemAlloc( cb );
    if ( PathBuf == NULL )
        return( STATUS_NO_MEMORY );

    wcscpy( PathBuf, REG_TSERVER_WINSTATIONS );
    wcscat( PathBuf, L"\\" );
    wcscat( PathBuf, WinStationName );

    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     PathBuf,
                                     WinStationSecurityTable,
                                     pWinStation,
                                     DefaultEnvironment
                                   );
   /*
    * Do not let a Winstation with no security descriptor
    */
    if ( (   ( Status == STATUS_OBJECT_NAME_NOT_FOUND )
          || ( pWinStation->pSecurityDescriptor == NULL) )
        && (DefaultWinStationSecurityDescriptor != NULL) )
    {
        //
        //  Free the old one if allocated
        //
        if ( pWinStation->pSecurityDescriptor ) {
            //  must break up into absolute format and self-relative
            CleanUpSD(pWinStation->pSecurityDescriptor);
            pWinStation->pSecurityDescriptor = NULL;
        }

        if(_wcsicmp( WinStationName, L"Console" ))
        {
            // RtlCopySecurityDescriptor only works with self-relative format
            Status = RtlCopySecurityDescriptor(DefaultWinStationSecurityDescriptor,
                                               &(pWinStation->pSecurityDescriptor));
        }
        else
        {
            //It is a console winstation
            Status = RtlCopySecurityDescriptor(DefaultConsoleSecurityDescriptor,
                                               &(pWinStation->pSecurityDescriptor));
        }

    }

    TRACE0(("TERMSRV: ReadWinStationSecurityDescriptor: Status 0x%x\n",Status));

    MemFree( PathBuf );
    
    if(pWinStation->pUserSid && pWinStation->LogonId == 0)
    {
        //This is the case when we are dynamically updating session 0's SD
        //It has logged on user, so we need to add this user to ACL
        Status = AddUserAce(pWinStation);
    }

    return( Status );
}

/*****************************************************************************
 *
 *  ConfigureSecurity
 *
 *   Processing function called by RtlQueryRegistryValues() to process the
 *   WINSTATION security descriptor read from the registry.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
ConfigureSecurity(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR * ppSD;
    PWINSTATION pWinStation = (PWINSTATION)Context;
    PSID pOwnerSid = NULL;
    BOOLEAN bOD;
    PSID pGroupSid = NULL;
    BOOLEAN bGD;
    PSID SystemSid;
    SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;

    /*
     * Ensure value type is REG_BINARY and length of value data
     * is at least the length of a minimum security descriptor
     * and not unreasonably large.
     */
    if ( ValueType != REG_BINARY ||
         ValueLength < SECURITY_DESCRIPTOR_MIN_LENGTH ||
         ValueLength > MAXUSHORT ) {
        DBGPRINT(( "TERMSRV: ConfigureSecurity, ValueType=0x%x\n", ValueType ));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    if( !IsValidSecurityDescriptor( ValueData )) {
        DBGPRINT(( "TERMSRV: ConfigureSecurity, Invalid Security Descriptor in registry\n"));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    //
    // HACK needed for TS 4.0 security descriptors conversion
    //
    if (!NT_SUCCESS(RtlGetOwnerSecurityDescriptor( ValueData, &pOwnerSid, &bOD))
        || (pOwnerSid == NULL))
    {
        DBGPRINT(( "TERMSRV: ConfigureSecurity, Invalid Security Descriptor in registry: Can't get owner\n"));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    if (!NT_SUCCESS(RtlGetGroupSecurityDescriptor( ValueData, &pGroupSid, &bGD)))
    {
        DBGPRINT(( "TERMSRV: ConfigureSecurity, Invalid Security Descriptor in registry: Can't get group\n"));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    if( pWinStation ) {
        /*
         * WinStation specific security descriptor
         */
        ppSD = &(pWinStation->pSecurityDescriptor);
    }
    else {
        /*
         * Update the global default security descriptor
         */
        ppSD = &DefaultWinStationSecurityDescriptor;
    }

    //
    // Free old one if allocated
    //
    if (*ppSD != NULL) {
        CleanUpSD(*ppSD);
        //RtlDeleteSecurityObject( ppSD );
        *ppSD = NULL;
    }

    if (pGroupSid != NULL)
    {
        //
        // Regular case:
        // Copy the value read in registry
        //
        // RtlCopySecurityDescriptor only works with self-relative format
        RtlCopySecurityDescriptor((PSECURITY_DESCRIPTOR)ValueData, ppSD);
    }
    else
    {
        //
        //  Conversion for TS 4 descriptors
        //

        PSECURITY_DESCRIPTOR AbsoluteSD = NULL;

        if (SelfRelativeToAbsoluteSD ( (PSECURITY_DESCRIPTOR)ValueData, &AbsoluteSD, NULL))
        {
            // set the owner as group (both should be system sid)
            Status = RtlSetGroupSecurityDescriptor(AbsoluteSD, pOwnerSid, FALSE);
            if (NT_SUCCESS(Status))
            {
                // need also to force the mapping. Sigh !
                Status = ApplyWinStaMappingToSD(AbsoluteSD);

                if ((!NT_SUCCESS(Status)) || ( !AbsoluteToSelfRelativeSD (AbsoluteSD, ppSD, NULL)))
                {
                    Status = STATUS_INVALID_SECURITY_DESCR;
                }
            }

            // Absolute SD was only needed temporarily
            CleanUpSD( AbsoluteSD );
        }
        else
        {
            Status = STATUS_INVALID_SECURITY_DESCR;
        }
        if (!NT_SUCCESS(Status))
        {
            DBGPRINT(( "TERMSRV: ConfigureSecurity, Invalid Security Descriptor in registry\n"));
            return( STATUS_INVALID_SECURITY_DESCR );
        }

    }

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  ConfigureConsoleSecurity
 *
 *   Processing function called by RtlQueryRegistryValues() to process the
 *   default console security descriptor read from the registry.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
ConfigureConsoleSecurity(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR * ppSD;
    PSID pOwnerSid = NULL;
    BOOLEAN bOD;
    PSID pGroupSid = NULL;
    BOOLEAN bGD;
    /*
     * Ensure value type is REG_BINARY and length of value data
     * is at least the length of a minimum security descriptor
     * and not unreasonably large.
     */
    if ( ValueType != REG_BINARY ||
         ValueLength < SECURITY_DESCRIPTOR_MIN_LENGTH ||
         ValueLength > MAXUSHORT ) {
        DBGPRINT(( "TERMSRV: ConfigureConsoleSecurity, ValueType=0x%x\n", ValueType ));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    if( !IsValidSecurityDescriptor( ValueData )) {
        DBGPRINT(( "TERMSRV: ConfigureConsoleSecurity, Invalid Security Descriptor in registry\n"));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    //
    // HACK needed for TS 4.0 security descriptors conversion
    //
    if (!NT_SUCCESS(RtlGetOwnerSecurityDescriptor( ValueData, &pOwnerSid, &bOD))
        || (pOwnerSid == NULL))
    {
        DBGPRINT(( "TERMSRV: ConfigureConsoleSecurity, Invalid Security Descriptor in registry: Can't get owner\n"));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    if (!NT_SUCCESS(RtlGetGroupSecurityDescriptor( ValueData, &pGroupSid, &bGD))
        ||(pGroupSid == NULL))
    {
        DBGPRINT(( "TERMSRV: ConfigureConsoleSecurity, Invalid Security Descriptor in registry: Can't get group\n"));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    
    /*
     * Update the global default security descriptor
     */
    ppSD = &DefaultConsoleSecurityDescriptor;


    //
    // Free old one if allocated
    //
    if (*ppSD != NULL) {
        CleanUpSD(*ppSD);
        //RtlDeleteSecurityObject( ppSD );
        *ppSD = NULL;
    }


    //
    // Regular case:
    // Copy the value read in registry
    //
    // RtlCopySecurityDescriptor only works with self-relative format
    RtlCopySecurityDescriptor((PSECURITY_DESCRIPTOR)ValueData, ppSD);

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  WinStationGetSecurityDescriptor
 *
 *   Return a pointer to the security descriptor that should be enforced
 *   on this winstation. This could be a specific, or a global
 *   default security descriptor.
 *
 * ENTRY:   pWinStation     the aimed winstation
 *
 * EXIT:    the SD of this winstation,
 *          or the default SD if this winstation hs no SD (it should not happen !)
 *
 ****************************************************************************/

PSECURITY_DESCRIPTOR
WinStationGetSecurityDescriptor(
    PWINSTATION pWinStation
    )
{
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    SecurityDescriptor = pWinStation->pSecurityDescriptor ?
                         pWinStation->pSecurityDescriptor :
                         DefaultWinStationSecurityDescriptor;

    return( SecurityDescriptor );
}


/*****************************************************************************
 *
 *  WinStationFreeSecurityDescriptor
 *
 *   Release the winstation security descriptor.
 *
 *   If its the global default, it is not free'd.
 *
 * ENTRY:   the winstation
 *
 * EXIT:    nothing
 *
 ****************************************************************************/

VOID
WinStationFreeSecurityDescriptor(
    PWINSTATION pWinStation
    )
{

    // console disconnect
    if ( pWinStation->pSecurityDescriptor == DefaultWinStationSecurityDescriptor && pWinStation->LogonId != 0) {
        pWinStation->pSecurityDescriptor = NULL;
    }
    // Catch callers mis-managing the security descriptor
    ASSERT( pWinStation->pSecurityDescriptor != DefaultWinStationSecurityDescriptor );

    if (pWinStation->pSecurityDescriptor) {
        //RtlDeleteSecurityObject( &(pWinStation->pSecurityDescriptor) );
        CleanUpSD(pWinStation->pSecurityDescriptor);
        pWinStation->pSecurityDescriptor = NULL;
    }

    return;
}

/*****************************************************************************
 *
 *  WinStationInheritSecurityDescriptor
 *
 *  Copy the security descriptor to the target WinStation and set it
 *  on the kernel object.
 *
 * ENTRY:
 *   pSecurityDescriptor (input)
 *     pointer to SD to be inherited
 *   pTargetWinStation (input)
 *     pointer to WinStation to inherit the SD
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationInheritSecurityDescriptor(
    PVOID pSecurityDescriptor,
    PWINSTATION pTargetWinStation
    )
{
    NTSTATUS Status;

    //
    // If the listen WinStation has a security descriptor, this means
    // that all WinStations of this protocol (TD) type will inherit
    // the security descriptor set by WinCfg.
    //
    if ( pSecurityDescriptor ) {

        ASSERT( IsValidSecurityDescriptor( pSecurityDescriptor ) );

        if ( pTargetWinStation->pSecurityDescriptor ) {
           //RtlDeleteSecurityObject( &(pTargetWinStation->pSecurityDescriptor) );
           CleanUpSD(pTargetWinStation->pSecurityDescriptor);
           pTargetWinStation->pSecurityDescriptor = NULL;
        }
        // RtlCopySecurityDescriptor only works with self-relative format
        Status = RtlCopySecurityDescriptor(pSecurityDescriptor,
                                           &(pTargetWinStation->pSecurityDescriptor) );
        return (Status);
    }

    //
    // If no specific security descriptor on the listen WinStation,
    // the default was set on the object when it was created for the pool.
    //

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  RpcCheckClientAccess
 *
 *   Verify whether client has the desired access to a WinStation.
 *
 *   NOTE: This is called under an RPC context.
 *
 * ENTRY:
 *    pWinStation (input)
 *      Pointer to WinStation to query access to
 *
 *    DesiredAccess (input)
 *      Access mask of desired client access
 *
 *    AlreadyImpersonating (input)
 *      BOOLEAN that specifies caller is already impersonating client
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
RpcCheckClientAccess(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    )
{
    NTSTATUS    Status;
    RPC_STATUS  RpcStatus;
    BOOL        bAccessCheckOk = FALSE;
    DWORD       GrantedAccess;
    BOOL        AccessStatus;
    BOOL        fGenerateOnClose;

    /*
     * Impersonate the client
     */
    if ( !AlreadyImpersonating ) {
        RpcStatus = RpcImpersonateClient( NULL );
        if ( RpcStatus != RPC_S_OK ) {
            DBGPRINT(("TERMSRV: CheckClientAccess: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
            return( STATUS_CANNOT_IMPERSONATE );
        }
    }
    bAccessCheckOk = AccessCheckAndAuditAlarm(szTermsrv,
                         NULL,
                         (LPWSTR)szTermsrvSession,
                         (LPWSTR)szTermsrvSession,
                         WinStationGetSecurityDescriptor(pWinStation),
                         DesiredAccess,
                         &WinStaMapping,
                         FALSE,
                         &GrantedAccess,
                         &AccessStatus,
                         &fGenerateOnClose);

    if ( !AlreadyImpersonating ) {
        RpcRevertToSelf();
    }

    if (bAccessCheckOk)
    {
        if (AccessStatus == FALSE)
        {
            Status = NtCurrentTeb()->LastStatusValue;
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: RpcCheckClientAccess, AccessCheckAndAuditAlarm(%u) returned error 0x%x\n",
                      pWinStation->LogonId, Status ));
        }
        else
        {
            TRACE((hTrace,TC_ICASRV,TT_API3, "TERMSRV: RpcCheckClientAccess, AccessCheckAndAuditAlarm(%u) returned no error \n",
                      pWinStation->LogonId));
            Status = STATUS_SUCCESS;
        }
    }
    else
    {
        Status = NtCurrentTeb()->LastStatusValue;
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: RpcCheckClientAccess, AccessCheckAndAuditAlarm(%u) failed 0x%x\n",
                  pWinStation->LogonId, Status ));
    }

    return (Status);
}

/*****************************************************************************
 *
 *  _CheckConnectAccess
 *
 *   Check for connect access to the WINSTATION.
 *
 *   This is called under RPC context.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

_CheckConnectAccess(
    PWINSTATION pSourceWinStation,
    PSID   pClientSid,
    ULONG  ClientLogonId,
    PWCHAR pPassword,
    DWORD  PasswordSize
    )
{
    NTSTATUS Status;
    BOOLEAN fWrongPassword;
    UNICODE_STRING PasswordString;

    /*
     * First check that the current RPC caller has WINSTATION_CONNECT access
     * to the target WINSTATIONS object. This is controlled by either the
     * default, or per WINSTATION ACL setup from the registry.
     */
    Status = RpcCheckClientAccess( pSourceWinStation, WINSTATION_CONNECT, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        /*
         *  clear the password parameter to prevent it being paged cleartext
         */
        if(pPassword && PasswordSize) {
            RtlSecureZeroMemory( pPassword, wcslen(pPassword) * sizeof(WCHAR) );
        }
        return( Status );
    }

   //
   // C2 WARNING - WARNING - WARNING
   //
   // Comments by JohnR 01/21/97 - The design of this feature was redone.
   //
   // There was legacy code which has WinLogon store the users password
   // scrambled in the PWINSTATION structure for all users to support
   // the feature in which a user logged on as account User1 may type the
   // "connect <winstation>" command, in which the disconnected winstation
   // logged in as account User2 may be connected to, if the proper account
   // password is supplied from the command line. The password verification
   // was a simple string compare between the winstations stored password,
   // and the password supplied by the caller.
   //
   // The problems with this are many:
   //
   // - LSA should do all authentication. The password may have
   //   been changed, or the account disabled. Also all authentication
   //   code must be in a centralized location.
   //
   // - The Logon Hours may have expired on the account. Another violation
   //   of policy.
   //
   // - No auditing is performed on failure, in violation of
   //   security policy.
   //
   // - The users password, though scrambled, is passed around the
   //   system in code not explicitly designed to handle user authentication.
   //   This code is not known, or registered with LSA as an authentication
   //   provider. Network redirectors, WinLogon, etc. do this registration.
   //
   //
   // FIX that was be done:
   //
   // The users password is no longer set in the PWINSTATION
   // by WinLogon. When a user wants to do a "connect <winstation>",
   // the account name and password of the winstation to connect to
   // is passed to LSA as a normal authentication. This means that
   // ICASRV.EXE is properly registered as a logon provider. If the
   // account and password is valid, a token is returned. This token
   // can then be closed, and the user connected to the winstation.
   // If failure, return the access denied error. The benefits are:
   //
   // - LSA authentication
   // - ICASRV registration as a logon provider
   // - Auditing
   // - Password change, account disable handling
   // - Logon hours enforcement
   // - Password no longer passed around the system
   //
   //
   // C2 WARNING
   //
   // Even with this routine using LSA, the WinFrame connect.exe command
   // could be trojan horsed. It is not in the trusted path. At least it is
   // a system utility that users should not allow writing to. Though a user
   // has to watch their %PATH%. A better design would be for the connect
   // commands function to be part of the WinLogon's GINA screen like our
   // current Disconnect... option. This will keep the password gathering
   // in the trusted path. But this is no worse than "net.exe", WinFile, etc.,
   // or anything else that asks for a network resource password.
   //
   // C2 WARNING - WARNING - WARNING
   //

    /*
     *  If different username/domain check the password by calling LogonUser()
     */
     // SALIMC CHANGE
    if ( pSourceWinStation->pUserSid && !RtlEqualSid( pClientSid, pSourceWinStation->pUserSid ) &&  
         !RtlEqualSid( pClientSid, gSystemSid ) ) {

        HANDLE hToken;
        BOOL   Result;

        Result = LogonUser(
                     pSourceWinStation->UserName,
                     pSourceWinStation->Domain,
                     pPassword,
                     LOGON32_LOGON_INTERACTIVE, // Logon Type
                     LOGON32_PROVIDER_DEFAULT,  // Logon Provider
                     &hToken                    // Token that represents the account
                     );

        /*
         *  clear the password parameter to prevent it being paged cleartext
         */
        if(pPassword && PasswordSize) {
            RtlSecureZeroMemory( pPassword, wcslen(pPassword) * sizeof(WCHAR) );
        }

        /*
         *  check for account restriction which indicates a blank password
         *  on the account that is correct though - allow this thru on console
         */
        if( !Result && (PasswordSize == sizeof(WCHAR)) && (GetLastError() == ERROR_ACCOUNT_RESTRICTION) && (USER_SHARED_DATA->ActiveConsoleId == ClientLogonId)) {
            return( STATUS_SUCCESS );
        }
        if( !Result) {
            DBGPRINT(("TERMSRV: _CheckConnectAccess: User Account %ws\\%ws not valid %d\n",pSourceWinStation->Domain,pSourceWinStation->UserName,GetLastError()));
            return( STATUS_LOGON_FAILURE );
        }

        /*
         * Close the token handle since we only needed to determine
         * if the account and password is still valid.
         */
        CloseHandle( hToken );

        return( STATUS_SUCCESS );
    }
    else {
        return( STATUS_SUCCESS );
    }

    // NOTREACHED
}

/*****************************************************************************
 *
 *  RpcCheckSystemClient
 *
 *   Inquire in the current RPC call context whether we were
 *   called by a local SYSTEM mode caller.
 *
 *   WinStation API's that are only to be called by the WinLogon
 *   process call this function.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
RpcCheckSystemClient(
    ULONG TargetLogonId
    )
{
    NTSTATUS    Status;
    PWINSTATION pWinStation;

    pWinStation = FindWinStationById( TargetLogonId, FALSE );
    if ( pWinStation == NULL ) {
        return( STATUS_CTX_WINSTATION_NOT_FOUND );
    }

    Status = RpcCheckSystemClientEx( pWinStation );

    ReleaseWinStation( pWinStation );

    return( Status );
}

/*****************************************************************************
 *
 *  RpcCheckSystemClientEx
 *
 *   Inquire in the current RPC call context whether we were
 *   called by a local SYSTEM mode caller.
 *
 *   WinStation API's that are only to be called by the WinLogon
 *   process call this function.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
RpcCheckSystemClientEx(
    PWINSTATION pWinStation
    )
{
    ULONG ClientLogonId;
    RPC_STATUS RpcStatus;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = RpcCheckSystemClientNoLogonId( pWinStation );
    if( !NT_SUCCESS(Status) ) {
        return( Status);
    }

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        return( STATUS_CANNOT_IMPERSONATE );
    }

    /*
     * Check that the LogonId of the client is the same
     * as the LogonId of the WINSTATION being targeted.
     */
    Status = RpcGetClientLogonId( &ClientLogonId );
    if( !NT_SUCCESS(Status) ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Could not get clients LogonId 0x%x\n",Status));
        RpcRevertToSelf();
        return( STATUS_ACCESS_DENIED );
    }

    if( ClientLogonId != pWinStation->LogonId ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Caller LogonId %d does not match target %d\n",ClientLogonId,pWinStation->LogonId));
        RpcRevertToSelf();
        return( STATUS_ACCESS_DENIED );
    }

    RpcRevertToSelf();

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  RpcCheckSystemClientNoLogonId
 *
 *   Inquire in the current RPC call context whether we were
 *   called by a local SYSTEM mode caller.
 *
 *   WinStation API's that are only to be called by the WinLogon
 *   process call this function.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
RpcCheckSystemClientNoLogonId(
    PWINSTATION pWinStation
    )
{
    UINT  LocalFlag;
    RPC_STATUS RpcStatus;
    RPC_AUTHZ_HANDLE Privs;
    PWCHAR pServerPrincName;
    ULONG AuthnLevel, AuthnSvc, AuthzSvc;
    NTSTATUS Status = STATUS_SUCCESS;


    /*
     * The following checking  is to keep from screwing up
     * the state due to attempts to invoke this local
     * only API remotely, across LogonId's, or from an application.
     */

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        return( STATUS_CANNOT_IMPERSONATE );
    }

    /*
     * Inquire if local RPC call
     */
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Could not query local client RpcStatus 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        return( STATUS_ACCESS_DENIED );
    }

    if( !LocalFlag ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Not a local client call\n"));
        RpcRevertToSelf();
        return( STATUS_ACCESS_DENIED );
    }

#ifdef notdef
    // This is not working in 4.0. Its not returning
    // the principle name on the LPC transport.
    // So we resort to looking into the thread token.

    /*
     * Get the principle name, and see if its the built in LSA
     * local account "SYSTEM".
     */
    RpcStatus = RpcBindingInqAuthClientW(
                    0,    // Active RPC call we are servicing
                    &Privs,
                    &pServerPrincName,
                    &AuthnLevel,
                    &AuthnSvc,
                    &AuthzSvc
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT(("TERMSRV: RpcCheckSystemClient RpcAuthorizaton query failed! RpcStatus 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        return( STATUS_ACCESS_DENIED );
    }

    TRACE0(("TERMSRV: AuthnLevel %d, AuthnSvc %d, AuthzSvc %d pServerPrincName 0x%x, Privs 0x%x\n",AuthnLevel,AuthnSvc,AuthzSvc,pServerPrincName,Privs));

    if( AuthnSvc != RPC_C_AUTHN_WINNT ) {
        DBGPRINT(("TERMSRV: RpcCheckSystemClient RpcAuthorizaton Type not NT! 0x%x\n",AuthnSvc));
        RpcRevertToSelf();
        Status = STATUS_ACCESS_DENIED;
    }

    if( pServerPrincName ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Principle Name :%ws:\n",pServerPrincName));

        // Compare with "SYSTEM"
        if( wcsicmp( L"SYSTEM", pServerPrincName ) ) {
            DBGPRINT(("TERMSRV: RpcCheckSystemClient: Principle Name :%ws: not SYSTEM\n",pServerPrincName));
            Status = STATUS_ACCESS_DENIED;
        }

        RpcStringFreeW( &pServerPrincName );
    }
#else
    /*
     * Validate that the thread token is SYSTEM
     */

    if( !IsCallerSystem() ) {
        Status = STATUS_ACCESS_DENIED;
    }
#endif

    RpcRevertToSelf();

    return( Status );
}



/*****************************************************************************
 *
 *  RpcCheckClientAccessLocal
 *
 *   Inquire in the current RPC call context whether we were
 *   called by a local caller.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
RpcCheckClientAccessLocal(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    )
{
    UINT  LocalFlag;
    RPC_STATUS RpcStatus;
    RPC_AUTHZ_HANDLE Privs;
    PWCHAR pServerPrincName;
    ULONG AuthnLevel, AuthnSvc, AuthzSvc;
    NTSTATUS Status;

    /*
     * Impersonate the client, if not already
     */
    if ( !AlreadyImpersonating ) {
        RpcStatus = RpcImpersonateClient( NULL );
        if ( RpcStatus != RPC_S_OK ) {
            DBGPRINT(("TERMSRV: RpcCheckClientAccessLocal: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
            return( STATUS_CANNOT_IMPERSONATE );
        }
    }

    /*
     * Check for desired access. This will generate an access audit if on.
     */
    Status = RpcCheckClientAccess( pWinStation, DesiredAccess, TRUE );
    if ( !NT_SUCCESS( Status ) ) {
        if ( !AlreadyImpersonating ) {
            RpcRevertToSelf();
        }
        return( Status );
    }

    /*
     * We have now checked security on the WINSTATION, the
     * rest of the checking is to keep from screwing up
     * the state due to attempts to invoke this local
     * only API remotely.
     */

    /*
     * Inquire if local RPC call
     */
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if ( !AlreadyImpersonating ) {
        RpcRevertToSelf();
    }

    if ( RpcStatus != RPC_S_OK ) {
        DBGPRINT(("TERMSRV: RpcCheckClientAccessLocal: Could not query local client RpcStatus 0x%x\n",RpcStatus));
        return( STATUS_ACCESS_DENIED );
    }

    if ( !LocalFlag ) {
        DBGPRINT(("TERMSRV: RpcCheckClientAccessLocal: Not a local client call\n"));
        return( STATUS_ACCESS_DENIED );
    }

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  AddUserAce
 *
 *   Add an ACE for the currently logged on user to the WinStation object.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to update
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
AddUserAce( PWINSTATION pWinStation )
{
    PACL Dacl = NULL;
    BOOLEAN DaclPresent, DaclDefaulted;
    ACL_SIZE_INFORMATION AclInfo;
    ULONG Length;
    NTSTATUS Status;

    /*
     * Get a pointer to the DACL from the security descriptor.
     */
    Status = RtlGetDaclSecurityDescriptor( pWinStation->pSecurityDescriptor, &DaclPresent,
                                           &Dacl, &DaclDefaulted );
    if ( !NT_SUCCESS( Status ) || !DaclPresent || !Dacl ) {

        return( Status );
    }

    Status = RtlAddAccessAllowedAce( Dacl, ACL_REVISION,
                                     (WINSTATION_ALL_ACCESS) & ~(STANDARD_RIGHTS_ALL),
                                     pWinStation->pUserSid );

    if ( (Status == STATUS_ALLOTTED_SPACE_EXCEEDED) || (Status == STATUS_REVISION_MISMATCH) )
    {
        //
        // We need to copy the security data into a new descriptor
        //
        Status = RtlQueryInformationAcl( Dacl, &AclInfo, sizeof(AclInfo),
                                         AclSizeInformation );
        if ( NT_SUCCESS( Status ) )
        {
            ULONG AceCount;
            PRTL_ACE_DATA pAceData;
            PACE_HEADER pAce;
            ULONG i;
            PSECURITY_DESCRIPTOR pSD;
            PSID Owner, Group;
            PSID * pSidList;

            BOOLEAN OwnerDefaulted, GroupDefaulted;

            AceCount = AclInfo.AceCount;
            AceCount++;
            //
            // allocate a RTL_ACE_DATA structure and a list of pPSIDs
            //
            Length = AceCount * sizeof(RTL_ACE_DATA);
            pAceData = MemAlloc(Length);
            if (!pAceData)
            {
                return (STATUS_NO_MEMORY);
            }

            Length = AceCount * sizeof(PSID *);
            pSidList = MemAlloc(Length);
            if (!pSidList)
            {
                MemFree(pAceData);
                return (STATUS_NO_MEMORY);
            }

            for ( i = 0; i < AclInfo.AceCount; i++ )
            {
                Status = RtlGetAce( Dacl, i, &pAce );
                ASSERT( NT_SUCCESS( Status ) );
                if (!NT_SUCCESS( Status ))
                {
                    MemFree(pAceData);
                    MemFree(pSidList);
                    return STATUS_INVALID_SECURITY_DESCR;
                }

                pAceData[i].AceType = pAce->AceType;
                pAceData[i].InheritFlags = 0;
                pAceData[i].AceFlags = 0;

                switch (pAce->AceType)
                {
                case ACCESS_ALLOWED_ACE_TYPE:

                    pAceData[i].Mask = ((PACCESS_ALLOWED_ACE)pAce)->Mask;

                    pSidList[i] = (PSID)(&(((PACCESS_ALLOWED_ACE)pAce)->SidStart));
                    break;

                case ACCESS_DENIED_ACE_TYPE:

                    pAceData[i].Mask = ((PACCESS_DENIED_ACE)pAce)->Mask;

                    pSidList[i] = (PSID)(&(((PACCESS_DENIED_ACE)pAce)->SidStart));
                    pAceData[i].Sid = (PSID *)(&(pSidList[i]));
                    break;

                default:        // we do not expect anything else

                    MemFree(pAceData);
                    MemFree(pSidList);
                    return STATUS_INVALID_SECURITY_DESCR;
                }
                pAceData[i].Sid = (PSID *)(&(pSidList[i]));
            }
            //
            // add the new ACE
            //
            pAceData[i].AceType = ACCESS_ALLOWED_ACE_TYPE;
            pAceData[i].InheritFlags = 0;
            pAceData[i].AceFlags = 0;
            pAceData[i].Mask = (WINSTATION_ALL_ACCESS) & ~(STANDARD_RIGHTS_ALL);
            pAceData[i].Sid = &(pWinStation->pUserSid);

            //
            // get the owner and the group
            //
            Status = RtlGetOwnerSecurityDescriptor(pWinStation->pSecurityDescriptor,
                                                   &Owner,
                                                   &OwnerDefaulted);
            Status = RtlGetOwnerSecurityDescriptor(pWinStation->pSecurityDescriptor,
                                                   &Group,
                                                   &GroupDefaulted);
            //
            // save the old security descriptor
            //
            pSD = pWinStation->pSecurityDescriptor;

            //
            // create the new security descriptor
            //
            Status = RtlCreateUserSecurityObject(pAceData,
                                                 AceCount,
                                                 Owner,
                                                 Group,
                                                 FALSE,
                                                 &WinStaMapping,
                                                 &(pWinStation->pSecurityDescriptor) );
            //
            // delete the old security descriptor
            //
            //RtlDeleteSecurityObject( &pSD );
            // must break up into absolute format and self-relative
            if (pSD) {
               CleanUpSD(pSD);
               pSD = NULL;
            }

            // 
            // In addition, if the above call to RtlCreateUserSecurityObject fails, we should set pSecurityDescriptor to NULL
            //
            if (Status != STATUS_SUCCESS) {
                pWinStation->pSecurityDescriptor = NULL;
            }

            //
            // free the RTL_ACE_DATA
            //
            MemFree(pAceData);
            MemFree(pSidList);
        }
    }
    return( Status );

}


/*******************************************************************************
 *
 *  RemoveUserAce
 *
 *   Remove the ACE for the currently logged on user from the WinStation object.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to update
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
RemoveUserAce( PWINSTATION pWinStation )
{
    SECURITY_INFORMATION SecInfo = DACL_SECURITY_INFORMATION;
    PACL Dacl;
    BOOLEAN DaclPresent, DaclDefaulted;
    ACL_SIZE_INFORMATION AclInfo;
    PACE_HEADER Ace;
    ULONG i, Length;
    NTSTATUS Status;

    /*
     * This is probably the console if ICASRV wasn't started soon enough
     * 
     */
    if ( !pWinStation->pUserSid ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
    }
    else
    {
        Status = RtlGetDaclSecurityDescriptor( pWinStation->pSecurityDescriptor, &DaclPresent,
                                               &Dacl, &DaclDefaulted );
        if ( !NT_SUCCESS( Status ) || !DaclPresent || !Dacl ) {
            return( Status );
        }

        Status = RtlQueryInformationAcl( Dacl, &AclInfo, sizeof(AclInfo),
                                        AclSizeInformation );
        if ( !NT_SUCCESS( Status ) ) {
            return( Status );
        }

        
        for ( i = 0; i < AclInfo.AceCount; i++ ) {
            RtlGetAce( Dacl, i, &Ace );
            if ( (Ace->AceType == ACCESS_ALLOWED_ACE_TYPE) && 
                (((PACCESS_ALLOWED_ACE)Ace)->Mask == (WINSTATION_ALL_ACCESS & ~STANDARD_RIGHTS_ALL)) &&
                RtlEqualSid( pWinStation->pUserSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart ) ) {
                RtlDeleteAce( Dacl, i );
                break;
            }
        }
    }
    return( Status );
}

/*******************************************************************************
 *
 *  ApplyWinStaMappingToSD
 *
 *   Apply the generic mapping on the security descriptor.
 *
 * ENTRY:
 *    pSecurityDescriptor
 *       Pointer to security descriptor to update
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
ApplyWinStaMappingToSD( PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
    PACL Dacl;
    BOOLEAN DaclPresent, DaclDefaulted;
    ACL_SIZE_INFORMATION AclInfo;
    PACE_HEADER Ace;
    ULONG i;
    NTSTATUS Status;

    Status = RtlGetDaclSecurityDescriptor( pSecurityDescriptor, &DaclPresent,
                                           &Dacl, &DaclDefaulted );
    if ( !NT_SUCCESS( Status ) || !DaclPresent || !Dacl ) {
        return( Status );
    }

    Status = RtlQueryInformationAcl( Dacl, &AclInfo, sizeof(AclInfo),
                                    AclSizeInformation );
    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
    }

    /*
     * Scan the DACL applying the generic mapping to each ACE
     */
    for ( i = 0; i < AclInfo.AceCount; i++ ) {
        RtlGetAce( Dacl, i, &Ace );
        RtlApplyAceToObject( Ace, &WinStaMapping );
    }

    return( Status );
}

/*******************************************************************************
 *
 *  ApplyWinStaMapping
 *
 *   Apply the generic mapping on the security descriptor of the WinStation object.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to update
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
ApplyWinStaMapping( PWINSTATION pWinStation )
{
    return (ApplyWinStaMappingToSD(pWinStation->pSecurityDescriptor));
}



/*****************************************************************************
 *
 *  BuildEveryOneAllowSD
 *
 *   Build and return an EveryOne (WORLD) allow Security descriptor.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PSECURITY_DESCRIPTOR
BuildEveryOneAllowSD()
{
    BOOL  rc;
    DWORD Error;
    DWORD AclSize;
    PACL  pAcl = NULL;
    PACCESS_ALLOWED_ACE pAce = NULL;
    PSECURITY_DESCRIPTOR pSd = NULL;

    PSID  SeWorldSid = NULL;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;

    pSd = LocalAlloc(LMEM_FIXED, sizeof(SECURITY_DESCRIPTOR) );
    if( pSd == NULL ) {
        return( NULL );
    }

    rc = InitializeSecurityDescriptor( pSd, SECURITY_DESCRIPTOR_REVISION );
    if( !rc ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"Error initing security descriptor %d\n",GetLastError()));
        LocalFree( pSd );
        return( NULL );
    }

    SeWorldSid = (PSID)LocalAlloc(LMEM_FIXED, RtlLengthRequiredSid(1) );
    if( SeWorldSid == NULL ) {
        LocalFree( pSd );
        return( NULL );
    }

    RtlInitializeSid( SeWorldSid, &WorldSidAuthority, 1 );
    *(RtlSubAuthoritySid( SeWorldSid, 0 ))        = SECURITY_WORLD_RID;

    /*
     * Calculate the ACL size
     */
    AclSize = sizeof(ACL);
    AclSize += sizeof(ACCESS_ALLOWED_ACE);
    AclSize += (GetLengthSid( SeWorldSid ) - sizeof(DWORD));

    pAcl = LocalAlloc( LMEM_FIXED, AclSize );
    if( pAcl == NULL ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"Could not allocate memory\n"));
        LocalFree( SeWorldSid );
        LocalFree( pSd );
        return( NULL );
    }

    rc = InitializeAcl(
             pAcl,
             AclSize,
             ACL_REVISION
             );

    if( !rc ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"Error %d InitializeAcl\n",GetLastError()));
        LocalFree( pAcl );
        LocalFree( SeWorldSid );
        LocalFree( pSd );
        return( NULL );
    }

    /*
     * Add the access allowed ACE
     */
    rc = AddAccessAllowedAce(
                 pAcl,
                 ACL_REVISION,
                 FILE_ALL_ACCESS,
                 SeWorldSid
                 );

    if( !rc ) {
        Error = GetLastError();
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"***ERROR*** adding allow ACE %d for SeWorldSid\n",Error));
        LocalFree( pAcl );
        LocalFree( SeWorldSid );
        LocalFree( pSd );
        return( NULL );
    }

    rc = SetSecurityDescriptorDacl(
             pSd,
             TRUE,
             pAcl,
             FALSE
             );

    if( !rc ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"Error %d SetSecurityDescriptorDacl\n",GetLastError()));
        LocalFree( pAcl );
        LocalFree( SeWorldSid );
        LocalFree( pSd );
        return( NULL );
    }

// These are contained in the SD
//   LocalFree( pAcl );
//   LocalFree( SeWorldSid );

   // Caller can free SD
   return( pSd );
}


/*****************************************************************************
 *
 *  CreateWinStationDefaultSecurityDescriptor
 *
 *   Create the default security descriptor for WinStation for
 *   when we do not find one in the registry.
 *
 * ENTRY:   nothing
 *
 * EXIT:    a self-relative SD, or NULL
 *
 ****************************************************************************/

PSECURITY_DESCRIPTOR
CreateWinStationDefaultSecurityDescriptor()
{
    PSECURITY_DESCRIPTOR SecurityDescriptor;

#define DEFAULT_ACE_COUNT 2
    RTL_ACE_DATA AceData[DEFAULT_ACE_COUNT] =
    {
        { ACCESS_ALLOWED_ACE_TYPE, 0, 0, WINSTATION_ALL_ACCESS, &gSystemSid },

        { ACCESS_ALLOWED_ACE_TYPE, 0, 0, WINSTATION_ALL_ACCESS, &gAdminSid }

    };

    SecurityDescriptor = NULL;

    RtlCreateUserSecurityObject(AceData, DEFAULT_ACE_COUNT, gSystemSid,
            gSystemSid, FALSE, &WinStaMapping, &SecurityDescriptor);

    return( SecurityDescriptor );
}

/*****************************************************************************
 *
 *  BuildSystemOnlySecurityDescriptor
 *
 *   Create a security descriptor for system access only.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PSECURITY_DESCRIPTOR
BuildSystemOnlySecurityDescriptor()
{
    PACL  Dacl;
    ULONG Length;
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;

    Length = SECURITY_DESCRIPTOR_MIN_LENGTH +
             (ULONG)sizeof(ACL) +
             (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
             RtlLengthSid( gSystemSid );
    SecurityDescriptor = MemAlloc(Length);
    if (SecurityDescriptor == NULL) {
        goto bsosderror;
    }

    Dacl = (PACL)((PCHAR)SecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);

    Status = RtlCreateSecurityDescriptor(SecurityDescriptor,
                                         SECURITY_DESCRIPTOR_REVISION);
    if (Status != STATUS_SUCCESS) {
        goto bsosderror;
    }

    Status = RtlCreateAcl( Dacl, Length - SECURITY_DESCRIPTOR_MIN_LENGTH,
                           ACL_REVISION2);
    if (Status != STATUS_SUCCESS) {
        goto bsosderror;
    }

    Status = RtlAddAccessAllowedAce (
                 Dacl,
                 ACL_REVISION2,
                 PORT_ALL_ACCESS,
                 gSystemSid
                 );
    if (Status != STATUS_SUCCESS) {
        goto bsosderror;
    }

    Status = RtlSetDaclSecurityDescriptor (
                 SecurityDescriptor,
                 TRUE,
                 Dacl,
                 FALSE
                 );

    if (Status != STATUS_SUCCESS) {
        goto bsosderror;
    }

    return( SecurityDescriptor );

bsosderror:
    if (SecurityDescriptor) {
        MemFree(SecurityDescriptor);
    }

    return(NULL);
}

/*****************************************************************************
 *
 *  RpcGetClientLogonId
 *
 *   Get the logonid from the client who we should be impersonating.
 *
 * ENTRY:
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
RpcGetClientLogonId(
    PULONG pLogonId
    )
{
    BOOL          Result;
    HANDLE        TokenHandle;
    ULONG         LogonId, ReturnLength;
    NTSTATUS      Status = STATUS_SUCCESS;

    //
    // We should be impersonating the client, so we will get the
    // LogonId from out token.
    //

    Result = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_QUERY,
                 FALSE,              // Use impersonation
                 &TokenHandle
                 );

    if( Result ) {

        //
        // Use the CITRIX extension to GetTokenInformation to
        // return the LogonId from the token.
        //
        // This identifies which WinStation is making this request.
        //

        Result = GetTokenInformation(
                     TokenHandle,
                     (TOKEN_INFORMATION_CLASS)TokenSessionId,
                     &LogonId,
                     sizeof(LogonId),
                     &ReturnLength
                     );

        if( Result ) {
#if DBG
            if( ReturnLength != sizeof(LogonId) ) {
                DbgPrint("TERMSRV: RpcGetClientLogonId GetTokenInformation: ReturnLength %d != sizeof(LogonId)\n", ReturnLength );
            }
#endif
            *pLogonId = LogonId;
        }
        else {
            DBGPRINT(("TERMSRV: Error getting token LogonId information %d\n", GetLastError()));
            Status = STATUS_NO_IMPERSONATION_TOKEN;
        }
        CloseHandle( TokenHandle );
    }
    else {
        TRACE0(("SYSLIB: Error opening token %d\n", GetLastError()));
        Status = STATUS_NO_IMPERSONATION_TOKEN;
    }

    return( Status );
}




/*****************************************************************************
 *
 *  IsServiceLoggedAsSystem
 *
 *   Returns whether the termsrv process is running under SYSTEM
 *   security.
 *
 * ENTRY:
 *   None
 *     Comments
 *
 * EXIT:
 *   TRUE if running under system account. FALSE otherwise
 *
 ****************************************************************************/


BOOL
IsServiceLoggedAsSystem( VOID )
{
    BOOL   Result;
    HANDLE TokenHandle;

    //
    // Open the process token and check if System token. 
    //


    Result = OpenProcessToken(
                 GetCurrentProcess(),
                 TOKEN_QUERY,
                 &TokenHandle
                 );
    if (!Result) {
        DBGPRINT(("TERMSRV: IsServiceLoggedAsSystem : Could not open process token %d\n",GetLastError()));
        return( FALSE );
    }

    Result = IsSystemToken(TokenHandle);
    return Result;

}




/*****************************************************************************
 *
 *  IsCallerSystem
 *
 *   Returns whether the current thread is running under SYSTEM
 *   security.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
IsCallerSystem( VOID )
{
    BOOL   Result;
    HANDLE TokenHandle;

    //
    // Open the thread token and check if System token. 
    //


    Result = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_QUERY,
                 FALSE,              // Use impersonation
                 &TokenHandle
                 );

    if( !Result ) {
        TRACE0(("TERMSRV: IsCallerSystem: Could not open thread token %d\n",GetLastError()));
        return( FALSE );
    }
    
    Result = IsSystemToken(TokenHandle);
    return Result;

}

/*****************************************************************************
 *
 *  IsSystemToken
 *
 *   Returns whether the current token is running under SYSTEM
 *   security.
 *
 * ENTRY:
 *   Param1 Thread or process token
 *     Comments
 *
 * EXIT:
 *   TRUE if System token. FALSE otherwise.
 *
 ****************************************************************************/

BOOL
IsSystemToken( HANDLE TokenHandle )
{
    BOOL   Result;
    ULONG  ReturnLength, BufferLength;
    NTSTATUS Status;
    PTOKEN_USER pTokenUser = NULL;



    //Get primary account SID from token and test if local system SID.

    if (gSystemSid == NULL) {
        return FALSE;
    }

    ReturnLength = 0;

    Result = GetTokenInformation(
                 TokenHandle,
                 TokenUser,
                 NULL,
                 0,
                 &ReturnLength
                 );

    if( ReturnLength == 0 ) {
        TRACE0(("TERMSRV: IsCallerSystem: Error %d Getting TokenInformation\n",GetLastError()));
        CloseHandle( TokenHandle );
        return( FALSE );
    }

    BufferLength = ReturnLength;

    pTokenUser = MemAlloc( BufferLength );
    if( pTokenUser == NULL ) {
        TRACE0(("TERMSRV: IsCallerSystem: Error allocating %d bytes memory\n",BufferLength));
        CloseHandle( TokenHandle );
        return( FALSE );
    }

    Result = GetTokenInformation(
                 TokenHandle,
                 TokenUser,
                 pTokenUser,
                 BufferLength,
                 &ReturnLength
                 );

    CloseHandle( TokenHandle );

    if( !Result ) {
        TRACE0(("TERMSRV: IsCallerSystem: Error %d Getting TokenInformation on buffer\n",GetLastError()));
        MemFree( pTokenUser );
        return( FALSE );
    }

    if( RtlEqualSid( pTokenUser->User.Sid, gSystemSid) ) {
        MemFree( pTokenUser );
        return( TRUE );
    }
    else {
#if DBGTRACE
        BOOL  OK;
        DWORD cDomain;
        DWORD cUserName;
        WCHAR Domain[256];
        WCHAR UserName[256];
        SID_NAME_USE UserSidType;

        cUserName = sizeof(UserName)/sizeof(WCHAR);
        cDomain = sizeof(Domain)/sizeof(WCHAR);

        // Now print its account
        OK = LookupAccountSidW(
                 NULL, // Computer Name
                 pTokenUser->User.Sid,
                 UserName,
                 &cUserName,
                 Domain,
                 &cDomain,
                 &UserSidType
                 );

        DBGPRINT(("TERMSRV: IsCallerSystem: Caller SID is not SYSTEM\n"));

        if( OK ) {
            DBGPRINT(("TERMSRV: IsCallerSystem: CallerAccount Name %ws, Domain %ws, Type %d, SidSize %d\n",UserName,Domain,UserSidType));
        }
        else {
            extern void CtxDumpSid( PSID, PCHAR, PULONG ); // syslib:dumpsd.c

            DBGPRINT(("TERMSRV: Could not lookup callers account Error %d\n",GetLastError()));
            CtxDumpSid( pTokenUser->User.Sid, NULL, NULL );
        }
#else
        TRACE0(("TERMSRV: IsCallerSystem: Caller SID is not SYSTEM\n"));
#endif
        MemFree( pTokenUser );
        return( FALSE );
    }

    // NOTREACHED
}


/*****************************************************************************
 *
 *  IsCallerAdmin
 *
 *   Returns whether the current thread is running under SYSTEM
 *   security.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
IsCallerAdmin( VOID )
{
    BOOL   FoundAdmin;
    NTSTATUS Status;

    //
    //  If the admin sid didn't initialize, the service would not have started.
    //

    ASSERT(gAdminSid != NULL);

    if (!CheckTokenMembership(NULL, gAdminSid, &FoundAdmin)) {
        FoundAdmin = FALSE;
    }

#if DBG
    if (!FoundAdmin)
    {
        DBGPRINT(("TERMSRV: IsCallerAdmin: Caller SID is not ADMINISTRATOR\n"));
    }
#endif

    return(FoundAdmin);
}

/*****************************************************************************
 *
 *  IsCallerAnonymous
 *
 *   Returns whether the current thread is running under ANONYMOUS_LOGON
 *   account.
 *
 * ENTRY:
 *   NONE
 *     
 *
 * EXIT:
 *   TRUE - caller is ANONYMOUS or error happened.
 *   FALSE - caller is not ANONYMOUS.
 *
 ****************************************************************************/

BOOL
IsCallerAnonymous( VOID )
{
    BOOL   Result;
    HANDLE TokenHandle;
    ULONG  ReturnLength, BufferLength;
    NTSTATUS Status;
    PTOKEN_USER pTokenUser = NULL;
    
    //Get primary account SID from token and test if anonymous SID.
    ASSERT(gAnonymousSid);

    if (gAnonymousSid == NULL) {
        return ( TRUE );
    }

    //
    // Open the thread token. 
    //

    Result = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_QUERY,
                 FALSE,              // Use impersonation
                 &TokenHandle
                 );

    if( !Result ) {
        TRACE0(("TERMSRV: IsCallerAnonymous: Could not open thread token %d\n",GetLastError()));
        return( TRUE );
    }

    ReturnLength = 0;

    Result = GetTokenInformation(
                 TokenHandle,
                 TokenUser,
                 NULL,
                 0,
                 &ReturnLength
                 );

    if( ReturnLength == 0 ) {
        TRACE0(("TERMSRV: IsCallerAnonymous: Error %d Getting TokenInformation\n",GetLastError()));
        CloseHandle( TokenHandle );
        return( TRUE );
    }

    BufferLength = ReturnLength;

    pTokenUser = MemAlloc( BufferLength );
    if( pTokenUser == NULL ) {
        TRACE0(("TERMSRV: IsCallerAnonymous: Error allocating %d bytes memory\n",BufferLength));
        CloseHandle( TokenHandle );
        return( TRUE );
    }

    Result = GetTokenInformation(
                 TokenHandle,
                 TokenUser,
                 pTokenUser,
                 BufferLength,
                 &ReturnLength
                 );

    CloseHandle( TokenHandle );

    if( !Result ) {
        TRACE0(("TERMSRV: IsCallerAnonymous: Error %d Getting TokenInformation on buffer\n",GetLastError()));
        MemFree( pTokenUser );
        return( TRUE );
    }

    if( RtlEqualSid( pTokenUser->User.Sid, gAnonymousSid) ) {
        MemFree( pTokenUser );
        return( TRUE );
    }
    else {
        MemFree( pTokenUser );
        return( FALSE );
    }

}

/*******************************************************************************
 *
 *  IsCallerAllowedPasswordAccess
 *
 *  Is the calling process allowed to view the password field?
 *
 *     The caller must be SYSTEM context, IE: WinLogon.
 *
 * ENTRY:
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

BOOLEAN
IsCallerAllowedPasswordAccess()
{
    UINT  LocalFlag;
    RPC_STATUS RpcStatus;

    //
    // Only a SYSTEM mode caller (IE: Winlogon) is allowed
    // to query this value.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        RpcRevertToSelf();
        return( FALSE );
    }

    if( !LocalFlag ) {
        RpcRevertToSelf();
        return( FALSE );
    }

    if( !IsCallerSystem() ) {
        RpcRevertToSelf();
        return( FALSE );
    }

    RpcRevertToSelf();
    return( TRUE );
}

BOOL
ConfigurePerSessionSecurity(
    PWINSTATION pWinStation
    )

/*++

Routine Description:

    Configure security for the new session. This sets the
    per session \Sessions\<x>\BasedNamedObjects and
    \Sessions\<x>\DosDevices with an ACE that allows the
    currently logged on user to be able to create objects
    in their sessions directories.

    This is called by WinStationNotifyLogon() after the user
    has been authenticated. This must be called before the
    newly logged on user can create any WIN32 objects
    (events, semaphores, etc.), or DosDevices.

Arguments:

   Arg - desc

Return Value:

   NTSTATUS - STATUS_SUCCESS no error

   !STATUS_SUCCESS NT Status code

--*/

{
    BOOL Result;
    BOOL bRet = TRUE;
    DWORD Len;
    PWCHAR pBuf;
    WCHAR IdBuf[MAX_PATH];
    static ProtectionMode = 0;
    static GotProtectionMode = FALSE;
    PSID CreatorOwnerSid;
    PSID LocalSystemSid;
    SID_IDENTIFIER_AUTHORITY CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    


#define SESSIONS_ROOT L"\\Sessions\\"
#define BNO_PATH      L"\\BaseNamedObjects"
#define DD_PATH       L"\\DosDevices"

    //
    // We leave the consoles default NT permissions
    // alone.
    //
    if( pWinStation->LogonId == 0 ) {
        return TRUE;
    }

    // Get the Protection mode from Session Manager\ProtectionMode
    if( !GotProtectionMode ) {

        HANDLE KeyHandle;
        NTSTATUS Status;
        ULONG ResultLength;
        WCHAR ValueBuffer[ 32 ];
        UNICODE_STRING NameString;
        OBJECT_ATTRIBUTES ObjectAttributes;
        PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;


        GotProtectionMode = TRUE;

        RtlInitUnicodeString( &NameString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );

        InitializeObjectAttributes(
            &ObjectAttributes,
            &NameString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtOpenKey(
                     &KeyHandle,
                     KEY_READ,
                     &ObjectAttributes
                     );

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString( &NameString, L"ProtectionMode" );
            KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
            Status = NtQueryValueKey(
                         KeyHandle,
                         &NameString,
                         KeyValuePartialInformation,
                         KeyValueInformation,
                         sizeof( ValueBuffer ),
                         &ResultLength
                         );

            if (NT_SUCCESS(Status)) {
                if (KeyValueInformation->Type == REG_DWORD &&
                    *(PULONG)KeyValueInformation->Data) {
                    ProtectionMode = *(PULONG)KeyValueInformation->Data;
                }
            }

            NtClose( KeyHandle );
        }
    }

    // Nothing locked down
    if( (ProtectionMode & 0x00000003) == 0 ) {
        return TRUE;
    }

    wsprintf( IdBuf, L"%d", pWinStation->LogonId );

    Len = wcslen( IdBuf ) + wcslen( SESSIONS_ROOT ) + wcslen( BNO_PATH ) + 2;

    pBuf = LocalAlloc( LMEM_FIXED, Len*sizeof(WCHAR) );
    if( pBuf == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    wsprintf( pBuf, L"%s%s%s", SESSIONS_ROOT, IdBuf, BNO_PATH );

    Result = AddAccessToDirectory(
                 pBuf,
                 GENERIC_ALL,
                 pWinStation->pUserSid
                 );

    if( !Result ) bRet = FALSE;



    if (NT_SUCCESS(RtlAllocateAndInitializeSid(
                 &CreatorAuthority,
                 1,
                 SECURITY_CREATOR_OWNER_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &CreatorOwnerSid
                 ))) {

       Result = AddAccessToDirectory(
                    pBuf,
                    GENERIC_ALL,
                    CreatorOwnerSid
                    );

       if( !Result ) {
          bRet = FALSE;
       }

       RtlFreeSid( CreatorOwnerSid );

    }



    if (NT_SUCCESS(RtlAllocateAndInitializeSid(
                 &NtAuthority,
                 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &LocalSystemSid
                 ))) {

       Result = AddAccessToDirectory(
                    pBuf,
                    GENERIC_ALL,
                    LocalSystemSid
                    );

       if( !Result ) {
          bRet = FALSE;
       }

       RtlFreeSid( LocalSystemSid );

    }

    LocalFree( pBuf );

    Len = wcslen( IdBuf ) + wcslen( SESSIONS_ROOT ) + wcslen( DD_PATH ) + 2;

    pBuf = LocalAlloc( LMEM_FIXED, Len*sizeof(WCHAR) );
    if( pBuf == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    wsprintf( pBuf, L"%s%s%s", SESSIONS_ROOT, IdBuf, DD_PATH );

    Result = AddAccessToDirectory(
                 pBuf,
                 GENERIC_READ | GENERIC_EXECUTE,
                 pWinStation->pUserSid
                 );

    if( !Result ) bRet = FALSE;

    LocalFree( pBuf );

    return bRet;
}

BOOL
AddAccessToDirectory(
    PWCHAR pPath,
    DWORD  NewAccess,
    PSID   pSid
    )

/*++

Routine Description:

    Add Access to the given NT object directory path for
    the supplied SID.

    This is done by adding a new AccessAllowedAce to
    the DACL on the object directory.

Arguments:

   Arg - desc

Return Value:

   TRUE - Success

   FALSE - Error in GetLastError()

--*/

{
    BOOL Result;
    HANDLE hDir;
    NTSTATUS Status;
    ULONG LengthNeeded;
    OBJECT_ATTRIBUTES Obja;
    PSECURITY_DESCRIPTOR pSd,pSelfSD;
    PACL pDacl;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, pPath );

    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
        NULL,
        NULL // Sd
        );

    Status = NtCreateDirectoryObject(
                 &hDir,
                 DIRECTORY_ALL_ACCESS,
                 &Obja
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("AddAccessToDirectory: NtCreateDirectoryObject 0x%x :%ws:\n",Status,pPath));
        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }


    // Get SD from sessions directory
    Status = NtQuerySecurityObject(
                 hDir,
                 OWNER_SECURITY_INFORMATION | 
                 GROUP_SECURITY_INFORMATION |
                 DACL_SECURITY_INFORMATION,
                 NULL,         // pSd
                 0,            // Length
                 &LengthNeeded
                 );

    // ? bad handle
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        DBGPRINT(("AddAccessToDirectory: NtQuerySecurityObject 0x%x :%ws:\n",Status,pPath));
        SetLastError(RtlNtStatusToDosError(Status));
        NtClose( hDir );
        return FALSE;
    }

    pSd = LocalAlloc(LMEM_FIXED, LengthNeeded );
    if( pSd == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        NtClose( hDir );
        return FALSE;
    }

    Status = NtQuerySecurityObject(
                 hDir,
                 OWNER_SECURITY_INFORMATION | 
                 GROUP_SECURITY_INFORMATION |
                 DACL_SECURITY_INFORMATION,
                 pSd,
                 LengthNeeded,
                 &LengthNeeded
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("AddAccessToDirectory: NtQuerySecurityObject 0x%x :%ws:\n",Status,pPath));
        SetLastError(RtlNtStatusToDosError(Status));
        LocalFree( pSd );
        NtClose( hDir );
        return FALSE;
    }


    Result = AddAceToSecurityDescriptor(
                 &pSd,
                 &pDacl,
                 NewAccess,
                 pSid,
                 TRUE
                 );

    if( !Result ) {
        DBGPRINT(("AddAccessToDirectory: AddAceToSecurityDescriptor failure :%ws:\n",pPath));
        CleanUpSD(pSd);
        NtClose( hDir );
        return FALSE;
    }

    Result = AddAceToSecurityDescriptor(
                 &pSd,
                 &pDacl,
                 NewAccess,
                 pSid,
                 FALSE
                 );

    if( !Result ) {
        DBGPRINT(("AddAccessToDirectory: AddAceToSecurityDescriptor failure :%ws:\n",pPath));
        CleanUpSD(pSd);
        NtClose( hDir );
        return FALSE;
    }
    
    Result = FALSE;
    // make sure that pSd is not self-relative already
    if (!(((PISECURITY_DESCRIPTOR)pSd)->Control & SE_SELF_RELATIVE)) {
       Result = AbsoluteToSelfRelativeSD (pSd, &pSelfSD, NULL);
       CleanUpSD(pSd);
       if ( !Result ) {
          NtClose( hDir);
          return FALSE;
       }
    }

    // Put a self-relative SD on session directory (note only self-relative sd are allowed)
    Status = NtSetSecurityObject(
                 hDir,
                 DACL_SECURITY_INFORMATION,
                 pSelfSD
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("AddAccessToDirectory: NtSetSecurityObject 0x%x :%ws:\n",Status,pPath));
        SetLastError(RtlNtStatusToDosError(Status));
        CleanUpSD(pSelfSD);
        NtClose( hDir );
        return FALSE;
    }

    // Result could only be false if the sd is already self-relative
    if (Result) {
       CleanUpSD(pSelfSD);
    }
    

    // Now update any objects in the directory already
    Status = AddAccessToDirectoryObjects(
        hDir,
        NewAccess,
        pSid
        
        );

    NtClose( hDir );

    // AddAccessToDirectoryObjects() may return out of memory.
    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
AddAceToSecurityDescriptor(
    PSECURITY_DESCRIPTOR *ppSd,
    PACL                 *ppDacl,
    DWORD                Access,
    PSID                 pSid,
    BOOLEAN              InheritOnly
    )

/*++

Routine Description:

   Adds the given ACE/SID to the security descriptor. It will
   re-allocate the security descriptor if more room is needed.

Arguments:

   ppSD - Pointer to PSECURITY_DESCRIPTOR

   ppDacl - Pointer to PACL, returns the newly created DACL for freeing
            after the security has been set.

   Access - Access mask for ACE

   pSid - Pointer to Sid this ACE is representing

Return Value:

   TRUE  - Success
   FALSE - Error

--*/

{
    ULONG i;
    BOOL Result;
    BOOL DaclPresent;
    BOOL DaclDefaulted;
    DWORD Length;
    DWORD NewAceLength, NewAclLength;
    PACE_HEADER OldAce;
    PACE_HEADER NewAce;
    ACL_SIZE_INFORMATION AclInfo;
    PACL Dacl = NULL;
    PACL NewDacl = NULL;
    PACL NewAceDacl = NULL;
    PSECURITY_DESCRIPTOR NewSD = NULL;
    PSECURITY_DESCRIPTOR OldSD = NULL;
    BOOL SDAllocated = FALSE;

    OldSD = *ppSd;
    *ppDacl = NULL;

    /*
     * Convert SecurityDescriptor to absolute format. It generates
     * a new SecurityDescriptor for its output which we must free.
     */

    if (((PISECURITY_DESCRIPTOR)OldSD)->Control & SE_SELF_RELATIVE) {

        Result = SelfRelativeToAbsoluteSD( OldSD, &NewSD, NULL );
        if ( !Result ) {
            DBGPRINT(("Could not convert to AbsoluteSD %d\n",GetLastError()));
            return( FALSE );
        }
        SDAllocated = TRUE;

    } else {
    
        NewSD = OldSD;
    }
    // Must get DACL pointer again from new (absolute) SD
    Result = GetSecurityDescriptorDacl(
                 NewSD,
                 &DaclPresent,
                 &Dacl,
                 &DaclDefaulted
                 );
    if( !Result ) {
        DBGPRINT(("Could not get Dacl %d\n",GetLastError()));
        goto ErrorCleanup;
    }

    //
    // If no DACL, no need to add the user since no DACL
    // means all accesss
    //
    if( !DaclPresent ) {
        DBGPRINT(("SD has no DACL, Present %d, Defaulted %d\n",DaclPresent,DaclDefaulted));
        if (SDAllocated && NewSD) {
           CleanUpSD(NewSD);
        }
        return( TRUE );
    }

    //
    // Code can return DaclPresent, but a NULL which means
    // a NULL Dacl is present. This allows no access to the object.
    //
    if( Dacl == NULL ) {
        DBGPRINT(("SD has NULL DACL, Present %d, Defaulted %d\n",DaclPresent,DaclDefaulted));
        goto ErrorCleanup;
    }

    // Get the current ACL's size
    Result = GetAclInformation(
                 Dacl,
                 &AclInfo,
                 sizeof(AclInfo),
                 AclSizeInformation
                 );
    if( !Result ) {
        DBGPRINT(("Error GetAclInformation %d\n",GetLastError()));
        goto ErrorCleanup;
    }

    //
    // Create a new ACL to put the new access allowed ACE on
    // to get the right structures and sizes.
    //
    NewAclLength = sizeof(ACL) +
                   sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) +
                   GetLengthSid( pSid );

    NewAceDacl = LocalAlloc( LMEM_FIXED, NewAclLength );
    if ( NewAceDacl == NULL ) {
        DBGPRINT(("Error LocalAlloc %d bytes\n",NewAclLength));
        goto ErrorCleanup;
    }

    Result = InitializeAcl( NewAceDacl, NewAclLength, ACL_REVISION );
    if( !Result ) {
        DBGPRINT(("Error Initializing Acl %d\n",GetLastError()));
        goto ErrorCleanup;
    }

    Result = AddAccessAllowedAce(
                 NewAceDacl,
                 ACL_REVISION,
                 Access,
                 pSid
                 );
    if( !Result ) {
        DBGPRINT(("Error adding Ace %d\n",GetLastError()));
        goto ErrorCleanup;
    }

    TRACE0(("Added 0x%x Access to ACL\n",Access));

    Result = GetAce( NewAceDacl, 0, &NewAce );
    if( !Result ) {
        DBGPRINT(("Error getting Ace %d\n",GetLastError()));
        goto ErrorCleanup;
    }

    /*
     * Allocate new DACL and copy existing ACE list
     */
    Length = AclInfo.AclBytesInUse + NewAce->AceSize;
    NewDacl = LocalAlloc( LMEM_FIXED, Length );
    if( NewDacl == NULL ) {
        DBGPRINT(("Error LocalAlloc %d bytes\n",Length));
        goto ErrorCleanup;
    }

    Result = InitializeAcl( NewDacl, Length, ACL_REVISION );
    if( !Result ) {
        DBGPRINT(("Error Initializing Acl %d\n",GetLastError()));
        goto ErrorCleanup;
    }


    if (InheritOnly) {
        /*
         * Make this an inherit ACE
         */
        NewAce->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
 
    } 

    /*
     * Insert new ACE at the front of the DACL
     */
    Result = AddAce( NewDacl, ACL_REVISION, 0, NewAce, NewAce->AceSize );
    if( !Result ) {
        DBGPRINT(("Error Adding New Ace to Acl %d\n",GetLastError()));
        goto ErrorCleanup;
    }

    /*
     * Now put the ACE's on the old Dacl to the new Dacl
     */
    for ( i = 0; i < AclInfo.AceCount; i++ ) {

        Result = GetAce( Dacl, i, &OldAce );
        if( !Result ) {
            DBGPRINT(("Error getting old Ace from Acl %d\n",GetLastError()));
            goto ErrorCleanup;
        }

        Result = AddAce( NewDacl, ACL_REVISION, i+1, OldAce, OldAce->AceSize );
        if( !Result ) {
            DBGPRINT(("Error setting old Ace to Acl %d\n",GetLastError()));
            goto ErrorCleanup;
        }
    }

    /*
     * Set new DACL for Security Descriptor
     */
    Result = SetSecurityDescriptorDacl(
                 NewSD,
                 TRUE,
                 NewDacl,
                 FALSE
                 );
    if( !Result ) {
        DBGPRINT(("Error setting New Dacl to SD %d\n",GetLastError()));
        goto ErrorCleanup;
    } 

    // NewSD is in absolute format and it's dacl is being replaced by NewDacl
    // thus it makes perfect sense to delete the old dacl
    if (Dacl) {
       LocalFree( Dacl );
    }

    // If we allocated the SD, release the callers old security descriptor,
    // otherwise, release the old SDs DACL.
    if (SDAllocated) {
       CleanUpSD(OldSD);
    }

    // Release the template Ace Dacl
    LocalFree( NewAceDacl );

    *ppSd = NewSD;
    *ppDacl = NewDacl;

    return( TRUE );


ErrorCleanup:

        if (NewDacl) {
           LocalFree( NewDacl );
        }
        if (NewAceDacl) {
           LocalFree( NewAceDacl );
        }
        if (SDAllocated && NewSD) {
           CleanUpSD( NewSD );
        }

        return( FALSE );
}

BOOL
AbsoluteToSelfRelativeSD(
    PSECURITY_DESCRIPTOR SecurityDescriptorIn,
    PSECURITY_DESCRIPTOR *SecurityDescriptorOut,
    PULONG ReturnedLength
    )
/*++

Routine Description:

    Make a security descriptor self-relative

Return Value:

   TRUE - Success
   FALSE - Failure

--*/

{
    BOOL Result;
    PSECURITY_DESCRIPTOR pSD;
    DWORD dwLength = 0;

    /*
     * Determine buffer size needed to convert absolute to self-relative SD .
     * We use try-except here since if the input security descriptor value
     * is sufficiently messed up, it is possible for this call to trap.
     */
    try {
        Result = MakeSelfRelativeSD(
                     SecurityDescriptorIn,
                     NULL,
                     &dwLength);

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        Result = FALSE;
    }

    if ( Result || (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ) {
        DBGPRINT(("SUSERVER: AbsoluteToSelfRelativeSD, Error %d\n",GetLastError()));
        return( FALSE );
    }

    /*
     * Allocate memory for the self-relative SD
     */
    pSD = LocalAlloc( LMEM_FIXED, dwLength );
    if ( pSD == NULL )
        return( FALSE );

    /*
     * Now convert absolute SD to self-relative format.
     * We use try-except here since if the input security descriptor value
     * is sufficiently messed up, it is possible for this call to trap.
     */
    try {
        Result = MakeSelfRelativeSD(SecurityDescriptorIn,
                                    pSD, 
                                    &dwLength);

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        Result = FALSE;
    }

    if ( !Result ) {
        DBGPRINT(("SUSERVER: SelfRelativeToAbsoluteSD, Error %d\n",GetLastError()));
        LocalFree( pSD );
        return( FALSE );
    }

    *SecurityDescriptorOut = pSD;

    if ( ReturnedLength )
        *ReturnedLength = dwLength;

    return( TRUE );
}



BOOL
SelfRelativeToAbsoluteSD(
    PSECURITY_DESCRIPTOR SecurityDescriptorIn,
    PSECURITY_DESCRIPTOR *SecurityDescriptorOut,
    PULONG ReturnedLength
    )

/*++

Routine Description:

    Make a security descriptor absolute

Arguments:

   Arg - desc

Return Value:

   TRUE - Success
   FALSE - Failure

--*/

{
    BOOL Result;
    PACL pDacl, pSacl;
    PSID pOwner, pGroup;
    PSECURITY_DESCRIPTOR pSD;
    ULONG SdSize, DaclSize, SaclSize, OwnerSize, GroupSize;

    /*
     * Determine buffer size needed to convert self-relative SD to absolute.
     * We use try-except here since if the input security descriptor value
     * is sufficiently messed up, it is possible for this call to trap.
     */
    try {
        SdSize = DaclSize = SaclSize = OwnerSize = GroupSize = 0;
        Result = MakeAbsoluteSD(
                     SecurityDescriptorIn,
                     NULL, &SdSize,
                     NULL, &DaclSize,
                     NULL, &SaclSize,
                     NULL, &OwnerSize,
                     NULL, &GroupSize
                     );

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        Result = FALSE;
    }

    if ( Result || (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ) {
        DBGPRINT(("SUSERVER: SelfRelativeToAbsoluteSD, Error %d\n",GetLastError()));
        return( FALSE );
    }

    /*
     * Allocate memory for the absolute SD and setup various pointers
     */
    pSD = NULL;
    pDacl = NULL;
    pSacl = NULL;
    pOwner = NULL;
    pGroup = NULL;
    if (SdSize>0) {
       pSD = LocalAlloc( LMEM_FIXED, SdSize);
       if ( pSD == NULL )
          goto error;
    }

    if (DaclSize>0) {
       pDacl = LocalAlloc( LMEM_FIXED, DaclSize);
       if ( pDacl == NULL ){
          goto error;
       }
    }

    if (SaclSize>0) {
       pSacl = LocalAlloc( LMEM_FIXED, SaclSize);
       if ( pSacl == NULL ){
          goto error;
       }
    }

    if (OwnerSize>0) {
       pOwner = LocalAlloc( LMEM_FIXED, OwnerSize);
       if ( pOwner == NULL ){
          goto error;
       }
    }

    if (GroupSize>0) {
       pGroup = LocalAlloc( LMEM_FIXED, GroupSize);
       if ( pGroup == NULL ){
          goto error;
       }
    }

    //pDacl = (PACL)((PCHAR)pSD + SdSize);
    ///pSacl = (PACL)((PCHAR)pDacl + DaclSize);
    //pOwner = (PSID)((PCHAR)pSacl + SaclSize);
    //pGroup = (PSID)((PCHAR)pOwner + OwnerSize);

    /*
     * Now convert self-relative SD to absolute format.
     * We use try-except here since if the input security descriptor value
     * is sufficiently messed up, it is possible for this call to trap.
     */
    try {
        Result = MakeAbsoluteSD(
                     SecurityDescriptorIn,
                     pSD, &SdSize,
                     pDacl, &DaclSize,
                     pSacl, &SaclSize,
                     pOwner, &OwnerSize,
                     pGroup, &GroupSize
                     );

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        Result = FALSE;
    }

    if ( !Result ) {
        DBGPRINT(("SUSERVER: SelfRelativeToAbsoluteSD, Error %d\n",GetLastError()));
        goto error;
    }

    *SecurityDescriptorOut = pSD;

    if ( ReturnedLength )
        *ReturnedLength = SdSize + DaclSize + SaclSize + OwnerSize + GroupSize;

    return( TRUE );


error:
    if (pSD) {
       LocalFree(pSD);
    }
    if (pDacl) {
       LocalFree(pDacl);
    }
    if (pSacl) {
       LocalFree(pSacl);
    }
    if (pOwner) {
       LocalFree(pOwner);
    }
    if (pGroup) {
       LocalFree(pGroup);
    }
    return( FALSE );
}

VOID
CleanUpSD(
   PSECURITY_DESCRIPTOR pSD
   )
/*++

Routine Description:
   
   delete the security descriptor

Arguments:

   Arg - desc

Return Value:

   TRUE - Success

   FALSE - Error in GetLastError()

--*/
{

   if (pSD) {
      if (((PISECURITY_DESCRIPTOR)pSD)->Control & SE_SELF_RELATIVE){
         LocalFree( pSD );
      }else{
         ULONG_PTR Dacl,Owner,Group,Sacl;
         ULONG_PTR SDTop = (ULONG_PTR)pSD;
         ULONG_PTR SDBottom = LocalSize(pSD)+SDTop;

         Dacl  = (ULONG_PTR)((PISECURITY_DESCRIPTOR)pSD)->Dacl;
         Owner = (ULONG_PTR)((PISECURITY_DESCRIPTOR)pSD)->Owner;
         Group = (ULONG_PTR)((PISECURITY_DESCRIPTOR)pSD)->Group;
         Sacl  = (ULONG_PTR)((PISECURITY_DESCRIPTOR)pSD)->Sacl;

         // make sure that the dacl, owner, group, sacl are not within the SD boundary

         if (Dacl) {
            if (Dacl>=SDBottom|| Dacl<SDTop) {
               LocalFree(((PISECURITY_DESCRIPTOR)pSD)->Dacl);
            }
         }

         if (Owner) {
            if (Owner>=SDBottom || Owner<SDTop) {
               LocalFree(((PISECURITY_DESCRIPTOR)pSD)->Owner);
            }
         }
         
         if (Group) {
            if (Group>=SDBottom || Group<SDTop) {
               LocalFree(((PISECURITY_DESCRIPTOR)pSD)->Group);
            }
         }

         if (Sacl) {
            if (Sacl>=SDBottom || Sacl<SDTop) {
               LocalFree(((PISECURITY_DESCRIPTOR)pSD)->Sacl);
            }
         }

         LocalFree(pSD);
      }
   }

}


NTSTATUS
AddAccessToDirectoryObjects(
    HANDLE DirectoryHandle,
    DWORD  NewAccess,
    PSID   pSid
    )

/*++

Routine Description:

    Add Access to the objects in the given NT object directory
    for the supplied SID.

    This is done by adding a new AccessAllowedAce to the DACL's
    on the objects in the directory.

Arguments:

   Arg - desc

Return Value:

   TRUE - Success

   FALSE - Error in GetLastError()

--*/

{
    BOOL  Result;
    ULONG Context;
    HANDLE LinkHandle;
    NTSTATUS Status;
    BOOLEAN RestartScan;
    ULONG ReturnedLength;
    ULONG LengthNeeded;
    OBJECT_ATTRIBUTES Attributes;
    PSECURITY_DESCRIPTOR pSd,pSelfSD;
    PACL pDacl;
    POBJECT_DIRECTORY_INFORMATION pDirInfo;
    RestartScan = TRUE;
    Context = 0;
    
    pDirInfo = (POBJECT_DIRECTORY_INFORMATION) LocalAlloc(LMEM_FIXED, 4096  );

    if ( !pDirInfo)
    {
        return STATUS_NO_MEMORY;
    }

    while (TRUE) {
        Status = NtQueryDirectoryObject( DirectoryHandle,
                                         pDirInfo,
                                         4096 ,
                                         TRUE,
                                         RestartScan,
                                         &Context,
                                         &ReturnedLength
                                       );
        
        RestartScan = FALSE;

        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status )) {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            break;
        }

        // SymbolicLink
        if (!wcscmp( pDirInfo->TypeName.Buffer, L"SymbolicLink" )) {

            InitializeObjectAttributes(
                &Attributes,
                &pDirInfo->Name,
                OBJ_CASE_INSENSITIVE,
                DirectoryHandle,
                NULL
                );

            Status = NtOpenSymbolicLinkObject(
                         &LinkHandle,
                         SYMBOLIC_LINK_ALL_ACCESS,
                         &Attributes
                         );
        }
        else {
            continue;
        }

        if (!NT_SUCCESS( Status )) {
           continue;
        }

        // GetSecurity
        Status = NtQuerySecurityObject(
                     LinkHandle,
                     OWNER_SECURITY_INFORMATION | 
                     GROUP_SECURITY_INFORMATION |
                     DACL_SECURITY_INFORMATION,
                     NULL,         // pSd
                     0,            // Length
                     &LengthNeeded
                     );

        if( Status != STATUS_BUFFER_TOO_SMALL ) {
            DBGPRINT(("NtQuerySecurityObject 0x%x\n",Status));
            NtClose( LinkHandle );
            continue;
        }

        pSd = LocalAlloc(LMEM_FIXED, LengthNeeded );
        if( pSd == NULL ) {
            NtClose( LinkHandle );
            continue;
        }

        Status = NtQuerySecurityObject(
                     LinkHandle,
                     OWNER_SECURITY_INFORMATION | 
                     GROUP_SECURITY_INFORMATION |
                     DACL_SECURITY_INFORMATION,
                     pSd,          // pSd
                     LengthNeeded, // Length
                     &LengthNeeded
                     );

        if( !NT_SUCCESS(Status) ) {
            DBGPRINT(("NtQuerySecurityObject 0x%x\n",Status));
            NtClose( LinkHandle );
            LocalFree( pSd );
            continue;
        }

        // Mung ACL
        Result = AddAceToSecurityDescriptor(
                     &pSd,
                     &pDacl,
                     NewAccess,
                     pSid,
                     FALSE
                     );

        if( !Result ) {
            NtClose( LinkHandle );
            CleanUpSD(pSd);
            continue;
        }

        // make sure that pSd is not self-relative already.
        if (!(((PISECURITY_DESCRIPTOR)pSd)->Control & SE_SELF_RELATIVE)) {
           if (!AbsoluteToSelfRelativeSD (pSd, &pSelfSD, NULL)){
              NtClose( LinkHandle );
              CleanUpSD(pSd);
              continue;
           }
        }

        // SetSecurity only accepts self-relative formats
        Status = NtSetSecurityObject(
                     LinkHandle,
                     DACL_SECURITY_INFORMATION,
                     pSelfSD
                     );
 
        NtClose( LinkHandle );

        //
        //  These must be freed regardless of the success of
        //  NtSetSecurityObject
        //
        // pDacl lives inside of pSd
        CleanUpSD(pSd);
        CleanUpSD(pSelfSD);

    } // end while


    LocalFree( pDirInfo );

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *
 *  ReInitializeSecurityWorker
 *
 *  ReInitialize the default WinStation security descriptor and force all active
 * sessions to update their security descirptors
 *
 * ENTRY:
 *   nothing
 *
 * EXIT:
 *   STATUS_SUCCESS
 *
 ******************************************************************************/

NTSTATUS
ReInitializeSecurityWorker( VOID )
{
    NTSTATUS Status;
    ULONG WinStationCount;
    ULONG ByteCount;
    WINSTATIONNAME * pWinStationName;
    ULONG i;
    PWINSTATION pWinStation;



    /*
     * Update Default Security Descriptor
     */

    RtlAcquireResourceExclusive(&WinStationSecurityLock, TRUE);
    WinStationSecurityInit();
    RtlReleaseResource(&WinStationSecurityLock);




    /*
     *  Get the number of WinStations in the registry 
     */
    WinStationCount = 0;
    Status = IcaRegWinStationEnumerate( &WinStationCount, NULL, &ByteCount );
    if ( !NT_SUCCESS(Status) ) 
        return Status;

    /*
     *  Allocate a buffer for the WinStation names
     */
    pWinStationName = MemAlloc( ByteCount );
    if ( pWinStationName == NULL ) {
        return STATUS_NO_MEMORY;
    }

    /*
     * Get list of WinStation names from registry
     */
    WinStationCount = (ULONG) -1;
    Status = IcaRegWinStationEnumerate( &WinStationCount, 
                                        (PWINSTATIONNAME)pWinStationName, 
                                        &ByteCount );
    if ( !NT_SUCCESS(Status) ) {
        MemFree( pWinStationName );
        return Status;
    }


    /*
     *  Check if any WinStations need to be created or reset
     */
    for ( i = 0; i < WinStationCount; i++ ) {

        /*
         * Ignore console WinStation 
         */
        if ( _wcsicmp( pWinStationName[i], L"Console" ) ) {

            /*
             * If this WinStation exists, then see if the Registry data
             * has changed.  If so, then reset the WinStation.
             */
            if ( pWinStation = FindWinStationByName( pWinStationName[i], FALSE ) ) {


                    /*
                     * Winstations should update their security 
                     * descriptors.
                     */

                RtlAcquireResourceExclusive(&WinStationSecurityLock, TRUE);
                ReadWinStationSecurityDescriptor( pWinStation );
                RtlReleaseResource(&WinStationSecurityLock);
                    
                ReleaseWinStation( pWinStation );

            }
        }
    }

    /*
     *  Free buffers
     */
    MemFree( pWinStationName );

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\lscore\session.h ===
/*
 *  Session.h
 *
 *  Author: BreenH
 *
 *  The Session class provides a level of separation between the winstation
 *  structure and the policy modules. It is just a wrapper class; it does not
 *  create or destroy winstation stuctures.
 */

#ifndef __LC_SESSION_H__
#define __LC_SESSION_H__


/*
 *  Typedefs
 */

typedef struct {
    CRITICAL_SECTION CritSec;
    class CPolicy *pPolicy;
    ULONG ulClientProtocolVersion;
    HANDLE hProtocolLibContext;
    BOOL fTsLicense;
    BOOL fLlsLicense;
    LS_HANDLE hLlsLicense;
    LPARAM lPrivate;
} LCCONTEXT, *LPLCCONTEXT;

/*
 *  Class Definition
 */

class CSession
{
public:

/*
 *  Creation Functions
 */

CSession(
    PWINSTATION pWinStation
    )
{
    m_pWinStation = pWinStation;
}

~CSession(
    )
{
    m_pWinStation = NULL;
}

/*
 *  Get Functions
 */

inline HANDLE
GetIcaStack(
    ) const
{
    return(m_pWinStation->hStack);
}

inline LPLCCONTEXT
GetLicenseContext(
    ) const
{
    return((LPLCCONTEXT)(m_pWinStation->lpLicenseContext));
}

inline ULONG
GetLogonId(
    ) const
{
    return(m_pWinStation->LogonId);
}

inline LPCWSTR
GetUserDomain(
    ) const
{
    return((LPCWSTR)(m_pWinStation->Domain));
}

inline LPCWSTR
GetUserName(
    ) const
{
    return((LPCWSTR)(m_pWinStation->UserName));
}

/*
 *  Is Functions
 */

inline BOOLEAN
IsConsoleSession(
    ) const
{
    return((BOOLEAN)(GetCurrentConsoleId() == m_pWinStation->LogonId));
}

inline BOOLEAN
IsSessionZero(
    ) const
{
    return((BOOLEAN)((0 == m_pWinStation->LogonId)
                     || (m_pWinStation->bClientSupportsRedirection
                         && m_pWinStation->bRequestedSessionIDFieldValid
                         && (0 == m_pWinStation->RequestedSessionID))));
}

inline BOOLEAN
IsUserAdmin(
    ) const
{
    return(m_pWinStation->fUserIsAdmin);
}

inline BOOL
IsUserHelpAssistant(
    ) const
{
    return TSIsSessionHelpSession( m_pWinStation, NULL );
}


/*
 *  Do Functions
 */

inline NTSTATUS
SendWinStationCommand(
    PWINSTATION_APIMSG pMsg
    )
{
    //
    //  Wait time must be zero, or termsrv will release the winstation,
    //  causing who knows what to happen to our state.
    //

    return(::SendWinStationCommand(m_pWinStation, pMsg, 0));
}

//
// ASSUMPTION: This function will be
//             called with the stack lock already held
//
inline NTSTATUS
SetErrorInfo(
    UINT32 dwErr
    )
{
        if(m_pWinStation->pWsx &&
           m_pWinStation->pWsx->pWsxSetErrorInfo &&
           m_pWinStation->pWsxContext)
        {
            return m_pWinStation->pWsx->pWsxSetErrorInfo(
                               m_pWinStation->pWsxContext,
                               dwErr,
                               TRUE); //lock already held
        }
        else
        {
            return STATUS_INVALID_PARAMETER;
        }
}


/*
 *  Set Functions
 */


private:

PWINSTATION m_pWinStation;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\audit.c ===
/*******************************************************************************
* AUDIT.C
*
*     This module contains the routines for logging audit events
*
* Copyright (C) 1997-1999 Microsoft Corp.
*******************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <rpc.h>
#include <msaudite.h>
#include <ntlsa.h>
#include <authz.h>
#include <authzi.h>
#include <winsock2.h>

HANDLE AuditLogHandle = NULL;
HANDLE SystemLogHandle = NULL;

#define MAX_INSTANCE_MEMORYERR 20

/*
 * Global data
 */
//Authz Changes
AUTHZ_RESOURCE_MANAGER_HANDLE hRM         = NULL;
extern RTL_CRITICAL_SECTION g_AuthzCritSection;
//END Authz Changes

/*
 * External procedures defined
 */
VOID
AuditEvent( PWINSTATION pWinstation, ULONG EventId );

NTSTATUS
AuthzReportEventW( IN PAUTHZ_AUDIT_EVENT_TYPE_HANDLE pHAET, 
                   IN DWORD Flags, 
                   IN ULONG EventId, 
                   IN PSID pUserID, 
                   IN USHORT NumStrings,
                   IN ULONG DataSize OPTIONAL, //Future - DO NOT USE
                   IN PWSTR* Strings,
                   IN PVOID  Data OPTIONAL         //Future - DO NOT USE
                   );


BOOL AuthzInit( IN DWORD Flags,
                IN USHORT CategoryID,
                IN USHORT AuditID,
                IN USHORT ParameterCount,
                OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
                );

BOOLEAN
AuditingEnabled ();

VOID
AuditEnd();

/*
 * Internal procedures defined
 */
NTSTATUS
AdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString
    );



BOOLEAN
IsAuditLogFull(
    HANDLE LogHandle
    )
{
    BOOLEAN retval = TRUE;
    EVENTLOG_FULL_INFORMATION EventLogFullInformation;
    DWORD dwBytesNeeded;

    if (GetEventLogInformation(LogHandle, 
                               EVENTLOG_FULL_INFO, 
                               &EventLogFullInformation, 
                               sizeof(EventLogFullInformation), 
                               &dwBytesNeeded )   ) {
        if (EventLogFullInformation.dwFull == FALSE) {
            retval = FALSE;
        }
    }

    return retval;
}



NTSTATUS
AdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed LUID.

    The resultant string will be formatted as follows:

        (0x00005678,0x12340000)

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;
    UNICODE_STRING          IntegerString;

    ULONG                   Buffer[(16*sizeof(WCHAR))/sizeof(ULONG)];


    IntegerString.Buffer = (PWCHAR)&Buffer[0];
    IntegerString.MaximumLength = 16*sizeof(WCHAR);


    //
    // Length (in WCHARS) is  3 for   (0x
    //                       10 for   1st hex number
    //                        3 for   ,0x
    //                       10 for   2nd hex number
    //                        1 for   )
    //                        1 for   null termination
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 28 * sizeof(WCHAR);

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }

    Status = RtlAppendUnicodeToString( ResultantString, L"(0x" );
    Status = RtlIntegerToUnicodeString( Value->HighPart, 16, &IntegerString );
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );

    Status = RtlAppendUnicodeToString( ResultantString, L",0x" );
    Status = RtlIntegerToUnicodeString( Value->LowPart, 16, &IntegerString );
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );

    Status = RtlAppendUnicodeToString( ResultantString, L")" );

    return(STATUS_SUCCESS);
}


VOID
AuditEvent( PWINSTATION pWinstation, ULONG EventId )
{
    NTSTATUS Status;
    UNICODE_STRING LuidString;
    PWSTR StringPointerArray[6];
    USHORT StringIndex = 0;
    TOKEN_STATISTICS TokenInformation;
    ULONG ReturnLength;
    LUID LogonId = {0,0};
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET = NULL;

    if (!AuditingEnabled() )
        return;

    // Initialize LuidString.
    LuidString.Length = 0;
    LuidString.Buffer = NULL;

    //
    //AUTHZ Changes 
    //

    if( !AuthzInit( 0, SE_CATEGID_LOGON, (USHORT)EventId, 6, &hAET ))
        goto badAuthzInit;
            
    if (pWinstation->UserName && (wcslen(pWinstation->UserName) > 0)) {
        StringPointerArray[StringIndex] = pWinstation->UserName;
    } else {
        StringPointerArray[StringIndex] = L"Unknown";
    }
    StringIndex++;

    if (pWinstation->Domain  && (wcslen(pWinstation->Domain) > 0)) {
        StringPointerArray[StringIndex] = pWinstation->Domain;
    } else {
        StringPointerArray [StringIndex] =  L"Unknown";
    }
    StringIndex++;

    if (pWinstation->UserToken != NULL) {
        Status = NtQueryInformationToken (
            pWinstation->UserToken,
            TokenStatistics,
            &TokenInformation,
            sizeof(TokenInformation),
            &ReturnLength
            );
    
        if (NT_SUCCESS(Status)) {
    
            Status = AdtBuildLuidString( &(TokenInformation.AuthenticationId), &LuidString );
        } else {
            Status = AdtBuildLuidString( &LogonId, &LuidString );
        }
    } else {
        Status = AdtBuildLuidString( &LogonId, &LuidString );
    }
    StringPointerArray[StringIndex] = LuidString.Buffer;
    StringIndex++;

    if (pWinstation->WinStationName && (wcslen(pWinstation->WinStationName) > 0)) {
        StringPointerArray[StringIndex] = pWinstation->WinStationName;
    } else {
        StringPointerArray[StringIndex] = L"Unknown" ;
    }
    StringIndex++;

    if (pWinstation->Client.ClientName && (wcslen(pWinstation->Client.ClientName) > 0)) {
        StringPointerArray[StringIndex] = pWinstation->Client.ClientName;
    } else {
        StringPointerArray[StringIndex] = L"Unknown";
    }

    StringIndex++;
	
	StringPointerArray[StringIndex] = L"Unknown";

    if( pWinstation->pLastClientAddress != NULL )
    {
        PSTR szIPV4 = NULL;
        TCHAR tchWideIP[ 80 ];
        int cchWideIP = sizeof( tchWideIP ) / sizeof( TCHAR );

        if( pWinstation->pLastClientAddress->length < 16 )
        {
            /* currently only ipv4 apis are in use */
            struct in_addr Ipv4;
            
            RtlCopyMemory( &Ipv4 , &pWinstation->pLastClientAddress->addr[0] ,  pWinstation->pLastClientAddress->length );

            szIPV4 = inet_ntoa( Ipv4 );

            // convert ansi to wide

            if( MultiByteToWideChar(
                CP_ACP,             // code page
                0,                  // character-type options
                szIPV4,             // string to map
                -1,                 // number of bytes in string
                tchWideIP,          // wide-character buffer
                cchWideIP           // size of buffer
                ) != 0 )
            {
                StringPointerArray[StringIndex] = tchWideIP;                
            }
        }

    }  

    StringIndex++;

    //Authz Changes
    
    Status = AuthzReportEventW( &hAET, 
                                APF_AuditSuccess, 
                                EventId, 
                                pWinstation->pUserSid, 
                                StringIndex,
                                0,
                                StringPointerArray,
                                NULL
                                );

    //end authz changes


     if ( !NT_SUCCESS(Status))
        DBGPRINT(("Termsrv - failed to report event \n" ));

badAuthzInit:
    if( hAET != NULL )
        AuthziFreeAuditEventType( hAET  );

    if (LuidString.Buffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, LuidString.Buffer);
    }
}




/***************************************************************************\
* AuditingEnabled
*
* Purpose : Check auditing via LSA.
*
* Returns:  TRUE on success, FALSE on failure
*
* History:
* 5-6-92   DaveHart     Created.
\***************************************************************************/

BOOLEAN
AuditingEnabled()
{
    NTSTATUS                    Status, IgnoreStatus;
    PPOLICY_AUDIT_EVENTS_INFO   AuditInfo;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE                  PolicyHandle;
    BOOLEAN                     ReturnValue; 

    //
    // Set up the Security Quality Of Service for connecting to the
    // LSA policy object.
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy(
                 NULL,
                 &ObjectAttributes,
                 POLICY_VIEW_AUDIT_INFORMATION | POLICY_SET_AUDIT_REQUIREMENTS,
                 &PolicyHandle
                 );
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("Termsrv: Failed to open LsaPolicyObject Status = 0x%lx", Status));
        return FALSE;
    }

    Status = LsaQueryInformationPolicy(
                 PolicyHandle,
                 PolicyAuditEventsInformation,
                 (PVOID *)&AuditInfo
                 );
    IgnoreStatus = LsaClose(PolicyHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("Termsrv: Failed to query audit event info Status = 0x%lx", Status));
        return FALSE;
    }

    ReturnValue = (AuditInfo->AuditingMode &&
            ((AuditInfo->EventAuditingOptions)[AuditCategoryLogon] &
                                          POLICY_AUDIT_EVENT_SUCCESS));

    LsaFreeMemory(AuditInfo);

    return ReturnValue;
}


VOID     WriteErrorLogEntry(
            IN  NTSTATUS NtStatusCode,
            IN  PVOID    pRawData,
            IN  ULONG    RawDataLength
            )
{
    NTSTATUS Status;
    ULONG Length;


    if ( !SystemLogHandle ) {
        UNICODE_STRING ModuleName;

        RtlInitUnicodeString( &ModuleName, L"TermService");

        Status = ElfRegisterEventSourceW( NULL, &ModuleName, &SystemLogHandle );

        if (!NT_SUCCESS(Status)) {
            DBGPRINT(("Termsrv - failed to open System log file\n"));
            return;
        }
    }

    if (IsAuditLogFull(SystemLogHandle))
        return;

    Status = ElfReportEventW( SystemLogHandle,
                              EVENTLOG_ERROR_TYPE,
                              0,
                              NtStatusCode,
                              NULL,
                              0,
                              RawDataLength,
                              NULL,
                              pRawData,
                              0,
                              NULL,
                              NULL );
    if ( !NT_SUCCESS(Status))
        DBGPRINT(("Termsrv - failed to report event \n" ));
}


// This function is duplicated in \nt\termsrv\sessdir\dis\tssdis.cpp.
/****************************************************************************/
// PostErrorValueEvent
//
// Utility function used to create a system log error event containing one
// hex DWORD error code value.
/****************************************************************************/
void PostErrorValueEvent(unsigned EventCode, DWORD ErrVal)
{
    HANDLE hLog;
    WCHAR hrString[128];
    PWSTR String = NULL;
	extern WCHAR gpszServiceName[];
    static DWORD numInstances = 0;
    //
    //count the numinstances of out of memory error, if this is more than
    //a specified number, we just won't log them
    //
    if( STATUS_COMMITMENT_LIMIT == ErrVal )
    {
        if( numInstances > MAX_INSTANCE_MEMORYERR )
            return;
         //
        //if applicable, tell the user that we won't log any more of the out of memory errors
        //
        if( numInstances >= MAX_INSTANCE_MEMORYERR - 1 ) {
            wsprintfW(hrString, L"0x%X. This type of error will not be logged again to avoid clutter.", ErrVal);
            String = hrString;
        }
        numInstances++;
    }

    hLog = RegisterEventSource(NULL, gpszServiceName);
    if (hLog != NULL) {
        if( NULL == String ) {
            wsprintfW(hrString, L"0x%X", ErrVal);
            String = hrString;
        }
        ReportEvent(hLog, EVENTLOG_ERROR_TYPE, 0, EventCode, NULL, 1, 0,
                (const WCHAR **)&String, NULL);
        DeregisterEventSource(hLog);
    }
}

/*************************************************************
* AuthzInit Purpose : Initialize authz for logging an event to the security log
*Flags - unused
*Category Id - Security Category to which this event belongs
*Audit Id - An id for the event
*PArameter count - Number of parameters that will be passed to the logging function later
****************************************************************/

BOOL AuthzInit( IN DWORD Flags,
                IN USHORT CategoryID,
                IN USHORT AuditID,
                IN USHORT ParameterCount,
                OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
                )                     
{
     BOOL fAuthzInit   = TRUE;
     BOOLEAN WasEnabled   = FALSE;
     NTSTATUS Status;

     if( NULL == phAuditEventType )
        goto badAuthzInit;
    
    Status = RtlAdjustPrivilege(
                 SE_SECURITY_PRIVILEGE | SE_AUDIT_PRIVILEGE,
                 TRUE,    // Enable the PRIVILEGE
                 FALSE,    // Don't Use Thread token (under impersonation)
                 &WasEnabled
                 );

    if ( Status == STATUS_NO_TOKEN ) {
        DBGPRINT(("TERMSRV: AuditEvent: RtlAdjustPrivilege failure 0x%x\n",Status));
        return FALSE;
    }
    

    *phAuditEventType = NULL;
    
    //
    //only one thread can create hRM
    //
    RtlEnterCriticalSection( &g_AuthzCritSection );
    if( NULL == hRM )
    {
            fAuthzInit = AuthzInitializeResourceManager( 0,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         L"Terminal Server",
                                                         &hRM
                                                         );

    }
    RtlLeaveCriticalSection( &g_AuthzCritSection );
    
    if ( !fAuthzInit )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthzInitializeResourceManager failed with %d\n", GetLastError()));
        goto badAuthzInit;
    }


    fAuthzInit = AuthziInitializeAuditEventType( Flags,
                                                 CategoryID,
                                                 AuditID,
                                                 ParameterCount,
                                                 phAuditEventType
                                                 );

    if ( !fAuthzInit )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthziInitializeAuditEventType failed with %d\n", GetLastError()));
        goto badAuthzInit;
    }

badAuthzInit:
    if( !fAuthzInit )
    {
        if( NULL != *phAuditEventType )
        {
            if( !AuthziFreeAuditEventType( *phAuditEventType ))
                DBGPRINT(("TERMSRV: AuditEvent: AuthziFreeAuditEventType failed with %d\n", GetLastError()));
            *phAuditEventType = NULL;
        }
    }
    
    if( !WasEnabled ) {

        /*
         * Principle of least rights says to not go around with privileges
         * held you do not need. So we must disable the privilege.
         */
            RtlAdjustPrivilege(
                      SE_SECURITY_PRIVILEGE | SE_AUDIT_PRIVILEGE,
                      FALSE,    // Disable the PRIVILEGE
                      FALSE,     // Don't Use Thread token
                      &WasEnabled
                      );

    }    

  // if( fAuthzInit )
   //  DBGPRINT(("TERMSRV: Successfully initialized authz = %d\n", AuditID));
 return fAuthzInit;
}


/*********************************************************
* Purpose : Log an Event to the security log
* In pHAET
*  Audit Event type obtained from a call to AuthzInit() above
* In Flags
*   APF_AuditSuccess or others as listed in the header file
* pUserSID - Unused
* NumStrings - Number of strings contained within "Strings"
* DataSize - unused
* Strings- Pointer to a sequence of unicode strings
* Data - unused
*
**********************************************************/
NTSTATUS
AuthzReportEventW( IN PAUTHZ_AUDIT_EVENT_TYPE_HANDLE pHAET, 
                   IN DWORD Flags, 
                   IN ULONG EventId, 
                   IN PSID pUserSID, 
                   IN USHORT NumStrings,
                   IN ULONG DataSize OPTIONAL, //Future - DO NOT USE
                   IN PWSTR* Strings,
                   IN PVOID  Data OPTIONAL         //Future - DO NOT USE
                  )
{
    NTSTATUS status = STATUS_ACCESS_DENIED;
    AUTHZ_AUDIT_EVENT_HANDLE      hAE         = NULL;
    BOOL                          fSuccess   = FALSE;
    PAUDIT_PARAMS                 pParams     = NULL;

    if( NULL == hRM || NULL == pHAET || *pHAET == NULL )
        return status;

    fSuccess = AuthziAllocateAuditParams( &pParams,  NumStrings  );

    if ( !fSuccess )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthzAllocateAuditParams failed with %d\n", GetLastError()));
        goto BadAuditEvent;
    }


    if( 6 == NumStrings )
    {
        fSuccess = AuthziInitializeAuditParamsWithRM( Flags,
                                                     hRM,
                                                     NumStrings,
                                                     pParams,
                                                     APT_String, Strings[0],
                                                     APT_String,  Strings[1],
                                                     APT_String,  Strings[2],
                                                     APT_String,  Strings[3],
                                                     APT_String, Strings[4],
                                                     APT_String, Strings[5]
                                                     );
    }
    else if( 0 == NumStrings )
    {
        fSuccess = AuthziInitializeAuditParamsWithRM( Flags,
                                                     hRM,
                                                     NumStrings,
                                                     pParams
                                                     );
    }
    else
    {
        //we don't support anything else
        fSuccess = FALSE;
        DBGPRINT(("TERMSRV: AuditEvent: unsupported audit type \n"));
        goto BadAuditEvent;
    }
    
    if ( !fSuccess )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthziInitializeAuditParamsWithRM failed with %d\n", GetLastError()));
        goto BadAuditEvent;
    }

    fSuccess = AuthziInitializeAuditEvent( 0,
                                           hRM,
                                           *pHAET,
                                           pParams,
                                           NULL,
                                           INFINITE,
                                           L"",
                                           L"",
                                           L"",
                                           L"",
                                           &hAE
                                           );

    if ( !fSuccess )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthziInitializeAuditEvent failed with %d\n", GetLastError()));
        goto BadAuditEvent;
    }    

    fSuccess = AuthziLogAuditEvent( 0,
                                    hAE,
                                    NULL
                                    );

    if ( !fSuccess )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthziLogAuditEvent failed with %d\n", GetLastError()));
        goto BadAuditEvent;
    }    

BadAuditEvent:

    if( hAE )
        AuthzFreeAuditEvent( hAE );

    if( pParams )
        AuthziFreeAuditParams( pParams );
    
    if( fSuccess )
        status = STATUS_SUCCESS;

    //if( fSuccess )
    // DBGPRINT(("TERMSRV: Successfully audited event with authz= %d\n", EventId));
    return status;
}


//
//should only be called once per our process
//
VOID AuditEnd()
{
    if( NULL != hRM )
    {
        if( !AuthzFreeResourceManager( hRM ))
            DBGPRINT(("TERMSRV: AuditEvent: AuthzFreeResourceManager failed with %d\n", GetLastError()));
        hRM = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\channel.c ===
/*************************************************************************
*
* channel.c
*
* WinStation channel routines
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

NTSTATUS
WinStationOpenChannel (
    HANDLE IcaDevice,
    HANDLE ProcessHandle,
    CHANNELCLASS ChannelClass,
    PVIRTUALCHANNELNAME pVirtualName,
    PHANDLE pDupChannel
   )

{
    NTSTATUS Status;
    HANDLE ChannelHandle;

    Status = IcaChannelOpen( IcaDevice,
                             ChannelClass,
                             pVirtualName,
                             &ChannelHandle );

    if ( !NT_SUCCESS( Status ) ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationOpenChannel, IcaChannelOpen 0x%x\n",
                  Status  ));
        return Status;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                ChannelHandle,
                                ProcessHandle,
                                pDupChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );

    if ( !NT_SUCCESS( Status ) ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationOpenChannel, NtDuplicateObject 0x%x\n",
                  Status  ));
        (void) IcaChannelClose( ChannelHandle );
        return Status;
    }

    Status = IcaChannelClose( ChannelHandle );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationOpenChannel status 0x%x\n", Status ));

    return Status;
}

/*
 * Disable virtual channel depending on the WinStation configuration.
 * This was supposed to be for security purposes (Web client).  
 *
 * Notes: 
 *    This doesn't protect the client since it's a host configuration option.
 *      The client doesn't have to support any virtual channels.
 *    It doesn't protect the host since it's the client devices you are denying
 *       access to.
 *    You may be adding some (fake) data security by denying the user access to
 *      a client printer and disk so he can't download data.
 */
VOID
VirtualChannelSecurity( PWINSTATION pWinStation )
{

    //  Check for availability
    if ( pWinStation->pWsx && 
         pWinStation->pWsx->pWsxVirtualChannelSecurity ) {

        (void) pWinStation->pWsx->pWsxVirtualChannelSecurity(
                    pWinStation->pWsxContext,
                    pWinStation->hIca,
                    &pWinStation->Config.Config.User);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\conntfy.c ===
#include "precomp.h"
#pragma hdrstop

#define SECURITY_WIN32

#ifdef NTSDDEBUG
#define NTSDDBGPRINT(x) DbgPrint x
#else
#define NTSDDBGPRINT(x)
#endif

#include "winsvcp.h"        // defines I_ScSendTSMessage
#include "conntfy.h"




BOOL IsBitSet(DWORD dwMask, WPARAM notifybit)
{
    // why are you asking for bit 0?
    ASSERT(notifybit != 0);
    ASSERT(notifybit <= WTS_MAX_SESSION_NOTIFICATION);
    return (CREATE_MASK(notifybit)) & dwMask;
}



//#ifdef MAKARANDS_HIGHER_WARNING_LEVEL
#pragma warning(push, 4)
#pragma warning(disable:4201) // nameless structure.
//#endif

#define INVALID_SESSIONSERIAL   0xffffffff


// 0x1  fConnected
// 0x2  fLoggedOn
// 0x3  fRemote
// 0x4  fWelcome
typedef struct _WTSSESSION_STATE
{
    unsigned int bConnected: 1;
    unsigned int bLoggedOn: 1;
    unsigned int bConsole:  1;
    unsigned int bRemote: 1;
    unsigned int bLocked: 1;

} WTSSESSION_STATE, *PWTSSESSION_STATE;

/*
WTS_CONSOLE_CONNECT         bConnected, bConsole, !bRemote,
WTS_CONSOLE_DISCONNECT      !bConnected, !bConsole, !bRemote
WTS_REMOTE_CONNECT          bConnected, !bConsole, bremote
WTS_REMOTE_DISCONNECT       !bConnected, !bConsole, !bRemote
WTS_SESSION_LOGON           bLoggedOn
WTS_SESSION_LOGOFF          !bLoggedOn
WTS_SESSION_LOCK            bLocked
WTS_SESSION_UNLOCK          !bLocked
*/

//
// this is head for hwnds list.
// this links NOTIFY_ENTRY or NOTIFY_ENTRY_GLOBAL together.
//
typedef struct _NOTIFY_LIST
{
    LIST_ENTRY              Links;              // links to other NOTIFY_LISTs. not used in case of global notification list.
    LIST_ENTRY              ListHead;           // head of notification entries. links NOTIFY_ENTRYs (or NOTIFY_ENTRY_GLOBAL) together
    RTL_CRITICAL_SECTION    ListLock;           // lock to travel the entries.
    ULONG                   SessionId;          // session id ( not used in case of global list)
    ULONG                   SessonSerialNumber; // serial number ( not used in case of global list)
    WTSSESSION_STATE        SessionState;        // state of the session.

} NOTIFY_LIST, *PNOTIFY_LIST;

//
// entry in notification list per winstation.
//
typedef struct _NOTIFY_ENTRY
{
    LIST_ENTRY               Links;             // links to other entries
    ULONG_PTR                hWnd;              // window or event handle.
    ULONG                    RefCount;          // how many times was this hwnd registered ?
    DWORD                    dwMask;            // mask tell us the event to be notified for.
    DWORD                    dwFlags;           // flags.

} NOTIFY_ENTRY, *PNOTIFY_ENTRY;

//
// Entry in Notification list for all sessions Notifications.
//
typedef struct _NOTIFY_ENTRY_GLOBAL
{
    struct                  _NOTIFY_ENTRY;       // above structure +
    ULONG                   SessionId;           // since this is global entry, it needs to keep session id per hwnd.

} NOTIFY_ENTRY_GLOBAL, *PNOTIFY_ENTRY_GLOBAL;

//
// The notification Queue.
//
typedef struct _NOTIFICATION_QUEUE
{
    LIST_ENTRY ListHead;                        // head of queue reuests. links NOTIFICATION_REQUESTs together
    RTL_CRITICAL_SECTION ListLock;              // lock to travel the queue
    HANDLE hNotificationEvent;                  // syncronization between woker and caller of queue.

} NOTIFICATION_QUEUE, *PNOTIFICATION_QUEUE;

//
// Entry in Notification Queue.
//
typedef struct _NOTIFICATION_REQUEST
{
    LIST_ENTRY              Links;                       // links to other entries.
    ULONG                   SessionId;                   // session id for the session this notificaiton is to be sent.
    ULONG                   SessonSerialNumber;          // serial number for the session this notificaiton is to be sent.
    WPARAM                  NotificationCode;            // notificaiton code

} NOTIFICATION_REQUEST, *PNOTIFICATION_REQUEST;

//
// our main data structure.
//
typedef struct _NOTIFY_LLIST
{
    LIST_ENTRY              ListHead;                   // head of notification lists. links NOTIFY_LISTs together.
    RTL_CRITICAL_SECTION    ListLock;                   // lock to travel the head list.
    NOTIFY_LIST             GlobalList;                 // global notification list.
    NOTIFICATION_QUEUE      RequestQueue;               // notification queue.
    NOTIFY_LIST             InvlidHwndList;             // invalid window list

} NOTIFY_LLIST, PNOTIFY_LLIST;

//
// File Globals.
//
NOTIFY_LLIST gNotifyLList;


//
// private functions
//
BOOL DoesHWndExists (
                     PNOTIFY_LIST pNotifyList,
                     ULONG_PTR hWnd
                     );

PNOTIFY_ENTRY GetHWndEntryFromSessionList (
                                           PNOTIFY_LIST pNotifyList,
                                           ULONG_PTR hWnd,
                                           DWORD dwFlags
                                           );

PNOTIFY_ENTRY_GLOBAL GetHWndEntryFromGlobalList (
                                                 PNOTIFY_LIST pNotifyList,
                                                 ULONG_PTR hWnd,
                                                 ULONG SessionId,
                                                 DWORD dwFlags
                                                 );

NTSTATUS GetNoficationListFromSessionId (
                                         ULONG SessionId,
                                         PNOTIFY_LIST *ppNofificationList,
                                         BOOL bKeepLListLocked
                                         );

NTSTATUS GetGlobalNotificationList (
                                    PNOTIFY_LIST *ppConChgNtfy
                                    );


NTSTATUS GetInvlidHwndList(PNOTIFY_LIST *ppConChgNtfy);
NTSTATUS NotifyConsole (
                        ULONG SessionId,
                        ULONG SessionSerialNumber,
                        WPARAM wParam
                        );

NTSTATUS SendConsoleNotification (
                                  ULONG SessionId,
                                  ULONG_PTR hWnd,
                                  ULONG Msg,
                                  WPARAM wParam,
                                  WTSSESSION_NOTIFICATION wtsConsoleNotification
                                  );

BOOL IsGlobalList(PNOTIFY_LIST pNtfyList);

int GetListCount (
                  LIST_ENTRY *pListHead
                  );


NTSTATUS DestroyLock ( PNOTIFY_LIST pNtfyList);
NTSTATUS CreateLock ( PNOTIFY_LIST pNtfyList);



NTSTATUS
InitializeNotificationQueue ();

NTSTATUS
QueueNotificationRequest (
                          ULONG SessionSerialNumber,
                          ULONG SessionId,
                          WPARAM notification
                          );

PNOTIFICATION_REQUEST
UnQueueNotificationRequest ();

DWORD NotificationQueueWorker (
                               LPVOID
                               );

NTSTATUS RemoveGlobalNotification (ULONG SessionId);
NTSTATUS RemoveInvalidWindowsFromLists ();
NTSTATUS RemoveBadEvents(ULONG SessionId);
NTSTATUS UnRegisterConsoleNotificationInternal (ULONG_PTR hWnd, ULONG SessionId, BOOL bDcrRef, DWORD dwFlags);

void ReleaseNotificationList  (PNOTIFY_LIST pNotifyList);

void UpdateSessionState(PNOTIFY_LIST pNotifyList, WPARAM wNotification)
{
/*
WTS_CONSOLE_CONNECT         bConnected, bConsole, !bRemote,
WTS_CONSOLE_DISCONNECT      !bConnected, !bConsole, !bRemote
WTS_REMOTE_CONNECT          bConnected, !bConsole, bremote
WTS_REMOTE_DISCONNECT       !bConnected, !bConsole, !bRemote
WTS_SESSION_LOGON           bLoggedOn
WTS_SESSION_LOGOFF          !bLoggedOn
WTS_SESSION_LOCK            bLocked
WTS_SESSION_UNLOCK          !bLocked
*/

    ASSERT(!IsGlobalList(pNotifyList));
    

    ASSERT(!pNotifyList->SessionState.bConsole || !pNotifyList->SessionState.bRemote);
    ASSERT(!pNotifyList->SessionState.bConnected || pNotifyList->SessionState.bConsole || pNotifyList->SessionState.bRemote);

    switch  (wNotification)
    {
        case WTS_CONSOLE_CONNECT:

            ASSERT(!pNotifyList->SessionState.bConsole);
            ASSERT(!pNotifyList->SessionState.bRemote);

            pNotifyList->SessionState.bConnected = 1;
            pNotifyList->SessionState.bConsole = 1;
            break;

        case WTS_CONSOLE_DISCONNECT:

            ASSERT(pNotifyList->SessionState.bConsole);
            ASSERT(pNotifyList->SessionState.bConnected);
            ASSERT(!pNotifyList->SessionState.bRemote);

            pNotifyList->SessionState.bConnected = 0;
            pNotifyList->SessionState.bConsole = 0;
            break;

        case WTS_REMOTE_DISCONNECT:

            ASSERT(pNotifyList->SessionState.bRemote);
            ASSERT(pNotifyList->SessionState.bConnected);
            ASSERT(!pNotifyList->SessionState.bConsole);

            pNotifyList->SessionState.bConnected = 0;
            pNotifyList->SessionState.bRemote = 0;
            break;

        case WTS_REMOTE_CONNECT:
            
            ASSERT(!pNotifyList->SessionState.bRemote);
            ASSERT(!pNotifyList->SessionState.bConnected);
            ASSERT(!pNotifyList->SessionState.bConsole);
            
            pNotifyList->SessionState.bConnected = 1;
            pNotifyList->SessionState.bRemote = 1;
            break;

        case WTS_SESSION_LOGON:
            
            ASSERT(pNotifyList->SessionState.bLoggedOn == 0);
            
            pNotifyList->SessionState.bLoggedOn = 1;
            break;

        case WTS_SESSION_LOGOFF:
            
            ASSERT(pNotifyList->SessionState.bLoggedOn == 1);

            pNotifyList->SessionState.bLoggedOn = 0;
            break;

        case WTS_SESSION_LOCK:
            
            ASSERT(pNotifyList->SessionState.bLocked == 0);

            pNotifyList->SessionState.bLocked = 1;
            break;

        case WTS_SESSION_UNLOCK:
            
            ASSERT(pNotifyList->SessionState.bLocked == 1);

            pNotifyList->SessionState.bLocked = 0;
            break;

        case WTS_SESSION_REMOTE_CONTROL:
            
            NOTHING;
            break;

        default:
            ASSERT(FALSE);
    }
    
    ASSERT(!pNotifyList->SessionState.bConsole || !pNotifyList->SessionState.bRemote);
    ASSERT(!pNotifyList->SessionState.bConnected || pNotifyList->SessionState.bConsole || pNotifyList->SessionState.bRemote);
}

//
// Global initialization.
//
NTSTATUS InitializeConsoleNotification ()
{
    NTSTATUS Status;

    InitializeListHead( &gNotifyLList.ListHead );
    Status = RtlInitializeCriticalSection( &gNotifyLList.ListLock );
    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }

    //
    // following members are unused in for global list.
    //
    gNotifyLList.GlobalList.Links.Blink = NULL;
    gNotifyLList.GlobalList.Links.Flink = NULL;
    gNotifyLList.GlobalList.SessionId = INVALID_SESSIONID;
    gNotifyLList.GlobalList.SessonSerialNumber = INVALID_SESSIONSERIAL;


    InitializeListHead( &gNotifyLList.GlobalList.ListHead);
    Status = RtlInitializeCriticalSection( &gNotifyLList.GlobalList.ListLock );
    if ( !NT_SUCCESS( Status ) )
    {
        RtlDeleteCriticalSection( &gNotifyLList.ListLock );
        return (Status);
    }


    gNotifyLList.InvlidHwndList.Links.Blink = NULL;
    gNotifyLList.InvlidHwndList.Links.Flink = NULL;
    gNotifyLList.InvlidHwndList.SessionId = INVALID_SESSIONID;
    gNotifyLList.InvlidHwndList.SessonSerialNumber = INVALID_SESSIONSERIAL;

    InitializeListHead(&gNotifyLList.InvlidHwndList.ListHead) ;
    Status = RtlInitializeCriticalSection( &gNotifyLList.InvlidHwndList.ListLock );
    if ( !NT_SUCCESS( Status ) )
    {
        RtlDeleteCriticalSection( &gNotifyLList.ListLock );
        RtlDeleteCriticalSection( &gNotifyLList.GlobalList.ListLock );
        return (Status);
    }


    Status =  InitializeNotificationQueue ();
    if ( !NT_SUCCESS( Status ) )
    {
        RtlDeleteCriticalSection( &gNotifyLList.ListLock );
        RtlDeleteCriticalSection( &gNotifyLList.GlobalList.ListLock );
        RtlDeleteCriticalSection( &gNotifyLList.InvlidHwndList.ListLock );
    }

    return (Status);
}


//
// per winstation initialization.
//
NTSTATUS InitializeSessionNotification (PWINSTATION  pWinStation)
{
    NTSTATUS        Status;
    PNOTIFY_LIST    pNewNotifyList;

    ASSERT(pWinStation);

    if (pWinStation->Terminating)
    {
        // dont create notification list if this winstation is already terminating.
        // its possible that a winstation is being terminated before getting completely created,
        // in such case we might end up calling RemoveSessionNotification before InitializeSessionNotification.
        // so essentially leaving this session never to deleted. (Bug #414330)
        return STATUS_SUCCESS;
    }

#ifdef DBG

    // BUGBUG - is it possible that a old session with the same session id is still there?
    Status = GetNoficationListFromSessionId(pWinStation->LogonId, &pNewNotifyList, FALSE);

    //
    // we are just being asked to initialize notification
    // we must not find list for this session in our LList.
    //
    ASSERT( STATUS_NO_SUCH_LOGON_SESSION == Status );

#endif


    //
    // create a new hwnd list for this session
    //
    pNewNotifyList = MemAlloc(sizeof(NOTIFY_LIST));
    if (!pNewNotifyList)
    {
        return STATUS_NO_MEMORY;
    }

    pNewNotifyList->SessionId = pWinStation->LogonId;
    pNewNotifyList->SessonSerialNumber = pWinStation->SessionSerialNumber;

    //
    // initialize session state.
    //
    {
        pNewNotifyList->SessionState.bConnected = 0;
        pNewNotifyList->SessionState.bConsole = 0;
        pNewNotifyList->SessionState.bLoggedOn = 0;
        pNewNotifyList->SessionState.bRemote = 0;
        pNewNotifyList->SessionState.bLocked = 0; // bugbug we dont know the real welcome state ;(
    }

    InitializeListHead( &pNewNotifyList->ListHead);

    Status = RtlInitializeCriticalSection( &pNewNotifyList->ListLock );
    if ( !NT_SUCCESS( Status ) )
    {
        MemFree(pNewNotifyList);
        pNewNotifyList = NULL;
        return Status;
    }

    // now link this new list into our main list of lists.
    ENTERCRIT(&gNotifyLList.ListLock);
    InsertTailList( &gNotifyLList.ListHead, &pNewNotifyList->Links);
    LEAVECRIT(&gNotifyLList.ListLock);

    return STATUS_SUCCESS;
}
//
// must be called when a session ends.
//
NTSTATUS RemoveSessionNotification(ULONG SessionId, ULONG SessionSerialNumber)
{
    NTSTATUS Status;
    PNOTIFY_LIST pListTobeRemoved;
    UNREFERENCED_PARAMETER(SessionSerialNumber);    // it's referenced only for Chk builds.


    // BUGBUG - is it possible that a new session with the same session id was created while we are here ?
    Status = GetNoficationListFromSessionId( SessionId, &pListTobeRemoved, TRUE);

    if (!NT_SUCCESS( Status ))
    {
        //
        // we are being asked to remove session notification
        // but its possible that we dont have session notification list created for this session. 
        // This can happen if the session is being terminate during session creation process.
        //
        ASSERT( !pListTobeRemoved );
        return Status;

    }

    ASSERT( pListTobeRemoved );
    ASSERT( SessionSerialNumber == pListTobeRemoved->SessonSerialNumber );

    RemoveEntryList( &pListTobeRemoved->Links );
    LEAVECRIT(&gNotifyLList.ListLock);

    //
    // walk throught this list and free all the nodes.
    //
    while (!IsListEmpty(&pListTobeRemoved->ListHead))
    {
        PNOTIFY_ENTRY pEntry;
        PLIST_ENTRY Next;

        Next = pListTobeRemoved->ListHead.Flink;

        ASSERT(Next);

        pEntry = CONTAINING_RECORD( Next, NOTIFY_ENTRY, Links );
        ASSERT(pEntry);

        RemoveEntryList( &pEntry->Links );

        if (pEntry->dwFlags & WTS_EVENT_NOTIFICATION)
        {
            CloseHandle((HANDLE)pEntry->hWnd);
        }
        MemFree(pEntry);
        pEntry = NULL;
    }

    // we are no more going to use this list lock.
    RtlDeleteCriticalSection( &pListTobeRemoved->ListLock );
    MemFree(pListTobeRemoved);
    pListTobeRemoved = NULL;


    return RemoveGlobalNotification (SessionId);
    // return QueueNotificationRequest(pWinStation->SessionSerialNumber, pWinStation->LogonId, 0);

}

NTSTATUS RemoveGlobalNotification (ULONG SessionId)
{
    PLIST_ENTRY Head, Next;
    PNOTIFY_LIST pListTobeRemoved = NULL;
    NTSTATUS Status = GetGlobalNotificationList(&pListTobeRemoved);


    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }

    ASSERT(pListTobeRemoved);


    Head = &pListTobeRemoved->ListHead;
    Next = Head->Flink;
    while (Head != Next)
    {
        PNOTIFY_ENTRY_GLOBAL pEntryGlobal = CONTAINING_RECORD( Next, NOTIFY_ENTRY_GLOBAL, Links );
        Next = Next->Flink;
        ASSERT(pEntryGlobal);
        if (pEntryGlobal->SessionId == SessionId)
        {
            RemoveEntryList( &pEntryGlobal->Links );
            if (pEntryGlobal->dwFlags & WTS_EVENT_NOTIFICATION)
            {
                CloseHandle((HANDLE)pEntryGlobal->hWnd);
            }

            MemFree(pEntryGlobal);
            pEntryGlobal = NULL;
        }
    }

    ReleaseNotificationList( pListTobeRemoved );
    pListTobeRemoved = NULL;

    // now lets remove the invalid Windows associated with this session.
    // from the list if there is any.

    pListTobeRemoved = NULL;
    Status = GetInvlidHwndList(&pListTobeRemoved);
    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }
    
    ASSERT(pListTobeRemoved);

    Head = &pListTobeRemoved->ListHead;
    Next = Head->Flink;
    while (Head != Next)
    {
        PNOTIFY_ENTRY_GLOBAL pEntryGlobal = CONTAINING_RECORD( Next, NOTIFY_ENTRY_GLOBAL, Links );
        Next = Next->Flink;
        ASSERT(pEntryGlobal);
        if (pEntryGlobal->SessionId == SessionId)
        {
            RemoveEntryList( &pEntryGlobal->Links );
            MemFree(pEntryGlobal);
            pEntryGlobal = NULL;
        }
    }

    ReleaseNotificationList(pListTobeRemoved);

    return STATUS_SUCCESS;
}

//NTSTATUS RegisterNotificationEvent(HANDLE hEvent, DWORD dwMaskFlags, BOOL bThisSessionOnly)
//{
//}
NTSTATUS RegisterConsoleNotification ( ULONG_PTR hWnd, ULONG SessionId, DWORD dwFlags, DWORD dwMask)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PNOTIFY_LIST pNotifyList = NULL;
    PNOTIFY_LIST pNotifyListGlobal = NULL;
    PNOTIFY_ENTRY pEntry = NULL;
    PNOTIFY_ENTRY_GLOBAL pEntryGlobal = NULL;

    // WTS_EVENT_NOTIFICATION & WTS_WINDOW_NOTIFICATION are mutually exclusive.
    ASSERT(!(dwFlags & WTS_EVENT_NOTIFICATION && dwFlags & WTS_WINDOW_NOTIFICATION));


    if (dwFlags & WTS_EVENT_NOTIFICATION)
    {
        //
        // lets clean up our event list before we register this new event.
        //
        RemoveBadEvents(SessionId);
    }
/*
    if (dwFlags != NOTIFY_FOR_THIS_SESSION && dwFlags != NOTIFY_FOR_ALL_SESSIONS)
    {
        //
        // invalid flag value
        //
        return STATUS_INVALID_PARAMETER_3;
    }
*/

    //
    // get the global session notificaiton list
    //
    Status = GetGlobalNotificationList(&pNotifyListGlobal);
    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // get the session specific list for this window
    //
    Status = GetNoficationListFromSessionId( SessionId, &pNotifyList, FALSE);
    if (!NT_SUCCESS(Status))
    {
        ReleaseNotificationList (pNotifyListGlobal);
        return Status;
    }


    ASSERT( pNotifyList );
    ASSERT( pNotifyListGlobal );


    pEntry = GetHWndEntryFromSessionList(pNotifyList, hWnd, dwFlags & (WTS_EVENT_NOTIFICATION  | WTS_WINDOW_NOTIFICATION));
    pEntryGlobal = GetHWndEntryFromGlobalList(pNotifyListGlobal, hWnd, SessionId, dwFlags & (WTS_EVENT_NOTIFICATION  | WTS_WINDOW_NOTIFICATION));

    //
    // entry must not exist in both the lists.
    //
    ASSERT(!(pEntry && pEntryGlobal));


    // in case of event notifications, return here if entry already exists.
    if ((pEntry || pEntryGlobal) && (dwFlags & WTS_EVENT_NOTIFICATION))
    {
        ReleaseNotificationList( pNotifyListGlobal );
        ReleaseNotificationList( pNotifyList );

        return STATUS_INVALID_PARAMETER_1; // BUGBUG : get better status;
    }


    if (pEntry)
    {
        //
        // Let other list go
        //
        ReleaseNotificationList( pNotifyListGlobal );

        ASSERT( pEntry );
        ASSERT( pEntry->RefCount > 0 );

        //
        // entry already exists, just increment its reference count.
        //
        pEntry->RefCount++;

        ReleaseNotificationList( pNotifyList );

    }
    else if (pEntryGlobal)
    {
        ReleaseNotificationList (pNotifyList);

        ASSERT( pEntryGlobal );
        ASSERT( pEntryGlobal->RefCount > 0 );

        //
        // entry already exists, just increment its reference count.
        //
        pEntryGlobal->RefCount++;

        ReleaseNotificationList( pNotifyListGlobal );
    }
    else
    {
        //
        // the entry does not exists in either of the lists.
        // so we need to create a new entry
        //
        if (dwFlags & NOTIFY_FOR_ALL_SESSIONS)
        {
            ReleaseNotificationList (pNotifyList);

            pEntryGlobal = MemAlloc( sizeof(NOTIFY_ENTRY_GLOBAL) );
            if (pEntryGlobal == NULL )
            {
                Status = STATUS_NO_MEMORY;
            }
            else
            {
                pEntryGlobal->hWnd = hWnd;
                pEntryGlobal->SessionId = SessionId;
                pEntryGlobal->RefCount = 1;
                pEntryGlobal->dwMask = dwMask;
                pEntryGlobal->dwFlags = dwFlags;
                InsertTailList( &(pNotifyListGlobal->ListHead), &(pEntryGlobal->Links) );
            }

            ReleaseNotificationList( pNotifyListGlobal );
        }
        else
        {
            ReleaseNotificationList( pNotifyListGlobal );

            pEntry = MemAlloc( sizeof(NOTIFY_ENTRY) );
            if (pEntry == NULL )
            {
                Status = STATUS_NO_MEMORY;
            }
            else
            {
                pEntry->hWnd = hWnd;
                pEntry->RefCount = 1;
                pEntry->dwMask = dwMask;
                pEntry->dwFlags = dwFlags;

                InsertTailList( &(pNotifyList->ListHead), &(pEntry->Links) );
            }

            ReleaseNotificationList (pNotifyList);
        }
    }

    return (Status);
}

NTSTATUS UnRegisterConsoleNotification (ULONG_PTR hWnd, ULONG SessionId, DWORD dwFlags)
{
    return UnRegisterConsoleNotificationInternal (hWnd, SessionId, TRUE, dwFlags);
}


NTSTATUS UnRegisterConsoleNotificationInternal (ULONG_PTR hWnd, ULONG SessionId, BOOL bDcrRef, DWORD dwFlags)
{
    NTSTATUS Status;
    PNOTIFY_LIST pNotifyList;
    PNOTIFY_ENTRY pEntry;

    //
    // get the notification list for the Session
    //
    Status = GetNoficationListFromSessionId( SessionId, &pNotifyList, FALSE);

    if (NT_SUCCESS(Status))
    {
        ASSERT(pNotifyList);

        pEntry = GetHWndEntryFromSessionList(pNotifyList,hWnd, dwFlags);

        if (pEntry)
        {
            ASSERT( pEntry->RefCount > 0 );
            ASSERT( !(pEntry->dwFlags & WTS_EVENT_NOTIFICATION) || pEntry->RefCount == 1);

            // decrement ref count
            pEntry->RefCount--;

            if (pEntry->RefCount == 0 || !bDcrRef)
            {
                RemoveEntryList( &pEntry->Links );
                if (pEntry->dwFlags & WTS_EVENT_NOTIFICATION)
                {
                    CloseHandle((HANDLE)pEntry->hWnd);
                }

                MemFree(pEntry);
                pEntry = NULL;
            }

            ReleaseNotificationList (pNotifyList);
        }
        else
        {
            PNOTIFY_LIST pNotifyListGlobal = NULL;
            PNOTIFY_ENTRY_GLOBAL pEntryGlobal = NULL;

            ReleaseNotificationList (pNotifyList);

            //
            // now check the global session notificaiton entry
            //
            Status = GetGlobalNotificationList(&pNotifyListGlobal);

            if (NT_SUCCESS(Status))
            {
                pEntryGlobal = GetHWndEntryFromGlobalList(pNotifyListGlobal, hWnd, SessionId, dwFlags);
                if (pEntryGlobal)
                {
                    ASSERT(pEntryGlobal->RefCount > 0);
                    ASSERT( !(pEntryGlobal->dwFlags & WTS_EVENT_NOTIFICATION) || pEntryGlobal->RefCount == 1);

                    pEntryGlobal->RefCount--;
                    if (pEntryGlobal->RefCount == 0 || !bDcrRef)
                    {
                        RemoveEntryList( &pEntryGlobal->Links );
                        if (pEntryGlobal->dwFlags & WTS_EVENT_NOTIFICATION)
                        {
                            CloseHandle((HANDLE)pEntryGlobal->hWnd);
                        }

                        MemFree(pEntryGlobal);
                        pEntryGlobal = NULL;
                    }
                }
                else
                {
                    Status = STATUS_NOT_FOUND;
                }

                ReleaseNotificationList( pNotifyListGlobal );
            }

        }

    }

    return (Status);
}

NTSTATUS NotifySessionChange (PWINSTATION pWinStation, WPARAM wNotification)
{
    return QueueNotificationRequest(pWinStation->SessionSerialNumber, pWinStation->LogonId, wNotification);
}

NTSTATUS NotifyLogon(PWINSTATION pWinStation)
{
    return NotifySessionChange(pWinStation, WTS_SESSION_LOGON);
}

NTSTATUS NotifyLogoff(PWINSTATION pWinStation)
{
    return NotifySessionChange(pWinStation, WTS_SESSION_LOGOFF);
}

NTSTATUS NotifyConnect (PWINSTATION pWinStation, BOOL bConsole)
{
    return NotifySessionChange(pWinStation, bConsole ? WTS_CONSOLE_CONNECT : WTS_REMOTE_CONNECT);
}

NTSTATUS NotifyDisconnect (PWINSTATION pWinStation, BOOL bConsole)
{
    return NotifySessionChange(pWinStation, bConsole ? WTS_CONSOLE_DISCONNECT : WTS_REMOTE_DISCONNECT);
}

NTSTATUS NofifyWelcomeOn  (PWINSTATION  pWinStation)
{
    return NotifySessionChange(pWinStation, WTS_SESSION_LOCK);
}

NTSTATUS NotifyWelcomeOff (PWINSTATION  pWinStation)
{
    return NotifySessionChange(pWinStation, WTS_SESSION_UNLOCK);
}

NTSTATUS NotifyShadowChange (PWINSTATION  pWinStation, BOOL bIsHelpAssistant)
{
    UNREFERENCED_PARAMETER(bIsHelpAssistant); // for a new event later?

    return NotifySessionChange(pWinStation, WTS_SESSION_REMOTE_CONTROL);
}


NTSTATUS SendNotificationToHwnd(PWINSTATION pWinstation, ULONG_PTR hWnd, ULONG SessionId, WPARAM wParam)
{
    WINSTATION_APIMSG WMsg;
    //
    // now pupulate the WMSG for delievery.
    //
    WMsg.u.sMsg.Msg        = WM_WTSSESSION_CHANGE;
    WMsg.u.sMsg.wParam     = wParam;
    WMsg.ApiNumber         = SMWinStationSendWindowMessage ;
    WMsg.WaitForReply      = FALSE;
    WMsg.u.sMsg.dataBuffer = NULL;
    WMsg.u.sMsg.bufferSize = 0;
    WMsg.u.sMsg.lParam     = SessionId;
    WMsg.u.sMsg.hWnd       = (HWND) hWnd ;

    return SendWinStationCommand( pWinstation, &WMsg, 0);

}


NTSTATUS NotifyConsole (ULONG SessionId, ULONG SessionSerialNumber, WPARAM wParam)
{
    NTSTATUS Status = STATUS_SUCCESS;


    DWORD dwError;
    PWINSTATION pWinStation=NULL;


    Status = RemoveInvalidWindowsFromLists();
    ASSERT(NT_SUCCESS(Status));
    

    pWinStation = FindWinStationById(SessionId, FALSE);

    //
    // if we find the session we were looking for
    // note: we must check for the serialnumber, as the session id is not unique.
    //
    if (pWinStation)
    {
        if (SessionSerialNumber == pWinStation->SessionSerialNumber)
        {
            PNOTIFY_LIST pConsoleList;

            Status = GetNoficationListFromSessionId(pWinStation->LogonId, &pConsoleList, FALSE);
            if (NT_SUCCESS(Status) && pConsoleList)
            {
                PLIST_ENTRY Head, Next;
                Head = &pConsoleList->ListHead;
                for ( Next = Head->Flink; Next != Head; Next = Next->Flink )
                {
                    PNOTIFY_ENTRY pEntry;
                    pEntry = CONTAINING_RECORD( Next, NOTIFY_ENTRY, Links );
                    ASSERT(pEntry);
                    ASSERT(!(pEntry->dwFlags & WTS_ALL_SESSION_NOTIFICATION));

                    if (IsBitSet(pEntry->dwMask, wParam))
                    {
                        if (pEntry->dwFlags & WTS_EVENT_NOTIFICATION)
                        {
                            SetEvent((HANDLE)pEntry->hWnd);
                        }
                        else
                        {
                            Status = SendNotificationToHwnd(pWinStation, pEntry->hWnd, SessionId, wParam);

                            if (!NT_SUCCESS(Status))
                            {
                                NTSDDBGPRINT(("conntfy.c - SendWinStationCommand failed, Status = %d.\n", Status));
                            }
                        }
                    }
                }

                UpdateSessionState(pConsoleList, wParam);

                ReleaseNotificationList( pConsoleList );
            }
        }

        ReleaseWinStation( pWinStation );
    }

    //
    // now send notifications to windows registered for all session notificaitons.
    //
    {
        PNOTIFY_LIST pNotifyListGlobal = NULL;

        Status = GetGlobalNotificationList(&pNotifyListGlobal);
        if (NT_SUCCESS(Status))
        {
            PLIST_ENTRY Head, Next;
            Head = &pNotifyListGlobal->ListHead;

            for ( Next = Head->Flink; Next != Head; Next = Next->Flink )
            {
                PNOTIFY_ENTRY_GLOBAL pEntryGlobal = NULL;
                pEntryGlobal = CONTAINING_RECORD( Next, NOTIFY_ENTRY_GLOBAL, Links );
                ASSERT(pEntryGlobal);
                ASSERT(pEntryGlobal->dwFlags & WTS_ALL_SESSION_NOTIFICATION);
                
                if (IsBitSet(pEntryGlobal->dwMask, wParam))
                {
                    if (pEntryGlobal->dwFlags & WTS_EVENT_NOTIFICATION)
                    {
                        SetEvent((HANDLE)pEntryGlobal->hWnd);
                    }
                    else
                    {
                        pWinStation = FindWinStationById(pEntryGlobal->SessionId, FALSE);
                        if (pWinStation)
                        {
                            if  (!pWinStation->Terminating)
                            {
                                Status = SendNotificationToHwnd(pWinStation, pEntryGlobal->hWnd, SessionId, wParam);
                        
                                if (!NT_SUCCESS(Status))
                                {
                                    NTSDDBGPRINT(("conntfy.c - SendWinStationCommand failed, Status = %d.\n", Status));
                                }
                            }
                    
                            ReleaseWinStation( pWinStation );
                        }
                    }
                }
            }

            ReleaseNotificationList(pNotifyListGlobal);
        }
        else
        {
            NTSDDBGPRINT(("conntfy.c - Failed to get all session notification list - status = 0x%x.\n", Status));
        }
    }


    //
    // now lets notify SCM which will notify all the services registered for SERVICE_ACCEPT_SESSIONCHANGE
    //

    //
    // logon logoff notifications for session 0 are sent by winlogon. rest are handled here.
    //
    if (SessionId != 0 || ( wParam != WTS_SESSION_LOGON && wParam != WTS_SESSION_LOGOFF))
    {

        WTSSESSION_NOTIFICATION wtsConsoleNotification;
        wtsConsoleNotification.cbSize = sizeof(WTSSESSION_NOTIFICATION);
        wtsConsoleNotification.dwSessionId = SessionId;

        dwError = I_ScSendTSMessage(
                SERVICE_CONTROL_SESSIONCHANGE,        // op code
                (DWORD)wParam,                        // event code,
                wtsConsoleNotification.cbSize,        // data size
                (LPBYTE)&wtsConsoleNotification       // data.
                );

    }

    return Status;
}



NTSTATUS DestroyLock( PNOTIFY_LIST pNtfyList)
{
    return RtlDeleteCriticalSection( &pNtfyList->ListLock );
}

NTSTATUS CreateLock (PNOTIFY_LIST pNtfyList)
{
    return RtlInitializeCriticalSection( &pNtfyList->ListLock );
}


BOOL IsInvalidHWndList (PNOTIFY_LIST pNtfyList)
{
    return (pNtfyList == &gNotifyLList.InvlidHwndList);
}
BOOL IsGlobalList(PNOTIFY_LIST pNtfyList)
{
    return (pNtfyList == &gNotifyLList.GlobalList);
}

int GetListCount (LIST_ENTRY *pListHead)
{
    PLIST_ENTRY Head, Next;
    int iCount = 0;

    ASSERT(pListHead);

    Head = pListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink )
    {
        iCount++;
    }

    return iCount;
}

PNOTIFY_ENTRY GetHWndEntryFromSessionList(PNOTIFY_LIST pNotifyList, ULONG_PTR hWnd, DWORD dwFlags)
{
    
    PLIST_ENTRY Head = NULL;
    PLIST_ENTRY Next = NULL;
    PNOTIFY_ENTRY pEntry = NULL;

    Head = &pNotifyList->ListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink )
    {
        pEntry = CONTAINING_RECORD( Next, NOTIFY_ENTRY, Links );

        ASSERT(pEntry);
        ASSERT(!(pEntry->dwFlags & WTS_EVENT_NOTIFICATION && pEntry->dwFlags & WTS_WINDOW_NOTIFICATION));

        if (pEntry->hWnd == hWnd && pEntry->dwFlags & dwFlags)
        {
            return pEntry;
        }
    }

    return NULL;
}

PNOTIFY_ENTRY_GLOBAL GetHWndEntryFromGlobalList(PNOTIFY_LIST pNotifyList, ULONG_PTR hWnd, ULONG SessionId, DWORD dwFlags)
{
    PLIST_ENTRY Head = NULL;
    PLIST_ENTRY Next = NULL;
    PNOTIFY_ENTRY_GLOBAL pEntry = NULL;

    Head = &pNotifyList->ListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink )
    {
        pEntry = CONTAINING_RECORD( Next, NOTIFY_ENTRY_GLOBAL, Links );

        ASSERT(pEntry);
        ASSERT(!(pEntry->dwFlags & WTS_EVENT_NOTIFICATION && pEntry->dwFlags & WTS_WINDOW_NOTIFICATION));

        if (pEntry->hWnd == hWnd && SessionId == pEntry->SessionId  && pEntry->dwFlags & dwFlags)
        {
            return pEntry;
        }
    }

    return NULL;
}

//
// returns PNOTIFY_LIST list for the given session.
//
NTSTATUS GetNoficationListFromSessionId (ULONG SessionId, PNOTIFY_LIST *ppNotifyList, BOOL bKeepLListLocked)
{
    PLIST_ENTRY Next, Head;

    ASSERT(ppNotifyList);

    *ppNotifyList = NULL;

    // lock our list of lists.
    ENTERCRIT(&gNotifyLList.ListLock);



    Head = &gNotifyLList.ListHead;
    Next = Head->Flink;
    while (Head != Next)
    {
        PNOTIFY_LIST pNotifyList = CONTAINING_RECORD( Next, NOTIFY_LIST, Links );

        ASSERT( pNotifyList );

        //
        // we always take gNotifyLList.ListLock first and then the Listlock
        // therefore we must never have PNOTIFY_LIST.ListLock at this time.
        //
        ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != pNotifyList->ListLock.OwningThread );


        if (pNotifyList->SessionId == SessionId)
        {
            //
            // did we find more that 1 matching notify list ???, should never happen!
            //
            ASSERT(*ppNotifyList == NULL);

            //
            // ok we found the session list we were looking for
            //
            *ppNotifyList = pNotifyList;

#ifndef DBG
            break;
#endif
        }

        Next = Next->Flink;
    }

    //
    // if we have found the list we were looking for
    //
    if (*ppNotifyList)
    {
        //
        // lock the list before returning.
        //
        ENTERCRIT(&(*ppNotifyList)->ListLock);
    }

    if (!(*ppNotifyList) || !bKeepLListLocked)
    {
        //
        // unlock llist lock.
        //
        LEAVECRIT(&gNotifyLList.ListLock);
    }

    if (*ppNotifyList)
    {
        return STATUS_SUCCESS;
    }
    else
    {
        return STATUS_NO_SUCH_LOGON_SESSION;
    }
}

void ReleaseNotificationList  (PNOTIFY_LIST pNotifyList)
{
    ASSERT(pNotifyList);
    if (IsInvalidHWndList(pNotifyList))
    {
        // we must take invalid hwnd list before taking global list.
        ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (gNotifyLList.GlobalList.ListLock).OwningThread );
        // we must take invalid hwnd list before taking LList.
        ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (gNotifyLList.ListLock).OwningThread );
    }
    else if (IsGlobalList(pNotifyList))
    {
        // we must take invalid hwnd list before taking LList.
        ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (gNotifyLList.ListLock).OwningThread );
    }

    LEAVECRIT(&pNotifyList->ListLock);
}

NTSTATUS GetInvlidHwndList(PNOTIFY_LIST *ppConChgNtfy)
{
    ASSERT(ppConChgNtfy);
    
    // we must take invalid hwnd list before taking global list.
    ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (gNotifyLList.GlobalList.ListLock).OwningThread );
    
    // we must take invalid hwnd list before taking LList.
    ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (gNotifyLList.ListLock).OwningThread );

    *ppConChgNtfy = &gNotifyLList.InvlidHwndList;
    ENTERCRIT(&(*ppConChgNtfy)->ListLock);

    ASSERT(gNotifyLList.InvlidHwndList.Links.Blink == NULL);
    ASSERT(gNotifyLList.InvlidHwndList.Links.Flink == NULL);
    ASSERT(gNotifyLList.InvlidHwndList.SessionId == INVALID_SESSIONID);
    ASSERT(gNotifyLList.InvlidHwndList.SessonSerialNumber == INVALID_SESSIONSERIAL);
    
    return STATUS_SUCCESS;
}

NTSTATUS GetGlobalNotificationList(PNOTIFY_LIST *ppConChgNtfy)
{
    ASSERT(ppConChgNtfy);
    
    // we must LLIst after global list.
    ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (gNotifyLList.ListLock).OwningThread );
    
    *ppConChgNtfy = &gNotifyLList.GlobalList;

    ENTERCRIT(&(*ppConChgNtfy)->ListLock);

    ASSERT(gNotifyLList.GlobalList.Links.Blink == NULL);
    ASSERT(gNotifyLList.GlobalList.Links.Flink == NULL);
    ASSERT(gNotifyLList.GlobalList.SessionId == INVALID_SESSIONID);
    ASSERT(gNotifyLList.GlobalList.SessonSerialNumber == INVALID_SESSIONSERIAL);

    return (STATUS_SUCCESS);
}


NTSTATUS InitializeNotificationQueue ()
{
    DWORD ThreadId;
    NTSTATUS Status;
    HANDLE hSessionNotifyThread;

    InitializeListHead( &gNotifyLList.RequestQueue.ListHead);

    gNotifyLList.RequestQueue.hNotificationEvent = CreateEvent(
        NULL,    // SD
        FALSE, // reset type
        FALSE, // initial state
        NULL    // object name
        );

    if (gNotifyLList.RequestQueue.hNotificationEvent == NULL)
    {
        // we failed to create event.
        // return GetLastError()
        return STATUS_UNSUCCESSFUL;

    }

    Status = RtlInitializeCriticalSection( &gNotifyLList.RequestQueue.ListLock );
    if (!NT_SUCCESS(Status))
    {
        CloseHandle(gNotifyLList.RequestQueue.hNotificationEvent);
        gNotifyLList.RequestQueue.hNotificationEvent = NULL;
        return Status;
    }

    //
    // now create thread for notifications.
    //
    hSessionNotifyThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)NotificationQueueWorker,
        NULL,
        0,
        &ThreadId);

    //
    // Just close it, we can do without this handle.
    //
    if( hSessionNotifyThread )
    {
        CloseHandle( hSessionNotifyThread );
    }
    else
    {
        
        RtlDeleteCriticalSection( &gNotifyLList.RequestQueue.ListLock );

        CloseHandle(gNotifyLList.RequestQueue.hNotificationEvent);
        gNotifyLList.RequestQueue.hNotificationEvent = NULL;

        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

void LockNotificationQueue()
{
    ENTERCRIT(&gNotifyLList.RequestQueue.ListLock);
}

void UnLockNotificationQueue()
{
    LEAVECRIT(&gNotifyLList.RequestQueue.ListLock);
}


//
// Queues a notification entry
//
NTSTATUS QueueNotificationRequest(ULONG SessionSerialNumber, ULONG SessionId, WPARAM notification)
{
    PNOTIFICATION_REQUEST pRequest = NULL;
    pRequest = MemAlloc( sizeof(NOTIFICATION_REQUEST) );

    if (!pRequest)
    {
        return STATUS_NO_MEMORY;
    }

    pRequest->SessonSerialNumber = SessionSerialNumber;
    pRequest->SessionId = SessionId;
    pRequest->NotificationCode = notification;

    // now lock the queue
    LockNotificationQueue();
    InsertHeadList(&gNotifyLList.RequestQueue.ListHead, &pRequest->Links);
    UnLockNotificationQueue();

    // let the waiting thread process this notification.
    PulseEvent(gNotifyLList.RequestQueue.hNotificationEvent);
    return STATUS_SUCCESS;
}

//
// takes out a notification entry from queue.
//
PNOTIFICATION_REQUEST UnQueueNotificationRequest()
{
    PLIST_ENTRY pEntry;
    PNOTIFICATION_REQUEST pRequest = NULL;

    //
    //  Remove a request from the list.
    //
    LockNotificationQueue();
    if (!IsListEmpty(&gNotifyLList.RequestQueue.ListHead))
    {
        pEntry = RemoveTailList(&gNotifyLList.RequestQueue.ListHead);
        pRequest = CONTAINING_RECORD(pEntry, NOTIFICATION_REQUEST, Links);
    }
    
    UnLockNotificationQueue();

    return pRequest;
}


// This thread is a helper for the next function.  We do this because the
// compiler defies reason by insisting not all control paths return a value.
VOID NotificationQueueWorkerEx()
{
    PNOTIFICATION_REQUEST pRequest = NULL;

    for(;;)
    {
        WaitForSingleObject(gNotifyLList.RequestQueue.hNotificationEvent, INFINITE); // wait for the event to be signaled.
        
        while ((pRequest = UnQueueNotificationRequest()) != NULL)
        {
            if (!pRequest->NotificationCode)
            {
                ASSERT(FALSE);
                // this is not a real notificaiton request.
                // this request is for session removal.
                // RemoveGlobalNotification(pRequest->SessionId, pRequest->SessonSerialNumber);
            }
            else
            {
                NotifyConsole (pRequest->SessionId, pRequest->SessonSerialNumber, pRequest->NotificationCode);
            }

            MemFree(pRequest);
            pRequest = NULL;
        }
    }
}

//
// this thread takes a notification request from queue and executes it.
// this thread gets signaled when a new item is added to the queue.
//
DWORD NotificationQueueWorker(LPVOID ThreadParameter)
{
    UNREFERENCED_PARAMETER(ThreadParameter);

    NotificationQueueWorkerEx();

    return 0;
}

NTSTATUS SetLockedState (PWINSTATION  pWinStation, BOOL bLocked)
{
    ASSERT(pWinStation);

    if (bLocked)
    {
        return NofifyWelcomeOn (pWinStation);
    }
    else
    {
        return NotifyWelcomeOff (pWinStation);
    }
}

NTSTATUS GetLockedState (PWINSTATION  pWinStation, BOOL *pbLocked)
{
    NTSTATUS Status;
    PNOTIFY_LIST pNotifyList;

    ASSERT(pbLocked);
    ASSERT(pWinStation);

    Status = GetNoficationListFromSessionId(pWinStation->LogonId, &pNotifyList, FALSE);
    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }

    *pbLocked = pNotifyList->SessionState.bLocked;
    ReleaseNotificationList(pNotifyList);
    return STATUS_SUCCESS;
}
/*
NTSTATUS GetSessionState (PWINSTATION  pWinStation, WTSSESSION_STATE *pSessionState)
{
    NTSTATUS Status;
    PNOTIFY_LIST pNotifyList;

    ASSERT(pSessionState);
    ASSERT(pWinStation);

    Status = GetNoficationListFromSessionId(pWinStation->LogonId, &pNotifyList, FALSE);
    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }

    *pSessionState = pNotifyList->SessionState;
    ReleaseNotificationList(pNotifyList);

    return STATUS_SUCCESS;
}
*/

NTSTATUS RemoveBadHwnd(ULONG_PTR hWnd, ULONG SessionId)
{
    PNOTIFY_ENTRY_GLOBAL pInvalidHwndEntry;
    PNOTIFY_LIST pInvalidHwndList;
    NTSTATUS Status;

    Status = GetInvlidHwndList(&pInvalidHwndList);
    
    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }

    pInvalidHwndEntry = GetHWndEntryFromGlobalList(pInvalidHwndList, hWnd, SessionId, WTS_WINDOW_NOTIFICATION);
    //
    // this entry must not already exist in invalid list.
    //
    if(!pInvalidHwndEntry)
    {
        // it alreay exists in our list. 
        pInvalidHwndEntry = MemAlloc(sizeof(NOTIFY_ENTRY_GLOBAL));
        if (pInvalidHwndEntry)
        {
            pInvalidHwndEntry->hWnd = hWnd;
            pInvalidHwndEntry->SessionId = SessionId;
            pInvalidHwndEntry->dwFlags = WTS_WINDOW_NOTIFICATION;
            pInvalidHwndEntry->RefCount = 0xFFFFFFFF;
            pInvalidHwndEntry->dwMask = 0xFFFFFFFF;

            InsertHeadList(&pInvalidHwndList->ListHead, &pInvalidHwndEntry->Links);
        }
    }
    
    ReleaseNotificationList( pInvalidHwndList );

    if (pInvalidHwndEntry)
        return STATUS_SUCCESS;
    else 
        return STATUS_NO_MEMORY;
}

NTSTATUS RemoveBadEvents(DWORD SessionId)
{
    PNOTIFY_LIST pListGlobal = NULL;
    PLIST_ENTRY Next, Head;
    PNOTIFY_LIST pNotifyList = NULL;

    NTSTATUS Status = GetGlobalNotificationList(&pListGlobal);

    if (NT_SUCCESS( Status ))
    {
        Head = &pListGlobal->ListHead;
        Next = Head->Flink;
        while (Head != Next)
        {
            PNOTIFY_ENTRY_GLOBAL pEntryGlobal = CONTAINING_RECORD( Next, NOTIFY_ENTRY_GLOBAL, Links );
            Next = Next->Flink;
            ASSERT(pEntryGlobal);
            if ((pEntryGlobal->SessionId == SessionId) && (pEntryGlobal->dwFlags & WTS_EVENT_NOTIFICATION))
            {
                OBJECT_BASIC_INFORMATION Obi;
                Status = NtQueryObject(
                    (HANDLE)pEntryGlobal->hWnd,
                    ObjectBasicInformation,
                    &Obi,
                    sizeof (OBJECT_BASIC_INFORMATION),
                    NULL
                    );

                if (Status == STATUS_SUCCESS) 
                {
                    ASSERT(Obi.HandleCount >= 1);
                    if (Obi.HandleCount == 1) 
                    {
                        //
                        // its just us referencing this event. 
                        // let it go.
                        //
                        RemoveEntryList( &pEntryGlobal->Links );
                        CloseHandle((HANDLE)pEntryGlobal->hWnd);
                        MemFree(pEntryGlobal);
                        pEntryGlobal = NULL;

                    }
                }
                else
                {
                    NTSDDBGPRINT(("conntfy.c - NtQueryObject failed, Status = %d.\n", Status));
                }
            }
        }
        
        ReleaseNotificationList(pListGlobal);
        pListGlobal = NULL;

    }
    else
    {
        NTSDDBGPRINT(("conntfy.c - GetGlobalNotificationList failed, Status = %d.\n", Status));
    }

    
    Status = GetNoficationListFromSessionId( SessionId, &pNotifyList, FALSE);
    if (NT_SUCCESS( Status ))
    {
        Head = &pNotifyList->ListHead;
        Next = Head->Flink;
        while (Head != Next)
        {
            PNOTIFY_ENTRY pEntry = CONTAINING_RECORD( Next, NOTIFY_ENTRY, Links );
            Next = Next->Flink;
            ASSERT(pEntry);
            if (pEntry->dwFlags & WTS_EVENT_NOTIFICATION)
            {
                OBJECT_BASIC_INFORMATION Obi;
                Status = NtQueryObject(
                    (HANDLE)pEntry->hWnd,
                    ObjectBasicInformation,
                    &Obi,
                    sizeof (OBJECT_BASIC_INFORMATION),
                    NULL
                    );

                if (Status == STATUS_SUCCESS) 
                {
                    ASSERT(Obi.HandleCount >= 1);
                    if (Obi.HandleCount == 1) 
                    {
                        //
                        // its just us referencing this event. 
                        // let it go.
                        //
                        RemoveEntryList( &pEntry->Links );
                        CloseHandle((HANDLE)pEntry->hWnd);
                        MemFree(pEntry);
                        pEntry = NULL;

                    }
                }
            }
        }
        
        ReleaseNotificationList(pNotifyList);
        pNotifyList = NULL;
    }
    else
    {
        NTSDDBGPRINT(("conntfy.c - GetNoficationListFromSessionId failed, Status = %d.\n", Status));
    }

    return Status;
}

NTSTATUS RemoveInvalidWindowsFromLists()
{
    PNOTIFY_LIST pInvalidHwndList;
    PLIST_ENTRY Next, Head;
    NTSTATUS Status;

    Status = GetInvlidHwndList(&pInvalidHwndList);
   
    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }

    Head = &pInvalidHwndList->ListHead;
    Next = Head->Flink;
    while (Head != Next)
    {
        PNOTIFY_ENTRY_GLOBAL pInvalidHwndEntry = CONTAINING_RECORD( Next, NOTIFY_ENTRY_GLOBAL, Links );
        Next = Next->Flink;
        ASSERT(pInvalidHwndEntry);
        Status = UnRegisterConsoleNotificationInternal (pInvalidHwndEntry->hWnd, pInvalidHwndEntry->SessionId, FALSE, WTS_WINDOW_NOTIFICATION);

        // we are done removing this invalid hwnd entry from our lists.
        RemoveEntryList( &pInvalidHwndEntry->Links );
        MemFree(pInvalidHwndEntry);
        pInvalidHwndEntry = NULL;
    }

    ReleaseNotificationList(pInvalidHwndList);

    return STATUS_SUCCESS;
}


/*
    our order of locks is

    0. Invalid Hwnd List.
    1. Global Notification List
    2. Winstation
    3. List of Lists lock.
    4. Session Notification List
*/

//#ifdef MAKARANDS_HIGHER_WARNING_LEVEL
#pragma warning(pop)
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\filters.h ===
#ifndef __FILTERS_H__
#define __FILTERS_H__

#define FILTERDEBUG 1

#ifdef FILTERDEBUG
#define FILTER_DBGPRINT(x) DbgPrint x
#else
#define FILTER_DBGPRINT(x)
#endif

// Linked list to maintain connections which failed authentication                                    
typedef struct _TS_FAILEDCONNECTION {
    ULONGLONG  blockUntilTime;
    PULONGLONG pTimeStamps;         // an array for holding the TimeStamps of Failed Connections 
    ULONG      NumFailedConnect;
    UINT       uAddrSize;
    BYTE       addr[16];
    struct _TS_FAILEDCONNECTION *pNext;
} TS_FAILEDCONNECTION, *PTS_FAILEDCONNECTION;

RTL_GENERIC_TABLE           gFailedConnections;

// Lock for Denial of Service handling
RTL_CRITICAL_SECTION        DoSLock;

BOOL
Filter_CheckIfBlocked(
        IN PBYTE    pin_addr,
        IN UINT     uAddrSize
        );

BOOL
Filter_AddFailedConnection(
        IN PBYTE    pin_addr,
        IN UINT     uAddrSize
        );


#endif /* __FILTERS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\filters.c ===
//********************************************************************************************/
// filters.c
//
// TermSrv code to filter incoming session Requests - Denial of Service policy implementations
//
// Author : SriramSa 
//
// Copyright (C) 1997-2001 Microsoft Corporation
/*********************************************************************************************/


#include "precomp.h"
#pragma hdrstop

#include <msaudite.h>
#include "filters.h"

PTS_FAILEDCONNECTION   g_pFailedBlockedConnections = NULL;
extern ULONG MaxFailedConnect;
extern ULONG DoSBlockTime;
extern ULONG TimeLimitForFailedConnections;
extern ULONG CleanupTimeout;

BOOLEAN IsTimeDiffLessThanDelta(ULONGLONG CurrentTime, ULONGLONG LoggedTime, ULONG Delta);
VOID CleanupTimeoutRoutine( VOID );
VOID Filter_CleanupBadIPTable( VOID );

BOOL
Filter_CheckIfBlocked(
        IN PBYTE    pin_addr,
        IN UINT     uAddrSize
        )
{                                     
    BOOL bBlocked = FALSE ;
    PTS_FAILEDCONNECTION pPrev, pIter;
    ULONGLONG currentTime; 

    // Check in the blocked linked list if this IP is present

    if (g_pFailedBlockedConnections == NULL) {
        // nothing in the list
        return bBlocked ;
    }

    pPrev = NULL;
    pIter = g_pFailedBlockedConnections;
    while ( NULL != pIter ) {

        if ( uAddrSize == pIter->uAddrSize &&
             uAddrSize == RtlCompareMemory( pIter->addr, pin_addr, uAddrSize )) {
            break;
        }
        pPrev = pIter;
        pIter = pIter->pNext;
    }

    if ( NULL != pIter ) {

        // present in blocked list
        // Check time to which we shud block from this IP

        GetSystemTimeAsFileTime( (LPFILETIME)&currentTime );
        if ( currentTime > pIter->blockUntilTime ) {
            // unblock, remove from list
            if ( NULL != pPrev ) {
                pPrev->pNext = pIter->pNext;
            } else {
                g_pFailedBlockedConnections = pIter->pNext;
            }
            MemFree( pIter );

        } else {
            bBlocked = TRUE;
        }

    } 

    return bBlocked;
}

BOOL
Filter_AddFailedConnection(
        IN PBYTE    pin_addr,
        IN UINT     uAddrSize
        )
{
    BOOL bAdded = TRUE, bAlreadyBlocked = FALSE;
    TS_FAILEDCONNECTION key;
    PTS_FAILEDCONNECTION pIter, pPrev;
    ULONGLONG currentTime;
    BOOLEAN bNewElement;
    PVOID bSucc;

    RtlCopyMemory( key.addr, pin_addr, uAddrSize );
    key.uAddrSize = uAddrSize;

    // Check Table of Failed IP to see if this is a new IP to be blocked
    GetSystemTimeAsFileTime( (LPFILETIME)&currentTime );

    ENTERCRIT( &DoSLock );

    pIter = RtlLookupElementGenericTable( &gFailedConnections, &key );

    if ( NULL == pIter ) {

        // This IP is not present in table 
        // Check if its already blocked 
        bAlreadyBlocked = Filter_CheckIfBlocked( pin_addr, uAddrSize);

        if (bAlreadyBlocked) {
            goto success; 
        } else {
            // this is a new IP 
            // Add it to the Table 
            key.NumFailedConnect = 1;
            key.pTimeStamps = MemAlloc( MaxFailedConnect * sizeof(ULONGLONG) );
            if (key.pTimeStamps == NULL) {
                goto error;
            }
            key.pTimeStamps[key.NumFailedConnect - 1] = currentTime;
            key.blockUntilTime = 0;

            bSucc = RtlInsertElementGenericTable( &gFailedConnections, &key, sizeof( key ), &bNewElement );

            if ( !bSucc ) {
                FILTER_DBGPRINT(("Filter_AddFailedConnection : Unable to add IP to table ! \n"));
                MemFree(key.pTimeStamps);
                goto error;
            } 
            ASSERT( bNewElement );
        }

    } else {
        // This is already in table
        pIter->NumFailedConnect++;
        if (pIter->NumFailedConnect == MaxFailedConnect) {
            BOOL bBlockIt = FALSE ; 
            // ok max bad connections from this IP
            bBlockIt = IsTimeDiffLessThanDelta( currentTime, pIter->pTimeStamps[0], TimeLimitForFailedConnections ) ; 
            if (bBlockIt) {

                // No need for the TimeStamps list anymore - free it

                if (pIter->pTimeStamps) {
                    MemFree(pIter->pTimeStamps);
                    pIter->pTimeStamps = NULL;
                }

                // Time Diff was less than Delta 
                // Need to block this guy for "m" minutes
                // Calculate time to which to block this IP
                // Add to blocking list

                key.NumFailedConnect = pIter->NumFailedConnect;
    
                // DoSBlockTime is in ms
                // currentTime is in 100s ns
                key.blockUntilTime = currentTime + ((ULONGLONG)10000) * ((ULONGLONG)DoSBlockTime);
    
                RtlDeleteElementGenericTable( &gFailedConnections, &key );
    
                //
                //  add to the blocked connections
                //
                pIter = MemAlloc ( sizeof(TS_FAILEDCONNECTION) );
                if (pIter == NULL) {
                    goto error;
                }
    
                RtlCopyMemory( pIter, &key, sizeof(TS_FAILEDCONNECTION));
                pIter->pNext = g_pFailedBlockedConnections;
                g_pFailedBlockedConnections = pIter;

                // Note -- We may want to event log the fact that this IP is blocked for "M" minutes here - Check 

            } else {
                UINT i ;
                // Time Diff betn 1st and 5th was more than Delta
                pIter->NumFailedConnect--;
                // No need to block now  - just LeftShift timestamps by 1 
                for (i = 0; i <= MaxFailedConnect - 3; i++) {
                    pIter->pTimeStamps[i] = pIter->pTimeStamps[i+1] ; 
                }

                pIter->pTimeStamps[MaxFailedConnect - 2] = currentTime;
                pIter->pTimeStamps[MaxFailedConnect - 1] = 0;

            }

        } else if (pIter->NumFailedConnect < MaxFailedConnect) {
            // less than 5 bad connections - not a problem -- just mark the TimeStamp 
            pIter->pTimeStamps[pIter->NumFailedConnect - 1] = currentTime;

        } else {
            FILTER_DBGPRINT(("Filter_AddFailedConnection : More than max connections (Num = %d) from IP and still in Table ?!?! \n", pIter->NumFailedConnect));
            ASSERT(FALSE);
        }
    }

    // 
    // If the Cleanup timer is not already started, we need to start it now !!
    //

    if ( (InterlockedExchange(&g_CleanupTimerOn, TRUE)) == FALSE ) {
        IcaTimerStart( hCleanupTimer, 
                       CleanupTimeoutRoutine,
                       NULL,
                       CleanupTimeout );

    }

success : 
    LEAVECRIT( &DoSLock );
    return bAdded ;

error : 
    // handle errors
    bAdded = FALSE;
    LEAVECRIT( &DoSLock );
    return bAdded ;
}

// FinalTime and InitialTime are in 100s of nanoseconds
// Delta is in milli seconds
BOOLEAN IsTimeDiffLessThanDelta(ULONGLONG FinalTime, ULONGLONG InitialTime, ULONG Delta) 
{
    BOOLEAN bLessThanFlag = FALSE;
    ULONGLONG RealDelta ;

    // convert Delta to 100s of nanoseconds
    RealDelta = Delta * 100000 ; 

    if ( (FinalTime - InitialTime) <= RealDelta ) {
        bLessThanFlag = TRUE ;
    }

    return bLessThanFlag;
}


VOID
Filter_CleanupBadIPTable(
    VOID
    )
{
    PTS_FAILEDCONNECTION p;
    TS_FAILEDCONNECTION con;

    while (p = RtlEnumerateGenericTable( &gFailedConnections, TRUE))  {
        RtlCopyMemory( &con, p, sizeof( con ));
        if (p->pTimeStamps) {
            MemFree(p->pTimeStamps);
        }
        RtlDeleteElementGenericTable( &gFailedConnections, &con);
    }

    return;

}

/*******************************************************************************
 *
 *  CleanupTimeoutRoutine
 *
 *  This routine is called when the Cleanup timer fires.
 *  Cleanup the Bad IP table.
 *
 * ENTRY:
 *   None.
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID CleanupTimeoutRoutine( VOID )
{

    ASSERT( g_CleanupTimerOn );
    //
    // We dont want anyone to modify/read the bad ip table when we r gonna cleanup the table itself
    //
    ENTERCRIT( &DoSLock );
    Filter_CleanupBadIPTable();
    LEAVECRIT( &DoSLock );

    // Close the Cleanup timer

    if ( (InterlockedExchange(&g_CleanupTimerOn, FALSE)) == TRUE ) {
        if (hCleanupTimer != NULL) {
            IcaTimerCancel(hCleanupTimer);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\helpasst.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    helpasst.h

Abstract:

    Prototype for Help Assistant account related function

Author:

    HueiWang    4/26/2000

--*/

#ifndef __HELPASST_H__
#define __HELPASST_H__

#include "tsremdsk.h"

#ifdef __cplusplus
extern "C"{
#endif

BOOL
TSIsSessionHelpSession(
    PWINSTATION pWinStation,
    BOOL* pValid
);

NTSTATUS
TSHelpAssistantQueryLogonCredentials(
    ExtendedClientCredentials* pCredential
);

BOOL
TSVerifyHelpSessionAndLogSalemEvent(
    PWINSTATION pWinStation
);

VOID
TSStartupSalem();

VOID
TSLogSalemReverseConnection(
    PWINSTATION pWinStation,
    PICA_STACK_ADDRESS pStackAddress
);

HRESULT
TSRemoteAssistancePrepareSystemRestore();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\conntfy.h ===
#ifndef __CONNTFY_H__
#define __CONNTFY_H__


#include <wtsapi32.h>

//
// notification flags.
// to make these public they they should go into wtsapi32.h
//
#define WTS_ALL_SESSION_NOTIFICATION      0x1
#define WTS_EVENT_NOTIFICATION            0x2 
#define WTS_WINDOW_NOTIFICATION           0x4 // mutually exclusive with WTS_EVENT_NOTIFICATION

#define WTS_MAX_SESSION_NOTIFICATION  WTS_SESSION_REMOTE_CONTROL

/*
 * interface
 */

NTSTATUS InitializeConsoleNotification      ();
NTSTATUS InitializeSessionNotification      (PWINSTATION  pWinStation);
NTSTATUS RemoveSessionNotification          (ULONG SessionId, ULONG SessionSerialNumber);

NTSTATUS RegisterConsoleNotification ( ULONG_PTR hWnd, ULONG SessionId, DWORD dwFlags, DWORD dwMask);
//NTSTATUS RegisterConsoleNotification        (ULONG_PTR hWnd, ULONG SessionId, DWORD dwFlags);
NTSTATUS UnRegisterConsoleNotification      (ULONG_PTR hWnd, ULONG SessionId, DWORD dwFlags);

NTSTATUS NotifyDisconnect                   (PWINSTATION  pWinStation, BOOL bConsole);
NTSTATUS NotifyConnect                      (PWINSTATION  pWinStation, BOOL bConsole);
NTSTATUS NotifyLogon                        (PWINSTATION  pWinStation);
NTSTATUS NotifyLogoff                       (PWINSTATION  pWinStation);
NTSTATUS NotifyShadowChange                 (PWINSTATION  pWinStation, BOOL bIsHelpAssistant);

NTSTATUS GetLockedState (PWINSTATION  pWinStation, BOOL *pbLocked);
NTSTATUS SetLockedState (PWINSTATION  pWinStation, BOOL bLocked);



#endif /* __CONNTFY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\helpasst.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    helpass.c

Abstract:

    Salem related function.

Author:

    HueiWang    4/26/2000

--*/

#define LSCORE_NO_ICASRV_GLOBALS
#include "precomp.h"
#include <tdi.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include "tsremdsk.h"
#include "sessmgr.h"
#include "sessmgr_i.c"

extern "C" 
NTSTATUS
xxxQueryRemoteAddress(
    PWINSTATION pWinStation,
    PWINSTATIONREMOTEADDRESS pRemoteAddress
);

HRESULT
__LogSalemEvent(
    IN IRemoteDesktopHelpSessionMgr* iSessMgr,
    IN ULONG eventType,
    IN ULONG eventCode,
    IN int numStrings,
    IN BSTR EventStrings[]
);

//
// Function copied from atlconv.h, we don't include
// any ATL header in termsrv.
//
BSTR A2WBSTR(LPCSTR lp)
{
    if (lp == NULL)
        return NULL;

    BSTR str = NULL;
    int nConvertedLen = MultiByteToWideChar(
                                    GetACP(), 0, lp,
                                    -1, NULL, NULL)-1;

    str = ::SysAllocStringLen(NULL, nConvertedLen);
    if (str != NULL)
    {
        MultiByteToWideChar(GetACP(), 0, lp, -1,
            str, nConvertedLen);
    }

    return str;
}

NTSTATUS
TSHelpAssistantQueryLogonCredentials(
    ExtendedClientCredentials* pCredential
    ) 
/*++

Description:

    Retrieve HelpAssistant logon credential, routine first retrieve
    infor passed from client and then decrypt password

Parameters:

    pWinStation : Pointer to WINSTATION
    pCredential : Pointer to ExtendedClientCredentials to receive HelpAssistant
                  credential.

Returns:

    STATUS_SUCCESS or STATUS_INVALID_PARAMETER

--*/
{
    LPWSTR pszHelpAssistantPassword = NULL;
    NTSTATUS Status;
    LPWSTR pszHelpAssistantAccountName = NULL;
    LPWSTR pszHelpAssistantAccountDomain = NULL;

    if( pCredential )
    {
        ZeroMemory( pCredential, sizeof(ExtendedClientCredentials) );

        Status = TSGetHelpAssistantAccountName(&pszHelpAssistantAccountDomain, &pszHelpAssistantAccountName);
        if( ERROR_SUCCESS == Status )
        {
            // make sure we don't overwrite buffer, length can't be
            // more than 255 characters.
            lstrcpyn( 
                    pCredential->UserName, 
                    pszHelpAssistantAccountName, 
                    EXTENDED_USERNAME_LEN 
                );

            lstrcpyn(
                    pCredential->Domain,
                    pszHelpAssistantAccountDomain,
                    EXTENDED_DOMAIN_LEN
                );

            Status = TSGetHelpAssistantAccountPassword( &pszHelpAssistantPassword );
            if( ERROR_SUCCESS == Status )
            {
                ASSERT( lstrlen(pszHelpAssistantPassword) < EXTENDED_PASSWORD_LEN );

                int nPasswordlen = lstrlen( pszHelpAssistantPassword );

                if( nPasswordlen < EXTENDED_PASSWORD_LEN )
                {
                    // Password contains encrypted version, overwrite with
                    // clear text.
                    lstrcpy( pCredential->Password, pszHelpAssistantPassword );

                    SecureZeroMemory( pszHelpAssistantPassword , nPasswordlen * sizeof( WCHAR ) );
                }
                else
                {
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
        }
    }
    else
    {
        ASSERT( FALSE );
        Status = STATUS_INVALID_PARAMETER;
    }

    if( NULL != pszHelpAssistantAccountDomain )
    {
        LocalFree( pszHelpAssistantAccountDomain );
    }

    if( NULL != pszHelpAssistantAccountName )
    {
        LocalFree(pszHelpAssistantAccountName);
    }

    if( NULL != pszHelpAssistantPassword )
    {
        LocalFree( pszHelpAssistantPassword );
    }

    return Status;
}


BOOL
TSIsSessionHelpSession(
    PWINSTATION pWinStation,
    BOOL* pValid
    )
/*++

Routine Description:

    Determine if a session is HelpAssistant session.

Parameters:

    pWinStation : Pointer to WINSTATION structure.
    pValid : Optional Pointer to BOOL to receive status of ticket, 
             TRUE of ticket is valid, FALSE if ticket is invalid or
             help is disabled.

Returns:

    TRUE/FALSE Funtion return TRUE even if ticket is invalid, caller
    should check pValid to determine if ticket is valid or not.

--*/
{
    BOOL bReturn;
    BOOL bValidHelpSession = FALSE;

    if( NULL == pWinStation )
    {
        ASSERT( NULL != pWinStation );
        SetLastError( ERROR_INVALID_PARAMETER );
        bReturn = FALSE;
        goto CLEANUPANDEXIT;
    }

    if( pWinStation->Client.ProtocolType != PROTOCOL_RDP )
    {
        //
        // HelpAssistant is RDP specific and not on console        
        DBGPRINT( ("TermSrv : HelpAssistant protocol type not RDP \n") );
        bValidHelpSession = FALSE;
        bReturn = FALSE;
    }
    else if( WSF_ST_HELPSESSION_NOTHELPSESSION & pWinStation->StateFlags )
    {
        // We are sure that this session is not HelpAssistant Session.
        bReturn = FALSE;
        bValidHelpSession = FALSE;
    }
    else if( WSF_ST_HELPSESSION_HELPSESSIONINVALID & pWinStation->StateFlags )
    {
        // Help assistant logon but password or ticket ID is invalid
        bReturn = TRUE;
        bValidHelpSession = FALSE;
    }
    else if( WSF_ST_HELPSESSION_HELPSESSION & pWinStation->StateFlags )
    {
        // We are sure this is help assistant logon
        bReturn = TRUE;
        bValidHelpSession = TRUE;
    }
    else
    {
        //
        // Clear RA state flags.
        //
        pWinStation->StateFlags &= ~WSF_ST_HELPSESSION_FLAGS;

        if( !pWinStation->Client.UserName[0] || !pWinStation->Client.Password[0] || 
            !pWinStation->Client.WorkDirectory[0] )
        {
            bReturn = FALSE;
            bValidHelpSession = FALSE;
            pWinStation->StateFlags |= WSF_ST_HELPSESSION_NOTHELPSESSION;
        }
        else
        {
            //
            // TermSrv might call this routine with data send from client,
            // client always send hardcoded SALEMHELPASSISTANTACCOUNT_NAME
            //
            if( lstrcmpi( pWinStation->Client.UserName, SALEMHELPASSISTANTACCOUNT_NAME ) )
            {
                bReturn = FALSE;
                bValidHelpSession = FALSE;
                pWinStation->StateFlags |= WSF_ST_HELPSESSION_NOTHELPSESSION;
                goto CLEANUPANDEXIT;
            }

            //
            // this is helpassistant login.
            //
            bReturn = TRUE;

            //
            // Check if machine policy restrict help or
            // in Help mode, deny access if not.
            //
            if( FALSE == TSIsMachinePolicyAllowHelp() || FALSE == TSIsMachineInHelpMode() )
            {
                bValidHelpSession = FALSE;
                pWinStation->StateFlags |= WSF_ST_HELPSESSION_HELPSESSIONINVALID;
                goto CLEANUPANDEXIT;
            }

            if( TSVerifyHelpSessionAndLogSalemEvent(pWinStation) )
            {
                bValidHelpSession = TRUE;
                pWinStation->StateFlags |= WSF_ST_HELPSESSION_HELPSESSION;
            }
            else
            {
                //
                // Either ticket is invalid or expired.
                //
                bValidHelpSession = FALSE;
                pWinStation->StateFlags |= WSF_ST_HELPSESSION_HELPSESSIONINVALID;
            }
        }
    }

CLEANUPANDEXIT:

    if( pValid )
    {
        *pValid = bValidHelpSession;
    }

    return bReturn;
}


DWORD WINAPI
SalemStartupThreadProc( LPVOID ptr )
/*++

Temporary code to start up Salem sessmgr, post B2 need to move sessmgr into svchost

--*/
{
    HRESULT hRes = S_OK;
    IRemoteDesktopHelpSessionMgr* pISessMgr = NULL;

    //
    // Startup sessmgr if there is outstanding ticket and 
    // we just rebooted from system restore.
    //

    if( !TSIsMachineInHelpMode() && !TSIsMachineInSystemRestore() && !TSIsFireWallPortsOpen( ) )
    {
        ExitThread(hRes);
        return hRes;
    }

    hRes = CoInitialize( NULL );
    if( FAILED(hRes) )
    {
        DBGPRINT( ("TermSrv : TSStartupSalem() CoInitialize() failed with 0x%08x\n", hRes) );

        // Failed in COM, return FALSE.
        goto CLEANUPANDEXIT;
    }

    hRes = CoCreateInstance(
                        CLSID_RemoteDesktopHelpSessionMgr,
                        NULL,
                        CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                        IID_IRemoteDesktopHelpSessionMgr,
                        (LPVOID *) &pISessMgr
                    );                    
    if( FAILED(hRes) || NULL == pISessMgr )
    {
        DBGPRINT( ("TermSrv : TSStartupSalem() CoCreateInstance() failed with 0x%08x\n", hRes) );

        // Can't initialize sessmgr
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    if( NULL != pISessMgr )
    {
        pISessMgr->Release();
    }

    CoUninitialize();

    ExitThread(hRes);
    return hRes;
}

void
TSStartupSalem()
{
    HANDLE hThread;

    hThread = CreateThread( NULL, 0, SalemStartupThreadProc, NULL, 0, NULL );
    if( NULL != hThread )
    {
        CloseHandle( hThread );
    }

    return;
}

BOOL
TSVerifyHelpSessionAndLogSalemEvent(
    PWINSTATION pWinStation
    )
/*++

Description:

    Verify help session is a valid, non-expired pending help session,
    log an event if help session is invalid.

Parameters:

    pWinStation : Point to WINSTATION

Returns:

    TRUE/FALSE

Note :

    WorkDirectory is HelpSessionID and InitialProgram contains
    password to pending help session

--*/
{
    HRESULT hRes;
    IRemoteDesktopHelpSessionMgr* pISessMgr = NULL;
    BOOL bSuccess = FALSE;
    BSTR bstrHelpSessId = NULL;
    BSTR bstrHelpSessPwd = NULL;
    WINSTATIONREMOTEADDRESS winstationRemoteAddress;
    DWORD dwReturnLength;
    NTSTATUS Status;

    BSTR bstrExpertIpAddressFromClient = NULL;
    BSTR bstrExpertIpAddressFromServer = NULL;

    // only have three strings in this event
    BSTR bstrEventStrings[3];


    hRes = CoInitialize( NULL );
    if( FAILED(hRes) )
    {
        DBGPRINT( ("TermSrv : TSIsHelpSessionValid() CoInitialize() failed with 0x%08x\n", hRes) );

        // Failed in COM, return FALSE.
        return FALSE;
    }

    hRes = CoCreateInstance(
                        CLSID_RemoteDesktopHelpSessionMgr,
                        NULL,
                        CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                        IID_IRemoteDesktopHelpSessionMgr,
                        (LPVOID *) &pISessMgr
                    );                    
    if( FAILED(hRes) || NULL == pISessMgr )
    {
        DBGPRINT( ("TermSrv : TSIsHelpSessionValid() CoCreateInstance() failed with 0x%08x\n", hRes) );

        // Can't initialize sessmgr
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the security level to impersonate.  This is required by
    //  the session manager.
    //
    hRes = CoSetProxyBlanket(
                    (IUnknown *)pISessMgr,
                    RPC_C_AUTHN_DEFAULT,
                    RPC_C_AUTHZ_DEFAULT,
                    NULL,
                    RPC_C_AUTHN_LEVEL_DEFAULT,
                    RPC_C_IMP_LEVEL_IDENTIFY,
                    NULL,
                    EOAC_NONE
                );

    if( FAILED(hRes) )
    {
        DBGPRINT( ("TermSrv : TSIsHelpSessionValid() CoSetProxyBlanket() failed with 0x%08x\n", hRes) );

        // can't impersonate, return FALSE
        goto CLEANUPANDEXIT;
    }

    bstrHelpSessId = ::SysAllocString(pWinStation->Client.WorkDirectory);
    bstrHelpSessPwd = ::SysAllocString(pWinStation->Client.InitialProgram);

    if( NULL == bstrHelpSessId || NULL == bstrHelpSessPwd )
    {
        // We are so out of memory, treat as error
        goto CLEANUPANDEXIT;
    }

    // Verify help session
    hRes = pISessMgr->IsValidHelpSession(
                                    bstrHelpSessId,
                                    bstrHelpSessPwd
                                );

    bSuccess = SUCCEEDED(hRes);

    if( FALSE == bSuccess )
    {
        // Log invalid help ticket event here.
        Status = xxxQueryRemoteAddress( pWinStation, &winstationRemoteAddress );
        bstrExpertIpAddressFromClient = ::SysAllocString( pWinStation->Client.ClientAddress );

        if( !NT_SUCCESS(Status) || AF_INET != winstationRemoteAddress.sin_family )
        {
            //
            // we don't support other than IPV4 now or we failed to retrieve address
            // from driver, use what's send in from client.
            bstrExpertIpAddressFromServer = ::SysAllocString( pWinStation->Client.ClientAddress );
        }
        else
        {
            // refer to in_addr structure.
            struct in_addr S;
            S.S_un.S_addr = winstationRemoteAddress.ipv4.in_addr;

            bstrExpertIpAddressFromServer = A2WBSTR( inet_ntoa(S) );
        }

        if( !bstrExpertIpAddressFromClient || !bstrExpertIpAddressFromServer )
        {
            // we are out of memory, can't log event.
            goto CLEANUPANDEXIT;
        }

        bstrEventStrings[0] = bstrExpertIpAddressFromClient;
        bstrEventStrings[1] = bstrExpertIpAddressFromServer;
        bstrEventStrings[2] = bstrHelpSessId;

        __LogSalemEvent( 
                    pISessMgr, 
                    EVENTLOG_INFORMATION_TYPE,
                    REMOTEASSISTANCE_EVENTLOG_TERMSRV_INVALID_TICKET,
                    3,
                    bstrEventStrings
                );
    }

CLEANUPANDEXIT:

    if( NULL != pISessMgr )
    {
        pISessMgr->Release();
    }

    if( NULL != bstrHelpSessId )
    {
        SecureZeroMemory( bstrHelpSessId , SysStringByteLen( bstrHelpSessId ) );

        ::SysFreeString( bstrHelpSessId );
    }

    if( NULL != bstrHelpSessPwd )
    {
        SecureZeroMemory( bstrHelpSessPwd , SysStringByteLen( bstrHelpSessPwd ) );

        ::SysFreeString( bstrHelpSessPwd );
    }

    if( NULL != bstrExpertIpAddressFromClient )
    {
        ::SysFreeString( bstrExpertIpAddressFromClient );
    }

    if( NULL != bstrExpertIpAddressFromServer )
    {
        ::SysFreeString( bstrExpertIpAddressFromServer );
    }

    DBGPRINT( ("TermSrv : TSIsHelpSessionValid() returns 0x%08x\n", hRes) );
    CoUninitialize();
    return bSuccess;
}


VOID
TSLogSalemReverseConnection(
    PWINSTATION pWinStation,
    PICA_STACK_ADDRESS pStackAddress
    )
/*++

--*/
{
    HRESULT hRes;
    IRemoteDesktopHelpSessionMgr* pISessMgr = NULL;
    BOOL bSuccess = FALSE;

    int index;

    // Fours string for this event
    BSTR bstrEventStrings[3];

    ZeroMemory( bstrEventStrings, sizeof(bstrEventStrings) );

    hRes = CoInitialize( NULL );
    if( FAILED(hRes) )
    {
        DBGPRINT( ("TermSrv : TSLogSalemReverseConnection() CoInitialize() failed with 0x%08x\n", hRes) );

        goto CLEANUPANDEXIT;
    }

    hRes = CoCreateInstance(
                        CLSID_RemoteDesktopHelpSessionMgr,
                        NULL,
                        CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                        IID_IRemoteDesktopHelpSessionMgr,
                        (LPVOID *) &pISessMgr
                    );                    
    if( FAILED(hRes) || NULL == pISessMgr )
    {
        DBGPRINT( ("TermSrv : TSLogSalemReverseConnection() CoCreateInstance() failed with 0x%08x\n", hRes) );

        // Can't initialize sessmgr
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the security level to impersonate.  This is required by
    //  the session manager.
    //
    hRes = CoSetProxyBlanket(
                    (IUnknown *)pISessMgr,
                    RPC_C_AUTHN_DEFAULT,
                    RPC_C_AUTHZ_DEFAULT,
                    NULL,
                    RPC_C_AUTHN_LEVEL_DEFAULT,
                    RPC_C_IMP_LEVEL_IDENTIFY,
                    NULL,
                    EOAC_NONE
                );

    if( FAILED(hRes) )
    {
        DBGPRINT( ("TermSrv : TSLogSalemReverseConnection() CoSetProxyBlanket() failed with 0x%08x\n", hRes) );

        // can't impersonate, return FALSE
        goto CLEANUPANDEXIT;
    }

    //
    // sessmgr expect event string in following order
    //
    //  IP address send from client.
    //  IP address that termsrv connect to, this is part of the expert connect parm.
    //  Help Session Ticket ID
    //  

    bstrEventStrings[0] = ::SysAllocString( pWinStation->Client.ClientAddress );

    {
        struct in_addr S;
        PTDI_ADDRESS_IP pIpAddress = (PTDI_ADDRESS_IP)&((PCHAR)pStackAddress)[2];

        // refer to in_addr structure.
        S.S_un.S_addr = pIpAddress->in_addr;
        bstrEventStrings[1] = A2WBSTR( inet_ntoa(S) );
    }

    bstrEventStrings[2] = ::SysAllocString(pWinStation->Client.WorkDirectory);

    if( NULL != bstrEventStrings[0] &&
        NULL != bstrEventStrings[1] &&
        NULL != bstrEventStrings[2] ) 
    {
        hRes = __LogSalemEvent(
                            pISessMgr,
                            EVENTLOG_INFORMATION_TYPE,
                            REMOTEASSISTANCE_EVENTLOG_TERMSRV_REVERSE_CONNECT,
                            3,
                            bstrEventStrings
                        );
    }
    

CLEANUPANDEXIT:

    if( NULL != pISessMgr )
    {
        pISessMgr->Release();
    }

    for(index=0; index < sizeof(bstrEventStrings)/sizeof(bstrEventStrings[0]); index++)
    {
        if( !bstrEventStrings[index] )
        {
            ::SysFreeString( bstrEventStrings[index] );
        }
    }

    DBGPRINT( ("TermSrv : TSLogSalemReverseConnection() returns 0x%08x\n", hRes) );
    CoUninitialize();
    return;
}

HRESULT
__LogSalemEvent(
    IN IRemoteDesktopHelpSessionMgr* pISessMgr,
    IN ULONG eventType,
    IN ULONG eventCode,
    IN int numStrings,
    IN BSTR bstrEventStrings[]
    )
/*++

Description:

    Create a safearray and pass parameters to sessmgr.

Parameters:


Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;
    VARIANT EventStrings;
    int index;

    // we only have three string to be included in the event log.
    SAFEARRAY* psa = NULL;
    SAFEARRAYBOUND bounds;
    BSTR* bstrArray = NULL;

    bounds.cElements = numStrings;
    bounds.lLbound = 0;

    VariantInit(&EventStrings);

    //
    // Create a safearray to pass all event string
    // 
    psa = SafeArrayCreate(VT_BSTR, 1, &bounds);
    if( NULL == psa )
    {
        goto CLEANUPANDEXIT;
    }

    // Required, lock the safe array
    hRes = SafeArrayAccessData(psa, (void **)&bstrArray);

    if( SUCCEEDED(hRes) )
    {
        for(index=0; index < numStrings; index++)
        {
            bstrArray[index] = bstrEventStrings[index];
        }

        EventStrings.vt = VT_ARRAY | VT_BSTR;
        EventStrings.parray = psa;
        hRes = pISessMgr->LogSalemEvent(
                                eventType,
                                eventCode,
                                &EventStrings
                            );

        //
        // make sure we clear BSTR array or VariantClear() will invoke
        // SafeArrayDestroy() which in term will invoke ::SysFreeString()
        // on each BSTR.
        //        
        for(index=0; index < numStrings; index++)
        {
            bstrArray[index] = NULL;
        }

        hRes = SafeArrayUnaccessData( psa );
        ASSERT( SUCCEEDED(hRes) );


        // make sure we don't destroy safe array twice, VariantClear()
        // will destroy it.
        psa = NULL;
    }
               

CLEANUPANDEXIT:

    hRes = VariantClear(&EventStrings);
    ASSERT( SUCCEEDED(hRes) );

    if( psa != NULL )
    {
        SafeArrayDestroy(psa);
    }

    return hRes;
}

HRESULT
TSRemoteAssistancePrepareSystemRestore()
/*++

Routine Description:

    Prepare system for RA specific system restore, this includes RA specific encryption key, 
    registry settings that we need preserve.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes;
    IRemoteDesktopHelpSessionMgr* pISessMgr = NULL;

    hRes = CoInitialize( NULL );
    if( FAILED(hRes) )
    {
        DBGPRINT( ("TermSrv : TSRemoteAssistancePrepareSystemRestore() CoInitialize() failed with 0x%08x\n", hRes) );
        goto CLEANUPANDEXIT;
    }

    hRes = CoCreateInstance(
                        CLSID_RemoteDesktopHelpSessionMgr,
                        NULL,
                        CLSCTX_LOCAL_SERVER | CLSCTX_DISABLE_AAA,
                        IID_IRemoteDesktopHelpSessionMgr,
                        (LPVOID *) &pISessMgr
                    );                    
    if( FAILED(hRes) || NULL == pISessMgr )
    {
        DBGPRINT( ("TermSrv : TSRemoteAssistancePrepareSystemRestore() CoCreateInstance() failed with 0x%08x\n", hRes) );

        // Can't initialize sessmgr
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the security level to impersonate.  This is required by
    //  the session manager.
    //
    hRes = CoSetProxyBlanket(
                    (IUnknown *)pISessMgr,
                    RPC_C_AUTHN_DEFAULT,
                    RPC_C_AUTHZ_DEFAULT,
                    NULL,
                    RPC_C_AUTHN_LEVEL_DEFAULT,
                    RPC_C_IMP_LEVEL_IDENTIFY,
                    NULL,
                    EOAC_NONE
                );

    if( FAILED(hRes) )
    {
        DBGPRINT( ("TermSrv : TSRemoteAssistancePrepareSystemRestore() CoSetProxyBlanket() failed with 0x%08x\n", hRes) );

        // can't impersonate, return FALSE
        goto CLEANUPANDEXIT;
    }

    hRes = pISessMgr->PrepareSystemRestore();

CLEANUPANDEXIT:

    if( NULL != pISessMgr )
    {
        pISessMgr->Release();
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\lcrpc-s.c ===
#include <lcrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\icarpc.c ===
/*************************************************************************
*
* icarpc.c
*
* Server specific routines for handling of RPC wire structures.
*
* Copyright Microsoft Corporation, 1998
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <winsta.h>

#include "rpcwire.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*****************************************************************************
 *
 *  ValidWireBuffer
 *
 *   Tests whether the buffer is a valid Winsta API Wire Buffer
 *
 * ENTRY:
 *    InfoClass (input)
 *       WinStationQuery/Set Information class.
 *    WireBuf (input)
 *       Data buffer
 *    WireBufLen
 *      Length of the wire buffer
 *
 * EXIT:
 *    Returns true if the buffer is a valid wire format buffer, FALSE otherwise.
 *
 ****************************************************************************/
BOOLEAN
ValidWireBuffer(WINSTATIONINFOCLASS InfoClass,
                PVOID WireBuf,
                ULONG WireBufLen)
{
    PVARDATA_WIRE GenericWire;
    PPDCONFIGWIREW PdConfigWire;
    PPDPARAMSWIREW PdParamsWire;
    PWINSTACONFIGWIREW WinStaConfigWire;

    switch(InfoClass) {
    case WinStationInformation:
    case WinStationWd:
    case WinStationClient:
        GenericWire = (PVARDATA_WIRE)WireBuf;
        if ((WireBufLen < sizeof(VARDATA_WIRE)) ||
            (GenericWire->Offset != sizeof(VARDATA_WIRE)) ||
            (WireBufLen < sizeof(VARDATA_WIRE) + GenericWire->Size)) {
            DBGPRINT(("ICASRV Bad Wire Buffer Type: %d\n",InfoClass));
            return(FALSE);
        }
        break;

    case WinStationPd:
        PdConfigWire = (PPDCONFIGWIREW)WireBuf;
        if ((WireBufLen < sizeof(PDCONFIGWIREW)) ||
            (PdConfigWire->PdConfig2W.Offset != sizeof(PDCONFIGWIREW)) ||
            (WireBufLen < sizeof(PDCONFIGWIREW) +
                          PdConfigWire->PdConfig2W.Size +
                          PdConfigWire->PdParams.SdClassSpecific.Size) ||
            (NextOffset(&PdConfigWire->PdConfig2W) !=
             PdConfigWire->PdParams.SdClassSpecific.Offset)) {
            DBGPRINT(("ICASRV Bad Wire Buffer Type: %d\n",InfoClass));
            return(FALSE);
        }
        break;

    case WinStationPdParams:
        PdParamsWire = (PPDPARAMSWIREW)WireBuf;
        if ((WireBufLen < sizeof(PDPARAMSWIREW)) ||
            (PdParamsWire->SdClassSpecific.Offset != sizeof(PDPARAMSWIREW)) ||
            (WireBufLen < sizeof(PDPARAMSWIREW) +
                          PdParamsWire->SdClassSpecific.Size)) {
            DBGPRINT(("ICASRV Bad Wire Buffer Type: %d\n",InfoClass));
            return(FALSE);
        }
        break;

    case WinStationConfiguration:
        WinStaConfigWire = (PWINSTACONFIGWIREW)WireBuf;
        if ((WireBufLen < sizeof(WINSTACONFIGWIREW)) ||
            WinStaConfigWire->UserConfig.Offset != sizeof(WINSTACONFIGWIREW) ||
            (WireBufLen < sizeof(WINSTACONFIGWIREW) +
                          WinStaConfigWire->UserConfig.Size +
                          WinStaConfigWire->NewFields.Size) ||
            (NextOffset(&WinStaConfigWire->UserConfig) !=
             WinStaConfigWire->NewFields.Offset) ||
            (WireBufLen < NextOffset(&WinStaConfigWire->UserConfig)) ||
            (WireBufLen < NextOffset(&WinStaConfigWire->NewFields))) {
            DBGPRINT(("ICASRV Bad Wire Buffer Type: %d\n",InfoClass));
            return(FALSE);
        }
        break;

    default:
        return(FALSE);
    }
    return(TRUE);
}

/*****************************************************************************
 *
 *  CheckWireBuffer
 *
 *   Tests whether the buffer is a Winsta API Wire Buffer. If it is a valid
 *   wire buffer, a local buffer is allocated and initialized from the data
 *   in the wire buffer.
 *
 * ENTRY:
 *    InfoClass (input)
 *       WinStationQuery/Set Information class.
 *    WireBuf (input)
 *       Data buffer
 *    WireBufLen
 *      Length of the wire buffer
 *    ppLocalBuf (output)
 *      Local format buffer allocated for conversion from wire format to
 *      native format.
 *    pLocalBufLen
 *      Length of the native buffer allocated.
  *
 * EXIT:
 *    STATUS_SUCCESS if successful. If successful, a native local buffer
 *    is allocated based on InfoClass and the wire buffer data is copied
 *    into it.
 *
 ****************************************************************************/
NTSTATUS
CheckWireBuffer(WINSTATIONINFOCLASS InfoClass,
                PVOID WireBuf,
                ULONG WireBufLen,
                PVOID *ppLocalBuf,
                PULONG pLocalBufLen)
{
    ULONG BufSize;
    PPDCONFIGWIREW PdConfigWire;
    PPDCONFIGW PdConfig;
    PPDPARAMSWIREW PdParamsWire;
    PPDPARAMSW PdParam;
    PWINSTACONFIGWIREW WinStaConfigWire;
    PWINSTATIONCONFIGW WinStaConfig;
    PVOID LocalBuf;

    switch (InfoClass) {
    case WinStationPd:
        BufSize = sizeof(PDCONFIGW);
        break;

    case WinStationPdParams:
        BufSize = sizeof(PDPARAMSW);
        break;

    case WinStationConfiguration:
        BufSize = sizeof(WINSTATIONCONFIGW);
        break;

    case WinStationInformation:
        BufSize = sizeof(WINSTATIONINFORMATIONW);
        break;

    case WinStationWd:
        BufSize = sizeof(WDCONFIGW);
        break;

    case WinStationClient:
        BufSize = sizeof(WINSTATIONCLIENTW);
        break;

    default:
        *ppLocalBuf = NULL;
        return(STATUS_INVALID_USER_BUFFER);

    }
    if (!ValidWireBuffer(InfoClass, WireBuf, WireBufLen)) {
        return(STATUS_INVALID_USER_BUFFER);
    }

    if ((LocalBuf = (PCHAR)LocalAlloc(0,BufSize)) == NULL)
        return(STATUS_NO_MEMORY);


    *pLocalBufLen = BufSize;
    *ppLocalBuf = LocalBuf;
    CopyOutWireBuf(InfoClass, LocalBuf, WireBuf);

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\precomp.h ===
/****************************************************************************/
// precomp.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntcsrsrv.h>
#include <windows.h>
#include <lmcons.h>
#include <lmserver.h>
#include <ntsm.h>
#include <stdio.h>
#include <string.h>
#include <winerror.h>
#include <ntverp.h>
#include <ntddbeep.h>
#include <regstr.h>
#include <ntlsapi.h>

#include <winstaw.h>

#include <ntexapi.h>

#include <regapi.h>

#include <wstmsg.h>

#include <icadd.h>
#include <icaapi.h>

#include <syslib.h>
#include <ntddvdeo.h>

#include <license.h>
#include <tsutilnt.h>
#include <tsutil.h>

#include "..\inc\wsxmgr.h"
#include "icasrv.h"
#include "lscore.h"
#include "helpasst.h"
#include "tserrs.h"

#define INVALID_SESSIONID       0xffffffff
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\misc.c ===
/****************************************************************************/
// misc.c
//
// TermSrv general code.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <rpc.h>
#include <msaudite.h>
#include <ntlsa.h>
#include <authz.h>
#include <authzi.h>
//external procedures used
extern NTSTATUS
AuthzReportEventW( IN PAUTHZ_AUDIT_EVENT_TYPE_HANDLE pHAET, 
                   IN DWORD Flags, 
                   IN ULONG EventId, 
                   IN PSID pUserID, 
                   IN USHORT NumStrings,
                   IN ULONG DataSize OPTIONAL, //Future - DO NOT USE
                   IN PUNICODE_STRING* Strings,
                   IN PVOID  Data OPTIONAL         //Future - DO NOT USE
                   );


extern BOOL 
AuthzInit( IN DWORD Flags,
           IN USHORT CategoryID,
           IN USHORT AuditID,
           IN USHORT ParameterCount,
           OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
           );




NTSTATUS ConfigureEnable(
        IN PWSTR ValueName,
        IN ULONG ValueType,
        IN PVOID ValueData,
        IN ULONG ValueLength,
        IN PVOID Context,
        IN PVOID EntryContext)
{
    if (ValueType == REG_DWORD && *(PULONG)ValueData != 0)
        return STATUS_SUCCESS;
    return STATUS_UNSUCCESSFUL;
}


RTL_QUERY_REGISTRY_TABLE WinStationEnableTable[] = {
    { ConfigureEnable, RTL_QUERY_REGISTRY_REQUIRED, WIN_ENABLEWINSTATION,
        NULL, REG_NONE, NULL, 0},
    { NULL, 0, NULL, NULL, REG_NONE, NULL, 0}
};


NTSTATUS CheckWinStationEnable(LPWSTR WinStationName)
{
    NTSTATUS Status;

    PWCHAR PathBuf = MemAlloc((wcslen(REG_TSERVER_WINSTATIONS L"\\") + wcslen(WinStationName) + 1) * sizeof(WCHAR));
    if (!PathBuf)
    {
        return STATUS_NO_MEMORY;
    }

    wcscpy(PathBuf, REG_TSERVER_WINSTATIONS L"\\");
    wcscat(PathBuf, WinStationName);

    /*
     * Check if WinStation is enabled, and return error if not.
     */
    Status = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL, PathBuf,
            WinStationEnableTable, NULL, NULL);

    MemFree(PathBuf);
    return Status;
}


void InitializeSystemTrace(HKEY hKeyTermSrv)
{
    ICA_TRACE Trace;
    NTSTATUS Status;
    WCHAR SystemDir[256];
    DWORD ValueType;
    DWORD ValueSize;
    ULONG fDebugger;
    UINT uiWinDirSize;

    ASSERT(hKeyTermSrv != NULL);


    RtlZeroMemory( &Trace , sizeof( ICA_TRACE ) );
    /*
     *  Query trace enable flag
     */
    ValueSize = sizeof(Trace.TraceEnable);
    Status = RegQueryValueEx(hKeyTermSrv, WIN_TRACEENABLE, NULL, &ValueType,
            (LPBYTE) &Trace.TraceEnable, &ValueSize);
    if (Status == ERROR_SUCCESS && Trace.TraceEnable != 0) {
        /*
         *  Query trace class flag
         */
        ValueSize = sizeof(Trace.TraceClass);
        Status = RegQueryValueEx(hKeyTermSrv, WIN_TRACECLASS, NULL,
                &ValueType, (LPBYTE)&Trace.TraceClass, &ValueSize);
        if (Status != ERROR_SUCCESS) {
            Trace.TraceClass = 0xffffffff;
        }

        /*
         *  Query trace to debugger flag
         */
        ValueSize = sizeof(fDebugger);
        Status = RegQueryValueEx(hKeyTermSrv, WIN_TRACEDEBUGGER, NULL, 
                &ValueType, (LPBYTE)&fDebugger, &ValueSize);
        if (Status != ERROR_SUCCESS) {
            fDebugger = FALSE; 
        }

        Trace.fDebugger  = (BOOLEAN)fDebugger;
        Trace.fTimestamp = TRUE;

        uiWinDirSize = GetWindowsDirectory(SystemDir, sizeof(SystemDir)/sizeof(WCHAR));
        if ((uiWinDirSize == 0) || 
            ((uiWinDirSize + wcslen(L"\\ICADD.log") + 1) > sizeof(Trace.TraceFile)/sizeof(WCHAR)))
        {
            // we failed to get the windows directory or we dont have enough buffer for the logfile.
            Trace.TraceEnable = 0;
            
        }
        else
        {

            wsprintf(Trace.TraceFile, L"%s\\ICADD.log", SystemDir);

            /*
             *  Open TermDD.
             */
            Status = IcaOpen(&hTrace);
            if (NT_SUCCESS(Status)) {
                Status = IcaIoControl(hTrace, IOCTL_ICA_SET_SYSTEM_TRACE, &Trace,
                        sizeof(Trace), NULL, 0, NULL);
                if (!NT_SUCCESS(Status)) {
                    IcaClose(hTrace);
                    hTrace = NULL;
                }
            }

            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_TRACE_LEVEL, "TRACE: %S, c:%x, e:%x d:%d, Status=0x%x\n", Trace.TraceFile,
                      Trace.TraceClass, Trace.TraceEnable, Trace.fDebugger, Status ));
        }
    }
}


void InitializeTrace(
        PWINSTATION pWinStation,
        BOOLEAN fListen,
        PICA_TRACE pTrace)
{
    PWINSTATIONNAME pWinStationName;
    NTSTATUS Status;
    WCHAR SystemDir[256];
    ULONG fDebugger;
    ULONG ulSize;

    /*
     * Use WinStation name if set, else try ListenName,
     * otherwise nothing to be done.
     */
    if (pWinStation->WinStationName[0])
        pWinStationName = pWinStation->WinStationName;
    else if (pWinStation->ListenName[0])
        pWinStationName = pWinStation->ListenName;
    else
        return;

    /*
     *  Check if trace should be enabled for this WinStation
     */
    Status = RegWinStationQueryNumValue(SERVERNAME_CURRENT, pWinStationName,
            WIN_TRACEENABLE, &pTrace->TraceEnable);

    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_TRACE_LEVEL, "TERMSRV: InitializeTrace: LogonId %d, fListen %u, Status=0x%x\n",
              pWinStation->LogonId, fListen, Status ));

    if (Status == ERROR_SUCCESS && pTrace->TraceEnable != 0) {
        /*
         *  Enable trace for this WinStation
         */
        if (RegWinStationQueryNumValue(SERVERNAME_CURRENT, pWinStationName,
                WIN_TRACECLASS, &pTrace->TraceClass))
            pTrace->TraceClass = 0xffffffff;

        if (RegWinStationQueryNumValue(SERVERNAME_CURRENT, pWinStationName,
                WIN_TRACEDEBUGGER, &fDebugger))
            fDebugger = FALSE; 

        pTrace->fDebugger  = (BOOLEAN)fDebugger;
        pTrace->fTimestamp = TRUE;

        if (RegWinStationQueryValue(SERVERNAME_CURRENT, pWinStationName,
                WIN_TRACEOPTION, pTrace->TraceOption,
                sizeof(pTrace->TraceOption), &ulSize))
            memset(pTrace->TraceOption, 0, sizeof(pTrace->TraceOption));

        if (GetWindowsDirectory(SystemDir, sizeof(SystemDir)/sizeof(WCHAR)) == 0) {
            return;
        }

        if (fListen)
            wsprintf(pTrace->TraceFile, L"%s\\%s.log", SystemDir,
                    pWinStationName);
        else
            wsprintf(pTrace->TraceFile, L"%s\\%u.log", SystemDir,
                    pWinStation->LogonId);

        Status = IcaIoControl(pWinStation->hIca, IOCTL_ICA_SET_TRACE, pTrace,
                sizeof(ICA_TRACE), NULL, 0, NULL);

        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_TRACE_LEVEL, "TRACE: %S, c:%x, e:%x d:%d, Status=0x%x\n", pTrace->TraceFile,
                  pTrace->TraceClass, pTrace->TraceEnable, pTrace->fDebugger, Status ));
    }
}


/*
 * Retrieves non-trace systemwide registry entries and conveys them to TermDD.
 * Single location for configuration params.
 */
void GetSetSystemParameters(HKEY hKeyTermSrv)
{
    TERMSRV_SYSTEM_PARAMS SysParams;
    NTSTATUS Status;
    DWORD ValueType;
    DWORD ValueSize;
    HANDLE hTermDD;

    ASSERT(hKeyTermSrv != NULL);

    // Read the mouse throttle size.
    ValueSize = sizeof(SysParams.MouseThrottleSize);
    if (RegQueryValueEx(hKeyTermSrv, REG_MOUSE_THROTTLE_SIZE, NULL,
            &ValueType, (PCHAR)&SysParams.MouseThrottleSize, &ValueSize) ==
            ERROR_SUCCESS) {
        // Round the retrieved value up to the next multiple of the
        // input size.
        SysParams.MouseThrottleSize = (SysParams.MouseThrottleSize +
                sizeof(MOUSE_INPUT_DATA) - 1) &
                ~(sizeof(MOUSE_INPUT_DATA) - 1);
    }
    else {
        // Set default value.
        SysParams.MouseThrottleSize = DEFAULT_MOUSE_THROTTLE_SIZE;
    }

    // Read the keyboard throttle size.
    ValueSize = sizeof(SysParams.KeyboardThrottleSize);
    if (RegQueryValueEx(hKeyTermSrv, REG_KEYBOARD_THROTTLE_SIZE, NULL,
            &ValueType, (PCHAR)&SysParams.KeyboardThrottleSize, &ValueSize) ==
            ERROR_SUCCESS) {
        // Round the retrieved value up to the next multiple of the
        // input size.
        SysParams.KeyboardThrottleSize = (SysParams.KeyboardThrottleSize +
                sizeof(KEYBOARD_INPUT_DATA) - 1) &
                ~(sizeof(KEYBOARD_INPUT_DATA) - 1);
    }
    else {
        // Set default value.
        SysParams.KeyboardThrottleSize = DEFAULT_KEYBOARD_THROTTLE_SIZE;
    }

    // Open TermDD and send IOCTL.
    Status = IcaOpen(&hTermDD);
    if (NT_SUCCESS(Status)) {
        Status = IcaIoControl(hTermDD, IOCTL_ICA_SET_SYSTEM_PARAMETERS,
                &SysParams, sizeof(SysParams), NULL, 0, NULL);
        IcaClose(hTermDD);
    }

    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_TRACE_LEVEL, "SysParams: MouseThrottle=%u, KbdThrottle=%u, Status=0x%x\n",
             SysParams.MouseThrottleSize, SysParams.KeyboardThrottleSize,
             Status));
}


VOID AuditShutdownEvent(void)
{
    RPC_STATUS  RPCStatus;
    NTSTATUS    NtStatus;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET = NULL;

    RPCStatus = RpcImpersonateClient(NULL);
    
    if (RPCStatus != RPC_S_OK)
    {
        DBGPRINT(("TERMSRV: AuditShutdownEvent: Not impersonating! RpcStatus 0x%x\n",RPCStatus));
        return;
    }

    //
    //authz Changes
    //
    if( !AuthzInit( 0, SE_CATEGID_SYSTEM, SE_AUDITID_SYSTEM_SHUTDOWN, 0, &hAET ))
            goto ExitFunc;
     
     NtStatus = AuthzReportEventW( &hAET, 
                                   APF_AuditSuccess, 
                                   0, 
                                   NULL, 
                                   0,
                                   0,
                                   NULL,
                                   NULL
                                   );
            

     //end authz changes

     if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: Failed to report shutdown event.\n"));
    }

ExitFunc:
    if( hAET != NULL )
        AuthziFreeAuditEventType( hAET  );
    if (RPCStatus == RPC_S_OK)
        RpcRevertToSelf();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\icasrv.h ===
/****************************************************************************/
// icasrv.h
//
// TermSrv types, data, prototypes.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <tssd.h>
#include <tssec.h>


#ifdef __cplusplus
extern "C" {
#endif

#define STR_CITRIX_IDLE_TITLE   249
#define STR_CITRIX_IDLE_MSG_LOGOFF 250
#define STR_CITRIX_LOGON_TITLE  251
#define STR_CITRIX_LOGON_MSG_LOGOFF 252
#define STR_CITRIX_SHADOW_TITLE 253
#define STR_CITRIX_SHADOW_MSG_1 254
#define STR_CITRIX_SHADOW_MSG_2 255
#define STR_TEMP_LICENSE_EXPIRED_MSG        257
#define STR_TEMP_LICENSE_EXPIRATION_MSG     258
#define STR_TEMP_LICENSE_MSG_TITLE          259
#define STR_ALL_LAN_ADAPTERS                260
#define STR_CANNOT_ALLOW_CONCURRENT_MSG     261
#define STR_CITRIX_IDLE_MSG_DISCON 262
#define STR_CITRIX_LOGON_MSG_DISCON 263
#define STR_FUS_REMOTE_DISCONNECT_TITLE     264
#define STR_FUS_REMOTE_DISCONNECT_MSG       265

/*
 *  Resource definitions for the Licensing Core.
 */

#define IDS_LSCORE_RA_NAME 1100
#define IDS_LSCORE_RA_DESC 1101
#define IDS_LSCORE_PERSEAT_NAME 1200
#define IDS_LSCORE_PERSEAT_DESC 1201
#define IDS_LSCORE_CONCURRENT_NAME 1300
#define IDS_LSCORE_CONCURRENT_DESC 1301
#define IDS_LSCORE_PERUSER_NAME 1302
#define IDS_LSCORE_PERUSER_DESC 1303

/*
 * defines for memory allocation
 */
#define MemAlloc( _x )  RtlAllocateHeap( IcaHeap, 0, _x )
#define MemFree( _p )   RtlFreeHeap( IcaHeap, 0, _p )

/*
 * Prototype for reference lock delete procedure
 */
typedef VOID (*PREFLOCKDELETEPROCEDURE)( struct _REFLOCK * );

typedef struct _WINSTATION *PWINSTATION;


/*
 * Reference counted lock structure
 */
typedef struct _REFLOCK {
    HANDLE Mutex;                       // mutex handle
    LONG RefCount;                      // reference count
    BOOLEAN Invalid;                    // containing struct no longer valid
    PREFLOCKDELETEPROCEDURE pDeleteProcedure; // pointer to delete procedure
} REFLOCK, *PREFLOCK;

/*
 * Structure used to get the exact credentials used for logon by the client
 * We use this to send back the notification to the client
 */
typedef struct _CLIENTNOTIFICATIONCREDENTIALS {
    WCHAR UserName[EXTENDED_USERNAME_LEN + 1];
    WCHAR Domain[EXTENDED_DOMAIN_LEN + 1] ; 
} CLIENTNOTIFICATIONCREDENTIALS, *PCLIENTNOTIFICATIONCREDENTIALS; 

//
// Private contents of the autoreconnect cookie
//

typedef struct _AUTORECONNECTIONINFO {
    BOOLEAN Valid;    
    BYTE  ArcRandomBits[ARC_SC_SECURITY_TOKEN_LEN];
} AUTORECONNECTIONINFO, *PAUTORECONNECTIONINFO; 


/*
 * Remembered Client address structure
 */


typedef struct _REMEMBERED_CLIENT_ADDRESS{
    ULONG length;
    BYTE  addr[1];
} REMEMBERED_CLIENT_ADDRESS, *PREMEMBERED_CLIENT_ADDRESS;

typedef enum _RECONNECT_TYPE {
    NeverReconnected = 0,
    ManualReconnect,
    AutoReconnect
} RECONNECT_TYPE, *PRECONNECT_TYPE; 
    
/*
 * Session Manager WinStation struct
 */
typedef struct _WINSTATION {
    LIST_ENTRY Links;
    BOOLEAN Starting;                   // WinStation is starting
    BOOLEAN Terminating;                // WinStation is terminating
    BOOLEAN NeverConnected;             // WinStation not connected yet
    REFLOCK Lock;
    ULONG LogonId;                      // Logon Id
    WINSTATIONNAME WinStationName;      // WinStation Name
    WINSTATIONNAME ListenName;          // Listen Name (for limits checking)
    WINSTATIONCONFIG2 Config;           // WinStation Config
    WINSTATIONCLIENT Client;            // WinStation client data

    ULONG State;                        // current state
    ULONG Flags;                        // WinStation Flags (see WSF_??? below)
    PVOID pSecurityDescriptor;
    HANDLE CreateEvent;
    NTSTATUS CreateStatus;
    HANDLE ConnectEvent;

    HANDLE hIca;                        // WinStation's primary Device
    HANDLE hStack;                      // WinStation's primary stack

    ULONG ShadowId;
    HANDLE hPassthruStack;              // passthru (shadow client) stack
    HANDLE ShadowBrokenEvent;
    HANDLE ShadowDoneEvent;
    HANDLE ShadowDisplayChangeEvent;
    NTSTATUS ShadowTargetStatus;
    BOOLEAN ShadowConnectionWait;

    LIST_ENTRY ShadowHead;              // head of shadow list

    HANDLE WindowsSubSysProcess;        // process handle for Win32 SS (csrss)
    HANDLE WindowsSubSysProcessId;      // process id for Win32 SS
    HANDLE InitialCommandProcess;       // process handle for initial command
    HANDLE InitialCommandProcessId;     // process id for initial command
    BOOLEAN InitialProcessSet;          // Flag for console communication

    HANDLE CsrStartEventHandle;         // Handle for CsrStartEvent

    HANDLE Win32CommandPort;
    PORT_MESSAGE Win32CommandPortMsg;
    LIST_ENTRY Win32CommandHead;        // head of COMMAND_ENTRY list
    struct _LPC_CLIENT_CONTEXT *pWin32Context;

    PSID pUserSid;                      // SID for currently logged on user
    WCHAR Password[PASSWORD_LENGTH+1];  // password for currently logged on user
    UCHAR Seed;                         // seed for above password

    HANDLE UserToken;                   // User Token

    HANDLE hIdleTimer;
    HANDLE hLogonTimer;
    HANDLE hDisconnectTimer;

    ULONG fIdleTimer : 1;
    ULONG fLogonTimer : 1;
    ULONG fDisconnectTimer : 1;

    LARGE_INTEGER ConnectTime;
    LARGE_INTEGER DisconnectTime;
    LARGE_INTEGER LogonTime;
    WCHAR Domain[ DOMAIN_LENGTH + 1 ];   // Domain
    WCHAR UserName[USERNAME_LENGTH + 1]; // UserName

    BYTE VideoModuleName[9];            // For reconnect checking

    HANDLE hConnectThread;              // Connect thread for this WinStation

    HANDLE hIcaBeepChannel;
    HANDLE hIcaThinwireChannel;

    PVOID pEndpoint;
    ULONG EndpointLength;

    struct _WSEXTENSION *pWsx;
    PVOID  pWsxContext;

    BROKENCLASS BrokenReason;           // reason/source why this WinStation..
    BROKENSOURCECLASS BrokenSource;     // ..is being reset/disconnected

    ULONG StateFlags;                   // WinStation State (see WSF_ST_??? below)
    ULONG SessionSerialNumber;          // Session Id is reused when session is deleted. Serial number not

    PSID pProfileSid;                   // SID for previously logged on user kept for profile cleanup
    BOOLEAN fOwnsConsoleTerminal;       // session currently connected to the console

    WCHAR DisplayDriverName[9];
    WCHAR ProtocolName[9];

    LPARAM lpLicenseContext;                        // Licensing context for the winstation
    BOOLEAN fUserIsAdmin;               // Needed for LLS licensing

    // Server pool (cluster) support - disconnected session query results
    // and client capabilities for this client.
    ULONG bClientSupportsRedirection : 1;
    ULONG bRequestedSessionIDFieldValid : 1;
    ULONG bClientRequireServerAddr : 1;
    UINT32 RequestedSessionID;
    unsigned NumClusterDiscSessions;
    TSSD_DisconnectedSessionInfo ClusterDiscSessions[TSSD_MaxDisconnectedSessions];

    HANDLE hWinmmConsoleAudioEvent;     // Event that set if console audio is enabled remotely
    HANDLE hRDPAudioDisabledEvent;      // Event that is set if remote audio is disabled for session 0, rdpsnd.dll is checking it
    // Support for longer UserName and Password during client autologon to a Terminal Server
    pExtendedClientCredentials pNewClientCredentials ; 

    HANDLE hReconnectReadyEvent;
    // The following structure is used to send back the logon notification to the client
    PCLIENTNOTIFICATIONCREDENTIALS pNewNotificationCredentials;

    // Cache original shadow setting when session is created.
    // this is to fix a security hole created by Salem/pcHealth in that
    // pcHealth dynamically switch shadow to full control without
    // user permission and does not reset it, a normal
    // termination of Help will trigger Salem sessmgr to reset shadow 
    // back to original setting, but a bad expert can stop sessmgr service
    // and our session's shadow setting will still be FULL CONTROL
    // WITHOUT USER PERMISSION, anyone with enough priviledge can then
    // start shadow and take control of this session .
    SHADOWCLASS OriginalShadowClass;
    //termsrv's cached cache statistics
    CACHE_STATISTICS Cache;
    PREMEMBERED_CLIENT_ADDRESS pRememberedAddress;
    PREMEMBERED_CLIENT_ADDRESS pLastClientAddress;
    BOOLEAN fReconnectPending;      // Flag to indicate Reconnect is still Pending 
    BOOLEAN fReconnectingToConsole; // Flag to indicate we r going to reconnect a session to the Console
    HANDLE  SessionInitializedEvent; // Event which indicates winlogon is done creating desktop for this session
    AUTORECONNECTIONINFO AutoReconnectInfo;
    RECONNECT_TYPE LastReconnectType;
    BOOLEAN fDisallowAutoReconnect;
    WCHAR ExecSrvSystemPipe[EXECSRVPIPENAMELEN];
    BOOLEAN  fSmartCardLogon;                       // Flag to indicate if a SmartCard was used to Logon to this session
    BOOLEAN  fSDRedirectedSmartCardLogon;          // Flag to indicate that this is gonna be a Session directory redirected AutoLogon
} WINSTATION, *PWINSTATION;

/*
 * WinStation Flags
 */
#define WSF_CONNECT          0x00000001 // being connected
#define WSF_DISCONNECT       0x00000002 // being disconnected
#define WSF_RESET            0x00000004 // being reset
#define WSF_DELETE           0x00000008 // being deleted
#define WSF_DOWNPENDING      0x00000010 // down pending
#define WSF_LOGOFF           0x00000020 // being logged off
#define WSF_LISTEN           0x00000040 // this is a "listening" WinStation
#define WSF_IDLE             0x00000080 // part of the idle pool
#define WSF_IDLEBUSY         0x00000100 // idle but in process of connecting
#define WSF_AUTORECONNECTING 0x00000200 // autoreconnecting

/*
 *  WinStation State Flags
 */

#define WSF_ST_WINSTATIONTERMINATE  0x00000001  //Called WinstationTerminate for this session
#define WSF_ST_DELAYED_STACK_TERMINATE  0x00000002 //Need to delay stack termination till WinstationDeleProc()
#define WSF_ST_BROKEN_CONNECTION    0x00000004 // received a broken connection indication
#define WSF_ST_CONNECTED_TO_CSRSS   0x00000008 // Connected or reconnected to CSRSS
#define WSF_ST_IN_DISCONNECT       0x00000010 // Disconnect processing is pending
#define WSF_ST_LOGON_NOTIFIED       0x00000020 // Logon notification is received
#define WSF_ST_SHADOW      0x00000200      // In shadow or waiting for user
#define WSF_ST_LICENSING   0x00000400      // Postlogon licensing hapened.

/*
 * Help Assistant Session flag.
 *  3 bits, winlogon, msgina, licensing query termsrv in different 
 *  phrase of logon, we don't want to make repeated call, and since 
 *  we can't be sure if a session is a help session until winlogon
 *  actually logon a user, we need more than TRUE/FALSE bit.
 */
#define WSF_ST_HELPSESSION_FLAGS                        0xF0000000      // reserved flags.
#define WSF_ST_HELPSESSION_NOTSURE                      0x00000000      // No sure it is helpassistant session
#define WSF_ST_HELPSESSION_NOTHELPSESSION               0x20000000      // Detemined not a helpassistant session
#define WSF_ST_HELPSESSION_HELPSESSION                  0x40000000      // Session is a helpassistant session
#define WSF_ST_HELPSESSION_HELPSESSIONINVALID           0x80000000      // HelpAssistant logon but ticket is invalid

/*
 * Reconnect struct
 *
 * This structure is used to store WinStation connection information.
 * This structure is transferred from one WinStation to another when
 * processing a reconnect.
 */
typedef struct _RECONNECT_INFO {
    WINSTATIONNAME WinStationName;      // WinStation Name
    WINSTATIONNAME ListenName;          // WinStation Name
    WINSTATIONCONFIG2 Config;           // Registry config data
    WINSTATIONCLIENT Client;            // WinStation client data
    struct _WSEXTENSION *pWsx;
    PVOID pWsxContext;
    HANDLE hIca;                        // temp ICA device handle to connect
                                        // stack to while in disconnect state
    HANDLE hStack;                      // handle of stack being reconnected
    PVOID pEndpoint;                    // endpoint data for connection..
    ULONG EndpointLength;               // ..being reconnected
    BOOLEAN fOwnsConsoleTerminal;       // session currently connected to the console
    WCHAR   DisplayDriverName[9];
    WCHAR   ProtocolName[9];
    // The following structure is used to send back the logon notification to the client
    PCLIENTNOTIFICATIONCREDENTIALS pNotificationCredentials;
    PREMEMBERED_CLIENT_ADDRESS pRememberedAddress;

} RECONNECT_INFO, *PRECONNECT_INFO;


/*
 * Shadow entry
 * There is one of these for each shadow client,
 * linked from the target WinStation (ShadowHead).
 */
typedef struct _SHADOW_INFO {
    LIST_ENTRY Links;
    HANDLE hStack;
    HANDLE hBrokenEvent;
    PVOID pEndpoint;
    ULONG EndpointLength;
} SHADOW_INFO, *PSHADOW_INFO;


/*
 * Command entry struct
 */
typedef struct _COMMAND_ENTRY {
    LIST_ENTRY Links;
    HANDLE Event;
    struct _WINSTATION_APIMSG * pMsg;
} COMMAND_ENTRY, *PCOMMAND_ENTRY;


/*
 * Event wait structure
 */
typedef struct _EVENT {
    LIST_ENTRY EventListEntry;
    HANDLE   Event;
    BOOLEAN  fWaiter;
    BOOLEAN  fClosing;
    NTSTATUS WaitResult;
    ULONG    EventMask;
    ULONG    EventFlags;
} EVENT, *PEVENT;

/*
 * RPC client context structure
 */
typedef struct _RPC_CLIENT_CONTEXT{
    PEVENT pWaitEvent;
} RPC_CLIENT_CONTEXT, *PRPC_CLIENT_CONTEXT;




/*
 * This structure is used to keep track of the client accessing the
 * LPC interfaces. This structure is pointed to by the CONTEXT value
 * that the NT LPC system maintains for us on a per communication port
 * basis.
 */
typedef struct _LPC_CLIENT_CONTEXT {
    ULONG     ClientLogonId;
    HANDLE    CommunicationPort;
    ULONG     AccessRights;
    PVOID     ClientViewBase;
    PVOID     ClientViewBounds;
    PVOID     ViewBase;
    SIZE_T     ViewSize;
    PVOID     ViewRemoteBase;
} LPC_CLIENT_CONTEXT, *PLPC_CLIENT_CONTEXT;


typedef struct _LOAD_BALANCING_METRICS {

    BOOLEAN fInitialized;

    // Basic system information
    ULONG NumProcessors;
    ULONG PageSize;
    ULONG PhysicalPages;

    // Idle system values to remove base system usage
    ULONG BaselineFreePtes ;
    ULONG BaselinePagedPool;
    ULONG BaselineCommit;

    // Minimum usage values to prevent absurdly large estimates
    ULONG MinPtesPerUser;
    ULONG MinPagedPoolPerUser;
    ULONG MinCommitPerUser;

    // Live usage values derived from runtime data: totals
    ULONG PtesUsed;
    ULONG PagedPoolUsed;
    ULONG CommitUsed;

    // Live usage values derived from runtime data: per user
    ULONG AvgPtesPerUser;
    ULONG AvgPagedPoolPerUser;
    ULONG AvgCommitPerUser;

    // Raw and Estimated values for session capacity
    ULONG RemainingSessions;
    ULONG EstimatedSessions;

    // CPU utilization metrics
    ULONG AvgIdleCPU;
    LARGE_INTEGER TotalCPU;
    LARGE_INTEGER IdleCPU;

} LOAD_BALANCING_METRICS, *PLOAD_BALANCING_METRICS;


// TODO: Is there a better place to get this value from?
//
#define MAX_PROCESSORS      32


// Minimum assumed resource usage per user
//
// TODO: Use these as registry defaults, but attempt to read from registry
//

// Floating point optimization: (Avg >> 1) == 0.50 (growth reservation)
#define SimGrowthBias             1
#define SimUserMinimum            5

// DEW (34 threads) = 1434KB (PTE) + 649KB (PP) + 172KB (NPP)
#define DEWAvgPtesPerUser         1434
#define DEWAvgPagedPoolPerUser    649 
#define DEWAvgNonPagedPoolPerUser 172
#define DEWCommitPerUser          3481

// KW  (65 threads) = 2812KB (PTE) + 987KB (PP) + 460KB (NPP)
#define KWAvgPtesPerUser          2812
#define KWAvgPagedPoolPerUser     987
#define KWAvgNonPagedPoolPerUser  460
#define KWCommitPerUser           7530

#define SimAvgPtesPerUser         DEWAvgPtesPerUser
#define SimAvgPagedPoolPerUser    DEWAvgPagedPoolPerUser
#define SimAvgNonPagedPoolPerUser DEWAvgNonPagedPoolPerUser
#define SimCommitPerUser          DEWCommitPerUser

/*
 * Global variables
 */
extern BOOLEAN ShutdownInProgress;
//extern BOOLEAN ShutdownTerminateNoWait;
extern ULONG ShutDownFromSessionID;
extern RTL_CRITICAL_SECTION WinStationListLock;
extern RTL_CRITICAL_SECTION WinStationListenersLock;
extern RTL_CRITICAL_SECTION TimerCritSec;
extern LIST_ENTRY SystemEventHead;
extern HANDLE hTrace;
extern BOOL g_bPersonalTS;
extern BOOL g_bAdvancedServer;
extern BOOL g_bPersonalWks;
extern BOOL gbServer;
extern BOOL gbListenerOff;
extern BOOLEAN g_fDenyTSConnectionsPolicy;
extern BOOL g_PreAuthenticateClient;
extern HANDLE hCleanupTimer;
extern BOOL g_BlackListPolicy;
extern LONG g_CleanupTimerOn;

/*
 * Globals to support load balancing.  Since this is queried frequently we can't
 * afford to lock the winstation list and count them up.
 */
extern ULONG IdleWinStationPoolCount;
extern ULONG WinStationTotalCount;
extern ULONG WinStationDiscCount;
extern LOAD_BALANCING_METRICS gLB;

extern ExtendedClientCredentials g_MprNotifyInfo;


/*
 * Function prototypes
 */
NTSTATUS InitTermSrv(HKEY);

void StartAllWinStations(HKEY);

NTSTATUS CheckWinStationEnable(LPWSTR);

NTSTATUS SetWinStationEnable(LPWSTR, ULONG);

NTSTATUS
LoadSubSystemsForWinStation(
    IN PWINSTATION pWinStation );

VOID
FreeWinStationLists(
    PWINSTATION pWinStation );

NTSTATUS
GetProcessLogonId(
    IN HANDLE Process,
    OUT PULONG pLogonId );

NTSTATUS
SetProcessLogonId(
    IN HANDLE Process,
    IN ULONG LogonId );

PWINSTATION FindWinStationById( ULONG, BOOLEAN );
PWINSTATION FindWinStationByName( LPWSTR, BOOLEAN );
void IncrementReference(PWINSTATION pWinStation);
BOOLEAN IsWinStationLockedByCaller( PWINSTATION );

NTSTATUS QueueWinStationReset( IN ULONG LogonId );
NTSTATUS QueueWinStationDisconnect( IN ULONG LogonId );
VOID ResetGroupByListener( PWINSTATIONNAME );

VOID NotifySystemEvent(ULONG);

NTSTATUS WinStationOpenChannel(
        HANDLE IcaDevice,
        HANDLE ProcessHandle,
        CHANNELCLASS ChannelClass,
        PVIRTUALCHANNELNAME pVirtualName,
        PHANDLE pDupChannel);

VOID InvalidateTerminateWaitList(VOID);

#define UnlockWinStation( _p )   UnlockRefLock( &_p->Lock )
#define RelockWinStation( _p )   RelockRefLock( &_p->Lock )

#if DBG
#define ReleaseWinStation( _p )  ReleaseRefLock( &_p->Lock ); \
                                                _p = NULL;
#else
#define ReleaseWinStation( _p )  ReleaseRefLock( &_p->Lock )
#endif



NTSTATUS InitRefLock( PREFLOCK, PREFLOCKDELETEPROCEDURE );
BOOLEAN  LockRefLock( PREFLOCK );
VOID     UnlockRefLock( PREFLOCK );
BOOLEAN  RelockRefLock( PREFLOCK );
VOID     ReleaseRefLock( PREFLOCK );
VOID     DeleteRefLock( PREFLOCK );

#if DBG
#define ENTERCRIT(_x) \
        { \
            ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (_x)->OwningThread ); \
            RtlEnterCriticalSection(_x); \
        }
#define LEAVECRIT(_x) \
        { \
            ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) == (_x)->OwningThread ); \
            RtlLeaveCriticalSection(_x); \
        }
#else
#define ENTERCRIT(_x)   RtlEnterCriticalSection(_x)
#define LEAVECRIT(_x)   RtlLeaveCriticalSection(_x)
#endif

NTSTATUS
MakeUserGlobalPath(
    IN OUT PUNICODE_STRING Unicode,
    IN ULONG LogonId );

NTSTATUS SendWinStationCommand( PWINSTATION, PWINSTATION_APIMSG, ULONG );

NTSTATUS
WsxStackIoControl(
    PVOID pContext,
    IN HANDLE pStack,
    IN ULONG IoControlCode,
    IN PVOID pInBuffer,
    IN ULONG InBufferSize,
    OUT PVOID pOutBuffer,
    IN ULONG OutBufferSize,
    OUT PULONG pBytesReturned );


VOID MergeUserConfigData( PWINSTATION pWinStation, 
                    PPOLICY_TS_USER         pPolicy,
                    PUSERCONFIGW            pPolicyData,
                    PUSERCONFIG             pUserConfig ) ;
                

VOID StartLogonTimers( PWINSTATION );
VOID ResetUserConfigData( PWINSTATION );

LONG    IcaTimerCreate( ULONG, HANDLE * );
NTSTATUS IcaTimerStart( HANDLE, PVOID, PVOID, ULONG );
BOOLEAN IcaTimerCancel( HANDLE );
BOOLEAN IcaTimerClose( HANDLE );

VOID InitializeTrace(IN PWINSTATION, IN BOOLEAN, OUT PICA_TRACE);
void InitializeSystemTrace(HKEY);
void GetSetSystemParameters(HKEY);

NTSTATUS CdmConnect( ULONG, HANDLE );
NTSTATUS CdmDisconnect( ULONG, HANDLE );

VOID VirtualChannelSecurity( PWINSTATION );

VOID
WinstationUnloadProfile( PWINSTATION pWinStation);

NTSTATUS
WinStationResetWorker(
    ULONG   LogonId,
    BOOLEAN bWait,
    BOOLEAN CallerIsRpc,
    BOOLEAN bRecreate
    );

BOOL     StartStopListeners( LPWSTR WinStationName, BOOLEAN bStart );
NTSTATUS WinStationCreateWorker( PWINSTATIONNAME, PULONG, BOOLEAN );

NTSTATUS ConsoleShadowStart( IN PWINSTATION pWinStation,
                             IN PWINSTATIONCONFIG2 pClientConfig,
                             IN PVOID pModuleData,
                             IN ULONG ModuleDataLength);

NTSTATUS ConsoleShadowStop(PWINSTATION pWinStation);

NTSTATUS TransferConnectionToIdleWinStation(
    PWINSTATION pListenWinStation,
    PVOID pEndpoint,
    ULONG EndpointLength,
    PICA_STACK_ADDRESS pStackAddress );

PWINSTATION
GetWinStationFromArcInfo(
    PBYTE pClientRandom,
    LONG  cbClientRandomLen,
    PTS_AUTORECONNECTINFO pArc
    );



// Why doesn't the compiler complain that each source file is redefining
// a global variable? This file _is_ included by all source files in this
// directory. But these definitions will cause warnings if they show up
// in the licensing core, so give the core the ability to ifdef them out.

#ifndef LSCORE_NO_ICASRV_GLOBALS
PVOID IcaHeap;

PVOID DefaultEnvironment;

HANDLE IcaSmApiPort;
HANDLE hModuleWin;
#endif

#if DBG
#define DBGPRINT(_arg) DbgPrint _arg
#else
#define DBGPRINT(_arg)
#endif

#if DBG
#undef TRACE
#define TRACE(_arg)     { if (hTrace) IcaSystemTrace _arg; }
#else
#define TRACE(_arg)
#endif


/*=============================================================================
== TermSrv Server Extension supplied procs
=============================================================================*/

/*
 * Macros
 */

#define WSX_INITIALIZE                        "WsxInitialize"
#define WSX_WINSTATIONINITIALIZE              "WsxWinStationInitialize"
#define WSX_WINSTATIONREINITIALIZE            "WsxWinStationReInitialize"
#define WSX_WINSTATIONRUNDOWN                 "WsxWinStationRundown"

#define WSX_CDMCONNECT                        "WsxConnect"
#define WSX_CDMDISCONNECT                     "WsxDisconnect"

#define WSX_VERIFYCLIENTLICENSE               "WsxVerifyClientLicense"
#define WSX_QUERYLICENSE                      "WsxQueryLicense"
#define WSX_GETLICENSE                        "WsxGetLicense"

#define WSX_WINSTATIONLOGONANNOYANCE          "WsxWinStationLogonAnnoyance"
#define WSX_WINSTATIONGENERATELICENSE         "WsxWinStationGenerateLicense"
#define WSX_WINSTATIONINSTALLLICENSE          "WsxWinStationInstallLicense"
#define WSX_WINSTATIONENUMERATELICENSES       "WsxWinStationEnumerateLicenses"
#define WSX_WINSTATIONACTIVATELICENSE         "WsxWinStationActivateLicense"
#define WSX_WINSTATIONREMOVELICENSE           "WsxWinStationRemoveLicense"
#define WSX_WINSTATIONSETPOOLCOUNT            "WsxWinStationSetPoolCount"
#define WSX_WINSTATIONQUERYUPDATEREQUIRED     "WsxWinStationQueryUpdateRequired"
#define WSX_WINSTATIONANNOYANCETHREAD         "WsxWinStationAnnoyanceThread"

#define WSX_DUPLICATECONTEXT                  "WsxDuplicateContext"
#define WSX_COPYCONTEXT                       "WsxCopyContext"
#define WSX_CLEARCONTEXT                      "WsxClearContext"

#define WSX_INITIALIZECLIENTDATA              "WsxInitializeClientData"
#define WSX_INITIALIZEUSERCONFIG              "WsxInitializeUserConfig"
#define WSX_CONVERTPUBLISHEDAPP               "WsxConvertPublishedApp"
#define WSX_VIRTUALCHANNELSECURITY            "WsxVirtualChannelSecurity"
#define WSX_ICASTACKIOCONTROL                 "WsxIcaStackIoControl"

#define WSX_BROKENCONNECTION                  "WsxBrokenConnection"

#define WSX_LOGONNOTIFY                       "WsxLogonNotify"
#define WSX_SETERRORINFO                      "WsxSetErrorInfo"
#define WSX_ESCAPE                            "WsxEscape"
#define WSX_SENDAUTORECONNECTSTATUS           "WsxSendAutoReconnectStatus"

/*
 * Typedefs and structures
 */

typedef struct _WSEXTENSION {

    LIST_ENTRY Links;                   // Links
    DLLNAME WsxDLL;                     // DLL name

    HANDLE hInstance;                   // Handle of the DLL

    PVOID Context;                      // Extension context data

    PWSX_INITIALIZE                     pWsxInitialize;
    PWSX_WINSTATIONINITIALIZE           pWsxWinStationInitialize;
    PWSX_WINSTATIONREINITIALIZE         pWsxWinStationReInitialize;
    PWSX_WINSTATIONRUNDOWN              pWsxWinStationRundown;

    PWSX_CDMCONNECT                     pWsxCdmConnect;
    PWSX_CDMDISCONNECT                  pWsxCdmDisconnect;

    PWSX_VERIFYCLIENTLICENSE            pWsxVerifyClientLicense;
    PWSX_QUERYLICENSE                   pWsxQueryLicense;
    PWSX_GETLICENSE                     pWsxGetLicense;

    PWSX_WINSTATIONLOGONANNOYANCE       pWsxWinStationLogonAnnoyance;
    PWSX_WINSTATIONGENERATELICENSE      pWsxWinStationGenerateLicense;
    PWSX_WINSTATIONINSTALLLICENSE       pWsxWinStationInstallLicense;
    PWSX_WINSTATIONENUMERATELICENSES    pWsxWinStationEnumerateLicenses;
    PWSX_WINSTATIONACTIVATELICENSE      pWsxWinStationActivateLicense;
    PWSX_WINSTATIONREMOVELICENSE        pWsxWinStationRemoveLicense;
    PWSX_WINSTATIONSETPOOLCOUNT         pWsxWinStationSetPoolCount;
    PWSX_WINSTATIONQUERYUPDATEREQUIRED  pWsxWinStationQueryUpdateRequired;
    PWSX_WINSTATIONANNOYANCETHREAD      pWsxWinStationAnnoyanceThread;

    PWSX_DUPLICATECONTEXT               pWsxDuplicateContext;
    PWSX_COPYCONTEXT                    pWsxCopyContext;
    PWSX_CLEARCONTEXT                   pWsxClearContext;

    PWSX_INITIALIZECLIENTDATA           pWsxInitializeClientData;
    PWSX_INITIALIZEUSERCONFIG           pWsxInitializeUserConfig;
    PWSX_CONVERTPUBLISHEDAPP            pWsxConvertPublishedApp;

    PWSX_VIRTUALCHANNELSECURITY         pWsxVirtualChannelSecurity;
    PWSX_ICASTACKIOCONTROL              pWsxIcaStackIoControl;

    PWSX_BROKENCONNECTION               pWsxBrokenConnection;

    PWSX_LOGONNOTIFY                    pWsxLogonNotify;
    PWSX_SETERRORINFO                   pWsxSetErrorInfo;
    PWSX_SENDAUTORECONNECTSTATUS        pWsxSendAutoReconnectStatus;
    PWSX_ESCAPE                         pWsxEscape; 

} WSEXTENSION, * PWSEXTENSION;

//
// For disconnect / reconnect completion constants
// Currently we wait 5000 milisecs (12*15) times,
// which make a maximum total wait of 3 minutes.

#define WINSTATION_WAIT_COMPLETE_DURATION 5000
#define WINSTATION_WAIT_COMPLETE_RETRIES  (12*15)

// For disconnect completion constant when we do a reconnect
// Currently we wait 2000 milisecs, (5*3) times,
// which make a maximum total wait of 30 seconds

#define WINSTATION_WAIT_DURATION 2000
#define WINSTATION_WAIT_RETRIES  (5*3)


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\registry.c ===
/*************************************************************************
*
* registry.c
*
*  WinStation Registry Routines
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   Public functions
=============================================================================*/

NTSTATUS WinStationReadRegistryWorker( VOID );


/*=============================================================================
==   Functions Used
=============================================================================*/

NTSTATUS IcaRegWinStationEnumerate( PULONG, PWINSTATIONNAME, PULONG );
NTSTATUS QueueWinStationCreate( PWINSTATIONNAME );
PWINSTATION FindWinStationByName( LPWSTR WinStationName, BOOLEAN LockList );
NTSTATUS QueueWinStationReset( ULONG LogonId );
NTSTATUS ReadWinStationSecurityDescriptor( PWINSTATION pWinStation );
NTSTATUS WinStationRenameWorker(PWINSTATIONNAME, ULONG, PWINSTATIONNAME, ULONG);

/*=============================================================================
==   Global data
=============================================================================*/

extern LIST_ENTRY WinStationListHead;    // protected by WinStationListLock

extern RTL_RESOURCE WinStationSecurityLock;
extern POLICY_TS_MACHINE    g_MachinePolicy;    //defined in winsta.c
extern RTL_RESOURCE WinStationSecurityLock;
extern BOOL g_fGetLocalIP;      //defined in winsta.c

extern WINSTATIONCONFIG2 gConsoleConfig;


/*******************************************************************************
 *
 *  WinStationReadRegistryWorker
 *
 *    Update the listening winstations to match the registry
 *
 *    This function assumes that g_MachinePolicy is up to date. This object is a global object
 *      which is updated on TS startup, and any time there is a TS related policy change.
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

typedef struct _RENAMEINFO {
    WINSTATIONNAME OldName;
    BOOLEAN Renamed;
} RENAMEINFO, *PRENAMEINFO;

#define KEEP_ALIVE_INTERVAL_DFLT     4     // in minutes

NTSTATUS
WinStationKeepAlive()
{
    NTSTATUS                    Status;
    ICA_KEEP_ALIVE              k;
    HANDLE                      hKeepAlive;
    static      ICA_KEEP_ALIVE  kPrev;
    static      BOOLEAN         firstTime = TRUE;

    k.start     = FALSE;
    k.interval  = 0;

    if ( g_MachinePolicy.fPolicyKeepAlive )
    {
        k.start = (BOOLEAN) g_MachinePolicy.fKeepAliveEnable;
        k.interval = g_MachinePolicy.KeepAliveInterval;
    }
    else
    {
        // read to see what the registry policy is set to...
        // Code below was cut/paste from termdd ( where Zw was replaced with Nt )
        UNICODE_STRING    RegistryPath;
        UNICODE_STRING    KeyName;
        HANDLE            hKey;
        OBJECT_ATTRIBUTES ObjAttribs;
        ULONG             KeyInfoBuffer[16];
        ULONG             KeyInfoLength;
        PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;
        ULONG             KeepAliveEnable;
        ULONG             KeepAliveInterval;
    
        // Open the Terminal Server subkey under \\HKEY_LOCAL_MACHINE\SYSTEM\CurrentConttrolSet\
        // Control\Terminal Server
        RtlInitUnicodeString(&RegistryPath, REG_NTAPI_CONTROL_TSERVER);
        InitializeObjectAttributes(&ObjAttribs, &RegistryPath, OBJ_CASE_INSENSITIVE, NULL, NULL);
        Status = NtOpenKey(&hKey, KEY_READ, &ObjAttribs);
    
        if (Status == STATUS_SUCCESS) {
            pKeyInfo =  (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfoBuffer;
    
            // Get the value for KeepAliveEnable Key
            RtlInitUnicodeString(&KeyName, KEEP_ALIVE_ENABLE_KEY);
            Status = NtQueryValueKey(hKey, &KeyName, KeyValuePartialInformation,
                    pKeyInfo, sizeof(KeyInfoBuffer), &KeyInfoLength);
    
            if ((Status == STATUS_SUCCESS) && (pKeyInfo->Type == REG_DWORD) &&
                    (pKeyInfo->DataLength == sizeof(ULONG))) {
                KeepAliveEnable = *((PULONG) pKeyInfo->Data);
            }
            else {
                // By default, we don't enable keepalive
                KeepAliveEnable = 0;
            }
    
            if (KeepAliveEnable) {
                // Get the value for KeepAliveInterval
                RtlInitUnicodeString(&KeyName, KEEP_ALIVE_INTERVAL_KEY);
                Status = NtQueryValueKey(hKey, &KeyName, KeyValuePartialInformation,
                        pKeyInfo, sizeof(KeyInfoBuffer), &KeyInfoLength);
    
                if (Status == STATUS_SUCCESS && (pKeyInfo->Type == REG_DWORD) &&
                        (pKeyInfo->DataLength == sizeof(ULONG))) {
                    KeepAliveInterval = *((PULONG) pKeyInfo->Data);
                }
                else {
                    // The default KeepAliveInterval is 2 min
                    KeepAliveInterval = KEEP_ALIVE_INTERVAL_DFLT;
                }
            }
            else {
                // The default KeepAliveInterval
                KeepAliveInterval = KEEP_ALIVE_INTERVAL_DFLT;
            }
    
            // Close the Key
            NtClose(hKey);
        }
        else {
            // Set the default values for KeepAlive parameters
            KeepAliveEnable = 0;
            KeepAliveInterval = KEEP_ALIVE_INTERVAL_DFLT;
        }

        k.start = (BOOLEAN )KeepAliveEnable;
        k.interval =  KeepAliveInterval;

    }

    if ( firstTime )
    {
        kPrev = k;
    }
    else
    {

        #ifdef  DBG
            #ifdef ARABERN_TEST
                #include <time.h>
                ULONG   x;
                srand( (unsigned)time( NULL ) );
                x = rand();
                k.start =    (BOOLEAN ) (0x00000001 & x) ;
                k.interval = 0x00000008 & x ;
            #endif
        #endif
        
        if ( ( kPrev.start == k.start  )  && ( kPrev.interval == k.interval ) )
        {
            // no change, nothing to do, so return;
            return STATUS_SUCCESS;
        }
    }

    /*
     *  Open TermDD.
     */
    Status = IcaOpen(&hKeepAlive);

    if (NT_SUCCESS(Status)) 
    {
        Status = IcaIoControl(hKeepAlive, IOCTL_ICA_SYSTEM_KEEP_ALIVE , &k,
                sizeof(k), NULL, 0, NULL);

        IcaClose(hKeepAlive);
        hKeepAlive = NULL;
    }

    firstTime = FALSE;

    return Status;

}

NTSTATUS 
WinStationReadRegistryWorker()
{
    ULONG WinStationCount;
    ULONG ByteCount;
    WINSTATIONNAME * pWinStationName;
    PWINSTATIONCONFIG2 pWinConfig;
    PWINSTATION pWinStation;
    PRENAMEINFO pRenameInfo;
    PLIST_ENTRY Head, Next;
    NTSTATUS Status;
    ULONG i;
    
    if ( gbListenerOff )
        ENTERCRIT( &WinStationListenersLock );

    // see if keep alive is required, then IOCTL it to TermDD
    WinStationKeepAlive();

    // LanAdapter may changed, need to update this for Session Directory
    g_fGetLocalIP = FALSE;
    /*
     *  Get the number of WinStations in the registry
     */
    WinStationCount = 0;
    Status = IcaRegWinStationEnumerate( &WinStationCount, NULL, &ByteCount );
    if ( !NT_SUCCESS(Status) ) 
        goto badenum1;

    /*
     *  Allocate a buffer for the WinStation names
     */
    pWinStationName = MemAlloc( ByteCount );
    if ( pWinStationName == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto badalloc1;
    }

    /*
     * Get list of WinStation names from registry
     */
    WinStationCount = (ULONG) -1;
    Status = IcaRegWinStationEnumerate( &WinStationCount, 
                                        (PWINSTATIONNAME)pWinStationName, 
                                        &ByteCount );
    if ( !NT_SUCCESS(Status) ) 
        goto badenum2;

    /*
     *  Allocate a buffer for WinStation configuration data
     */
    pWinConfig = MemAlloc( sizeof(WINSTATIONCONFIG2) * WinStationCount );
    if ( pWinConfig == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto badalloc2;
    }

    /*
     *  Allocate a buffer for tracking listener WinStation renames
     */
    pRenameInfo = MemAlloc( sizeof(RENAMEINFO) * WinStationCount );
    if ( pRenameInfo == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto badalloc3;
    }


    /*
     * Now query the configuration data for each of the WinStation names
     */
    for ( i = 0; i < WinStationCount; i++ ) {
        pRenameInfo[i].Renamed = FALSE;
            {
            TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationReadRegistryWorker: %S\n",pWinStationName[i]));
            Status = RegWinStationQueryEx( 
                                         SERVERNAME_CURRENT, 
                                         &g_MachinePolicy, 
                                         pWinStationName[i],
                                         &pWinConfig[i],
                                         sizeof(WINSTATIONCONFIG2),
                                         &ByteCount, TRUE );
            if ( !NT_SUCCESS(Status) ) {
                goto badregdata;
            }
        }
    }

    /*
     *  Check if any existing WinStations need to be deleted
     */
    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {

        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

        /*
         * only check listening and single-instance winstations
         */
        if ( !(pWinStation->Flags & WSF_LISTEN) &&
             !(pWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST) )
            continue;

        /* check if name still exists in the registry */
        for ( i = 0; i < WinStationCount; i++ ) {
            if ( !_wcsicmp( pWinStationName[i], pWinStation->WinStationName ) ) {
                break;
            }
        }

        if ( i == WinStationCount ) {
            /* The WinStation is not in the registry. If the listener was
               renamed, we don't want to reset it. We look for a registry
               entry which has the same configuration info.
             */

            for ( i = 0; i < WinStationCount; i++ ) {
                if ( !memcmp( &pWinStation->Config, &pWinConfig[i], sizeof(WINSTATIONCONFIG2) ) ) {
                    pRenameInfo[i].Renamed = TRUE;
                    wcscpy(pRenameInfo[i].OldName, pWinStation->WinStationName);
                    DBGPRINT(("TERMSRV: Renaming %ws to %ws\n",
                             pWinStation->WinStationName, pWinStationName[i]));
                    break;
                }
            }
    
        }

        /* If no match was found in the registry, or if the matching
           listener is diabled, reset the listener.
         */
        if ((i == WinStationCount) ||
            (CheckWinStationEnable(!pRenameInfo[i].Renamed ? 
                                   pWinStation->WinStationName :
                                   pWinStationName[i]) != STATUS_SUCCESS)) {
            TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationReadRegistryWorker: DELETE %u\n",
                   pWinStation->LogonId ));
            QueueWinStationReset( pWinStation->LogonId );
        }

    }
    LEAVECRIT( &WinStationListLock );
    
    /*
     *  Check if any WinStations need to be created or reset
     */
    for ( i = 0; i < WinStationCount; i++ ) {

        if ( _wcsicmp( pWinStationName[i], L"Console" ) ){
        /*
         * Ignore console WinStation
         */
            /*
             * If this WinStation exists, then see if the Registry data
             * has changed.  If so, then reset the WinStation.
             */
            if ( pWinStation = FindWinStationByName( pWinStationName[i], FALSE ) ) {

                if ( memcmp( &pWinStation->Config, &pWinConfig[i], sizeof(WINSTATIONCONFIG2) ) ) {

                    /*
                     * NOTE: For network WinStations, we test to see if the Lan
                     *       Adapter setting has changed.  If not, we simply
                     *       refresh the configuration data since resetting the
                     *       WinStation would reset ALL connections on the same
                     *       Transport/Lan adapter combination.
                     */
                    if ( pWinConfig[i].Pd[0].Create.SdClass == SdNetwork &&
                         pWinConfig[i].Pd[0].Params.Network.LanAdapter ==
                         pWinStation->Config.Pd[0].Params.Network.LanAdapter ) {
                        memcpy( &pWinStation->Config, &pWinConfig[i], sizeof(WINSTATIONCONFIG2) );

                        /*
                         * Listening network winstations should update their security 
                         * descriptors.
                         */
                        RtlAcquireResourceExclusive(&WinStationSecurityLock, TRUE);
                        ReadWinStationSecurityDescriptor( pWinStation );
                        RtlReleaseResource(&WinStationSecurityLock);
                        
                    /*
                     * NOTE: For async WinStations, if the WinStation is NOT in
                     *       in the listen state and the Device name and Modem
                     *       name have not changed, then we do nothing.  The
                     *       new config data will be read when the WinStation
                     *       is next re-created.
                     */
                    } else if ( pWinConfig[i].Pd[0].Create.SdClass == SdAsync &&
                                pWinStation->State != State_Listen &&
                                !memcmp ( pWinConfig[i].Pd[0].Params.Async.DeviceName,
                                          pWinStation->Config.Pd[0].Params.Async.DeviceName,
                                          sizeof( pWinConfig[i].Pd[0].Params.Async.DeviceName ) ) &&
                                !memcmp ( pWinConfig[i].Pd[0].Params.Async.ModemName,
                                          pWinStation->Config.Pd[0].Params.Async.ModemName,
                                          sizeof( pWinConfig[i].Pd[0].Params.Async.ModemName ) ) ) {

                        // Nothing to do

                    /*
                     * NOTE: For OEM WinStations, if the WinStation is NOT in
                     *       in the listen state and the Pd[0] params have not
                     *       changed, then we do nothing.  The new config data
                     *       will be read when the WinStation is next re-created.
                     */
                    } else if ( pWinConfig[i].Pd[0].Create.SdClass == SdOemTransport &&
                                pWinStation->State != State_Listen &&
                                !memcmp ( &pWinConfig[i].Pd[0].Params,
                                          &pWinStation->Config.Pd[0].Params,
                                          sizeof( pWinConfig[i].Pd[0].Params ) ) ) {

                        // Nothing to do

                    } else {

                        BOOLEAN bRecreate = TRUE;

                        if ( gbListenerOff ) {
                            if ( g_fDenyTSConnectionsPolicy  &&
                                 // Performance, we only want to check if policy enable help when connection is denied
                                 (!TSIsMachineInHelpMode() || !TSIsMachinePolicyAllowHelp()) ) {

                                bRecreate = FALSE;
                            } 

                            WinStationResetWorker( pWinStation->LogonId, TRUE, FALSE, bRecreate ); 

                        } else {

                            QueueWinStationReset( pWinStation->LogonId );
                        }
                    }
                }
                else if ( !(pWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST) ||
                          ( pWinStation->State == State_Listen ) ) {

                    RtlAcquireResourceExclusive(&WinStationSecurityLock, TRUE);
                    ReadWinStationSecurityDescriptor( pWinStation );
                    RtlReleaseResource(&WinStationSecurityLock);
                }
                ReleaseWinStation( pWinStation );

            } else
            if (pRenameInfo[i].Renamed &&
                NT_SUCCESS(WinStationRenameWorker(pRenameInfo[i].OldName,
                                                  sizeof(WINSTATIONNAMEW)/sizeof(WCHAR),
                                                  pWinStationName[i],
                                                  sizeof(WINSTATIONNAMEW)/sizeof(WCHAR)))) {
                // Rename succeeded - don't recreate listener
            /*
             * An active WinStation was not found so we will create one.
             */
            } else {

                 if ( gbListenerOff &&
                       g_fDenyTSConnectionsPolicy  &&
                      // Performance, we only want to check if policy enable help when connection is denied
                      (!TSIsMachineInHelpMode() || !TSIsMachinePolicyAllowHelp()) ) {

                     continue;
                 }

                /*
                 * NOTE: NEVER create TAPI modem winstations in this routine.
                 *       We only allow creation of these winstations at
                 *       system startup time due to issues with the TAPI
                 *       database potentially being locked by this and other
                 *       processes, resulting in incorrect TAPI device
                 *       enumeration.
                 */
                 if ( pWinConfig[i].Cd.CdClass != CdModem ) {
                     if (gbListenerOff ) {
                        WinStationCreateWorker( pWinStationName[i], NULL, TRUE );
                     } else {
                        QueueWinStationCreate( pWinStationName[i] );
                     }
                 }
            }
        }
        else
        {
            // Update shadow bit for session0. 
            // Session0 could be local ( hence named "console" ) or remoted (and named something like tcp-rdp-xxx).
            // In either case of session0 being local or remote, we need to update the shadow bit since session0 never
            // exits and we care about this param to stay current.
            // When session0 is remoted, there is a tmp session called "console" present, but that is a locked session
            // that doesn't have anybody logged in, and just goes away upon the return of session0 to local. So, I don't
            // think we need to update the shadow bit of that tmp session
            //
            // ok, what the hell, let's also update the fPromptForPassword & fInheritAutoLogon
            // for BUG 703350 
            //

            if ( pWinStation = FindWinStationById( 0, FALSE ) ) {

                pWinStation->Config.Config.User.Shadow = pWinConfig[i].Config.User.Shadow;
                pWinStation->Config.Config.User.fInheritShadow  = pWinConfig[i].Config.User.fInheritShadow;
                pWinStation->Config.Config.User.fInheritAutoLogon  = pWinConfig[i].Config.User.fInheritAutoLogon;
                pWinStation->Config.Config.User.fPromptForPassword  = pWinConfig[i].Config.User.fPromptForPassword;

                gConsoleConfig.Config.User.Shadow = pWinConfig[i].Config.User.Shadow;
                gConsoleConfig.Config.User.fInheritShadow = pWinConfig[i].Config.User.fInheritShadow;
                gConsoleConfig.Config.User.fInheritAutoLogon = pWinConfig[i].Config.User.fInheritAutoLogon;
                gConsoleConfig.Config.User.fPromptForPassword = pWinConfig[i].Config.User.fPromptForPassword;

                TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationReadRegistryWorker: %S, Shadow value of %d copied to console session's USERCONFIG\n",pWinStationName[i], 
                       pWinConfig[i].Config.User.Shadow));

                //Update security descriptor on session 0. 
                RtlAcquireResourceExclusive(&WinStationSecurityLock, TRUE);
                ReadWinStationSecurityDescriptor( pWinStation );
                RtlReleaseResource(&WinStationSecurityLock);

                ReleaseWinStation( pWinStation );
            }
        }
    }

    /*
     *  Free buffers
     */
    MemFree( pRenameInfo );
    MemFree( pWinConfig );
    MemFree( pWinStationName );

    if ( gbListenerOff )
        LEAVECRIT( &WinStationListenersLock );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badregdata:
    MemFree( pRenameInfo );
badalloc3:
    MemFree( pWinConfig );
badalloc2:
badenum2:
    MemFree( pWinStationName );
badalloc1:
badenum1:
    
    if ( gbListenerOff )
        LEAVECRIT( &WinStationListenersLock );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\icasrv.c ===
/****************************************************************************/
// icasrv.c
//
// TermSrv service process entry points.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <objbase.h>

#include "icaevent.h"
#include "sessdir.h"
#include <safeboot.h>

extern BOOL UpdateOemAndProductInfo(HKEY);

extern BOOL IsServiceLoggedAsSystem( VOID );

extern VOID     WriteErrorLogEntry(
            IN  NTSTATUS NtStatusCode,
            IN  PVOID    pRawData,
            IN  ULONG    RawDataLength
            );

extern NTSTATUS WinStationInitRPC();
extern NTSTATUS InitializeWinStationSecurityLock(VOID);
extern VOID AuditEnd();

/*
 * Definitions
 */
#define STACKSIZE_LPCTHREAD (4 * 0x1000)

/*
 * Internal Procedures defined
 */
VOID ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv);
VOID Handler(DWORD fdwControl);
BOOL UpdateServiceStatus(DWORD, DWORD, DWORD, DWORD);
void ShutdownService();

/*
 * Global variables
 */
WCHAR gpszServiceName[] = L"TermService";
SERVICE_TABLE_ENTRY gpServiceTable[] = {
    gpszServiceName, (LPSERVICE_MAIN_FUNCTION)ServiceMain,
    NULL,            NULL,
};

SERVICE_STATUS_HANDLE gStatusHandle;
SERVICE_STATUS gStatus;
DWORD gExitStatus = STATUS_SUCCESS;

WCHAR g_wszProductVersion[22];
TCHAR g_tszServiceAccount[UNLEN + 1];

BOOL g_fAppCompat = TRUE;
BOOL g_bPersonalTS = FALSE;
BOOL g_bPersonalWks = FALSE;
BOOL g_bAdvancedServer = FALSE;
BOOL g_SafeBootWithNetwork = FALSE;
BOOL gbServer = FALSE;


// BUGBUG: this variable means we want listner off when connections are not allowed.
// this is hardcoded value, and is never changed.
// we have kept the variable just in case we want to fall back to old behaviour.
BOOL gbListenerOff = TRUE;
BOOL g_PreAuthenticateClient = FALSE; // NOTE - do not change this value to TRUE unless PreAuth is needed
BOOL g_BlackListPolicy = TRUE;
LONG g_CleanupTimerOn = 0;

OSVERSIONINFOEX gOsVersion;

HANDLE gReadyEventHandle = NULL;

HANDLE hCleanupTimer = NULL;

//
// The following is used to inform Session 0 winlogon of the credentials needed to notify 3rd party n/w logon providers
// This happens only during force logoff console reconnect scenario in PTS and /console in Server
//
ExtendedClientCredentials g_MprNotifyInfo; 

extern PSID gAdminSid;
extern PSID gSystemSid;
extern PSID gAnonymousSid;

// Local prototypes.
void LicenseModeInit(HKEY);
NTSTATUS WsxInit(VOID);
NTSTATUS VfyInit(VOID);
BOOL WINAPI 
IsSafeBootWithNetwork();


void CreateTermsrvHeap ()
{
    IcaHeap = GetProcessHeap();
    return;
}

#ifdef TERMSRV_PROC
/****************************************************************************/
// main
//
// Standard console-app-style entry point. Returns an NTSTATUS code.
/****************************************************************************/
int _cdecl main(int argc, char *argv[])
{
    NTSTATUS Status = STATUS_SUCCESS;
    KPRIORITY BasePriority;
    HRESULT hr;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Loading...\n"));

    /*
     * Run TermSrv at just above foreground priority.
     */
    BasePriority = FOREGROUND_BASE_PRIORITY + 1;
    Status = NtSetInformationProcess(NtCurrentProcess(),
            ProcessBasePriority,
            &BasePriority,
            sizeof(BasePriority) );
    ASSERT((Status == STATUS_PRIVILEGE_NOT_HELD) || NT_SUCCESS(Status));

    // Initialize COM once with multithreaded capability. This must be done
    // on the main service thread to allow other threads in the service to
    // inherit this initialization, if not specifically initialized for
    // apartment threading.
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (!SUCCEEDED(hr)) {
        HANDLE h;
        WCHAR hrString[16];
        PWSTR String;

        h = RegisterEventSource(NULL, gpszServiceName);
        if (h != NULL) {
            wsprintfW(hrString, L"0x%X", hr);
            String = hrString;
            ReportEvent(h, EVENTLOG_ERROR_TYPE, 0, EVENT_TERMSRV_FAIL_COM_INIT,
                    NULL, 1, 0, &String, NULL);
            DeregisterEventSource(h);
        }

        DbgPrint("TERMSRV: Failed init COM, hr=0x%X\n", hr);
        goto done;
    }

    /*
     * Call service dispatcher
     */
    if (!StartServiceCtrlDispatcher(gpServiceTable)) {
        Status = GetLastError();
        DbgPrint("TERMSRV: Error %d in StartServiceCtrlDispatcher\n", Status);
        goto done;
    }

done:

    if (SUCCEEDED(hr))
        CoUninitialize();

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Unloading...\n"));
    return Status;
}
#else // TERMSRV_PROC

BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,  // handle to the DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
{

    BOOL fResult = TRUE;

    switch(fdwReason) {
        case DLL_PROCESS_ATTACH:

            hModuleWin = hinstDLL;

            DisableThreadLibraryCalls(hinstDLL);

            break;

        default:;
    }

    return fResult;

}

#endif // TERMSRV_PROC


/*****************************************************************************
 *
 *  InitializeLoadMetrics
 *
 *    Grabs baseline system resource values for use in load balancing.  These
 *    values are used to factor out the system resources required for basic OS
 *    operation so they don't get into the calculations for how much resource on
 *    average a user is consuming.
 *
 *
 * ENTRY:
 *    no arguments.
 *
 * EXIT:
 *   void
 *
 ****************************************************************************/
VOID InitializeLoadMetrics()
{
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION ProcessorInfo[MAX_PROCESSORS];
    SYSTEM_PERFORMANCE_INFORMATION           SysPerfInfo;
    SYSTEM_BASIC_INFORMATION                 SysBasicInfo;

    ULONG i;
    NTSTATUS Status;

    memset(&gLB, 0, sizeof(LOAD_BALANCING_METRICS));

    // Get basic system information
    Status = NtQuerySystemInformation(SystemBasicInformation, &SysBasicInfo,
                                      sizeof(SysBasicInfo), NULL);

    if (!NT_SUCCESS(Status)) {
        TRACE((hTrace, TC_LOAD, TT_ERROR,
               "InitializeLoadMetrics failed! SystemBasicInformation: %lx\n",
               Status));
        return;
    }

    gLB.NumProcessors = SysBasicInfo.NumberOfProcessors;
    gLB.PageSize = SysBasicInfo.PageSize;
    gLB.PhysicalPages = (ULONG)SysBasicInfo.NumberOfPhysicalPages;

    // Establish minimum usage levels to prevent absurd estimation
    gLB.MinPtesPerUser = SimAvgPtesPerUser;
    gLB.MinPagedPoolPerUser = (SimAvgPagedPoolPerUser * 1024) / gLB.PageSize;
    gLB.MinCommitPerUser = (SimCommitPerUser * 1024) / gLB.PageSize;

    // Grab base boot values.  This isn't perfect, but it allows us to factor
    // out base OS resource requirements from the per user averages.  The runtime
    // algorithm will reset the baselines if we go below these.
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      &SysPerfInfo, sizeof(SysPerfInfo),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        TRACE((hTrace, TC_LOAD, TT_ERROR, 
               "InitializeLoadMetrics failed! SystemPerformanceInformation: %lx\n",
               Status));
        return;
    }

    // Note: we have an unsolvable problem in that there is no way to get
    // perfect values for how much memory the baseline system consumes.  We
    // default baseline commit to 64M since that is the minimum recommended
    // system requirement.
    gLB.BaselineCommit    = (64 * 1024*1024) / gLB.PageSize;
//  gLB.BaselineCommit    = SysPerfInfo.CommittedPages;
    gLB.BaselineFreePtes  = SysPerfInfo.FreeSystemPtes;
    gLB.BaselinePagedPool = SysPerfInfo.PagedPoolPages;

    // Initialize CPU Loading
    Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                                      ProcessorInfo, 
                                      sizeof(ProcessorInfo),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        TRACE((hTrace, TC_LOAD, TT_ERROR, 
               "InitializeLoadMetrics failed! SystemProcessorPerformanceInformation: %lx\n",
               Status));
        return;
    }

    for (i = 0; i < gLB.NumProcessors; i++) {
        gLB.IdleCPU.QuadPart  += ProcessorInfo[i].IdleTime.QuadPart;
        gLB.TotalCPU.QuadPart += ProcessorInfo[i].KernelTime.QuadPart +
                                     ProcessorInfo[i].UserTime.QuadPart;
    }
    
    // Start out saying we're 80 percent idle (0-255 based)
    gLB.AvgIdleCPU = 204 ;

    // Indicate we got all the intial values!
    gLB.fInitialized = TRUE;

    TRACE((hTrace, TC_LOAD, TT_API1, "InitializeLoadMetrics():\n"));
    TRACE((hTrace, TC_LOAD, TT_API1, 
           "   Processors [%6ld], PageSize  [%6ld], Physical [%6ld]\n",
           gLB.NumProcessors, gLB.PageSize, gLB.PhysicalPages));
    TRACE((hTrace, TC_LOAD, TT_API1,
           "   PtesAvail  [%6ld], PagedUsed [%6ld], Commit   [%6ld]\n",
           gLB.BaselineFreePtes, gLB.BaselinePagedPool, gLB.BaselineCommit));
}


BOOL IsKernelDebuggerAttached ()
{
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInfo;
    NTSTATUS Status;

    Status = NtQuerySystemInformation( SystemKernelDebuggerInformation,
                    &KernelDebuggerInfo,
                    sizeof(KernelDebuggerInfo),
                    NULL
                    );

    return ( NT_SUCCESS(Status) && KernelDebuggerInfo.KernelDebuggerEnabled );
}

void DebugBreakIfAsked()
{

    TCHAR REG_TERMSRV_DEBUGBREAK[] = TEXT("DebugTS");
    TCHAR REG_TERMSRV_DEBUGGER[]   = TEXT("Debugger");
    TCHAR szDebugger[256];
    TCHAR szCommand[256];
    HKEY  hTermSrv = NULL;
    DWORD dwBreakIn;
    DWORD dwValueType;
    DWORD dwSize;
    DWORD dwError;

    enum
    {
        TermSrvDoNotBreak = 0,
        TermSrvBreakIfBeingDebugged = 1,
        TermSrvAttachDebugger = 2,
        TermSrvBreakAlways = 3
    };

    dwError = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    REG_CONTROL_TSERVER,
                    0,
                    KEY_READ,
                    &hTermSrv
                    );

    if (ERROR_SUCCESS == dwError)
    {
        dwSize = sizeof(dwBreakIn);
        dwError = RegQueryValueEx(
                        hTermSrv,
                        REG_TERMSRV_DEBUGBREAK,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwBreakIn,
                        &dwSize
                        );

        if (ERROR_SUCCESS == dwError && dwValueType == REG_DWORD)
        {
            switch (dwBreakIn)
            {
                case TermSrvAttachDebugger:

                    //
                    // if its already being debugged Break into it.
                    //

                    if (IsDebuggerPresent())
                    {
                        DebugBreak();
                        break;
                    }

                    //
                    // Get the debugger to be launched.
                    // must contain %d which will be replaced by processid
                    //
                    dwSize = sizeof(szDebugger) / sizeof(TCHAR);
                    dwError = RegQueryValueEx(
                                hTermSrv,
                                REG_TERMSRV_DEBUGGER,
                                NULL,
                                &dwValueType,
                                (LPBYTE)szDebugger,
                                &dwSize
                                );

                    if (ERROR_SUCCESS == dwError && dwValueType == REG_SZ)
                    {
                        PROCESS_INFORMATION ProcessInfo;
                        STARTUPINFO StartupInfo;
                        wsprintf(szCommand, szDebugger, GetCurrentProcessId());
                        DbgPrint("TERMSRV:*-----------------* Executing:<%ws> *-----------------*\n", szCommand);

                        ZeroMemory(&StartupInfo, sizeof(StartupInfo));
                        StartupInfo.cb = sizeof(StartupInfo);
                        if (!CreateProcess(NULL, szCommand, NULL, NULL, FALSE, 0, NULL, NULL, &StartupInfo, &ProcessInfo))
                        {
                            DbgPrint("TERMSRV:*-----------------* TERMSRV:CreateProcess failed *-----------------*\n");
                        }
                        else
                        {
                            CloseHandle(ProcessInfo.hProcess);
                            CloseHandle(ProcessInfo.hThread);

                            while (!IsDebuggerPresent())
                            {
                                Sleep(500);
                            }
                        }

                    }
                    else
                    {
                        DbgPrint("TERMSRV:*-----------------* Did not find the debugger entry. *-----------------*\n");
                    }
                    break;

                case TermSrvBreakIfBeingDebugged:

                    // check if any debugger is attached, if not dont breakin.
                    if (!IsDebuggerPresent() && !IsKernelDebuggerAttached ())
                        break;

                case TermSrvBreakAlways:
                    DebugBreak();
                    break;

                case TermSrvDoNotBreak:
                default:
                    break;

            }

        }

        RegCloseKey(hTermSrv);
    }
    else
    {
        DbgPrint("TERMSRV:*-----------------* Could not open termsrv registry *-----------------*\n");
    }
}

/****************************************************************************/
// ServiceMain
//
// TermSrv service entry point.
/****************************************************************************/
VOID ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv)
{
    HANDLE hIcaLPCThread;
    HANDLE hIcaLPCPort = NULL;
    DWORD  dwValueType;
    LONG   lReturn;
    DWORD  cbValue;
    BOOL   bAdvertiseTS;
    DWORD  dwTSAdvertise;
    NTSTATUS Status;
    HKEY hKeyTermSrv = NULL;

    DWORDLONG  dwlConditionMask;

    DebugBreakIfAsked();

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: ServiceMain entered...\n"));

    gStatus.dwServiceType = SERVICE_WIN32;
    gStatus.dwWaitHint = 30000;
    gStatus.dwCurrentState = SERVICE_STOPPED;



     /*
     * Register the control handler
     */
    if (!(gStatusHandle = RegisterServiceCtrlHandler(gpszServiceName,
            Handler))) {
        DbgPrint("TERMSRV: Error %d in RegisterServiceCtrlHandler\n",
        GetLastError());
        goto done;
    }


    // If Terminal Services are not enabled then don't allow starting termsrv
    // service.
    if (!IsTerminalServicesEnabled()) {
        HANDLE h;
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Not a TSBox."));
        h = RegisterEventSource(NULL, gpszServiceName);
        if (h != NULL) {
            if (!ReportEvent(
                    h,                     // event log handle
                    EVENTLOG_ERROR_TYPE,   // event type
                    0,                     // category zero
                    EVENT_NOT_A_TSBOX,     // event identifier
                    NULL,                  // no user security identifier
                    0,                     // one substitution string
                    0,                     // no data
                    NULL,                  // pointer to string array
                    NULL                   // pointer to data
                    )) {

                DBGPRINT(("ReportEvent Failed %ld. Event ID=%lx\n",GetLastError(), EVENT_NOT_A_TSBOX));
            }
        }

        goto done;
    }

    CreateTermsrvHeap ();


    /*
     * Create and set an event which indicates that TermSrv is ready.
     * WinLogon checks this event. Do not signal now.
     *
     */
    gReadyEventHandle = OpenEvent( EVENT_MODIFY_STATE, FALSE, TEXT("Global\\TermSrvReadyEvent") );

    // Initialize Global System and Admin SID
    Status = NtCreateAdminSid(&gAdminSid);

    if (!NT_SUCCESS(Status))
    {
        goto done;
    }

    Status = InitializeWinStationSecurityLock();
    if (!NT_SUCCESS(Status))
    {
        goto done;
    }

    Status = NtCreateSystemSid(&gSystemSid);

    if (!NT_SUCCESS(Status))
    {
        goto done;
    }
    
    //Initialize Anonymous SID (used to filter out anonymous RPC users).
    Status = NtCreateAnonymousSid(&gAnonymousSid);

    if (!NT_SUCCESS(Status))
    {
        goto done;
    }

    if (!IsServiceLoggedAsSystem()) {
        WriteErrorLogEntry(EVENT_NOT_SYSTEM_ACCOUNT, NULL, 0);
        gExitStatus = ERROR_PRIVILEGE_NOT_HELD;
        goto done;
    }

    // Set global flag for Personal WorkStation
    g_bPersonalWks = IsPersonalWorkstation();

    #if DBG
    if( TRUE == g_bPersonalWks )
    {
        DbgPrint("TERMSRV : TS running on Personal Workstation\n");
    }
    else
    {
        DbgPrint("TERMSRV : Not Personal Workstation\n");
    }
    #endif

    //
    // Initialize HelpAssistant password encryption.
    //
    lReturn = TSHelpAssistantInitializeEncryptionLib();

    //
    // Not a critical error, No help will be available
    //
    #if DBG
    if( lReturn != ERROR_SUCCESS ) {
        DbgPrint( "TERMSRV : EncryptionLib failed with %d, no help is available\n", lReturn );
    }
    #endif

    //
    // We are booting in safeboot with network support
    //
    g_SafeBootWithNetwork = IsSafeBootWithNetwork();


    // Set the global flag for Personal TS support. We use this to reduce
    // the feature set based on product (e.g. no load balancing session
    // directory if not on Server).
    g_bPersonalTS = IsPersonalTerminalServicesEnabled();
    g_bAdvancedServer = IsAdvancedServer();

    ZeroMemory(&gOsVersion, sizeof(OSVERSIONINFOEX));
    gOsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    gOsVersion.wProductType = VER_NT_WORKSTATION;
    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    gbServer = !VerifyVersionInfo(&gOsVersion, VER_PRODUCT_TYPE, dwlConditionMask);

    // Open a single, global HKLM\System\CCS\Control\TS reg handle, from which
    // other init code can query.
    lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
            KEY_READ, &hKeyTermSrv);
    if (lReturn != ERROR_SUCCESS) {
        DbgPrint("TERMSRV: Unable to open TS key in HKLM, lasterr=0x%X",
               GetLastError());
        goto done;
    }

    /*
     * Indicate service is starting.
     */
    Status = UpdateServiceStatus(SERVICE_START_PENDING, 0, 1, 0);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("TERMSRV: Unable update service status %X\n", Status );
    }

    Status = RtlCreateEnvironment(TRUE, &DefaultEnvironment);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("TERMSRV: Unable to alloc default environment, Status=0x%X\n",
                Status);
        goto done;
    }

#ifdef TERMSRV_PROC
    /*
     * Get the module handle for messages.
     */
    hModuleWin = GetModuleHandleW(NULL);
#endif // TERMSRV_PROC

    /*
     * Indicate service has started successfully.
     * Maybe this should be moved below? No way!!!
     */
    Status = UpdateServiceStatus(SERVICE_RUNNING, 0, 2, 0);
    if (!Status)
        DbgPrint("TERMSRV: Unable to update service status %X\n", Status);

    /*
     *  Connect to the session manager
     */




    Status = SmConnectToSm((PUNICODE_STRING)NULL, (HANDLE)NULL, 0,
            &IcaSmApiPort);
    if (!NT_SUCCESS(Status))
        goto done;

    // Initialize the licensing mode - this only gets information, it doesn't
    // initialize the licensing core.




    LicenseModeInit(hKeyTermSrv);

    // Perform the bulk of the TermSrv init.



    Status = InitTermSrv(hKeyTermSrv);
    if (!NT_SUCCESS(Status))
        goto ShutdownService;

    /*
     * Indicate that we are a Terminal Server unless were asked not to
     * advertise ourselves as a Terminal Server.
     */
    bAdvertiseTS = TRUE;
    cbValue = sizeof(dwTSAdvertise);
    lReturn = RegQueryValueEx(hKeyTermSrv, REG_TERMSRV_ADVERTISE, NULL,
            &dwValueType, (LPBYTE)&dwTSAdvertise, &cbValue);
    if (ERROR_SUCCESS == lReturn && dwValueType == REG_DWORD)
        bAdvertiseTS = dwTSAdvertise;
    if (bAdvertiseTS)
        SetServiceBits(gStatusHandle, SV_TYPE_TERMINALSERVER, TRUE, TRUE);

    /*
     * Need to do this at least once
     */
    UpdateOemAndProductInfo(hKeyTermSrv);

    // Initialize TermSrv and TermDD trace.


    InitializeSystemTrace(hKeyTermSrv);

    /*
     * Set TermDD parameters.
     */
    GetSetSystemParameters(hKeyTermSrv);

    /*
     * Initialize WinStation extension DLL support
     */
    Status = WsxInit();
    if (!NT_SUCCESS(Status))
        goto ShutdownService;

    /*
     *  Initialize DLL Verification mechanism.
     */
    Status = VfyInit();
    if (!NT_SUCCESS(Status))
        goto ShutdownService;

    /*
     * Start WinStations
     */


    StartAllWinStations(hKeyTermSrv);

    // Initialize the TS Session Directory for load balancing.
    // Not available on Personal TS or remote admin.
    if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer)
        InitSessionDirectory();


    InitializeLoadMetrics();

    // Done with init, close the TermSrv regkey.
    RegCloseKey(hKeyTermSrv);
    hKeyTermSrv = NULL;


    /*
     * Initialize WinStationAPI's
     */


    Status = WinStationInitRPC();
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto done;
    }


    /*
     * Set the  event which indicates that TermSrv is ready.
     * WinLogon checks this event. 
     */



    if (gReadyEventHandle != NULL)
        SetEvent(gReadyEventHandle);

    TSStartupSalem();

    return;

ShutdownService:
    ShutdownService();

done:
    // Kill the session directory.
    if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer)
        DestroySessionDirectory();

    // In case of error, check the TermSrv regkey again.
    if (hKeyTermSrv != NULL)
        RegCloseKey(hKeyTermSrv);

    UpdateServiceStatus(SERVICE_STOPPED, gExitStatus, 5, 0);
}


/****************************************************************************/
// Handler
//
// TermSrv service control event handler.
/****************************************************************************/
VOID Handler(DWORD fdwControl)
{
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Handler %d\n", fdwControl));
    switch (fdwControl) {
        case SERVICE_CONTROL_STOP:
            // We absolutely do not want to be stopping TermSrv -- it is
            // the only location for a lot of system-wide TS related state.
            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: control code %d, stopping service...\n",
                    fdwControl));
            if (gStatus.dwCurrentState == SERVICE_RUNNING) {
                UpdateServiceStatus(SERVICE_STOP_PENDING, 0, 3, 0);
#ifdef notdef
                // For now don't stop TermSRV
                // The CDM service does a KeAttachProcess() to this process
 
                if (gReadyEventHandle != NULL) {
                    ResetEvent(gReadyEventHandle);
                    CloseHandle(gReadyEventHandle);
                    gReadyEventHandle = NULL;
                }
                ShutdownService();
                UpdateServiceStatus(SERVICE_STOPPED, gExitStatus, 5, 0);
#endif
            }
            break;

        case SERVICE_CONTROL_SHUTDOWN:
            DBGPRINT(("TERMSRV: control code %d, shutdown service...\n",
                    fdwControl));
            if (gStatus.dwCurrentState == SERVICE_RUNNING) {
                // 2 seconds at most to shut down.
                UpdateServiceStatus(SERVICE_STOP_PENDING, 0, 4, 2000);
#ifdef notdef
                // We don't trigger this event that invokes destructors for
                // all of TermSrv, since on shutdown we don't want to be
                // destroying machine state. We want to invoke only those
                // destructors that are required for proper functioning of
                // the system.
#endif

                // Invoke required destruction code.
                if (gReadyEventHandle != NULL) {
                    ResetEvent(gReadyEventHandle);
                    CloseHandle(gReadyEventHandle);
                    gReadyEventHandle = NULL;
                }
                ShutdownService();
                UpdateServiceStatus(SERVICE_STOPPED, 0, 4, 0);
            }
            break;

        case SERVICE_CONTROL_INTERROGATE :
            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Interrogating service...\n"));
            SetServiceStatus(gStatusHandle, &gStatus);
            break;

        default:
            DBGPRINT(("TERMSRV: Unhandled control code %d\n", fdwControl));
            break;
    }
}


/****************************************************************************/
// ShutdownService
//
// Called by service manager to shut down the service at system shutdown
// time. This function should invoke only the most important and required
// destruction code, since we're on a strict time limit on system shutdown.
/****************************************************************************/
void ShutdownService()
{
    //free authz resource manager
    AuditEnd();

    // Destroy the session directory so the directory can be informed to
    // remove server- and session-specific information.
    if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer)
        DestroySessionDirectory();

    #if 0
        // Stop the Cleanup Timer 
        if (hCleanupTimer) {
            IcaTimerClose( hCleanupTimer );
            hCleanupTimer = NULL;
        }
    #endif 

}


/****************************************************************************/
// UpdateServiceStatus
//
// Updates the service's status to the Service Control Manager. Returns
// FALSE on error.
/****************************************************************************/
BOOL UpdateServiceStatus(
        DWORD CurrentState,
        DWORD ExitCode,
        DWORD CheckPoint,
        DWORD WaitHint)
{
    // If service is starting, then disable all control requests, otherwise
    // accept shutdown notifications if we are an app server, to properly
    // clean up the session directory. We do not accept stop requests
    // during the lifetime of the server up state, the CDM service does a
    // KeAttachProcess() to this process so it must always be around.
    if (gStatusHandle == NULL) {
        return FALSE;
    }

    gStatus.dwControlsAccepted = 0;

    gStatus.dwCurrentState = CurrentState;
    gStatus.dwWin32ExitCode = ExitCode;
    gStatus.dwCheckPoint = CheckPoint;
    gStatus.dwServiceSpecificExitCode = 0;
    gStatus.dwWaitHint = WaitHint;

    return SetServiceStatus(gStatusHandle, &gStatus);
}


/*****************************************************************************
 *  LicenseModeInit
 *
 *    Initialize the licensing mode
 ****************************************************************************/

void LicenseModeInit(HKEY hKeyTermSrv)
{
    DWORD dwValueType;
    LONG lReturn;
    DWORD cbValue = sizeof( DWORD ), dwAccount = UNLEN + 1;
    DWORD dwRegValue;
    OSVERSIONINFO VersionInfo;

    ASSERT(hKeyTermSrv != NULL);

    //
    // Get the user name for which the service is started under
    //
    GetUserName(g_tszServiceAccount, &dwAccount);

    // 
    // Check whether Remote Admin is enabled
    //
    lReturn = RegQueryValueEx(hKeyTermSrv,
            REG_TERMSRV_APPCOMPAT,
            NULL,
            &dwValueType,
            (LPBYTE) &dwRegValue,
            &cbValue);
    if (lReturn == ERROR_SUCCESS) {
        g_fAppCompat = (BOOL)dwRegValue;
    }

    //
    // Get the product version
    //
    memset( &VersionInfo, 0, sizeof( OSVERSIONINFO ) );
    VersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    if (GetVersionEx(&VersionInfo)) {
        wsprintf( g_wszProductVersion, L"%d.%d",
                  VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion );
    }
    else {
        TRACE((hTrace, TC_ICASRV, TT_ERROR, "LicenseModeInit: GetVersionEx "
                "failed: 0x%x\n", GetLastError()));
    }
}

//
// Get Safeboot option, code modified from ds\security\gina\winlogon\aenrlhlp.c
//
BOOL WINAPI 
IsSafeBootWithNetwork()
{
    DWORD   dwSafeBoot = 0;
    DWORD   cbSafeBoot = sizeof(dwSafeBoot);
    DWORD   dwType = 0;

    HKEY    hKeySafeBoot = NULL;

    if(ERROR_SUCCESS == RegOpenKeyW(
                              HKEY_LOCAL_MACHINE,
                              L"system\\currentcontrolset\\control\\safeboot\\option",
                              &hKeySafeBoot))
    {
        // we did in fact boot under safeboot control
        if(ERROR_SUCCESS != RegQueryValueExW(
                                    hKeySafeBoot,
                                    L"OptionValue",
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwSafeBoot,
                                    &cbSafeBoot))
        {
            dwSafeBoot = 0;
        }

        if(hKeySafeBoot)
            RegCloseKey(hKeySafeBoot);
    }

    

    return ( SAFEBOOT_NETWORK == dwSafeBoot );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\shadow.c ===
/*************************************************************************
*
* shadow.c
*
* Citrix routines for supporting shadowing
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

#include <rpc.h>
#include <winsock.h>
#include <wincrypt.h>

#include "conntfy.h"
#define SECURITY_WIN32
#include <security.h>

// the highest required size for RDP is 431
#define MODULE_SIZE 512 

typedef struct _SHADOW_PARMS {
    BOOLEAN ShadowerIsHelpSession;  //  True if the shadow target is being
                                    //   shadowed in a Remote Assistance
                                    //   scenario.
    ULONG ClientLogonId;
    ULONG ClientShadowId;
    PWSTR pTargetServerName;
    ULONG TargetLogonId;
    WINSTATIONCONFIG2 Config;
    ICA_STACK_ADDRESS Address;
    PVOID pModuleData;
    ULONG ModuleDataLength;
    PVOID pThinwireData;
    ULONG ThinwireDataLength;
    HANDLE ImpersonationToken;
    WCHAR ClientName[DOMAIN_LENGTH+USERNAME_LENGTH+4];
    BOOL fResetShadowMode;
} SHADOW_PARMS, *PSHADOW_PARMS;

/*
 * External procedures defined
 */
NTSTATUS WinStationShadowWorker( ULONG, PWSTR, ULONG, ULONG, BYTE, USHORT );
NTSTATUS WinStationShadowTargetSetupWorker( BOOL, ULONG );
NTSTATUS WinStationShadowTargetWorker( BOOLEAN, BOOL, ULONG, PWINSTATIONCONFIG2, PICA_STACK_ADDRESS,
                                       PVOID, ULONG, PVOID, ULONG, PVOID);
NTSTATUS WinStationStopAllShadows( PWINSTATION );

BOOLEAN WINAPI
_WinStationShadowTargetSetup(
    HANDLE hServer,
    ULONG LogonId
    );

NTSTATUS WINAPI
_WinStationShadowTarget(
    HANDLE hServer,
    ULONG LogonId,
    PWINSTATIONCONFIG2 pConfig,
    PICA_STACK_ADDRESS pAddress,
    PVOID pModuleData,
    ULONG ModuleDataLength,
    PVOID pThinwireData,
    ULONG ThinwireDataLength,
    PVOID pClientName,
    ULONG ClientNameLength
    );

NTSTATUS
WinStationWinerrorToNtStatus(ULONG ulWinError);

/*
 * Internal procedures defined
 */
NTSTATUS _CreateShadowAddress( ULONG, PWINSTATIONCONFIG2, PWSTR, ULONG,
                               PICA_STACK_ADDRESS, PICA_STACK_ADDRESS );
NTSTATUS _WinStationShadowTargetThread( PVOID );

NTSTATUS
_CheckShadowLoop(
    IN ULONG ClientLogonId,
    IN PWSTR pTargetServerName,
    IN ULONG TargetLogonId
    );

/*
 * External procedures used.
 */
NTSTATUS RpcCheckClientAccess( PWINSTATION, ACCESS_MASK, BOOLEAN );

NTSTATUS RpcGetUserSID( BOOLEAN AlreadyImpersonating, PSID* ppSid );

NTSTATUS WinStationDoDisconnect( PWINSTATION, PRECONNECT_INFO, BOOLEAN bSyncNotify );

NTSTATUS xxxWinStationQueryInformation(ULONG, WINSTATIONINFOCLASS,
        PVOID, ULONG, PULONG);

BOOL GetSalemOutbufCount(PDWORD pdwValue);

ULONG UniqueShadowId = 0;

extern WCHAR g_DigProductId[CLIENT_PRODUCT_ID_LENGTH];

/*****************************************************************************
 *
 *  WinStationShadowWorker
 *
 *   Start a Winstation shadow operation
 *
 * ENTRY:
 *   ClientLogonId (input)
 *     client of the shadow
 *   pTargetServerName (input)
 *     target server name
 *   TargetLogonId (input)
 *     target login id (where the app is running)
 *   HotkeyVk (input)
 *     virtual key to press to stop shadow
 *   HotkeyModifiers (input)
 *     virtual modifer to press to stop shadow (i.e. shift, control)
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationShadowWorker(
    IN ULONG ClientLogonId,
    IN PWSTR pTargetServerName,
    IN ULONG ulTargetServerNameLength,
    IN ULONG TargetLogonId,
    IN BYTE HotkeyVk,
    IN USHORT HotkeyModifiers
    )
{
    PWINSTATION pWinStation;
    ULONG Length;
    LONG rc;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE ClientToken;
    HANDLE ImpersonationToken;
    PVOID pModuleData;
    ULONG ModuleDataLength;
    PVOID pThinwireData;
    ULONG ThinwireDataLength;
    PWINSTATIONCONFIG2 pShadowConfig = NULL;
    ICA_STACK_ADDRESS ShadowAddress;
    ICA_STACK_ADDRESS RemoteShadowAddress;
    ICA_STACK_BROKEN Broken;
    ICA_STACK_HOTKEY Hotkey;
    WINSTATION_APIMSG msg;
    HANDLE hShadowThread;
    PSHADOW_PARMS pShadowParms;
    HANDLE hTargetThread;
    DWORD ThreadId;
    PVOID pEndpoint;
    ULONG EndpointLength;
    LARGE_INTEGER Timeout;
    LONG retry;
    NTSTATUS WaitStatus;
    NTSTATUS TargetStatus;
    NTSTATUS Status;
    int nFormattedlength;
    BOOL bShadowerHelpSession = FALSE;

    /* 
     * Allocate memory
     */
    pShadowConfig = MemAlloc(sizeof(WINSTATIONCONFIG2));
    if (pShadowConfig == NULL) {
        Status = STATUS_NO_MEMORY;
        return Status;
    }

    /*
     * If target server name is ourself, then clear the target name
     */

    if ( pTargetServerName ) {
        if ( *pTargetServerName ) {
            WCHAR ServerName[MAX_COMPUTERNAME_LENGTH+1];

            Length = MAX_COMPUTERNAME_LENGTH+1;
            GetComputerName( ServerName, &Length );
            if ( !_wcsicmp( ServerName, pTargetServerName ) )
                pTargetServerName = NULL;
        } else {
            pTargetServerName = NULL;
        }
    }


    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_ACCESS_DENIED;
        goto badsetup;
    }

    /*
     * If shadower is help session, we already disable screen saver on logon notify
     */
    
    bShadowerHelpSession = TSIsSessionHelpSession(pWinStation, NULL);

    //
    // Check that the shadower and the caller are the same
    //
    if (!bShadowerHelpSession) {
        PSID pClientSid;

        Status = RpcGetUserSID( TRUE, &pClientSid);

        if(!NT_SUCCESS(Status)) {
            goto badstate;
        }

        if (!RtlEqualSid(pClientSid, pWinStation->pUserSid)) {
            Status = STATUS_ACCESS_DENIED;
            MemFree(pClientSid);
            goto badstate;
        }

        MemFree(pClientSid);
    }

    // Release lock on winstation for remote call 
    // and WinStationShadowTargetSetupWorker(), both might take a while
    UnlockWinStation(pWinStation);


    /*
     * Verify the target logonid is valid, is currently shadowable,
     * and that the caller (client) has shadow access.
     */
    if ( pTargetServerName == NULL ) {

        Status = WinStationShadowTargetSetupWorker( bShadowerHelpSession, TargetLogonId );


    /*
     * Otherwise, open the remote targer server and call the shadow target API.
     */
    } else {
        HANDLE hServer;

        hServer = WinStationOpenServer( pTargetServerName );
        if ( hServer == NULL ) {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        } else {
            if (_WinStationShadowTargetSetup( hServer, TargetLogonId ) == FALSE) {
                Status = WinStationWinerrorToNtStatus(GetLastError());
            } else {
                Status = STATUS_SUCCESS;
            }
            WinStationCloseServer( hServer );
        }
    }

    // relock winstation.
    if( !RelockWinStation( pWinStation ) ) {
        Status = STATUS_CTX_CLOSE_PENDING;
        ReleaseWinStation( pWinStation );
        goto badsetup;
    }

    /*
     * Check the status of the setup call.
     */
    if ( !NT_SUCCESS( Status ) )
        goto badstate;

#if 0
    // SERVER B3 fix for OEM machine with same product ID.
    // we will need this call again.
    Status = _CheckShadowLoop( ClientLogonId, pTargetServerName, TargetLogonId);
    if ( !NT_SUCCESS( Status ))
       goto badstate;
#endif
 
    /*
     * If WinStation is not in the active state (connected and
     * a user is logged on), or there is no stack handle,
     * then deny the shadow request.
     */
    if ( pWinStation->State != State_Active ||
         pWinStation->hStack == NULL ) {
        Status = STATUS_CTX_SHADOW_INVALID;
        goto badstate;
    }

    /*
     * Allocate a unique shadow id for this request.
     * (This is used by the shadow target thread in order
     *  to synchronize the return status.)
     */
    pWinStation->ShadowId = InterlockedIncrement( &UniqueShadowId );

    /*
     * Set up shadow config structure to use Named Pipe transport driver
     */
    RtlZeroMemory( pShadowConfig, sizeof(WINSTATIONCONFIG2) );
    wcscpy( pShadowConfig->Pd[0].Create.PdName, L"namedpipe" );
    pShadowConfig->Pd[0].Create.SdClass = SdNetwork;
    wcscpy( pShadowConfig->Pd[0].Create.PdDLL, L"tdpipe" );
    pShadowConfig->Pd[0].Create.PdFlag =
        PD_TRANSPORT | PD_CONNECTION | PD_FRAME | PD_RELIABLE;

    pShadowConfig->Pd[0].Create.OutBufLength = 530;
    pShadowConfig->Pd[0].Create.OutBufCount = 6;
    //
    //344175    Mouse buffer size needs to be increased
    //check if this is a help session, if it is read OutBufCount from registry
    //
    if (bShadowerHelpSession) {
        if (!GetSalemOutbufCount((PDWORD)&pShadowConfig->Pd[0].Create.OutBufCount)) {
            //
            //set the default outbuf count to 25
            //we don't want any low water mark for help sessions
            //
            pShadowConfig->Pd[0].Create.OutBufCount = 25;
        }
        
        pShadowConfig->Pd[0].Create.PdFlag |= PD_NOLOW_WATERMARK; //no low water mark
    }

    pShadowConfig->Pd[0].Create.OutBufDelay = 0;
    pShadowConfig->Pd[0].Params.SdClass = SdNetwork;
    pShadowConfig->Pd[1].Create.SdClass = SdNone;

    /*
     * Use same WD as shadowing WinStation
     */
    pShadowConfig->Wd = pWinStation->Config.Wd;

    /*
     * Create a shadow address based on the config Pd[0] type.
     */
    Status = _CreateShadowAddress( pWinStation->ShadowId, pShadowConfig,
                                   pTargetServerName,
                                   ulTargetServerNameLength,
                                   &ShadowAddress, &RemoteShadowAddress );

    if (!NT_SUCCESS(Status)) {
        goto badAddress;
    }

    /*
     * Now impersonate the client and duplicate the impersonation token
     * so we can hand it off to the thread doing the target side work.
     */

    /*
     * Duplicate our impersonation token to allow the shadow
     * target thread to use it.
     */
    Status = NtOpenThreadToken( NtCurrentThread(),
                                TOKEN_ALL_ACCESS,
                                FALSE,
                                &ClientToken );

    if (!NT_SUCCESS(Status)) {
        goto badtoken;
    }


    InitializeObjectAttributes( &ObjA, NULL, 0L, NULL, NULL );

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjA.SecurityQualityOfService = &SecurityQualityOfService;
    Status = NtDuplicateToken( ClientToken,
                               TOKEN_IMPERSONATE,
                               &ObjA,
                               FALSE,
                               TokenImpersonation,
                               &ImpersonationToken );

    NtClose( ClientToken );

    if (!NT_SUCCESS(Status)) {
        goto badtoken;
    }

    /*
     * Query client module data
     */

    pModuleData = MemAlloc( MODULE_SIZE );
    if ( !pModuleData ) {
        Status = STATUS_NO_MEMORY;
        goto badwddata;
    }

    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hStack,
                                IOCTL_ICA_STACK_QUERY_MODULE_DATA,
                                NULL,
                                0,
                                pModuleData,
                                MODULE_SIZE,
                                &ModuleDataLength );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( Status == STATUS_BUFFER_TOO_SMALL ) {

        MemFree( pModuleData );
        pModuleData = MemAlloc( ModuleDataLength );
        if ( !pModuleData ) {
            Status = STATUS_NO_MEMORY;
            goto badwddata;
        }

        //  Check for availability
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxIcaStackIoControl ) {

            Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                    pWinStation->pWsxContext,
                                    pWinStation->hIca,
                                    pWinStation->hStack,
                                    IOCTL_ICA_STACK_QUERY_MODULE_DATA,
                                    NULL,
                                    0,
                                    pModuleData,
                                    ModuleDataLength,
                                    &ModuleDataLength );
        }
        else {
            Status = STATUS_CTX_SHADOW_INVALID;
        }
    }

    if ( !NT_SUCCESS( Status ) ) {
        goto badwddata;
    }

    /*
     * Query thinwire module data
     */
    pThinwireData = MemAlloc( MODULE_SIZE );
    if ( !pThinwireData ) {
        Status = STATUS_NO_MEMORY;
        goto badthinwiredata;
    }

    Status = IcaChannelIoControl( pWinStation->hIcaThinwireChannel,
                                  IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA,
                                  NULL,
                                  0,
                                  pThinwireData,
                                  MODULE_SIZE,
                                  &ThinwireDataLength );
    if ( Status == STATUS_BUFFER_TOO_SMALL ) {

        MemFree( pThinwireData );
        pThinwireData = MemAlloc( ThinwireDataLength );
        if ( !pThinwireData ) {
            Status = STATUS_NO_MEMORY;
            goto badthinwiredata;
        }

        Status = IcaChannelIoControl( pWinStation->hIcaThinwireChannel,
                                      IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA,
                                      NULL,
                                      0,
                                      pThinwireData,
                                      ThinwireDataLength,
                                      &ThinwireDataLength );
    }

    if ( !NT_SUCCESS( Status ) ) {
        goto badthinwiredata;
    }

    /*
     * Create the local passthru stack
     */
    Status = IcaStackOpen( pWinStation->hIca, Stack_Passthru,
                           (PROC)WsxStackIoControl, pWinStation,
                           &pWinStation->hPassthruStack );
    if ( !NT_SUCCESS( Status ) )
        goto badstackopen;

#ifdef notdef
    /*
     * Create the client endpoint.
     * This call will return the ICA_STACK_ADDRESS we bound to,
     * so we can pass it on to the shadow target routine.
     */
    Status = IcaStackCreateShadowEndpoint( pWinStation->hPassthruStack,
                                           pWinStation->ListenName,
                                           pShadowConfig,
                                           &ShadowAddress,
                                           NULL );
    if ( !NT_SUCCESS( Status ) )
        goto badshadowendpoint;
#endif

    /*
     * Create stack broken event and register it
     */
    Status = NtCreateEvent( &pWinStation->ShadowBrokenEvent, EVENT_ALL_ACCESS,
                            NULL, NotificationEvent, FALSE );
    if ( !NT_SUCCESS( Status ) )
        goto badevent;
    Broken.BrokenEvent = pWinStation->ShadowBrokenEvent;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: BrokenEvent(%ld) = %p\n",
          pWinStation->LogonId, pWinStation->ShadowBrokenEvent));


    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hPassthruStack,
                                IOCTL_ICA_STACK_REGISTER_BROKEN,
                                &Broken,
                                sizeof(Broken),
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS(Status) )
        goto badbroken;

    /*
     * Register hotkey
     */
    Hotkey.HotkeyVk        = HotkeyVk;
    Hotkey.HotkeyModifiers = HotkeyModifiers;

    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hStack,
                                IOCTL_ICA_STACK_REGISTER_HOTKEY,
                                &Hotkey,
                                sizeof(Hotkey),
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS(Status) )
        goto badhotkey;

    /*
     * Before we enable passthru mode, change the WinStation state
     */
    pWinStation->State = State_Shadow;
    NotifySystemEvent( WEVENT_STATECHANGE );

    /*
     * Tell win32k about passthru mode being enabled
     */
    msg.ApiNumber = SMWinStationPassthruEnable;
    Status = SendWinStationCommand( pWinStation, &msg, 60 );
    if ( !NT_SUCCESS( Status ) )
        goto badpassthru;

    /*
     * Allocate a SHADOW_PARMS struct to pass to the target thread
     */
    pShadowParms = MemAlloc( sizeof(SHADOW_PARMS) );
    if ( !pShadowParms ) {
        Status = STATUS_NO_MEMORY;
        goto badshadowparms;
    }

    /*
     * Create a thread to load the target shadow stack
     */
    pShadowParms->fResetShadowMode   = bShadowerHelpSession;    // Only reset if client is HelpAssistant session
    pShadowParms->ShadowerIsHelpSession = bShadowerHelpSession ? TRUE : FALSE;   
    pShadowParms->ClientLogonId         = ClientLogonId;
    pShadowParms->ClientShadowId        = pWinStation->ShadowId;
    pShadowParms->pTargetServerName     = pTargetServerName;
    pShadowParms->TargetLogonId         = TargetLogonId;
    pShadowParms->Config                = *pShadowConfig;
    pShadowParms->Address               = ShadowAddress;
    pShadowParms->pModuleData           = pModuleData;
    pShadowParms->ModuleDataLength      = ModuleDataLength;
    pShadowParms->pThinwireData         = pThinwireData;
    pShadowParms->ThinwireDataLength    = ThinwireDataLength;
    pShadowParms->ImpersonationToken    = ImpersonationToken;

    nFormattedlength = _snwprintf(pShadowParms->ClientName,
            sizeof(pShadowParms->ClientName) / sizeof(WCHAR),
            L"%s\\%s", pWinStation->Domain, pWinStation->UserName);

    if (nFormattedlength < 0 || nFormattedlength ==
            sizeof(pShadowParms->ClientName) / sizeof(WCHAR)) {
        Status = STATUS_INVALID_PARAMETER;
        goto badClientName;
    }

    pWinStation->ShadowTargetStatus = 0;
    hTargetThread = CreateThread( NULL,
            0,
            (LPTHREAD_START_ROUTINE)_WinStationShadowTargetThread,
            pShadowParms,
            THREAD_SET_INFORMATION,
            &ThreadId );
    if ( hTargetThread == NULL ){
        Status = STATUS_NO_MEMORY;
        goto badthread;
    }
    pModuleData = NULL;                 // Target thread will free
    pThinwireData = NULL;               // Target thread will free
    ImpersonationToken = NULL;          // Target thread will close
    pShadowParms = NULL;                // Target thread will free

    /*
     * Allocate an endpoint buffer
     */
    EndpointLength = MODULE_SIZE;
    pEndpoint = MemAlloc( MODULE_SIZE );
    if ( !pEndpoint ) {
        Status = STATUS_NO_MEMORY;
        goto badmalloc;
    }

    /*
     * Unlock WinStation while we try to connect to the shadow target
     */
    UnlockWinStation( pWinStation );

    /*
     *  Wait for connection from the shadow target
     *
     *  We must do this in a loop since we don't know how long it
     *  will take the target side thread to get to the corresponding
     *  IcaStackConnectionWait() call.  In between calls, we delay for
     *  1 second, but break out if the ShadowBrokenEvent gets triggered.
     */
    for ( retry = 0; retry < 35; retry++ ) {
        ULONG ReturnedLength;


        Status = IcaStackConnectionRequest( pWinStation->hPassthruStack,
                                         pWinStation->ListenName,
                                         pShadowConfig,
                                         &RemoteShadowAddress,
                                         pEndpoint,
                                         EndpointLength,
                                         &ReturnedLength );
        if ( Status == STATUS_BUFFER_TOO_SMALL ) {
            MemFree( pEndpoint );
            pEndpoint = MemAlloc( ReturnedLength );
            if ( !pEndpoint ) {
                Status = STATUS_NO_MEMORY;
                break;
            }
            EndpointLength = ReturnedLength;
            Status = IcaStackConnectionRequest( pWinStation->hPassthruStack,
                                                pWinStation->ListenName,
                                                pShadowConfig,
                                                &RemoteShadowAddress,
                                                pEndpoint,
                                                EndpointLength,
                                                &ReturnedLength );
        }
        if ( Status != STATUS_OBJECT_NAME_NOT_FOUND )
            break;
        Timeout = RtlEnlargedIntegerMultiply( 1000, -10000 );
        WaitStatus = NtWaitForSingleObject( pWinStation->ShadowBrokenEvent, FALSE, &Timeout );
        if ( WaitStatus != STATUS_TIMEOUT )
            break;
        
        /*
         * If the shadow has already completed, we don't need to continue 
         * trying to initiate it
         */
        if (pWinStation->ShadowTargetStatus)
        {
           break;
        }
    }

    /*
     * Now relock the WinStation
     */
    RelockWinStation( pWinStation );

    /*
     * Check the status from the wait for connection
     */
    if ( !NT_SUCCESS( Status ) ) {
        // The pipe disconnected before the worker thread can set an error
        // code.  Wait for worker thread to set error code.
        if ( Status == STATUS_PIPE_DISCONNECTED ) {
            UnlockWinStation( pWinStation );
            Timeout = RtlEnlargedIntegerMultiply( 10000, -10000 );
            WaitStatus = NtWaitForSingleObject( hTargetThread,
                                                FALSE, &Timeout );
            RelockWinStation( pWinStation );
        }
        if ( pWinStation->ShadowTargetStatus ) {
            Status = pWinStation->ShadowTargetStatus;
        }
        goto badconnect;
    }

#ifdef notdef
    /*
     * Now accept the shadow target connection
     */
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hPassthruStack,
                                IOCTL_ICA_STACK_OPEN_ENDPOINT,
                                pEndpoint,
                                EndpointLength,
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS( Status ) )
        goto badaccept;
#endif

    /*
     * Enable I/O for the passthru stack
     */
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hPassthruStack,
                                IOCTL_ICA_STACK_ENABLE_IO,
                                NULL,
                                0,
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS(Status) )
        goto badenableio;

    /*
     * Since we don't do the stack query for a shadow stack,
     * simply call an ioctl to mark the stack as connected now.
     */
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hPassthruStack,
                                IOCTL_ICA_STACK_SET_CONNECTED,
                                NULL,
                                0,
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS( Status ) )
        goto badsetconnect;

    /*
     * Wait for shadow broken event to be triggered
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Waiting for BrokenEvent(%ld) = %p\n",
      pWinStation->LogonId, pWinStation->ShadowBrokenEvent));    

    if( !bShadowerHelpSession ) {
        /*
         * Notify WinLogon shadow Started.
         */
        msg.ApiNumber = SMWinStationNotify;
        msg.WaitForReply = FALSE;
        msg.u.DoNotify.NotifyEvent = WinStation_Notify_DisableScrnSaver;
        Status = SendWinStationCommand( pWinStation, &msg, 0 );

        //
        // Not critical, just performance issue
        //
        ASSERT( NT_SUCCESS( Status ) );
    }    

    UnlockWinStation( pWinStation );



    Status = NtWaitForSingleObject( pWinStation->ShadowBrokenEvent, FALSE, NULL );


    RelockWinStation( pWinStation );

    if( !bShadowerHelpSession ) {

        /*
         * Notify WinLogon shadow Ended.
         */
        msg.ApiNumber = SMWinStationNotify;
        msg.WaitForReply = FALSE;
        msg.u.DoNotify.NotifyEvent = WinStation_Notify_EnableScrnSaver;
        Status = SendWinStationCommand( pWinStation, &msg, 0 );

        //
        // Not critical, just performance issue
        //
        ASSERT( NT_SUCCESS( Status ) );
    }

    /*
     * Disable I/O for the passthru stack
     */
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hPassthruStack,
                                IOCTL_ICA_STACK_DISABLE_IO,
                                NULL,
                                0,
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    ASSERT( NT_SUCCESS( Status ) );

    /*
     * Tell win32k about passthru mode being disabled
     */
    msg.ApiNumber = SMWinStationPassthruDisable;
    Status = SendWinStationCommand( pWinStation, &msg, 60 );
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Passthru mode disabled\n"));

    //ASSERT( NT_SUCCESS( Status ) );

    /*
     * Restore WinStation state
     */
    if ( pWinStation->State == State_Shadow ) {
        pWinStation->State = State_Active;
        NotifySystemEvent( WEVENT_STATECHANGE );
    }

    /*
     * Turn off hotkey registration
     */
    RtlZeroMemory( &Hotkey, sizeof(Hotkey) );
    if ( pWinStation->hStack ) {
        //  Check for availability
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxIcaStackIoControl ) {

            Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                    pWinStation->pWsxContext,
                                    pWinStation->hIca,
                                    pWinStation->hStack,
                                    IOCTL_ICA_STACK_REGISTER_HOTKEY,
                                    &Hotkey,
                                    sizeof(Hotkey),
                                    NULL,
                                    0,
                                    NULL );
        }
        else {
            Status = STATUS_CTX_SHADOW_INVALID;
        }

        ASSERT( NT_SUCCESS( Status ) );
    }

    /*
     * Close broken event and passthru stack
     */
    NtClose( pWinStation->ShadowBrokenEvent );
    pWinStation->ShadowBrokenEvent = NULL;

    if ( pWinStation->hPassthruStack ) {
        IcaStackConnectionClose( pWinStation->hPassthruStack,
                                 pShadowConfig,
                                 pEndpoint,
                                 EndpointLength );

        IcaStackClose( pWinStation->hPassthruStack );
        pWinStation->hPassthruStack = NULL;
    }

    MemFree( pEndpoint );

    /*
     * Now give target thread a chance to exit. If it fails to exit within the
     * allotted time period we just allow it to orphan and close its handle so
     * it will be destroyed when it finally does exit. This can occur in
     * highly loaded stress situations and is not part of normal execution.
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Waiting for target thread to exit\n"));
    UnlockWinStation( pWinStation );
    Timeout = RtlEnlargedIntegerMultiply( 5000, -10000 );
    WaitStatus = NtWaitForSingleObject( hTargetThread, FALSE, &Timeout );
    NtClose( hTargetThread );
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Target thread exit status: %lx\n",
           WaitStatus));

    /*
     * Relock WinStation and get target thread exit status
     */
    RelockWinStation( pWinStation );
    TargetStatus = pWinStation->ShadowTargetStatus;

    /*
     * If there is a shadow done event, then signal the waiter now
     */
    if ( pWinStation->ShadowDoneEvent )
        SetEvent( pWinStation->ShadowDoneEvent );

    /*
     * Release winstation
     */
    ReleaseWinStation( pWinStation );

    if (pShadowConfig != NULL) {
        MemFree(pShadowConfig);
        pShadowConfig = NULL;
    }
    return( TargetStatus );

/*=============================================================================
==   Error returns
=============================================================================*/

badsetconnect:
    if ( pWinStation->hPassthruStack ) {
        //  Check for availability
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxIcaStackIoControl ) {

            (void) pWinStation->pWsx->pWsxIcaStackIoControl(
                           pWinStation->pWsxContext,
                           pWinStation->hIca,
                           pWinStation->hPassthruStack,
                           IOCTL_ICA_STACK_DISABLE_IO,
                           NULL,
                           0,
                           NULL,
                           0,
                           NULL );
        }
    }

badenableio:

#ifdef notdef
badaccept:
#endif

    if ( pWinStation->hPassthruStack ) {
        IcaStackConnectionClose( pWinStation->hPassthruStack,
                                 pShadowConfig,
                                 pEndpoint,
                                 EndpointLength );
    }

badconnect:
    if ( pEndpoint )
        MemFree( pEndpoint );

badmalloc:
    UnlockWinStation( pWinStation );
    //Timeout = RtlEnlargedIntegerMultiply( 5000, -10000 );
    //WaitStatus = NtWaitForSingleObject( hTargetThread, FALSE, &Timeout );
    //ASSERT( WaitStatus == STATUS_SUCCESS );
    NtClose( hTargetThread );

    /*
     * Relock WinStation and get target thread exit status
     */
    RelockWinStation( pWinStation );
    if ( pWinStation->ShadowTargetStatus )
        Status = pWinStation->ShadowTargetStatus;

badthread:
badClientName:
    if ( pShadowParms )
        MemFree( pShadowParms );

badshadowparms:
    msg.ApiNumber = SMWinStationPassthruDisable;
    SendWinStationCommand( pWinStation, &msg, 60 );

badpassthru:
    if ( pWinStation->State == State_Shadow ) {
        pWinStation->State = State_Active;
        NotifySystemEvent( WEVENT_STATECHANGE );
    }
    RtlZeroMemory( &Hotkey, sizeof(Hotkey) );
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl && pWinStation->hStack) {

        (void) pWinStation->pWsx->pWsxIcaStackIoControl(
                       pWinStation->pWsxContext,
                       pWinStation->hIca,
                       pWinStation->hStack,
                       IOCTL_ICA_STACK_REGISTER_HOTKEY,
                       &Hotkey,
                       sizeof(Hotkey),
                       NULL,
                       0,
                       NULL );
    }

badhotkey:
badbroken:
    NtClose( pWinStation->ShadowBrokenEvent );
    pWinStation->ShadowBrokenEvent = NULL;

badevent:

#ifdef notdef
badshadowendpoint:
#endif

    if ( pWinStation->hPassthruStack ) {
        IcaStackClose( pWinStation->hPassthruStack );
        pWinStation->hPassthruStack = NULL;
    }

badstackopen:
badthinwiredata:
    if ( pThinwireData )
        MemFree( pThinwireData );
badwddata:
    if ( pModuleData )
        MemFree( pModuleData );
    if ( ImpersonationToken )
        NtClose( ImpersonationToken );
badAddress:
badtoken:
badstate:

    /*
     * If there is a shadow done event, then signal the waiter now
     */
    if ( pWinStation->ShadowDoneEvent )
        SetEvent( pWinStation->ShadowDoneEvent );

    ReleaseWinStation( pWinStation );

badsetup:

    if (pShadowConfig != NULL) {
        MemFree(pShadowConfig);
        pShadowConfig = NULL;
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationShadowWorker, Status=0x%x\n", Status ));
    return( Status );
}


/*****************************************************************************
 *
 *  WinStationShadowTargetSetupWorker
 *
 *   Setup the target side of a Winstation shadow operation
 *
 * ENTRY:
 *   LogonId (input)
 *      client of the shadow
 *
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationShadowTargetSetupWorker(
    IN BOOL ShadowHelpSession,
    IN ULONG TargetLogonId )
{
    PWINSTATION pWinStation;
    NTSTATUS Status;

    /*
     * Find and lock target WinStation
     */
    pWinStation = FindWinStationById( TargetLogonId, FALSE );
    if ( pWinStation == NULL ) {
        return( STATUS_ACCESS_DENIED );
    }

    /*
     * Check the target WinStation state.  We only allow shadow of
     * active (connected, logged on) WinStations.
     */
    if ( pWinStation->State != State_Active ) {
        Status = STATUS_CTX_SHADOW_INVALID;
        goto shadowinvalid;
    }

    /*
     * Stop attempts to shadow an RDP session that is already shadowed.
     * RDP stacks don't support that yet.
     * TODO: Add support for multiple RDP shadows.
     */
    if ((pWinStation->Config).Wd.WdFlag & WDF_TSHARE)
    {
        if ( !IsListEmpty( &pWinStation->ShadowHead ) ) {
            Status = STATUS_CTX_SHADOW_DENIED;
            goto shadowdenied;
        }
    }

    // Give RA session exclusive right to shadow all session
    if( !ShadowHelpSession )
    {
        /*
         * Verify that client has WINSTATION_SHADOW access to the target WINSTATION
         */
        Status = RpcCheckClientAccess( pWinStation, WINSTATION_SHADOW, TRUE );
        if ( !NT_SUCCESS( Status ) )
            goto shadowinvalid;
    }

    ReleaseWinStation( pWinStation );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

shadowinvalid:
shadowdenied:
    ReleaseWinStation( pWinStation );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationShadowTargetSetupWorker, Status=0x%x\n", Status ));
    return( Status );
}





/*****************************************************************************
 *
 *  WinStationShadowTargetWorker
 *
 *   Start the target side of a Winstation shadow operation
 *
 * ENTRY:
 *   fResetShadowSetting(input)
 *      Reset session shadow class back to original value
 *   ShadowerIsHelpSession
 *      true if the shadowing session is logged in as help assistant.
 *   LogonId (input)
 *      client of the shadow
 *   pConfig (input)
 *      pointer to WinStation config data (for shadow stack)
 *   pAddress (input)
 *      address of shadow client
 *   pModuleData (input)
 *      pointer to client module data
 *   ModuleDataLength (input)
 *      length of client module data
 *   pThinwireData (input)
 *      pointer to thinwire module data
 *   ThinwireDataLength (input)
 *      length of thinwire module data
 *   pClientName (input)
 *      pointer to client name string (domain/username)
 *
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/


NTSTATUS
WinStationShadowTargetWorker(
    IN BOOLEAN ShadowerIsHelpSession,
    IN BOOL fResetShadowSetting,
    IN ULONG TargetLogonId,
    IN PWINSTATIONCONFIG2 pConfig,
    IN PICA_STACK_ADDRESS pAddress,
    IN PVOID pModuleData,
    IN ULONG ModuleDataLength,
    IN PVOID pThinwireData,
    IN ULONG ThinwireDataLength,
    IN PVOID pClientName)

{
    PWINSTATION pWinStation;
    WINSTATION_APIMSG msg;
    ULONG ShadowResponse;
    OBJECT_ATTRIBUTES ObjA;
    PSHADOW_INFO pShadow;
    ICA_STACK_BROKEN Broken;
    NTSTATUS Status, ShadowStatus;
    BOOLEAN fConcurrentLicense = FALSE;
    DWORD ProtocolMask;
    BOOLEAN fChainedDD = FALSE;
    int cchTitle, cchMessage;
    PVOID pRealUserName = pClientName; 
    WCHAR userName[DOMAIN_LENGTH + USERNAME_LENGTH + 4];
    
    ULONG shadowIoctlCode;

    HANDLE hIca;
    HANDLE hStack;
    HANDLE hIcaBeepChannel = NULL;
    HANDLE hIcaThinwireChannel = NULL;
    PWSEXTENSION pWsx;
    PVOID pWsxContext;

    BOOL bResetStateFlags = FALSE;

    HANDLE ChannelHandle;
    BOOLEAN fOwnsConsoleTerminal = FALSE;

    /*
     * Find and lock target WinStation
     */
    pWinStation = FindWinStationById( TargetLogonId, FALSE );
    if ( pWinStation == NULL ) {

        Status = STATUS_ACCESS_DENIED;
        goto done;
    }

    //
    // save current the console winstation parameters and
    // set them to the global values.
    //

    if ((fOwnsConsoleTerminal = pWinStation->fOwnsConsoleTerminal)) {
        hIca = pWinStation->hIca;
        hStack = pWinStation->hStack;
        pWsx = pWinStation->pWsx;
        pWsxContext = pWinStation->pWsxContext;
        hIcaBeepChannel = pWinStation->hIcaBeepChannel;
        hIcaThinwireChannel = pWinStation->hIcaThinwireChannel;
    }

    /*
     * Check the target WinStation state.  We only allow shadow of
     * active (connected, logged on) WinStations.
     */
    if ( pWinStation->State != State_Active ) {


        // the line below is the fix for bug #230870
        Status = STATUS_CTX_SHADOW_INVALID;
        goto shadowinvalid;
    }

    /*
     * Check if we are shadowing the same protocol winstation or not.
     * But let any shadow happen if it's the console and it isn't being shadowed.
     */
    if (!(pWinStation->fOwnsConsoleTerminal && IsListEmpty( &pWinStation->ShadowHead ))) {

        ProtocolMask=WDF_ICA|WDF_TSHARE;

        if (((pConfig->Wd).WdFlag & ProtocolMask) != ((pWinStation->Config).Wd.WdFlag & ProtocolMask))
        {
            Status=STATUS_CTX_SHADOW_INVALID;
            goto shadowinvalid;
        }
    }

    //
    // Stop attempts to shadow an RDP session that is already shadowed.
    // RDP stacks don't support that yet.
    //
    if( pWinStation->fOwnsConsoleTerminal || ((pWinStation->Config).Wd.WdFlag & WDF_TSHARE ))
    {
        if ( pWinStation->StateFlags & WSF_ST_SHADOW ) {
            //
            // Bug 195616, we release winstation lock when
            // waiting for user to accept/deny shadow request,
            // another thread can come in and weird thing can
            // happen
            Status = STATUS_CTX_SHADOW_DENIED;
            goto shadowdenied;
        }

        pWinStation->StateFlags |= WSF_ST_SHADOW;
        bResetStateFlags = TRUE;
    }

    // Give RA session exclusive right to shadow all session
    if( !ShadowerIsHelpSession )
    {
        ULONG userNameLength = sizeof(userName)/sizeof(userName[0]);    
        /*
         * Verify that client has WINSTATION_SHADOW access to the target WINSTATION
         */
        Status = RpcCheckClientAccess( pWinStation, WINSTATION_SHADOW, TRUE );
        if ( !NT_SUCCESS( Status ) )
            goto shadowdenied;

        //
        // Get the real user name.
        //
        if (GetUserNameEx(NameSamCompatible, userName, &userNameLength)) {
            pRealUserName = (PVOID)userName;
        }
        //
        // else, we will give the shadower the benefit of doubt.
        // We check the shadower's access anyway above.
        //
    }

    /*
     *  Check shadowing options
     */
    switch ( pWinStation->Config.Config.User.Shadow ) {
        WCHAR szTitle[32];
        WCHAR szMsg2[256];
        WCHAR ShadowMsg[256];
        NTSTATUS DelieveryStatus = STATUS_SUCCESS;;

        /*
         * If shadowing is disabled, then deny this request
         */
        case Shadow_Disable :

            Status = STATUS_CTX_SHADOW_DISABLED;
            goto shadowinvalid;
            break;

        /*
         * If one of the Notify shadow options is set,
         * then ask for permission from session being shadowed.
         * But deny the shadow if this WinStation is currently
         * disconnected (i.e. there is no user to answer the request).
         */
        case Shadow_EnableInputNotify :
        case Shadow_EnableNoInputNotify :

            if ( pWinStation->State == State_Disconnected ) {
                Status = STATUS_CTX_SHADOW_INVALID;
                goto shadowinvalid;
            }

            cchTitle = LoadString( hModuleWin, STR_CITRIX_SHADOW_TITLE, szTitle, sizeof(szTitle)/sizeof(WCHAR));

            cchMessage = LoadString( hModuleWin, STR_CITRIX_SHADOW_MSG_2, szMsg2, sizeof(szMsg2)/sizeof(WCHAR));

            if ((cchMessage == 0) || (cchMessage == sizeof(szMsg2)/sizeof(WCHAR))) {
                Status = STATUS_CTX_SHADOW_INVALID;
                goto shadowinvalid;
            }

            cchMessage = _snwprintf( ShadowMsg, sizeof(ShadowMsg)/sizeof(WCHAR), L" %s %s", pRealUserName, szMsg2 );

            if ((cchMessage <= 0) || (cchMessage == sizeof(ShadowMsg)/sizeof(WCHAR))) {
                Status = STATUS_CTX_SHADOW_INVALID;
                goto shadowinvalid;
            }

            /*
             * Send message and wait for reply
             */
            msg.u.SendMessage.pTitle = szTitle;
            msg.u.SendMessage.TitleLength = (cchTitle+1) * sizeof(WCHAR);
            msg.u.SendMessage.pMessage = ShadowMsg;
            msg.u.SendMessage.MessageLength = (cchMessage+1) * sizeof(WCHAR);
            msg.u.SendMessage.Style = MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION | MB_DEFAULT_DESKTOP_ONLY;
            msg.u.SendMessage.Timeout = 30;
            msg.u.SendMessage.DoNotWait = FALSE;
            msg.u.SendMessage.DoNotWaitForCorrectDesktop = TRUE;
            // since we going to wait for the message delievary, 
            // we need to know about status of message delievery, and the response
            // this is modified by IcaWaitReplyMessage
            msg.u.SendMessage.pStatus = &DelieveryStatus;  
            msg.u.SendMessage.pResponse = &ShadowResponse;

            msg.ApiNumber = SMWinStationDoMessage;
            


            /*
             *  Create wait event
             */
            InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
            Status = NtCreateEvent( &msg.u.SendMessage.hEvent, EVENT_ALL_ACCESS, &ObjA,
                                    NotificationEvent, FALSE );
            if ( !NT_SUCCESS(Status) ) {
                goto shadowinvalid;
            }

            /*
             *  Initialize response to IDTIMEOUT
             */
            ShadowResponse = IDTIMEOUT;

            /*
             * Tell the WinStation to display the message box
             */
            Status = SendWinStationCommand( pWinStation, &msg, 0 );

            /*
             *  Wait for response
             */
            if ( Status == STATUS_SUCCESS ) {
                TRACE((hTrace,TC_ICASRV,TT_API1, "WinStationSendMessage: wait for response\n" ));
                UnlockWinStation( pWinStation );
                Status = NtWaitForSingleObject( msg.u.SendMessage.hEvent, FALSE, NULL );
                if ( !RelockWinStation( pWinStation ) ) {
                    Status = STATUS_CTX_CLOSE_PENDING;
                } else {
                    Status = DelieveryStatus;
                }
                TRACE((hTrace,TC_ICASRV,TT_API1, "WinStationSendMessage: got response %u\n", ShadowResponse ));
                NtClose( msg.u.SendMessage.hEvent );
            }
            else
            {
                /* makarp; close the event in case of SendWinStationCommand failure as well. #182792 */
                NtClose( msg.u.SendMessage.hEvent );
            }

            if ( Status == STATUS_SUCCESS && ShadowResponse != IDYES )
                 Status = STATUS_CTX_SHADOW_DENIED;

            /*
             * Check again the target WinStation state as the user could logoff.
             * We only allow shadow of active (connected, logged on) WinStations.
             */
            if ( Status == STATUS_SUCCESS && pWinStation->State != State_Active ) {
                Status = STATUS_CTX_SHADOW_INVALID;
            }

            /*
             * Make sure we didn't switch from local to remote (or the other way arround)
             */

            if ( Status == STATUS_SUCCESS && (fOwnsConsoleTerminal != pWinStation->fOwnsConsoleTerminal) ) {
                Status = STATUS_CTX_SHADOW_INVALID;
            }
            

            if ( Status != STATUS_SUCCESS ) {
                goto shadowinvalid;
            }

            break;
    }

    /*
     * The shadow request is accepted: for the console session, we now need
     * to chain in the DD or there won't be much output to shadow
     */
    TRACE((hTrace,TC_ICASRV,TT_API3, "TERMSRV: Logon ID %ld\n",
                                                      pWinStation->LogonId ));

    /*
     * If the session is connected to the local console, we need to load
     * the chained shadow display driver before starting the shadoe sequence
     */

    if (pWinStation->fOwnsConsoleTerminal)
    {

        Status = ConsoleShadowStart( pWinStation, pConfig, pModuleData, ModuleDataLength );
        if (NT_SUCCESS(Status))
        {
            fChainedDD = TRUE;
            TRACE((hTrace,TC_ICASRV,TT_API3, "TERMSRV: success\n"));
        }
        else
        {
            TRACE((hTrace,TC_ICASRV,TT_API3, "TERMSRV: ConsoleConnect failed 0x%x\n", Status));
            goto shadowinvalid;
        
        }

    }

    /*
     * Allocate shadow data structure
     */
    pShadow = MemAlloc( sizeof(*pShadow) );
    if ( pShadow == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto shadowinvalid;
    }

    /*
     *  Create shadow stack
     */
    Status = IcaStackOpen( pWinStation->hIca, Stack_Shadow,
                           (PROC)WsxStackIoControl, pWinStation,
                           &pShadow->hStack );
    if ( !NT_SUCCESS(Status) )
        goto badopen;

    /*
     * Create stack broken event and register it
     */
    Status = NtCreateEvent( &pShadow->hBrokenEvent, EVENT_ALL_ACCESS,
                            NULL, NotificationEvent, FALSE );
    if ( !NT_SUCCESS( Status ) )
        goto badevent;
    Broken.BrokenEvent = pShadow->hBrokenEvent;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: BrokenEvent(%ld) = %p\n",
          pWinStation->LogonId, pShadow->hBrokenEvent));

    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pShadow->hStack,
                                IOCTL_ICA_STACK_REGISTER_BROKEN,
                                &Broken,
                                sizeof(Broken),
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS(Status) )
        goto badbroken;

    /*
     * Add the shadow structure to the shadow list for the WinStation
     */
    InsertTailList( &pWinStation->ShadowHead, &pShadow->Links );

    /*
     * Allocate an endpoint buffer
     */
    pShadow->pEndpoint = MemAlloc( MODULE_SIZE );
    if ( pShadow->pEndpoint == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto badendpoint;
    }

    /*
     * Unlock WinStation while we attempt to connect to the client
     * side of the shadow.
     */
    UnlockWinStation( pWinStation );

    /*
     *  Connect to client side of shadow
     */


    Status = IcaStackConnectionWait   ( pShadow->hStack,
                                        pWinStation->ListenName,
                                        pConfig,
                                        pAddress,
                                        pShadow->pEndpoint,
                                        MODULE_SIZE,
                                        &pShadow->EndpointLength );
    if ( Status == STATUS_BUFFER_TOO_SMALL ) {
        MemFree( pShadow->pEndpoint );
        pShadow->pEndpoint = MemAlloc( pShadow->EndpointLength );
        if ( pShadow->pEndpoint == NULL ) {
            Status = STATUS_NO_MEMORY;
            RelockWinStation( pWinStation );
            goto badendpoint;
        }
        Status = IcaStackConnectionWait   ( pShadow->hStack,
                                            pWinStation->ListenName,
                                            pConfig,
                                            pAddress,
                                            pShadow->pEndpoint,
                                            pShadow->EndpointLength,
                                            &pShadow->EndpointLength );
    }
    if ( !NT_SUCCESS(Status) ) {
        RelockWinStation( pWinStation );
        goto badconnect;
    }

    /*
     * Relock the WinStation.
     * If the WinStation is going away, then bail out.
     */
    if ( !RelockWinStation( pWinStation ) ) {
        Status = STATUS_CTX_CLOSE_PENDING;
        goto closing;
    }

    /*
     * Now accept the shadow target connection
     */
    //  Check for availability



    if (pWinStation->pWsx &&
            pWinStation->pWsx->pWsxIcaStackIoControl) {
        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                pWinStation->pWsxContext,
                pWinStation->hIca,
                pShadow->hStack,
                IOCTL_ICA_STACK_OPEN_ENDPOINT,
                pShadow->pEndpoint,
                pShadow->EndpointLength,
                NULL,
                0,
                NULL);
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }
    if (!NT_SUCCESS(Status))
        goto PostCreateConnection;

    /*
     * If user is configured to permit shadow input,
     * then enable shadow input on the keyboard/mouse channels,
     * if not permitting shadow input, disable keyboard/mouse
     * channels.
     */
    switch ( pWinStation->Config.Config.User.Shadow ) {

        case Shadow_EnableInputNotify :
        case Shadow_EnableInputNoNotify :

            shadowIoctlCode = IOCTL_ICA_CHANNEL_ENABLE_SHADOW;
            break;

        case Shadow_EnableNoInputNotify :
        case Shadow_EnableNoInputNoNotify :

            shadowIoctlCode = IOCTL_ICA_CHANNEL_DISABLE_SHADOW;
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
    }        
        
    if( !NT_SUCCESS(Status) )
        goto PostCreateConnection;
                
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Keyboard,
                             NULL,
                             &ChannelHandle );

    if( !NT_SUCCESS( Status ) ) 
        goto PostCreateConnection;

    Status = IcaChannelIoControl( ChannelHandle,
                                  shadowIoctlCode,
                                  NULL, 0, NULL, 0, NULL );
    ASSERT( NT_SUCCESS( Status ) );
    IcaChannelClose( ChannelHandle );

    if( !NT_SUCCESS( Status ) )
        goto PostCreateConnection;

    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Mouse,
                             NULL,
                             &ChannelHandle );
    if ( !NT_SUCCESS( Status ) ) 
        goto PostCreateConnection;

    Status = IcaChannelIoControl( ChannelHandle,
                                  shadowIoctlCode,
                                  NULL, 0, NULL, 0, NULL );
    ASSERT( NT_SUCCESS( Status ) );
    IcaChannelClose( ChannelHandle );

    if( !NT_SUCCESS( Status ) )
        goto PostCreateConnection;

    /*
     * Tell win32k about the pending shadow operation
     */

    msg.ApiNumber = SMWinStationShadowSetup;
    Status = SendWinStationCommand( pWinStation, &msg, 60 );
    if ( !NT_SUCCESS( Status ) )
        goto badsetup;

    /*
     * Since we don't do the stack query for a shadow stack,
     * simply call an ioctl to mark the stack as connected now.
     */
    //  Check for availability


    if (pWinStation->pWsx &&
            pWinStation->pWsx->pWsxIcaStackIoControl) {
        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                pWinStation->pWsxContext,
                pWinStation->hIca,
                pShadow->hStack,
                IOCTL_ICA_STACK_SET_CONNECTED,
                pModuleData,
                ModuleDataLength,
                NULL,
                0,
                NULL);
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if (!NT_SUCCESS(Status))
        goto badsetconnect;

    /*
     * Enable I/O for the shadow stack
     */
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pShadow->hStack,
                                IOCTL_ICA_STACK_ENABLE_IO,
                                NULL,
                                0,
                                NULL,
                                0,
                                NULL );

    }
    else {

        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS(Status) )
        goto badenableio;

    /*
     * If this is a help assistant scenario then notify the target winlogon (via Win32k)
     * that HA shadow is about to commence.
     */
    if (ShadowerIsHelpSession) {
        msg.ApiNumber = SMWinStationNotify;
        msg.WaitForReply = TRUE;
        msg.u.DoNotify.NotifyEvent = WinStation_Notify_HelpAssistantShadowStart;
        SendWinStationCommand( pWinStation, &msg, 60);
    }

    /*
     * Start shadowing
     */
    msg.ApiNumber = SMWinStationShadowStart;
    msg.u.ShadowStart.pThinwireData = pThinwireData;
    msg.u.ShadowStart.ThinwireDataLength = ThinwireDataLength;
    ShadowStatus = SendWinStationCommand( pWinStation, &msg, 60 );
    if ( NT_SUCCESS( ShadowStatus ) ) {

        //
        // Notify that a new shadow started on this session.
        // Note: on multi-shadow, test if it's the first shadower.
        //
        NotifyShadowChange( pWinStation, ShadowerIsHelpSession);

        /*
         * Wait for the shadow to be terminated
         */
        UnlockWinStation( pWinStation );

        if ( fChainedDD ) {
            HANDLE hEvents[2];

            hEvents[0] = pShadow->hBrokenEvent;
            hEvents[1] = pWinStation->ShadowDisplayChangeEvent;

            Status = NtWaitForMultipleObjects( 2, hEvents, WaitAny, FALSE, NULL );
        } else {
            NtWaitForSingleObject( pShadow->hBrokenEvent, FALSE, NULL );
        }
        RelockWinStation( pWinStation );

        if ( fChainedDD && (Status == WAIT_OBJECT_0 + 1) ) {

            // valid only if there's one shadower?
            NtResetEvent(pWinStation->ShadowDisplayChangeEvent, NULL);
            ShadowStatus = STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE;
        }

        /*
         * Stop shadowing
         */
        msg.ApiNumber = SMWinStationShadowStop;


        Status = SendWinStationCommand( pWinStation, &msg, 60 );

        ASSERT( NT_SUCCESS( Status ) );

        /*
         * Since SMWinStationShadowStart succeeded, store the
         * result from SMWinStationShadowStop.
         * Test if a mode change terminated the shadow since
         * in that case it needs to be reported.
         */
        if ( NT_SUCCESS( ShadowStatus ) ) {
            ShadowStatus = Status;
        }
    }

    /*
     * If this is a help assistant scenario then notify the target winlogon (via Win32k)
     * that HA shadow is done.
     */
    if (ShadowerIsHelpSession) {
        msg.ApiNumber = SMWinStationNotify;
        msg.WaitForReply = FALSE;
        msg.u.DoNotify.NotifyEvent = WinStation_Notify_HelpAssistantShadowFinish;
        SendWinStationCommand( pWinStation, &msg, 0);
    }

    /*
     * Disable I/O for the shadow stack
     */
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        (void) pWinStation->pWsx->pWsxIcaStackIoControl(
                              pWinStation->pWsxContext,
                              pWinStation->hIca,
                              pShadow->hStack,
                              IOCTL_ICA_STACK_DISABLE_IO,
                              NULL,
                              0,
                              NULL,
                              0,
                              NULL );
    }

    /*
     * Do final shadow cleanup
     */
    msg.ApiNumber = SMWinStationShadowCleanup;
    msg.u.ShadowCleanup.pThinwireData = pThinwireData;
    msg.u.ShadowCleanup.ThinwireDataLength = ThinwireDataLength;
    Status =  SendWinStationCommand( pWinStation, &msg, 60 );
    ASSERT( NT_SUCCESS( Status ) );

    /*
     * Normally, ShadowStatus indicates the success of the shadow
     * operation (or of the shadow terminate).  However, if
     * the shadow operation succeeded then we want to return the
     * result of the shadow cleanup instead.
     */
    if ( NT_SUCCESS(ShadowStatus) )
    {
        ShadowStatus = Status;
    }
   
    RemoveEntryList( &pShadow->Links );

    //
    // Notify that a new shadow stopped on this session.
    // It's important to do it here so that win32k could
    // update its internal state for the SM_REMOTECONTROL.
    // Note: on multi-shadow, test if it's the last shadower.
    //
    NotifyShadowChange( pWinStation, ShadowerIsHelpSession);

    IcaStackConnectionClose( pShadow->hStack, pConfig,
                             pShadow->pEndpoint, pShadow->EndpointLength );

    MemFree( pShadow->pEndpoint );

    NtClose( pShadow->hBrokenEvent );
    IcaStackClose( pShadow->hStack );

    MemFree( pShadow );

    /*
     * If there is a shadow done event and this was the last shadow,
     * then signal the waiter now.
     */
    if ( pWinStation->ShadowDoneEvent && IsListEmpty( &pWinStation->ShadowHead ) )
        SetEvent( pWinStation->ShadowDoneEvent );

    /*
     * For the console session, we now need to unchain the DD for
     * performance reasons.  Ignore this return code -- we don't need it and 
     * we also don't want to overwrite the value in Status.
     */
    if (fChainedDD == TRUE)
    {
        TRACE((hTrace,TC_ICASRV,TT_API3, "TERMSRV: unchain console DD\n"));
        pWinStation->Flags |= WSF_DISCONNECT;
        Status = ConsoleShadowStop( pWinStation );
        fResetShadowSetting = FALSE;

        /*
         * Normally, ShadowStatus indicates the success of the shadow
         * operation (or of the shadow terminate).  However, if
         * the shadow operation succeeded then we want to return the
         * result of the shadow cleanup instead.
         */
        if ( NT_SUCCESS(ShadowStatus) )
        {
            ShadowStatus = Status;
        }
   
        pWinStation->Flags &= ~WSF_DISCONNECT;
        fChainedDD = FALSE;
    }

    //
    // reset the console winstation parameters.
    //

    if (fOwnsConsoleTerminal) {
        pWinStation->hIca = hIca;
        pWinStation->hStack = hStack;
        pWinStation->pWsx = pWsx;
        pWinStation->pWsxContext = pWsxContext;
        pWinStation->hIcaBeepChannel = hIcaBeepChannel;
        pWinStation->hIcaThinwireChannel = hIcaThinwireChannel;

    }   
        
    if( fResetShadowSetting ) {
        // Console shadow already reset back to original value
        // can't do this in WinStationShadowWorker(), might run into
        // some timing problem.

        pWinStation->Config.Config.User.Shadow = pWinStation->OriginalShadowClass;
    }


    if( bResetStateFlags ) {
        pWinStation->StateFlags &= ~WSF_ST_SHADOW;
    }


    /*
     *  Unlock winstation
     */
    ReleaseWinStation( pWinStation );

    return( ShadowStatus );

/*=============================================================================
==   Error returns
=============================================================================*/

badenableio:
badsetconnect:
    msg.ApiNumber = SMWinStationShadowCleanup;
    msg.u.ShadowCleanup.pThinwireData = pThinwireData;
    msg.u.ShadowCleanup.ThinwireDataLength = ThinwireDataLength;
    SendWinStationCommand( pWinStation, &msg, 60 );

badsetup:
PostCreateConnection:
closing:
    IcaStackConnectionClose( pShadow->hStack, pConfig,
                             pShadow->pEndpoint, pShadow->EndpointLength );

badconnect:
    MemFree( pShadow->pEndpoint );

badendpoint:
    RemoveEntryList( &pShadow->Links );

badbroken:
    NtClose( pShadow->hBrokenEvent );

badevent:
    IcaStackClose( pShadow->hStack );

badopen:
    MemFree( pShadow );

shadowinvalid:
shadowdenied:
    /*
     * For the console session, we now need to unchain the DD for
     * performance reasons
     */
    if (fChainedDD == TRUE)
    {
        TRACE((hTrace,TC_ICASRV,TT_API3, "TERMSRV: unchain console DD\n"));
        pWinStation->Flags |= WSF_DISCONNECT;
        /*
         * Ignore this return code -- we don't need it and we also don't want
         * to overwrite the value in Status.
         */
        (void)ConsoleShadowStop( pWinStation );
        fResetShadowSetting = FALSE;
        pWinStation->Flags &= ~WSF_DISCONNECT;
        fChainedDD = FALSE;
    }

    //
    // reset the console winstation parameters.
    //

    if (fOwnsConsoleTerminal) {
        pWinStation->hIca = hIca;
        pWinStation->hStack = hStack;
        pWinStation->pWsx = pWsx;
        pWinStation->pWsxContext = pWsxContext;
        pWinStation->hIcaBeepChannel = hIcaBeepChannel;
        pWinStation->hIcaThinwireChannel = hIcaThinwireChannel;
    }   
    
    if( fResetShadowSetting ) {
        // Console shadow already reset back to original value
        // can't do this in WinStationShadowWorker(), might run into
        // some timing problem.

        pWinStation->Config.Config.User.Shadow = pWinStation->OriginalShadowClass;
    }


    if( bResetStateFlags ) {
        pWinStation->StateFlags &= ~WSF_ST_SHADOW;
    }

    ReleaseWinStation( pWinStation );

done:
    TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationShadowTarget, Status=0x%x\n", 
           Status ));
    return Status;

}


/*****************************************************************************
 *
 *  WinStationStopAllShadows
 *
 *   Stop all shadow activity for this Winstation
 *
 * ENTRY:
 *   pWinStation (input)
 *      pointer to WinStation
 *
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationStopAllShadows( PWINSTATION pWinStation )
{
    PLIST_ENTRY Head, Next;
    NTSTATUS Status;

    /*
     * If this WinStation is a shadow client, then set the shadow broken
     * event and create an event to wait on for it the shadow to terminate.
     */
    if ( pWinStation->hPassthruStack ) {

        pWinStation->ShadowDoneEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        ASSERT( pWinStation->ShadowDoneEvent );

        if ( pWinStation->ShadowBrokenEvent ) {
            SetEvent( pWinStation->ShadowBrokenEvent );
        }
    }

    /*
     * If this WinStation is a shadow target, then loop through the
     * shadow structures and signal the broken event for each one.
     */
    if ( !IsListEmpty( &pWinStation->ShadowHead ) ) {

        pWinStation->ShadowDoneEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        ASSERT( pWinStation->ShadowDoneEvent );

        Head = &pWinStation->ShadowHead;
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
            PSHADOW_INFO pShadow;

            pShadow = CONTAINING_RECORD( Next, SHADOW_INFO, Links );
            NtSetEvent( pShadow->hBrokenEvent, NULL );
        }
    }

    /*
     * If a shadow done event was created above, then we'll wait on it
     * now (for either the shadow client or shadow target to complete).
     */
    if ( pWinStation->ShadowDoneEvent ) {

        UnlockWinStation( pWinStation );
        Status = WaitForSingleObject( pWinStation->ShadowDoneEvent, 60*1000 );
        RelockWinStation( pWinStation );

        CloseHandle( pWinStation->ShadowDoneEvent );
        pWinStation->ShadowDoneEvent = NULL;
    }

    return( STATUS_SUCCESS );
}


//-----------------------------------------------------
// Helper functions copied from SALEM
// (nt\termsrv\remdsk\server\sessmgr\helper.cpp)
//-----------------------------------------------------

DWORD
GenerateRandomBytes(
    IN DWORD dwSize,
    IN OUT LPBYTE pbBuffer
    )
/*++

Description:

    Generate fill buffer with random bytes.

Parameters:

    dwSize : Size of buffer pbBuffer point to.
    pbBuffer : Pointer to buffer to hold the random bytes.

Returns:

    TRUE/FALSE

--*/
{
    HCRYPTPROV hProv = (HCRYPTPROV)NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Create a Crypto Provider to generate random number
    //
    if( !CryptAcquireContext(
                    &hProv,
                    NULL,
                    NULL,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                ) )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( !CryptGenRandom(hProv, dwSize, pbBuffer) )
    {
        dwStatus = GetLastError();
    }

CLEANUPANDEXIT:    

    if( (HCRYPTPROV)NULL != hProv )
    {
        CryptReleaseContext( hProv, 0 );
    }

    return dwStatus;
}


DWORD
GenerateRandomString(
    IN DWORD dwSizeRandomSeed,
    IN OUT LPTSTR* pszRandomString
    )
/*++


--*/
{
    PBYTE lpBuffer = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess;
    DWORD cbConvertString = 0;

    if( 0 == dwSizeRandomSeed || NULL == pszRandomString )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    *pszRandomString = NULL;

    lpBuffer = (PBYTE)LocalAlloc( LPTR, dwSizeRandomSeed );  
    if( NULL == lpBuffer )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    dwStatus = GenerateRandomBytes( dwSizeRandomSeed, lpBuffer );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    // Convert to string
    // cbConvertString will include the NULL character
    bSuccess = CryptBinaryToString(
                                lpBuffer,
                                dwSizeRandomSeed,
                                CRYPT_STRING_BASE64,
                                NULL,
                                &cbConvertString
                            );
    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    *pszRandomString = (LPTSTR)LocalAlloc( LPTR, cbConvertString*sizeof(TCHAR) );
    if( NULL == *pszRandomString )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    bSuccess = CryptBinaryToString(
                                lpBuffer,
                                dwSizeRandomSeed,
                                CRYPT_STRING_BASE64,
                                *pszRandomString,
                                &cbConvertString
                            );
    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
    }
    else
    {
        if( (*pszRandomString)[cbConvertString - 1] == '\n' &&
            (*pszRandomString)[cbConvertString - 2] == '\r' )
        {
            (*pszRandomString)[cbConvertString - 2] = 0;
        }
    }

CLEANUPANDEXIT:

    if( ERROR_SUCCESS != dwStatus )
    {
        if( NULL != *pszRandomString )
        {
            LocalFree(*pszRandomString);
            *pszRandomString = NULL;
        }
    }

    if( NULL != lpBuffer )
    {
        LocalFree(lpBuffer);
    }

    return dwStatus;
}

NTSTATUS
_CreateShadowAddress(
    ULONG ShadowId,
    PWINSTATIONCONFIG2 pConfig,
    PWSTR pTargetServerName,
    ULONG ulTargetServerNameLength,
    PICA_STACK_ADDRESS pAddress,
    PICA_STACK_ADDRESS pRemoteAddress
    )
{
    int   nFormattedLength;
    NTSTATUS Status =  STATUS_INVALID_PARAMETER;

    RtlZeroMemory( pAddress, sizeof(*pAddress) );

    if ( !_wcsicmp( pConfig->Pd[0].Create.PdDLL, L"tdpipe" ) ) {

        LPTSTR pszRandomString = NULL;
        DWORD dwStatus;
        WCHAR szShadowId[32];
        ULONG ulRandomStringLength;

        nFormattedLength = _snwprintf( szShadowId, sizeof(szShadowId)/sizeof(szShadowId[0]), L"%d", ShadowId );
        if (nFormattedLength < 0 || nFormattedLength == sizeof(szShadowId)/sizeof(szShadowId[0])) {
            return STATUS_INVALID_PARAMETER;
        }

        if (pTargetServerName) {

            nFormattedLength += 26 + 1 // length of "\\??\\UNC\\\\Pipe\\Shadowpipe\\-" + NULL
                                + ulTargetServerNameLength;
        } else {

            nFormattedLength += 21 + 1; // length of "\\??\\Pipe\\Shadowpipe\\-" + NULL
        }

        if (nFormattedLength >= sizeof(ICA_STACK_ADDRESS)/sizeof(WCHAR)) {
            return STATUS_INVALID_PARAMETER;
        }

        ulRandomStringLength = sizeof(ICA_STACK_ADDRESS)/sizeof(WCHAR) - nFormattedLength;

        dwStatus = GenerateRandomString( ulRandomStringLength, &pszRandomString );
        if( ERROR_SUCCESS != dwStatus )
        {
            return WinStationWinerrorToNtStatus(dwStatus);
        }

        // the string generated is always greater than what we ask
        pszRandomString[ulRandomStringLength] = L'\0';

        *((PWCHAR)pAddress) = (WCHAR)0;
        nFormattedLength = _snwprintf( (PWSTR)pAddress, sizeof(ICA_STACK_ADDRESS)/sizeof(WCHAR), L"\\??\\Pipe\\Shadowpipe\\%d-%ws", ShadowId, pszRandomString );
        if (nFormattedLength < 0 || nFormattedLength == sizeof(ICA_STACK_ADDRESS)/sizeof(WCHAR)) {
            LocalFree( pszRandomString );
            return STATUS_INVALID_PARAMETER;
        }
        if ( pTargetServerName ) {

            // note that pTargetServerName is guaranted to
            // not exceed MAX_COMPUTERNAME_LENGTH (should be 15)
            // this check is done in RpcWinStationShadow
            *((PWCHAR)pRemoteAddress) = (WCHAR)0;
            nFormattedLength = _snwprintf( (PWSTR)pRemoteAddress,  sizeof(ICA_STACK_ADDRESS)/sizeof(WCHAR), L"\\??\\UNC\\%ws\\Pipe\\Shadowpipe\\%d-%ws",
                                          pTargetServerName, ShadowId, pszRandomString );
            if (nFormattedLength < 0 || nFormattedLength == sizeof(ICA_STACK_ADDRESS)/sizeof(WCHAR)) {
                LocalFree( pszRandomString );
                return STATUS_INVALID_PARAMETER;
            }
        } else {
            *pRemoteAddress = *pAddress;
        }

        LocalFree( pszRandomString );

    } else if ( !_wcsicmp( pConfig->Pd[0].Create.PdDLL, L"tdnetb" ) ) {
        *(PUSHORT)pAddress = AF_NETBIOS;
        GetSystemTimeAsFileTime( (LPFILETIME)((PUSHORT)(pAddress)+1) );
        pConfig->Pd[0].Params.Network.LanAdapter = 1;
        *pRemoteAddress = *pAddress;
    } else if ( !_wcsicmp( pConfig->Pd[0].Create.PdDLL, L"tdtcp" ) ) {
        *(PUSHORT)pAddress = AF_INET;
        *pRemoteAddress = *pAddress;
    } else if ( !_wcsicmp( pConfig->Pd[0].Create.PdDLL, L"tdipx" ) ||
                !_wcsicmp( pConfig->Pd[0].Create.PdDLL, L"tdspx" ) ) {
        *(PUSHORT)pAddress = AF_IPX;
        *pRemoteAddress = *pAddress;
    } else {
        return STATUS_INVALID_PARAMETER;
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
_WinStationShadowTargetThread( PVOID p )
{
    PSHADOW_PARMS pShadowParms;
    HANDLE NullToken;
    PWINSTATION pWinStation;
    //DWORD WNetRc;
    NTSTATUS Status;
    NTSTATUS ShadowStatus;

    pShadowParms = (PSHADOW_PARMS)p;

    /*
     * Impersonate the client using the token handle passed to us.
     */
    ShadowStatus = NtSetInformationThread( NtCurrentThread(),
                                           ThreadImpersonationToken,
                                           (PVOID)&pShadowParms->ImpersonationToken,
                                           (ULONG)sizeof(HANDLE) );
    ASSERT( NT_SUCCESS( ShadowStatus ) );
    if ( !NT_SUCCESS( ShadowStatus ) )
        goto impersonatefailed;

    /*
     * If target server name was not specified, then call the
     * target worker function directly and avoid the RPC overhead.
     */
    if ( pShadowParms->pTargetServerName == NULL ) {

        ShadowStatus = WinStationShadowTargetWorker(
                    pShadowParms->ShadowerIsHelpSession,
                    pShadowParms->fResetShadowMode,
                    pShadowParms->TargetLogonId,
                    &pShadowParms->Config,
                    &pShadowParms->Address,
                    pShadowParms->pModuleData,
                    pShadowParms->ModuleDataLength,
                    pShadowParms->pThinwireData,
                    pShadowParms->ThinwireDataLength,
                    pShadowParms->ClientName);
        SetLastError(RtlNtStatusToDosError(ShadowStatus));        

    /*
     * Otherwise, open the remote targer server and call the shadow target API.
     */
    } else {
        HANDLE hServer;

        hServer = WinStationOpenServer( pShadowParms->pTargetServerName );
        if ( hServer == NULL ) {
            ShadowStatus = STATUS_OBJECT_NAME_NOT_FOUND;
        } else {
            ShadowStatus = _WinStationShadowTarget(
                    hServer,
                    pShadowParms->TargetLogonId,
                    &pShadowParms->Config,
                    &pShadowParms->Address,
                    pShadowParms->pModuleData,
                    pShadowParms->ModuleDataLength,
                    pShadowParms->pThinwireData,
                    pShadowParms->ThinwireDataLength,
                    pShadowParms->ClientName,
                    sizeof(pShadowParms->ClientName) );

            if (ShadowStatus != STATUS_SUCCESS) {
                ShadowStatus = WinStationWinerrorToNtStatus(GetLastError());
            }

            WinStationCloseServer( hServer );
        }
    }

    /*
     * Revert back to our threads default token.
     */
    NullToken = NULL;
    Status = NtSetInformationThread( NtCurrentThread(),
                                     ThreadImpersonationToken,
                                     (PVOID)&NullToken,
                                     (ULONG)sizeof(HANDLE) );
    ASSERT( NT_SUCCESS( Status ) );

impersonatefailed:

    /*
     * Now find and lock the client WinStation and return the status
     * from the above call to the client WinStation.
     */
    pWinStation = FindWinStationById( pShadowParms->ClientLogonId, FALSE );
    if ( pWinStation != NULL ) {
        if ( pWinStation->ShadowId == pShadowParms->ClientShadowId ) {
            pWinStation->ShadowTargetStatus = ShadowStatus;
        }
        ReleaseWinStation( pWinStation );
    }

    NtClose( pShadowParms->ImpersonationToken );
    MemFree( pShadowParms->pModuleData );
    MemFree( pShadowParms->pThinwireData );
    MemFree( pShadowParms );

    TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: ShadowTargetThread got: Status=0x%x\n", 
           ShadowStatus ));


    return( ShadowStatus );
}


/*****************************************************************************
 *
 *  WinStationShadowChangeMode
 *
 *   Change the mode of the current shadow: interactive/non interactive
 *
 * ENTRY:
 *   pWinStation (input/output)
 *      pointer to WinStation
 *   pWinStationShadow (input)
 *      pointer to WINSTATIONSHADOW struct
 *   ulLength (input)
 *      length of the input buffer
 *
 *
 * EXIT:
 *   STATUS_xxx error
 *
 ****************************************************************************/

NTSTATUS WinStationShadowChangeMode( 
    PWINSTATION pWinStation,
    PWINSTATIONSHADOW pWinStationShadow,
    ULONG ulLength )
{
    NTSTATUS Status = STATUS_SUCCESS; //assume success

    if (ulLength >= sizeof(WINSTATIONSHADOW)) {

        //
        // If the session is being shadowed then check the new shadow mode
        //
        if ( pWinStation->State == State_Active &&
             !IsListEmpty(&pWinStation->ShadowHead) ) {

            HANDLE ChannelHandle;
            ULONG IoCtlCode = 0;

            switch ( pWinStationShadow->ShadowClass ) {

                case Shadow_EnableInputNotify :
                case Shadow_EnableInputNoNotify :
                    // 
                    // we want input : enable it regardless of current state!
                    //
                    IoCtlCode = IOCTL_ICA_CHANNEL_ENABLE_SHADOW;
                    break;

                case Shadow_EnableNoInputNotify :
                case Shadow_EnableNoInputNoNotify :
                    //
                    // We want no input, disable it.
                    //
                    IoCtlCode = IOCTL_ICA_CHANNEL_DISABLE_SHADOW;
                    break;

                case Shadow_Disable :
                    Status = STATUS_INVALID_PARAMETER;
                    break;

                default:
                    Status = STATUS_INVALID_PARAMETER;
                    break;

            }

            if ( IoCtlCode != 0 ) {
                KEYBOARD_INDICATOR_PARAMETERS KbdLeds;
                NTSTATUS Status2;

                Status = IcaChannelOpen( pWinStation->hIca,
                                         Channel_Keyboard,
                                         NULL,
                                         &ChannelHandle );

                if ( NT_SUCCESS( Status ) ) {

                    // if we're re-enabling input, get the leds state on the primary stack...
                    if ( IoCtlCode == IOCTL_ICA_CHANNEL_ENABLE_SHADOW ) {
                        Status2 = IcaChannelIoControl( ChannelHandle, IOCTL_KEYBOARD_QUERY_INDICATORS,
                                             NULL, 0, &KbdLeds, sizeof(KbdLeds), NULL);
                    }

                    Status = IcaChannelIoControl( ChannelHandle, IoCtlCode,
                                                  NULL, 0, NULL, 0, NULL );

                    // and update all stacks with this state.
                    if ( IoCtlCode == IOCTL_ICA_CHANNEL_ENABLE_SHADOW &&
                         NT_SUCCESS( Status ) &&
                         NT_SUCCESS( Status2 ) ) {

                        Status2 = IcaChannelIoControl( ChannelHandle, IOCTL_KEYBOARD_SET_INDICATORS,
                                             &KbdLeds, sizeof(KbdLeds), NULL, 0, NULL);
                    }

                    IcaChannelClose( ChannelHandle );
                }

                if ( NT_SUCCESS( Status ) ) {

                    Status = IcaChannelOpen( pWinStation->hIca,
                                             Channel_Mouse,
                                             NULL,
                                             &ChannelHandle );

                    if ( NT_SUCCESS( Status ) ) {

                        Status = IcaChannelIoControl( ChannelHandle, IoCtlCode,
                                                      NULL, 0, NULL, 0, NULL );
                        IcaChannelClose( ChannelHandle );
                    }
                }

            }

            // Do not update WinStation shadow config, user should not
            // be able to bypass what's defined in Group Policy. 

        }

    } else {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    return Status;
}


/*****************************************************************************
 *
 *  _DetectLoop
 *
 *   Detects a loop by walking the chain of containers.
 *
 * ENTRY:
 *   RemoteSessionId (input)
 *     id of the session from where we start the search
 *   pRemoteServerDigProductId (input)
 *     product id of the machine from where we start the search
 *   TargetSessionId (input)
 *     id of the session looked up
 *   pTargetServerDigProductId (input)
 *     product id of the machine looked up
 *   pLocalServerProductId (input)
 *     product id of the local machine
 *   pbLoop (output)
 *     pointer to the result of the search
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
_DetectLoop(
    IN ULONG RemoteSessionId,
    IN PWSTR pRemoteServerDigProductId,
    IN ULONG TargetSessionId,
    IN PWSTR pTargetServerDigProductId,
    IN PWSTR pLocalServerProductId,
    OUT BOOL* pbLoop
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWINSTATION pWinStation;
    WCHAR TmpDigProductId[CLIENT_PRODUCT_ID_LENGTH];

    if ( pbLoop == NULL )
        return STATUS_INVALID_PARAMETER;
    else
        *pbLoop = FALSE;



      do {

        if ( _wcsicmp( pLocalServerProductId, pRemoteServerDigProductId ) != 0 ) {

            // For now limit the search to the local cases.
            // Later we can add a RPC call or any other 
            // mechanism (by instance through the client)
            // to get this info from the distant machine.
            
            Status = STATUS_UNSUCCESSFUL;

            // The solution could be to RPC the remote machine to get
            // the client data for the session id. Then from these data
            // we can get the client computer name and the client session id.
            // RPC to use: WinStationQueryInformation with information
            // class set to WinStationClient.
            // No need to add a new RPC call.

          } else {

            // we're sure that the remote session is on the same server
            pWinStation = FindWinStationById( RemoteSessionId, FALSE );

            if ( pWinStation != NULL ) {
                // set the new remote info
                RemoteSessionId = pWinStation->Client.ClientSessionId;

                memcpy(TmpDigProductId, pWinStation->Client.clientDigProductId, sizeof( TmpDigProductId ));
                pRemoteServerDigProductId = TmpDigProductId;
                ReleaseWinStation( pWinStation );
            } else {
                Status = STATUS_ACCESS_DENIED;
            }
          }

          if( !*pRemoteServerDigProductId )
          //older client, can't do anything, allow shadow
            break;

          if ( Status == STATUS_SUCCESS ) {

            if ( (RemoteSessionId == TargetSessionId) &&
                (_wcsicmp( pRemoteServerDigProductId, pTargetServerDigProductId ) == 0) ) {

                *pbLoop = TRUE;

            } else  if ( RemoteSessionId == LOGONID_NONE ) {

                // no loop, return success.
                break;
            }
          }
      } while ( (*pbLoop == FALSE) && (Status == STATUS_SUCCESS) );

    return Status;
}

/*****************************************************************************
 *
 *  _CheckShadowLoop
 *
 *   Detects a loop in the shadow.
 *
 * ENTRY:
     pWinStation
        pointer to the current Winstation
 *   ClientLogonId (input)
 *     client of the shadow
 *   pTargetServerName (input)
 *     target server name
 *   TargetLogonId (input)
 *     target login id (where the app is running)
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/
NTSTATUS
_CheckShadowLoop(
    IN ULONG ClientLogonId,
    IN PWSTR pTargetServerName,
    IN ULONG TargetLogonId
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL bLoop;

    WCHAR LocalDigProductId [ CLIENT_PRODUCT_ID_LENGTH ];
    WCHAR* pTargetServerDigProductId = NULL;
    WINSTATIONPRODID WinStationProdId;
    ULONG len;

    memcpy( LocalDigProductId, g_DigProductId, sizeof( LocalDigProductId ));

    //get the target's sessionid and digital product id
    if ( pTargetServerName == NULL ) {
        pTargetServerDigProductId = LocalDigProductId;
    /*
     * Otherwise, open the remote targer server and call the shadow target API.
     */
    } 
    
    else 
    {
        HANDLE hServer;
        ZeroMemory( &WinStationProdId, sizeof( WINSTATIONPRODID ));

        hServer = WinStationOpenServer( pTargetServerName );
        if ( hServer == NULL ) 
        {
            //ignore errors, we allow shadowing
            goto done;
        } 
        else 
        {
          //ignore errors 
          WinStationQueryInformation( hServer, TargetLogonId, WinStationDigProductId, &WinStationProdId, sizeof(WinStationProdId), &len);
          WinStationCloseServer( hServer );
        }
        pTargetServerDigProductId = WinStationProdId.DigProductId;
    }

     //
    // First pass: start from the local session (i.e. the shadow client)
    // and walk the chain of containers up to the outtermost session in case
    // we reach the target session in the chain.
    //
    
    if( *LocalDigProductId && *pTargetServerDigProductId ) {

        Status = _DetectLoop( ClientLogonId,
                          LocalDigProductId,
                          TargetLogonId,
                          pTargetServerDigProductId,
                          LocalDigProductId,
                          &bLoop);

        if ( Status == STATUS_SUCCESS ) {
            if (bLoop) {
                // Status = STATUS_CTX_SHADOW_CIRCULAR;
                Status = STATUS_ACCESS_DENIED;
                goto done;
            }
        } //else ignore errors and do the second pass

    //
    // Second pass: start from the target session (i.e. the shadow target)
    // and walk the chain of containers up to the outtermost session in case
    // we reach the client session in the chain.
    //

        Status = _DetectLoop( TargetLogonId,
                          pTargetServerDigProductId,
                          ClientLogonId,
                          LocalDigProductId,
                          LocalDigProductId,
                          &bLoop);

        if ( Status == STATUS_SUCCESS ) {
            if (bLoop) {
                //Status = STATUS_CTX_SHADOW_CIRCULAR;
                Status = STATUS_ACCESS_DENIED;
            }
        } else {
        //else ignore errors and grant shadow
            Status = STATUS_SUCCESS;
          }
     }

done:
    return Status;
}


/*****************************************************************************
 *
 *  GetSalemOutbufCount
 *
 *   Gets the outbufcount from the registry for the help assistant
 *
 * ENTRY:
 *    pdwValue
 *      output where the value is stored
 * EXIT:
 *   TRUE - no error
 *
 ****************************************************************************/

BOOL GetSalemOutbufCount(PDWORD pdwValue)
{
    BOOL fSuccess = FALSE;
    HKEY hKey = NULL;
    
    if( NULL == pdwValue )
        return FALSE;
    
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REG_CONTROL_SALEM,
                    0,
                    KEY_READ,
                    &hKey
                   ) == ERROR_SUCCESS ) {

        DWORD dwSize = sizeof(DWORD);
        DWORD dwType;
        if((RegQueryValueEx(hKey,
                            WIN_OUTBUFCOUNT,
                            NULL,
                            &dwType,
                            (PBYTE) pdwValue,
                            &dwSize
                           ) == ERROR_SUCCESS) 
                           && dwType == REG_DWORD 
                           && *pdwValue > 0) {
            fSuccess = TRUE;
        }
    }

    if(NULL != hKey )
        RegCloseKey(hKey);
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\tsrpc-s.c ===
#include <tsrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\sessdir.h ===
/****************************************************************************/
// sessdir.h
//
// TS Session Directory header.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/
#ifndef __SESSDIR_H
#define __SESSDIR_H

#include "tssd.h"
#include "tssdcommon.h"
#include <winsock2.h>
#include <ws2tcpip.h>


#ifdef __cplusplus
extern "C" {
#endif

// This one shoud be consistent with the one in at120ex.h
#define TS_CLUSTER_REDIRECTION_VERSION3             0x2
#define TS_CLUSTER_REDIRECTION_VERSION4             0x3

// Default 30 second for waiting repopulation to complete.
#define TS_WAITFORREPOPULATE_TIMEOUT                30

extern WCHAR g_LocalServerAddress[64];
extern ULONG g_LocalIPAddress;

extern POLICY_TS_MACHINE g_MachinePolicy;

void InitSessionDirectory();
DWORD UpdateSessionDirectory(DWORD UpdatePara);
DWORD RepopulateSessionDirectory();
void DestroySessionDirectory();

void SessDirNotifyLogon(TSSD_CreateSessionInfo *);
void SessDirNotifyDisconnection(DWORD, FILETIME);
void SessDirNotifyReconnection(PWINSTATION, TSSD_ReconnectSessionInfo *);
void SessDirNotifyLogoff(DWORD);
void SessDirNotifyReconnectPending(WCHAR *ServerName);
unsigned SessDirGetDisconnectedSessions(WCHAR *, WCHAR *,
        TSSD_DisconnectedSessionInfo[TSSD_MaxDisconnectedSessions]);
BOOL SessDirCheckRedirectClient(PWINSTATION, TS_LOAD_BALANCE_INFO *);
BOOL SessDirGetLBInfo(WCHAR *ServerAddress, DWORD* pLBInfoSize, PBYTE* pLBInfo);

void SessDirWaitForRepopulate();

int SetTSSD(ITSSessionDirectory *pTSSD);
ITSSessionDirectory *GetTSSD();
void ReleaseTSSD();

int SetTSSDEx(ITSSessionDirectoryEx *pTSSD);
ITSSessionDirectoryEx *GetTSSDEx();
void ReleaseTSSDEx();

DWORD SessDirOpenSessionDirectory( LPWSTR );


#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // __SESSDIR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\setuinfo.c ===
/*************************************************************************
*
* setuinfo.c
*
* Sets user logon information.
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

#include "precomp.h"
#include "tsremdsk.h"
#pragma hdrstop

// global vars
extern POLICY_TS_MACHINE    g_MachinePolicy;

/*****************************************************************************
 *
 *  MergeUserConfigData
 *
 *  This is the final step in updating a Winstation's USERCONFIG data, which is the final merge of
 *  settings from 5 different sources of data, in the following precedence where top most has the highest
 *  precedence overriding all below it:
 *          Machine Policy
 *          User Policy
 *          TSCC
 *          TsUserEx
 *          Client preference settings
 *
 *          By the time this call is made, the Client preference and TsUserEX data is already merged, where
 *              the result of that merge is in pWinstation's USERCONFIGW struct.
 *
 *  The final call happens when user has logged in, and user policy data is present. When this func is called from 
 *      RpcWinStationUpdateUserConfig, any user policy data that is not already overriden by machine policy will be 
 *      set in USERCONFIG.
 *
 *  The User policy has the following items which ARE repeated in Machine policy, and hence, Machine Policy takes precedence
 *      Remote Control Settings ( SHADOW)
 *      Start up program
 *      Session time out:
 *          time out for disconnected session
 *          time limit for active session
 *          time limit for idle session
 *          allow reconnect from oirginal client only
 *          terminate session when time limits are reaced (instead of disconnect).
 *  
 *  None of the session-time-out and start-up-program USER policies are relevant to 
 *      sesion 0, or any session that is physically connected on the console.
 *
 * ENTRY:
 *    pWinStation
 *         Pointer to WINSTATION structure
 *    pPolicy
 *         TS user policy flags, could be NULL
 *    pPolicyData
 *          policy data if pPolicy is not NULL, otherwise, can be NULL
 *    pUserConfig
 *         Pointer to USERCONFIG structure, can be NULL if pWinstation already has user conifig data from SAM
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 * USAGE
 *      fn( pWinstation, NULL, NULL, pUserConfig) will do a legacy merge of user data into pWinstation.
 *          Legacy merge means that data set by TSCC could override user data.
 *
 *      fn( pWinstation, pPolicy, pPolicyData, NULL ) would override pWinstation data of user by per user data
 *          from  group policy 
 *
 ****************************************************************************/


VOID
MergeUserConfigData( PWINSTATION pWinStation, 
    PPOLICY_TS_USER         pPolicy,
    PUSERCONFIGW            pPolicyData,
    PUSERCONFIG             pUserConfig )
{
    PUSERCONFIG         pWSConfig;
    PPOLICY_TS_MACHINE  pMachinePolicy; 
    BOOLEAN             dontApplySomePolicy ;
    BOOL                bValidHelpSessionLogin;

    pWSConfig      = & pWinStation->Config.Config.User;
    pMachinePolicy = & g_MachinePolicy;


    // active console ID is the ID of the session that is physically connected to the real video drivers at this time.
    dontApplySomePolicy = ( pWinStation->LogonId == 0 ) || (pWinStation->LogonId == (USER_SHARED_DATA->ActiveConsoleId) );

    // None of the session-time-out and start-up-program USER policies are relevant to 
    //    sesion 0, or any session that is physically connected on the console.
    if (! dontApplySomePolicy )
    {
        // if sessions0, or if sessions is the phisical console, then we do not want to apply certain policies at all.
    
        if ( ! pMachinePolicy->fPolicyInitialProgram )  // if we don't have a machine policy for this, then it is ok to use User policy
        {
            if ( pPolicy && pPolicy->fPolicyInitialProgram  )
            {
                wcscpy( pWSConfig->InitialProgram, pPolicyData->InitialProgram );
                wcscpy( pWSConfig->WorkDirectory,  pPolicyData->WorkDirectory );
        
                pWSConfig->fInheritInitialProgram = FALSE;
            }
            else if (pUserConfig)
            {
                /*
                 * Use initial program/working directory from user config if WinStation
                 * config says inherit and user config does NOT say inherit from client.
                 */
                if ( pWSConfig->fInheritInitialProgram &&
                     !pUserConfig->fInheritInitialProgram ) {
            
                    /*
                     *  Always copy the user config info in this case, plugs security hole.
                     */
                    wcsncpy( pWSConfig->InitialProgram, pUserConfig->InitialProgram, INITIALPROGRAM_LENGTH );
                    wcsncpy( pWSConfig->WorkDirectory,  pUserConfig->WorkDirectory, DIRECTORY_LENGTH );
                }
            }
        }

        if ( ! pMachinePolicy->fPolicyResetBroken ) // if we don't have a machine policy for this, then it is ok to use User policy
        {
            if ( pPolicy && pPolicy->fPolicyResetBroken )
            {
                pWSConfig->fResetBroken = pPolicyData->fResetBroken;
                pWSConfig->fInheritResetBroken = FALSE;
            }
            else if (pUserConfig)
            {
                if ( pWSConfig->fInheritResetBroken )
                    pWSConfig->fResetBroken = pUserConfig->fResetBroken;
            }
        }


        // ---------------------------------------------- 
        if ( ! pMachinePolicy->fPolicyReconnectSame )  // if we don't have a machine policy for this, then it is ok to use User policy 
        {
            if ( pPolicy && pPolicy->fPolicyReconnectSame )
            {
                pWSConfig->fReconnectSame = pPolicyData->fReconnectSame;
                pWSConfig->fInheritReconnectSame = FALSE;
            }
            else if (pUserConfig)
            {
                if ( pWSConfig->fInheritReconnectSame )
                    pWSConfig->fReconnectSame = pUserConfig->fReconnectSame;
            }
        }


        // ---------------------------------------------- 
        if ( ! pMachinePolicy->fPolicyMaxSessionTime )  // if we don't have a machine policy for this, then it is ok to use User policy
        {
            if ( pPolicy && pPolicy->fPolicyMaxSessionTime )
            {
                pWSConfig->MaxConnectionTime = pPolicyData->MaxConnectionTime;
                pWSConfig->fInheritMaxSessionTime = FALSE;
            }
            else if (pUserConfig)
            {
                if ( pWSConfig->fInheritMaxSessionTime )
                    pWSConfig->MaxConnectionTime = pUserConfig->MaxConnectionTime;
            }
        }


        // ---------------------------------------------- 
        if ( ! pMachinePolicy->fPolicyMaxDisconnectionTime ) // if we don't have a machine policy for this, then it is ok to use User policy
        {
            if ( pPolicy && pPolicy->fPolicyMaxDisconnectionTime )
            {
                pWSConfig->MaxDisconnectionTime = pPolicyData->MaxDisconnectionTime;
                pWSConfig->fInheritMaxDisconnectionTime = FALSE;
            }
            else if (pUserConfig)
            {
                if ( pWSConfig->fInheritMaxDisconnectionTime )
                    pWSConfig->MaxDisconnectionTime = pUserConfig->MaxDisconnectionTime;
            }
        }

        // ---------------------------------------------- 
        if ( ! pMachinePolicy->fPolicyMaxIdleTime ) // if we don't have a machine policy for this, then it is ok to use User policy
        {
            if ( pPolicy && pPolicy->fPolicyMaxIdleTime )
            {
                pWSConfig->MaxIdleTime = pPolicyData->MaxIdleTime;
                pWSConfig->fInheritMaxIdleTime = FALSE;
            }
            else if (pUserConfig)
            {
                if ( pWSConfig->fInheritMaxIdleTime )
                    pWSConfig->MaxIdleTime = pUserConfig->MaxIdleTime;
            }
        }

    }

    // ---------------------------------------------- 
    if ( ! pMachinePolicy->fPolicyShadow ) // if we don't have a machine policy for this, then it is ok to use User policy
    {
        if ( pPolicy && pPolicy->fPolicyShadow )
        {
            pWSConfig->Shadow = pPolicyData->Shadow;
            pWSConfig->fInheritShadow = FALSE;
        }
        else if (pUserConfig)
        {
            if ( pWSConfig->fInheritShadow )
                pWSConfig->Shadow = pUserConfig->Shadow;
        }
    }

    // ---------------------------------------------- 
    // we don't have a machine policy for this item, which does not even have a UI for user policy...
    //      if ( ! pMachinePolicy->fPolicyCallback ) 
    //
    {
        if ( pPolicy && pPolicy->fPolicyCallback )
        {
            pWSConfig->Callback = pPolicyData->Callback;
            pWSConfig->fInheritCallback = FALSE;
        }
        else if (pUserConfig)
        {
            if ( pWSConfig->fInheritCallback )
                pWSConfig->Callback = pUserConfig->Callback;
        }
    }

    // ---------------------------------------------- 
    // we don't have a machine policy for this item, which does not even have a UI for user policy...
    //      if ( ! pMachinePolicy->fPolicyCallbackNumber ) 
    //
    {
        if ( pPolicy && pPolicy->fPolicyCallbackNumber )
        {
            wcscpy( pWSConfig->CallbackNumber, pPolicyData->CallbackNumber );
            pWSConfig->fInheritCallbackNumber = FALSE;
        }
        else if (pUserConfig)
        {
            if ( pWSConfig->fInheritCallbackNumber )
                wcsncpy( pWSConfig->CallbackNumber, pUserConfig->CallbackNumber, CALLBACK_LENGTH );
        }
    }

    // ---------------------------------------------- 
    // we don't have a machine policy for this item. Policy forces a state, does not configure a preferance.
    //      if ( ! pMachinePolicy->fPolicyAutoClientDrives ) 
    //
    {
        if ( pPolicy && pPolicy->fPolicyAutoClientDrives)
        {
            pWSConfig->fAutoClientDrives = pPolicyData->fAutoClientDrives;
    
            // In case other items such as 
            // lpt or def-printer are set to be inherited, such an
            // inheritance of bits would continue for those items
            // pWSConfig->fInheritAutoClient = FALSE;
            //
        }
        else if (pUserConfig)
        {
            if ( pWSConfig->fInheritAutoClient ) 
            {
                pWSConfig->fAutoClientDrives = pUserConfig->fAutoClientDrives;
            }
        }
    }

    // ---------------------------------------------- 
    // we don't have a machine policy for this item. Policy forces a state, does not configure a preferance.
    //      if ( ! pMachinePolicy->fPolicyAutoClientLpts )                                  
    //
    {
        if ( pPolicy && pPolicy->fPolicyAutoClientLpts )
        {
            pWSConfig->fAutoClientLpts   = pPolicyData->fAutoClientLpts;
        }
        else if (pUserConfig)
        {
            if (pWSConfig->fInheritAutoClient)
            {
                pWSConfig->fAutoClientLpts   = pUserConfig->fAutoClientLpts;
            }
        }
    }

    // ---------------------------------------------- 
    if ( ! pMachinePolicy->fPolicyForceClientLptDef) // if we don't have a machine policy for this, then it is ok to use User policy
    {
        if ( pPolicy && pPolicy->fPolicyForceClientLptDef )
        {
            pWSConfig->fForceClientLptDef = pPolicyData->fForceClientLptDef;
        }
        else if (pUserConfig)
        {
            if ( pWSConfig->fInheritAutoClient ) 
            {
                pWSConfig->fForceClientLptDef = pUserConfig->fForceClientLptDef;
            }
        }
    }

    if( TSIsSessionHelpSession( pWinStation, &bValidHelpSessionLogin ) )
    {
        // We disconnected RA if ticket is invalid.
        ASSERT( TRUE == bValidHelpSessionLogin );

        // Reset initial program.
        pWSConfig->fInheritInitialProgram = FALSE;

        //
        // our string is still less than 256 (INITIALPROGRAM_LENGTH),
        // need to revisit this if ever increase ticket ID and password length
        //
        _snwprintf( 
                pWSConfig->InitialProgram,
                INITIALPROGRAM_LENGTH,
                L"%s %s",
                SALEMRDSADDINNAME,
                pWinStation->Client.WorkDirectory
            );

        pWSConfig->WorkDirectory[0] = 0;

        // reset winstation when connection is broken
        pWSConfig->fInheritResetBroken = FALSE;
        pWSConfig->fResetBroken = TRUE;

        //
        // No re-direction
        //
        pWSConfig->fInheritAutoClient = FALSE;
        pWSConfig->fAutoClientDrives = FALSE;
        pWSConfig->fAutoClientLpts = FALSE;
        pWSConfig->fForceClientLptDef = FALSE;
    }

    // Cache the original shadow setting so we can reset shadow setting
    // at the end of shadow call, we don't to look it up from registry again
    // as winstion shadow setting might change, in addition, a common
    // winstation configuration for more than one NIC might get split
    // into different winstation, in that case, we will spend a lot time
    // figure out which winstation to use.
    // We do this here to pick up new value from RpcWinStationUpdateUserConfig
    //
    pWinStation->OriginalShadowClass = pWSConfig->Shadow;
}


/*****************************************************************************
 *
 *  ResetUserConfigData
 *
 * ENTRY:
 *    pWinStation
 *         Pointer to WINSTATION structure
 *
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
ResetUserConfigData( PWINSTATION pWinStation )
{
    PUSERCONFIG pWSConfig = &pWinStation->Config.Config.User;

    if ( pWSConfig->fInheritInitialProgram ) {
        pWSConfig->InitialProgram[0] = 0;
        pWSConfig->WorkDirectory[0] = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\regnw.c ===
/*************************************************************************
*
* nw.c
*
*  Netware security support
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop
#include <ntlsa.h>

#include <rpc.h>


#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*
 * This is the prefix for the secret object name.
 */
#define CITRIX_NW_SECRET_NAME L"CTX_NW_INFO_"


/*=============================================================================
==   Public functions
=============================================================================*/



/*=============================================================================
==   Functions Used
=============================================================================*/
NTSTATUS CreateSecretInLsa(
    PWCHAR pSecretName,
    PWCHAR pSecretData
    );

NTSTATUS
QuerySecretInLsa(
    PWCHAR pSecretName,
    PWCHAR pSecretData,
    DWORD  ByteCount
    );

BOOL
IsCallerSystem( VOID );

BOOL
IsCallerAdmin( VOID );

BOOL
TestUserForAdmin( VOID );



NTSTATUS
IsZeroterminateStringA(
    PBYTE pString,
    DWORD  dwLength
    );



NTSTATUS
IsZeroterminateStringW(
    PWCHAR pwString,
    DWORD  dwLength
    ) ;
/*=============================================================================
==   Global data
=============================================================================*/


/*******************************************************************************
 *
 *  RpcServerNWLogonSetAdmin (UNICODE)
 *
 *    Creates or updates the specified server's NWLogon Domain Administrator
 *    UserID and Password in the SAM secret objects of the specified server.
 *
 *    The caller must be ADMIN.
 *
 * ENTRY:
 *    pServerName (input)
 *       Server to store info for. This server is typically a domain controller.
 *
 *    pNWLogon (input)
 *       Pointer to a NWLOGONADMIN structure containing specified server's
 *       domain admin and password.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *    ERROR_INSUFFICIENT_BUFFER - pUserConfig buffer too small
 *      otherwise: the error code
 *
 ******************************************************************************/

BOOLEAN
RpcServerNWLogonSetAdmin(
    HANDLE        hServer,
    DWORD         *pResult,
    PWCHAR        pServerName,
    DWORD         ServerNameSize,
    PNWLOGONADMIN pNWLogon,
    DWORD         ByteCount
    )
{
    DWORD Size;
    DWORD Result;
    PWCHAR pDomain;
    UINT  LocalFlag;
    PWCHAR pSecretName;
    RPC_STATUS RpcStatus;
    WCHAR UserPass[ USERNAME_LENGTH + PASSWORD_LENGTH + DOMAIN_LENGTH + 3 ];
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    // Do minimal buffer validation

    if (pNWLogon == NULL ) {
        *pResult = STATUS_INVALID_USER_BUFFER;
        return FALSE;
    }

    if (ByteCount < sizeof(NWLOGONADMIN))
    {
        *pResult = STATUS_INVALID_USER_BUFFER;
        return FALSE;
    }

    if( pServerName == NULL ) {
        DBGPRINT(("NWLogonSetAdmin: No ServerName\n"));
        *pResult = (ULONG)STATUS_INVALID_PARAMETER;
        return( FALSE );
    }

    *pResult = IsZeroterminateStringW(pServerName, ServerNameSize  );

    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }


    pNWLogon->Username[USERNAME_LENGTH] = (WCHAR) 0;
    pNWLogon->Password[PASSWORD_LENGTH] = (WCHAR) 0;
    pNWLogon->Domain[DOMAIN_LENGTH] = (WCHAR) 0;

    //
    // Only a SYSTEM mode caller (IE: Winlogon) is allowed
    // to query this value.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT(("RpcServerNWLogonSetAdmin: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = (ULONG)STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT(("NWLogonSetAdmin Could not query local client RpcStatus 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        *pResult = (ULONG)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    if( !LocalFlag ) {
        DBGPRINT(("NWLogonSetAdmin Not a local client call\n"));
        RpcRevertToSelf();
        *pResult = (ULONG)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    if( !IsCallerAdmin() ) {
        RpcRevertToSelf();
        DBGPRINT(("RpcServerNWLogonSetAdmin: Caller Not SYSTEM\n"));
        *pResult = (ULONG)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    RpcRevertToSelf();


    if( ByteCount < sizeof(NWLOGONADMIN) ) {
        DBGPRINT(("NWLogonSetAdmin: Bad size %d\n",ByteCount));
        *pResult = (ULONG)STATUS_INFO_LENGTH_MISMATCH;
        return( FALSE );
    }

    //  check for username, and if there is one then encrypt username and pw

        TRACE0(("NWLogonSetAdmin: UserName %ws\n",pNWLogon->Username));

        // concatenate the username, password, and domain together
        wcscpy(UserPass, pNWLogon->Username);
        wcscat(UserPass, L"/");
        wcscat(UserPass, pNWLogon->Password);
        wcscat(UserPass, L"/");

        // Skip over any \\ backslashes (if a machine name was passed in)
        pDomain = pNWLogon->Domain;
        while (*pDomain == L'\\') {
            pDomain++;
        }
        wcscat(UserPass, pDomain);

        //
        // Build the secret name from the server name.
        //
        // This is because each domain will have a different entry.
        //

        // Skip over any \\ backslashes (if a machine name was passed in)
        while (*pServerName == L'\\') {
            pServerName++;
        }
        Size = wcslen(pServerName) + 1;
        Size *= sizeof(WCHAR);
        Size += sizeof(CITRIX_NW_SECRET_NAME);

        pSecretName = MemAlloc( Size );
        if( pSecretName == NULL ) {
            DBGPRINT(("NWLogonSetAdmin: No memory\n"));
            *pResult = (ULONG)STATUS_NO_MEMORY;
            return( FALSE );
        }

        wcscpy(pSecretName, CITRIX_NW_SECRET_NAME );
        wcscat(pSecretName, pServerName );

    //  check for username, and if there is one then encrypt username and pw
    if ( wcslen( pNWLogon->Username ) ) {
        //  store encrypted username
        Result = CreateSecretInLsa( pSecretName, UserPass );
    } else {
        // If there wasn't a username, clear this secret object. 
        Result = CreateSecretInLsa( pSecretName, L"");
        DBGPRINT(("TERMSRV: RpcServerNWLogonSetAdmin: UserName not supplied\n"));
    }
    MemFree( pSecretName );

    *pResult = Result;
    return( Result == STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  RpcServerQueryNWLogonAdmin
 *
 *     Query NWLOGONADMIN structure from the SAM Secret object on the given
 *     WinFrame server.
 *
 *     The caller must be SYSTEM context, IE: WinLogon.
 *
 * ENTRY:
 *    hServer (input)
 *       Rpc handle
 *
 *    pServerName (input)
 *       Server to store info for. This server is typically a domain controller.
 *
 *    pNWLogon (output)
 *       pointer to NWLOGONADMIN structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

BOOLEAN
RpcServerNWLogonQueryAdmin(
    HANDLE        hServer,
    DWORD         *pResult,
    PWCHAR        pServerName,
    DWORD         ServerNameSize,
    PNWLOGONADMIN pNWLogon,
    DWORD         ByteCount
    )
{
    PWCHAR pwch;
    DWORD  Size;
    ULONG  ulcsep;
    UINT  LocalFlag;
    NTSTATUS Status;
    PWCHAR pSecretName;
    RPC_STATUS RpcStatus;
    WCHAR encString[ USERNAME_LENGTH + PASSWORD_LENGTH + DOMAIN_LENGTH + 3 ];
    BOOLEAN  SystemCaller = FALSE;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
         return( FALSE );
    }

    // Do minimal buffer validation

   if (pNWLogon == NULL) {
       *pResult = STATUS_INVALID_USER_BUFFER;
       return FALSE;
   }

   if( ByteCount < sizeof(NWLOGONADMIN) ) {
       DBGPRINT(("NWLogonQueryAdmin: Bad size %d\n",ByteCount));
       *pResult = (ULONG)STATUS_INFO_LENGTH_MISMATCH;
       return( FALSE );
   }

   if( pServerName == NULL ) {
       DBGPRINT(("NWLogonQueryAdmin: No ServerName\n"));
       *pResult = (ULONG)STATUS_INVALID_PARAMETER;
       return( FALSE );
   }

    *pResult = IsZeroterminateStringW(pServerName, ServerNameSize  );

   if (*pResult != STATUS_SUCCESS) {
      return FALSE;
   }


   pNWLogon->Username[USERNAME_LENGTH] = (WCHAR) 0;
   pNWLogon->Password[PASSWORD_LENGTH] = (WCHAR) 0;
   pNWLogon->Domain[DOMAIN_LENGTH] = (WCHAR) 0;

   //



    //
    // Only a SYSTEM mode caller (IE: Winlogon) is allowed
    // to query this value.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT(("RpcServerNWLogonQueryAdmin: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = (ULONG)STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT(("NWLogonQueryAdmin Could not query local client RpcStatus 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        *pResult = (ULONG)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    if( !LocalFlag ) {
        DBGPRINT(("NWLogonQueryAdmin Not a local client call\n"));
        RpcRevertToSelf();
        *pResult = (ULONG)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

/* find out who is calling us system has complete access, admin can't get password, user is kicked out */
    if( IsCallerSystem() ) {
        SystemCaller = TRUE;
    }
    if( !TestUserForAdmin() && (SystemCaller != TRUE) ) {
        RpcRevertToSelf();
        DBGPRINT(("RpcServerNWLogonQueryAdmin: Caller Not SYSTEM or Admin\n"));
        *pResult = (ULONG)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    RpcRevertToSelf();


    //
    // Build the secret name from the server name.
    //
    // This is because each domain will have a different entry.
    //

    // Skip over any \\ backslashes (if a machine name was passed in)
    while (*pServerName == L'\\') {
        pServerName++;
    }
    Size = wcslen(pServerName) + 1;
    Size *= sizeof(WCHAR);
    Size += sizeof(CITRIX_NW_SECRET_NAME);

    pSecretName = MemAlloc( Size );
    if( pSecretName == NULL ) {
        DBGPRINT(("NWLogonSetAdmin: No memory\n"));
        *pResult = (ULONG)STATUS_NO_MEMORY;
        return( FALSE );
    }

    wcscpy(pSecretName, CITRIX_NW_SECRET_NAME );
    wcscat(pSecretName, pServerName );

    Status = QuerySecretInLsa(
                 pSecretName,
                 encString,
                 sizeof(encString)
                 );

    MemFree( pSecretName );

    if( !NT_SUCCESS(Status) ) {
        *pResult = Status;
        DBGPRINT(("NWLogonQueryAdmin: Error 0x%x querying secret object\n",Status));
        return( FALSE );
    }

    //  check for username/password if there is one then decrypt it
    if ( wcslen( encString ) ) {

        // Change the '/' seperator to null
        pwch = &encString[0];
        ulcsep = 0;
        while (pwch && *pwch) {
            pwch = wcschr(pwch, L'/');
            if (pwch) {
                *pwch = L'\0';
                pwch++;
                ulcsep++;
            }
        }

        //  get clear text username
        wcscpy( pNWLogon->Username, &encString[0] );

        if (ulcsep >= 1) {
            // Skip to the password
            pwch = &encString[0] + wcslen(&encString[0]) + 1;

            if( SystemCaller == TRUE ){ 
                //  get clear text password
                wcscpy( pNWLogon->Password, pwch);
            } else {
                *pNWLogon->Password = L'\0';
            }

        } else {
            *pNWLogon->Password = L'\0';
        }
        if (ulcsep >= 2) {
            // Skip to the domain string
            pwch = pwch + wcslen(pwch) + 1;

            //  get clear text domain
            wcscpy( pNWLogon->Domain, pwch);
        } else {
            *pNWLogon->Domain = L'\0';
        }

        *pResult = STATUS_SUCCESS;
        return( TRUE );
    }
    else {
        DBGPRINT(("RpcServerNWLogonQueryAdmin: zero length data\n"));

        //  set to username and password to NULL strings
        pNWLogon->Password[0] = L'\0';
        pNWLogon->Username[0] = L'\0';
        pNWLogon->Domain[0]   = L'\0';

        *pResult = STATUS_SUCCESS;
        return( TRUE );
    }
}

/*******************************************************************************
 *
 *  CreateSecretInLsa
 *
 *     Create the secret object in the LSA to keep it from prying eyes.
 *
 *     NOTE: There is no need to encode the data since it is RSA encrypted
 *           by the LSA secret routines.
 *
 * ENTRY:
 *    pSecretName (input)
 *       Secret name to create.
 *
 *    pSecretData (input)
 *       Data to store in secret
 *
 * EXIT:
 *    NTSTATUS
 *
 ******************************************************************************/

NTSTATUS
CreateSecretInLsa(
    PWCHAR pSecretName,
    PWCHAR pSecretData
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretName;
    UNICODE_STRING SecretValue;
    LSA_HANDLE SecretHandle;
    ACCESS_MASK DesiredAccess;

    if( pSecretName == NULL ) {
        DBGPRINT(("CreateSecretInLsa: NULL SecretName\n"));
        return( STATUS_INVALID_PARAMETER );
    }

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
    );

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    Status = LsaOpenPolicy(
                 NULL,    // SystemName (Local)
                 &ObjectAttributes,
                 GENERIC_ALL,
                 &PolicyHandle
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("Error 0x%x Opening Policy\n",Status));
        return( Status );
    }

    RtlInitUnicodeString( &SecretName, pSecretName );

    DesiredAccess = GENERIC_ALL;

    Status = LsaCreateSecret(
                 PolicyHandle,
                 &SecretName,
                 DesiredAccess,
                 &SecretHandle
                 );

    // Its OK if the name already exits, we will set a new value or delete
    if( Status == STATUS_OBJECT_NAME_COLLISION ) {
        TRACE0(("CreateSecretInLsa: Existing Entry, Opening\n"));
        Status = LsaOpenSecret(
                     PolicyHandle,
                     &SecretName,
                     DesiredAccess,
                     &SecretHandle
                     );
    }

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("Error 0x%x Creating Secret\n",Status));

        /* makarp; Close Policy Handle in case of LsaCreateSecrete, LsaopenSecret failures. #182787 */
        LsaClose( PolicyHandle );
        return( Status );
    }

    TRACE0(("CreateSecretInLsa: Status 0x%x\n",Status));

    if ( wcslen(pSecretData) != 0 ){
    RtlInitUnicodeString( &SecretValue, pSecretData );

    Status = LsaSetSecret( SecretHandle, &SecretValue, NULL );

    TRACE0(("CreateSecretInLsa: LsaSetSecret Status 0x%x\n",Status));

    LsaClose(SecretHandle);
    }
    else{
        Status = LsaDelete(SecretHandle);
    }

    LsaClose( PolicyHandle );

    return( Status );
}

/*******************************************************************************
 *
 *  QuerySecretInLsa
 *
 *     Query the secret object in the LSA.
 *
 * ENTRY:
 *    pSecretName (input)
 *       Secret name to create.
 *
 *    pSecretData (output)
 *       Buffer to store secret data.
 *
 *    ByteCount (input)
 *       Maximum size of buffer to store result.
 *
 * EXIT:
 *    NTSTATUS
 *
 ******************************************************************************/

NTSTATUS
QuerySecretInLsa(
    PWCHAR pSecretName,
    PWCHAR pSecretData,
    DWORD  ByteCount
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretName;
    LSA_HANDLE SecretHandle;
    ACCESS_MASK DesiredAccess;
    LARGE_INTEGER CurrentTime;
    PUNICODE_STRING pCurrentValue = NULL;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
    );

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    Status = LsaOpenPolicy(
                 NULL,    // SystemName (Local)
                 &ObjectAttributes,
                 GENERIC_ALL,
                 &PolicyHandle
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("Error 0x%x Opening Policy\n",Status));
        return( Status );
    }

    RtlInitUnicodeString( &SecretName, pSecretName );

    DesiredAccess = GENERIC_ALL;

    Status = LsaOpenSecret(
                 PolicyHandle,
                 &SecretName,
                 DesiredAccess,
                 &SecretHandle
                 );

    if( !NT_SUCCESS(Status) ) {

        /* makarp; Close Policy Handle in case of LsaopenSecret failures. #182787 */
        LsaClose( PolicyHandle );

        return( Status );
    }

    Status = LsaQuerySecret(
                 SecretHandle,
                 &pCurrentValue,
                 &CurrentTime,
                 NULL,
                 NULL
                 );

    TRACE0(("QuerySecretInLsa: Status 0x%x\n",Status));

    if( NT_SUCCESS(Status) ) {
        if (pCurrentValue != NULL) {
            if( (pCurrentValue->Length+sizeof(WCHAR)) > ByteCount ) {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            else {
                RtlMoveMemory( pSecretData, pCurrentValue->Buffer, pCurrentValue->Length );
                pSecretData[pCurrentValue->Length/sizeof(WCHAR)] = 0;
            }
            LsaFreeMemory( pCurrentValue );
        } else {
            pSecretData[0] = (WCHAR) 0;
        }

    }

    LsaClose(SecretHandle);

    LsaClose( PolicyHandle );

    TRACE0(("QuerySecretInLsa: Final Status 0x%x\n",Status));

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\sessdir.cpp ===
/****************************************************************************/
// sessdir.cpp
//
// TS Session Directory code used by TermSrv.exe.
//
// Copyright (C) 2000 Microsot Corporation
/****************************************************************************/

// precomp.h includes COM base headers.
#define INITGUID
#include "precomp.h"
#pragma hdrstop

#include "icaevent.h"

#include "sessdir.h"

#pragma warning (push, 4)

#define CLSIDLENGTH 39
#define STORESERVERNAMELENGTH 64
#define CLUSTERNAMELENGTH 64
#define OPAQUESETTINGSLENGTH 256
#define IPADDRESSLENGTH 64

#define TOTAL_STRINGS_LENGTH 640
#define USERNAME_OFFSET 0
#define DOMAIN_OFFSET 256
#define APPLICATIONTYPE_OFFSET 384

#define SINGLE_SESSION_FLAG 0x1

// Extern defined in icasrv.c.
extern "C" WCHAR gpszServiceName[];

// Extern defined in winsta.c
extern "C" LIST_ENTRY WinStationListHead;    // protected by WinStationListLock

extern "C" void PostErrorValueEvent(unsigned EventCode, DWORD ErrVal);

extern "C" BOOL IsCallerSystem( VOID );
extern "C" BOOL IsCallerAdmin( VOID );

WCHAR g_LocalServerAddress[64];
ULONG g_LocalIPAddress = 0;

BOOL g_SessDirUseServerAddr = TRUE;

DWORD g_WaitForRepopulate = TS_WAITFORREPOPULATE_TIMEOUT * 1000;

// Do not access directly.  Use *TSSD functions.
//
// These variables are used to manage synchronization with retrieving the 
// pointer to the COM object.  See *TSSD, below, for details on how they are
// used.
ITSSessionDirectory *g_pTSSDPriv = NULL;
CRITICAL_SECTION g_CritSecComObj;
CRITICAL_SECTION g_CritSecInitialize;
int g_nComObjRefCount = 0;
BOOL g_bCritSecsInitialized = FALSE;

// Do not access directly.  Use *TSSDEx functions.
//
// These variables are used to manage synchronization with retrieving the 
// pointer to the COM object.  See *TSSDEx, below, for details on how they are
// used.
ITSSessionDirectoryEx *g_pTSSDExPriv = NULL;
int g_nTSSDExObjRefCount = 0;


/****************************************************************************/
// SessDirGetLocalIPAddr
//
// Gets the local IP address of this machine.  On success, returns 0.  On
// failure, returns a failure code from the function that failed.
/****************************************************************************/
DWORD SessDirGetLocalIPAddr(WCHAR *LocalIP)
{
    DWORD NameSize;
    unsigned char *tempaddr;
    WCHAR psServerName[64];
    char psServerNameA[64];
    
    NameSize = sizeof(psServerName) / sizeof(WCHAR);
    if (GetComputerNameEx(ComputerNamePhysicalDnsHostname,
            psServerName, &NameSize)) {
        // Temporary code to get an IP address.  This should be replaced in the
        // fix to bug #323867.
        struct hostent *hptr;

        // change the wide character string to non-wide
        sprintf(psServerNameA, "%S", psServerName);

        if ((hptr = gethostbyname(psServerNameA)) == 0) {
            DWORD Err = WSAGetLastError();

            return Err;
        }
     
        tempaddr = (unsigned char *)*(hptr->h_addr_list);
        wsprintf(LocalIP, L"%d.%d.%d.%d", tempaddr[0], tempaddr[1],
        tempaddr[2], tempaddr[3]);
    }
    else {
        DWORD Err = GetLastError();

        return Err;
    }

    return 0;
}


/****************************************************************************/
// Remove preceding and succeding space in str
//
//  Assume the str is NULL terminated
/****************************************************************************/
void RemoveSpaceInStr(WCHAR *str)
{
    WCHAR *strEnd, *strTemp;
    size_t len, i;

    if ((str == NULL) || (wcslen(str) == 0)) {
        return;
    }

    len = wcslen(str); 
    // strEnd point to the last char in str
    strEnd = str + len -1;
    // Remove the succeding blank space in the str
    for (strTemp=strEnd; strTemp>=str; strTemp--) {
        if (strTemp[0] == L' ') {
            strTemp[0] = L'\0';
        }
        else {
            break;
        }
    }
    // Get the length of the new string
    len = wcslen(str);
    if (len == 0) {
        return;
    }
    // Find the 1st non-space char in str
    for (i=0; i<len; i++) {
        if (str[i] != L' ') {
            break;
        }
    }
    if (i != 0) {
        // New str length
        len -= i;
        wcsncpy(str, str + i, len);
    }
    str[len] = '\0';

    return;
}

/****************************************************************************/
// InitSessionDirectoryEx
//
// Reads values from the registry, and either initializes the session 
// directory or updates it, depending on the value of the Update parameter.
/****************************************************************************/
DWORD InitSessionDirectoryEx(DWORD UpdatePara)
{
    DWORD Len;
    DWORD Type;
    DWORD DataSize;
    BOOL hKeyTermSrvSucceeded = FALSE;
    HRESULT hr;
    DWORD ErrVal = 0;
    CLSID TSSDCLSID;
    CLSID TSSDEXCLSID;
    LONG RegRetVal;
    HKEY hKey = NULL;
    HKEY hKeyTermSrv = NULL;
    ITSSessionDirectory *pTSSD = NULL;
    ITSSessionDirectoryEx *pTSSDEx = NULL;
    BOOL bClusteringActive = FALSE;
    BOOL bThisServerIsInSingleSessionMode;
    WCHAR CLSIDStr[CLSIDLENGTH];
    WCHAR CLSIDEXStr[CLSIDLENGTH];
    WCHAR StoreServerName[STORESERVERNAMELENGTH];
    WCHAR ClusterName[CLUSTERNAMELENGTH];
    WCHAR OpaqueSettings[OPAQUESETTINGSLENGTH];
    WCHAR SDRedirectionIP[IPADDRESSLENGTH];
    unsigned char *tempaddr;
    BOOL Update = FALSE;
    BOOL ForceRejoin = FALSE;
    LONG RepopulateWaitTimeout = TS_WAITFORREPOPULATE_TIMEOUT;

    if (UpdatePara & TSSD_UPDATE)
        Update = TRUE;
    if (UpdatePara & TSSD_FORCEREJOIN) 
        ForceRejoin = TRUE;


    if (g_bCritSecsInitialized == FALSE) {
        ASSERT(FALSE);
        PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_INIT_TSSD, 
                (DWORD) E_OUTOFMEMORY);
        return (DWORD) E_OUTOFMEMORY;
    }

// trevorfo: Load only if any 1 loaded protocol needs it? Requires running
// off of StartAllWinStations.

    // No more than one thread should be doing initialization.
    EnterCriticalSection(&g_CritSecInitialize);

    // Load registry keys.
    RegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0, 
            KEY_READ, &hKeyTermSrv);
    if (RegRetVal != ERROR_SUCCESS) {
        PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_INIT_TSSD,
                RegRetVal);
        goto RegFailExit;
    }
    else {
        hKeyTermSrvSucceeded = TRUE;
    }
    
    RegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_TS_CLUSTERSETTINGS, 0,
            KEY_READ, &hKey);
    if (RegRetVal != ERROR_SUCCESS) {
        DBGPRINT(("TERMSRV: RegOpenKeyEx for ClusterSettings err %u\n",
                RegRetVal));
        goto RegFailExit;
    }

    //
    // First, we get the serious settings--active, SD location, and cluster 
    // name.
    //
    // If group policy exists for all three, use that.  Otherwise, use what
    // is in the registry.
    //

    StoreServerName[0] = L'\0';
    ClusterName[0] = L'\0';
    OpaqueSettings[0] = L'\0';
    SDRedirectionIP[0] = L'\0';

    if (g_MachinePolicy.fPolicySessionDirectoryActive) {
        bClusteringActive = g_MachinePolicy.SessionDirectoryActive;
    }
    else { //Read from registry
        Len = sizeof(bClusteringActive);
        RegQueryValueEx(hKeyTermSrv, REG_TS_SESSDIRACTIVE, NULL, &Type,
                (BYTE *)&bClusteringActive, &Len);
    }

    // Get SD server name
    if (g_MachinePolicy.fPolicySessionDirectoryLocation) {
        wcsncpy(StoreServerName, g_MachinePolicy.SessionDirectoryLocation, 
                STORESERVERNAMELENGTH);
        StoreServerName[STORESERVERNAMELENGTH - 1] = '\0';
    }
    else { //Read from registry
        // Not an error for the name to be absent or empty.
        DataSize = sizeof(StoreServerName);
        RegRetVal = RegQueryValueExW(hKey, REG_TS_CLUSTER_STORESERVERNAME,
                NULL, &Type, (BYTE *)StoreServerName, &DataSize);
        if (RegRetVal != ERROR_SUCCESS) {
            DBGPRINT(("TERMSRV: Failed RegQuery for StoreSvrName - "
                    "err=%u, DataSize=%u, type=%u\n",
                    RegRetVal, DataSize, Type));
        }
    }

    // Get SD cluster name
    if (g_MachinePolicy.fPolicySessionDirectoryClusterName) {
        wcsncpy(ClusterName, g_MachinePolicy.SessionDirectoryClusterName, 
                CLUSTERNAMELENGTH);
        ClusterName[CLUSTERNAMELENGTH - 1] = '\0';
    }
    else { //Read from registry
        // Not an error for the name to be absent or empty.
        DataSize = sizeof(ClusterName);
        RegRetVal = RegQueryValueExW(hKey, REG_TS_CLUSTER_CLUSTERNAME,
                NULL, &Type, (BYTE *)ClusterName, &DataSize);
        if (RegRetVal != ERROR_SUCCESS) {
            DBGPRINT(("TERMSRV: Failed RegQuery for ClusterName - "
                    "err=%u, DataSize=%u, type=%u\n",
                    RegRetVal, DataSize, Type));
        }
    }

    if (g_MachinePolicy.fPolicySessionDirectoryAdditionalParams) {
        wcsncpy(OpaqueSettings, 
                g_MachinePolicy.SessionDirectoryAdditionalParams, 
                OPAQUESETTINGSLENGTH);
        OpaqueSettings[OPAQUESETTINGSLENGTH - 1] = '\0';
    }
    else { //Read from registry
        // Not an error for the string to be absent or empty.
        DataSize = sizeof(OpaqueSettings);
        RegRetVal = RegQueryValueExW(hKey, REG_TS_CLUSTER_OPAQUESETTINGS,
                NULL, &Type, (BYTE *)OpaqueSettings, &DataSize);
        if (RegRetVal != ERROR_SUCCESS) {
            DBGPRINT(("TERMSRV: Failed RegQuery for OpaqueSettings - "
                    "err=%u, DataSize=%u, type=%u\n",
                    RegRetVal, DataSize, Type));
        }
    }

    // Query for the IP address used for SD redirection
    DataSize = sizeof(SDRedirectionIP);
    RegRetVal = RegQueryValueExW(hKey, REG_TS_CLUSTER_REDIRECTIONIP,
                NULL, &Type, (BYTE *)SDRedirectionIP, &DataSize);
    if (RegRetVal != ERROR_SUCCESS) {
        SDRedirectionIP[0] = L'\0';
        DBGPRINT(("TERMSRV: Failed RegQuery for RedirectionIP for SD - "
                "err=%u, DataSize=%u, type=%u\n",
                RegRetVal, DataSize, Type));
    }

    //
    // Now for the less crucial settings.
    //
    // Get the setting that determines whether the server's local address is 
    // visible to the client.  Group Policy takes precedence over registry.
    //

    if (g_MachinePolicy.fPolicySessionDirectoryExposeServerIP) {
        g_SessDirUseServerAddr = g_MachinePolicy.SessionDirectoryExposeServerIP;
    }
    else {
        Len = sizeof(g_SessDirUseServerAddr);
        RegRetVal = RegQueryValueEx(hKeyTermSrv, REG_TS_SESSDIR_EXPOSE_SERVER_ADDR, 
                NULL, &Type, (BYTE *)&g_SessDirUseServerAddr, &Len);

        if (RegRetVal == ERROR_SUCCESS) {
            //DBGPRINT(("TERMSRV: RegOpenKeyEx for allow server addr to client %d"
            //      "\n", g_SessDirUseServerAddr));
        }
        else {
            DBGPRINT(("TERMSRV: RegQueryValueEx for allow server addr to client"
                    " %d, err %u\n", g_SessDirUseServerAddr, RegRetVal));
        }
    }

    // Get the single session per user setting from GP if it's active, otherwise
    // from the registry.
    if (g_MachinePolicy.fPolicySingleSessionPerUser) {
        bThisServerIsInSingleSessionMode = 
                g_MachinePolicy.fSingleSessionPerUser;
    }
    else {
        Len = sizeof(bThisServerIsInSingleSessionMode);
        RegRetVal = RegQueryValueEx(hKeyTermSrv, 
                POLICY_TS_SINGLE_SESSION_PER_USER, NULL, &Type, 
                (BYTE *)&bThisServerIsInSingleSessionMode, &Len);

        if (RegRetVal != ERROR_SUCCESS) {
            DBGPRINT(("TERMSRV: RegQueryValueEx for single session mode"
                    ", Error %u\n", RegRetVal));
        }
    }

    //
    // Get the default wait timeout for repopulate thread to complete
    //
    Len = sizeof(RepopulateWaitTimeout);
    RegRetVal = RegQueryValueEx( hKeyTermSrv,
                                 L"RepopulateWaitTimeout",
                                 NULL,
                                 &Type,
                                 (LPBYTE)&RepopulateWaitTimeout,
                                 &Len);
    if( RegRetVal == ERROR_SUCCESS && REG_DWORD == Type ) {
        if( RepopulateWaitTimeout < 0 ) {
            g_WaitForRepopulate = INFINITE;
        }
        else {
            g_WaitForRepopulate = RepopulateWaitTimeout * 1000;
        }
    }

    DBGPRINT(("TERMSRV: WaitForRepopulateTimeout set to %d\n", g_WaitForRepopulate));


    // Get the CLSID of the session directory object to instantiate.
    CLSIDStr[0] = L'\0';
    Len = sizeof(CLSIDStr);
    RegQueryValueEx(hKeyTermSrv, REG_TS_SESSDIRCLSID, NULL, &Type,
            (BYTE *)CLSIDStr, &Len);

    // Get the CLSID of the session directory object to instantiate.
    CLSIDEXStr[0] = L'\0';
    Len = sizeof(CLSIDEXStr);
    RegQueryValueEx(hKeyTermSrv, REG_TS_SESSDIR_EX_CLSID, NULL, &Type,
            (BYTE *)CLSIDEXStr, &Len);

    RegCloseKey(hKey);
    RegCloseKey(hKeyTermSrv);

    //
    // Configuration loading complete.
    //
    // See what to do about activation/deactivation.
    //

    pTSSD = GetTSSD();
    
    if (pTSSD == NULL) {
        // This is the normal initialization path.  If Update is true here, it 
        // should be treated as a normal initialize because the COM object was 
        // unloaded.
        Update = false;
    }
    else {
        // Clustering is already active.  See whether we should deactivate it.
        if (bClusteringActive == FALSE) {
            ReleaseTSSD();  // Once here, once again at the end of the function.
            pTSSDEx = GetTSSDEx();
            if (pTSSDEx) {
                ReleaseTSSDEx();
                ReleaseTSSDEx();
                pTSSDEx = NULL;
            }
        }
    }
    if (bClusteringActive) {
        // We need to get the local machine's address to pass in to
        // the directory.
        // If SDRedirectionIP is not empty, i.e. RedirectionIP is selected in tscc or though WMI, use it,
        //  otherwise, use the IP we get from TermSrv or from winsock API
        if (SDRedirectionIP[0] == L'\0') {
            if (g_LocalIPAddress != 0) {
                tempaddr = (unsigned char *)&g_LocalIPAddress;
                wsprintf(g_LocalServerAddress, L"%d.%d.%d.%d", tempaddr[0], tempaddr[1],
                        tempaddr[2], tempaddr[3]);
            }
            else {
                //RPD-Enabled NIC is not specified in TSCC, need to get through winsock API
                ErrVal = SessDirGetLocalIPAddr(g_LocalServerAddress);
            }  
        }
        else {
            wcsncpy(g_LocalServerAddress, SDRedirectionIP, IPADDRESSLENGTH);
        }

        if (ErrVal == 0) {

            if (wcslen(CLSIDStr) > 0 &&
                    SUCCEEDED(CLSIDFromString(CLSIDStr, &TSSDCLSID))) {

                // If it's not an update, create the TSSD object.
                if (Update == false) {
                    hr = CoCreateInstance(TSSDCLSID, NULL, 
                            CLSCTX_INPROC_SERVER, IID_ITSSessionDirectory, 
                            (void **)&pTSSD);
                    if (SUCCEEDED(hr)) {
                        if (SetTSSD(pTSSD) != 0) {
                            DBGPRINT(("TERMSRV: InitSessDirEx: Could not set "
                                    "TSSD", E_FAIL));
                            pTSSD->Release();
                            pTSSD = NULL;
                            hr = E_FAIL;
                        }
                        else {
                            // Add 1 to the ref count because we're gonna use 
                            // it.
                            pTSSD = GetTSSD();
                        }
                    }
                }
                else {
                    hr = S_OK;
                }
                
                if (SUCCEEDED (hr)) {
                    // Right now the only flag we pass in to session directory
                    // says whether we are in single-session mode.
                    DWORD Flags = 0;

                    Flags |= (bThisServerIsInSingleSessionMode ? 
                            SINGLE_SESSION_FLAG : 0x0);

                    if (UpdatePara & TSSD_NOREPOPULATE) {
                        Flags |= NO_REPOPULATE_SESSION;
                    }

                    // Remove preceding and succeeding space in ClusterName
                    RemoveSpaceInStr(ClusterName);
                    if (Update == false) 
                        hr = pTSSD->Initialize(g_LocalServerAddress,
                                StoreServerName, ClusterName, OpaqueSettings,
                                Flags, RepopulateSessionDirectory, UpdateSessionDirectory);
                    else
                        hr = pTSSD->Update(g_LocalServerAddress,
                                StoreServerName, ClusterName, OpaqueSettings,
                                Flags, ForceRejoin);
                    if (FAILED(hr)) {
                        DBGPRINT(("TERMSRV: InitSessDirEx: Failed %s TSSD, "
                                "hr=0x%X\n", Update ? "update" : "init", hr));
                        ReleaseTSSD();
                        PostErrorValueEvent(
                                EVENT_TS_SESSDIR_FAIL_INIT_TSSD, hr);
                    }

                }
                else {
                    DBGPRINT(("TERMSRV: InitSessDirEx: Failed create TSSD, "
                            "hr=0x%X\n", hr));
                    PostErrorValueEvent(
                            EVENT_TS_SESSDIR_FAIL_CREATE_TSSD, hr);
                }
            }
            else {
                DBGPRINT(("TERMSRV: InitSessDirEx: Failed get or parse "
                        "CLSID\n"));
                PostErrorValueEvent(
                        EVENT_TS_SESSDIR_FAIL_GET_TSSD_CLSID, 0);

                hr = E_INVALIDARG;
            }
        }
        else {
            DBGPRINT(("TERMSRV: InitSessDirEx: Failed to get local DNS name, "
                    "lasterr=0x%X\n", ErrVal));
            PostErrorValueEvent(EVENT_TS_SESSDIR_NO_COMPUTER_DNS_NAME,
                    ErrVal);

            hr = E_FAIL;
        }

        // Initialize the other COM object, but only if the above succeeded.
        if (SUCCEEDED(hr)) {
            if (wcslen(CLSIDEXStr) > 0 &&
                    SUCCEEDED(CLSIDFromString(CLSIDEXStr, &TSSDEXCLSID))) {
                // If it's not an update, create the TSSDEX object.
                if (Update == false) {
                    hr = CoCreateInstance(TSSDEXCLSID, NULL, 
                            CLSCTX_INPROC_SERVER, IID_ITSSessionDirectoryEx, 
                            (void **)&pTSSDEx);
                    if (SUCCEEDED(hr)) {
                        if (SetTSSDEx(pTSSDEx) != 0) {
                            DBGPRINT(("TERMSRV: InitSessDirEx: Could not set "
                                    "TSSDEx\n", E_FAIL));
                            pTSSDEx->Release();
                            pTSSDEx = NULL;
                            hr = E_FAIL;
                        }
                    }
                }
                else
                    hr = S_OK;
                
                if (FAILED(hr)) {
                    DBGPRINT(("TERMSRV: InitSessDirEx: Failed create TSSDEx, "
                            "hr=0x%X\n", hr));
                    PostErrorValueEvent(
                            EVENT_TS_SESSDIR_FAIL_CREATE_TSSDEX, hr);
                }
            }
            else {
                DBGPRINT(("TERMSRV: InitSessDirEx: Failed get or parse "
                        "CLSIDSDEx\n"));
                PostErrorValueEvent(
                        EVENT_TS_SESSDIR_FAIL_GET_TSSDEX_CLSID, 0);
            }
        }
    }
    else {
        DBGPRINT(("TERMSRV: InitSessDirEx: SessDir not activated\n"));
    }

    if (pTSSD != NULL)
        ReleaseTSSD();

    // Initialization complete--someone else is allowed to enter now.
    LeaveCriticalSection(&g_CritSecInitialize);
    
    return S_OK;

RegFailExit:
    // Initialization complete--someone else is allowed to enter now.
    LeaveCriticalSection(&g_CritSecInitialize);

    if (hKeyTermSrvSucceeded)
        RegCloseKey(hKeyTermSrv);

    return (DWORD) E_FAIL;
}

/****************************************************************************/
// InitSessionDirectory
//
// Initializes the directory by loading and initializing the session directory
// object, if load balancing is enabled. We assume COM has been initialized
// on the service main thread as COINIT_MULTITHREADED.
//
// This function should only be called once ever.  It is the location of the
// initialization of the critical sections used by this module.
/****************************************************************************/
void InitSessionDirectory()
{
    BOOL br1 = FALSE;
    BOOL br2 = FALSE;

    ASSERT(g_bCritSecsInitialized == FALSE);

    // Initialize critical sections.
    __try {

        // Initialize the provider critical section to preallocate the event
        // and spin 4096 times on each try (since we don't spend very
        // long in our critical section).
        br1 = InitializeCriticalSectionAndSpinCount(&g_CritSecComObj, 
                0x80001000);
        br2 = InitializeCriticalSectionAndSpinCount(&g_CritSecInitialize,
                0x80001000);

        // Since this happens at startup time, we should not fail.
        ASSERT(br1 && br2);

        if (br1 && br2) {
            g_bCritSecsInitialized = TRUE;
        }
        else {
            DBGPRINT(("TERMSRV: InitSessDir: critsec init failed\n"));

            if (br1)
                DeleteCriticalSection(&g_CritSecComObj);
            if (br2)
                DeleteCriticalSection(&g_CritSecInitialize);
            
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_INIT_TSSD, 
                    GetLastError());
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        // Since this happens at startup time, we should not fail.
        ASSERT(FALSE);

        DBGPRINT(("TERMSRV: InitSessDir: critsec init failed\n"));

        if (br1)
            DeleteCriticalSection(&g_CritSecComObj);
        if (br2)
            DeleteCriticalSection(&g_CritSecInitialize);

        PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_INIT_TSSD, 
                GetExceptionCode());
    }

    // Now do the common initialization.
    if (g_bCritSecsInitialized)
        InitSessionDirectoryEx(0);
}

/****************************************************************************/
// UpdateSessionDirectory
//
// Updates the session directory with new settings. Assumes COM has been 
// initialized.
/****************************************************************************/
DWORD UpdateSessionDirectory(DWORD UpdatePara)
{   
    UpdatePara |= TSSD_UPDATE;
    return InitSessionDirectoryEx(UpdatePara);
}


#define REPOP_FAIL 1
#define REPOP_SUCCESS 0
/****************************************************************************/
// RepopulateSessionDirectory
//
// Repopulates the session directory.  Returns REPOP_FAIL (1) on failure,
// REPOP_SUCCESS(0) otherwise.
/****************************************************************************/
DWORD RepopulateSessionDirectory()
{
    DWORD WinStationCount = 0;
    PLIST_ENTRY Head, Next;
    DWORD i = 0;
    HRESULT hr = S_OK;
    PWINSTATION pWinStation = NULL;
    ITSSessionDirectory *pTSSD;
    WCHAR *wBuffer = NULL;

    #if DBG
    DWORD dwStartTime;
    DWORD dwEndTime;
    #endif

    // If we got here, it should be because of the session directory.
    pTSSD = GetTSSD();

    if (pTSSD != NULL) {

        // Grab WinStationListLock
        ENTERCRIT( &WinStationListLock );

        Head = &WinStationListHead;

        // Count the WinStations I care about.
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {

            pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

            //
            // In winstation reset, we only mark flag not the state but
            // we can't be sure progress of this logoff so we depends on
            // SessDirWaitForRepopulate() and let logoff thread
            // to notify session directory itself.
            //
            // 
            //if ( (pWinStation->Flags & (WSF_RESET | WSF_DELETE)) ) {
            //    continue;
            //}

            //
            // WinStation was disconnected and no user was logged on.
            //
            if( RtlLargeIntegerEqualToZero( pWinStation->LogonTime ) ) {
                // NotifyLogonWorker set winstation state and logontime after 
                // getting user SID and user/domain name, it is possible on
                // next loop, this logon thread might finish setting logontime and
                // causing we pick it up from next loop and that will
                // cause buffer overwrite, so we increment counter here
                WinStationCount += 1;
                continue;
            }

            //
            // We need to handle console session differently.
            //
            //  Action      Physical Console State      |   Remote Console State    UserName
            //  -------     ----------------------      |   --------------------    ---------           
            //  After boot  Conn                        | 
            //  Logon       Active                      |   Active                  Logon User
            //  Logoff      Conn                        |   Disc                    <Blank>
            //  Disconnect                              |   Disc                    Logon User
            //
            // We should not report to Session Directory when state is 
            // Disconnect and user name is blank.
            //
            switch (pWinStation->State) {
                case State_Disconnected:
                    if( (pWinStation->LogonId == 0) && (pWinStation->UserName[0] == 0) ) {
                        break;
                    }

                    #if DBG
                    if( (pWinStation->LogonId == 0) ) {
                        DBGPRINT( ("TERMSRV: RepopulateSessDir: Include console session to Session Directory\n") );
                    }
                    #endif

                case State_Active:
                case State_Shadow:

                    WinStationCount += 1;
                    break;
            }
        }

        // Allocate the memory for the structure to pass to the session 
        // directory.
        TSSD_RepopulateSessionInfo *rsi = new TSSD_RepopulateSessionInfo[
                WinStationCount];

        if (rsi == NULL) {
            DBGPRINT(("TERMSRV: RepopulateSessDir: mem alloc failed\n"));

            // Release WinStationListLock
            LEAVECRIT( &WinStationListLock );

            goto CleanUp;
        }

        // Allocate string arrays (for now)
        wBuffer = new WCHAR[WinStationCount * TOTAL_STRINGS_LENGTH];
        if (wBuffer == NULL) {
            DBGPRINT(("TERMSRV: RepopulateSessDir: mem alloc failed\n"));

            // Release WinStationListLock
            LEAVECRIT( &WinStationListLock );

            delete [] rsi;

            goto CleanUp;
        }

        // Set the pointers in the rsi
        for ( i = 0; i < WinStationCount; i += 1) {
            rsi[i].UserName = &(wBuffer[i * TOTAL_STRINGS_LENGTH + 
                    USERNAME_OFFSET]);
            rsi[i].Domain = &(wBuffer[i * TOTAL_STRINGS_LENGTH + 
                    DOMAIN_OFFSET]);
            rsi[i].ApplicationType = &(wBuffer[i * TOTAL_STRINGS_LENGTH + 
                    APPLICATIONTYPE_OFFSET]);
        }

        // Now populate the structure to pass in.

        // Reset index to 0
        i = 0;
        
        for ( Next = Head->Flink; Next != Head && i < WinStationCount; Next = Next->Flink ) {

            pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

            //
            // In winstation reset, we only mark flag not the state but
            // we can't be sure progress of this logoff so we depends on
            // SessDirWaitForRepopulate() and let logoff thread
            // to notify session directory itself.
            //
            //if ( (pWinStation->Flags & (WSF_RESET | WSF_DELETE)) ) {
            //    continue;
            //}

            // refer to comment above regarding console session
            if( (pWinStation->LogonId == 0) && 
                (pWinStation->State == State_Disconnected) && 
                (pWinStation->UserName[0] == 0) ) {
                continue;
            }

            //
            // WinStation was disconnected or in the middle of connect.
            // we will let notify logon do its job to report to SD
            //
            if( RtlLargeIntegerEqualToZero( pWinStation->LogonTime ) ) {
                continue;
            }

            // There are two sets of information here: First, if the session
            // is Active, we can do stuff, then we have an intentional 
            // fallthrough to the common code used by Disconnected and Active
            // sessions for the common stuff.  For now, if it's disconnected
            // we then call the update function in our COM object.
            switch (pWinStation->State) {
            case State_Active:
            case State_Shadow:
                rsi[i].State = 0;
                // NOTE INTENTIONAL FALLTHROUGH
            case State_Disconnected:
                rsi[i].TSProtocol = pWinStation->Client.ProtocolType;
                rsi[i].ResolutionWidth = pWinStation->Client.HRes;
                rsi[i].ResolutionHeight = pWinStation->Client.VRes;
                rsi[i].ColorDepth = pWinStation->Client.ColorDepth;

                // TODO: I don't get it--USERNAME_LENGTH is 20, yet in the csi,
                // TODO: it's 256.  Likewise, DOMAIN_LENGTH is 17.
                wcsncpy(rsi[i].UserName, pWinStation->UserName, 
                        USERNAME_LENGTH);
                rsi[i].UserName[USERNAME_LENGTH] = '\0';
                wcsncpy(rsi[i].Domain, pWinStation->Domain, DOMAIN_LENGTH);
                rsi[i].Domain[DOMAIN_LENGTH] = '\0';

                // TODO: Here there is a problem in that the INITIALPROGRAM
                // TODO: length is 256 + 1, but the buffer we copy into is
                // TODO: 256, hence we lose a character.
                wcsncpy(rsi[i].ApplicationType, pWinStation->
                        Client.InitialProgram, INITIALPROGRAM_LENGTH - 1);
                rsi[i].ApplicationType[INITIALPROGRAM_LENGTH - 2] = '\0';
                rsi[i].SessionID = pWinStation->LogonId;
                rsi[i].CreateTimeLow = pWinStation->LogonTime.LowPart;
                rsi[i].CreateTimeHigh = pWinStation->LogonTime.HighPart;
                if (pWinStation->State == State_Disconnected) {
                    rsi[i].DisconnectionTimeLow = pWinStation->DisconnectTime.
                            LowPart;
                    rsi[i].DisconnectionTimeHigh = pWinStation->DisconnectTime.
                            HighPart;
                    rsi[i].State = 1;
                }

                if( (pWinStation->LogonId == 0) && 
                    (pWinStation->State == State_Disconnected) && 
                    (pWinStation->UserName[0] == 0) ) {
                    break;
                }

                // make sure after we copy data over, winstation still valid.
                ASSERT( rsi[i].UserName[0] != 0 );
                ASSERT( rsi[i].Domain[0] != 0 );

                i += 1;
                break;
            }
        }

        // Release WinStationListLock
        LEAVECRIT( &WinStationListLock );

        #if DBG
        dwStartTime = GetTickCount();
        DBGPRINT( ("RepopulateSessionDirectory: Start repopulating session\n") );
        #endif

        if( i > 0 ) {
            // Call the session directory provider with our big struct.
            hr = pTSSD->Repopulate(i, rsi);
        }

        #if DBG
        dwEndTime = GetTickCount();
        DBGPRINT( ("RepopulateSessionDirectory: End repopulating %d sessions takes %d ms\n", i, dwEndTime - dwStartTime) );
        #endif

        delete [] rsi;
        delete [] wBuffer;

        if (hr == S_OK) {
            ReleaseTSSD();
            return REPOP_SUCCESS;
        }
        else {
            goto CleanUp;
        }

CleanUp:
        ReleaseTSSD();
    }

    return REPOP_FAIL;
}


/****************************************************************************/
// DestroySessionDirectory
//
// Destroys the directory, releasing any COM objects held and other memory
// used. Assumes COM has been initialized.
/****************************************************************************/
void DestroySessionDirectory()
{
    ITSSessionDirectory *pTSSD = NULL;
    ITSSessionDirectoryEx *pTSSDEx = NULL;

    pTSSD = GetTSSD();
    pTSSDEx = GetTSSDEx();
    if (pTSSD != NULL) {
        ReleaseTSSD();
        ReleaseTSSD();
    }

    if (pTSSDEx != NULL) {     
        ReleaseTSSDEx();
        ReleaseTSSDEx();
    }
}

/****************************************************************************/
// SessDirNotifyLogon
//
// Called to inform the session directory of session creation.
/****************************************************************************/
void SessDirNotifyLogon(TSSD_CreateSessionInfo *pCreateInfo)
{
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();

    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {
        hr = pTSSD->NotifyCreateLocalSession(pCreateInfo);
        if (FAILED(hr)) {
            DBGPRINT(("TERMSRV: SessDirNotifyLogon: Call failed, "
                    "hr=0x%X\n", hr));
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_UPDATE, hr);
        }

        ReleaseTSSD();
    }

}


/****************************************************************************/
// SessDirNotifyDisconnection
//
// Called on session disconnection to inform the session directory.
/****************************************************************************/
void SessDirNotifyDisconnection(DWORD SessionID, FILETIME DiscTime)
{
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();
    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {
        hr = pTSSD->NotifyDisconnectLocalSession(SessionID, DiscTime);
        if (FAILED(hr)) {
            DBGPRINT(("TERMSRV: SessDirNotifyDisc: Call failed, "
                    "hr=0x%X\n", hr));
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_UPDATE, hr);
        }

        ReleaseTSSD();
    }
}


/****************************************************************************/
// SessDirNotifyReconnection
//
// Called on session reconnection to inform the session directory.
/****************************************************************************/
void SessDirNotifyReconnection(PWINSTATION pTargetWinStation, TSSD_ReconnectSessionInfo *pReconnInfo)
{
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();

    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {
        PTS_LOAD_BALANCE_INFO pLBInfo = NULL;
        ULONG ReturnLength;
        NTSTATUS Status;
        BYTE *pRedirInfo = NULL;
        BYTE *pRedirInfoStart = NULL;
        BYTE *LBInfo = NULL; 
        DWORD LBInfoSize = 0;
        DWORD RedirInfoSize = 0;
        DWORD ServerAddrLen = 0;
        HKEY hKey = NULL;
        DWORD Type, DataSize;
        WCHAR SDRedirectionIP[IPADDRESSLENGTH];
        WCHAR *pszServerIPAddress = NULL;
        LONG RegRetVal;

        // We need to send redirection packet with LB_NOREDIRECT set to the client 
        // to let it know the server address it actually connects to (for later
        // auto-reconnect use)

        // Get the client load balance capability info. We continue onward
        // to do a session directory query only when the client supports
        // redirection and has not already been redirected to this server.
        pLBInfo = (PTS_LOAD_BALANCE_INFO)MemAlloc(sizeof(TS_LOAD_BALANCE_INFO));
        if (NULL == pLBInfo) {
            goto Cleanup;
        }

        memset(pLBInfo, 0, sizeof(TS_LOAD_BALANCE_INFO));
        Status = IcaStackIoControl(pTargetWinStation->hStack,
                IOCTL_TS_STACK_QUERY_LOAD_BALANCE_INFO,
                NULL, 0,
                pLBInfo, sizeof(TS_LOAD_BALANCE_INFO),
                &ReturnLength);
        //    Send the redirection packet to client if this is not a redirected connection
        //     and client support redirect-version4 and above
        if (NT_SUCCESS(Status) 
            && !pLBInfo->bRequestedSessionIDFieldValid &&
            (pLBInfo->ClientRedirectionVersion >= TS_CLUSTER_REDIRECTION_VERSION4)) {
            // Construct and send redirection packet
            

            // Load registry keys.
            RegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_TS_CLUSTERSETTINGS, 0,
                                    KEY_READ, &hKey);
            if (RegRetVal != ERROR_SUCCESS) {
                goto Cleanup;
            }
            // Query for the IP address used for SD redirection
            DataSize = sizeof(SDRedirectionIP);
            RegRetVal = RegQueryValueExW(hKey, REG_TS_CLUSTER_REDIRECTIONIP,
                        NULL, &Type, (BYTE *)SDRedirectionIP, &DataSize);
            RegCloseKey(hKey);
            if (RegRetVal != ERROR_SUCCESS) {
                 SDRedirectionIP[0] = L'\0';
                 DBGPRINT(("TERMSRV: Failed RegQuery for RedirectionIP for SD - "
                          "err=%u, DataSize=%u, type=%u\n",
                          RegRetVal, DataSize, Type));
                 goto Cleanup;
            }
            pszServerIPAddress = SDRedirectionIP;
                        
            RedirInfoSize = sizeof(TS_CLIENT_REDIRECTION_INFO);

            // Setup the server addr
            if (g_SessDirUseServerAddr || 
                pLBInfo->bClientRequireServerAddr) {
                ServerAddrLen =  (DWORD)((wcslen(pszServerIPAddress) + 1) *
                                  sizeof(WCHAR));
                RedirInfoSize += (ServerAddrLen + sizeof(ULONG));

                DBGPRINT(("TERMSRV: SessDirCheckRedir: size=%d, "
                         "addr=%S\n", ServerAddrLen, 
                         (WCHAR *)pszServerIPAddress));
            }
            else {
                DBGPRINT(("TERMSRV: SessDirCheckRedir no server "
                          "address: g_SessDirUseServerAddr = %d, "
                          "bClientRequireServerAddr = %d\n",
                          g_SessDirUseServerAddr, 
                          pLBInfo->bClientRequireServerAddr));
            }

            // Setup the load balance info
            if ((pLBInfo->bClientRequireServerAddr == 0) &&
                 SessDirGetLBInfo(
                    pszServerIPAddress, &LBInfoSize, &LBInfo)) {
                        
                if (LBInfo) {
                    DBGPRINT(("TERMSRV: SessDirCheckRedir: size=%d, "
                              "info=%S\n", LBInfoSize, 
                              (WCHAR *)LBInfo));
                    RedirInfoSize += (LBInfoSize + sizeof(ULONG));
                }
            }
            else {
                DBGPRINT(("TERMSRV: SessDirCheckRedir failed: "
                          "size=%d, info=%S\n", LBInfoSize, 
                         (WCHAR *)LBInfo));
                        
            }

            // Setup the load balance IOCTL
            pRedirInfoStart = pRedirInfo = new BYTE[RedirInfoSize];

            TS_CLIENT_REDIRECTION_INFO *pClientRedirInfo =
                (TS_CLIENT_REDIRECTION_INFO *)pRedirInfo;

            if (pRedirInfo != NULL) {
                            
                pClientRedirInfo->Flags = 0;

                pRedirInfo += sizeof(TS_CLIENT_REDIRECTION_INFO);

                if (ServerAddrLen) {
                    *((ULONG UNALIGNED*)(pRedirInfo)) = 
                                    ServerAddrLen;
                                
                    memcpy((BYTE*)(pRedirInfo + sizeof(ULONG)),
                                  (BYTE*)pszServerIPAddress,
                                  ServerAddrLen);

                    pRedirInfo += ServerAddrLen + sizeof(ULONG);
                                
                    pClientRedirInfo->Flags |= TARGET_NET_ADDRESS;
                }

                if (LBInfoSize) {
                    *((ULONG UNALIGNED*)(pRedirInfo)) = LBInfoSize;
                    memcpy((BYTE*)(pRedirInfo + sizeof(ULONG)), 
                           LBInfo, LBInfoSize);

                    pRedirInfo += LBInfoSize + sizeof(ULONG);

                    pClientRedirInfo->Flags |= LOAD_BALANCE_INFO;
                }
                pClientRedirInfo->Flags |= LB_NOREDIRECT;
            }
            else {
                Status = STATUS_NO_MEMORY;

                goto Cleanup;
            }

            Status = IcaStackIoControl(pTargetWinStation->hStack,
                        IOCTL_TS_STACK_SEND_CLIENT_REDIRECTION,
                        pClientRedirInfo, RedirInfoSize,
                        NULL, 0,
                        &ReturnLength);

            if (NT_SUCCESS(Status)) {
                // do nothing here
            }
            else {
                // The stack returned failure. Continue
                // the current connection.
                TRACE((hTrace,TC_ICASRV,TT_API1,
                        "TERMSRV: Failed STACK_CLIENT_REDIR, "
                        "SessionID=%u, Status=0x%X\n",
                        pTargetWinStation->LogonId, Status));
            }
                        
Cleanup:
            // Cleanup the buffers
            if (LBInfo != NULL) {
                 SysFreeString((BSTR)LBInfo);
                 LBInfo = NULL;
            }

            if (pRedirInfo != NULL) {
                delete [] pRedirInfoStart;
                pRedirInfoStart = NULL;
            }        
        }
        if (pLBInfo != NULL) {
             MemFree(pLBInfo);
             pLBInfo = NULL;
        }

        hr = pTSSD->NotifyReconnectLocalSession(pReconnInfo);
        if (FAILED(hr)) {
            DBGPRINT(("TERMSRV: SessDirNotifyReconn: Call failed, "
                    "hr=0x%X\n", hr));
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_UPDATE, hr);
        }

        ReleaseTSSD();
    }
}


/****************************************************************************/
// SessDirNotifyLogoff
//
// Called on logoff to inform the session directory.
/****************************************************************************/
void SessDirNotifyLogoff(DWORD SessionID)
{
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();

    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {
        hr = pTSSD->NotifyDestroyLocalSession(SessionID);
        if (FAILED(hr)) {
            DBGPRINT(("TERMSRV: SessDirNotifyLogoff: Call failed, "
                    "hr=0x%X\n", hr));
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_UPDATE, hr);
        }

        ReleaseTSSD();
    }
}


/****************************************************************************/
// SessDirNotifyReconnectPending
//
// Called to inform the session directory a session should start soon on
// another machine in the cluster (for Directory Integrity Service).
/****************************************************************************/
void SessDirNotifyReconnectPending(WCHAR *ServerName)
{
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();

    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {
        hr = pTSSD->NotifyReconnectPending(ServerName);
        if (FAILED(hr)) {
            DBGPRINT(("TERMSRV: SessDirNotifyReconnectPending: Call failed, "
                    "hr=0x%X\n", hr));
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_UPDATE, hr);
        }

        ReleaseTSSD();
    }
}


/****************************************************************************/
// SessDirWaitForRepopulate
//
// Wait for session directory to complete repopulate
/****************************************************************************/
void SessDirWaitForRepopulate()
{
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    #if DBG
    DWORD dwStartTime;
    #endif

    // no waiting so just return
    if( g_WaitForRepopulate == 0 ) {
        return;
    }

    pTSSD = GetTSSD();

    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {

        #if DBG
        dwStartTime = GetTickCount();
        #endif

        hr = pTSSD->WaitForRepopulate(g_WaitForRepopulate);
        if (FAILED(hr)) {
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_UPDATE, hr);
            DBGPRINT(("TERMSRV: WaitForRepopulate: Call failed, "
                    "hr=0x%X\n", hr));
        }

        #if DBG
        DBGPRINT(("SessDirWaitForRepopulate() takes %d ms\n", GetTickCount() - dwStartTime) );
        #endif

        ReleaseTSSD();
    }
}


/****************************************************************************/
// SessDirGetDisconnectedSessions
//
// Returns in the provided TSSD_DisconnectedSessionInfo buffer space
// up to TSSD_MaxDisconnectedSessions' worth of disconnected sessions
// from the session directory. Returns the number of sessions returned, which
// can be zero.
/****************************************************************************/
unsigned SessDirGetDisconnectedSessions(
        WCHAR *UserName,
        WCHAR *Domain,
        TSSD_DisconnectedSessionInfo Info[TSSD_MaxDisconnectedSessions])
{
    DWORD NumSessions = 0;
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();

    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {
        hr = pTSSD->GetUserDisconnectedSessions(UserName, Domain,
                &NumSessions, Info);
        if (FAILED(hr)) {
            DBGPRINT(("TERMSRV: SessDirGetDiscSessns: Call failed, "
                    "hr=0x%X\n", hr));
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_QUERY, hr);
        }
        ReleaseTSSD();
    }

    return NumSessions;
}

/****************************************************************************/
// SessDirGetLBInfo
//
// Call the SessDirEx COM object interface, using the server address, get
// the opaque load balance info back, will send the info to the client.
/****************************************************************************/
BOOL SessDirGetLBInfo(
        WCHAR *ServerAddress, 
        DWORD* pLBInfoSize,
        PBYTE* pLBInfo)        
{
    ITSSessionDirectoryEx *pTSSDEx;
    HRESULT hr;
    static BOOL EventLogged = FALSE;

    *pLBInfoSize = 0;
    *pLBInfo = NULL;

    pTSSDEx = GetTSSDEx();

    if (pTSSDEx != NULL) {
        hr = pTSSDEx->GetLoadBalanceInfo(ServerAddress, (BSTR *)pLBInfo);

        if(SUCCEEDED(hr))
        {
             *pLBInfoSize = SysStringByteLen((BSTR)(*pLBInfo));
        }
        else 
        {
            DBGPRINT(("TERMSRV: SessDirGetLBInfo: Call failed, "
                    "hr=0x%X\n", hr));
            if (EventLogged == FALSE) {
                PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_LBQUERY, hr);
                EventLogged = TRUE;
            }
        }

        ReleaseTSSDEx();
    }
    else {
        DBGPRINT(("TERMSRV: SessDirGetLBInfo: Call failed, pTSSDEx is NULL "));
        hr = E_FAIL;
    }

    return SUCCEEDED(hr);
}


#define SERVER_ADDRESS_LENGTH 64
/****************************************************************************/
// IsSameAsCurrentIP
//
// Determines whether the IP address given is the same as the current machine.
// Returning FALSE in case of error is not a problem--the client will
// just get redirected right back here.
/****************************************************************************/
BOOL IsSameAsCurrentIP(WCHAR *SessionIPAddress)
{
    // Get the server adresses.
    int RetVal;
    unsigned long NumericalSessionIPAddr = 0;
    char  achComputerName[256];
    DWORD dwComputerNameSize;
    PBYTE pServerAddrByte;
    PBYTE pSessionAddrByte;
    ADDRINFO *AddrInfo, *AI;
    struct sockaddr_in *pIPV4addr;
    char AnsiSessionIPAddress[SERVER_ADDRESS_LENGTH];

    // Compute integer for the server address.
    // First, get ServerAddress as an ANSI string.
    RetVal = WideCharToMultiByte(CP_ACP, 0, SessionIPAddress, -1, 
            AnsiSessionIPAddress, SERVER_ADDRESS_LENGTH, NULL, NULL);
    if (RetVal == 0) {
        DBGPRINT(("IsSameServerIP: WideCharToMB failed %d\n", GetLastError()));
        return FALSE;
    }

    // Now, get the numerical server address.
    // Now, use inet_addr to turn into an unsigned long.
    NumericalSessionIPAddr = inet_addr(AnsiSessionIPAddress);
    if (NumericalSessionIPAddr == INADDR_NONE) {
        DBGPRINT(("IsSameServerIP: inet_addr failed\n"));
        return FALSE;
    }

    pSessionAddrByte = (PBYTE) &NumericalSessionIPAddr;

    dwComputerNameSize = sizeof(achComputerName);
    if (!GetComputerNameA(achComputerName,&dwComputerNameSize)) {
        return FALSE;
    }

    RetVal = getaddrinfo(achComputerName, NULL, NULL, &AddrInfo);
    if (RetVal != 0) {
        DBGPRINT (("Cannot resolve address, error: %d\n", RetVal));
        return FALSE;
    } 
    else {
        // Compare all server adresses with client till a match is found.
        // Currently only works for IPv4.
        for (AI = AddrInfo; AI != NULL; AI = AI->ai_next) {

            if (AI->ai_family == AF_INET) {

                if (AI->ai_addrlen >= sizeof(struct sockaddr_in)) {
                    pIPV4addr = (struct sockaddr_in *) AI->ai_addr;
                    pServerAddrByte = (PBYTE)&pIPV4addr->sin_addr;
                    if (RtlEqualMemory(pSessionAddrByte, pServerAddrByte, 4)) {
                        return TRUE;
                    }
                }
                
            }
        }
        
    }

    return FALSE;
}

/****************************************************************************/
// SessDirCheckRedirectClient
//
// Performs the set of steps needed to get the client's clustering
// capabilities, get the disconnected session list, and apply client
// redirection policy. Returns TRUE if the client was redirected, FALSE if
// the current WinStation transfer should be continued.
/****************************************************************************/
BOOL SessDirCheckRedirectClient(
        PWINSTATION pTargetWinStation,
        TS_LOAD_BALANCE_INFO *pLBInfo)
{
    BOOL rc = FALSE;
    ULONG ReturnLength;
    unsigned i, NumSessions;
    NTSTATUS Status;
    ITSSessionDirectory *pTSSD;
    BOOL fLogonUsingUPN = FALSE;
    BOOL fNeedToRedirect = FALSE;

    pTSSD = GetTSSD();

    pTargetWinStation->NumClusterDiscSessions = 0;

    if (pTSSD != NULL) {
        if (pLBInfo->bClientSupportsRedirection &&
                !pLBInfo->bRequestedSessionIDFieldValid) {
            // The client has not been redirected to this machine. See if we
            // have disconnected sessions in the database for redirecting.
            NumSessions = pTargetWinStation->NumClusterDiscSessions =
                    SessDirGetDisconnectedSessions(
                    pLBInfo->UserName,
                    pLBInfo->Domain,
                    pTargetWinStation->ClusterDiscSessions);
            if (pTargetWinStation->NumClusterDiscSessions > 0) {
                
// trevorfo: Applying policy here for reconnection to only one session
// (whichever is first).  More general policy requires a selection UI at the 
// client or in WinLogon.

                // Find the first session in the list that matches the
                // client's session requirements. Namely, we filter based
                // on the client's TS protocol, wire protocol, and application
                // type.
                for (i = 0; i < NumSessions; i++) {
                    if ((pLBInfo->ProtocolType ==
                            pTargetWinStation->ClusterDiscSessions[i].
                            TSProtocol) &&
                            (!_wcsicmp(pLBInfo->InitialProgram,
                            pTargetWinStation->ClusterDiscSessions[i].
                            ApplicationType))) {
                        break;
                    }
                }
                if (i == NumSessions) {
                    TRACE((hTrace,TC_ICASRV,TT_API1,
                            "TERMSRV: SessDirCheckRedir: No matching sessions "
                            "found\n"));
                }
                else {
                    // If the session is not on this server, redirect the
                    // client. See notes above about use of
                    // _IcaStackIoControl().
                    
                    if (!IsSameAsCurrentIP(pTargetWinStation->
                            ClusterDiscSessions[i].ServerAddress)) {
                        fNeedToRedirect = TRUE;
                    }
                }
            }

            if (fNeedToRedirect ||
                (pLBInfo->ClientRedirectionVersion >= TS_CLUSTER_REDIRECTION_VERSION4)) {
            
                BYTE *pRedirInfo = NULL;
                BYTE *pRedirInfoStart = NULL;
                BYTE *LBInfo = NULL; 
                DWORD LBInfoSize = 0;
                DWORD RedirInfoSize = 0;
                DWORD ServerAddrLen = 0;
                DWORD DomainSize = 0;
                DWORD UserNameSize = 0;
                DWORD PasswordSize = 0;
                HKEY hKey = NULL;
                DWORD Type, DataSize;
                WCHAR SDRedirectionIP[IPADDRESSLENGTH];
                WCHAR *pszServerIPAddress = NULL;
                LONG RegRetVal;

                // Even fNeedToRedirect is FALSE, we still need to send redirection packet
                //  with LB_NOREDIRECT set to the client to let it know the server address
                //  it actually connects to (for later auto-reconnect use)
                if (!fNeedToRedirect) {
                    // Load registry keys.
                    RegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_TS_CLUSTERSETTINGS, 0,
                                            KEY_READ, &hKey);
                    if (RegRetVal != ERROR_SUCCESS) {
                        goto Cleanup;
                    }
                    // Query for the IP address used for SD redirection
                    DataSize = sizeof(SDRedirectionIP);
                    RegRetVal = RegQueryValueExW(hKey, REG_TS_CLUSTER_REDIRECTIONIP,
                            NULL, &Type, (BYTE *)SDRedirectionIP, &DataSize);
                    RegCloseKey(hKey);
                    if (RegRetVal != ERROR_SUCCESS) {
                        SDRedirectionIP[0] = L'\0';
                        DBGPRINT(("TERMSRV: Failed RegQuery for RedirectionIP for SD - "
                            "err=%u, DataSize=%u, type=%u\n",
                            RegRetVal, DataSize, Type));
                        goto Cleanup;
                    }
                    pszServerIPAddress = SDRedirectionIP;
                }
                else {
                    pszServerIPAddress = pTargetWinStation->ClusterDiscSessions[i].ServerAddress;
                }
                        
                RedirInfoSize = sizeof(TS_CLIENT_REDIRECTION_INFO);

                // Setup the server addr
                if (g_SessDirUseServerAddr || 
                    pLBInfo->bClientRequireServerAddr) {
                    ServerAddrLen =  (DWORD)((wcslen(pszServerIPAddress) + 1) *
                                    sizeof(WCHAR));
                    RedirInfoSize += (ServerAddrLen + sizeof(ULONG));

                    DBGPRINT(("TERMSRV: SessDirCheckRedir: size=%d, "
                             "addr=%S\n", ServerAddrLen, 
                             (WCHAR *)pszServerIPAddress));
                }
                else {
                    DBGPRINT(("TERMSRV: SessDirCheckRedir no server "
                              "address: g_SessDirUseServerAddr = %d, "
                              "bClientRequireServerAddr = %d\n",
                              g_SessDirUseServerAddr, 
                              pLBInfo->bClientRequireServerAddr));
                }

                // Setup the load balance info
                if ((pLBInfo->bClientRequireServerAddr == 0) &&
                     SessDirGetLBInfo(
                        pszServerIPAddress, &LBInfoSize, &LBInfo)) {
                        
                    if (LBInfo) {
                        DBGPRINT(("TERMSRV: SessDirCheckRedir: size=%d, "
                                  "info=%S\n", LBInfoSize, 
                                  (WCHAR *)LBInfo));
                        RedirInfoSize += (LBInfoSize + sizeof(ULONG));
                    }
                }
                else {
                    DBGPRINT(("TERMSRV: SessDirCheckRedir failed: "
                              "size=%d, info=%S\n", LBInfoSize, 
                             (WCHAR *)LBInfo));
                        
                }

                // Only send domain, username and password info if client
                // redirection version is 3 and above
                if ((pLBInfo->ClientRedirectionVersion >= TS_CLUSTER_REDIRECTION_VERSION3) &&
                    fNeedToRedirect) {
                    //domain
                    if (pLBInfo->Domain) {
                        DomainSize = (DWORD)(wcslen(pLBInfo->Domain) + 1) * sizeof(WCHAR);
                        RedirInfoSize += DomainSize + sizeof(ULONG);
                    }

                    if( pTargetWinStation && pTargetWinStation->pNewNotificationCredentials &&
                        wcschr(pTargetWinStation->pNewNotificationCredentials->UserName, L'@') ) {

                        // User is logon using UPN address, we need to send back same UPN in case the target machine
                        // does not have the domain in the logon dialog list.

                        // WINLOGON calls TS's WinStationUpdateClientCachedCredentialsWorker() which sets up
                        // UPN address
                        UserNameSize = (DWORD)(wcslen(pTargetWinStation->pNewNotificationCredentials->UserName) + 1 ) * sizeof(WCHAR);  
                        RedirInfoSize += UserNameSize + sizeof(ULONG);
                        fLogonUsingUPN = TRUE;

                    }
                    else if (pLBInfo->UserName) {
                        UserNameSize = (DWORD)(wcslen(pLBInfo->UserName) + 1) * sizeof(WCHAR);
                        RedirInfoSize += UserNameSize + sizeof(ULONG);
                    }

                    //password
                    if (pLBInfo->Password) {
                        PasswordSize = (DWORD)(wcslen(pLBInfo->Password) + 1) * sizeof(WCHAR);
                        RedirInfoSize += PasswordSize + sizeof(ULONG);
                    }
                }

                // Setup the load balance IOCTL
                pRedirInfoStart = pRedirInfo = new BYTE[RedirInfoSize];

                TS_CLIENT_REDIRECTION_INFO *pClientRedirInfo =
                    (TS_CLIENT_REDIRECTION_INFO *)pRedirInfo;

                if (pRedirInfo != NULL) {
                            
                    if (fNeedToRedirect) {
                        pClientRedirInfo->SessionID = 
                              pTargetWinStation->ClusterDiscSessions[i].
                              SessionID;
                    }

                    pClientRedirInfo->Flags = 0;

                    pRedirInfo += sizeof(TS_CLIENT_REDIRECTION_INFO);

                    if (ServerAddrLen) {
                        *((ULONG UNALIGNED*)(pRedirInfo)) = 
                                        ServerAddrLen;
                                
                        memcpy((BYTE*)(pRedirInfo + sizeof(ULONG)),
                                     (BYTE*)pszServerIPAddress,
                                     ServerAddrLen);

                        pRedirInfo += ServerAddrLen + sizeof(ULONG);
                                
                        pClientRedirInfo->Flags |= TARGET_NET_ADDRESS;
                    }

                    if (LBInfoSize) {
                        *((ULONG UNALIGNED*)(pRedirInfo)) = LBInfoSize;
                        memcpy((BYTE*)(pRedirInfo + sizeof(ULONG)), 
                               LBInfo, LBInfoSize);

                        pRedirInfo += LBInfoSize + sizeof(ULONG);

                        pClientRedirInfo->Flags |= LOAD_BALANCE_INFO;
                    }

                    if (UserNameSize) {
                        *((ULONG UNALIGNED*)(pRedirInfo)) = UserNameSize;

                        if( TRUE == fLogonUsingUPN ) {
                            memcpy((BYTE*)(pRedirInfo + sizeof(ULONG)), 
                                  (BYTE*)(pTargetWinStation->pNewNotificationCredentials->UserName), UserNameSize);
                        }
                        else {
                            memcpy((BYTE*)(pRedirInfo + sizeof(ULONG)), 
                                  (BYTE*)(pLBInfo->UserName), UserNameSize);
                        }

                        pRedirInfo += UserNameSize + sizeof(ULONG);

                        pClientRedirInfo->Flags |= LB_USERNAME;
                    }

                    if (DomainSize) {
                        *((ULONG UNALIGNED*)(pRedirInfo)) = DomainSize;
                        memcpy((BYTE*)(pRedirInfo + sizeof(ULONG)), 
                               (BYTE*)(pLBInfo->Domain), DomainSize);

                        pRedirInfo += DomainSize + sizeof(ULONG);

                        pClientRedirInfo->Flags |= LB_DOMAIN;
                     }

                    if (PasswordSize) {
                        *((ULONG UNALIGNED*)(pRedirInfo)) = PasswordSize;
                        memcpy((BYTE*)(pRedirInfo + sizeof(ULONG)), 
                                (BYTE*)(pLBInfo->Password), PasswordSize);

                        pRedirInfo += PasswordSize + sizeof(ULONG);

                        pClientRedirInfo->Flags |= LB_PASSWORD;
                    }

                    if (pTargetWinStation->fSmartCardLogon) {
                        pClientRedirInfo->Flags |= LB_SMARTCARD_LOGON;
                    }

                    if (!fNeedToRedirect) {
                        pClientRedirInfo->Flags |= LB_NOREDIRECT;
                    }
                }
                else {
                    Status = STATUS_NO_MEMORY;

                    // The stack returned failure. Continue
                    // the current connection.
                    TRACE((hTrace,TC_ICASRV,TT_API1,
                           "TERMSRV: Failed STACK_CLIENT_REDIR, "
                           "SessionID=%u, Status=0x%X\n",
                           pTargetWinStation->LogonId, Status));
                    PostErrorValueEvent(
                                    EVENT_TS_SESSDIR_FAIL_CLIENT_REDIRECT,
                                    Status);

                    goto Cleanup;
                }

                Status = IcaStackIoControl(pTargetWinStation->hStack,
                            IOCTL_TS_STACK_SEND_CLIENT_REDIRECTION,
                            pClientRedirInfo, RedirInfoSize,
                            NULL, 0,
                            &ReturnLength);

                if (NT_SUCCESS(Status)) {
                    // Notify session directory
                    // 
                    // There is a relatively benign race condition here.
                    // If the second server logs in the user completely,
                    // it may end up hitting the session directory
                    // before this statement executes.  In that case, 
                    // the directory integrity service may end up 
                    // pinging the machine once.
                    if (fNeedToRedirect) {
                        SessDirNotifyReconnectPending(pTargetWinStation->
                            ClusterDiscSessions[i].ServerAddress);

                        // Drop the current connection.
                        rc = TRUE;
                    }
                }
                else {
                    // The stack returned failure. Continue
                    // the current connection.
                    TRACE((hTrace,TC_ICASRV,TT_API1,
                            "TERMSRV: Failed STACK_CLIENT_REDIR, "
                            "SessionID=%u, Status=0x%X\n",
                            pTargetWinStation->LogonId, Status));
                    PostErrorValueEvent(
                        EVENT_TS_SESSDIR_FAIL_CLIENT_REDIRECT,
                        Status);
                    }
                        
Cleanup:
                // Cleanup the buffers
                if (LBInfo != NULL) {
                     SysFreeString((BSTR)LBInfo);
                     LBInfo = NULL;
                }

                if (pRedirInfo != NULL) {
                    delete [] pRedirInfoStart;
                    pRedirInfoStart = NULL;
                }
            }
        }
        ReleaseTSSD();
    }

    return rc;
}

/****************************************************************************/
// SetTSSD
//
// These three functions ensure protected access to the session directory 
// provider at all times.  SetTSSD sets the pointer and increments the
// reference count to 1.
//
// SetTSSD returns:
//  0 on success
//  -1 if failed because there was still a reference count on the COM object.
//   This could happen if set was called too quickly after the final release
//   to attempt to delete the object, as there still may be pending calls using
//   the COM object.
//  -2 if failed because the critical section is not initialized.  This 
//   shouldn't be reached in normal operation, because Init is the only 
//   function that can call Set, and it bails if it fails the creation of the
//   critical section.
/****************************************************************************/
int SetTSSD(ITSSessionDirectory *pTSSD)
{
    int retval = 0;

    if (g_bCritSecsInitialized != FALSE) {
        EnterCriticalSection(&g_CritSecComObj);

        if (g_nComObjRefCount == 0) {
            ASSERT(g_pTSSDPriv == NULL);
            
            g_pTSSDPriv = pTSSD;
            g_nComObjRefCount = 1;
        }
        else {
            DBGPRINT(("TERMSRV: SetTSSD: obj ref count not 0!\n"));
            retval = -1;
        }

        LeaveCriticalSection(&g_CritSecComObj);
    }
    else {
        ASSERT(g_bCritSecsInitialized == TRUE);
        retval = -2;
    }

    return retval;
}


/****************************************************************************/
// GetTSSD
//
// GetTSSD returns a pointer to the session directory provider, if any, and
// increments the reference count if there is one.
/****************************************************************************/
ITSSessionDirectory *GetTSSD()
{
    ITSSessionDirectory *pTSSD = NULL;

    if (g_bCritSecsInitialized != FALSE) {
        EnterCriticalSection(&g_CritSecComObj);

        if (g_pTSSDPriv != NULL) {
            g_nComObjRefCount += 1;
        }
        else {
            ASSERT(g_nComObjRefCount == 0);
        }

        pTSSD = g_pTSSDPriv;
        LeaveCriticalSection(&g_CritSecComObj);
    }

    return pTSSD;
}


/****************************************************************************/
// ReleaseTSSD
//
// ReleaseTSSD decrements the reference count of the session directory provider
// after a thread has finished using it, or when it is going to be deleted.
//
// If the reference count goes to zero, the pointer to the session directory
// provider is set to NULL.
/****************************************************************************/
void ReleaseTSSD()
{
    ITSSessionDirectory *killthispTSSD = NULL;

    if (g_bCritSecsInitialized != FALSE) {
        EnterCriticalSection(&g_CritSecComObj);

        ASSERT(g_nComObjRefCount != 0);

        if (g_nComObjRefCount != 0) {
            g_nComObjRefCount -= 1;

            if (g_nComObjRefCount == 0) {
                killthispTSSD = g_pTSSDPriv;
                g_pTSSDPriv = NULL;
            }
        }
        
        LeaveCriticalSection(&g_CritSecComObj);
    }
    // Now, release the session directory provider if our temppTSSD is NULL.
    // We didn't want to release it while holding the critical section because
    // that might create a deadlock in the recovery thread.  Well, it did once.
    if (killthispTSSD != NULL)
        killthispTSSD->Release();

}

/****************************************************************************/
// SetTSSDEx
//
// These three functions ensure protected access to the session directory 
// provider at all times.  SetTSSDEx sets the pointer and increments the
// reference count to 1.
//
// SetTSSDEx returns:
//  0 on success
//  -1 if failed because there was still a reference count on the COM object.
//   This could happen if set was called too quickly after the final release
//   to attempt to delete the object, as there still may be pending calls using
//   the COM object.
/****************************************************************************/
int SetTSSDEx(ITSSessionDirectoryEx *pTSSDEx)
{
    int retval = 0;
    
    EnterCriticalSection(&g_CritSecComObj);

    if (g_nTSSDExObjRefCount == 0) {
        ASSERT(g_pTSSDExPriv == NULL);
        
        g_pTSSDExPriv = pTSSDEx;
        g_nTSSDExObjRefCount = 1;
    }
    else {
        DBGPRINT(("TERMSRV: SetTSSDEx: obj ref count not 0!\n"));
        retval = -1;
    }

    LeaveCriticalSection(&g_CritSecComObj);

    return retval;
}

/****************************************************************************/
// GetTSSDEx
//
// GetTSSDEx returns a pointer to the session directory provider, if any, and
// increments the reference count if there is one.
/****************************************************************************/
ITSSessionDirectoryEx *GetTSSDEx()
{
    ITSSessionDirectoryEx *pTSSDEx = NULL;

    if (g_bCritSecsInitialized != FALSE) {
        EnterCriticalSection(&g_CritSecComObj);

        if (g_pTSSDExPriv != NULL) {
            g_nTSSDExObjRefCount += 1;
        }
        else {
            ASSERT(g_nTSSDExObjRefCount == 0);
        }

        pTSSDEx = g_pTSSDExPriv;
        LeaveCriticalSection(&g_CritSecComObj);
    }

    return pTSSDEx;
}

/****************************************************************************/
// ReleaseTSSDEx
//
// ReleaseTSSDEx decrements the reference count of the session directory
// provider after a thread has finished using it, or when it is going to be 
// deleted.
//
// If the reference count goes to zero, the pointer to the session directory 
// provider is set to NULL.
/****************************************************************************/
void ReleaseTSSDEx()
{
    ITSSessionDirectoryEx *killthispTSSDEx = NULL;
    
    EnterCriticalSection(&g_CritSecComObj);

    ASSERT(g_nTSSDExObjRefCount != 0);
    if (g_nTSSDExObjRefCount != 0) {
        g_nTSSDExObjRefCount -= 1;

        if (g_nTSSDExObjRefCount == 0) {
            killthispTSSDEx = g_pTSSDExPriv;
            g_pTSSDExPriv = NULL;
        }
    }
    
    LeaveCriticalSection(&g_CritSecComObj);

    // Now, release the session directory provider if our temppTSSD is NULL.
    // We didn't want to release it while holding the critical section because
    // that might create a deadlock in the recovery thread.  Well, it did once.
    if (killthispTSSDEx != NULL)
        killthispTSSDEx->Release();
}



/*****************************************************************************
  ****************************************************************************/
DWORD SessDirOpenSessionDirectory( LPWSTR pszServerName )
{
    ITSSessionDirectory *pTSSD = NULL;
    DWORD Len;
    DWORD Type;
    WCHAR CLSIDStr[CLSIDLENGTH + 1]; // CLSIDLENGTH is limit, one extra for NULL
    CLSID TSSDCLSID;
    DWORD Status = ERROR_SUCCESS;
    HKEY hKeyTermSrv = NULL;
    HRESULT hr = S_OK;

    // Load registry keys.
    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0, 
                       KEY_READ, &hKeyTermSrv);
    if (Status != ERROR_SUCCESS) 
    {
        // Return Error Code as it is
        goto Exit;
    }

    CLSIDStr[CLSIDLENGTH] = L'\0';

    // Get the CLSID of the session directory object to instantiate.
    Len = sizeof(CLSIDStr) - sizeof(CLSIDStr[0]);
    Status = RegQueryValueEx(hKeyTermSrv, REG_TS_SESSDIRCLSID, NULL, &Type,
                (BYTE *)CLSIDStr, &Len);

    if( Status != ERROR_SUCCESS )
    {
        // Return Error Code as it is
        goto Exit;
    }

    if( Type != REG_SZ || wcslen(CLSIDStr) == 0 ) 
    {
        // we have invalid data in registry, likely cause is setup not done.
        Status = ERROR_INVALID_DATA;
        goto Exit;
    }

    hr = CLSIDFromString(CLSIDStr, &TSSDCLSID);
    if ( SUCCEEDED(hr) )
    {
        // Get the instance of TSSessionDirectory interface
        hr = CoCreateInstance(TSSDCLSID, NULL, 
                            CLSCTX_INPROC_SERVER, IID_ITSSessionDirectory, 
                            (void **)&pTSSD);
        if (SUCCEEDED(hr)) {
            // Call PingSD to make the RPC call to SD
            hr = pTSSD->PingSD(pszServerName);
            pTSSD->Release();
        }
    }

    // none of code returns HRESULT.
    Status = HRESULT_CODE(hr);

Exit:
    if (hKeyTermSrv) {
        RegCloseKey(hKeyTermSrv);
    }

    return Status;
}

#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\version.c ===
/****************************************************************************/
// version.c
//
// TermSrv version setting functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   Vars
=============================================================================*/
PWCHAR pProductOemInfo[] = {
    REG_CITRIX_OEMID,
    REG_CITRIX_OEMNAME,
    REG_CITRIX_PRODUCTNAME,
    REG_CITRIX_PRODUCTVERSION,
    (PWCHAR) NULL,
};


/*******************************************************************************
// UpdateOemAndProductInfo
//
// Updates the registry with the OEM and Product info from SHELL32.DLL.
// Called at init time. hKeyTermSrv is an open reg handle to
// HKLM\Sys\CCS\Ctrl\TS TermSrv key. Returns FALSE on error.
 ******************************************************************************/
BOOL UpdateOemAndProductInfo(HKEY hKeyTermSrv)
{
    ULONG   i;
    PWCHAR  pInfo = NULL;
    DWORD   dwSize;
    PCHAR   pBuffer;
    DWORD   dwBytes;
    PUSHORT pTransL;
    PUSHORT pTransH;
    WCHAR   pString[255];
    PWCHAR  pKey;
    BOOL    bRc = TRUE;
    NTSTATUS Status;

    ASSERT(hKeyTermSrv != NULL);

    // Get the VersionInfo data: Determine size, alloc memory, then get it.
    dwSize = GetFileVersionInfoSize(OEM_AND_PRODUCT_INFO_DLL, 0);
    if (dwSize != 0) {
        pInfo = MemAlloc(dwSize);
        if (pInfo != NULL) {
            bRc = GetFileVersionInfo(OEM_AND_PRODUCT_INFO_DLL, 0, dwSize,
                    pInfo);
            if (!bRc)
                goto done;
        }
        else {
            bRc = FALSE;
            goto done;
        }
    }
    else {
        bRc = FALSE;
        goto done;
    }

    /*
     *  Get the translation information
     */
    if (!VerQueryValue(pInfo, L"\\VarFileInfo\\Translation", &pBuffer, &dwBytes)) {
        bRc = FALSE;
        goto done;
    }

    /*
     *  Get the language and character set
     */
    pTransL = (PUSHORT)pBuffer;
    pTransH = (PUSHORT)(pBuffer + 2);

    /*
     *  Pull out the individual fields
     */
    i = 0;
    while ((pKey = pProductOemInfo[i++]) != NULL) {
        /*
         *  Generate StringFileInfo entry
         */
        wsprintf(pString, L"\\StringFileInfo\\%04X%04X\\%s", *pTransL,
                *pTransH, pKey);

        /*
         *  Pull entry
         */
        if (!VerQueryValue( pInfo, pString, &pBuffer, &dwBytes ) ) {
            bRc = FALSE;
            goto done;
        }

        /*
         *  Write key value
         */
        RegSetValueEx(hKeyTermSrv, pKey, 0, REG_SZ, pBuffer, dwBytes * 2);
    }

done:
    /*
     *  Free memory
     */
    if (pInfo != NULL)
        MemFree(pInfo);

    return bRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\timer.c ===
/*************************************************************************
*
* timer.c
*
* Common timer routines
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   Local structures
=============================================================================*/

typedef VOID (*PCLIBTIMERFUNC)(PVOID);
typedef NTSTATUS (*PCREATETHREAD)( PUSER_THREAD_START_ROUTINE, PVOID, BOOLEAN, PHANDLE );

/*
 *  Timer thread structure
 */
typedef struct _CLIBTIMERTHREAD {
    HANDLE hTimerThread;
    HANDLE hTimer;
    LIST_ENTRY TimerHead;
} CLIBTIMERTHREAD, * PCLIBTIMERTHREAD;

/*
 *  Timer structures
 */
typedef struct _CLIBTIMER {
    PCLIBTIMERTHREAD pThread;
    LIST_ENTRY Links;
    LARGE_INTEGER ExpireTime;
    PCLIBTIMERFUNC pFunc;
    PVOID pParam;
    ULONG Flags;
} CLIBTIMER, * PCLIBTIMER;

#define TIMER_ENABLED 0x00000001


/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS IcaTimerCreate( ULONG, HANDLE * );
NTSTATUS IcaTimerStart( HANDLE, PVOID, PVOID, ULONG );
BOOLEAN IcaTimerCancel( HANDLE );
BOOLEAN IcaTimerClose( HANDLE );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _TimersInit( PCLIBTIMERTHREAD );
NTSTATUS _TimerSet( PCLIBTIMERTHREAD );
BOOLEAN _TimerRemove( PCLIBTIMERTHREAD, PCLIBTIMER, BOOLEAN );
DWORD _TimerThread( PCLIBTIMERTHREAD );


/*=============================================================================
==   Global data
=============================================================================*/

CLIBTIMERTHREAD ThreadData[ 3 ];


/*******************************************************************************
 *
 *  _TimersInit
 *
 *  Initialize timers for process
 *
 *  NOTE: timer semaphore must be locked
 *
 *
 *  ENTRY:
 *    pThread (input)
 *        pointer to timer thread structure
 *
 *  EXIT:
 *     NO_ERROR : successful
 *
 ******************************************************************************/

NTSTATUS
_TimersInit( PCLIBTIMERTHREAD pThread )
{
    ULONG Tid;
    NTSTATUS Status;

    /*
     *  Check if someone beat us here
     */
    if ( pThread->hTimerThread )
        return( STATUS_SUCCESS );

    /*
     *  Initialize timer variables
     */
    InitializeListHead( &pThread->TimerHead );
    pThread->hTimerThread = NULL;
    pThread->hTimer = NULL;

    /*
     *  Create timer object
     */
    Status = NtCreateTimer( &pThread->hTimer, TIMER_ALL_ACCESS, NULL, NotificationTimer );
    if ( !NT_SUCCESS(Status) )
        goto badtimer;

    pThread->hTimerThread = CreateThread( NULL,
                                          0,
                                          _TimerThread,
                                          pThread,
                                          THREAD_SET_INFORMATION,
                                          &Tid );

    if ( !pThread->hTimerThread ) {
        Status = NtCurrentTeb()->LastStatusValue;
        goto badthread;
    }

    SetThreadPriority( pThread->hTimerThread, THREAD_PRIORITY_TIME_CRITICAL-2 );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  bad thread create
     */
badthread:
    NtClose( pThread->hTimer );

    /*
     *  bad timer object
     */
badtimer:
    pThread->hTimerThread = NULL;
    ASSERT( Status == STATUS_SUCCESS );
    return( Status );
}


/*******************************************************************************
 *
 *  IcaTimerCreate
 *
 *  Create a timer
 *
 *
 *  ENTRY:
 *     TimerThread (input)
 *         index of time thread (TIMERTHREAD_?)   clib.h
 *     phTimer (output)
 *         address to return timer handle
 *
 *  EXIT:
 *    STATUS_SUCCESS - no error
 *
 *
 ******************************************************************************/

NTSTATUS
IcaTimerCreate( ULONG TimerThread, HANDLE * phTimer )
{
    PCLIBTIMER pTimer;
    NTSTATUS Status;
    PCLIBTIMERTHREAD pThread;

    if ( TimerThread >= 3 )
        return( STATUS_INVALID_PARAMETER );

    /*
     *  Lock timer semaphore
     */
    RtlEnterCriticalSection( &TimerCritSec );

    /*
     *  Get pointer to thread structure
     */
    pThread = &ThreadData[ TimerThread ];

    /*
     *  Make sure timers are initialized
     */
    if ( pThread->hTimerThread == NULL ) {
        Status = _TimersInit( pThread );
        if ( !NT_SUCCESS(Status) )
            goto badinit;
    }

    /*
     *  Unlock timer semaphore
     */
    RtlLeaveCriticalSection( &TimerCritSec );

    /*
     *  Allocate timer event
     */
    pTimer = MemAlloc( sizeof(CLIBTIMER) );
    if ( !pTimer ) {
        Status = STATUS_NO_MEMORY;
        goto badmalloc;
    }

    /*
     *  Initialize timer event
     */
    RtlZeroMemory( pTimer, sizeof(CLIBTIMER) );
    pTimer->pThread = pThread;

    *phTimer = (HANDLE) pTimer;
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  timer create failed
     *  timer initialization failed
     */

// badmalloc:
badinit:
    RtlLeaveCriticalSection( &TimerCritSec );
badmalloc: /* makarp; dont LeaveCritical Section in case of bad malloc as we have done it already. #182846*/
    *phTimer = NULL;
    return( Status );
}


/*******************************************************************************
 *
 *  IcaTimerStart
 *
 *  Start a timer
 *
 *
 *  ENTRY:
 *     TimerHandle (input)
 *        timer handle
 *     pFunc (input)
 *        address of procedure to call when timer expires
 *     pParam (input)
 *        parameter to pass to procedure
 *     TimeLeft (input)
 *        relative time until timer expires (1/1000 seconds)
 *
 *  EXIT:
 *     NO_ERROR : successful
 *
 *
 ******************************************************************************/

NTSTATUS
IcaTimerStart( HANDLE TimerHandle,
            PVOID pFunc,
            PVOID pParam,
            ULONG TimeLeft )
{
    PCLIBTIMER pTimer;
    PCLIBTIMER pNextTimer;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER Time;
    PLIST_ENTRY Head, Next;
    BOOLEAN fSetTimer = FALSE;
    NTSTATUS Status;
    PCLIBTIMERTHREAD pThread;


    /*
     *  Lock timer semaphore
     */
    RtlEnterCriticalSection( &TimerCritSec );

    /*
     *  Get timer pointer
     */
    pTimer = (PCLIBTIMER) TimerHandle;
    pThread = pTimer->pThread;

    /*
     *  Remove timer if it is enabled
     *  (If the timer was the head entry, then fSetTimer
     *   will be TRUE and _TimerSet will be called below.)
     */
    if ( (pTimer->Flags & TIMER_ENABLED) )
        fSetTimer = _TimerRemove( pThread, pTimer, FALSE );

    /*
     *  Initialize timer event
     */
    Time = RtlEnlargedUnsignedMultiply( TimeLeft, 10000 );
    (VOID) NtQuerySystemTime( &CurrentTime );
    pTimer->ExpireTime = RtlLargeIntegerAdd( CurrentTime, Time );
    pTimer->pFunc      = pFunc;
    pTimer->pParam     = pParam;

    /*
     *  Locate correct spot in linked list to insert this entry
     */
    Head = &pThread->TimerHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pNextTimer = CONTAINING_RECORD( Next, CLIBTIMER, Links );
        if ( RtlLargeIntegerLessThan( pTimer->ExpireTime,
                                      pNextTimer->ExpireTime ) )
            break;
    }

    /*
     *  Insert timer event into timer list.
     *  (InsertTailList inserts 'pTimer' entry in front of 'Next' entry.
     *   If 'Next' points to TimerHead, either because the list is empty,
     *   or because we search